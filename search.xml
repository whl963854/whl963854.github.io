<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go泛型运用</title>
      <link href="/p/f0317f09.html"/>
      <url>/p/f0317f09.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go泛型运用"><a href="#Go泛型运用" class="headerlink" title="Go泛型运用"></a>Go泛型运用</h1><h2 id="泛型起源"><a href="#泛型起源" class="headerlink" title="泛型起源"></a>泛型起源</h2><p>泛型编程是一种计算机编程风格，程序逻辑是根据参数指定的类型编写的，然后在调用时为作为参数提供的特定类型实例化。这种方法由1973年的ML编程语言开创，允许编写通用函数或类型，从而减少了代码重复。</p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>简而言之，类型做为参数。在Go语言语言中就是， 函数中携带泛型类型参数，接口&#x2F;结构体 支持泛型类型参数声明。</p><pre><code>func Add(a int, b int) int &#123;    return a + b&#125;func AddInt64(a int64, b int64) int64 &#123;    return a + b&#125;func Add[T int | int32 | int64 | float32 | float64](a T, b T) T &#123;    return a + b&#125;</code></pre><p>让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 泛型编程。</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>泛型能实现的功能通过接口+反射也基本能实现。但是使用过反射的人都知道反射机制有很多问题：</p><ol><li>用起来麻烦</li><li>失去了编译时的类型检查，不仔细写容易出错</li><li>性能不太理想</li></ol><h2 id="主流的泛型介绍"><a href="#主流的泛型介绍" class="headerlink" title="主流的泛型介绍"></a>主流的泛型介绍</h2><table><thead><tr><th>类型</th><th>实现原理</th><th>优点</th></tr></thead><tbody><tr><td>模板泛型</td><td>将代码中使用的每个类型编译成对应的类型的代码。</td><td>代码运行效率最高。</td></tr><tr><td>运行时泛型</td><td>编译时用占位符代替泛型参数，运行时由JIT编译成实际的类型。</td><td>编译时代码不膨胀，编译速度不受影响，经过JIT优化后性能几乎不受影响。</td></tr><tr><td>擦除泛型</td><td>编译时将类型擦除，统一转换为object或约束类。</td><td>实现简单。</td></tr><tr><td>动态语言泛型</td><td>依托编译器语法转换进行类型检查。</td><td>灵活，但具体性能和类型安全性取决于编译器。</td></tr></tbody></table><p>C#实现原理查看链接：SharpLab<br>JAVA实现原理链接：java泛型字节码</p><h2 id="Go泛型实现原理"><a href="#Go泛型实现原理" class="headerlink" title="Go泛型实现原理"></a>Go泛型实现原理</h2><p>go是基于模板的方案来实现泛型并做了改善</p><ol><li>为基础类型单独生成一份模板代码</li><li>非基础类型统一生成一个虚拟方法表，在运行时调用的时候通过虚拟方法表找到实际的类型</li></ol><h3 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h3><p>• 函数名后可以附带一个方括号，包含了该函数涉及的类型参数（Type Paramters）的列表：func F[T any](p T) { … }<br>• 这些类型参数可以在函数参数和函数体中（作为类型）被使用<br>• 自定义类型也可以有类型参数列表：type M[T any] []T<br>• 每个类型参数对应一个类型约束，上述的 any 就是预定义的匹配任意类型的约束<br>• 类型约束在语法上以 interface 的形式存在，在 interface 中嵌入类型 T 可以表示这个类型必须是 T:<br>• any\comparable\Ordered 约束类型</p><pre><code>type Integer interface &#123;    int ｜ int8 | int16 | int32 | int64&#125;type Integer1 interface &#123;    ~int ｜ ~int8&#125;</code></pre><h3 id="泛型反射"><a href="#泛型反射" class="headerlink" title="泛型反射"></a>泛型反射</h3><p>Go 1.18 版本并没有增加泛型相关的反射API，并且泛型是在编译期生成故推测Go不支持在运行时调用泛型方法&#x2F;函数. 这也是为什么Go方法不支持泛型原因之一</p><pre><code>func Test_Reflect3(t *testing.T) &#123;    myType := &amp;MyType[string]&#123;&quot;asd&quot;&#125;    mtV := reflect.ValueOf(&amp;myType).Elem()    params := make([]reflect.Value, 0)    params = append(params, reflect.ValueOf(&quot;OOOOOO&quot;))    mtV.MethodByName(&quot;Hello&quot;).Call(params)&#125;type MyType[T any] struct &#123;    name T&#125;func (mt *MyType[T]) Hello(show string) &#123;    println(mt.name, show)&#125;</code></pre><p>java 类型擦除式泛型，所以在运行是可通过反射插入不同类型的数据到泛型集合中</p><pre><code>List&lt;String&gt; strList=new ArrayList&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.add(&quot;sdadas&quot;);//但是通过反射方案可以实现插入数字    strList.add(123)</code></pre><p>C#是运行时泛型，所以反射时仍然可以做到类型检查</p><pre><code>var strList=new List&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.Add(&quot;sdadas&quot;);//反射插入数字时会报运行时错误    strList.add(123)//error</code></pre><h2 id="泛型运用"><a href="#泛型运用" class="headerlink" title="泛型运用"></a>泛型运用</h2><p>三元表达式</p><pre><code>func If[T any](flag bool, f1, f2 T) T &#123;    if flag &#123;        return f1    &#125;    return f2&#125;func IfFunc[T any](flag bool, f1, f2 func() T) T &#123;    if flag &#123;        return f1()    &#125;    return f2()&#125;//调用If(len(arr)&gt;0,arr[0],0)IfFunc(len(arr) &gt; 0 ,func()int64&#123;return arr[0]&#125;,0)</code></pre><p>泛型类型转换</p><pre><code>func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;//调用a := ToNumber[int](&quot;123&quot;)b := ToNumber[int64](&quot;123&quot;)c := ToNumber[float64](&quot;123&quot;)d := ToNumber[int32](&quot;123&quot;)</code></pre><p>linq 集合操作</p><pre><code>type Student struct &#123;    Id     int    Name   string    Age    int    Sex    bool    Score  int&#125;var list = []*Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;  </code></pre><p>a. 集合过滤</p><pre><code>//返回年龄大于19岁的学生res := linq.Where(list, func(s *Student) bool &#123; return s.Age &gt; 19 &#125;)    // Id: 3, Name: &quot;王五&quot;        </code></pre><p>b. 取第一个或者最后一个</p><pre><code>b := linq.First(list) //输出 1// 获取指定条件的第一个b = linq.First(list, func(s *Student) bool &#123; return s.Sex &#125;) //输出 1b = linq.Last(list) //输出 7 // 获取指定条件的最后一个b = linq.Last(list, func(s *Student) bool &#123; return s.Sex &#125;)</code></pre><p>   &#x2F;&#x2F;输出 3    </p><p> c. 去重</p><pre><code>//引用类型需要指定 去重的Key值   c := linq.Distinct(list, func(s *Student) int &#123; return s.Id &#125;)fmt.Println(c) //输出 1，2，3，4，5，6，7 //值类型可直接调用var list1 = []Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;d := linq.DistinctComparable(list1)fmt.Println(d) //输出 1，2，3，4，5，6，7     </code></pre><p>d. 投影成新对象</p><pre><code>//将学生数组转换为名称数组e := linq.Select(list, func(s *Student) string &#123; return s.Name &#125;)// 输出 [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,...]    </code></pre><p>e. 取前几条数据</p><pre><code>//取前几条数据f := linq.Take(list,3)fmt.Println(f)   </code></pre><p>f. 判断 元素，集合，条件 是否存在&#x2F;满足</p><pre><code>//判断是否存在分数大于99分的同学linq.Any(list, func(s *Student) bool &#123; return s.Score &gt; 99 &#125;) // falsevar arr = []int&#123;1,2,3,4,4,5&#125;linq.AnyComparable(arr, 8)//falselinq.AnyComparable(arr, 8,12,1)//true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 60 &#125;) //true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 70 &#125;) //falselinq.AnyComparable(arr,1) //判断所有元素都为1    </code></pre><p>g. 求和&#x2F;最大值&#x2F;最小值</p><pre><code> //分数汇总linq.Sum(list, func(s *Student) int &#123; return s.Score &#125;) // 654linq.Max(list, func(s *Student) int &#123; return s.Score &#125;) // Id: 6, Name: &quot;王芊&quot;linq.Min(list, func(s *Student) int &#123; return s.Score &#125;) //Id: 4, Name: &quot;赵六&quot;var arr1 = []int&#123;1, 2, 3, 4, 4, 5&#125;linq.SumOrdered(arr1) // 19linq.MaxOrdered(arr1) // 5linq.MinOrdered(arr1) // 1    </code></pre><p>h. 按照条件分组</p><pre><code>m := linq.GroupBy(list, func(s *Student) int &#123; return s.Age &#125;)// 单词出现频率统计var words = &quot;how do you do&quot;//var s = words.Split(&#39; &#39;).GroupBy(x =&gt; x).ToDictionary(x =&gt; x.Key, x =&gt; x.Count());var s5 = linq.ToComparableMap(strings.Split(words, &quot; &quot;),func(key string, es []string) int &#123; return len(es) &#125;)fmt.Println(s5)</code></pre><p>i. 链式操作，如果有集合的组合操作需求，可以先将切片转换为链式操作对象</p><pre><code>s1 := linq.AsEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort(func(s1, s2 string) bool &#123; return s1 &lt; s2 &#125;).    ToSlice()fmt.Println(s1)s2 := linq.AsComparableEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Distinct().    Take(3).    ToSlice()fmt.Println(s2)s3 := linq.AsOrderEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort().    Distinct().    Take(3).    ToSlice()fmt.Println(s3)s5 := linq.AsSelectEnumerable([]int&#123;1, 2, 3, 4, 5&#125;).    Where(func(v int) bool &#123; return v &gt; 3 &#125;).    Select(func(v int) string &#123; return &quot;mapping_&quot; + strconv.Itoa(v) &#125;).    Take(2).    ToSlice&lt;&gt;()fmt.Println(s5)</code></pre><p>实现泛型Set，泛型 LRU,泛型orm,泛型Redis返回</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>方法不支持泛型</p><pre><code>type A[T any] struct &#123;&#125;//编译通过func (a A[T]) SelectString() string &#123;    return &quot;&quot;&#125;//编译不通过func (a A[T]) Select2[E any]() E &#123;    retrun nil&#125;type Foo struct &#123;&#125;​//编译不通过func (Foo) bar[T any](t T) &#123;&#125;</code></pre><p>Go没有提供在编译期操作类型的能力,只能在运行时操作</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;</code></pre><p>类型转换，不支持转换为带类型约束的interface</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;        K, _ := v.(int)  //编译通过    g, _ := v.(Number) //编译不通过</code></pre><p>更加智能类型推导，函数lamda化</p><pre><code>f(x) = ax + by = f(x)joinCorpIds := linq.Select(newUserInfos, func(s *wps.NewUserInfo) int64 &#123; return s.CompanyId &#125;)joinCorpIds := linq.Select(newUserInfos, s = &gt; s.CompanyId)joinCorpIds = newUserInfos.Select(s = &gt; s.CompanyId)</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/p/f255ffad.html"/>
      <url>/p/f255ffad.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>• docker是什么<br>docker是用GO开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。<br>Docker 容器是</p><ul><li>利用Linux Namespace做资源隔离，</li><li>Cgroup做资源上限限制，</li><li>rootfs做文件系统 </li><li>运行在宿主机上面的一个特殊进程。</li></ul><p>• 为什么使用docker<br>利用docker可以将项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在宿主机创建一个容器，让镜像在容器内运行，从而实现项目的部署。<br>项目可以是mysql、nginx、nodejs、redis等，从而可以在一台宿主机上快速搭建相互隔离的不同的环境。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>镜像（image)、容器(container)、仓库（repository)<br>举个例子，电脑安装操作系统，称其为镜像，镜像是一个固定的文件，这次读盘和下次读盘内容是一样的。<br>把这个镜像安装到电脑上，再在这个电脑上删删改改，再重新打包一个镜像刻盘，固化出一个镜像来，这就是镜像打包，<br>如国内以前泛滥的盗版XP系统，从微软官方镜像出发，添加小工具，系统设置修改优化，加主题，造出番茄花园，雨林木风，深度之类的盗版安装碟。<br>镜像装到电脑后，这个电脑就是个容器，里面包含使用者的数据和设置。</p><p>• 镜像<br>镜像可以看成是由多个镜像层叠加起来的一个文件系统；<br>镜像层的主要组成部分包括镜像层 ID、镜像层指针 「指向父层」、元数据；<br>镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层。统一文件系统（ AUFS）能够将不同的层整合成一个文件系统。</p><p>• 容器<br>容器的定义和镜像几乎一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br>要点：容器 &#x3D; 镜像 + 读写层</p><p>• 仓库<br>顾名思义，docker仓库是用来存储镜像的，理解时，可以参考git仓库。</p><p>Docker环境安装，以安装docker-ce为例</p><ol><li>Linux安装<br>1）下载阿里的源<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br>sudo yum makecache<br>sudo yum install docker-ce2）docker启动<br>systemctl start docker.service</li><li>Windows安装<br><a href="https://www.runoob.com/docker/windows-docker-install.html">https://www.runoob.com/docker/windows-docker-install.html</a><br>下载Docker Desktop<br>启用Hyper-V(win10)<br>安装Docker Desttop</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>搜索镜像</li></ol><p>docker search xxx</p><ol><li>拉取镜像</li></ol><p>docker pull xxx</p><ol start="3"><li>查看镜像</li></ol><p>docker images</p><ol start="4"><li>运行镜像</li></ol><p>docker run<br>    -p 暴露端口:容器端口         #端口<br>    -v 本地路径:容器内路径       #挂在本地路径<br>    -e 环境变量&#x3D;value           #指定环境变量<br>    –add-host 域名:IP        # 绑定域名    -p 暴露端口：容器端口<br>    -v 本地路径：容器内路径<br>    -e 环境变量&#x3D;value</p><ol start="5"><li><p>查看运行中的容器</p><p> docker ps</p></li><li><p>容器启动、停止、重启</p><p> docker container start | stop | restart [containername]</p></li></ol><h2 id="启动一个nginx服务器"><a href="#启动一个nginx服务器" class="headerlink" title="启动一个nginx服务器"></a>启动一个nginx服务器</h2><pre><code># 检索nginx镜像docker search nginx --limit 5# 拉取镜像docker pull nginx:stable#采用默认配置启动一个服务器docker run -p 9080:80 --name my-nginx nginx:stable#采用自定义配置，并挂载外部目录docker run -d -p 9081:81 -v /home/luanhongjun/temp1/demo/nginx/conf.d:/etc/nginx/conf.d -v /home/luanhongjun/temp1/demo/nginx/html:/usr/share/nginx/html --name my-nginx nginx:stable</code></pre><h2 id="自定义打包镜像"><a href="#自定义打包镜像" class="headerlink" title="自定义打包镜像"></a>自定义打包镜像</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code>FROM khub.wps.cn/sreopen/node:14.2.0ADD ./ /opt/zhiliaoWORKDIR /opt/zhiliaoRUN npm installRUN npm run build:pcRUN npm run build:mobileFROM khub.wps.cn/sreopen/nginx:1.18.0COPY --from=0 /opt/zhiliao/dist/ /var/www/zhiliao/COPY --from=0 /opt/zhiliao/m-dist/ /var/www/m-zhiliao/COPY --from=0 /opt/zhiliao/nginx/nginx.conf /etc/nginx/RUN nginxCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><p>FROM：指定基础镜像<br>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。<br>WORKDIR： 指定工作目录<br>RUN：构建镜像时运行的命令<br>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源<br>CMD：构建容器后调用，也就是在容器启动时才进行调用。</p><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p><h3 id="Docker镜像瘦身技巧："><a href="#Docker镜像瘦身技巧：" class="headerlink" title="Docker镜像瘦身技巧："></a>Docker镜像瘦身技巧：</h3><p>善用 &amp;&amp;<br>优化前</p><pre><code>RUN npm installRUN npm run build:pcRUN npm run build:mobile</code></pre><p>优化后</p><pre><code>RUN /bin/bash -c &#39;npm install &amp;&amp; npm run build:pc &amp;&amp; npm run build:mobile&#39;</code></pre><p>使用多阶段构建</p><p>选择Alpine&#x2F;Distroless基础镜像<br>Alpine Linux是一个基于musl libc和busybox、面向安全的轻量级Linux发行版。它更小、更安全。</p><pre><code>FROM khub.wps.cn/zl-open/golang-base:1.14.2 AS build-linkADD wps-zhiliao-backend-mics-known-link /opt/kingsoft/src/wps.cn/drive/linkADD wps-zhiliao-backend-mics-known-lib /opt/kingsoft/src/wps.cn/drive/libADD wps-zhiliao-backend-lib /opt/kingsoft/src/wps.cn/libADD kgo-kms /opt/kingsoft/src/ksogit.kingsoft.net/kgo/kmsADD openksa-cksdk  /opt/kingsoft/src/wps.cn/cksdkADD kgo-i18n /opt/kingsoft/src/wps.cn/drive/i18nWORKDIR /opt/kingsoft/src/wps.cn/drive/linkENV GOPATH=/opt/kingsoft/:/opt/kingsoft/src/wps.cn/lib/Godeps/_workspaceENV CGO_ENABLED=0RUN go build -v -o /opt/kingsoft/src/wps.cn/drive/link/bin/main /opt/kingsoft/src/wps.cn/drive/link/main.goFROM khub.wps.cn/sreopen/sre-base:pyjinja-supervisor-alpine AS run-linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/bin/main /usr/local/bin/linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/i18n /opt/apps/link/i18n/COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/etc/link.kae.toml.j2 /etc/link.kae.toml.j2COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/kae_start.sh /usr/local/bin/kae_start.sh#EXPOSE 8080RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39; /etc/apk/repositories \    &amp;&amp; apk add --no-cache tzdata \    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \    &amp;&amp; chmod +x /usr/local/bin/kae_start.shCMD [&quot;kae_start.sh&quot;]</code></pre><p>打包</p><p>docker build . -t xxx:yy</p><h2 id="docker-compose的使用"><a href="#docker-compose的使用" class="headerlink" title="docker-compose的使用"></a>docker-compose的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。<br>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。<br>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）<br>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>方式一：下载适应版本的compose</p><pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose</code></pre><p>方式二：</p><pre><code>安装python-pippip install docker-compose</code></pre><h3 id="docker-compose-yml简介"><a href="#docker-compose-yml简介" class="headerlink" title="docker-compose.yml简介"></a>docker-compose.yml简介</h3><p>标准配置文件应该包含version、services、networks三部分:<br>version:  定义了版本信息<br>services: 定义了服务的配置信息，包含应用于该服务启动的每个容器的配置<br>networks: 定义了网络信息，提供给 services 中的 具体容器使用</p><p>实例</p><pre><code>version: &#39;3.2&#39;services:#Nginxnginx_lb:    restart: always    image: nginx:1.11.6-alpine    ports:    - 28080:80    - 80:80    - 443:443    volumes:    - /opt/kingsoft/containers/nginx/conf.d:/etc/nginx/conf.d    - /opt/kingsoft/containers/nginx/log:/var/log/nginx    - /opt/kingsoft/containers/nginx/www:/var/www    - /opt/kingsoft/containers/nginx/zhiliao-management-system:/var/zhiliao-management-system    - /opt/kingsoft/containers/nginx/ssl:/etc/nginx/ssl    extra_hosts:    - &quot;msgcenter.wps.cn:120.92.124.158&quot;    stdin_open: true    tty: true# Redis cluster#redis_db:#  image: grokzen/redis-cluster:5.0.12#  environment:#    TZ: &quot;Asia/Shanghai&quot;#  volumes:#    - /opt/kingsoft:/opt/kingsoft#  # docker network bridge mode#  networks:#      vpcbr:#      ipv4_address: 172.16.0.50#  ports:#    - &quot;7000:7000&quot;  # MySQL DBmysql_db:    image: percona:5.6    environment:    MYSQL_ROOT_PASSWORD: xxxx    TZ: &quot;Asia/Shanghai&quot;    volumes:    - /opt/kingsoft/containers/mysql/conf:/etc/mysql/conf.d    - /opt/kingsoft/containers/mysql/data:/var/lib/mysql    - /opt/kingsoft:/opt/kingsoft    ports:    - &quot;3306:3306&quot;    networks:    vpcbr:        ipv4_address: 172.16.0.51zoo1:    image: wurstmeister/zookeeper    ports:    - &quot;2181:2181&quot;    networks:    vpcbr:        ipv4_address: 172.16.0.56# kafka version: 1.1.0# scala version: 2.12kafka:    image: wurstmeister/kafka    ports:    - &quot;9092:9092&quot;    environment:    KAFKA_ADVERTISED_HOST_NAME: kafka    KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181&quot;    KAFKA_BROKER_ID: 1    KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1    KAFKA_CREATE_TOPICS: &quot;drive_fsys_fop:1:1&quot;    depends_on:    - zoo1    networks:    vpcbr:        ipv4_address: 172.16.0.57networks:vpcbr:    driver: bridge    ipam:    config:    - subnet: 172.16.0.0/16                                        </code></pre><h3 id="结合KAE使用"><a href="#结合KAE使用" class="headerlink" title="结合KAE使用"></a>结合KAE使用</h3><pre><code>绑定120.92.124.158 khub.wps.cndocker tag xximage:xxtagdocker login khub.wps.cndocker push khub.wps.cn/zl-open/golang-base:1.14.2</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>如何从一个容器做一个镜像</p><p> docker commit命令创建镜像<br> docker commit xxxcontaineridd imagename:tag</p></li><li><p>docker logs 能否输出nginx的access.log</p></li></ol><p>docker logs xxx 只能输出容器内程序输出到终端（stdout|stderr）的日志。无法输出写入到文件中的日志。所以不能直接输出nginx的access.log<br>当然，如果使用一些hook程序，将access.log内的日志实时输出到终端，可以通过docker logs看到。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mod</title>
      <link href="/p/17f45348.html"/>
      <url>/p/17f45348.html</url>
      
        <content type="html"><![CDATA[<h1 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h1><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>go 1.11 (2018-08-24)开始支持gomod的方式去管理包的依赖<br>具体的发行说明参考官方链接：<a href="https://go.dev/doc/go1.11">https://go.dev/doc/go1.11</a> [所有版本的发行说明：<a href="https://go.dev/doc/devel/release]">https://go.dev/doc/devel/release]</a></p><p>Q: GOPATH方式存在的问题？<br>A今天go get pkg1 commit了提交，第二天pkg1更新了，B去clone A的项目执行go get pkg1，此时pkg1变化了<br>同一个包，不同项目无法引用不同版本<br>vendor目录，git上传整份代码，git库体积过大，升级包时，文件太多，MR review不友好</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="GO111MODULE变量"><a href="#GO111MODULE变量" class="headerlink" title="GO111MODULE变量"></a>GO111MODULE变量</h3><p>go1.16 GO111MODULE默认值是on，并且增加了retract功能（版本撤回）</p><h2 id="go-mod常用操作命令"><a href="#go-mod常用操作命令" class="headerlink" title="go mod常用操作命令"></a>go mod常用操作命令</h2><p>用go mod初始化一个新项目</p><pre><code>mkdir democd demogo mod init demogo: creating new go.mod: module demo</code></pre><p>添加一个依赖包</p><pre><code>// 根据commit id添加依赖包的方式go get github.com/golang/groupcache@41bb18b</code></pre><p>此时，go.mod里会记录好依赖包，和对应的版本名</p><p>go.mod里出现的关键字<br>• module - go mod init指令定义的库名<br>• go - 要求go语言的最低版本，会影响到后面依赖库的下载<br>• require - 必备库，也就是代码中直接import的部分<br>• indirect：间接依赖，即A -&gt; B -&gt; C时，A就是间接依赖C了<br>• replace - 替换库，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）<br>• retract 撤回版本，告诉调用本库的项目，部分版本有严重问题、不要引用</p><p>根据go.mod下载依赖包</p><pre><code>go mod download</code></pre><p>清理下载好的go pkg缓存</p><pre><code>go clean -modcache</code></pre><p>清理go.mod不在使用的依赖</p><pre><code>go mod tidy</code></pre><p>将gomod项目依赖包存放到vendor目录，以便在离线环境下使用GOPATH方式编译</p><pre><code>go mod vendor</code></pre><p>查看一个包是怎么被引用的</p><pre><code>go mod why $&#123;pkg&#125;</code></pre><p>替换一个包</p><pre><code>go mod edit -replace wps.cn/lib=ksogit.kingsoft.net/wps-zhiliao/backend/lib.git@v0.0.2-prep</code></pre><h2 id="go-mod版本格式"><a href="#go-mod版本格式" class="headerlink" title="go mod版本格式"></a>go mod版本格式</h2><p><a href="https://go.dev/doc/modules/version-numbers">https://go.dev/doc/modules/version-numbers</a><br><a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>  译文</p><p>格式：</p><ul><li><p>第一种：v${大版本}.${功能版本}.${fix版本}。例如：v1.0.0</p></li><li><p>第二种：v${大版本}.${功能版本}.${fix版本}-${预发行版本}。例如：v1.0.0-rc.1，v1.0.0-pre，v8.0.0-alpha.0，v1.0.0-分支名.${整型序号}【目前采用】</p></li><li><p>第三种：v0.0.0-yyyyMMddHHmmss-${commitId}<br>然后我们要给对应的稳定代码版本打上tag，项目go get时，可以指定对应的版本。同时打tag的好处可以针对引用库的改动做发行说明，留底方便作兼容性记录，为后续问题排查提供依据。<br>大版本号可以用来做重构以确保一个项目里，可以同时存在v1,v2这种情况的引用链。</p><p>  main<br>  pkgA<br>  pkgX@v1<br>  pkgB<br>  pkgX@v2</p></li></ul><p>这样保证了，pkgA,pkgB可以同时存在，pkgX做了大版本升级，可能有功能是废弃的</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>goroutine</title>
      <link href="/p/15a4d7c.html"/>
      <url>/p/15a4d7c.html</url>
      
        <content type="html"><![CDATA[<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="goroutine是什么？"><a href="#goroutine是什么？" class="headerlink" title="goroutine是什么？"></a>goroutine是什么？</h2><p>官方的给出的定义是一个并发逻辑块，我们可以用一个函数和一个关键字创建它。</p><pre><code>// 非匿名func main() &#123;    go sayHello()    // continue doing other things&#125;func sayHello() &#123;    fmt.Println(&quot;hello&quot;)&#125;// 匿名go func() &#123;    fmt.Println(&quot;hello&quot;)&#125;()// 1// continue doing other things</code></pre><p>从go的整体运行框架中可以看出goroutine并不属于一个操作系统线程，也不属于go语言运行时管理的线程，它在go语言执行框架之内是线程的高级抽象——协程。<br>协程是非抢占式的并发子程序，换句话说，无法被中断。<br>协程拥有自身的资源同时共享线程的资源。<br>协程自身无法独立运行必须依托于线程。</p><p>go通过一个M:N调度器实现运行，也就是go的一个核心思想线程复用。</p><h2 id="goroutine的闭包"><a href="#goroutine的闭包" class="headerlink" title="goroutine的闭包"></a>goroutine的闭包</h2><p>一般会在main函数中暂停几秒来使得goroutine得以运行。</p><pre><code>sayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;go sayHello()time.Sleep(time.Second)</code></pre><p>这是因为goroutine是独立于main的一个协程，而goroutine的运行管理是交给go的runtime来负责的，我们无法得知goroutine何时会运行，通过暂停几秒钟本质是并不是给与goroutine启动的时间，而是提高runtime调用goroutine的机会，这种方式并不能保证goroutine一定会启动。<br>如果想要确保goroutine一定会启动，需要在main和goroutine之间建立一种同步机制，保证在main的执行过程中一定会等待goroutine的调用完成。</p><pre><code>var wg sync.WaitGroupsayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;wg.Add(1)go sayHello()wg.Wait() //1</code></pre><p>goroutine拥有独立的资源空间，来满足其运行时需要的全部条件，也正是利用了这种机制go才可以实现线程这种珍贵资源的复用，但是在某些情况下，我们需要在一个goroutine调用另一个goroutine的资源，而goroutine之间都是独立运行的，如何确保资源的安全性。</p><pre><code>var wg sync.WaitGroupsalutation := &quot;hello&quot;wg.Add(1)go func() &#123;    defer wg.Done()    salutation = &quot;welcome&quot; // 1&#125;()wg.Wait()fmt.Println(salutation)</code></pre><p>上面的例子在实际的运行过程中不会出现hello被打印的情况，原因在于goroutine对main的资源进行了访问并修改。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func() &#123;        defer wg.Done()        fmt.Println(salutation) // 1    &#125;()&#125;wg.Wait()</code></pre><p>这种情况下goroutine会输出什么？<br>答案是3个good day。很奇怪不是吗？</p><p>是什么原因导致这个奇怪的现象出现？<br>我们回顾goroutine的定义，一个并发逻辑块，我们并不知道它会何时运行，在上面的例子中我们通过同步机制，确保了在main运行的期间goroutine一定会启动运行，但是仍然无法确保goroutine何时运行。<br>那么问题就迎刃而解了，for循环的执行在goroutine运行之前执行完，go为通过代码检查将salutation转移到堆中，并保存对字符串切片“good day”中最后一个值的引用。</p><p>通过上面的两个例子可以看出，因为goroutine具有独立逻辑，当一个goroutine访问另一个goroutine的资源时，是极度不安全的，资源不确定性无限放大。</p><p>如何正确的访问goroutine资源呢，确保安全性？<br>答案很简单：闭包。<br>闭包这个词用人话说就是将资源复制一份给goroutine，使得goroutine不用访问另一个goroutine的资源，实现资源的封闭。<br>再通俗一点就是，给你一份，你用你的，我用我的。<br>在程序的执行方式就是传递参数。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func(salutation string) &#123; // 1        defer wg.Done()        fmt.Println(salutation)    &#125;(salutation) // 2&#125;wg.Wait()</code></pre><p>不过需要注意go的传递是值传递，并且包含指针，闭包的概念对于指针类型的对象来说没用。</p><h2 id="goroutine的大小"><a href="#goroutine的大小" class="headerlink" title="goroutine的大小"></a>goroutine的大小</h2><p>goroutine在官方中还有一个一直被人津津乐道的一个地方，轻巧，占用空间很小，大约几KB</p><pre><code>memConsumed := func() uint64 &#123;    runtime.GC()    var s runtime.MemStats    runtime.ReadMemStats(&amp;s)    return s.Sys&#125;var c &lt;-chan interface&#123;&#125;var wg sync.WaitGroupnoop := func() &#123; wg.Done(); &lt;-c &#125; // 1const numGoroutines = 1e4 // 2wg.Add(numGoroutines)before := memConsumed() // 3for i := numGoroutines; i &gt; 0; i-- &#123;    go noop()&#125;wg.Wait()after := memConsumed() // 4fmt.Printf(&quot;%.3fkb&quot;, float64(after-before)/numGoroutines/1000)</code></pre><p>9.291kb<br>PASS</p><p>测试一下上下文切换</p><p>func BenchmarkContextSwitch(b *testing.B) {<br>    var wg sync.WaitGroup<br>    begin :&#x3D; make(chan struct{})<br>    c :&#x3D; make(chan struct{})</p><pre><code>var token struct&#123;&#125;sender := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        c &lt;- token //2    &#125;&#125;receiver := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        &lt;-c //3    &#125;&#125;wg.Add(2)go sender()go receiver()b.StartTimer() //4close(begin)   //5wg.Wait()</code></pre><p>}</p><p>结果如下：</p><pre><code>goos: windowsgoarch: amd64pkg: concurrency_mode/pipelinecpu: Intel(R) Core(TM) i5-10500 CPU @ 3.10GHzBenchmarkContextSwitch-12         4074472           293.5 ns/opPASS</code></pre><h2 id="goroutine的内存泄露"><a href="#goroutine的内存泄露" class="headerlink" title="goroutine的内存泄露"></a>goroutine的内存泄露</h2><p>goroutine虽然很牛逼，但是作为独立的线程如果不进行恰当的控制，会面对很严重泄露问题</p><p>goroutine的内存泄露一般由于程序不能正常结束所导致<br>• 死循环<br>• 阻塞等待</p><p>死循环</p><pre><code>go func() &#123;// &lt;操作会在这里永久阻塞&gt;    for&#123;    &#125;&#125;()// Do work</code></pre><p>破除死循环的最好方式就是告诉goroutine如何结束<br>• 定义退出逻辑<br>• 信号通知</p><p>阻塞等待<br>阻塞等待的情况有两种<br>go的经典语句“不要通过共享内存来通信，而应该通过通信来共享内存”<br>正因为如此<br>通道被广泛使用到各种场景，而通道阻塞是goroutine内存泄漏面临的一个大问题</p><p>通道分为进和出<br>当通道无法出时会进入阻塞状态，需要等待通道进数据</p><pre><code>doWork := func(strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123;    completed := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(completed)        for s := range strings &#123;            fmt.Println(s)        &#125;    &#125;()    return completed&#125;doWork(nil)// 这里还有其他任务执行fmt.Println(&quot;Done.&quot;)</code></pre><p>结果</p><pre><code>Done.PASS</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>doWork := func(done &lt;-chan interface&#123;&#125;, strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123; //1    terminated := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(terminated)        for &#123;            select &#123;            case s := &lt;-strings:                // Do something interesting                fmt.Println(s)            case &lt;-done: //2                return            &#125;        &#125;    &#125;()    return terminated&#125;done := make(chan interface&#123;&#125;)terminated := doWork(done, nil)go func() &#123; //3    // Cancel the operation after 1 second.    time.Sleep(1 * time.Second)    fmt.Println(&quot;Canceling doWork goroutine...&quot;)    close(done)&#125;()&lt;-terminated //4fmt.Println(&quot;Done.&quot;)</code></pre><p>结果如下：</p><pre><code>Canceling doWork goroutine...doWork exited.Done.PASS</code></pre><p>当通道无法进时会进入阻塞状态，需要等待通道出数据</p><pre><code>newRandStream := func() &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;) // 1        defer close(randStream)        for &#123;            randStream &lt;- rand.Int()        &#125;    &#125;()    return randStream&#125;randStream := newRandStream()fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;</code></pre><p>结果如下：</p><pre><code>3 random ints:1: 86597149668366241682: 35918201309525418263: 2839916754701944393</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>newRandStream := func(done &lt;-chan interface&#123;&#125;) &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;)        defer close(randStream)        for &#123;            select &#123;            case randStream &lt;- rand.Int():            case &lt;-done:                return            &#125;        &#125;    &#125;()    return randStream&#125;done := make(chan interface&#123;&#125;)randStream := newRandStream(done)fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;close(done)//模拟正在进行的工作time.Sleep(1 * time.Second)</code></pre><p>这样就可以了</p><pre><code>3 random ints:1: 83955671426514482052: 84217454730047417783: 7407000177342364812newRandStream closure exited.</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工作流</title>
      <link href="/p/7653a710.html"/>
      <url>/p/7653a710.html</url>
      
        <content type="html"><![CDATA[<h1 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h1><p>原文链接：<a href="https://juejin.cn/post/7202952940196708410">https://juejin.cn/post/7202952940196708410</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git 是目前最流行的代码管理工具，团队一般为了规范开发，保持良好的代码提交记录以及维护 Git 分支结构清晰，方便后续维护等，都会定制一套团队内部比较规范的 Git 工作流。本期主要介绍最为常见和流行的三种Git分支工作流。<br>Git工作流与我们常用的add、commit、push等命令有区别，但它们之间是相互关联的。Git工作流定义了一个开发过程的整体架构和规范，而add、commit、push等命令则是在具体操作层面上实现Git工作流的基本操作。在具体使用Git时，你可以根据所采用的工作流选择合适的命令和操作来管理代码版本和进行团队协作。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>GitFlow 是最早诞生，并且得到广泛应用的一种工作流程。GitFlow 通常包含五种类型的分支，分别为master、develop、feature、release、hotfix。<br>• master：主干分支，也是正式发布版本的分支，每次发布版本都需要打上相应的 tag，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许直接向 master 分支直接提交代码 (master 对应着生产环境)。<br>• develop：开发分支，在开发初期，由团队负责人从 master 签出，用来集成测试最新合入的开发成果，包含要发布到下一个 Release 的代码（对应开发环境）。<br>• feature：特性分支，通常从 Develop 分支签出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将 Feature 分支的代码合并至 Develop 分支，进入下一个Release 环节。<br>• release：预发布分支，发布新版本时，基于 Develop 分支创建，发布完成后，需要将此分支合并到 Master 和 Develop 分支（对应集成测试环境）。<br>• hotfix：热修复分支，生产环境发现新 Bug 时创建的临时分支，问题验证通过后，合并到 Master 和 Develop 分支。<br>develop分支包含项目完整的历史记录，而master分支将包含简化版本。团队成员在克隆中央存储库后，应基于develop创建跟踪分支，进行新功能开发。</p><p>GitFlow的优点和缺点？<br>• 优点：流程清晰可控。<br>• 缺点：管理相对复杂，需要同时维护两个长期分支。同时不适合持续发布，目标产物通常是一段时间后产出一个新版本，是基于版本发布。</p><h3 id="开发分支（Develop）"><a href="#开发分支（Develop）" class="headerlink" title="开发分支（Develop）"></a>开发分支（Develop）</h3><p>Develop 分支由团队负责人从 Master 创建。首次创建时，由团队负责人构建项目结构，推送至远端。通常在该分支上进行新特性的合并、签出予发布分支、合并hotfix分支等操作。</p><h3 id="特性分支（Feature）"><a href="#特性分支（Feature）" class="headerlink" title="特性分支（Feature）"></a>特性分支（Feature）</h3><p>新特性分支基于 Develop 分支创建，每个新功能都应该驻留在其自己的分支中，我们可以将其推送到中央存储库进行协作或者备份。<br>在新功能开发完成后，需要将其合并到 Develop 分支中，同时删除本地与远端的feature分支。<br>预发布分支（Release）<br>一旦 Develop 分支获得了足够的发布功能，或者临近预定的发布日期，就需要基于 Develop 分支创建</p><h3 id="Release-分支。"><a href="#Release-分支。" class="headerlink" title="Release 分支。"></a>Release 分支。</h3><p>创建此分支意味着将开始下一个发行周期，此刻 Release 分支不能添加任何新功能（除了错误修复、文档完善等），一旦准备发布，Release 分支将合并到 Master 分支并用版本号标记。另外，还要将其合并回 Develop 分支。待发版成功后，删除 Release 分支。<br>使用专门的分支进行版本发布可以让我们在新版本发布的同时，其他团队成员可以继续为下个版本开发新功能，而不影响此次发布。</p><h3 id="补丁分支（hotfix）"><a href="#补丁分支（hotfix）" class="headerlink" title="补丁分支（hotfix）"></a>补丁分支（hotfix）</h3><p>维护 hotfix 分支用于快速修补生产版本出现的 bug。hotfix 分支是唯一一个从 Master 分支上创建的分支。<br>待修复程序完成后，应该将其合并到 Master 和 Develop 或者当前 Release 分支中，随后删除 hotfix 分支，并应使用更新的版本号标记 Master 分支。<br>拥用有专门的错误修复分支，可以保障团队可以在不中断其余工作流程的情况下，对线上的版本进行错误修复。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>GitHub flow 是 Git Flow 的简化版，它是 github.com 使用的工作流程。它只有一个长期分支(master)，相对于 GitFlow 用起来相对比较简单。GitHubFlow 假设每次合并一个特性分支时都可以部署到生产环境，虽然这在某些情况下是不可能的。<br>它只有一个长期分支master：<br>• 第一步：根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。<br>• 第二步：新分支开发完成后，或者需要讨论的时候，就像 master 分支发起一个pull request(简称PR)。<br>• 第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码，对话过程中，你还可以不断提交代码。<br>• 第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。<br>GitHub Flow的优点和缺点？<br>• 优点：非常适合持续发布的产品，使用流程简单，仅有一个主干分支。Master 分支的最新代码，默认就是线上代码。<br>• 缺点：master 既包含生产环境，又包含开发环境，比较混乱。有些时候，代码合并进入 Master 分支，并不代表就能立刻发布，你不能控制发布的时间。例如，iOS 应用程序通过App Store验证后才发布。这是，如果后面还有新的代码合并到 Master，导致与刚刚发布的版本不一致。在这些情况下，需要额外创建一个 production 分支跟踪线上版本。如果想要查看生产环境代码，可切换至生产分支。</p><h2 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h2><p>Gitlab Flow 是 Git Flow 与 Github Flow 的结合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一分支的简单和便利，是 gitlab.com 推荐的做法。</p><h3 id="上游优先"><a href="#上游优先" class="headerlink" title="上游优先"></a>上游优先</h3><p>Gitlab Flow 的最大原则叫做“上游优先”，指存在一个主分支，他是所有其他分支的上游，只有上游分支采纳的代码变化，才能应用到其他分支。</p><h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>对于持续发布的项目，建议在 Master 之外，创建不同环境的分支，比如开发环境是 Master，预发布分支是pre-production，生产环境是production。<br>开发分支是语发布分支的上游，予发布分支是生产分支的上游。代码变化，必须由上游向下游发展。</p><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对于版本发布的项目，建议的做法是每一个稳定的版本，都要从 Master 分支上拉出一个分支，比如1.0.3-stable等等。<br>发布版本后，只有向该分支添加严重的错误修复，首先将错误修复合并到 Master 分支，然后将其合并到 stable 分支，并且此时要更新小版本号码。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/p/0.html"/>
      <url>/p/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p>给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。</p><p>输入输出<br>输入</p><p>“this is a sentence”</p><p>输出</p><p>sentence a is this</p><p>首先，题目要求把每个单词倒过来，同时联想到栈有先进先出的特点。如果我们把单词作为一个整体按顺序入栈，然后再全部出栈，这时得到的就是反转后的句子了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    stack&lt;string&gt; wordStack;    int len = str.size();    string temp=&quot;&quot;;    for (int i = 0; i &lt; len; i++) &#123;        if (str[i] != &#39; &#39;) &#123;            temp += str[i];        &#125;        else &#123;            wordStack.push(temp);            temp.clear();        &#125;    &#125;    wordStack.push(temp);    string tempword;    while (!wordStack.empty())    &#123;        tempword = wordStack.top();        wordStack.pop();        if (!wordStack.empty()) &#123;            cout &lt;&lt; tempword &lt;&lt; &#39; &#39;;        &#125;        else        &#123;            cout &lt;&lt; tempword;        &#125;    &#125;    return 0;&#125;</code></pre><p>在整个字符串反转后，可以看到单词的相对位置就已经反转过来了，但是对于每个单词依然内部字母是反转的，因此考虑是否有方法将每个单词进行反转，这样单词字母的顺序就变过来了。</p><p>没错，把每个单词作为一个独立的字符串进行反转就可以了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;void reverseStr(string&amp; str, int beg, int end) &#123;    while (beg &lt; end) &#123;        swap(str[beg++], str[end--]);    &#125;&#125;int main() &#123;    string str;    getline(cin, str);    reverseStr(str, 0, str.size() - 1);    int begin=0, end=0;    for (int i = 0; i &lt; str.size(); i++) &#123;        if (str[i] != &#39; &#39;) &#123;            end=i;        &#125;        else &#123;            reverseStr(str, begin, end);            begin = end + 2;        &#125;    &#125;    reverseStr(str, begin, end);    cout &lt;&lt; str;    return 0;&#125;</code></pre><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><p>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出: 4</p><p>原文的分析是：</p><p>注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）</p><p>if nums[0] &lt;&#x3D; nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;&#x3D; target &lt;&#x3D; nums[i]时我们应该在 0 - i 范围内查找；<br>if nums[i] &lt; nums[0] 那么在 0 - i 区间的某个点处发生了下降（旋转），那么 I + 1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当 target 不属于 nums[0] 到 nums[i] 时（target &lt;&#x3D; nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;&#x3D; target），我们应该在 0 - i 区间内查找。<br>上述三种情况可以总结如下：</p><pre><code>nums[0] &lt;= target &lt;= nums[i]           target &lt;= nums[i] &lt; nums[0]                     nums[i] &lt; nums[0] &lt;= target</code></pre><p>所以我们进行三项判断：</p><p>(nums[0] &lt;&#x3D; target)， (target &lt;&#x3D; nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））</p><p>所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。</p><p>使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）</p><p>之后我们通过二分查找不断做小 target 可能位于的区间直到 low&#x3D;&#x3D;high，此时如果 nums[low]&#x3D;&#x3D;target 则找到了，如果不等则说明该数组里没有此项。</p><p>class Solution {<br>public:<br>    int search(vector<int>&amp; nums, int target) {<br>        int lo &#x3D; 0, hi &#x3D; nums.size() - 1;<br>        while (lo &lt; hi) {<br>            int mid &#x3D; (lo + hi) &#x2F; 2;<br>            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))<br>                lo &#x3D; mid + 1;<br>            else<br>                hi &#x3D; mid;<br>        }<br>        return lo &#x3D;&#x3D; hi &amp;&amp; nums[lo] &#x3D;&#x3D; target ? lo : -1;<br>    }<br>};</int></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/p/b7e144d1.html"/>
      <url>/p/b7e144d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="力扣56，合并区间"><a href="#力扣56，合并区间" class="headerlink" title="力扣56，合并区间"></a>力扣56，合并区间</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VLD</title>
      <link href="/p/ba0d0e90.html"/>
      <url>/p/ba0d0e90.html</url>
      
        <content type="html"><![CDATA[<h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p>金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。</p><h2 id="Valgrind-的介绍"><a href="#Valgrind-的介绍" class="headerlink" title="Valgrind 的介绍"></a>Valgrind 的介绍</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><pre><code>$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2$ bzip2 -d valgrind-3.13.0.tar.bz2$ tar -xf valgrind-3.13.0.tar$ cd valgrind-3.13.0$ ./configure &amp;&amp; make$ sudo make install</code></pre><p>检测内存泄漏</p><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><pre><code>#include &lt;stdlib.h&gt;int main()&#123;    int *array = malloc(sizeof(int));    return 0;&#125;</code></pre><p>编译程序时，需要加上-g选项：</p><pre><code>$ gcc -g -o main_c main.c</code></pre><p>使用 Valgrind 检测内存使用情况：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full  ./main_c==31416== Memcheck, a memory error detector==31416== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31416== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31416== Command: ./main_c==31416====31416====31416== HEAP SUMMARY:==31416==     in use at exit: 4 bytes in 1 blocks==31416==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated==31416====31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)==31416====31416== LEAK SUMMARY:==31416==    definitely lost: 4 bytes in 1 blocks==31416==    indirectly lost: 0 bytes in 0 blocks==31416==      possibly lost: 0 bytes in 0 blocks==31416==    still reachable: 0 bytes in 0 blocks==31416==         suppressed: 0 bytes in 0 blocks==31416====31416== For counts of detected and suppressed errors, rerun with: -v==31416== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>先看看输出信息中的HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees表示程序释放了 0 次内存，4 bytes allocated表示分配了 4 个字节的内存。<br>另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是main.c文件的第 5 行：</p><pre><code>==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)</code></pre><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><p>#include <string><br>int main()<br>{<br>    auto ptr &#x3D; new std::string(“Hello, World!”);<br>    delete ptr;<br>    return 0;<br>}</string></p><p>使用 Valgrind 分析这段程序：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp==31438== Memcheck, a memory error detector==31438== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31438== Command: ./main_cpp==31438====31438====31438== HEAP SUMMARY:==31438==     in use at exit: 72,704 bytes in 1 blocks==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated==31438====31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)==31438==    by 0x40105FA: call_init (dl-init.c:30)==31438==    by 0x40105FA: _dl_init (dl-init.c:120)==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)==31438====31438== LEAK SUMMARY:==31438==    definitely lost: 0 bytes in 0 blocks==31438==    indirectly lost: 0 bytes in 0 blocks==31438==      possibly lost: 0 bytes in 0 blocks==31438==    still reachable: 72,704 bytes in 1 blocks==31438==         suppressed: 0 bytes in 0 blocks==31438====31438== For counts of detected and suppressed errors, rerun with: -v==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从HEAP SUMMARY可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？<br>实际上这是由于 C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏，例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。</p><p>检测越界访问<br>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><pre><code>#include &lt;vector&gt;#include &lt;iostream&gt;int main()&#123;    std::vector&lt;int&gt; v(10, 0);    std::cout &lt;&lt; v[10] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31523== Memcheck, a memory error detector==31523== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31523== Command: ./main_cpp==31523====31523== Invalid read of size 4==31523==    at 0x400AD7: main (main.cpp:7)==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#39;d==31523==    at 0x4C2E216: operator new(unsigned long) (vg_replace_malloc.c:334)==31523==    by 0x4010D3: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)==31523==    by 0x401040: std::allocator_traits&lt;std::allocator&lt;int&gt; &gt;::allocate(std::allocator&lt;int&gt;&amp;, unsigned long) (alloc_traits.h:491)==31523==    by 0x400F91: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:170)==31523==    by 0x400E7E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_create_storage(unsigned long) (stl_vector.h:185)==31523==    by 0x400D1E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:136)==31523==    by 0x400C11: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector(unsigned long, int const&amp;, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:291)==31523==    by 0x400AB9: main (main.cpp:6)</code></pre><p>Invalid read of size 4表示越界读取 4 个字节，这个操作出现在main.cpp文件的第 7 行。另外可以看到，vector分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><p>检测未初始化的内存<br>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><pre><code>#include &lt;iostream&gt;int main()&#123;    int x;    if (x == 0)    &#123;        std::cout &lt;&lt; &quot;X is zero&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 检测这个程序：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31554== Memcheck, a memory error detector==31554== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31554== Command: ./main_cpp==31554====31554== Conditional jump or move depends on uninitialised value(s)==31554==    at 0x400852: main (main.cpp:6)</code></pre><p>　　<br>输出中提示了main.cpp文件的第 6 行访问了未初始化的内存。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/p/54e1373e.html"/>
      <url>/p/54e1373e.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL相关问题，事务，索引，索引的优化，用过没"><a href="#MySQL相关问题，事务，索引，索引的优化，用过没" class="headerlink" title="MySQL相关问题，事务，索引，索引的优化，用过没"></a>MySQL相关问题，事务，索引，索引的优化，用过没</h2><h2 id="数据库的水平划分和垂直划分"><a href="#数据库的水平划分和垂直划分" class="headerlink" title="数据库的水平划分和垂直划分"></a>数据库的水平划分和垂直划分</h2><h2 id="数据库ACID的概念，事务是怎么保证的"><a href="#数据库ACID的概念，事务是怎么保证的" class="headerlink" title="数据库ACID的概念，事务是怎么保证的"></a>数据库ACID的概念，事务是怎么保证的</h2><ul><li>原子性(Atomicity)：  事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：  数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)： 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>事务的原子性指一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。</p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态;如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。<br>另一部分是业务数据的一致性，这需要程序代码来保证。比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。</p><p>事务的隔离性指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>事务的持久性指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。持久性意味着事务操作最终要持久化到数据库中，持久性是由 内存+redo log来保证的，MySQL的InnoDB在修改数据的时候，同时在内存和redo log记录这次操作，宕机的时候可以从redo log中恢复数据。</p><h2 id="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"><a href="#介绍一下mysql的常见的存储引擎，以及它们的区别是什么？" class="headerlink" title="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"></a>介绍一下mysql的常见的存储引擎，以及它们的区别是什么？</h2><h2 id="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"><a href="#介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）" class="headerlink" title="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"></a>介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）</h2><ul><li>读未提交（READ UNCOMMITTED）在该隔离级别一个事务还没提交时，它做的变更就能被别的事务看到，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务提交之后，它做的变更才会被其他事务看到。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>可重复读 （REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>串行化 （SERIALIZABLE）“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p>MySQL的InnoDB引擎在可重复读级别通过间隙锁解决了幻读问题，通过MVCC解决了不可重复读的问题</p><h2 id="mysql底层为什么用的是b-树？"><a href="#mysql底层为什么用的是b-树？" class="headerlink" title="mysql底层为什么用的是b+树？"></a>mysql底层为什么用的是b+树？</h2><h2 id="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"><a href="#介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？" class="headerlink" title="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"></a>介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？</h2><h2 id="MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。"><a href="#MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。" class="headerlink" title="MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。"></a>MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。</h2><h2 id="MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"><a href="#MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。" class="headerlink" title="MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"></a>MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。</h2><h2 id="MySQL的LRU和普通的LRU算法有何区别？"><a href="#MySQL的LRU和普通的LRU算法有何区别？" class="headerlink" title="MySQL的LRU和普通的LRU算法有何区别？"></a>MySQL的LRU和普通的LRU算法有何区别？</h2><h2 id="介绍MySQL三大日志redo-log-undo-log-bin-log。"><a href="#介绍MySQL三大日志redo-log-undo-log-bin-log。" class="headerlink" title="介绍MySQL三大日志redo log,undo log,bin log。"></a>介绍MySQL三大日志redo log,undo log,bin log。</h2><h2 id="写一个LRU缓存。"><a href="#写一个LRU缓存。" class="headerlink" title="写一个LRU缓存。"></a>写一个LRU缓存。</h2><h2 id="查询优化器有哪些优化"><a href="#查询优化器有哪些优化" class="headerlink" title="查询优化器有哪些优化"></a>查询优化器有哪些优化</h2><h2 id="InnoDB里面有哪些线程"><a href="#InnoDB里面有哪些线程" class="headerlink" title="InnoDB里面有哪些线程"></a>InnoDB里面有哪些线程</h2><h2 id="为什么使用B-树做索引，而不是B树或者哈希"><a href="#为什么使用B-树做索引，而不是B树或者哈希" class="headerlink" title="为什么使用B+树做索引，而不是B树或者哈希"></a>为什么使用B+树做索引，而不是B树或者哈希</h2><h2 id="了解Trie树吗"><a href="#了解Trie树吗" class="headerlink" title="了解Trie树吗"></a>了解Trie树吗</h2><h2 id="MySQL缓存介绍一下，有哪些优化"><a href="#MySQL缓存介绍一下，有哪些优化" class="headerlink" title="MySQL缓存介绍一下，有哪些优化"></a>MySQL缓存介绍一下，有哪些优化</h2><h2 id="为什么使用索引、说一下你对索引的理解？"><a href="#为什么使用索引、说一下你对索引的理解？" class="headerlink" title="为什么使用索引、说一下你对索引的理解？"></a>为什么使用索引、说一下你对索引的理解？</h2><h2 id="事务的性质有哪些，具体概念以及实现"><a href="#事务的性质有哪些，具体概念以及实现" class="headerlink" title="事务的性质有哪些，具体概念以及实现"></a>事务的性质有哪些，具体概念以及实现</h2><h2 id="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"><a href="#也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等" class="headerlink" title="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"></a>也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="/p/bdbd2d9.html"/>
      <url>/p/bdbd2d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h2><h2 id="tcp四次挥手第二次和第三次不能合并吗"><a href="#tcp四次挥手第二次和第三次不能合并吗" class="headerlink" title="tcp四次挥手第二次和第三次不能合并吗"></a>tcp四次挥手第二次和第三次不能合并吗</h2><h2 id="osi七层网络模型，每层有的协议"><a href="#osi七层网络模型，每层有的协议" class="headerlink" title="osi七层网络模型，每层有的协议"></a>osi七层网络模型，每层有的协议</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="ssl四次挥手"><a href="#ssl四次挥手" class="headerlink" title="ssl四次挥手"></a>ssl四次挥手</h2><h2 id="计算机网络的理解大概是什么样的？说下TCP的三次握手"><a href="#计算机网络的理解大概是什么样的？说下TCP的三次握手" class="headerlink" title="计算机网络的理解大概是什么样的？说下TCP的三次握手"></a>计算机网络的理解大概是什么样的？说下TCP的三次握手</h2><h2 id="SSL的四次握手知道不？"><a href="#SSL的四次握手知道不？" class="headerlink" title="SSL的四次握手知道不？"></a>SSL的四次握手知道不？</h2><h2 id="tcp三次握手过程、是否熟悉TLS协议"><a href="#tcp三次握手过程、是否熟悉TLS协议" class="headerlink" title="tcp三次握手过程、是否熟悉TLS协议"></a>tcp三次握手过程、是否熟悉TLS协议</h2><h2 id="介绍一下使用tcp进行通信的时候socket的使用过程"><a href="#介绍一下使用tcp进行通信的时候socket的使用过程" class="headerlink" title="介绍一下使用tcp进行通信的时候socket的使用过程"></a>介绍一下使用tcp进行通信的时候socket的使用过程</h2><h2 id="网络模型、介绍一下每一层的作用？"><a href="#网络模型、介绍一下每一层的作用？" class="headerlink" title="网络模型、介绍一下每一层的作用？"></a>网络模型、介绍一下每一层的作用？</h2><h2 id="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"><a href="#这个也是从上面引申的，流量控制和拥塞控制怎么实现的？" class="headerlink" title="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"></a>这个也是从上面引申的，流量控制和拥塞控制怎么实现的？</h2><h2 id="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"><a href="#具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。" class="headerlink" title="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"></a>具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。</h2><h2 id="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"><a href="#如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）" class="headerlink" title="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"></a>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）</h2><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><h2 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h2><h2 id="如何使用UDP设计一个可靠的传输协议（知识盲区）"><a href="#如何使用UDP设计一个可靠的传输协议（知识盲区）" class="headerlink" title="如何使用UDP设计一个可靠的传输协议（知识盲区）"></a>如何使用UDP设计一个可靠的传输协议（知识盲区）</h2><h2 id="一条SQL语句的执行流程"><a href="#一条SQL语句的执行流程" class="headerlink" title="一条SQL语句的执行流程"></a>一条SQL语句的执行流程</h2><h2 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h2><h2 id="为什么要用epoll"><a href="#为什么要用epoll" class="headerlink" title="为什么要用epoll"></a>为什么要用epoll</h2><h2 id="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"><a href="#reactor和proactor的好处和坏处。为什么要用reactor而不用proactor" class="headerlink" title="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"></a>reactor和proactor的好处和坏处。为什么要用reactor而不用proactor</h2><h2 id="能详细讲一下有限状态机怎么解析http报文吗"><a href="#能详细讲一下有限状态机怎么解析http报文吗" class="headerlink" title="能详细讲一下有限状态机怎么解析http报文吗"></a>能详细讲一下有限状态机怎么解析http报文吗</h2><h2 id="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"><a href="#小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题" class="headerlink" title="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"></a>小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题</h2><h2 id="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"><a href="#如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆" class="headerlink" title="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"></a>如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆</h2><h2 id="socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）"><a href="#socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）" class="headerlink" title="socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）"></a>socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）</h2><h2 id="这个时候会绑定端口吗？"><a href="#这个时候会绑定端口吗？" class="headerlink" title="这个时候会绑定端口吗？"></a>这个时候会绑定端口吗？</h2><h2 id="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"><a href="#后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）" class="headerlink" title="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"></a>后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）</h2><h2 id="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"><a href="#第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？" class="headerlink" title="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"></a>第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？</h2><h2 id="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"><a href="#第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？" class="headerlink" title="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"></a>第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？</h2><h2 id="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"><a href="#TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？" class="headerlink" title="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"></a>TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？</h2><h2 id="tcp-x2F-ip五层模型"><a href="#tcp-x2F-ip五层模型" class="headerlink" title="tcp&#x2F;ip五层模型"></a>tcp&#x2F;ip五层模型</h2><h2 id="dns服务器用的是什么协议。"><a href="#dns服务器用的是什么协议。" class="headerlink" title="dns服务器用的是什么协议。"></a>dns服务器用的是什么协议。</h2><h2 id="ping命令-用的是什么协议。在哪一层。"><a href="#ping命令-用的是什么协议。在哪一层。" class="headerlink" title="ping命令 用的是什么协议。在哪一层。"></a>ping命令 用的是什么协议。在哪一层。</h2><h2 id="tcp拥塞控制实现。"><a href="#tcp拥塞控制实现。" class="headerlink" title="tcp拥塞控制实现。"></a>tcp拥塞控制实现。</h2><h2 id="在浏览器输入URL后回车的过程，涉及什么协议"><a href="#在浏览器输入URL后回车的过程，涉及什么协议" class="headerlink" title="在浏览器输入URL后回车的过程，涉及什么协议"></a>在浏览器输入URL后回车的过程，涉及什么协议</h2><h2 id="http一定是tcp吗，http3之前是"><a href="#http一定是tcp吗，http3之前是" class="headerlink" title="http一定是tcp吗，http3之前是"></a>http一定是tcp吗，http3之前是</h2><h2 id="服务器多个进程可以都绑定80这个端口监听吗"><a href="#服务器多个进程可以都绑定80这个端口监听吗" class="headerlink" title="服务器多个进程可以都绑定80这个端口监听吗"></a>服务器多个进程可以都绑定80这个端口监听吗</h2><h2 id="原理是什么"><a href="#原理是什么" class="headerlink" title="原理是什么"></a>原理是什么</h2><h2 id="操作系统怎么转发的"><a href="#操作系统怎么转发的" class="headerlink" title="操作系统怎么转发的"></a>操作系统怎么转发的</h2><h2 id="https可以绑定80端口吗，绑定了还能加密吗，为什么"><a href="#https可以绑定80端口吗，绑定了还能加密吗，为什么" class="headerlink" title="https可以绑定80端口吗，绑定了还能加密吗，为什么"></a>https可以绑定80端口吗，绑定了还能加密吗，为什么</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承构造函数</title>
      <link href="/p/4d123864.html"/>
      <url>/p/4d123864.html</url>
      
        <content type="html"><![CDATA[<h1 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h1><p>继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    using Base::Base;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>在 C++11 以前，你就必须在 Derived 里再写一份同参数列表的构造函数，将参数转发给基类。</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y)    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>如果基类有很多重载的构造函数的话，每个重载版本都要在子类重写一下，这是违反代码复用原则的！更要命的是，如果基类构造函数重构了，而子类忘记跟着改的话，就容易 BOOM</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, double y) : x(x), y(y) // 基类 api 改了    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y) // 子类这里忘改了    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4.5); // 定义变量的时候参考了基类 api 手册    // 你就等着调 bug 调到猝死吧&#125;</code></pre><p>using Base::基类方法名的这个语法是 C++98 就有的，不是 C++11 里才加的全新玩意。</p><pre><code>#include &lt;iostream&gt;class Base&#123;    protected:        void print() const        &#123;            std::cout &lt;&lt; 2333 &lt;&lt; std::endl;        &#125;&#125;;class Derived: public Base&#123;    public:        using Base::print;        // 如果不加这句声明，        // 则 print 方法在 Derived 类中就仍是 protected 的        // main 中无法调用&#125;;int main()&#123;    Derived d;    d.print();&#125;</code></pre><p>如上例所示，这种语法可以改变方法的访问控制域，比如将基类的保护方法公开出来，当然也可以将基类的公开方法在子类中变更为私有。再强调一下，这个是 C++98 中就有的语法。只不过 98 里不能 using 父类::构造函数（构造函数在某种意义上也是类的方法对吧，所以 11 补上了）</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/p/d04bd5bc.html"/>
      <url>/p/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="多线程接触过吗？控制线程访问共享资源有哪些锁？"><a href="#多线程接触过吗？控制线程访问共享资源有哪些锁？" class="headerlink" title="多线程接触过吗？控制线程访问共享资源有哪些锁？"></a>多线程接触过吗？控制线程访问共享资源有哪些锁？</h2><h2 id="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"><a href="#介绍一下互斥锁（中间穿插了一点项目的实现细节问题）" class="headerlink" title="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"></a>介绍一下互斥锁（中间穿插了一点项目的实现细节问题）</h2><h2 id="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"><a href="#用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？" class="headerlink" title="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"></a>用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？</h2><h2 id="操作系统是怎么进行内存管理的？"><a href="#操作系统是怎么进行内存管理的？" class="headerlink" title="操作系统是怎么进行内存管理的？"></a>操作系统是怎么进行内存管理的？</h2><h2 id="程序的状态有哪些？"><a href="#程序的状态有哪些？" class="headerlink" title="程序的状态有哪些？"></a>程序的状态有哪些？</h2><h2 id="详细介绍一下每个状态是怎样转换的？"><a href="#详细介绍一下每个状态是怎样转换的？" class="headerlink" title="详细介绍一下每个状态是怎样转换的？"></a>详细介绍一下每个状态是怎样转换的？</h2><h2 id="你知道的进程调度算法有哪些？详细介绍一下？"><a href="#你知道的进程调度算法有哪些？详细介绍一下？" class="headerlink" title="你知道的进程调度算法有哪些？详细介绍一下？"></a>你知道的进程调度算法有哪些？详细介绍一下？</h2><h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><h2 id="多进程fork后不同进程会共享哪些资源"><a href="#多进程fork后不同进程会共享哪些资源" class="headerlink" title="多进程fork后不同进程会共享哪些资源"></a>多进程fork后不同进程会共享哪些资源</h2><h2 id="多线程里线程的同步方式有哪些"><a href="#多线程里线程的同步方式有哪些" class="headerlink" title="多线程里线程的同步方式有哪些"></a>多线程里线程的同步方式有哪些</h2><h2 id="select怎么用。底层原理"><a href="#select怎么用。底层原理" class="headerlink" title="select怎么用。底层原理"></a>select怎么用。底层原理</h2><h2 id="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"><a href="#select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。" class="headerlink" title="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"></a>select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。</h2><h2 id="epoll-底层为什么用红黑树不用hash"><a href="#epoll-底层为什么用红黑树不用hash" class="headerlink" title="epoll 底层为什么用红黑树不用hash"></a>epoll 底层为什么用红黑树不用hash</h2><h2 id="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"><a href="#了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别" class="headerlink" title="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"></a>了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别</h2><h2 id="介绍一下epoll的两种实现方式"><a href="#介绍一下epoll的两种实现方式" class="headerlink" title="介绍一下epoll的两种实现方式"></a>介绍一下epoll的两种实现方式</h2><h2 id="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"><a href="#磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？" class="headerlink" title="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"></a>磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？</h2><h2 id="有了解epoll的底层数据结构吗？介绍一下"><a href="#有了解epoll的底层数据结构吗？介绍一下" class="headerlink" title="有了解epoll的底层数据结构吗？介绍一下"></a>有了解epoll的底层数据结构吗？介绍一下</h2><h2 id="如何限制一个进程能够使用的线程等资源"><a href="#如何限制一个进程能够使用的线程等资源" class="headerlink" title="如何限制一个进程能够使用的线程等资源"></a>如何限制一个进程能够使用的线程等资源</h2><p>ulimit -u 4096</p><p>这属于软限制，是可以改变的。也就是说在我的机器上最多可以有4096个进程，但是我可以通过改变这个参数的值来修改对于进程数量的软限制，比如说用下面的命令将软限制改到5120。</p><p>ulimit -u 5120</p><h2 id="了解过stdexec吗（NVIDIA的异步编程高性能库）"><a href="#了解过stdexec吗（NVIDIA的异步编程高性能库）" class="headerlink" title="了解过stdexec吗（NVIDIA的异步编程高性能库）"></a>了解过stdexec吗（NVIDIA的异步编程高性能库）</h2><p>没有</p><h2 id="使用过perf吗"><a href="#使用过perf吗" class="headerlink" title="使用过perf吗"></a>使用过perf吗</h2><p>没有</p><h2 id="怎么查看tlb命中率"><a href="#怎么查看tlb命中率" class="headerlink" title="怎么查看tlb命中率"></a>怎么查看tlb命中率</h2><h2 id="如何查看进程的线程数"><a href="#如何查看进程的线程数" class="headerlink" title="如何查看进程的线程数"></a>如何查看进程的线程数</h2><p>使用top命令，具体用法是 top -H</p><pre><code>    加上这个选项，top的每一行就不是显示一个进程，而是一个线程。</code></pre><p>使用ps命令，具体用法是 ps -xH</p><pre><code>    这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。</code></pre><p> 使用ps命令，具体用法是 ps -mq PID</p><pre><code>    这样可以看到指定的进程产生的线程数目。</code></pre><h2 id="如何查看进程打开的文件有哪些"><a href="#如何查看进程打开的文件有哪些" class="headerlink" title="如何查看进程打开的文件有哪些"></a>如何查看进程打开的文件有哪些</h2><p>1.列出所有打开的文件:</p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><ol start="2"><li>查看谁正在使用某个文件</li></ol><p>lsof   &#x2F;filepath&#x2F;file</p><p>3.递归查看某个目录的文件信息</p><p>lsof +D &#x2F;filepath&#x2F;filepath2&#x2F;</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><ol start="4"><li>比使用+D选项，遍历查看某个目录的所有文件信息 的方法</li></ol><p>lsof | grep ‘&#x2F;filepath&#x2F;filepath2&#x2F;’</p><ol start="5"><li>列出某个用户打开的文件信息</li></ol><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><ol start="6"><li>列出某个程序所打开的文件信息</li></ol><p>lsof -c mysql</p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p><ol start="7"><li>列出多个程序多打开的文件信息</li></ol><p>lsof -c mysql -c apache</p><ol start="8"><li>列出某个用户以及某个程序所打开的文件信息</li></ol><p>lsof -u test -c mysql</p><ol start="9"><li>列出除了某个用户外的被打开的文件信息</li></ol><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><ol start="10"><li>通过某个进程号显示该进行打开的文件</li></ol><p>lsof -p 1</p><ol start="11"><li>列出多个进程号对应的文件信息</li></ol><p>lsof -p 123,456,789</p><ol start="12"><li>列出除了某个进程号，其他进程号所打开的文件信息</li></ol><p>lsof -p ^1</p><p>13 . 列出所有的网络连接</p><p>lsof -i</p><ol start="14"><li>列出所有tcp 网络连接信息</li></ol><p>lsof  -i tcp</p><ol start="15"><li>列出所有udp网络连接信息</li></ol><p>lsof  -i udp</p><ol start="16"><li>列出谁在使用某个端口</li></ol><p>lsof -i :3306</p><ol start="17"><li>列出谁在使用某个特定的udp端口</li></ol><p>lsof -i udp:55</p><p>特定的tcp端口</p><p>lsof -i tcp:80</p><ol start="18"><li>列出某个用户的所有活跃的网络端口</li></ol><p>lsof  -a -u test -i</p><ol start="19"><li>列出所有网络文件系统</li></ol><p>lsof -N</p><p>20.域名socket文件</p><p>lsof -u</p><p>21.某个用户组所打开的文件信息</p><p>lsof -g 5555</p><ol start="22"><li>根据文件描述列出对应的文件信息</li></ol><p>lsof -d description(like 2)</p><ol start="23"><li>根据文件描述范围列出文件信息</li></ol><p>lsof -d 2-3</p><h2 id="产生死锁的条件以及怎么解决死锁问题"><a href="#产生死锁的条件以及怎么解决死锁问题" class="headerlink" title="产生死锁的条件以及怎么解决死锁问题"></a>产生死锁的条件以及怎么解决死锁问题</h2><h2 id="Linux大概学到什么程度？"><a href="#Linux大概学到什么程度？" class="headerlink" title="Linux大概学到什么程度？"></a>Linux大概学到什么程度？</h2><h2 id="线程怎么创建，什么语言"><a href="#线程怎么创建，什么语言" class="headerlink" title="线程怎么创建，什么语言"></a>线程怎么创建，什么语言</h2><h2 id="线程的基本状态有哪几个？"><a href="#线程的基本状态有哪几个？" class="headerlink" title="线程的基本状态有哪几个？"></a>线程的基本状态有哪几个？</h2><h2 id="多线程的使用的好处是什么"><a href="#多线程的使用的好处是什么" class="headerlink" title="多线程的使用的好处是什么"></a>多线程的使用的好处是什么</h2><h2 id="多线程会竞争资源出现死锁的状态，死锁怎么解决？"><a href="#多线程会竞争资源出现死锁的状态，死锁怎么解决？" class="headerlink" title="多线程会竞争资源出现死锁的状态，死锁怎么解决？"></a>多线程会竞争资源出现死锁的状态，死锁怎么解决？</h2><h2 id="事务及事务隔离"><a href="#事务及事务隔离" class="headerlink" title="事务及事务隔离"></a>事务及事务隔离</h2><h2 id="编译一个hello-world程序并且在shell上运行打印的全过程"><a href="#编译一个hello-world程序并且在shell上运行打印的全过程" class="headerlink" title="编译一个hello world程序并且在shell上运行打印的全过程?"></a>编译一个hello world程序并且在shell上运行打印的全过程?</h2><h2 id="fork-父子进程之间的关系"><a href="#fork-父子进程之间的关系" class="headerlink" title="fork()父子进程之间的关系"></a>fork()父子进程之间的关系</h2><h2 id="缺页中断的过程"><a href="#缺页中断的过程" class="headerlink" title="缺页中断的过程"></a>缺页中断的过程</h2><h2 id="地址转换的过程"><a href="#地址转换的过程" class="headerlink" title="地址转换的过程"></a>地址转换的过程</h2><h2 id="进程状态是怎么转变的"><a href="#进程状态是怎么转变的" class="headerlink" title="进程状态是怎么转变的"></a>进程状态是怎么转变的</h2><h2 id="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"><a href="#进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）" class="headerlink" title="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"></a>进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）</h2><h2 id="总线在其中发挥的作用"><a href="#总线在其中发挥的作用" class="headerlink" title="总线在其中发挥的作用"></a>总线在其中发挥的作用</h2><h2 id="这个过程中磁盘和内存的关系"><a href="#这个过程中磁盘和内存的关系" class="headerlink" title="这个过程中磁盘和内存的关系"></a>这个过程中磁盘和内存的关系</h2><h2 id="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"><a href="#从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行" class="headerlink" title="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"></a>从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp面向对象</title>
      <link href="/p/87fdbf5e.html"/>
      <url>/p/87fdbf5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="cpp面向对象"><a href="#cpp面向对象" class="headerlink" title="cpp面向对象"></a>cpp面向对象</h1><p>面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装可以隐藏实现细节，使得代码模块化；封装将一些属性和相关方法封装在一个对象中，对数据的访问只能通过已定义的界面。对外隐藏内部具体实现细节。内部实现，外界不需要关心，外界只需要根据“内部提供的接口”去使用就可以。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><ul><li>保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）</li><li>隐藏方法（实现）细节，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</li><li>封装可以使对象拥有完整的属性和方法（类中的函数）</li><li>外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p><p>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>多态的构成条件</p><ul><li>必须通过基类的指针或者引用调用虚函数<ul><li>虚函数：在类的普通成员函数前加上virtual关键字+</li></ul></li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp内存管理</title>
      <link href="/p/ee3dbaf8.html"/>
      <url>/p/ee3dbaf8.html</url>
      
        <content type="html"><![CDATA[<h1 id="cpp内存管理"><a href="#cpp内存管理" class="headerlink" title="cpp内存管理"></a>cpp内存管理</h1><p><img src="https://s1.ax1x.com/2023/08/06/pPA4Y7T.png" alt="pPA4Y7T.png"></p><p>栈：又叫堆栈，主要存放非静态局部变量、函数参数、返回值等等，栈是向下增长的；</p><p>BSS（Block started by symbol)：存放未初始化的全局和静态变量。</p><p>堆：用于程序运行时动态内存分配，堆是可以上增长的；</p><p>数据段：存储全局数据和静态数据，常量数据（如字符串常量）。</p><p>代码段：存储可执行的代码与只读常量；</p><p>当全局&#x2F;静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。</p><pre><code>int x;int z = 5;void func()&#123;    static int y;&#125;int main()&#123;    return 0;&#125;</code></pre><p>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p><p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p><p>而对于已经初始化了的全局&#x2F;静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p><h2 id="堆和栈的主要区别"><a href="#堆和栈的主要区别" class="headerlink" title="堆和栈的主要区别"></a>堆和栈的主要区别</h2><p>有以下几点：</p><ul><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ul><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="让一个对象只在栈（堆）上分配内存"><a href="#让一个对象只在栈（堆）上分配内存" class="headerlink" title="让一个对象只在栈（堆）上分配内存"></a>让一个对象只在栈（堆）上分配内存</h2><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<br>虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。<br>将operator new()设为私有即可禁止对象被new在堆上。</p><pre><code>class A  &#123;  private:      void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的      void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  public:      A()&#123;&#125;      ~A()&#123;&#125;  &#125;;</code></pre><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><p>就是不能静态建立类对象, 即不能直接调用类的构造函数。<br>首先要知道， 当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</p><pre><code>class A&#123;public:    A()&#123;&#125;    void destroy()&#123;delete this;&#125;private:    ~A()&#123;&#125;&#125;</code></pre><p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</p><p>存在问题：<br>1.无法解决继承问题：为了实现多态， 析构函数通常要设为virtual， 因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。<br>2. new和destroy的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp</title>
      <link href="/p/caeaa4a1.html"/>
      <url>/p/caeaa4a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h1><p><a href="https://www.dotcpp.com/course/808">https://www.dotcpp.com/course/808</a></p><h2 id="c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗"><a href="#c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗" class="headerlink" title="c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗"></a>c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗</h2><p>封装、继承、多态</p><h2 id="c-面向对象编程讲一下"><a href="#c-面向对象编程讲一下" class="headerlink" title="c++面向对象编程讲一下"></a>c++面向对象编程讲一下</h2><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><h2 id="多态和继承在什么情况下使用"><a href="#多态和继承在什么情况下使用" class="headerlink" title="多态和继承在什么情况下使用"></a>多态和继承在什么情况下使用</h2><h2 id="除了多态和继承还有什么面向对象方法"><a href="#除了多态和继承还有什么面向对象方法" class="headerlink" title="除了多态和继承还有什么面向对象方法"></a>除了多态和继承还有什么面向对象方法</h2><h2 id="能再仔细介绍一下c-的多态吗"><a href="#能再仔细介绍一下c-的多态吗" class="headerlink" title="能再仔细介绍一下c++的多态吗"></a>能再仔细介绍一下c++的多态吗</h2><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h2 id="多态是怎么调用派生类重写的方法的"><a href="#多态是怎么调用派生类重写的方法的" class="headerlink" title="多态是怎么调用派生类重写的方法的"></a>多态是怎么调用派生类重写的方法的</h2><h2 id="实现String-的普通和拷贝构造、赋值重载和析构函数"><a href="#实现String-的普通和拷贝构造、赋值重载和析构函数" class="headerlink" title="实现String 的普通和拷贝构造、赋值重载和析构函数"></a>实现String 的普通和拷贝构造、赋值重载和析构函数</h2><pre><code>#pragma warning(disable:4996)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyString &#123;public:    // 默认构造函数    MyString(const char* str = NULL);    // 复制构造函数    MyString(const MyString&amp; str);    // 移动构造函数    MyString(MyString&amp;&amp; str)noexcept;    // 析构函数    ~MyString();    // 字符串连接    MyString operator+(const MyString&amp; str);    // 拷贝赋值    MyString&amp; operator=(const MyString&amp; str);    //移动赋值    MyString&amp; operator=(MyString&amp;&amp; str);    // 字符串赋值    MyString&amp; operator=(const char* str);    // 判断是否字符串相等    bool operator==(const MyString&amp; str);    // 获取字符串长度    int length();    // 求子字符串[start,start+n-1]    MyString substr(int start, int n);    // 重载输出    friend ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str);private:    char* m_data;    int m_size;&#125;;// 构造函数MyString::MyString(const char* str)&#123;    if (str == nullptr)    &#123;        m_data = new char[1];        m_data[0] = &#39;\0&#39;;        m_size = 0;    &#125;    else    &#123;        m_size = strlen(str);        m_data = new char[m_size + 1];        strcpy(m_data, str);    &#125;&#125;// 复制构造函数MyString::MyString(const MyString&amp; str)&#123;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);&#125;// 析构函数MyString::~MyString()&#123;    delete[] m_data;&#125;// 字符串连接MyString MyString::operator+(const MyString&amp; str)&#123;    MyString newStr;    //释放原有空间    delete[] newStr.m_data;    newStr.m_size = m_size + str.m_size;    newStr.m_data = new char[newStr.m_size + 1];    strcpy(newStr.m_data, m_data);    strcpy(newStr.m_data + m_size, str.m_data);    return newStr;&#125;// 字符串赋值MyString&amp; MyString::operator=(const MyString&amp; str)&#123;    if (m_data == str.m_data)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);    return *this;&#125;MyString&amp; MyString::operator=(MyString&amp;&amp; str)&#123;    if (str.m_data == m_data)    &#123;        return *this;    &#125;    delete m_data;    m_data = str.m_data;    m_size = str.m_size;    str.m_data = nullptr;    str.m_size = 0;&#125;// 字符串赋值MyString&amp; MyString::operator=(const char* str)&#123;    if (m_data == str)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = strlen(str);    m_data = new char[m_size + 1];    strcpy(m_data, str);    return *this;&#125;// 判断是否字符串相等bool MyString::operator==(const MyString&amp; str)&#123;    return strcmp(m_data, str.m_data) == 0;&#125;// 获取字符串长度int MyString::length()&#123;    return m_size;&#125;// 求子字符串[start,start+n-1]MyString MyString::substr(int start, int n)&#123;    MyString newStr;    // 释放原有内存    delete[] newStr.m_data;    // 重新申请内存    newStr.m_data = new char[n + 1];    for (int i = 0;i &lt; n;++i)    &#123;        newStr.m_data[i] = m_data[start + i];    &#125;    newStr.m_data[n] = &#39;\0&#39;;    newStr.m_size = n;    return newStr;&#125;MyString::MyString(MyString&amp;&amp; str) noexcept&#123;    m_data = str.m_data;    str.m_data = nullptr;    m_size = str.m_size;    str.m_size = 0;&#125;// 重载输出ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str)&#123;    o &lt;&lt; str.m_data;    return o;&#125;</code></pre><h2 id="有了new是不是可以就不用malloc了？"><a href="#有了new是不是可以就不用malloc了？" class="headerlink" title="有了new是不是可以就不用malloc了？"></a>有了new是不是可以就不用malloc了？</h2><p>比如内存池，在这个基础上可以利用placement new<br>c 没有new  </p><h2 id="malloc是如何跟物理地址关联上的？"><a href="#malloc是如何跟物理地址关联上的？" class="headerlink" title="malloc是如何跟物理地址关联上的？"></a>malloc是如何跟物理地址关联上的？</h2><p>malloc申请内存返回的是虚拟地址而不是物理地址，而且，返回的这个虚拟地址是没有map映射到物理内存中的，只有当程序(进程)用到访问了这个地址的时候，</p><p>内核才响应“缺页异常”，才回去映射一块物理地址。</p><p>关于malloc(0) 能申请成功是肯定的，它返回的是虚拟地址(对应的物理地址还不确定的)，在你没用到这块地址空间的时候，它不会再物理上开辟内存。</p><p>在你用到malloc(0)返回的地址时，因为参数为0，缺页异常不会为你的进程空间申请额外内存。所以这个指针应该是不能用的。</p><h2 id="new-x2F-delete-malloc-x2F-free-区别"><a href="#new-x2F-delete-malloc-x2F-free-区别" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free 区别"></a>new&#x2F;delete  malloc&#x2F;free 区别</h2><ol><li>运算符库函数</li><li>构造函数析构函数</li><li>可以重载</li><li>手动计算大小，自动计算大小</li><li>类型安全</li></ol><h2 id="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"><a href="#讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常" class="headerlink" title="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"></a>讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常</h2><p>调用malloc+构造函数<br>nothrow指定<br>bad——alloc</p><h2 id="malloc线程安全吗，多线程malloc系统怎么设计"><a href="#malloc线程安全吗，多线程malloc系统怎么设计" class="headerlink" title="malloc线程安全吗，多线程malloc系统怎么设计"></a>malloc线程安全吗，多线程malloc系统怎么设计</h2><p>在多线程环境下，使用 malloc() 和 free() 函数需要特别注意，因为这两个函数都会涉及到内存的分配和释放，容易引起多线程竞争问题，可能会导致内存泄漏或程序崩溃。</p><p>为了避免这些问题，需要采取以下措施：</p><p>确保线程安全：多个线程同时使用 malloc() 或 free() 时可能会导致内存竞争。为了确保线程安全，可以使用线程安全的内存分配器，例如 tcmalloc 或 jemalloc，或者使用互斥锁来保护内存分配和释放的操作。</p><p>避免内存泄漏：如果在分配内存后忘记释放，将会导致内存泄漏。在多线程环境中，内存泄漏问题可能会更加复杂，因为在一个线程中分配的内存可能需要在另一个线程中释放。为了避免内存泄漏，应该在适当的时候调用 free() 函数来释放已经不再使用的内存。</p><p>避免悬挂指针问题：在多线程环境中，如果一个线程释放了某个内存块，而另一个线程仍然在使用这个内存块，就可能导致悬挂指针问题。为了避免这个问题，应该在释放内存块之前确保没有其他线程在使用该内存块，可以使用同步机制来解决这个问题。</p><p>总之，在多线程环境中，使用 malloc() 和 free() 函数需要特别小心，需要采取适当的措施来确保线程安全和避免内存泄漏和悬挂指针问题。</p><h2 id="C-内存分布。什么样的数据在栈区，什么样的在堆区。"><a href="#C-内存分布。什么样的数据在栈区，什么样的在堆区。" class="headerlink" title="C++内存分布。什么样的数据在栈区，什么样的在堆区。"></a>C++内存分布。什么样的数据在栈区，什么样的在堆区。</h2><p>局部栈区，全局堆区</p><h2 id="C-内存管理（RAII啥的）"><a href="#C-内存管理（RAII啥的）" class="headerlink" title="C++内存管理（RAII啥的）"></a>C++内存管理（RAII啥的）</h2><p>资源获取即初始化。使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><h2 id="sizeof一个空的结构体，返回什么"><a href="#sizeof一个空的结构体，返回什么" class="headerlink" title="sizeof一个空的结构体，返回什么"></a>sizeof一个空的结构体，返回什么</h2><p>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><h2 id="问了c-文件编译过程"><a href="#问了c-文件编译过程" class="headerlink" title="问了c++文件编译过程"></a>问了c++文件编译过程</h2><p>预编译  cpp<br>汇编    i<br>编译    s<br>链接    o</p><h2 id="静态链接动态链接区别"><a href="#静态链接动态链接区别" class="headerlink" title="静态链接动态链接区别"></a>静态链接动态链接区别</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="动态链接库具体怎样操作链接的"><a href="#动态链接库具体怎样操作链接的" class="headerlink" title="动态链接库具体怎样操作链接的"></a>动态链接库具体怎样操作链接的</h2><p>重定位   忘了待更新</p><h2 id="c-学的好的是哪块-具体说"><a href="#c-学的好的是哪块-具体说" class="headerlink" title="c++学的好的是哪块 具体说"></a>c++学的好的是哪块 具体说</h2><p>学得最好的是没有</p><h2 id="野指针和内存泄漏是什么，如何避免？"><a href="#野指针和内存泄漏是什么，如何避免？" class="headerlink" title="野指针和内存泄漏是什么，如何避免？"></a>野指针和内存泄漏是什么，如何避免？</h2><p>内存泄漏：①访问已经释放的内存</p><pre><code>②访问没有权限的内存</code></pre><p>野指针：指向内存被释放的内存或者没有访问权限的内存的指针。<br>野指针”的成因主要有3种：<br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><h2 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h2><p>智能指针</p><h2 id="内存泄漏怎样应对"><a href="#内存泄漏怎样应对" class="headerlink" title="内存泄漏怎样应对"></a>内存泄漏怎样应对</h2><p>智能指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><h2 id="讲一下智能指针"><a href="#讲一下智能指针" class="headerlink" title="讲一下智能指针"></a>讲一下智能指针</h2><h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="讲讲智能指针"><a href="#讲讲智能指针" class="headerlink" title="讲讲智能指针"></a>讲讲智能指针</h2><h2 id="c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用"><a href="#c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用" class="headerlink" title="c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用"></a>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用</h2><h2 id="shared-ptr循环引用怎么解决"><a href="#shared-ptr循环引用怎么解决" class="headerlink" title="shared_ptr循环引用怎么解决"></a>shared_ptr循环引用怎么解决</h2><p>weak_ptr</p><h2 id="make-shared和shared-ptr"><a href="#make-shared和shared-ptr" class="headerlink" title="make_shared和shared_ptr"></a>make_shared和shared_ptr</h2><p>std::shared_ptr构造函数会执行两次内存申请，而std::make_shared则执行一次。<br>std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr<A> p2(new A)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared<A>()则是只执行一次内存申请，将数据和控制块的申请放到一起。</A></A></p><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>考虑下面一段代码：</p><pre><code>void f(std::shared_ptr&lt;Lhs&gt; &amp;lhs, std::shared_ptr&lt;Rhs&gt; &amp;rhs)&#123;...&#125;...f(std::shared_ptr&lt;Lhs&gt;(new Lhs()),std::shared_ptr&lt;Rhs&gt;(new Rhs()));</code></pre><p>因为C++允许参数在计算的时候打乱顺序，因此一个可能的顺序如下:</p><pre><code>new Lhs()new Rhs()std::shared_ptrstd::shared_ptr</code></pre><p>此时假设第2步出现异常，则在第一步申请的内存将没处释放了，上面产生内存泄露的本质是当申请数据指针后，没有马上传给std::shared_ptr，因此一个可能的解决办法是：</p><pre><code>auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs());auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs());f(lhs, rhs);</code></pre><p>当然更好的方法是：</p><pre><code>f(std::make_shared&lt;Lhs&gt;(),    std::make_shared&lt;Rhs&gt;());</code></pre><p>make_shared的缺点<br>因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。</p><p>什么是weak_ptr？<br>weak_ptr是用来指向shared_ptr，用来判断shared_ptr指向的数据内存是否还存在了（通过方法lock），下面是一段示例代码：</p><pre><code>#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;struct A&#123;    int _i;    A(): _i(int())&#123;&#125;    A(int i): _i(i)&#123;&#125;&#125;;int main()&#123;    shared_ptr&lt;A&gt; sharedPtr(new A(2));    weak_ptr&lt;A&gt; weakPtr = sharedPtr;    sharedPtr.reset(new A(3)); // reset，weakPtr指向的失效了。    cout &lt;&lt; weakPtr.use_count() &lt;&lt;endl;&#125;</code></pre><p>通过lock（）来判断是否存在了，lock（）相当于</p><pre><code>expired（）？shared_ptr&lt;element_type&gt;() ： shared_ptr&lt;element_type&gt;(*this)</code></pre><p>当不存在的时候，会返回一个空的shared_ptr，weak_ptr在指向shared_ptr的时候，并不会增加ref count，因此weak_ptr主要有两个用途：</p><ul><li>用来记录对象是否存在了</li><li>用来解决shared_ptr环形依赖问题</li></ul><h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a>map和set</h2><p>底层红黑树，剩下不会了</p><h2 id="迭代器作用-迭代器和指针的区别"><a href="#迭代器作用-迭代器和指针的区别" class="headerlink" title="迭代器作用 迭代器和指针的区别"></a>迭代器作用 迭代器和指针的区别</h2><p><a href="https://whl963854.github.io/p/2cf69f40.html">https://whl963854.github.io/p/2cf69f40.html</a></p><h2 id="析构函数作用"><a href="#析构函数作用" class="headerlink" title="析构函数作用"></a>析构函数作用</h2><p>完成一些清理工作，比如：释放内存等。</p><h2 id="static关键字在C-中有什么作用？"><a href="#static关键字在C-中有什么作用？" class="headerlink" title="static关键字在C++中有什么作用？"></a>static关键字在C++中有什么作用？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰的类的数据成员怎么初始化的？"><a href="#static修饰的类的数据成员怎么初始化的？" class="headerlink" title="static修饰的类的数据成员怎么初始化的？"></a>static修饰的类的数据成员怎么初始化的？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"><a href="#static修饰类的成员函数，这个成员函数使用起来有哪些限制？" class="headerlink" title="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"></a>static修饰类的成员函数，这个成员函数使用起来有哪些限制？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="知道哪些c-中的关键字，然后讲了static"><a href="#知道哪些c-中的关键字，然后讲了static" class="headerlink" title="知道哪些c++中的关键字，然后讲了static"></a>知道哪些c++中的关键字，然后讲了static</h2><h2 id="static变量存储在哪，和局部变量存储位置有什么区别"><a href="#static变量存储在哪，和局部变量存储位置有什么区别" class="headerlink" title="static变量存储在哪，和局部变量存储位置有什么区别?"></a>static变量存储在哪，和局部变量存储位置有什么区别?</h2><h2 id="C-你觉得最特别于其他语言的点是什么"><a href="#C-你觉得最特别于其他语言的点是什么" class="headerlink" title="C++你觉得最特别于其他语言的点是什么"></a>C++你觉得最特别于其他语言的点是什么</h2><h2 id="java，python，c-垃圾回收怎么实现的"><a href="#java，python，c-垃圾回收怎么实现的" class="headerlink" title="java，python，c++垃圾回收怎么实现的"></a>java，python，c++垃圾回收怎么实现的</h2><h2 id="指针和引用的区别，左值右值，右值引用"><a href="#指针和引用的区别，左值右值，右值引用" class="headerlink" title="指针和引用的区别，左值右值，右值引用"></a>指针和引用的区别，左值右值，右值引用</h2><p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>可以有const指针，但是没有const引用；<br>指针可以有多级，但是引用只能是一级<br>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或–</p><p>引用在汇编层面会被c++编译器当做const指针来进行操作</p><h2 id="说说对指针和引用的理解"><a href="#说说对指针和引用的理解" class="headerlink" title="说说对指针和引用的理解"></a>说说对指针和引用的理解</h2><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="堆和栈的区别。什么情况下会往堆里放"><a href="#堆和栈的区别。什么情况下会往堆里放" class="headerlink" title="堆和栈的区别。什么情况下会往堆里放"></a>堆和栈的区别。什么情况下会往堆里放</h2><p>new<br>malloc</p><h2 id="堆区都是手动释放？"><a href="#堆区都是手动释放？" class="headerlink" title="堆区都是手动释放？"></a>堆区都是手动释放？</h2><p>答：也不一定，主要看使用方法。如果使用的函数是malloc，new之类，就需要手动释放，不然会造成内存泄漏。但是如果我们使用智能指针，智能指针会自动释放内存，因为智能指针基于类自动调用析构函数实现了内存的自动释放</p><h2 id="C-哪些运算符不能重载？"><a href="#C-哪些运算符不能重载？" class="headerlink" title="C++哪些运算符不能重载？"></a>C++哪些运算符不能重载？</h2><p>答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p><p>以下运算符不能被重载：.、.*、::、? :、sizeof。<br>重载运算符()、[]、-&gt;、或者赋值运算符&#x3D;时，只能将它们重载为成员函数，不能重载为全局函数。</p><h2 id="char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别"><a href="#char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别" class="headerlink" title="char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别"></a>char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别</h2><p>4  3 size</p><h2 id="C-11的特性有没有"><a href="#C-11的特性有没有" class="headerlink" title="C++11的特性有没有"></a>C++11的特性有没有</h2><p>初始化列表 使用 {} 可以方便地初始化数组、结构体、类等对象<br>智能指针 引入了 std::unique_ptr、std::shared_ptr 等智能指针，方便地进行动态内存管理<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式 可以在函数内部定义匿名函数，从而方便地实现函数对象。<br>字符串字面量<br>auto 自动类型推导：使用关键字 auto 可以让编译器自动推导变量的类型。<br>枚举类<br>完美转发<br>移动语义 使用 &amp;&amp; 可以表示右值引用，引入了移动构造函数和移动赋值运算符，可以减少不必要的拷贝。<br>constexptr<br>静态断言 使用关键字 static_assert 可以在编译时检查一个表达式是否为 true<br>新的容器和算法：引入了 std::array、std::forward_list、std::unordered_map、std::move 等新特性，增强了容器和算法库的功能。</p><h2 id="聊一聊你理解的移动构造函数？"><a href="#聊一聊你理解的移动构造函数？" class="headerlink" title="聊一聊你理解的移动构造函数？"></a>聊一聊你理解的移动构造函数？</h2><p>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。</p><h2 id="那c-有哪些构造函数呢？"><a href="#那c-有哪些构造函数呢？" class="headerlink" title="那c++有哪些构造函数呢？"></a>那c++有哪些构造函数呢？</h2><p>答：默认构造函数，有参构造函数，拷贝构造函数，移动构造函数。<br>委托构造函数<br>继承构造函数</p><h2 id="介绍一下map容器？"><a href="#介绍一下map容器？" class="headerlink" title="介绍一下map容器？"></a>介绍一下map容器？</h2><p>答：map支持kv键值对的查找，底层基于红黑树，查询和插入的时间复杂度都是logn。因为底层基于红黑树，map的key是有序的，所以map容器为我们提供了一些有序的api，比如对key的二分查找(lower_bound）。与此同时，我们还有unoredered_map,这个容器是哈希表，查询和插入的时间复杂度是O(1)，但是如果遇上哈希冲突，复杂度可能退化到O(n)。这个容器的key是无序的。unordered_map的使用的常数时间是要比map快一到两倍。</p><h2 id="讲一讲const关键字。"><a href="#讲一讲const关键字。" class="headerlink" title="讲一讲const关键字。"></a>讲一讲const关键字。</h2><p>答：const关键字在C++11之前，具有只读和常量两个语义。在C++11，引入constexpr关键字之后，const语义固定在了只读，constexpr固定为常量，但总而言之，这个两个关键字核心的语义是，指向的内容不可更改。<br>const 关键字用于指定变量或对象的值是不可修改的。它可以用于修饰变量、函数参数、函数返回值和成员函数等。 constexpr 关键字用于指定表达式在编译时就能够被计算出结果，从而产生一个编译期常量。它可以用于修饰变量、函数、类和模板等。constexpr 的作用是在编译时进行计算，从而提高程序的性能。</p><h2 id="那const指向地址呢？"><a href="#那const指向地址呢？" class="headerlink" title="那const指向地址呢？"></a>那const指向地址呢？</h2><p>答：const指向的地址值不可更改，但是地址对应的内容是可更改的。</p><h2 id="const关键字修饰类的对象使用起来有什么限制？"><a href="#const关键字修饰类的对象使用起来有什么限制？" class="headerlink" title="const关键字修饰类的对象使用起来有什么限制？"></a>const关键字修饰类的对象使用起来有什么限制？</h2><p><a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="const关键字修饰类的对象有什么办法改变内部数据？"><a href="#const关键字修饰类的对象有什么办法改变内部数据？" class="headerlink" title="const关键字修饰类的对象有什么办法改变内部数据？"></a>const关键字修饰类的对象有什么办法改变内部数据？</h2><p>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="虚函数是什么，重载和重写的关系。"><a href="#虚函数是什么，重载和重写的关系。" class="headerlink" title="虚函数是什么，重载和重写的关系。"></a>虚函数是什么，重载和重写的关系。</h2><p>答：虚函数涉及到C++的多态。当、在基类中声明一个虚函数，在派生类中重写该函数，可以实现动态绑定。在运行时，程序会根据具体对象的类型调用相应的函数。重写要求函数签名完全一致，即函数名，函数变量和返回值完全一致，但是函数体可以不同。重写是运行时多态，也就是动态多态。重载是函数名相同，返回值和函数参数可以不同，重载是编译时多态，即静态多态。</p><h2 id="讲讲你理解的虚基类。"><a href="#讲讲你理解的虚基类。" class="headerlink" title="讲讲你理解的虚基类。"></a>讲讲你理解的虚基类。</h2><p>答：C++的虚基类类似Java的抽象类，是不可以实例化的。【这里回答错了】</p><p>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。虚基类是可以被实例化的。</p><h2 id="C-多态虚函数实现原理。虚函数表里面有哪些东西？"><a href="#C-多态虚函数实现原理。虚函数表里面有哪些东西？" class="headerlink" title="C++多态虚函数实现原理。虚函数表里面有哪些东西？"></a>C++多态虚函数实现原理。虚函数表里面有哪些东西？</h2><h2 id="虚函数和静态函数-虚表"><a href="#虚函数和静态函数-虚表" class="headerlink" title="虚函数和静态函数 虚表"></a>虚函数和静态函数 虚表</h2><h2 id="cpp编译生成二进制文件过程"><a href="#cpp编译生成二进制文件过程" class="headerlink" title=".cpp编译生成二进制文件过程"></a>.cpp编译生成二进制文件过程</h2><p><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><h2 id="C-从源程序到可执行程序的过程"><a href="#C-从源程序到可执行程序的过程" class="headerlink" title="C++从源程序到可执行程序的过程"></a>C++从源程序到可执行程序的过程</h2><h2 id="动态链接和静态链接区别。"><a href="#动态链接和静态链接区别。" class="headerlink" title="动态链接和静态链接区别。"></a>动态链接和静态链接区别。</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="如何优化一个c-程序-局部性"><a href="#如何优化一个c-程序-局部性" class="headerlink" title="如何优化一个c++程序,局部性"></a>如何优化一个c++程序,局部性</h2><p>时间局部性<br>空间局部性</p><h2 id="左值，右值，万能引用，完美转发"><a href="#左值，右值，万能引用，完美转发" class="headerlink" title="左值，右值，万能引用，完美转发"></a>左值，右值，万能引用，完美转发</h2><p><a href="https://whl963854.github.io/p/64657.html">https://whl963854.github.io/p/64657.html</a><br><a href="https://whl963854.github.io/p/3763.html">https://whl963854.github.io/p/3763.html</a><br><a href="https://whl963854.github.io/p/50074.html">https://whl963854.github.io/p/50074.html</a></p><h2 id="STL基本容器用过哪些"><a href="#STL基本容器用过哪些" class="headerlink" title="STL基本容器用过哪些"></a>STL基本容器用过哪些</h2><p>vector<br>string<br>stack<br>queue<br>set<br>map</p><h2 id="能说一下内存泄漏发生的情景吗"><a href="#能说一下内存泄漏发生的情景吗" class="headerlink" title="能说一下内存泄漏发生的情景吗"></a>能说一下内存泄漏发生的情景吗</h2><p>忘了释放内存资源</p><h2 id="size-of是在编译期还是在运行期确定"><a href="#size-of是在编译期还是在运行期确定" class="headerlink" title="size_of是在编译期还是在运行期确定"></a>size_of是在编译期还是在运行期确定</h2><p>sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。</p><h2 id="C-如何调整内存对齐值"><a href="#C-如何调整内存对齐值" class="headerlink" title="C++ 如何调整内存对齐值"></a>C++ 如何调整内存对齐值</h2><p>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</p><h2 id="主机大小端序"><a href="#主机大小端序" class="headerlink" title="主机大小端序"></a>主机大小端序</h2><p>C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的x86处理器是小端模式（Little Endian）。Java编写的程序则唯一采用Big Endian方式来存储数据。</p><h3 id="C-Coroutine"><a href="#C-Coroutine" class="headerlink" title="C++ Coroutine"></a>C++ Coroutine</h3><h2 id="C-虚函数-gt-构造函数能否是虚函数，析构函数"><a href="#C-虚函数-gt-构造函数能否是虚函数，析构函数" class="headerlink" title="C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数"></a>C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数</h2><p>构造不可以<br>析构可</p><h2 id="构造函数能否是虚函数？"><a href="#构造函数能否是虚函数？" class="headerlink" title="构造函数能否是虚函数？"></a>构造函数能否是虚函数？</h2><p>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。</p><p>虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。</p><p>vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。</p><p>如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。</p><p>因此，构造函数不可以是虚函数。</p><h2 id="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"><a href="#多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？" class="headerlink" title="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"></a>多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？</h2><p>使用多线程和使用多进程的选择取决于您的应用程序的需求。</p><p>多线程：在同一个进程中创建多个线程，多个线程共享进程的内存空间，因此它们可以很容易地共享数据，而且通信成本更低。因此，如果您的应用程序需要在单个进程内部并行执行不同任务，并且需要共享大量数据，则多线程是一个很好的选择。</p><p>多进程：当您的应用程序需要在不同的进程之间并行执行任务时，您可以使用多进程。不同进程之间的通信通常比同一进程中的通信慢，但它们拥有完全独立的内存空间，因此不存在内存访问冲突的问题。</p><p>总的来说，多线程适用于在单个进程中并行执行任务，并且需要共享大量数据的情况，而多进程适用于在不同进程中并行执行任务的情况。</p><h2 id="你这个项目是多线程的，那用多进程可不可以实现？"><a href="#你这个项目是多线程的，那用多进程可不可以实现？" class="headerlink" title="你这个项目是多线程的，那用多进程可不可以实现？"></a>你这个项目是多线程的，那用多进程可不可以实现？</h2><h2 id="项目相关介绍一下"><a href="#项目相关介绍一下" class="headerlink" title="项目相关介绍一下"></a>项目相关介绍一下</h2><h2 id="进程和线程的区别。"><a href="#进程和线程的区别。" class="headerlink" title="进程和线程的区别。"></a>进程和线程的区别。</h2><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="为什么要用多线程。多进程可以吗（webserver的）"><a href="#为什么要用多线程。多进程可以吗（webserver的）" class="headerlink" title="为什么要用多线程。多进程可以吗（webserver的）"></a>为什么要用多线程。多进程可以吗（webserver的）</h2><h2 id="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"><a href="#了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？" class="headerlink" title="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"></a>了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？</h2><h2 id="线程池中的队列知道吗？队列是无限大的还是有限的"><a href="#线程池中的队列知道吗？队列是无限大的还是有限的" class="headerlink" title="线程池中的队列知道吗？队列是无限大的还是有限的"></a>线程池中的队列知道吗？队列是无限大的还是有限的</h2><h2 id="介绍一下线程的几种状态。"><a href="#介绍一下线程的几种状态。" class="headerlink" title="介绍一下线程的几种状态。"></a>介绍一下线程的几种状态。</h2><h2 id="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"><a href="#一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？" class="headerlink" title="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"></a>一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？</h2><h2 id="了解线程池吗？大概介绍一下"><a href="#了解线程池吗？大概介绍一下" class="headerlink" title="了解线程池吗？大概介绍一下"></a>了解线程池吗？大概介绍一下</h2><h2 id="多线程会发生什么问题？线程同步有哪些手段？"><a href="#多线程会发生什么问题？线程同步有哪些手段？" class="headerlink" title="多线程会发生什么问题？线程同步有哪些手段？"></a>多线程会发生什么问题？线程同步有哪些手段？</h2><h2 id="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"><a href="#什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？" class="headerlink" title="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"></a>什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？</h2><h2 id="说说对设计模式的理解"><a href="#说说对设计模式的理解" class="headerlink" title="说说对设计模式的理解"></a>说说对设计模式的理解</h2><h2 id="了解设计模式吗？介绍一下单例模式"><a href="#了解设计模式吗？介绍一下单例模式" class="headerlink" title="了解设计模式吗？介绍一下单例模式"></a>了解设计模式吗？介绍一下单例模式</h2><h2 id="了解的设计模式"><a href="#了解的设计模式" class="headerlink" title="了解的设计模式"></a>了解的设计模式</h2><p>单例<br>组件</p><h2 id="手撕一个设计模式"><a href="#手撕一个设计模式" class="headerlink" title="手撕一个设计模式"></a>手撕一个设计模式</h2><h2 id="手写一个单例模式"><a href="#手写一个单例模式" class="headerlink" title="手写一个单例模式"></a>手写一个单例模式</h2><h2 id="设计模式几大原则"><a href="#设计模式几大原则" class="headerlink" title="设计模式几大原则"></a>设计模式几大原则</h2><h2 id="手撕单例模式（懒汉模式）"><a href="#手撕单例模式（懒汉模式）" class="headerlink" title="手撕单例模式（懒汉模式）"></a>手撕单例模式（懒汉模式）</h2><h2 id="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"><a href="#情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统" class="headerlink" title="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"></a>情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统</h2><h2 id="模板元编程（简历上写了，但答的不好）"><a href="#模板元编程（简历上写了，但答的不好）" class="headerlink" title="模板元编程（简历上写了，但答的不好）"></a>模板元编程（简历上写了，但答的不好）</h2><h2 id="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"><a href="#编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的" class="headerlink" title="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"></a>编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的</h2><h2 id="怎么debug，怎么看内存泄漏。"><a href="#怎么debug，怎么看内存泄漏。" class="headerlink" title="怎么debug，怎么看内存泄漏。"></a>怎么debug，怎么看内存泄漏。</h2><h2 id="介绍一下条件变量"><a href="#介绍一下条件变量" class="headerlink" title="介绍一下条件变量"></a>介绍一下条件变量</h2><h2 id="一个对象-x3D-另一个对象会发生什么（赋值构造函数）"><a href="#一个对象-x3D-另一个对象会发生什么（赋值构造函数）" class="headerlink" title="一个对象&#x3D;另一个对象会发生什么（赋值构造函数）"></a>一个对象&#x3D;另一个对象会发生什么（赋值构造函数）</h2><h2 id="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"><a href="#如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）" class="headerlink" title="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"></a>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）</h2><h2 id="py修饰器"><a href="#py修饰器" class="headerlink" title="py修饰器"></a>py修饰器</h2><h2 id="函数重载的机制。重载是在编译期还是在运行期确定"><a href="#函数重载的机制。重载是在编译期还是在运行期确定" class="headerlink" title="函数重载的机制。重载是在编译期还是在运行期确定"></a>函数重载的机制。重载是在编译期还是在运行期确定</h2><h2 id="hash表数据很大。rehash的代价很高，怎么办"><a href="#hash表数据很大。rehash的代价很高，怎么办" class="headerlink" title="hash表数据很大。rehash的代价很高，怎么办"></a>hash表数据很大。rehash的代价很高，怎么办</h2><p>为字典的备用哈希表分配空间：</p><p>如果执行的是扩展操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)*2 的 2n（2 的 n 次方幂）</p><p>如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)的 2n</p><p>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始（为-1 时表示没有进行 rehash）。</p><p>rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当一次 rehash 工作完成之后，程序将 rehashidx 属性的值+1。同时在 serverCron 中调用 rehash 相关函数，在 1ms 的时间内，进行 rehash 处理，每次仅处理少量的转移任务(100 个元素)。</p><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为-1，表示 rehash 操作已完成。</p><h2 id="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"><a href="#最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。" class="headerlink" title="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"></a>最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。</h2><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h2 id="二叉树应用场景-底层结构"><a href="#二叉树应用场景-底层结构" class="headerlink" title="二叉树应用场景 底层结构"></a>二叉树应用场景 底层结构</h2><h2 id="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"><a href="#说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的" class="headerlink" title="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"></a>说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的</h2><h2 id="了解哪些算法，说一点———–我说了排序"><a href="#了解哪些算法，说一点———–我说了排序" class="headerlink" title="了解哪些算法，说一点———–我说了排序"></a>了解哪些算法，说一点———–我说了排序</h2><h2 id="介绍下快速排序的过程"><a href="#介绍下快速排序的过程" class="headerlink" title="介绍下快速排序的过程"></a>介绍下快速排序的过程</h2><h2 id="栈和队列的区别，在实际应用中的场景"><a href="#栈和队列的区别，在实际应用中的场景" class="headerlink" title="栈和队列的区别，在实际应用中的场景"></a>栈和队列的区别，在实际应用中的场景</h2><p>队列</p><p>队列是一种先进先出的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；<br>打印机：当多个任务分配给打印机时，为了防止冲突，创建一个队列，把任务入队，按先入先出的原则处理任务；<br>远程服务器：当多个用户要访问远程服务端的文件时，也用到队列，满足先来先服务的原则；<br>队列理论：用来计算 预测用户在队中的等待时间，队的长度等等问题；<br>常用于处理任务请求队列，例如在操作系统内部处理进程队列、在网络传输协议中处理数据包队列等。</p><p>栈</p><p>栈是一种后进先出的数据结构，也就是说最新添加的项最早被移出；它是一种运算受限的线性表，只能在栈顶进行插入和删除操作。向一个栈插入新元素叫入栈（进栈），就是把新元素放入到栈顶的上面，成为新的栈顶；从一个栈删除元素叫出栈，就是把栈顶的元素删除掉，相邻的成为新栈顶。</p><p>用于符号的匹配：在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。<br>用于计算代数式：如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题；先要把代数式构造成 6 4 8 * + 的形式；逐个读取数据，当读到数字时，把数字入栈；读到运算符时，弹出栈中的两个元素进行运算并把结果压入栈中；<br>构造表达式：比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。（先规定优先级，加减的优先级最低，左括号优先级最高）<br>用于函数调用：因为CPU一次只能执行一个命令，而寄存器也是公用的，当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()。能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。target() 函数执行结束就取栈顶的返回地址继续执行 current()。</p><h2 id="手撕二分查找。"><a href="#手撕二分查找。" class="headerlink" title="手撕二分查找。"></a>手撕二分查找。</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>招商银行</title>
      <link href="/p/26e6c52c.html"/>
      <url>/p/26e6c52c.html</url>
      
        <content type="html"><![CDATA[<h1 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"><a href="#介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别" class="headerlink" title="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"></a>介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别</h3><h3 id="Innodb的事务和锁机制"><a href="#Innodb的事务和锁机制" class="headerlink" title="Innodb的事务和锁机制"></a>Innodb的事务和锁机制</h3><h3 id="Mysql如何保证事务的一致性，MVCC与锁介绍"><a href="#Mysql如何保证事务的一致性，MVCC与锁介绍" class="headerlink" title="Mysql如何保证事务的一致性，MVCC与锁介绍"></a>Mysql如何保证事务的一致性，MVCC与锁介绍</h3><h3 id="Innodb和Myisam的索引机制和存储结构"><a href="#Innodb和Myisam的索引机制和存储结构" class="headerlink" title="Innodb和Myisam的索引机制和存储结构"></a>Innodb和Myisam的索引机制和存储结构</h3><h3 id="Mysql的各种日志，以及介绍用途"><a href="#Mysql的各种日志，以及介绍用途" class="headerlink" title="Mysql的各种日志，以及介绍用途"></a>Mysql的各种日志，以及介绍用途</h3><h3 id="何时使用索引，什么时候索引会失效"><a href="#何时使用索引，什么时候索引会失效" class="headerlink" title="何时使用索引，什么时候索引会失效"></a>何时使用索引，什么时候索引会失效</h3><h3 id="单表访问用到的索引"><a href="#单表访问用到的索引" class="headerlink" title="单表访问用到的索引"></a>单表访问用到的索引</h3><h3 id="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"><a href="#查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析" class="headerlink" title="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"></a>查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析</h3><h3 id="如何解决sql注入"><a href="#如何解决sql注入" class="headerlink" title="如何解决sql注入"></a>如何解决sql注入</h3><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="你还有什么我没看到的优点，可以说一说（我是懵的）"><a href="#你还有什么我没看到的优点，可以说一说（我是懵的）" class="headerlink" title="你还有什么我没看到的优点，可以说一说（我是懵的）"></a>你还有什么我没看到的优点，可以说一说（我是懵的）</h3><h3 id="对工科有什么看法？？？"><a href="#对工科有什么看法？？？" class="headerlink" title="对工科有什么看法？？？"></a>对工科有什么看法？？？</h3><h3 id="开始问项目经验，项目经历-——————-出乎意料"><a href="#开始问项目经验，项目经历-——————-出乎意料" class="headerlink" title="开始问项目经验，项目经历 ——————- 出乎意料"></a>开始问项目经验，项目经历 ——————- 出乎意料</h3><h3 id="项目中怎么做的，遇到最大的问题是什么？你有什么突破"><a href="#项目中怎么做的，遇到最大的问题是什么？你有什么突破" class="headerlink" title="项目中怎么做的，遇到最大的问题是什么？你有什么突破"></a>项目中怎么做的，遇到最大的问题是什么？你有什么突破</h3><h3 id="如果不把他当成hr-会怎么描述这个项目？"><a href="#如果不把他当成hr-会怎么描述这个项目？" class="headerlink" title="如果不把他当成hr, 会怎么描述这个项目？"></a>如果不把他当成hr, 会怎么描述这个项目？</h3><h3 id="这个项目在实际中是怎么使用的？"><a href="#这个项目在实际中是怎么使用的？" class="headerlink" title="这个项目在实际中是怎么使用的？"></a>这个项目在实际中是怎么使用的？</h3><h3 id="去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？"><a href="#去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？" class="headerlink" title="去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？"></a>去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？</h3><h3 id="最有成就感的事情？"><a href="#最有成就感的事情？" class="headerlink" title="最有成就感的事情？"></a>最有成就感的事情？</h3><h3 id="对自己的优缺点评价？"><a href="#对自己的优缺点评价？" class="headerlink" title="对自己的优缺点评价？"></a>对自己的优缺点评价？</h3><h3 id="转Java愿意吗？"><a href="#转Java愿意吗？" class="headerlink" title="转Java愿意吗？"></a>转Java愿意吗？</h3><h3 id="对其他编程语言的看法？"><a href="#对其他编程语言的看法？" class="headerlink" title="对其他编程语言的看法？"></a>对其他编程语言的看法？</h3><h3 id="工作地倾向？"><a href="#工作地倾向？" class="headerlink" title="工作地倾向？"></a>工作地倾向？</h3><h3 id="目前投的其他岗位是什么情况？"><a href="#目前投的其他岗位是什么情况？" class="headerlink" title="目前投的其他岗位是什么情况？"></a>目前投的其他岗位是什么情况？</h3><h3 id="你有什么问题"><a href="#你有什么问题" class="headerlink" title="你有什么问题"></a>你有什么问题</h3><h3 id="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"><a href="#我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。" class="headerlink" title="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"></a>我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。</h3><h3 id="项目过程中遇到的问题"><a href="#项目过程中遇到的问题" class="headerlink" title="项目过程中遇到的问题"></a>项目过程中遇到的问题</h3><h3 id="最近学了什么、学习方法是什么"><a href="#最近学了什么、学习方法是什么" class="headerlink" title="最近学了什么、学习方法是什么"></a>最近学了什么、学习方法是什么</h3><h3 id="对新入手的项目有没有什么学习技巧"><a href="#对新入手的项目有没有什么学习技巧" class="headerlink" title="对新入手的项目有没有什么学习技巧"></a>对新入手的项目有没有什么学习技巧</h3><h3 id="家庭情况"><a href="#家庭情况" class="headerlink" title="家庭情况"></a>家庭情况</h3><h3 id="base地的问题"><a href="#base地的问题" class="headerlink" title="base地的问题"></a>base地的问题</h3><h3 id="对加班的看法、最大能接受的加班强度"><a href="#对加班的看法、最大能接受的加班强度" class="headerlink" title="对加班的看法、最大能接受的加班强度"></a>对加班的看法、最大能接受的加班强度</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++新特性</title>
      <link href="/p/a70da3b7.html"/>
      <url>/p/a70da3b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="C-11-中的新特性"><a href="#C-11-中的新特性" class="headerlink" title="C++11 中的新特性"></a>C++11 中的新特性</h2><p>C++11 引入了许多新特性，包括自动类型推导、lambda 表达式、右值引用等。下面介绍其中的一些重要特性。</p><h3 id="自动类型推导（Type-Inference）"><a href="#自动类型推导（Type-Inference）" class="headerlink" title="自动类型推导（Type Inference）"></a>自动类型推导（Type Inference）</h3><p>C++11 中引入了 auto 关键字，它可以用于自动推导变量的类型。例如：</p><pre><code>auto i = 10; // 推导为 intauto name = &quot;John&quot;; // 推导为 const char*自动类型推导使得代码更加简洁，并且可以避免显式指定类型的麻烦。</code></pre><p>auto只能推导类型，推导出来的类型不能用来定义对象，decltype解决了这点，推导类型后可以用来定义对象。</p><pre><code>#include&lt;cstring&gt;int main()&#123;    int i = 10;    auto p = &amp;i;    decltype(p) pi;//int*    pi = &amp;i;    cout &lt;&lt; *pi &lt;&lt; endl;//10    return 0;&#125;</code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种用于定义匿名函数的语法。它可以在需要函数对象的地方使用，并且可以捕获上下文中的变量。例如：</p><pre><code>auto sum = [](int a, int b) &#123;    return a + b;&#125;;int result = sum(5, 3); // 调用 lambda 表达式</code></pre><p>Lambda 表达式提供了一种简洁的方式来定义和使用函数对象，特别是在需要传递函数作为参数的情况下。</p><h3 id="右值引用（Rvalue-References）"><a href="#右值引用（Rvalue-References）" class="headerlink" title="右值引用（Rvalue References）"></a>右值引用（Rvalue References）</h3><p>C++11 引入了右值引用，它允许我们绑定到临时对象（右值），并且可以实现移动语义和完美转发。右值引用由双引号 &amp;&amp; 表示。</p><h4 id="什么是左值和右值："><a href="#什么是左值和右值：" class="headerlink" title="什么是左值和右值："></a>什么是左值和右值：</h4><p>• 一般来说，位于&#x3D; 前的表达式为左值；存储在内存中、有明确存储地址（可取地址）的数据；<br>• 右值是指可以提供数据值的数据（不可取地址）。</p><pre><code>int&amp;&amp; rvalue = 42; // 绑定到右值 42</code></pre><h4 id="右值引用的主要作用和意义如下："><a href="#右值引用的主要作用和意义如下：" class="headerlink" title="右值引用的主要作用和意义如下："></a>右值引用的主要作用和意义如下：</h4><p>移动语义：右值引用可以用于实现移动语义，即将一个对象的资源所有权从一个对象转移给另一个对象，而不需要进行深拷贝或浅拷贝。例如：</p><pre><code>class MyString &#123;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_) &#123;        other.data_ = nullptr;        other.size_ = 0;    &#125;private:    char* data_;    size_t size_;&#125;;MyString str1(&quot;Hello&quot;);      // 创建一个 MyString 对象MyString str2(std::move(str1));  // 将 str1 转移给 str2</code></pre><p>在上述代码中，MyString 类定义了一个移动构造函数，用于将一个右值引用转移给一个新对象。在创建 str2 对象时，使用 std::move 函数将 str1 转移给 str2，从而避免了不必要的深拷贝和内存分配操作，提高了程序的性能和效率。</p><p>完美转发：右值引用可以用于实现完美转发，即在函数调用时将参数按照原样转发给其他函数，从而避免了不必要的复制和拷贝操作。例如：</p><pre><code>template&lt;typename T&gt;void process(T&amp;&amp; arg) &#123;    other_func(std::forward&lt;T&gt;(arg));  // 将 arg 按照原样转发给 other_func&#125;</code></pre><p>在上述代码中，process 函数接受一个右值引用参数 arg，并使用 std::forward 函数将 arg 按照原样转发给 other_func 函数，从而避免了不必要的复制和拷贝操作，提高了程序的性能和效率。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><pre><code>for (decl : expr) &#123;    // 循环体&#125;</code></pre><p>decl表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中.<br>expr是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。<br>基于范围的 for 循环遍历容器，示例代码如下：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123;    vector&lt;int&gt; t&#123; 1,2,3,4,5,6 &#125;;    for (const auto&amp; value : t) &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="C-14-中的新特性"><a href="#C-14-中的新特性" class="headerlink" title="C++14 中的新特性"></a>C++14 中的新特性</h2><p>C++14 对 C++11 进行了一些改进，并引入了一些新特性，例如变长模板参数、二进制字面量等。</p><h3 id="变长模板参数（Variadic-Templates）"><a href="#变长模板参数（Variadic-Templates）" class="headerlink" title="变长模板参数（Variadic Templates）"></a>变长模板参数（Variadic Templates）</h3><p>C++14 允许定义可变数量的模板参数，这被称为变长模板参数。通过使用省略号 …，可以在模板参数列表中指定任意数量的参数。例如：</p><pre><code>template &lt;typename... Args&gt;void print(Args... args) &#123;    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);&#125;print(1, &quot;hello&quot;, 3.14); // 输出: 1 hello 3.14</code></pre><p>变长模板参数提供了更大的灵活性，可以处理不同数量和类型的参数。   </p><h3 id="二进制字面量（Binary-Literals）"><a href="#二进制字面量（Binary-Literals）" class="headerlink" title="二进制字面量（Binary Literals）"></a>二进制字面量（Binary Literals）</h3><p>C++14 允许使用二进制字面量来表示二进制数值。使用前缀 0b 或 0B，后跟一串二进制数字。例如：</p><pre><code>int binary = 0b1010; // 二进制数值 10</code></pre><p>二进制字面量提供了一种直观和简洁的方式来表示和使用二进制数值。</p><h2 id="C-17-中的新特性"><a href="#C-17-中的新特性" class="headerlink" title="C++17 中的新特性"></a>C++17 中的新特性</h2><p>C++17 引入了一些有用的新特性，包括结构化绑定、折叠表达式、文件系统库等。</p><h3 id="结构化绑定（Structured-Bindings）"><a href="#结构化绑定（Structured-Bindings）" class="headerlink" title="结构化绑定（Structured Bindings）"></a>结构化绑定（Structured Bindings）</h3><p>结构化绑定允许将元组或其他复杂类型的成员解包并绑定到独立的变量中。这样可以方便地访问和操作复杂类型的成员。例如：</p><pre><code>std::pair&lt;int, std::string&gt; person&#123; 25, &quot;John&quot; &#125;;auto [age, name] = person;std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Name: &quot; &lt;&lt; name; // 输出: Age: 25, Name: John</code></pre><p>结构化绑定简化了处理复杂类型的过程，使代码更加简洁易读。</p><h3 id="折叠表达式（Fold-Expressions）"><a href="#折叠表达式（Fold-Expressions）" class="headerlink" title="折叠表达式（Fold Expressions）"></a>折叠表达式（Fold Expressions）</h3><p>折叠表达式是一种用于处理可变数量参数包的语法。它允许在模板展开过程中对参数包进行操作。例如：</p><pre><code>template &lt;typename... Args&gt;bool allTrue(Args... args) &#123;    return (true &amp;&amp; ... &amp;&amp; args);&#125;bool result = allTrue(true, true, false); // 返回 false</code></pre><p>折叠表达式提供了一种简洁的方式来处理参数包，可以在编译时对参数进行组合和计算。</p><h3 id="文件系统库（Filesystem-Library）"><a href="#文件系统库（Filesystem-Library）" class="headerlink" title="文件系统库（Filesystem Library）"></a>文件系统库（Filesystem Library）</h3><p>C++传统文件操作需要使用std::ifstream 和 std::ofstream 类：分别表示输入文件流和输出文件流，可以用于读写文件内容。例如:</p><pre><code>#include &lt;fstream&gt;#include &lt;iostream&gt;int main() &#123;    std::ifstream input_file(&quot;input.txt&quot;);  // 打开输入文件    if (!input_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open input file.\n&quot;;        return 1;    &#125;    std::ofstream output_file(&quot;output.txt&quot;);  // 打开输出文件    if (!output_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open output file.\n&quot;;        return 1;    &#125;    int num;    while (input_file &gt;&gt; num) &#123;  // 从输入文件中读取数字        output_file &lt;&lt; num * 2 &lt;&lt; &#39;\n&#39;;  // 将每个数字乘以 2 并写入输出文件    &#125;    input_file.close();   // 关闭输入文件    output_file.close();  // 关闭输出文件    return 0;&#125;</code></pre><p>C++17 引入了标准文件系统库，用于处理文件和目录的操作。该库提供了一组类和函数，用于创建、删除、移动、遍历文件和目录等操作。例如：</p><pre><code>#include &lt;filesystem&gt;namespace fs = std::filesystem;int main() &#123;    fs::path dir_path = &quot;dir&quot;;   // 定义目录路径    fs::create_directory(dir_path);  // 创建目录    fs::path file_path = dir_path / &quot;file.txt&quot;;  // 定义文件路径    fs::ofstream file(file_path);   // 打开文件    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file.\n&quot;;        return 1;    &#125;    file &lt;&lt; &quot;Hello, world!\n&quot;;  // 写入文件内容    file.close();  // 关闭文件    fs::remove(file_path);     // 删除文件    fs::remove(dir_path);      // 删除目录    return 0;&#125;</code></pre><p>文件系统库简化了文件和目录操作的实现，使得操作更加方便和可移植。</p><h2 id="C-20-中的新特性"><a href="#C-20-中的新特性" class="headerlink" title="C++20 中的新特性"></a>C++20 中的新特性</h2><p>C++20 引入了一系列新特性，包括概念、协程、三路比较运算符等。</p><h3 id="概念（Concepts）"><a href="#概念（Concepts）" class="headerlink" title="概念（Concepts）"></a>概念（Concepts）</h3><p>概念是 C++20 中的一项重要特性，用于对模板的类型参数进行约束。概念允许我们对类型进行条件检查，从而限制模板的实例化。例如：</p><pre><code>template &lt;typename T&gt;concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;template &lt;Arithmetic T&gt;T square(T value) &#123;    return value * value;&#125;int result = square(5); // 正确，T 为算术类型std::string str = &quot;hello&quot;;// 错误，T 不是算术类型int result = square(str);</code></pre><p>概念提供了一种声明式的方式来定义模板参数的约束条件，使代码更具表达力和安全性。</p><h3 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h3><p>C++20 引入了协程支持，使得异步编程更加简洁和可读。协程允许函数在执行期间暂停和恢复，以便于异步任务的处理。例如</p><pre><code>#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Generator &#123;    struct promise_type &#123;        int current_value;        auto get_return_object() &#123;            return Generator&#123; std::coroutine_handle&lt;promise_type&gt;::from_promise(*this) &#125;;        &#125;        auto initial_suspend() &#123;            return std::suspend_always&#123;&#125;;        &#125;        auto final_suspend() noexcept &#123;            return std::suspend_always&#123;&#125;;        &#125;        void return_void() &#123;&#125;        auto yield_value(int value) &#123;            current_value = value;            return std::suspend_always&#123;&#125;;        &#125;        void unhandled_exception() &#123;            std::terminate();        &#125;    &#125;;    std::coroutine_handle&lt;promise_type&gt; coroutine;    bool move_next() &#123;        coroutine.resume();        return !coroutine.done();    &#125;    int current_value() &#123;        return coroutine.promise().current_value;    &#125;&#125;;Generator generate() &#123;    co_yield 1;    co_yield 2;    co_yield 3;&#125;int main() &#123;    Generator generator = generate();    while (generator.move_next()) &#123;        std::cout &lt;&lt; generator.current_value() &lt;&lt; &quot; &quot;;    &#125;    // 输出: 1 2 3    return 0;&#125;</code></pre><p>协程提供了一种简洁的方式来编写异步代码，提高了代码的可读性和可维护性。</p><h3 id="三路比较运算符（Three-Way-Comparison）"><a href="#三路比较运算符（Three-Way-Comparison）" class="headerlink" title="三路比较运算符（Three-Way Comparison）"></a>三路比较运算符（Three-Way Comparison）</h3><p>C++20 引入了三路比较运算符（&lt;&#x3D;&gt;），用于比较对象的大小关系。它返回一个可比较的结果，可以是小于、等于或大于。例如：</p><pre><code>struct Person &#123;    std::string name;    int age;    auto operator&lt;=&gt;(const Person&amp; other) const = default;//auto表示函数的返回类型将由编译器自动推导.在这里，返回类型将会是一个 std::strong_ordering 类型，这是 C++20 引入的一种枚举类型，用于表示强制排序关系。//= default：这个关键字表示使用默认实现，即使用编译器自动生成的代码来实现这个成员函数。在这里，编译器会自动生成一个使用 spaceship 运算符比较对象的代码。&#125;;Person john&#123;&quot;John&quot;, 25&#125;;Person alice&#123;&quot;Alice&quot;, 30&#125;;if (john &lt; alice) &#123;    std::cout &lt;&lt; &quot;John is younger than Alice.&quot;;&#125; else if (john &gt; alice) &#123;    std::cout &lt;&lt; &quot;John is older than Alice.&quot;;&#125; else &#123;    std::cout &lt;&lt; &quot;John and Alice have the same age.&quot;;&#125;</code></pre><p>三路比较运算符简化了比较操作的实现，提供了一种统一和直观的比较语法。</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/p/2f57a694.html"/>
      <url>/p/2f57a694.html</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式是一种以字符串匹配为核心的强大的文本处理工具。通过一系列特殊字符和限定条件，正则表达式可以精确地描述一个文本片段的特征，从而达到将匹配的文本内容从整体文本中筛选出来的目的。它的核心功能就是在文本中查找符合指定规律的模式，这种模式可以是字符、字符组合或者字符范围，正则表达式就是定义这些规律的方式和规则。</p><h2 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h2><ul><li>字符匹配：<ul><li>普通字符：正则表达式中的普通字符表示自身，例如 a 匹配字符 “a”。</li><li>字符类：使用方括号 [ ] 来匹配一组字符中的任意一个字符，例如 [abc] 匹配字符 “a”、”b” 或 “c”。</li><li>转义字符：使用反斜杠 \ 来转义特殊字符，例如 . 匹配字符 “.”。</li></ul></li><li>重复匹配：<ul><li><em>：匹配前一个元素零次或多次，例如 a</em> 匹配零个或多个字符 “a”。</li><li>+：匹配前一个元素一次或多次，例如 a+ 匹配一个或多个字符 “a”。</li><li>?：匹配前一个元素零次或一次，例如 a? 匹配零个或一个字符 “a”。</li><li>{n}：匹配前一个元素恰好 n 次，例如 a{3} 匹配恰好三个字符 “a”。</li><li>{n,}：匹配前一个元素至少 n 次，例如 a{3,} 匹配至少三个字符 “a”。</li><li>{n,m}：匹配前一个元素至少 n 次，最多 m 次，例如 a{3,5} 匹配三到五个字符 “a”。</li></ul></li><li>特殊字符：<ul><li>.：匹配任意字符，除了换行符。</li><li>^：匹配输入字符串的开始位置。</li><li>$：匹配输入字符串的结束位置。</li><li>\b：匹配单词边界。</li><li>\d：匹配任意数字。</li><li>\w：匹配任意字母、数字或下划线。</li><li>\s：匹配任意空白字符。</li></ul></li><li>分组和捕获：<ul><li>()：用于分组，并且可以捕获分组的内容用于后续引用。</li></ul></li><li>选择符：<ul><li>|：用于在多个模式之间进行选择，例如 a|b 匹配字符 “a” 或 “b”。<br>这只是正则表达式的基本语法，还有更多高级的用法和特性。不同编程语言和工具对正则表达式的支持和语法也可能有所差异.</li></ul></li></ul><h2 id="C-和Qt-正则表达式的实现方法"><a href="#C-和Qt-正则表达式的实现方法" class="headerlink" title="C++ 和Qt 正则表达式的实现方法"></a>C++ 和Qt 正则表达式的实现方法</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>可以使用标准库中的正则表达式库 regex 来实现正则表达式的功能。以下是使用C++标准库的方法：<br>包含头文件：</p><pre><code>#include &lt;regex&gt;  </code></pre><p>创建正则表达式对象：</p><pre><code>std::regex regexObj(&quot;pattern&quot;);  //这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>std::string str = &quot;input string&quot;;  std::smatch match;  bool isMatch = std::regex_search(str, match, regexObj);  </code></pre><p>这里的 str 是你要匹配的字符串。match 是一个 std::smatch 对象,可以通过索引来访问匹配的子字符串,用于存储匹配结果。regex_search 函数用于搜索字符串中的第一个匹配项。</p><p>遍历匹配结果：</p><pre><code>for (size_t i = 0; i &lt; match.size(); ++i) &#123;      std::cout &lt;&lt; match[i] &lt;&lt; std::endl;  &#125;  </code></pre><h3 id="在Qt中"><a href="#在Qt中" class="headerlink" title="在Qt中"></a>在Qt中</h3><p>Qt提供了自己的正则表达式类 QRegularExpression 来处理正则表达式。以下是使用Qt的方法：<br>包含头文件：</p><pre><code>#include &lt;QRegularExpression&gt;  2. 创建正则表达式对象：QRegularExpression regexObj(&quot;pattern&quot;);  这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>QString str = &quot;input string&quot;;  QRegularExpressionMatch match = regexObj.match(str);  //这里的 str 是你要匹配的字符串。match 是一个 QRegularExpressionMatch 对象，用于存储匹配结果。match 对象提供了一组方法来访问匹配的子字符串。</code></pre><p>遍历匹配结果：</p><pre><code>while (match.hasMatch()) &#123;      QString matchedStr = match.captured();      // 处理匹配的子字符串      match = regexObj.match(str, match.capturedEnd());  &#125;  </code></pre><p>通过调用 captured 方法可以获取匹配的子字符串。capturedEnd 方法返回上一个匹配结束的位置，用于在字符串中继续搜索下一个匹配项。</p><h2 id="正则表达式的应用案例"><a href="#正则表达式的应用案例" class="headerlink" title="正则表达式的应用案例"></a>正则表达式的应用案例</h2><h3 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h3><p>以下是一个使用 Qt 的正则表达式实现文本匹配的示例：<br>    #include <QRegularExpression><br>    #include <QDebug>  </QDebug></QRegularExpression></p><pre><code>int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched word: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。该正则表达式会匹配由小写字母组成的单词,输出结果是整句话中的每个单词。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>以下是一个使用 Qt 的正则表达式实现字符串替换的示例：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QString replacedStr = str.replace(regex, &quot;REPLACED&quot;);      qDebug() &lt;&lt; &quot;Replaced string: &quot; &lt;&lt; replacedStr;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。然后，使用 replace 函数将匹配到的单词替换为 “REPLACED”。<br>输出结果会显示替换后的字符串：</p><pre><code>Replaced string: &quot;The REPLACED REPLACED REPLACED jumps over the REPLACED REPLACED.&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来实现字符串替换。</p><h3 id="提取字符串中的邮箱地址"><a href="#提取字符串中的邮箱地址" class="headerlink" title="提取字符串中的邮箱地址"></a>提取字符串中的邮箱地址</h3><p>下面使用 Qt 的正则表达式的实例，它演示了如何使用正则表达式来验证和提取字符串中的邮箱地址：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;My email is john.doe@example.com and another email is jane@example.com&quot;;      QRegularExpression regex(&quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched email: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>使用了一个正则表达式来匹配邮箱地址的模式。正则表达式 \b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b 匹配标准的邮箱地址格式。<br>输出结果会显示匹配到的邮箱地址：</p><pre><code>Matched email:  &quot;john.doe@example.com&quot;  Matched email:  &quot;jane@example.com&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来验证和提取字符串中的邮箱地址。</p><h2 id="正则表达式的扩展和优化"><a href="#正则表达式的扩展和优化" class="headerlink" title="正则表达式的扩展和优化"></a>正则表达式的扩展和优化</h2><h3 id="使用正则表达式的进阶技巧"><a href="#使用正则表达式的进阶技巧" class="headerlink" title="使用正则表达式的进阶技巧"></a>使用正则表达式的进阶技巧</h3><p>在Qt中，使用正则表达式进行一些进阶技巧的操作，可以增强正则表达式的功能和灵活性。以下是一些常见的Qt正则表达式的进阶技巧：</p><h4 id="捕获组（Capturing-Group）"><a href="#捕获组（Capturing-Group）" class="headerlink" title="捕获组（Capturing Group）"></a>捕获组（Capturing Group）</h4><p>使用括号将正则表达式的一部分括起来，可以将这部分内容作为一个捕获组。捕获组可以通过indexIn()函数的捕获组索引或capturedTexts()函数的捕获组名来获得匹配的子字符串。<br>QString input &#x3D; “Hello World”;<br>QRegExp regex(“Hello (\w+)”);  </p><p>if (regex.indexIn(input) !&#x3D; -1) {<br>    QString match &#x3D; regex.cap(0); &#x2F;&#x2F; 整个匹配的字符串<br>    QString capturingGroup &#x3D; regex.cap(1); &#x2F;&#x2F; 捕获组中的内容<br>}  </p><h4 id="替换（Replacement）："><a href="#替换（Replacement）：" class="headerlink" title="替换（Replacement）："></a>替换（Replacement）：</h4><p>使用QRegExp类的replace()函数可以进行替换操作，将匹配的部分替换为指定的内容。</p><pre><code>QString input = &quot;Hello, Alice!&quot;;  QRegExp regex(&quot;Alice&quot;);  QString replaced = input.replace(regex, &quot;Bob&quot;);  qDebug() &lt;&lt; &quot;Replaced: &quot; &lt;&lt; replaced; // Hello, Bob!  </code></pre><h4 id="最短匹配（Non-greedy）"><a href="#最短匹配（Non-greedy）" class="headerlink" title="最短匹配（Non-greedy）"></a>最短匹配（Non-greedy）</h4><p>使用问号（?）可以使量词变为最短匹配，即尽可能少地匹配字符。</p><pre><code>QString input = &quot;Hello &lt;b&gt;World&lt;/b&gt;!&quot;;  QRegExp regex(&quot;&lt;.*?&gt;&quot;);  int pos = regex.indexIn(input);  if (pos != -1) &#123;      QString match = regex.cap(0); // &lt;b&gt;  &#125;  </code></pre><h4 id="全局匹配（Global-Match）："><a href="#全局匹配（Global-Match）：" class="headerlink" title="全局匹配（Global Match）："></a>全局匹配（Global Match）：</h4><p>使用globalMatch()函数可以进行全局匹配，找到输入字符串中的所有匹配项。</p><pre><code>QString input = &quot;Hello, Alice! How are you, Alice?&quot;;  QRegExp regex(&quot;Alice&quot;);  QRegExpIterator iter(input, regex);  while (iter.hasNext()) &#123;      iter.next();      QString match = iter.value(); // Alice  &#125;  </code></pre><p>这些是一些Qt中正则表达式的进阶技巧，可以根据具体需求进行使用。</p><h3 id="利用正则表达式的编译器和解释器"><a href="#利用正则表达式的编译器和解释器" class="headerlink" title="利用正则表达式的编译器和解释器"></a>利用正则表达式的编译器和解释器</h3><p>在Qt中，有两个主要的正则表达式引擎：QRegExp和QRegularExpression。</p><h4 id="QRegExp"><a href="#QRegExp" class="headerlink" title="QRegExp"></a>QRegExp</h4><p>QRegExp是Qt早期版本中使用的正则表达式引擎。它基于C++标准库中的正则表达式功能，并在其基础上添加了一些Qt特定的扩展。QRegExp是一个解释器，它在运行时解释和匹配正则表达式。尽管QRegExp功能强大，但它不是完全兼容于Perl正则表达式语法，并且在处理大型文本时可能存在性能问题。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegExp regex(&quot;Hello (\\w+)&quot;);  if (regex.indexIn(input) != -1) &#123;      QString match = regex.cap(0); // 整个匹配的字符串      QString capturingGroup = regex.cap(1); // 捕获组中的内容  &#125;  </code></pre><h4 id="QRegularExpression"><a href="#QRegularExpression" class="headerlink" title="QRegularExpression"></a>QRegularExpression</h4><p>从Qt 5开始，引入了QRegularExpression作为新的正则表达式引擎。QRegularExpression是一个编译器，它在使用正则表达式之前将其编译成一个内部表示形式，这样可以提高效率。它也支持Perl正则表达式语法的大部分功能，并且在性能方面更优于QRegExp。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegularExpression regex(&quot;Hello (\\w+)&quot;);  QRegularExpressionMatch match = regex.match(input);  if (match.hasMatch()) &#123;      QString captured = match.captured(0); // 整个匹配的字符串      QString capturingGroup = match.captured(1); // 捕获组中的内容  &#125;  </code></pre><p>无论是QRegExp还是QRegularExpression，都可以用于正则表达式的匹配、搜索和替换等操作，但在新的代码中推荐使用QRegularExpression，以获得更好的性能和更强大的功能。</p><h4 id="正则表达式的插件和辅助工具"><a href="#正则表达式的插件和辅助工具" class="headerlink" title="正则表达式的插件和辅助工具"></a>正则表达式的插件和辅助工具</h4><p>有一些独立的正则表达式插件和辅助工具可用于不同的开发环境和编辑器。以下是一些常见的正则表达式插件和辅助工具：</p><ol><li>RegexBuddy：这是一个强大的独立工具，用于创建、调试和测试正则表达式。它提供了一个直观的界面，可以可视化地构建和编辑正则表达式，并提供实时的匹配结果和错误提示。</li><li>RegExpert：这是一个在线的正则表达式调试器和测试工具，可以帮助您验证和调试正则表达式。它提供了一个交互式界面，可以实时检查输入文本的匹配结果，并显示匹配的子字符串和捕获组。</li><li>regex101：这是一个在线的正则表达式测试和学习平台，提供了一个交互式界面，可以输入正则表达式和测试文本，并实时显示匹配结果、捕获组和匹配的解释。</li><li>RegExr：这是一个基于Web的正则表达式工具，提供了一个交互式界面，可以可视化地构建和测试正则表达式。它还提供了实时的匹配结果和错误提示，以及一个正则表达式库和示例。<br>这些正则表达式插件和辅助工具可以帮助您更方便地创建、调试和测试正则表达式，提高开发效率和准确性。</li></ol><h2 id="正则表达式的陷阱和注意事项"><a href="#正则表达式的陷阱和注意事项" class="headerlink" title="正则表达式的陷阱和注意事项"></a>正则表达式的陷阱和注意事项</h2><p>在使用正则表达式时，有一些常见的陷阱和注意事项需要注意。以下是一些常见的陷阱和注意事项：</p><ul><li>贪婪匹配：默认情况下，正则表达式是贪婪匹配的，即它会尽可能多地匹配字符。如果您想要最短匹配，可以使用非贪婪量词（如*?，+?，??）或限定符的最小化形式。</li><li>转义字符：在正则表达式中，某些字符具有特殊含义，如点号（.）、星号（<em>）、加号（+）、问号（?）等。如果需要匹配这些特殊字符本身，需要使用反斜杠进行转义（如.、</em>、+、?）。</li><li>转义序列：正则表达式中有一些特殊的转义序列，如\d表示任意一个数字字符，\w表示任意一个字母、数字或下划线字符。这些转义序列可以用于简化正则表达式的编写。</li><li>字符边界：在正则表达式中，\b表示单词边界，即单词字符和非单词字符之间的位置。但请注意，\b在C++字符串中也是转义字符，所以需要使用双反斜杠（\b）来匹配单词边界。</li><li>捕获组编号：在一些正则表达式引擎中，捕获组的编号是从1开始的，而不是从0开始。因此，在访问捕获组时需要注意编号的对应关系。</li><li>性能问题：某些复杂的正则表达式可能会导致性能问题，特别是在处理大型文本时。尽量避免使用过于复杂的正则表达式，可以考虑将其拆分为多个简单的正则表达式。</li><li>Unicode支持：如果需要处理Unicode字符，确保使用支持Unicode的正则表达式引擎，并使用相应的Unicode转义序列和属性。</li><li>测试和验证：在编写正则表达式之前，建议使用测试工具或在线正则表达式测试平台来验证和调试您的正则表达式，以确保其正确性和预期的匹配结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>database/sql</title>
      <link href="/p/cacc0385.html"/>
      <url>/p/cacc0385.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用-database-x2F-sql-在-Go-中进行数据库操作的简介"><a href="#使用-database-x2F-sql-在-Go-中进行数据库操作的简介" class="headerlink" title="使用 database&#x2F;sql 在 Go 中进行数据库操作的简介"></a>使用 database&#x2F;sql 在 Go 中进行数据库操作的简介</h1><p>公司需要用到database&#x2F;sql，在 Go 中使用 SQL 或类似 SQL 的数据库的惯用方法是通过 database&#x2F;sql 包。它为面向行的数据库提供了一个轻量级接口。看完以后觉得和JDBC差不多。英语无障碍可以参照<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sql.DB</code> 并不是直接的数据库连接，它是数据库的抽象接口，它也不映射到任何特定数据库软件的“数据库”或“模式”概念。数据库可能像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。。它负责打开和关闭数据库连接，并管理连接池。正在使用的连接会被标记为繁忙，用完后会返回连接池等待下次使用。如果没有将连接释放回连接池，可能导致过多连接，从而耗尽系统资源。sql.DB不是数据库连接。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>要连接数据库，我们首先需要导入相应的驱动，具体取决于我们使用的数据库。例如，我们考虑使用 MySQL：</p><pre><code class="go">import (    &quot;database/sql&quot;    _ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123;    db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)    if err != nil &#123;        log.Fatal(err)    &#125;    defer db.Close()&#125;</code></pre><p><code>sql.Open()</code> 函数的第一个参数是驱动名称，第二个参数是连接数据库的信息。我们可以立即使用 <code>Ping()</code> 方法验证连接。</p><pre><code class="go">err = db.Ping()if err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>需要注意的是，<code>sql.DB</code> 被设计为长连接。频繁地进行 <code>Open()</code> 和 <code>Close()</code> 操作是不推荐的。最佳实践是为每个不同的数据存储创建一个 <code>DB</code> 对象，并保持这些对象的打开状态。如果需要短连接，请将 <code>DB</code> 对象作为参数传递给函数，而不是在函数中打开和关闭连接。</p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>如果方法涉及查询并返回多行结果，我们可以使用 <code>Query()</code>。对于其他操作，例如 INSERT、UPDATE 和 DELETE，我们使用 <code>Exec()</code>。</p><pre><code class="go">var (    id   int    name string)rows, err := db.Query(&quot;SELECT id, name FROM users WHERE id = ?&quot;, 1)if err != nil &#123;    log.Fatal(err)&#125;defer rows.Close()for rows.Next() &#123;    err := rows.Scan(&amp;id, &amp;name)    if err != nil &#123;        log.Fatal(err)    &#125;    log.Println(id, name)&#125;err = rows.Err()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><p>在迭代行时务必检查错误，并使用 <code>rows.Close()</code> 关闭结果集以释放底层连接。</p><p>对于单行查询，我们可以使用 <code>QueryRow()</code>：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    log.Fatal(err)&#125;fmt.Println(name)</code></pre><h2 id="修改数据和事务"><a href="#修改数据和事务" class="headerlink" title="修改数据和事务"></a>修改数据和事务</h2><p>对于 INSERT、UPDATE 和 DELETE 操作，我们使用预编译语句和 <code>Exec()</code>：<br>预处理执行过程：</p><ul><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ul><p>为什么要预处理？</p><ul><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ul><pre><code class="go">stmt, err := db.Prepare(&quot;INSERT INTO users (name) VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;res, err := stmt.Exec(&quot;Dolly&quot;)if err != nil &#123;    log.Fatal(err)&#125;lastId, err := res.LastInsertId()if err != nil &#123;    log.Fatal(err)&#125;rowCnt, err := res.RowsAffected()if err != nil &#123;    log.Fatal(err)&#125;log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)</code></pre><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。<br>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><p>要执行事务，我们使用 <code>Begin()</code>、<code>Commit()</code> 和 <code>Rollback()</code>：</p><pre><code class="go">tx, err := db.Begin()if err != nil &#123;    log.Fatal(err)&#125;defer tx.Rollback()stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;defer stmt.Close()for i := 0; i &lt; 10; i++ &#123;    _, err = stmt.Exec(i)    if err != nil &#123;        log.Fatal(err)    &#125;&#125;err = tx.Commit()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在与数据库交互时，适当处理错误非常重要。例如，在迭代 <code>Rows</code> 时检查错误并关闭结果集：</p><pre><code class="go">for rows.Next() &#123;    // ...&#125;if err = rows.Err(); err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>如果在迭代所有行之前退出循环，必须手动关闭结果集并处理错误：</p><pre><code class="go">for rows.Next() &#123;    // ...    break&#125;if err = rows.Close(); err != nil &#123;    log.Println(err)&#125;</code></pre><p>对于单行查询，需要单独处理 <code>ErrNoRows</code> 错误：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    if err == sql.ErrNoRows &#123;        // 处理没有找到行的情况    &#125; else &#123;        log.Fatal(err)    &#125;&#125;fmt.Println(name)</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七层协议</title>
      <link href="/p/e431c708.html"/>
      <url>/p/e431c708.html</url>
      
        <content type="html"><![CDATA[<p>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线<br>数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）<br>传输层：TCP（T&#x2F;TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS&#x2F;SSL<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP&#x2F;2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP</p><h2 id="TCP和UDP的-区别"><a href="#TCP和UDP的-区别" class="headerlink" title="TCP和UDP的 区别"></a>TCP和UDP的 区别</h2><p>TCP是面向有连接型，UDP是面向无连接型；<br>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；<br>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；<br>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http和https</title>
      <link href="/p/36b011d7.html"/>
      <url>/p/36b011d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP：80端口<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><p>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议的主要特点可概括如下：<br>1、支持客户&#x2F;服务器模式。支持基本认证和安全认证。<br>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。<br>5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。<br>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p><p>一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。一般http中存在如下问题：</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h4 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h4><p>减少重定向请求次数；<br>合并请求；<br>延迟发送请求；</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。<br>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。<br>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递<br>如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了，直接通过代理服务器重新请求，而不是客户端重新请求，更进一步，如果代理服务器缓存了重定向网站可以直接向服务端发送请求。</p><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP&#x2F;1.1 管道模式是默认不使用的，所以讨论 HTTP&#x2F;1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。<br>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。</p><p>按需获取的方式，来减少第一时间的 HTTP 请求次数。请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><p>头部压缩<br>二进制格式<br>并发传输<br>服务器主动推送资源</p><h4 id="头部压缩（Header-Compression）"><a href="#头部压缩（Header-Compression）" class="headerlink" title="头部压缩（Header Compression）"></a>头部压缩（Header Compression）</h4><p>http1.x的头带有大量信息，而且每次都要重复发送。http&#x2F;2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p><p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><p>需要注意的是，http 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p><p>http&#x2F;2使用的是专门为首部压缩而设计的HPACK②算法。<br>用header字段表里的索引代替实际的header。</p><p>http&#x2F;2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>http2.0之所以能够突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p><p>在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><h4 id="多路复用-Multiplexing-x2F-连接共享"><a href="#多路复用-Multiplexing-x2F-连接共享" class="headerlink" title="多路复用 (Multiplexing) &#x2F; 连接共享"></a>多路复用 (Multiplexing) &#x2F; 连接共享</h4><p>在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，http&#x2F;2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><h4 id="服务端推送（Server-Push）"><a href="#服务端推送（Server-Push）" class="headerlink" title="服务端推送（Server Push）"></a>服务端推送（Server Push）</h4><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。<br>服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h4 id="http2-0性能瓶颈"><a href="#http2-0性能瓶颈" class="headerlink" title="http2.0性能瓶颈"></a>http2.0性能瓶颈</h4><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。、</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</p><ul><li>HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；</li><li>HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；</li><li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li></ul><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h4 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h4><p>TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>TCP实现高并发有3个弊端：</p><ul><li>实现成本高。TCP是由操作系统内核实现的，如果通过多线程实现并发，并发线程数不能太多，否则线程间切换成本会以指数级上升；如果通过异步、非阻塞socket实现并发，开发效率又太低；</li><li>每个TCP连接与TLS会话都叠加了2-3个RTT的建链成本；</li><li>TCP连接有一个防止出现拥塞的慢启动流程，它会对每个TCP连接都产生减速效果。</li></ul><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="https://s1.ax1x.com/2023/07/30/pPpTX1P.png" alt="小林code"></p><h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。https端口：443</p><p>前面我们知道一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被<strong>窃听截取</strong>。</li><li>数据的完整性未校验，容易被<strong>篡改</strong></li><li>没有验证对方身份，存在<strong>冒充</strong>危险</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了HTTP的风险：</p><ul><li>数据保密性：保证数据内容在传输的过程中不会被第三方查看,交互信息无法被窃取。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</li><li>数据完整性：及时发现被第三方篡改的传输内容,无法篡改通信内容，篡改了就不能正常显示。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</li><li>身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</li></ul><p>对应采取了以下三种做法：</p><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了<strong>窃听</strong>的风险。</li><li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了<strong>冒充</strong>的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。<br>采用「混合加密」的方式的原因：</li><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个哈希值，然后同内容一起传输给对方。<br>对方收到后，先是对内容也计算出一个哈希值，然后跟发送方发送的哈希值做一个比较，如果哈希值相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证秘钥本身就是货真价实的公开密钥；</p><p>那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：</p><p>一个是公钥，这个是可以公开给所有人的；<br>一个是私钥，这个必须由本人管理，不可泄露。<br>这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。<br>流程的不同，意味着目的也不相同：</p><p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<br>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。<br>所以非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。<br>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>前面我们知道：<br>可以通过哈希算法来保证消息的完整性；<br>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？我伪造一个网站然后发给你公钥，按照前面流程我是知道私钥的，因为公钥是我伪造的，前面流程只能验证公钥和私钥匹配的，并不能解决身份冒充的问题。为了解决这个问题，可以使用由数字证书认证机构（CA）和其他相关机构颁发的公开秘钥证书。<br>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程：</li><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><ul><li>服务器拥有自己的私钥与公钥。</li><li>服务器将公钥交给CA认证机构，请求给予一份数字证书。</li><li>CA认证机构生成数字证书，并颁发给服务器。</li><li>服务器将带有公钥信息的数字证书发给客户端。</li><li>进入客户端生成对称密钥再进行对接的过程。</li></ul><h3 id="HTTPS的通信步骤"><a href="#HTTPS的通信步骤" class="headerlink" title="HTTPS的通信步骤"></a>HTTPS的通信步骤</h3><p>SSL&#x2F;TLS 协议基本流程：</p><p>客户端向服务器索要并验证服务器的公钥。<br>双方协商生产「会话秘钥」。<br>双方采用「会话秘钥」进行加密通信。<br>TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法</p><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ul><li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ul><p>客户端回应，客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li><p>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p></li><li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li><li><p>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="https://s1.ax1x.com/2023/07/30/pPp6EZV.png" alt="pPp6EZV.png"></p></li></ul><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改、确保数据的完整性。<br>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但他大幅度增加了中间人攻击的成本。</p><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>慢，HTTPS未经任何优化的情况下要比HTTP慢几百毫秒以上，特别在移动端可能要慢500毫秒以上，关于HTTPS慢和如何优化已经是一个非常系统和复杂的话题。<br>贵，特别在计算性能和服务器成本方面。HTTPS要额外计算，要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。<br>大量的计算.SSL的每一个字节都涉及到较为复杂的计算。即使是clientHello，也需要在握手完成时做校验。<br>TLS协议的封装和解析。HTTPS所有数据都是按照TLS record格式进行封装和解析的。<br>协议的网络交互。从TLS的握手过程可以看出，即使不需要进行任何计算，TLS的握手也需要至少1个RTT（round trip time)以上的网络交互。RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。<br>HTTPS降低用户访问速度（需多次握手）。<br>网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）。<br>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https 访问过程需要加解密）。</p><h3 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h3><p>1）HSTS重定向技术：将http自动转换为https，减少301重定向。<br>2）TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据。直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT<br>3）会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了。<br>4）OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询。<br>5）完全前向加密PFS：使用更牛逼复杂的秘钥算法。</p><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><ol><li>DHCP 请求报文，目的端口67源端口68的UTP报文，广播地址255.255.255.255，源地址0.0.0.0</li><li>DHCP的IP数据报被放置在以太网帧当中以太网帧具有FF:FF:FF:FF:FF:FF进行广播。</li><li>当DHCP服务器收到后，通过CIDR分配IP</li><li>DNS 域名解析发送UDP报文段获取域名IP</li><li>不知道网关路由器mac地址，ARP广播报文查询</li><li>获取mac地址后发送DNS解析帧通过RIP，OSPF，或者IS-IS或者域间协议BGP将报文请求，获取ip</li><li>获取ip后tcp三次握手</li><li>http协议</li></ol><p>在浏览器输入网址后，首先要经过<strong>域名解析</strong>。通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p>为了查找DNS记录，浏览器会检查四个缓存。<br>第一，检查浏览器缓存。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。<br>第二，浏览器检查操作系统缓存。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。<br>第三，检查路由器缓存。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。<br>第四，检查ISP缓存。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。<br>如果请求的URL不在缓存中，ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）<br>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈，生成HTTP 请求信息，<strong>封装成一个 HTTP 数据包。</strong><br>HTTP 底层是依赖 TCP&#x2F;IP 协议实现的，所以在底层数据传输时，会将 HTTP 请求包进一步<strong>封装成 TCP 数据包。</strong><br>打开⼀个socket与⽬标IP地址，端⼝<strong>建⽴TCP链接</strong>，三次握⼿如下：</p><ul><li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端口</li><li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li><li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z<br>TCP链接建⽴后浏览器<strong>向 web 服务器发送一个 HTTP 请求</strong><br>服务器端拿到了客户端的请求参数之后，会进行相应的业务处理，处理完成之后，再将处理的结果返回给客户端。返回的流程和发送的流程类似，先将结果封装成 HTTP 数据包</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>new/delete  malloc/free</title>
      <link href="/p/80c02825.html"/>
      <url>/p/80c02825.html</url>
      
        <content type="html"><![CDATA[<h1 id="new-x2F-delete-malloc-x2F-free"><a href="#new-x2F-delete-malloc-x2F-free" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free"></a>new&#x2F;delete  malloc&#x2F;free</h1><h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><p>new操作针对数据类型的处理，分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要构造函数的类型）"><a href="#简单数据类型（-包括基本数据类型和不需要构造函数的类型）" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要构造函数的类型）"></a>简单数据类型（ 包括基本数据类型和不需要构造函数的类型）</h3><p>代码实例：</p><pre><code>int* p = new int;</code></pre><p>汇编码如下：</p><pre><code>int* p = new int;    00E54C44  push        4      00E54C46  call        operator new (0E51384h)      00E54C4B  add         esp,4  </code></pre><p>分析：传入4byte的参数后调用operator new。其源码如下：</p><pre><code>void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123;           // try to allocate size bytes    void *p;    while ((p = malloc(size)) == 0)    &#123;        if (_callnewh(size) == 0)        &#123;       // report no memory                _THROW_NCEE(_XSTD bad_alloc, );        &#125;    &#125;    return (p);&#125;</code></pre><p>分析：调用malloc失败后会调用_callnewh。如果_callnewh返回0则抛出bac_alloc异常，返回非零则继续分配内存。<br>这个_callnewh是什么呢？它是一个new handler，通俗来讲就是new失败的时候调用的回调函数。可以通过_set_new_handler来设置。下面举个实例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;new.h&gt;int MyNewHandler(size_t size)&#123;    printf(&quot;Allocation failed.Try again&quot;);    return 1;//continue to allocate    //return 0;//stop allocating,throw bad_alloc&#125;void main()&#123;    // Set the failure handler for new to be MyNewHandler.    _set_new_handler(MyNewHandler);    while (1)    &#123;        int* p = new int[10000000];    &#125;&#125;</code></pre><p>在new基本数据类型的时候还可以指定初始化值，比如：</p><pre><code>int* p = new int(4);</code></pre><p>简单类型直接调用operator new分配内存；<br>可以通过new_handler来处理new失败的情况；<br>new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；</p><p>new[] 调用的是operator new[]，计算出数组总大小之后调用operator new。</p><h3 id="复杂数据类型（需要由构造函数初始化对象）"><a href="#复杂数据类型（需要由构造函数初始化对象）" class="headerlink" title="复杂数据类型（需要由构造函数初始化对象）"></a>复杂数据类型（需要由构造函数初始化对象）</h3><p>例如：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object();&#125;</code></pre><p>汇编码如下：</p><pre><code>Object* p = new Object();    00AD7EDD  push        4      00AD7EDF  call        operator new (0AD1384h)      00AD7EE4  add         esp,4      00AD7EE7  mov         dword ptr [ebp-0E0h],eax      00AD7EED  mov         dword ptr [ebp-4],0      00AD7EF4  cmp         dword ptr [ebp-0E0h],0      00AD7EFB  je          main+70h (0AD7F10h)      00AD7EFD  mov         ecx,dword ptr [ebp-0E0h]      00AD7F03  call        Object::Object (0AD1433h)        //在new的地址上调用构造函数    00AD7F08  mov         dword ptr [ebp-0F4h],eax      00AD7F0E  jmp         main+7Ah (0AD7F1Ah)      00AD7F10  mov         dword ptr [ebp-0F4h],0      00AD7F1A  mov         eax,dword ptr [ebp-0F4h]      00AD7F20  mov         dword ptr [ebp-0ECh],eax      00AD7F26  mov         dword ptr [ebp-4],0FFFFFFFFh      00AD7F2D  mov         ecx,dword ptr [ebp-0ECh]      00AD7F33  mov         dword ptr [p],ecx  </code></pre><p>new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。</p><p>针对复杂类型，new[]会额外存储数组大小。</p><h2 id="delete的实现"><a href="#delete的实现" class="headerlink" title="delete的实现"></a>delete的实现</h2><p>delete也分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要析构函数的类型）。"><a href="#简单数据类型（-包括基本数据类型和不需要析构函数的类型）。" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。"></a>简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。</h3><pre><code>int *p = new int(1);delete p;</code></pre><p>delete的汇编码如下：</p><pre><code>    delete p;00275314  mov         eax,dword ptr [p]  00275317  mov         dword ptr [ebp-0D4h],eax  0027531D  mov         ecx,dword ptr [ebp-0D4h]  00275323  push        ecx  00275324  call        operator delete (0271127h) </code></pre><p>分析：传入参数p之后调用operator delete，其源码如下：</p><pre><code>void operator delete( void * p )&#123;    RTCCALLBACK(_RTC_Free_hook, (p, 0));    free( p );&#125;</code></pre><p>RTCCALLBACK默认是空的宏定义，所以这个函数默认情况下就是简单的调用free函数。<br>delete简单数据类型默认只是调用free函数。</p><p>针对简单类型，delete和delete[]等同。</p><h3 id="复杂数据类型（需要由析构函数销毁对象）"><a href="#复杂数据类型（需要由析构函数销毁对象）" class="headerlink" title="复杂数据类型（需要由析构函数销毁对象）"></a>复杂数据类型（需要由析构函数销毁对象）</h3><p>代码实例：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;        cout &lt;&lt; &quot;destroy object&quot; &lt;&lt; endl;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object;    delete p;&#125;</code></pre><p>部分汇编码如下：</p><pre><code>012241F0  mov         dword ptr [this],ecx  012241F3  mov         ecx,dword ptr [this]  012241F6  call        Object::~Object (0122111Dh)     //先调用析构函数012241FB  mov         eax,dword ptr [ebp+8]  012241FE  and         eax,1  01224201  je          Object::`scalar deleting destructor&#39;+3Fh (0122420Fh)  01224203  mov         eax,dword ptr [this]  01224206  push        eax  01224207  call        operator delete (01221145h)  0122420C  add         esp,4 </code></pre><p>delete复杂数据类型先调用析构函数再调用operator delete。</p><p>释放内存之前会先调用每个对象的析构函数。<br>new[]分配的内存只能由delete[]释放。如果由delete释放会崩溃，为什么会崩溃呢？<br>假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。<br>总结：<br>针对复杂类型，new[]出来的内存只能由delete[]释放。</p><h2 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h2><p>1）plain new（默认new） 2）nothrow new（不抛异常的new） 3）placement new（放置new）</p><h3 id="plain-new-和-nothrow-new"><a href="#plain-new-和-nothrow-new" class="headerlink" title="plain new 和 nothrow new"></a>plain new 和 nothrow new</h3><p>默认的new和nothrow new用法上差不多，只不过是返回值上面的区别</p><p>默认的new在分配失败的时候会抛出异常，而非返回NULL<br>但是nothrow new在分配失败的时候会返回NULL，而不是异常</p><p>下面这个例子，我们一开始先用默认的new，不断要求分配一个内存空间，为了节省时间，可以要求分配的内存空间很大，比较容易达到“无法再分配的状态”。</p><p>当无法再继续分配的时候，new就会抛出异常“std::bad_alloc”</p><p>nothrow new，这时候已经是“无法再分配”，所以直接就会使得nothrow new失败，但是nothrow new返回的是NULL，我们可以验证一下</p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;int main()&#123;    try &#123;        while (true) &#123;            new int[100000000ul];   // throwing overload        &#125;    &#125; catch (const std::bad_alloc&amp; e) &#123;        std::cout &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;    &#125;    while (true) &#123;        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload        if (p == nullptr) &#123;            std::cout &lt;&lt; &quot;Allocation returned nullptr\n&quot;;            break;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>std::bad_allocAllocation returned nullptr</code></pre><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>该运算符用于在已分配的内存上重新构造对象,因为不分配内存，所以也不用担心分配失败<br>我们可以验证一下，我们先分配一块内存并存储数据，然后我们再在这同一块内存中申请一个相同的对象（其他对象也可以，不过要比原先申请的空间小），给新对象赋一个不同的数据，查看最后内存的数据是什么</p><pre><code>// C++ program to illustrate the placement new operator#include&lt;iostream&gt;using namespace std;int main()&#123;    // initial value of X    int X = 10;    cout &lt;&lt; &quot;Before placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    // Placement new changes the value of X to 100    int *mem = new (&amp;X) int(100);    cout &lt;&lt; &quot;\nAfter placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;mem : &quot; &lt;&lt; mem &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code>Before placement new :X : 10&amp;X : 0x7fff71ce8bfcAfter placement new :X : 100 mem : 0x7fff71ce8bfc&amp;X : 0x7fff71ce8bfc</code></pre><p>解释一下，就是一开始内存地址为”0x7fff71ce8bfc”,数据为“10”</p><p>然后进行了palcement new以后，new的内存空间还是原来的内存空间，数据变成了“100”</p><h2 id="new-x2F-delete-和-malloc-x2F-free的区别"><a href="#new-x2F-delete-和-malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free的区别"></a>new&#x2F;delete 和 malloc&#x2F;free的区别</h2><h3 id="引入上"><a href="#引入上" class="headerlink" title="引入上"></a>引入上</h3><p>new&#x2F;delete：这两个是C++中的关键字，若要使用，需要编译器支持；<br>malloc&#x2F;free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。</p><h3 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h3><p>malloc：申请空间需要显式填入申请内存的大小；<br>new：无需显式填入申请的内存大小，new会根据new的类型分配内存。</p><h3 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h3><p>new：申请的内存空间在自由存储区</p><p>malloc：申请的内存空间在堆</p><p>自由存储区：默认是堆，也可以通过自己实现，使得为进程中的其他区域</p><h3 id="是否可以重载"><a href="#是否可以重载" class="headerlink" title="是否可以重载"></a>是否可以重载</h3><p>在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等<br>而malloc和free是C里的库函数，无法对其进行重载。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br>malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。</p><p>malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；<br>new内存分配失败时，会抛出bac_alloc异常，</p><h3 id="对数组的处理"><a href="#对数组的处理" class="headerlink" title="对数组的处理"></a>对数组的处理</h3><p>使用new操作符来分配对象内存时会调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。运行相应的构造函数以构造对象，并为其传入初值，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会调用对象的析构函数，调用operator delete(或operator delete[])函数释放内存空间。</p><p>malloc：和非数组数据的内存分配没有区别<br>free：和非数组数据的的内存释放没有区别</p><p>free怎么知道要释放多大的内存空间？<br>malloc分配空间时，可以理解成整个内存空间分成两块<br>一块在首地址，记录内存的大小的。一块就是你指定大小的内存空间</p><h3 id="是否可以扩展内存空间"><a href="#是否可以扩展内存空间" class="headerlink" title="是否可以扩展内存空间"></a>是否可以扩展内存空间</h3><p>new：不行<br>malloc：可以</p><p>使用malloc分配的空间可以使用realloc函数对其进行内存的扩展</p><p>realloc先判断当前指针指向的内存空间是否有足够的连续空间支持扩展，如果有，直接原地扩展，并且返回原来地址的指针；如果没有，按照新指定的内存空间大小，开辟一块新的内存空间，然后把旧内存空间的数据复制过去，然后释放旧内存空间，返回新内存空间的指针</p><h2 id="既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？"><a href="#既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？" class="headerlink" title="既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h2><p>malloc&#x2F;free适用于： 简单的数据类型（int，char等），这些数据在定义的时候没有构造函数和析构函数，就无须使用new&#x2F;delete，只用简单分配空间和释放空间即可</p><p>new&#x2F;delete适用于： 自定义的类，这些数据在定义的时候往往需要调用构造函数初始化，释放的时候需要调用析构函数。这时简单的内存分配和内存释放无法满足需求，所以这时就需要new和delete</p><h2 id="Malloc函数的线程安全"><a href="#Malloc函数的线程安全" class="headerlink" title="Malloc函数的线程安全"></a>Malloc函数的线程安全</h2><p>malloc函数线程安全但是不可重入的，因为malloc函数在用户空间要自己管理各进程共享的内存链表，由于有共享资源访问，本身会造成线程不安全。为了做到线程安全，需要加锁进行保护。同时这个锁必须是递归锁，因为如果当程序调用malloc函数时收到信号，在信号处理函数里再调用malloc函数，如果使用一般的锁就会造成死锁（信号处理函数中断了原程序的执行），所以要使用递归锁。<br>一个函数要做到可重入，需要不在函数内部使用静态或全局数据，不返回静态或全局数据，也不调用不可重入函数。</p><h2 id="被free回收的内存怎么处理？"><a href="#被free回收的内存怎么处理？" class="headerlink" title="被free回收的内存怎么处理？"></a>被free回收的内存怎么处理？</h2><p>会被统一管理起来，而不是归还给操作系统</p><p>这些内存空间会被一条双链表连接起来，这样下一次需要分配内存空间的时候，就可以先在这里面找是否合适的内存，合适就直接使用；如果所需内存比这里的内存空间都要大，那么再去重新向系统申请一块内存空间</p><p>这样统一管理，不立即归还给操作系统的好处是避免每次free都要进行系统调用；而且避免返回给操作系统很多小的碎片，难以管理；</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载operator new<br>因为new是关键字，我们本应该无法修改new分配内存的方式。由于new在分配内存时，调用operator new。所以重载operator new就可以修改分配内存的方式了。</p><pre><code>class Foo &#123;public:    Foo() &#123; std::cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; std::endl; &#125;    virtual ~Foo() &#123; std::cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; std::endl; &#125;    void* operator new(std::size_t size)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new(std::size_t size, int num)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new (std::size_t size, void* p)    &#123;        std::cout &lt;&lt; &quot;placement new&quot; &lt;&lt; std::endl;        return p;    &#125;    void operator delete(void* ptr)    &#123;        std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Foo* m = new(100) Foo;    Foo* m2 = new(m) Foo;    std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;    //delete m2;    delete m;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/p/80c02825.html"/>
      <url>/p/80c02825.html</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>局部static是线程安全的，可以用来实现单例模式</p><h2 id="面向过程设计中的static"><a href="#面向过程设计中的static" class="headerlink" title="面向过程设计中的static"></a>面向过程设计中的static</h2><p>全局变量、静态变量和类的静态成员变量在main执行之前初始化；局部静态变量在第一次使用时初始化。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。                         </p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的，不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，该变量的值不会因为函数终止而丢失，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><p>修饰函数时，表明该函数只在同一文件中调用。</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突；</li></ul><h2 id="面向对象的static关键字"><a href="#面向对象的static关键字" class="headerlink" title="面向对象的static关键字"></a>面向对象的static关键字</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>用static修饰不访问非静态数据成员的类成员函数。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。</p><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p><strong>在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗。</strong></p><p>答：可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响。</p><p><strong>为什么静态成员函数不能申明为const</strong></p><p>答：这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。<span style="line-height:26px">一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了</span></p><p><strong>为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义</strong><br>答：因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p><strong>static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中。</strong><br>如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。</p><p><strong>为什么常量静态成员数据的初始化可以放在类内（注意：只有静态常量整型数据成员才可以在类中初始化）</strong></p><p>答：是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’&#x3D;’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p><p><strong>为什么静态成员函数只能访问静态成员变量。</strong></p><p>1.静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的<br>2.非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问<br>3.访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</p><p><strong>静态成员函数与非静态成员函数的区别</strong><br>根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。</p><p><strong>为什么要用静态成员变量和静态成员函数</strong><br>为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享</p><p><strong>静态成员的作用、优点</strong><br>静态成员函数主要为了调用方便，不需要生成对象就能调用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节提前批</title>
      <link href="/p/7d1900d6.html"/>
      <url>/p/7d1900d6.html</url>
      
        <content type="html"><![CDATA[<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP怎么建立连接"><a href="#TCP怎么建立连接" class="headerlink" title="TCP怎么建立连接"></a>TCP怎么建立连接</h3><h3 id="有抓过包吗-（无）"><a href="#有抓过包吗-（无）" class="headerlink" title="有抓过包吗 （无）"></a>有抓过包吗 （无）</h3><h3 id="TCP的可靠性怎么保证"><a href="#TCP的可靠性怎么保证" class="headerlink" title="TCP的可靠性怎么保证"></a>TCP的可靠性怎么保证</h3><h3 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）</h3><h3 id="聊天室是怎么做的，以及一些地方的实现"><a href="#聊天室是怎么做的，以及一些地方的实现" class="headerlink" title="聊天室是怎么做的，以及一些地方的实现"></a>聊天室是怎么做的，以及一些地方的实现</h3><h3 id="用户密码明文存吗"><a href="#用户密码明文存吗" class="headerlink" title="用户密码明文存吗"></a>用户密码明文存吗</h3><h3 id="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"><a href="#因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施" class="headerlink" title="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"></a>因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施</h3><h3 id="TCP和UDP的区别，TCP为什么能保证可靠传输"><a href="#TCP和UDP的区别，TCP为什么能保证可靠传输" class="headerlink" title="TCP和UDP的区别，TCP为什么能保证可靠传输"></a>TCP和UDP的区别，TCP为什么能保证可靠传输</h3><h3 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h3><h3 id="HTTP长连接怎么保活"><a href="#HTTP长连接怎么保活" class="headerlink" title="HTTP长连接怎么保活"></a>HTTP长连接怎么保活</h3><h3 id="输入一个网址到查看到信息，中间的过程"><a href="#输入一个网址到查看到信息，中间的过程" class="headerlink" title="输入一个网址到查看到信息，中间的过程"></a>输入一个网址到查看到信息，中间的过程</h3><h3 id="讲一下什么是IO多路复用"><a href="#讲一下什么是IO多路复用" class="headerlink" title="讲一下什么是IO多路复用"></a>讲一下什么是IO多路复用</h3><h3 id="讲一讲select、poll和epoll的区别"><a href="#讲一讲select、poll和epoll的区别" class="headerlink" title="讲一讲select、poll和epoll的区别"></a>讲一讲select、poll和epoll的区别</h3><h3 id="socket通讯的流程，深入到kernel层面"><a href="#socket通讯的流程，深入到kernel层面" class="headerlink" title="socket通讯的流程，深入到kernel层面"></a>socket通讯的流程，深入到kernel层面</h3><h3 id="poll，select，epoll-ET-x2F-LT"><a href="#poll，select，epoll-ET-x2F-LT" class="headerlink" title="poll，select，epoll,ET&#x2F;LT"></a>poll，select，epoll,ET&#x2F;LT</h3><h3 id="docker里能bind-CPU-是真的bind吗"><a href="#docker里能bind-CPU-是真的bind吗" class="headerlink" title="docker里能bind CPU,是真的bind吗"></a>docker里能bind CPU,是真的bind吗</h3><h3 id="Http框架构成。"><a href="#Http框架构成。" class="headerlink" title="Http框架构成。"></a>Http框架构成。</h3><h3 id="Http和RPC区别。"><a href="#Http和RPC区别。" class="headerlink" title="Http和RPC区别。"></a>Http和RPC区别。</h3><h3 id="RPC的优势。"><a href="#RPC的优势。" class="headerlink" title="RPC的优势。"></a>RPC的优势。</h3><p>14 算法题：给一个二叉树，输出二叉树的左视图，所谓左视图就是每一层最左边的节点</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux命令用过哪些"><a href="#linux命令用过哪些" class="headerlink" title="linux命令用过哪些"></a>linux命令用过哪些</h3><h3 id="死锁怎么产生"><a href="#死锁怎么产生" class="headerlink" title="死锁怎么产生"></a>死锁怎么产生</h3><h3 id="怎么避免死锁"><a href="#怎么避免死锁" class="headerlink" title="怎么避免死锁"></a>怎么避免死锁</h3><h3 id="操作系统中内核态和用户态的区别，分别干什么"><a href="#操作系统中内核态和用户态的区别，分别干什么" class="headerlink" title="操作系统中内核态和用户态的区别，分别干什么"></a>操作系统中内核态和用户态的区别，分别干什么</h3><h3 id="敲键盘发生的中断"><a href="#敲键盘发生的中断" class="headerlink" title="敲键盘发生的中断"></a>敲键盘发生的中断</h3><h3 id="Linux里kernel里的buffer如何通知user的"><a href="#Linux里kernel里的buffer如何通知user的" class="headerlink" title="Linux里kernel里的buffer如何通知user的"></a>Linux里kernel里的buffer如何通知user的</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL的隔离级别有哪几种"><a href="#MySQL的隔离级别有哪几种" class="headerlink" title="MySQL的隔离级别有哪几种"></a>MySQL的隔离级别有哪几种</h3><h3 id="脏读和幻读分别是什么"><a href="#脏读和幻读分别是什么" class="headerlink" title="脏读和幻读分别是什么"></a>脏读和幻读分别是什么</h3><h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><h3 id="小于n的最大数（寄）"><a href="#小于n的最大数（寄）" class="headerlink" title="小于n的最大数（寄）"></a>小于n的最大数（寄）</h3><p>给一个数n，一个数组A，返回由A中元素组成的小于n的最大数<br>如n&#x3D;23121，A&#x3D;{2,4,9| 返回22999<br>n&#x3D;23121 A&#x3D;{9} 返回9999<br>n&#x3D;23333 A&#x3D;{2,3} 返回23332<br>n&#x3D;2222 A&#x3D;{2} 返回222<br>n&#x3D;2 A&#x3D;{2} 无解</p><h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><h3 id="最长连续递增子序列长度"><a href="#最长连续递增子序列长度" class="headerlink" title="最长连续递增子序列长度"></a>最长连续递增子序列长度</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就2，4或3，8，最长长度为2<br>设数组dp[i]，表示以i为结尾的最长连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，1，1，2，1，2}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[6] = &#123;1,5,2,4,3,8&#125;;    int dp[6];    dp[0] = 1;    for(int i=1;i&lt;6;i++)&#123;        dp[i] = 1;        if(Array[i] &gt; Array[i-1])&#123;            dp[i] = dp[i-1] + 1;        &#125;    &#125;    for(int i=0;i&lt;6;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre><h3 id="最长不连续递增子序列"><a href="#最长不连续递增子序列" class="headerlink" title="最长不连续递增子序列"></a>最长不连续递增子序列</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就1，2，418或1，2，3，8，最长长度为4<br>设数组dp[i]，表示以i为结尾的最长不连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，2，2，3，3，4}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[10] = &#123;1,5,2,4,3,8,7,2,9,10&#125;;    int dp[10];    dp[0]=1;    for(int i=1;i&lt;10;i++)&#123;        dp[i] = 1;        for(int j=i-1;j&gt;=0;j--)&#123;            if(Array[i]&gt;Array[j])&#123;                dp[i] = max(dp[i],dp[j]+1);            &#125;        &#125;    &#125;    for(int i=0;i&lt;10;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百度</title>
      <link href="/p/158ea4f5.html"/>
      <url>/p/158ea4f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="计网："><a href="#计网：" class="headerlink" title="计网："></a>计网：</h2><h3 id="讲一下http和https的不同"><a href="#讲一下http和https的不同" class="headerlink" title="讲一下http和https的不同"></a>讲一下http和https的不同</h3><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><h3 id="用的是对称加密还是非对称加密"><a href="#用的是对称加密还是非对称加密" class="headerlink" title="用的是对称加密还是非对称加密"></a>用的是对称加密还是非对称加密</h3><h3 id="HTTP1-1，-2-0区别"><a href="#HTTP1-1，-2-0区别" class="headerlink" title="HTTP1.1， 2.0区别"></a>HTTP1.1， 2.0区别</h3><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h3 id="TCP能不能改成2次握手"><a href="#TCP能不能改成2次握手" class="headerlink" title="TCP能不能改成2次握手"></a>TCP能不能改成2次握手</h3><h3 id="讲一下OSI的七层模型，以及每一层的含义和应用"><a href="#讲一下OSI的七层模型，以及每一层的含义和应用" class="headerlink" title="讲一下OSI的七层模型，以及每一层的含义和应用"></a>讲一下OSI的七层模型，以及每一层的含义和应用</h3><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h3 id="三次握手中如果数据发送失败，让你设计你会怎么处理"><a href="#三次握手中如果数据发送失败，让你设计你会怎么处理" class="headerlink" title="三次握手中如果数据发送失败，让你设计你会怎么处理"></a>三次握手中如果数据发送失败，让你设计你会怎么处理</h3><h3 id="讲一讲四次挥手？"><a href="#讲一讲四次挥手？" class="headerlink" title="讲一讲四次挥手？"></a>讲一讲四次挥手？</h3><p>答：TCP的四次挥手分为主动关闭方和被动关闭方。主动关闭方因为自身的stream结束，主动发送了FIN报文，为第一次挥手。被动关闭方发送对第一次挥手确认的ACK报文，这为第二次挥手。接着被动方的stream结束，发送FIN报文，此为第三次挥手。最后，主动关闭方发送ACK报文对第三次挥手进行确认，为第四次挥手。</p><h3 id="为什么是四次挥手，不能是两次挥手吗？"><a href="#为什么是四次挥手，不能是两次挥手吗？" class="headerlink" title="为什么是四次挥手，不能是两次挥手吗？"></a>为什么是四次挥手，不能是两次挥手吗？</h3><p>答：因为发送方发送完FIN报文之后，需要对方回复ACK报文表示：发送方的FIN报文被接收方确认已经收到。所以一定需要四次挥手。如果只有两次挥手，主动关闭方和被动关闭方分别发送FIN报文，不接受ACK报文。主动关闭方和被动关闭方无法知道发送的FIN报文被对方收到，因为FIN报文可能在网络中遗失了。</p><h3 id="讲讲close-wait状态和last-ack状态的区别？"><a href="#讲讲close-wait状态和last-ack状态的区别？" class="headerlink" title="讲讲close_wait状态和last_ack状态的区别？"></a>讲讲close_wait状态和last_ack状态的区别？</h3><p>答：这两个状态都是被动结束方的状态，被动结束方接收第一次挥手，从establish状态变成close_wait状态。接着。被动结束方发送第二次和第三次挥手，从close_wait状态转变到last_ack状态。在last_ack状态，被动结束方等待主动结束方的第四次挥手。其中，第二次和第三次挥手之间，需要程序员触发close()。</p><h3 id="HTTP请求有哪些方法，GET和-POST方法有什么区别？"><a href="#HTTP请求有哪些方法，GET和-POST方法有什么区别？" class="headerlink" title="HTTP请求有哪些方法，GET和 POST方法有什么区别？"></a>HTTP请求有哪些方法，GET和 POST方法有什么区别？</h3><p>答：HTTP请求有head，get,post方法。其中GET方法语义倾向于下载，post倾向于上传。</p><h3 id="如果在time-wait状态点击read会怎样？"><a href="#如果在time-wait状态点击read会怎样？" class="headerlink" title="如果在time_wait状态点击read会怎样？"></a>如果在time_wait状态点击read会怎样？</h3><p>答：在timewait状态read类似重新进行tcp连接，如果开启时间戳机制，下一次的序列号和时间戳都比期望的大可以重新进行连接</p><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><h3 id="OSI的七层模型，以及每一层的含义和应用"><a href="#OSI的七层模型，以及每一层的含义和应用" class="headerlink" title="OSI的七层模型，以及每一层的含义和应用"></a>OSI的七层模型，以及每一层的含义和应用</h3><h3 id="三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲"><a href="#三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲" class="headerlink" title="三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲"></a>三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲</h3><h3 id="RPC协议讲解。通用于分布式框架中"><a href="#RPC协议讲解。通用于分布式框架中" class="headerlink" title="RPC协议讲解。通用于分布式框架中"></a>RPC协议讲解。通用于分布式框架中</h3><h3 id="为什么要三次握手，两次不行吗？"><a href="#为什么要三次握手，两次不行吗？" class="headerlink" title="为什么要三次握手，两次不行吗？"></a>为什么要三次握手，两次不行吗？</h3><h3 id="tcp和udp是什么，有什么区别"><a href="#tcp和udp是什么，有什么区别" class="headerlink" title="tcp和udp是什么，有什么区别"></a>tcp和udp是什么，有什么区别</h3><h3 id="为啥要OSI七层模型？有什么作用"><a href="#为啥要OSI七层模型？有什么作用" class="headerlink" title="为啥要OSI七层模型？有什么作用"></a>为啥要OSI七层模型？有什么作用</h3><h3 id="http如何进行流量控制？拥塞控制"><a href="#http如何进行流量控制？拥塞控制" class="headerlink" title="http如何进行流量控制？拥塞控制"></a>http如何进行流量控制？拥塞控制</h3><h3 id="数据链路层的传输单位，网络层呢？"><a href="#数据链路层的传输单位，网络层呢？" class="headerlink" title="数据链路层的传输单位，网络层呢？"></a>数据链路层的传输单位，网络层呢？</h3><h3 id="HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。"><a href="#HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。" class="headerlink" title="HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。"></a>HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。</h3><h3 id="ftp是什么，哪一层的协议？"><a href="#ftp是什么，哪一层的协议？" class="headerlink" title="ftp是什么，哪一层的协议？"></a>ftp是什么，哪一层的协议？</h3><p>作者：maybe的小超人<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post">https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post</a><br>来源：牛客网</p><h3 id="知不知道拥塞控制，讲一下"><a href="#知不知道拥塞控制，讲一下" class="headerlink" title="知不知道拥塞控制，讲一下"></a>知不知道拥塞控制，讲一下</h3><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>应用  http ftp  DNS POP3<br>会话<br>表示<br>运输<br>网络  IP，ICMP，RIP，OSPF，BGP，IGMP<br>链路  SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理  ISO2110，IEEE802，IEEE802.2</p><h3 id="tcp建立连接过程"><a href="#tcp建立连接过程" class="headerlink" title="tcp建立连接过程"></a>tcp建立连接过程</h3><h3 id="断开连接过程"><a href="#断开连接过程" class="headerlink" title="断开连接过程"></a>断开连接过程</h3><h3 id="为什么客户端的-TIME-WAIT-状态必须等待-2MSL"><a href="#为什么客户端的-TIME-WAIT-状态必须等待-2MSL" class="headerlink" title="为什么客户端的 TIME-WAIT 状态必须等待 2MSL"></a>为什么客户端的 TIME-WAIT 状态必须等待 2MSL</h3><h3 id="输入网址到浏览器的过程"><a href="#输入网址到浏览器的过程" class="headerlink" title="输入网址到浏览器的过程"></a>输入网址到浏览器的过程</h3><h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="查看端口的命令"><a href="#查看端口的命令" class="headerlink" title="查看端口的命令"></a>查看端口的命令</h3><h3 id="解除端口占用的命令"><a href="#解除端口占用的命令" class="headerlink" title="解除端口占用的命令"></a>解除端口占用的命令</h3><h3 id="查看日志文件接口被调用次数的命令"><a href="#查看日志文件接口被调用次数的命令" class="headerlink" title="查看日志文件接口被调用次数的命令"></a>查看日志文件接口被调用次数的命令</h3><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><h3 id="查看-TCP-状态？"><a href="#查看-TCP-状态？" class="headerlink" title="查看 TCP 状态？"></a>查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h3 id="进程间有哪些通信方式，讲一下"><a href="#进程间有哪些通信方式，讲一下" class="headerlink" title="进程间有哪些通信方式，讲一下"></a>进程间有哪些通信方式，讲一下</h3><h3 id="linux中32-和-64是什么意思"><a href="#linux中32-和-64是什么意思" class="headerlink" title="linux中32 和 64是什么意思"></a>linux中32 和 64是什么意思</h3><h3 id="I-x2F-O多路复用。水平触发和边缘触发"><a href="#I-x2F-O多路复用。水平触发和边缘触发" class="headerlink" title="I&#x2F;O多路复用。水平触发和边缘触发"></a>I&#x2F;O多路复用。水平触发和边缘触发</h3><h3 id="数据序列化实现。对二进制序列化，Pool-Buffer。"><a href="#数据序列化实现。对二进制序列化，Pool-Buffer。" class="headerlink" title="数据序列化实现。对二进制序列化，Pool Buffer。"></a>数据序列化实现。对二进制序列化，Pool Buffer。</h3><h3 id="cpu密集型和i-x2F-o密集型什么意思"><a href="#cpu密集型和i-x2F-o密集型什么意思" class="headerlink" title="cpu密集型和i&#x2F;o密集型什么意思"></a>cpu密集型和i&#x2F;o密集型什么意思</h3><h3 id="如果1g的内存，能否申请2g的空间，8g呢？"><a href="#如果1g的内存，能否申请2g的空间，8g呢？" class="headerlink" title="如果1g的内存，能否申请2g的空间，8g呢？"></a>如果1g的内存，能否申请2g的空间，8g呢？</h3><h3 id="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"><a href="#死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）" class="headerlink" title="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"></a>死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）</h3><h3 id="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"><a href="#进程调度算法有哪些，最短作业优先怎么样的，有什么弊端" class="headerlink" title="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"></a>进程调度算法有哪些，最短作业优先怎么样的，有什么弊端</h3><h3 id="讲一下select-x2F-pool-x2F-epoll"><a href="#讲一下select-x2F-pool-x2F-epoll" class="headerlink" title="讲一下select&#x2F;pool&#x2F;epoll"></a>讲一下select&#x2F;pool&#x2F;epoll</h3><h3 id="讲一下同步（阻塞，非阻塞）IO-x2F-异步IO"><a href="#讲一下同步（阻塞，非阻塞）IO-x2F-异步IO" class="headerlink" title="讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO"></a>讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO</h3><h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="用过哪些数据库，了解NOSQL吗"><a href="#用过哪些数据库，了解NOSQL吗" class="headerlink" title="用过哪些数据库，了解NOSQL吗"></a>用过哪些数据库，了解NOSQL吗</h3><h3 id="MySQL有哪些索引"><a href="#MySQL有哪些索引" class="headerlink" title="MySQL有哪些索引"></a>MySQL有哪些索引</h3><h3 id="主键索引和唯一索引区别"><a href="#主键索引和唯一索引区别" class="headerlink" title="主键索引和唯一索引区别"></a>主键索引和唯一索引区别</h3><h3 id="Mysql中的索引讲一下"><a href="#Mysql中的索引讲一下" class="headerlink" title="Mysql中的索引讲一下"></a>Mysql中的索引讲一下</h3><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><h3 id="一个联合索引（a，b，c），查询（a，c），能用到索引吗"><a href="#一个联合索引（a，b，c），查询（a，c），能用到索引吗" class="headerlink" title="一个联合索引（a，b，c），查询（a，c），能用到索引吗"></a>一个联合索引（a，b，c），查询（a，c），能用到索引吗</h3><h3 id="事物的特性"><a href="#事物的特性" class="headerlink" title="事物的特性"></a>事物的特性</h3><h3 id="SQL注入-怎么避免"><a href="#SQL注入-怎么避免" class="headerlink" title="SQL注入 怎么避免"></a>SQL注入 怎么避免</h3><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h3 id="读已提交和读未提交有什么区别"><a href="#读已提交和读未提交有什么区别" class="headerlink" title="读已提交和读未提交有什么区别"></a>读已提交和读未提交有什么区别</h3><h3 id="解释脏读"><a href="#解释脏读" class="headerlink" title="解释脏读"></a>解释脏读</h3><h3 id="解释可重复读-说一个场景-a数b数"><a href="#解释可重复读-说一个场景-a数b数" class="headerlink" title="解释可重复读 说一个场景 a数b数"></a>解释可重复读 说一个场景 a数b数</h3><h3 id="mvcc实现逻辑"><a href="#mvcc实现逻辑" class="headerlink" title="mvcc实现逻辑"></a>mvcc实现逻辑</h3><h3 id="mysql日志-有哪几种"><a href="#mysql日志-有哪几种" class="headerlink" title="mysql日志 有哪几种"></a>mysql日志 有哪几种</h3><h3 id="mvcc用的哪一个日志"><a href="#mvcc用的哪一个日志" class="headerlink" title="mvcc用的哪一个日志"></a>mvcc用的哪一个日志</h3><h3 id="mysql的锁有哪些"><a href="#mysql的锁有哪些" class="headerlink" title="mysql的锁有哪些"></a>mysql的锁有哪些</h3><h3 id="char和varchar的区别-哪一个效率高"><a href="#char和varchar的区别-哪一个效率高" class="headerlink" title="char和varchar的区别  哪一个效率高"></a>char和varchar的区别  哪一个效率高</h3><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>两个包含5亿URL的文件，找两个文件的重复URL，内存只有4G。<br>首先我们最常想到的方法是读取文件a，建立哈希表，然后再读取文件b，遍历文件b中每个url，对于每个遍历，我们都执行查找hash表的操作，若hash表中搜索到了，则说明两文件共有，存入一个集合。</p><p>但上述方法有一个明显问题，加载一个文件的数据需要50亿*64bytes &#x3D; 320G远远大于4G内存，何况我们还需要分配哈希表数据结构所使用的空间，所以不可能一次性把文件中所有数据构建一个整体的hash表。所以虽然可行，但是无法满足需求。</p><p>针对上述问题，我们采用分治算法的思想。</p><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M)，为什么是1000？主要根据内存大小和要分治的文件大小来计算，我们就大致可以把320G大小分为1000份，每份大约300M（当然，到底能不能分布尽量均匀，得看hash函数的设计）</p><p>遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999)（为什么要这样做? 文件a的hash映射和文件b的hash映射函数要保持一致，这样的话相同的url就会保存在对应的小文件中，比如，如果a中有一个url记录data1被hash到了a99文件中，那么如果b中也有相同url，则一定被hash到了b99中）</p><p>所以现在问题转换成了：找出1000对小文件中每一对相同的url（不对应的小文件不可能有相同的url）</p><p>因为每个hash大约300M，所以我们再可以采用哈希中的想法</p><h3 id="场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？"><a href="#场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？" class="headerlink" title="场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？"></a>场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？</h3><h3 id="算法场景题。一个生产者消费者场景。提了一些改进点。"><a href="#算法场景题。一个生产者消费者场景。提了一些改进点。" class="headerlink" title="算法场景题。一个生产者消费者场景。提了一些改进点。"></a>算法场景题。一个生产者消费者场景。提了一些改进点。</h3><p>&#x2F;&#x2F; 模块A、B，创建一个Buffer类，提供统一的接口供有A去生产数据，B去消费数据。<br>&#x2F;&#x2F; 一些细节：<br>&#x2F;&#x2F; 1. A创建数据的大小是任意的，可能是256个字节，也可能是1k<br>&#x2F;&#x2F; 2. 提供接口供消费者B，获取数据的大小，并可以一次性获取所有数据，或者分批获取数据<br>&#x2F;&#x2F; 3. A、B在不同的线程中，要实现线程安全的数据接口</p><p>作者：Olimiya<br>链接：<a href="https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic">https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic</a><br>来源：牛客网</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="数组中找第K大的数"><a href="#数组中找第K大的数" class="headerlink" title="数组中找第K大的数"></a>数组中找第K大的数</h3><pre><code>class Solution &#123;public:    void quickPartition(vector&lt;int&gt;&amp; nums, int start, int end, int target) &#123;        // 随机取一个数作为基准        srand(time(nullptr));        int random = rand() % (end - start + 1) + start;        int base = nums[random];        // 将该数放到待快排区间开头第一个元素        swap(nums[start], nums[random]);        int index = start;        // 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素        // 交换到index + 1位置，index++，使得最终index前面的元素都比base大。        for (int i = start + 1; i &lt;= end; ++i) &#123;            if (nums[i] &gt;= base) &#123;                swap(nums[index + 1], nums[i]);                index++;            &#125;        &#125;        // base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。        swap(nums[index], nums[start]);            // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，        // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。        if (index &lt; target) &#123;            quickPartition(nums, index + 1, end, target);        &#125;        else if (index &gt; target) &#123;            quickPartition(nums, start, index - 1, target);        &#125;    &#125;    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        // 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，        // 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k    // 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。        quickPartition(nums, 0, nums.size() - 1, k - 1);        return nums[k - 1];    &#125;&#125;;class Solution &#123;    Random random=new Random();    public int findKthLargest(int[] nums, int k) &#123;            return quickSelect(nums,k,0,nums.length-1);    &#125;    public int quickSelect(int[] nums,int k,int left,int right)&#123;        //随机获取一个值作为目标值        int index=random.nextInt(right-left+1)+left;        //保存目标值        int target=nums[index];        //在进行第一次交换时，会丢失nums[left],因此需要保存        nums[index]=nums[left];        int i=left,j=right;        while(i&lt;j)&#123;            while(i&lt;j&amp;&amp;nums[j]&lt;=target) j--;            nums[i]=nums[j];            while(i&lt;j&amp;&amp;nums[i]&gt;=target) i++;            nums[j]=nums[i];        &#125;        nums[i]=target;        //经过交换后，i左部均大于nums[i],右部均小于nums[i]        if(i==k-1) return nums[i];        //说明在左部分        else if(i&gt;k-1) return quickSelect(nums,k,left,i-1);        else return quickSelect(nums,k,i+1,right);    &#125;&#125;</code></pre><h3 id="合并k个链表"><a href="#合并k个链表" class="headerlink" title="合并k个链表"></a>合并k个链表</h3><p>class Solution {<br>public:<br>    struct Status {<br>        int val;<br>        ListNode *ptr;<br>        bool operator &lt; (const Status &amp;rhs) const {<br>            return val &gt; rhs.val;<br>        }<br>    };</p><pre><code>priority_queue &lt;Status&gt; q;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    for (auto node: lists) &#123;        if (node) q.push(&#123;node-&gt;val, node&#125;);    &#125;    ListNode head, *tail = &amp;head;    while (!q.empty()) &#123;        auto f = q.top(); q.pop();        tail-&gt;next = f.ptr;         tail = tail-&gt;next;        if (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);    &#125;    return head.next;&#125;</code></pre><p>};</p><h3 id="k个升序链表的合并"><a href="#k个升序链表的合并" class="headerlink" title="k个升序链表的合并"></a>k个升序链表的合并</h3><p>class Solution {<br>public:<br>    struct Status {<br>        int val;<br>        ListNode *ptr;<br>        bool operator &lt; (const Status &amp;rhs) const {<br>            return val &gt; rhs.val;<br>        }<br>    };</p><pre><code>priority_queue &lt;Status&gt; q;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    for (auto node: lists) &#123;        if (node) q.push(&#123;node-&gt;val, node&#125;);    &#125;    ListNode head, *tail = &amp;head;    while (!q.empty()) &#123;        auto f = q.top(); q.pop();        tail-&gt;next = f.ptr;         tail = tail-&gt;next;        if (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);    &#125;    return head.next;&#125;</code></pre><p>};</p><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><pre><code>class Solution &#123;public:    int getKthMagicNumber(int k) &#123;        set&lt;long long&gt; st;        st.insert(1LL);        long long ans = 0;        for(int i=0;i&lt;k;++i)&#123;            ans = *st.begin();            st.erase(st.begin());            st.insert(ans * 3);            st.insert(ans * 5);            st.insert(ans * 7);        &#125;        return ans;    &#125;&#125;;</code></pre><h3 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h3><h3 id="中序遍历递归和非递归写法"><a href="#中序遍历递归和非递归写法" class="headerlink" title="中序遍历递归和非递归写法"></a>中序遍历递归和非递归写法</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="数组中第K大的值，O-nlogn-，不能用sort-函数"><a href="#数组中第K大的值，O-nlogn-，不能用sort-函数" class="headerlink" title="数组中第K大的值，O(nlogn)，不能用sort()函数"></a>数组中第K大的值，O(nlogn)，不能用sort()函数</h3><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><h3 id="查找链表倒数第K个数"><a href="#查找链表倒数第K个数" class="headerlink" title="查找链表倒数第K个数"></a>查找链表倒数第K个数</h3><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><h2 id="智力题："><a href="#智力题：" class="headerlink" title="智力题："></a>智力题：</h2><h3 id="25匹马5个赛道，最少几次前三名马"><a href="#25匹马5个赛道，最少几次前三名马" class="headerlink" title="25匹马5个赛道，最少几次前三名马"></a>25匹马5个赛道，最少几次前三名马</h3><h3 id="1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药"><a href="#1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药" class="headerlink" title="1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药"></a>1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="/p/c5176eb2.html"/>
      <url>/p/c5176eb2.html</url>
      
        <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。RPC 的作用就是体现在这样两个方面：</p><ul><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</li></ul><h2 id="RPC-通信流程"><a href="#RPC-通信流程" class="headerlink" title="RPC 通信流程"></a>RPC 通信流程</h2><p>RPC 是一个远程调用，那肯定就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。<br>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方<br>从 TCP 通道里面收到二进制数据.根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p><p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验</p><p><img src="https://s1.ax1x.com/2023/07/22/pCqmTbt.png" alt="pCqmTbt.png"></p><p>RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从“单体”演进成“微服务化”，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是“经络”一样的存在。RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p><h2 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h2><p>RPC 本质上就是一个远程调用，那肯定就需要通过网络来传输数据。虽然传输协议可以有多种选择，但考虑到可靠性的话，我们一般默认采用 TCP 协议。为了屏蔽网络传输的复杂性，我们需要封装一个单独的数据传输模块用来收发二进制数据，这个单独模块我们可以叫做传输模块<br>用户请求的时候是基于方法调用，方法出入参数都是对象数据，对象是肯定没法直接在网络中传输的，我们需要提前把它转成可传输的二进制，这就是我们说的序列化过程。但只是把方法调用参数的二进制数据传输到服务提供方是不够的，我们需要在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，在两个“断句”符号中间放的内容就是我们请求的二进制数据，这个过程我们叫做协议封装。<br>虽然这是两个不同的过程，但其目的都是一样的，都是为了保证数据在网络中可以正确传输。这里我说的正确，可不仅指数据能够传输，还需要保证传输后能正确还原出传输前的语义。所以我们可以把这两个处理过程放在架构中的同一个模块，统称为协议模块。除此之外，我们还可以在协议模块中加入压缩功能，这是因为压缩过程也是对传输的二进制数据进行操作。在实际的网络传输过程中，我们的请求数据包在数据链路层可能会因为太大而被拆分成多个数据包进行传输，为了减少被拆分的次数，从而导致整个传输过程时间太长的问题，我们可以在 RPC 调用的时候这样操作：在方法调用参数或者返回值的二进制数据大于某个阈值的情况下，我们可以通过压缩框架进行无损压缩，然后在另外一端也用同样的压缩算法进行解压，保证数据可还原<br>传输和协议这两个模块是 RPC 里面最基础的功能，它们使对象可以正确地传输到服务提供方。但距离 RPC 的目标——实现像调用本地一样地调用远程，还缺少点东西。因为这两个模块所提供的都是一些基础能力，要让这两个模块同时工作的话，我们需要手写一些黏合的代码，但这些代码对我们使用 RPC 的研发人员来说是没有意义的，而且属于一个重复的工作，会导致使用过程的体验非常不友好。<br>这就需要我们在 RPC 里面把这些细节对研发人员进行屏蔽，让他们感觉不到本地调用和远程调用的区别。假设有用到 Spring 的话，我们希望 RPC 能让我们把一个 RPC 接口定义成一个 Spring Bean，并且这个 Bean 也会统一被 Spring Bean Factory 管理，可以在项目中通过 Spring 依赖注入到方式引用。这是 RPC 调用的入口，我们一般叫做 Bootstrap 模块</p><p>到这儿，一个点对点（Point to Point）版本的 RPC 框架就完成了。我一般称这种模式的 RPC 框架为单机版本，因为它没有集群能力。所谓集群能力，就是针对同一个接口有着多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在 RPC 里面我们还需要给调用方找到所有的服务提供方，并需要在 RPC 里面维护好接口跟服务提供者地址的关系，这样调用方在发起请求的时候才能快速地找到对应的接收地址，这就是我们常说的“服务发现”。</p><p>但服务发现只是解决了接口和服务提供方地址映射关系的查找问题，这更多是一种“静态数据”。说它是静态数据是因为，对于我们的 RPC 来说，我们每次发送请求的时候都是需要用 TCP 连接的，相对服务提供方 IP 地址，TCP 连接状态是瞬息万变的，所以我们的 RPC框架里面要有连接管理器去维护 TCP 连接的状态。<br>有了集群之后，提供方可能就需要管理好这些服务了，那我们的 RPC 就需要内置一些服务治理的功能，比如服务提供方权重的设置、调用授权等一些常规治理手段。而服务调用方需要额外做哪些事情呢？每次调用前，我们都需要根据服务提供方设置的规则，从集群中选择可用的连接用于发送请求</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq17QO.png" alt="pCq17QO.png"></p><p>设计 RPC 框架不可能在开始时就面面俱到。有一天业务方有了新的需求，要加入很多新的功能，这时当前架构面临的可就是大挑战了，要修改很多地方才能实现。这就是我们接下来要讲的插件化架构</p><p>在 RPC 框架里面，我们是怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机制，它可以动态地为某个接口寻找服务实现。使用 SPI 机制需要在 Classpath 下的 META-INF&#x2F;services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。<br>但在实际项目中，我们其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载，ServiceLoader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。</p><p>加上了插件功能之后，我们的 RPC 框架就包含了两大核心体系——核心功能体系与插件体</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3pSf.png" alt="pCq3pSf.png"></p><p>这时，整个架构就变成了一个微内核架构，我们将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离并提供接口的默认实现。这样的架构相比之前的架构，有很多优势。首先它的可扩展性很好，实现了开闭原则，用户可以非常方便地通过插件扩展实现自己的功能，而且不需要修改核心功能的本身；其次就是保持了核心包的精简，依赖外部包少，这样可以有效减少开发人员引入 RPC 导致的包版本冲突问题</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="为什么需要服务发现？"><a href="#为什么需要服务发现？" class="headerlink" title="为什么需要服务发现？"></a>为什么需要服务发现？</h3><p>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现<br>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例。服务 IP 集合作为“通信录”中的地址，从而可以通过接口获取服务 IP 的集合来完成服务的发现。这就是我要说的 PRC 框架的服务发现机制，如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3lm4.png" alt="pCq3lm4.png"></p><ol><li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。</li><li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</li></ol><h3 id="基于-ZooKeeper-的服务发现"><a href="#基于-ZooKeeper-的服务发现" class="headerlink" title="基于 ZooKeeper 的服务发现"></a>基于 ZooKeeper 的服务发现</h3><p>整体的思路很简单，就是搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能，整体流程如下图：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3dXD.md.png" alt="pCq3dXD.md.png"></p><p>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：&#x2F;service&#x2F;com.demo.xxService），在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息。</p><p>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</p><p>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方 watch 该服务的服务提供方目录（&#x2F;service&#x2F;com.demo.xxService&#x2F;provider）中所有的服务节点数据。</p><p>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</p><p>微服务化程度越来越高之后，ZooKeeper 集群整体压力也越来越高,当连接到ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机。而宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机。</p><h3 id="基于消息总线的最终一致性的注册中心"><a href="#基于消息总线的最终一致性的注册中心" class="headerlink" title="基于消息总线的最终一致性的注册中心"></a>基于消息总线的最终一致性的注册中心</h3><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。<br>而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。</p><p>因为要求最终一致性，我们可以考虑采用消息总线机制。注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据。当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本。<br>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息。对于获取到消息的在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。<br>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面。<br>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</p><p>为了性能，这里采用了两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性。</p><p>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况，这个时候有没有问题？这个问题我们放到了 RPC 框架里面去处理，在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求。服务调用方收到拒绝异常后，会安全重试到其它节点。</p><p>通过消息总线的方式，我们就可以完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作。服务发现的特性是允许我们在设计超大规模集群服务发现系统的时候，舍弃强一致性，更多地考虑系统的健壮性。最终一致性才是分布式系统设计中更为常用</p><h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的IP 地址。为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的.<br>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况，那怎么保证选择出来的连接一定是可用的呢？</p><p>终极的解决方案是让调用方实时感知到节点的状态变化，这样他们才能做出正确的选择。</p><h3 id="健康检测的逻辑"><a href="#健康检测的逻辑" class="headerlink" title="健康检测的逻辑"></a>健康检测的逻辑</h3><p>当服务方下线，正常情况下我们肯定会收到连接断开的通知事件,但咱们这里不行，因为应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。<br>业内常用的检测方法就是用心跳机制。心跳机制说起来也不复杂，其实就是服务调用方每隔一段时间就问一下服务提供方，“兄弟，你还好吧？”，然后服务提供方很诚实地告诉调用方它目前的状态。</p><p>服务方的状态一般会有三种情况</p><ol><li>健康状态：建立连接成功，并且心跳探活也一直成功；</li><li>亚健康状态：建立连接成功，但是心跳请求连续失败；</li><li>死亡状态：建立连接失败。</li></ol><p>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化，具体状态间转换图如下：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>一开始初始化的时候，如果建立连接成功，那就是健康状态，否则就是死亡状态。这里没有亚健康这样的中间态。紧接着，如果健康状态的节点连续出现几次不能响应心跳请求的情况，那就会被标记为亚健康状态，也就是说，服务调用方会觉得它生病了。生病之后（亚健康状态），如果连续几次都能正常响应心跳请求，那就可以转回健康状态，证明病好了。如果病一直好不了，那就会被断定为是死亡节点，死亡之后还需要善后，比如关闭连接<br>当然，死亡并不是真正死亡，它还有复活的机会。如果某个时间点里，死亡的节点能够重连成功，那它就可以重新被标记为健康状态。</p><p>一个节点从健康状态过渡到亚健康状态的前提是“连续”心跳失败次数必须到达某一个阈值</p><ul><li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次，所以我们不能把简单的把总失败的次数当作判断条件。</li><li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s，所以我们也不能把 TPS 至来当作判断条件。</li></ul><p>所以可以考虑使用可用率，可用率的计算方式是某一个时间窗口内接口调用成功次数的百分比（成功次数 &#x2F; 总调用次数）。当可用率低于个比例就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口也兼顾了接口响应时间不同的问题。</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p>在真实环境中我们的服务提供方是以一个集群的方式提供服务，这对于服务调用方来说，就是一个接口会有多个服务提供方同时提供服务，所以我们的 RPC 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。<br>既然这些节点都可以用来完成这次请求，那么我们就可以简单地认为这些节点是同质的。就是这次请求无论发送到集合中的哪个节点上，返回的结果都是一样的。<br>既然服务提供方是以集群的方式对外提供服务，那就要考虑一些实际问题。要知道我们每次上线应用的时候都不止一台服务器会运行实例，那上线就涉及到变更，只要变更就可能导致原本正常运行的程序出现异常，尤其是发生重大变动的时候，导致我们应用不稳定的因素就变得很多。为了减少这种风险，我们一般会选择灰度发布我们的应用实例，比如我们可以先发布少量实例观察是否有异常，后续再根据观察的情况，选择发布更多实例还是回滚已经上线的实例。<br>但这种方式不好的一点就是，线上一旦出现问题，影响范围还是挺大的。因为对于我们的服务提供方来说，我们的服务会同时提供给很多调用方来调用，尤其是像一些基础服务的调用方会更复杂，比如商品、价格等等，一旦刚上线的实例有问题，那将会导致所有的调用方业务都会受损。</p><h3 id="如何实现路由策略？"><a href="#如何实现路由策略？" class="headerlink" title="如何实现路由策略？"></a>如何实现路由策略？</h3><p>在 RPC 里面服务调用方是通过服务发现的方式拿到了所有服务提供方的 IP 地址，当我们选择要灰度验证功能的时候，是不是就可以让注册中心在推送的时候区别对待，而不是一股脑的把服务提供方的 IP地址推送到所有调用方。换句话说就是，注册中心只会把刚上线的服务 IP 地址推送到选择指定的调用方，而其他调用方是不能通过服务发现拿到这个 IP 地址的。<br>通过服务发现的方式来隔离调用方请求，从逻辑上来看确实可行，但注册中心在 RPC 里面的定位是用来存储数据并保证数据一致性的。如果把这种复杂的计算逻辑放到注册中心里面，当集群节点变多之后，就会导致注册中心压力很大，而且大部分情况下我们一般都是采用开源软件来搭建注册中心，要满足这种需求还需要进行二次开发。所以从实际的角度出发，通过影响服务发现来实现请求隔离并不划算</p><p>我们可以重新回到调用方发起 RPC 调用的流程。在 RPC 发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（就是我们常说的负载均衡），那我们是不是可以在选择节点前加上“筛选逻辑”，把符合我们要求的节点筛选出来。那这个筛选的规则是什么呢？就是我们灰度过程中要验证的规则。</p><p>比如我们要求新上线的节点只允许某个 IP 可以调用，那我们的注册中心会把这条规则下发到服务调用方。在调用方收到规则后，在选择具体要发请求的节点前，会先通过筛选规则过滤节点集合，按照这个例子的逻辑，最后会过滤出一个节点，这个节点就是我们刚才新上线的节点。通过这样的改造，RPC 调用流程就变成了这样：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq7jMR.md.png" alt="pCq7jMR.md.png"></p><p>这个筛选过程在RPC 里面有一个专业名词，就是“路由策略”，而上面例子里面的路由策略是我们常见的 IP 路由策略，用于限制可以调用服务提供方的 IP。使用了 IP 路由策略后，整个集群的调用拓扑如下图所示</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqb8hD.png" alt="pCqb8hD.png"></p><h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><p>有了 IP 路由之后，上线过程中我们就可以做到只让部分调用方请求调用到新上线的实例，相对传统的灰度发布功能来说，这样做我们可以把试错成本降到最低。但在有些场景下，我们可能还需要更细粒度的路由方式。比如，在升级改造应用的时候，为了保证调用方能平滑地切调用我们的新应用逻辑，在升级过程中我们常用的方式是让新老应用并行运行一段时间，然后通过切流量百分比的方式，慢慢增大新应用承接的流量，直到新应用承担了 100% 且运行一段时间后才能去下线老应用。</p><p>在流量切换的过程中，为了保证整个流程的完整性，我们必须保证某个主题对象的所有请求都使用同一种应用来承接。假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作是用新应用（或者老应用）来完成所有请求的响应。很显然，上面的 IP 路由并不能满足我们这个需求，因为 IP 路由只是限制调用方来源，并不会根据请求参数请求到我们预设的服务提供方节点上去。</p><p>我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点。在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID，我们可以根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点。因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点。使用了参数路由策略后，整个集群的调用拓扑如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqbdBt.png" alt="pCqbdBt.png"></p><p>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。灰度发布功能是 RPC 路由功能的一个典型应用场景，通过 RPC 路由策略的组合使用可以让服务提供方更加灵活地管理、调用自己的流量，进一步降低上线可能导致的风<br>险。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqqjMj.png" alt="pCqqjMj.png"></p><p>负载均衡主要分为软负载和硬负载，软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等，硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等。负载均衡的算法主要有随机法、轮询法、最小连接法等。</p><h3 id="RPC-框架中的负载均衡"><a href="#RPC-框架中的负载均衡" class="headerlink" title="RPC 框架中的负载均衡"></a>RPC 框架中的负载均衡</h3><p>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。<br>RPC 负载均衡策略一般包括随机权重、Hash、轮询。当然，这还是主要看 RPC 框架自身的实现。其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制。比如我们默认每个节点的权重都是 100，但当我们把其中的一个节点的权重设置成 50 时，它接收到的流量就是其他节点的 1&#x2F;2。</p><p>由于负载均衡机制完全是由 RPC 框架自身实现的，所以它不再需要依赖任何负载均衡设备，自然也不会发生负载均衡设备的单点问题，服务调用方的负载均衡策略也完全可配，同时我们可以通过控制权重的方式，对负载均衡进行治理。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/p/a3a0c28e.html"/>
      <url>/p/a3a0c28e.html</url>
      
        <content type="html"><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><strong>【分库】</strong></p><p>分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就可能会成为瓶颈，因为数据库的连接数是有限的，虽然可以调整，但是也不是无限调整的。当你的数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</p><p>常见的分库方式有：单库单表 -&gt; 单库多表 -&gt; 多库多表</p><p><strong>【分表】</strong></p><p>分表，就是将一个表结构分为多个表，分表后，可以存在于同一个库里，也可以放到不同的库。分表其实主要解决的是数据量大的问题。</p><p>常见的分表方式：</p><ul><li>纵向分表：根据数据的活跃度进行拆分，也就是按照字段使用活跃度来拆分。</li><li>横向分表：把大的表结构，横向切割为同样结构的不同表，也就是同样的表按照某个业务规则复制很多个。</li></ul><p><strong>分库分表根本不是一件事，而是三件事。分别是”只分库不分表”、”只分表不分库”、以及”既分库又分表”。</strong></p><h2 id="为什么需要考虑分库分表呢"><a href="#为什么需要考虑分库分表呢" class="headerlink" title="为什么需要考虑分库分表呢"></a>为什么需要考虑分库分表呢</h2><p>不管是分库还是分表都是因为单个空间内存储数据过多，导致性能下降无法满足正常业务需要。拆分后减小单个个体的负担，缩短操作时间，提高性能满足业务需要。数据库出现性能瓶颈，对外表现有几个方面：</p><ul><li>大量请求阻塞<ul><li>在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。</li></ul></li><li>SQL 操作变慢<ul><li>如果数据库中存在一张上亿数据量的表，一条 SQL 没有命中索引会全表扫描，这个查询耗时会非常久。</li></ul></li><li>存储出现问题<ul><li>业务量剧增，单库数据量越来越大，给存储造成巨大压力。</li></ul></li></ul><p><strong>IO 瓶颈</strong><br>第一种：磁盘读 IO 瓶颈。</p><p>由于热点数据太多，数据库缓存完全放不下，查询时会产生大量的磁盘 IO，查询速度会比较慢，这样会导致产生大量活跃连接，最终可能会发展成无连接可用的后果。</p><p>可以采用一主多从，读写分离的方案，用多个从库分摊查询流量。或者采用分库+水平分表(把一张表的数据拆成多张表来存放，比如订单表可以按 user_id 来拆分)的方案。</p><p>第二种：磁盘写 IO 瓶颈。</p><p>由于数据库写入频繁，会产生频繁的磁盘写入 IO 操作，频繁的磁盘 IO 操作导致产生大量活跃连接，最终同样会发展成无连接可用的后果。</p><p>这时只能采用分库方案，用多个库来分摊写入压力。再加上水平分表的策略，分表后，单表存储的数据量会更小，插入数据时索引查找和更新的成本会更低，插入速度自然会更快。</p><p><strong>CPU 瓶颈</strong></p><p>SQL 问题：如果 SQL 中包含 join，group by，order by，非索引字段条件查询等增加 CPU 运算的操作，会对 CPU 产生明显的压力。</p><p>这时可以考虑 SQL 优化，创建适当的索引，也可以把一些计算量大的SQL逻辑放到应用中处理。</p><p>单表数据量太大：由于单张表数据量过大，比如超过一亿，查询时遍历树的层次太深或者扫描的行太多，SQL 效率会很低，也会非常消耗 CPU。这时可以根据业务场景水平分表。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>随着业务快速发展，数据库中的数据量猛增，所有的数据限制在一台服务器，「数据库物理机本身的CPU、内存、网络IO、磁盘等都会成为性能瓶颈」，此时我们可以按照业务的划分，将不同的表放在不同的服务器中，分散流量，减轻单个数据库的压力，提高系统的性能。</p><p><strong>「垂直分库优点」</strong></p><ul><li>专库专用，业务层面解耦</li><li>能够针对不同业务的数据进行分级管理、维护、监控、扩展</li><li>在一定程度上提升了IO、数据库连接数、降低单机硬件资源的瓶颈</li></ul><p><strong>「垂直分库缺点」</strong></p><ul><li>事务一致性的问题</li><li>多表连接查询困难</li></ul><p><strong>场景</strong>：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>当我们的一行数据过大时，数据页存储的数据行就会减少，也就是说跨数据页查询的概率就会增加，因此垂直分表就是将一个表拆分到多个表，避免出现数据库跨页存储的问题，从而提升查效率。</p><p><strong>「垂直分表拆分原则」</strong></p><ul><li>将热点字段和不常用的字段区分，放在不同的表中</li><li>将text，blob等大字段拆分出来放在附表中</li><li>将组合查询的列放在一张表中</li></ul><p><strong>「垂直分表优点」</strong></p><ul><li>减少锁竞争，查询不同字段数据互不影响</li><li>可实现冷热分离的数据表设计</li><li>可以使得行数据变小，一个数据页能存放更多的数据，最大限度利用数据页缓存，减少查询的 I&#x2F;O 次 数</li></ul><p><strong>「垂直分表缺点」</strong></p><ul><li>事务一致性的问题</li><li>多表连接查询困难</li><li>无法解决单表数据量过大</li></ul><p><strong>场景：</strong>系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>垂直分库是将不同业务表分别放在了不同数据库中以此减轻单个数据库的性能瓶颈，但是如果某个核心业务的并发非常高，比如订单库，双十一下单的并发非常高，单个的订单库仍然存在单个订单数据库性能瓶颈问题，因此我们可以对数据进行分片，将单个订单库进行拆分成多个库，以此提高数据库总体性能。水平分库的本质也是分表，是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</p><p><strong>水平分库优点」</strong></p><ul><li>解决单个库高并发的性能瓶颈</li><li>切分的表的结构相同，应用层改造较少，只需要增加路由规则即可</li><li>提高了系统的稳定性和负载能力。<br><strong>「水平分库缺点」</strong></li><li>分片事务的一致性难以解决</li><li>数据扩容的难度和维护量极大</li></ul><p><strong>场景：</strong>系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>当我们的业务量猛增，单表数据达数千万甚至上亿的时候，查询效率会降低，此时我们考虑将数据表按照一定的规则将表中的记录进行分片，存储在不同的表中，以此提高查询效率。<br>水平分表的本质是数据分片，将不同的数据按照一定的规则（ hash取模&#x2F;range范围）将数据存储在不同的表中，以此减少单表的数据量，提高查询效率</p><p><strong>「水平分表优点」</strong></p><ul><li>解决单表数据量大，查询性能下降的问题</li><li>可实现多表连接查询<br><strong>「水平分表缺点」</strong></li><li>引发排序、分页、函数计算等问题</li><li>数据扩容的难度和维护量极大。</li></ul><p><strong>场景</strong>：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</p><h2 id="数据切分"><a href="#数据切分" class="headerlink" title="数据切分"></a>数据切分</h2><p>当设计中按照业务逻辑实现了分库或者分表，我们在开发过程中怎样将不同的数据存放到指定的库或者表中。要想做到数据的水平切分，在每一个表中都要有相冗余字符作为切分依据和标记字段，通常的应用中我们选用id作为区分字段，基于此就有如下三种分库或者分表的方式和规则：（当然还可以有其他的方式）</p><h3 id="号段分区"><a href="#号段分区" class="headerlink" title="号段分区"></a>号段分区</h3><p>id为1～1000的对应DB1，1001～2000的对应DB2，以此类推；</p><p>优点：可部分迁移</p><p>缺点：数据分布不均</p><h3 id="hash取模分区"><a href="#hash取模分区" class="headerlink" title="hash取模分区"></a>hash取模分区</h3><p>对id进行hash（或者如果id是数值型的话直接使用id 的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对id的hash值进行取模运算，也就是id%4,这样的话每次运算就有四种可能：结果为1的时候对应DB1；结果为2的时候对应DB2；结果为3的时候对应DB3；结果为0的时候对应DB4。这样一来就非常均匀的将数据分配到4个DB中。</p><p>优点：数据分布均匀</p><p>缺点：数据迁移的时候麻烦，不能按照机器性能分摊数据，如果需要扩容二次分表，表的总数量发生变化时，就需要重新计算hash值，就需要涉及到数据迁移了。</p><p>为了解决扩容的问题，我们可以采用一致性哈希的方式来做分表。</p><h3 id="在认证库中保存数据库配置"><a href="#在认证库中保存数据库配置" class="headerlink" title="在认证库中保存数据库配置"></a>在认证库中保存数据库配置</h3><p>就是建立一个DB，这个DB单独保存id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作。</p><p>优点：灵活性强，一对一关系</p><p>缺点：每次查询之前都要多一次查询，性能大打折扣</p><h2 id="分库分表引发什么问题"><a href="#分库分表引发什么问题" class="headerlink" title="分库分表引发什么问题"></a>分库分表引发什么问题</h2><p>分库分表之后，虽然能够解决数据库的性能问题，但是也带来了一系列的其他问题：</p><p>事务问题<br>跨库关联问题<br>排序、分页、函数计算问题<br>分布式ID问题<br>多数据源问题</p><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><h3 id="跨库关联问题"><a href="#跨库关联问题" class="headerlink" title="跨库关联问题"></a>跨库关联问题</h3><p>在单库单表中，我们经常使用JOIN来进行多表查询，但是经过分库分表后多个表可能存在于多个数据库中，无法直接使用join进行联表查询，但是联表查询是非常常见的，所以针对这种情况有以下几种解决方式</p><h4 id="字段冗余"><a href="#字段冗余" class="headerlink" title="字段冗余"></a>字段冗余</h4><p>利用空间换时间，为了性能而避免join查询，将查询字段冗余。<br>例如：订单表保存userId时候，也将用户名称性别等需要查询的字段冗余保存一份，这样查询订单详情时就不需要再去查询用户表了。</p><h4 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h4><p>在系统模块中，对于一些依赖的数据表，在每个数据库都保存一份，避免跨库join查询。</p><h4 id="ER-表（绑定表）"><a href="#ER-表（绑定表）" class="headerlink" title="ER 表（绑定表）"></a>ER 表（绑定表）</h4><p>先确定各个业务表的关联关系，将那些存在关联关系的表记录存放在同一个分片上，避免跨分片join问题</p><h4 id="系统层组装"><a href="#系统层组装" class="headerlink" title="系统层组装"></a>系统层组装</h4><p>在系统层面，分多次查询，将获得到的数据通过代码进行字段拼装</p><h3 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h3><p>分库分表之后，数据分散，在跨节点进行count,order by,group by,limit 以及聚合函数的时候需要特殊处理，可以采用分片的方式：先在每个分片上执行相应的函数，得到结果后在应用程序端进行合并，得到最终结果。</p><h3 id="分布式ID问题"><a href="#分布式ID问题" class="headerlink" title="分布式ID问题"></a>分布式ID问题</h3><p>分库分表之后，我们不能再依赖数据库自增主键了，分表以后每个表都可以自增，会导致ID 重复或者混乱的问题，因此我们需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p><ul><li>UUID</li><li>基于数据库自增单独维护一张 ID表</li><li>号段模式</li><li>Redis</li><li>雪花算法（Snowflake）</li><li>美团Leaf</li><li>滴滴Tinyid</li></ul><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>好处就是本地生成，不要基于数据库；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><h3 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h3><p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p>适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>实例1生成的ID从1000开始，到1999结束。<br>实例2生成的ID从2000开始，到2999结束。<br>实例3生成的ID从3000开始，到3999结束。<br>实例4生成的ID从4000开始，到4999结束。<br>如果第一个实例的ID已经用到1999了怎么办?那就生成一个新的起始值：实例1生成的ID从5000开始，到5999结束。实例2生成的ID从6000开始，到6999结束。实例3生成的ID从7000开始，到7999结束。实例4生成的ID从8000开始，到8999结束。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法也是比较常用的一种分布式ID的生成方式，它具有全局唯一、递增、高可用的特点。</p><p>雪花算法生成的主键主要由 4 部分组成，1bit符号位、41bit时间戳位、10bit工作进程位以及 12bit 序列号位。</p><p>时间戳占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p><p>工作进程位占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p><p>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p><p>所以，一个雪花算法可以在同一毫秒内最多可以生成1024 X 4096 &#x3D; 4194304个唯一的ID</p><h4 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h4><p>这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。</p><p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="多数据源问题"><a href="#多数据源问题" class="headerlink" title="多数据源问题"></a>多数据源问题</h3><p>多数据源主要针对分库，既然数据库变成了多个，那什么时候查询那个库必然是一个必须要解决的问题，一般的解决方式有：「应用程序适配和代理层适配」。一般我们都会使用比较成熟的中间件来处理。</p><h2 id="如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>如何设计才可以让系统从未分库分表动态切换到分库分表上？</h2><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个导数的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>验证一下，ok了，完美，大家伸个懒腰，看看看凌晨 4 点钟的夜景，打个滴滴回家吧。</p><p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看凌晨 4 点的风景。</p><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p><p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p><p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p><p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p><p>现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</p><h2 id="如何设计可以动态扩容缩容的分库分表方案"><a href="#如何设计可以动态扩容缩容的分库分表方案" class="headerlink" title="如何设计可以动态扩容缩容的分库分表方案"></a>如何设计可以动态扩容缩容的分库分表方案</h2><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1小时数据就导完了。这没有问题。</p><p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载32 * 1000 &#x3D; 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 &#x3D; 48000 的写并发，接近 5万&#x2F;s 的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128个库，256个库，512个库。</p><p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>每秒的 5 万写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>一个实践是利用 32 * 32 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><p>+———+——–+——–+<br>| orderId | 库编号 | 表编号 |<br>+———+——–+——–+<br>|   259   |   3    |   8    |<br>|   1189  |   5    |   5    |<br>|   352   |   0    |   11   |<br>|   4593  |   17   |   15   |<br>+———+——–+——–+</p><p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表。</p><p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>这里对步骤做一个总结：</p><ul><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 &#x3D; 库，orderId &#x2F; 32 模 32 &#x3D; 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concepts</title>
      <link href="/p/7082d49f.html"/>
      <url>/p/7082d49f.html</url>
      
        <content type="html"><![CDATA[<h1 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h1><p>我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义half 对于 int 和 string 有不同的作用：</p><pre><code>int half(int n)&#123;    return n / 2;&#125;string half(string s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>除了 int，我们还有差不多的 short、long 等类型，甚至还有 boost::multiprecision::cpp_int；除了 string，我们也还有 wstring、u16string、u32string 等等。上面的每个函数，实际上都适用于一族类型，而不是单个类型。重载在这方面并帮不了什么忙</p><p>C++ 的概念就是用来解决这个问题的。对于上面的例子，我们只需要事先定义了 Integer和 String 的概念），我们就可以写出下面这样的代码：</p><pre><code>template &lt;Integer N&gt;N half(N n)&#123;    return n / 2;&#125;template &lt;String S&gt;S half(S s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>从概念上讲，上面这种形式的含义和下面的代码实质相同（以上面的第一个函数为例）</p><pre><code>template &lt;typename N&gt;requires Integer&lt;N&gt;N half(N n)&#123;    return n / 2;&#125;</code></pre><p>这个 half 是一个函数模板，有一个模板参数，启用这个模板的前提条件是这个参数满足 Integer 这个约束。</p><h2 id="基本的-Concepts"><a href="#基本的-Concepts" class="headerlink" title="基本的 Concepts"></a>基本的 Concepts</h2><p><img src="https://s1.ax1x.com/2023/07/20/pCHyjiT.png" alt="pCHyjiT.png"></p><p>我们从下往上看一下：</p><ul><li>move_constructible：可移动构造</li><li>swappable：可交换</li><li>movable：可移动构造、可交换，合在一起就是可移动了</li><li>copy_constructible：可拷贝构造</li><li>copyable：可拷贝构造、可移动，合在一起就是可拷贝了</li><li>default_initializable：可默认初始化（名字不叫 default_constructible 是因为目前的 type traits 中有 is_default_constructible，且意义和default_initializable 有点微妙的区别；</li><li>semiregular：可复制、可默认初始化，合在一起就是半正则了</li><li>equality_comparable：可相等比较，即对象之间可以使用 &#x3D;&#x3D; 运算符</li><li>regular：半正则、可相等比较，合在一起就是正则了</li></ul><ol><li><code>move_constructible</code>（可移动构造）：类型可以通过移动构造函数从另一个对象获得资源，而不会进行深拷贝。通常用于支持资源所有权的转移。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MyClass &#123;public:    // Move constructor    MyClass(MyClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::move_constructible&lt;MyClass&gt;::value, &quot;MyClass must be move constructible&quot;);</code></pre><ol start="2"><li><code>swappable</code>（可交换）：类型的对象可以通过 <code>std::swap</code> 进行交换，即可以互相交换其内部状态或资源。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class SwappableClass &#123;public:    // Implement the swap function to enable swapping of objects    void swap(SwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::swappable&lt;SwappableClass&gt;, &quot;SwappableClass must be swappable&quot;);</code></pre><ol start="3"><li><code>movable</code>（可移动构造、可交换）：类型既支持移动构造（<code>move_constructible</code>）又支持交换（<code>swappable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MovableAndSwappableClass &#123;public:    // Move constructor    MovableAndSwappableClass(MovableAndSwappableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;    // Implement the swap function to enable swapping of objects    void swap(MovableAndSwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::movable&lt;MovableAndSwappableClass&gt;, &quot;MovableAndSwappableClass must be movable&quot;);</code></pre><ol start="4"><li><code>copy_constructible</code>（可拷贝构造）：类型可以通过拷贝构造函数从另一个对象创建一个副本。</li></ol><p>示例：</p><pre><code class="cpp">class CopyConstructibleClass &#123;public:    // Copy constructor    CopyConstructibleClass(const CopyConstructibleClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::copy_constructible&lt;CopyConstructibleClass&gt;, &quot;CopyConstructibleClass must be copy constructible&quot;);</code></pre><ol start="5"><li><code>copyable</code>（可拷贝构造、可移动）：类型既支持拷贝构造（<code>copy_constructible</code>）又支持移动构造（<code>move_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class CopyableAndMovableClass &#123;public:    // Copy constructor    CopyableAndMovableClass(const CopyableAndMovableClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;    // Move constructor    CopyableAndMovableClass(CopyableAndMovableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::copyable&lt;CopyableAndMovableClass&gt;, &quot;CopyableAndMovableClass must be copyable&quot;);</code></pre><ol start="6"><li><code>default_initializable</code>（可默认初始化）：类型可以通过默认构造函数进行初始化，而不需要提供任何参数。</li></ol><p>示例：</p><pre><code class="cpp">class DefaultInitializableClass &#123;public:    // Default constructor    DefaultInitializableClass() &#123;        // Initialize internal state/resources here    &#125;&#125;;static_assert(std::default_initializable&lt;DefaultInitializableClass&gt;, &quot;DefaultInitializableClass must be default initializable&quot;);</code></pre><ol start="7"><li><code>semiregular</code>（可复制、可默认初始化）：类型既支持默认初始化（<code>default_initializable</code>）又支持拷贝构造（<code>copy_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class SemiregularClass &#123;public:    // Default constructor    SemiregularClass() &#123;        // Initialize internal state/resources here    &#125;    // Copy constructor    SemiregularClass(const SemiregularClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::semiregular&lt;SemiregularClass&gt;, &quot;SemiregularClass must be semiregular&quot;);</code></pre><ol start="8"><li><code>equality_comparable</code>（可相等比较）：类型的对象可以使用 <code>==</code> 运算符进行相等比较。</li></ol><p>示例：</p><pre><code class="cpp">class EqualityComparableClass &#123;public:    // Implement the equality operator (==)    bool operator==(const EqualityComparableClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::equality_comparable&lt;EqualityComparableClass&gt;, &quot;EqualityComparableClass must be equality comparable&quot;);</code></pre><ol start="9"><li><code>regular</code>（半正则、可相等比较）：类型既支持可相等比较（<code>equality_comparable</code>）又支持默认初始化（<code>default_initializable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class RegularClass &#123;public:    // Default constructor    RegularClass() &#123;        // Initialize internal state/resources here    &#125;    // Implement the equality operator (==)    bool operator==(const RegularClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::regular&lt;RegularClass&gt;, &quot;RegularClass must be regular&quot;);</code></pre><p>上述匹配的行为都是在编译期完成的，因此concept其实是zero-cost的。 </p><pre><code>// 任意类型都能匹配成功的约束，因此mul只要支持乘法运算符的类型都可以匹配成功。template &lt;always_satisfied T&gt;T mul(T a, T b) &#123;    return a * b;&#125;// 整型才能匹配add函数的Ttemplate &lt;integral T&gt;T add(T a, T b) &#123;    return a + b;&#125;// 有符号整型才能匹配subtract函数的Ttemplate &lt;signed_integral T&gt;T subtract(T a, T b) &#123;    return a - b;&#125;int main() &#123;    mul(1, 2); // 匹配成功, T =&gt; int    mul(1.0f, 2.0f);  // 匹配成功，T =&gt; float    add(1, -2);  // 匹配成功, T =&gt; int    add(1.0f, 2.0f); // 匹配失败, T =&gt; float，而T必须是整型    subtract(1U, 2U); // 匹配失败，T =&gt; unsigned int,而T必须是有符号整型    subtract(1, 2); // 匹配成功, T =&gt; int&#125;</code></pre><p>简单总结就是 有3种方式，另外再加上与auto关键字的一些结合方式。</p><pre><code>// 约束函数模板方法1template &lt;my_concept T&gt;void f(T v);// 约束函数模板方法2template &lt;typename T&gt;requires my_concept&lt;T&gt;void f(T v);// 约束函数模板方法3template &lt;typename T&gt;void f(T v) requires my_concept&lt;T&gt;;// 直接约束C++14的auto的函数参数void f(my_concept auto v);// 约束模板的auto参数template &lt;my_concept auto v&gt;void g();// 约束auto变量my_concept auto foo = ...;</code></pre><p>Concept当然也可以用在lambda函数上，使用方法跟上面一样，也有同样数量的花式用法</p><pre><code>// 约束lambda函数的方法1auto f = []&lt;my_concept T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法2auto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法3auto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; &#123;// ...&#125;;// auto函数参数约束auto f = [](my_concept auto v) &#123;// ...&#125;;// auto模板参数约束auto g = []&lt;my_concept auto v&gt; () &#123;// ...&#125;;</code></pre><h2 id="requires关键字的其他用法"><a href="#requires关键字的其他用法" class="headerlink" title="requires关键字的其他用法"></a>requires关键字的其他用法</h2><p>requires关键字不仅能用在concept的使用上，也可以用在定义中。 例如</p><pre><code>// requires用在使用concept时template &lt;typename T&gt;requires my_concept&lt;T&gt;void f(T);// requires用在concept的定义，它表达了类型T的参数f，必须符合大括号内的模式，也就是能被调用。// 也就是它是一个函数或者一个重载了operator()的类型template &lt;typename T&gt;concept callable = requires (T f) &#123; f(); &#125;; template &lt;typename T&gt;requires requires (T x) &#123; x + x; &#125; // `requires` 同时使用在concept的定义和使用上T add(T a, T b) &#123;return a + b;&#125;requires的语法看起来很复杂，初看会觉得很乱，没有啥规律或者总结性的东西。我这边个人理解大概是这样：// 这种也就是，requires后面接的是一个正在被eval的concept，这也就是用在上面的concept的使用中。requires evaled-concept// 本质上，concept在evaluate时，也就会是一个编译期返回结果为bool的表达式。这种其实等价于上面那种。requires expression// 例如 下面这种就是requires后直接接个bool表达式了template &lt;typename T&gt;requires std::is_integral_v&lt;T&gt;T add(T a, T b) &#123;    return a + b;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地套接字</title>
      <link href="/p/e431c708.html"/>
      <url>/p/e431c708.html</url>
      
        <content type="html"><![CDATA[<h1 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h1><p>本地套接字是 IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是进程间通信的常用方法，但因为本地套接字开发便捷，接受度高，所以普遍适用于在同一台主机上进程间通信的各种场景.</p><p>现在最火的云计算技术是什么？无疑是 Kubernetes 和 Docker。在 Kubernetes 和 Docker 的技术体系中，有很多优秀的设计，比如 Kubernetes 的 CRI（Container Runtime Interface），其思想是将 Kubernetes 的主要逻辑和 Container Runtime 的实现解耦。</p><p>为了实现和容器运行时的解耦，kubelet 设计了基于本地套接字的客户端 - 服务器 GRPC 调用。<br>Docker 其实也是大量使用了本地套接字技术来构建的。</p><h2 id="本地套接字概述"><a href="#本地套接字概述" class="headerlink" title="本地套接字概述"></a>本地套接字概述</h2><p>本地套接字一般也叫做 UNIX 域套接字，最新的规范已经改叫本地套接字。在前面的 TCP&#x2F;UDP 例子中，我们经常使用 127.0.0.1 完成客户端进程和服务器端进程同时在本机上的通信，那么，这里的本地套接字又是什么呢？</p><p>本地套接字是一种特殊类型的套接字，和 TCP&#x2F;UDP 套接字不同。TCP&#x2F;UDP 即使在本地地址通信，也要走系统网络协议栈，而本地套接字，严格意义上说提供了一种单主机跨进程间调用的手段，减少了协议栈实现的复杂度，效率比 TCP&#x2F;UDP 套接字都要高许多。类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等。<br>比如 X Window 实现，如果发现是本地连接，就会走本地套接字，工作效率非常高。</p><h2 id="本地字节流套接字"><a href="#本地字节流套接字" class="headerlink" title="本地字节流套接字"></a>本地字节流套接字</h2><p>这是一个字节流类型的本地套接字服务器端例子。在这个例子中，服务器程序打开本地套接字后，接收客户端发送来的字节流，并往客户端回送了新的字节流。</p><pre><code class="cpp">#include  &quot;lib/common.h&quot; int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamserver &lt;local_path&gt;&quot;);    &#125;     int listenfd, connfd;    socklen_t clilen;    struct sockaddr_un cliaddr, servaddr;     listenfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (listenfd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;     char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);     if (bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;     if (listen(listenfd, LISTENQ) &lt; 0) &#123;        error(1, errno, &quot;listen failed&quot;);    &#125;     clilen = sizeof(cliaddr);    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0) &#123;        if (errno == EINTR)            error(1, errno, &quot;accept failed&quot;);        /* back to for() */        else            error(1, errno, &quot;accept failed&quot;);    &#125;     char buf[BUFFER_SIZE];     while (1) &#123;        bzero(buf, sizeof(buf));        if (read(connfd, buf, BUFFER_SIZE) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s&quot;, buf);         char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, buf);         int nbytes = sizeof(send_line);         if (write(connfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);    &#125;     close(listenfd);    close(connfd);     exit(0); &#125;</code></pre><p>第 12～15 行非常关键，这里创建的套接字类型，注意是 AF_LOCAL，并且使用字节流格式。TCP 的类型是 AF_INET 和字节流类型；UDP 的类型是 AF_INET 和数据报类型。 AF_UNIX 也是可以的，基本上可以认为和 AF_LOCAL 是等价的。<br>第 17～21 行创建了一个本地地址，这里的本地地址和 IPv4、IPv6 地址可以对应，数据类型为 sockaddr_un，这个数据类型中的 sun_family 需要填写为 AF_LOCAL，最为关键的是需要对 sun_path 设置一个本地文件路径。我们这里还做了一个 unlink 操作，以便把存在的文件删除掉，这样可以保持幂等性。<br>第 23～29 行，分别执行 bind 和 listen 操作，这样就监听在一个本地文件路径标识的套接字上，这和普通的 TCP 服务端程序没什么区别。<br>第 41～56 行，使用 read 和 write 函数从套接字中按照字节流的方式读取和发送数据。</p><p>这个本地文件，必须是一个“文件”，不能是一个“目录”。如果文件不存在，后面 bind 操作时会自动创建这个文件。</p><p>下面我们再看一下客户端程序。</p><pre><code class="cpp">#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un servaddr;    sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, argv[1]);    if (connect(sockfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;connect failed&quot;);    &#125;    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int nbytes = sizeof(send_line);        if (write(sockfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);        if (read(sockfd, recv_line, MAXLINE) == 0)            error(1, errno, &quot;server terminated prematurely&quot;);        fputs(recv_line, stdout);    &#125;    exit(0);&#125;</code></pre><p>11～14 行创建了一个本地套接字，和前面服务器端程序一样，用的也是字节流类型 SOCK_STREAM。<br>16～18 行初始化目标服务器端的地址。我们知道在 TCP 编程中，使用的是服务器的 IP 地址和端口作为目标，在本地套接字中则使用文件路径作为目标标识，sun_path 这个字段标识的是目标文件路径，所以这里需要对 sun_path 进行初始化。<br>20 行和 TCP 客户端一样，发起对目标套接字的 connect 调用，不过由于是本地套接字，并不会有三次握手。<br>28～38 行从标准输入中读取字符串，向服务器端发送，之后将服务器端传输过来的字符打印到标准输出上。</p><p>本地字节流套接字和 TCP 服务器端、客户端编程最大的差异就是套接字类型的不同。本地字节流套接字识别服务器不再通过 IP 地址和端口，而是通过本地文件。</p><h2 id="只启动客户端"><a href="#只启动客户端" class="headerlink" title="只启动客户端"></a>只启动客户端</h2><p>第一个场景中，我们只启动客户端程序：</p><pre><code>$ ./unixstreamclient /tmp/unixstream.sockconnect failed: No such file or directory (2)</code></pre><p>由于没有启动服务器端，没有一个本地套接字在 &#x2F;tmp&#x2F;unixstream.sock 这个文件上监听，客户端直接报错，提示我们没有文件存在。</p><h2 id="服务器端监听在无权限的文件路径上"><a href="#服务器端监听在无权限的文件路径上" class="headerlink" title="服务器端监听在无权限的文件路径上"></a>服务器端监听在无权限的文件路径上</h2><p>在 Linux 下，执行任何应用程序都有应用属主的概念。在这里，我们让服务器端程序的应用属主没有 &#x2F;var&#x2F;lib&#x2F; 目录的权限，然后试着启动一下这个服务器程序 ：</p><pre><code>$ ./unixstreamserver /var/lib/unixstream.sockbind failed: Permission denied (13)</code></pre><p>这个结果告诉我们启动服务器端程序的用户，必须对本地监听路径有权限。<br>试一下 root 用户启动该程序：</p><pre><code>sudo ./unixstreamserver /var/lib/unixstream.sock(阻塞运行中)</code></pre><p>打开另外一个 shell，我们看到 &#x2F;var&#x2F;lib 下创建了一个本地文件，大小为 0，而且文件的最后结尾有一个（&#x3D;）号。其实这就是 bind 的时候自动创建出来的文件。</p><pre><code>$ ls -al /var/lib/unixstream.sockrwxr-xr-x 1 root root 0 Jul 15 12:41 /var/lib/unixstream.sock=</code></pre><p>如果我们使用 netstat 命令查看 UNIX 域套接字，就会发现 unixstreamserver 这个进程，监听在 &#x2F;var&#x2F;lib&#x2F;unixstream.sock 这个文件路径上。</p><h2 id="服务器-客户端应答"><a href="#服务器-客户端应答" class="headerlink" title="服务器 - 客户端应答"></a>服务器 - 客户端应答</h2><p>现在，我们让服务器和客户端都正常启动，并且客户端依次发送字符：</p><pre><code>$./unixstreamserver /tmp/unixstream.sockReceive: g1Receive: g2Receive: g3client quit</code></pre><p>服务器端陆续收到客户端发送的字节，同时，客户端也收到了服务器端的应答；最后，当我们使用 Ctrol+C，让客户端程序退出时，服务器端也正常退出。</p><pre><code>$./unixstreamclient /tmp/unixstream.sockg1Hi, g1g2Hi, g2g3Hi, g3^C</code></pre><h2 id="本地数据报套接字"><a href="#本地数据报套接字" class="headerlink" title="本地数据报套接字"></a>本地数据报套接字</h2><p>我们再来看下在本地套接字上使用数据报的服务器端例子：</p><pre><code>#include  &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataserver &lt;local_path&gt;&quot;);    &#125;    int socket_fd;    socket_fd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (socket_fd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;    struct sockaddr_un servaddr;    char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);    if (bind(socket_fd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    char buf[BUFFER_SIZE];    struct sockaddr_un client_addr;    socklen_t client_len = sizeof(client_addr);    while (1) &#123;        bzero(buf, sizeof(buf));        if (recvfrom(socket_fd, buf, BUFFER_SIZE, 0, (struct sockadd *) &amp;client_addr, &amp;client_len) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s \n&quot;, buf);        char send_line[MAXLINE];        bzero(send_line, MAXLINE);        sprintf(send_line, &quot;Hi, %s&quot;, buf);        size_t nbytes = strlen(send_line);        printf(&quot;now sending: %s \n&quot;, send_line);        if (sendto(socket_fd, send_line, nbytes, 0, (struct sockadd *) &amp;client_addr, client_len) != nbytes)            error(1, errno, &quot;sendto error&quot;);    &#125;    close(socket_fd);    exit(0);&#125;</code></pre><p>本地数据报套接字和前面的字节流本地套接字有以下几点不同：</p><p>这里创建的套接字类型，注意是 AF_LOCAL，协议类型为 SOCK_DGRAM。<br>bind 到本地地址之后，没有再调用 listen 和 accept，这其实和 UDP 的性质一样。<br>使用 recvfrom 和 sendto 来进行数据报的收发，不再是 read 和 send</p><p>然后我们再看一下客户端的例子：</p><pre><code>#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un client_addr, server_addr;    sockfd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;client_addr, sizeof(client_addr));        /* bind an address for us */    client_addr.sun_family = AF_LOCAL;    strcpy(client_addr.sun_path, tmpnam(NULL));    if (bind(sockfd, (struct sockaddr *) &amp;client_addr, sizeof(client_addr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sun_family = AF_LOCAL;    strcpy(server_addr.sun_path, argv[1]);    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        size_t nbytes = strlen(send_line);        printf(&quot;now sending %s \n&quot;, send_line);        if (sendto(sockfd, send_line, nbytes, 0, (struct sockaddr *) &amp;server_addr, sizeof(server_addr)) != nbytes)            error(1, errno, &quot;sendto error&quot;);        int n = recvfrom(sockfd, recv_line, MAXLINE, 0, NULL, NULL);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>这个程序和 UDP 网络编程的例子基本是一致的，我们可以把它当做是用本地文件替换了 IP 地址和端口的 UDP 程序，不过，这里还是有一个非常大的不同的。</p><p>这个不同点是本地套接字 bind 到本地一个路径上，然而 UDP 客户端程序是不需要这么做的。本地数据报套接字这么做的原因是，它需要指定一个本地路径，以便在服务器端回包时，可以正确地找到地址；而在 UDP 客户端程序里，数据是可以通过 UDP 包的本地地址和端口来匹配的。</p><p>下面这段代码就展示了服务器端和客户端通过数据报应答的场景：</p><pre><code>./unixdataserver /tmp/unixdata.sockReceive: g1now sending: Hi, g1Receive: g2now sending: Hi, g2Receive: g3now sending: Hi, g3</code></pre><p>我们可以看到，服务器端陆续收到客户端发送的数据报，同时，客户端也收到了服务器端的应答。</p><pre><code>$ ./unixdataclient /tmp/unixdata.sockg1now sending g1Hi, g1g2now sending g2Hi, g2g3now sending g3Hi, g3^C</code></pre><p>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议。<br>本地套接字的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报套接字实现。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UDP</title>
      <link href="/p/6a48eebc.html"/>
      <url>/p/6a48eebc.html</url>
      
        <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>TCP 是一个面向连接的协议，TCP 在 IP 报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定的上下文中工作的。</p><p>而 UDP 则不同，UDP 没有这样一个确定的上下文，它是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。我们可以简单地理解为，在 IP 报文的基础上，UDP 增加的能力有限。<br>UDP 不保证报文的有效传递，不保证报文的有序，也就是说使用 UDP 的时候，我们需要做好丢包、重传、报文组装等工作。</p><p><img src="https://s1.ax1x.com/2023/07/19/pC7BS54.png" alt="pC7BS54.png"></p><p>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 recvfrom 函数等待客户端的报文发送；客户端创建套接字之后，调用 sendto 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程。<br>recvfrom 和 sendto 是 UDP 用来接收和发送报文的两个主要函数：</p><pre><code>#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,const struct sockaddr *to, socklen_t *addrlen); </code></pre><p>先来看一下 recvfrom 函数。</p><ul><li><p>sockfd、buff 和 nbytes 是前三个参数。sockfd 是本地创建的套接字描述符，buff 指向本地的缓存，nbytes 表示最大接收数据字节。第四个参数 flags 是和 I&#x2F;O 相关的参数，这里我们还用不到，设置为 0。</p></li><li><p>后面两个参数 from 和 addrlen，实际上是返回对端发送方的地址和端口等信息，这和 TCP 非常不一样，TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息。另外 UDP 报文每次接收都会获取对端的信息，也就是说报文和报文之间是没有上下文的。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>接下来看一下 sendto 函数。</p><ul><li><p>sendto 函数中的前三个参数为 sockfd、buff 和 nbytes。sockfd 是本地创建的套接字描述符，buff 指向发送的缓存，nbytes 表示发送字节数。第四个参数 flags 依旧设置为 0。</p></li><li><p>后面两个参数 to 和 addrlen，表示发送的对端地址和端口等信息。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>TCP 的发送和接收每次都是在一个上下文中，类似这样的过程：</p><p>A 连接上: 接收→发送→接收→发送→…<br>B 连接上: 接收→发送→接收→发送→ …</p><p>而 UDP 的每次接收和发送都是一个独立的上下文，类似这样：</p><p>接收 A→发送 A→接收 B→发送 B →接收 C→发送 C→ …</p><h2 id="UDP-服务端例子"><a href="#UDP-服务端例子" class="headerlink" title="UDP 服务端例子"></a>UDP 服务端例子</h2><p>先来看一个 UDP 服务器端的例子：</p><pre><code>#include &quot;lib/common.h&quot;static int count;static void recvfrom_int(int signo) &#123;    printf(&quot;\nreceived %d datagrams\n&quot;, count);    exit(0);&#125;int main(int argc, char **argv) &#123;    int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);    bind(socket_fd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));    socklen_t client_len;    char message[MAXLINE];    count = 0;    signal(SIGINT, recvfrom_int);//信号    struct sockaddr_in client_addr;    client_len = sizeof(client_addr);    for (;;) &#123;        int n = recvfrom(socket_fd, message, MAXLINE, 0, (struct sockaddr *) &amp;client_addr, &amp;client_len);        message[n] = 0;        printf(&quot;received %d bytes: %s\n&quot;, n, message);        char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, message);        sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;client_addr, client_len);        count++;    &#125;&#125;</code></pre><p>首先创建一个套接字，这里的套接字类型是“SOCK_DGRAM”，表示的是 UDP 数据报。<br>绑定数据报套接字到本地的一个端口上。<br>为该服务器创建了一个信号处理函数，以便在响应“Ctrl+C”退出时，打印出收到的报文总数。<br>通过调用 recvfrom 函数获取客户端发送的报文，之后我们对收到的报文进行重新改造，加上“Hi”的前缀，再通过 sendto 函数发送给客户端对端。</p><h2 id="UDP-客户端例子"><a href="#UDP-客户端例子" class="headerlink" title="UDP 客户端例子"></a>UDP 客户端例子</h2><p>接下来我们再来构建一个对应的 UDP 客户端。在这个例子中，从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上。</p><pre><code>#include &quot;lib/common.h&quot;# define    MAXLINE     4096int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: udpclient &lt;IPaddress&gt;&quot;);    &#125;        int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    struct sockaddr *reply_addr;    reply_addr = malloc(server_len);    char send_line[MAXLINE], recv_line[MAXLINE + 1];    socklen_t len;    int n;    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        printf(&quot;now sending %s\n&quot;, send_line);        size_t rt = sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;server_addr, server_len);        if (rt &lt; 0) &#123;            error(1, errno, &quot;send failed &quot;);        &#125;        printf(&quot;send bytes: %zu \n&quot;, rt);        len = 0;        n = recvfrom(socket_fd, recv_line, MAXLINE, 0, reply_addr, &amp;len);        if (n &lt; 0)            error(1, errno, &quot;recvfrom failed&quot;);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>创建一个类型为“SOCK_DGRAM”的套接字。<br>初始化目标服务器的地址和端口。<br>从标准输入中读取的字符进行处理后，调用 sendto 函数发送给目标服务器端，然后再次调用 recvfrom 函数接收目标服务器发送过来的新报文，并将其打印到标准输出上。</p><h2 id="UDP-的三种运行场景"><a href="#UDP-的三种运行场景" class="headerlink" title="UDP 的三种运行场景"></a>UDP 的三种运行场景</h2><h3 id="只运行客户端"><a href="#只运行客户端" class="headerlink" title="只运行客户端"></a>只运行客户端</h3><p>如果我们只运行客户端，程序会一直阻塞在 recvfrom 上。</p><pre><code>$ ./udpclient 127.0.0.11now sending g1send bytes: 2&lt; 阻塞在这里 &gt;</code></pre><p>如果不开启服务端，TCP 客户端的 connect 函数会直接返回“Connection refused”报错信息。而在 UDP 程序里，则会一直阻塞在这里。</p><h3 id="先开启服务端，再开启客户端"><a href="#先开启服务端，再开启客户端" class="headerlink" title="先开启服务端，再开启客户端"></a>先开启服务端，再开启客户端</h3><p>我们先开启服务端在端口侦听，然后再开启客户端</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2$./udpclient 127.0.0.1g1now sending g1send bytes: 2Hi, g1g2now sending g2send bytes: 2Hi, g2</code></pre><h3 id="开启服务端，再一次开启两个客户端"><a href="#开启服务端，再一次开启两个客户端" class="headerlink" title="开启服务端，再一次开启两个客户端"></a>开启服务端，再一次开启两个客户端</h3><p>这个实验中，在服务端开启之后，依次开启两个客户端，并发送报文。</p><p>服务端：</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4</code></pre><p>两个客户端发送的报文，依次都被服务端收到，并且客户端也可以收到服务端处理之后的报文。<br>如果我们此时把服务器端进程杀死，就可以看到信号函数在进程退出之前，打印出服务器端接收到的报文个数。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams</code></pre><p>我们再重启服务器端进程，并使用客户端 1 和客户端 2 继续发送新的报文，我们可以看到和 TCP 非常不同的结果。<br>TCP 断联之后必须重新连接才可以发送报文信息。但是 UDP 报文的”无连接“的特点，可以在 UDP 服务器重启之后，继续进行报文的发送，这就是 UDP 报文“无上下文”的最好说明。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams$ ./udpserverreceived 2 bytes: g5received 2 bytes: g6</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3g5now sending g5send bytes: 2Hi, g5</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4g6now sending g6send bytes: 2Hi, g6</code></pre><p>UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。<br>UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。</p><h2 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a>QUIC 是如何实现可靠传输的？</h2><p>在 UDP 报文头部与  HTTP&#x2F;3  消息之间，共有 3 层头部：</p><h3 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h3><p>Packet Header 细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。<br>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。所以，你可以看到日常传输数据的 Short Packet Header 不需要在传输 Source Connection ID 字段了，只需要传输 Destination Connection ID。<br>Short Packet Header 中的 Packet Number 是每个报文独一无二的编号，它是严格递增的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。<br>比如上图，当 TCP 发生超时重传后，客户端发起重传，然后接收到了服务端确认 ACK 。由于客户端原始报文和重传报文序列号都是一样的，那么服务端针对这两个报文回复的都是相同的 ACK。</li></ul><p>这样的话，客户端就无法判断出是「原始报文的响应」还是「重传报文的响应」，这样在计算 RTT（往返时间） 时应该选择从发送原始报文开始计算，还是重传原始报文开始计算呢？</p><ul><li>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。</li><li>如果算成重传请求的响应，但实际上是原始请求的响应（上图右），又很容易导致采样 RTT 过小。<br>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。<br>还有一个好处，QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</li></ul><p>Packet Number 单调递增的两个好处：</p><ul><li>可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；</li><li>可以支持乱序确认，因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；</li></ul><h3 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h3><p>一个 Packet 报文中可以存放多个 QUIC Frame。<br>每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同<br>说到 Packet Number 是严格递增，即使重传报文的 Packet Number 也是递增的，既然重传数据包的 Packet N+M 与丢失数据包的 Packet N 编号并不一致，我们怎么确定这两个数据包的内容一样呢？<br>所以引入 Frame Header 这一层，通过 Stream ID + Offset 字段信息实现数据的有序性，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。<br>数据包 Packet N 丢失了，后面重传该数据包的编号为 Packet N+2，丢失的数据包和重传的数据包 Stream ID 与 Offset 都一致，说明这两个数据包的内容一致。这些数据包传输到接收端后，接收端能根据 Stream ID 与 Offset 字段信息将 Stream x 和 Stream x+y 按照顺序组织起来，然后交给应用程序处理。<br>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p><h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><p>TCP 队头阻塞的问题，其实就是接收窗口的队头阻塞问题。</p><p>接收方收到的数据范围必须在接收窗口范围内，如果收到超过接收窗口范围的数据，就会丢弃该数据，比如接收窗口的范围是 32 ～ 51 字节，如果收到第 52 字节以上数据都会被丢弃。当接收窗口收到有序数据时，接收窗口才能往前滑动，然后那些已经接收并且被确认的「有序」数据就可以被应用层读取。当接收窗口收到的数据不是有序的，比如收到第 33～40 字节的数据，由于第 32 字节数据没有收到， 接收窗口无法向前滑动，那么即使先收到第 33～40 字节的数据，这些数据也无法被应用层读取的。只有当发送方重传了第 32 字节数据并且被接收方收到后，接收窗口才会往前滑动，然后应用层才能从内核读取第 32～40 字节的数据。</p><p>HTTP&#x2F;2 通过抽象出 Stream 的概念，实现了 HTTP 并发传输，一个 Stream 就代表 HTTP&#x2F;1.1 里的请求和响应。在 HTTP&#x2F;2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。<br>但是 HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p><p>QUIC 也借鉴 HTTP&#x2F;2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。<br>但是 QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。<br>假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>TCP 流量控制是通过让「接收方」告诉「发送方」，它（接收方）的接收窗口有多大，从而让「发送方」根据「接收方」的实际接收能力控制发送的数据量。</p><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。<br>QUIC 的 每个 Stream 都有各自的滑动窗口，不同 Stream 互相独立，队头的 Stream A 被阻塞后，不妨碍 StreamB、C的读取。而对于 HTTP&#x2F;2 而言，所有的 Stream 都跑在一条 TCP 连接上，而这些 Stream 共享一个滑动窗口，因此同一个Connection内，Stream A 被阻塞后，StreamB、C 必须等待。</li></ul><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><ul><li>Stream 级别的流量控制：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li><li>Connection 流量控制：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。<br>接收窗口的左边界取决于接收到的最大偏移字节数，此时的接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</li></ul><p>这里就可以看出 QUIC 的流量控制和 TCP 有点区别了：</p><ul><li>TCP 的接收窗口只有在前面所有的 Segment 都接收的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口也不会移动。</li><li>QUIC 的接收窗口的左边界滑动条件取决于接收到的最大偏移字节数。</li></ul><p>当已收到的顺序的数据超过最大接收窗口的一半后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到窗口滑动的效果。<br>如果中途丢失了数据包，导致已收到的顺序的数据没有超过最大接收窗口的一半，那接收窗口就无法滑动了，这个只影响同一个 Stream，其他 Stream 是不会影响的，因为每个 Stream 都有各自的滑动窗口。</p><h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><p>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，所以 TCP 拥塞控制算法迭代速度是很慢的。而 QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较快的迭代速度。</p><p>TCP 更改拥塞控制算法是对系统中所有应用都生效，无法根据不同应用设定不同的拥塞控制策略。但是因为 QUIC 处于应用层，所以就可以针对不同的应用设置不同的拥塞控制算法，这样灵活性就很高了。</p><h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手（1RTT），再 TLS 握手（2RTT），所以需要 3RTT 的延迟才能传输数据，就算 Session 会话复用，也需要至少 2 个 RTT。<br>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接。</p><p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接</title>
      <link href="/p/d6bcf660.html"/>
      <url>/p/d6bcf660.html</url>
      
        <content type="html"><![CDATA[<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。<br>因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。<br>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p><ul><li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h2 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h2><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。<br>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li>Socket：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题等</li><li>窗口大小：用来做流量控制</li></ul><p>如何唯一确定一个 TCP 连接呢？<br>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p>服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p><ul><li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li>系统级：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；</li><li>用户级：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；</li><li>进程级：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li></ul></li><li>内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>先从服务器端开始，看看tcp如何连接的。</p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>创建一个可用的套接字要使用下面的函数：</p><pre><code>int socket(int domain, int type, int protocol)</code></pre><p>domain 就是指 PF_INET、PF_INET6 以及 PF_LOCAL 等，表示什么样的套接字。</p><p>type 可用的值是：</p><ul><li>SOCK_STREAM: 表示的是字节流，对应 TCP；</li><li>SOCK_DGRAM： 表示的是数据报，对应 UDP；</li><li>SOCK_RAW: 表示的是原始套接字。</li></ul><p>参数 protocol 原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。protocol 目前一般写成 0 即可。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>创建出来的套接字如果需要被别人使用，就需要调用 bind 函数把套接字和套接字地址绑定</p><pre><code>bind(int fd, sockaddr * addr, socklen_t len)</code></pre><p>bind 函数后面的第二个参数是通用地址格式sockaddr * addr。这里有一个地方值得注意，那就是虽然接收的是通用地址格式，实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式。bind 函数会根据 len 字段判断传入的参数 addr 该怎么解析，len 字段表示的就是传入的地址长度，它是一个可变值。<br>对于使用者来说，每次需要将 IPv4、IPv6 或者本地套接字格式转化为通用套接字格式，就像下面的 IPv4 套接字地址格式的例子一样：</p><pre><code>struct sockaddr_in name;bind (sock, (struct sockaddr *) &amp;name, sizeof (name)</code></pre><p>对于实现者来说，可根据该地址结构的前两个字节判断出是哪种地址。为了处理长度可变的结构，需要读取函数里的第三个参数，也就是 len 字段，这样就可以对地址进行解析和判断了。</p><p>设置 bind 的时候，对地址和端口可以有多种处理方式。我们可以把地址设置成本机的 IP 地址，这相当告诉操作系统内核，仅仅对目标 IP 是本机 IP 地址的 IP 包进行处理。但是这样写的程序在部署时有一个问题，我们编写应用程序时并不清楚自己的应用程序将会被部署到哪台机器上。这个时候，可以利用通配地址的能力帮助我们解决这个问题。比如一台机器有两块网卡，IP 地址分别是 202.61.22.55 和 192.168.1.11，那么向这两个 IP 请求的请求包都会被我们编写的应用程序处理。<br>对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置；对于 IPv6 的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置。</p><pre><code>struct sockaddr_in name;name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4 通配地址 */</code></pre><p>除了地址，还有端口。如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核来处理，操作系统内核会根据一定的算法选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用。<br>一般来说，服务器端的程序一定要绑定到一个众所周知的端口上。服务器端的 IP 地址和端口数据，相当于打电话拨号时需要知道的对方号码，如果没有电话号码，就没有办法和对方建立连接。</p><pre><code>include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int make_socket (uint16_t port)&#123;    int sock;    struct sockaddr_in name;        /* 创建字节流类型的 IPV4 socket. */    sock = socket (PF_INET, SOCK_STREAM, 0);    if (sock &lt; 0)    &#123;        perror (&quot;socket&quot;);        exit (EXIT_FAILURE);    &#125;        /* 绑定到 port 和 ip. */    name.sin_family = AF_INET; /* IPV4 */    name.sin_port = htons (port);  /* 指定端口 */    name.sin_addr.s_addr = htonl (INADDR_ANY); /* 通配地址 */    /* 把 IPV4 地址转换成通用地址格式，同时传递长度 */    if (bind (sock, (struct sockaddr *) &amp;name, sizeof (name)) &lt; 0)    &#123;        perror (&quot;bind&quot;);        exit (EXIT_FAILURE);    &#125;            return sock&#125;</code></pre><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 connect 函数，后面会讲到）。通过 listen 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：“我这个套接字是用来等待用户请求的。”当然，操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。<br>listen 函数的原型是这样的：</p><pre><code>int listen (int socketfd, int backlog)</code></pre><p>第一个参数 socketfd 为套接字描述符，第二个参数 backlog，官方的解释为未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目。这个参数越大，并发数目理论上也会越大。但是参数过大也会占用过多的系统资源，一些系统，比如 Linux 并不允许对这个参数进行改变。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这个时候操作系统内核需要把这个事件通知到应用程序，并让应用程序感知到这个连接。<br>accept 这个函数的作用就是连接建立之后，操作系统内核和应用程序之间的桥梁。它的原型是：</p><pre><code>int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)</code></pre><p>第一个参数 listensockfd 是套接字，可以叫它为 listen 套接字，因为这就是前面通过 bind，listen 一系列操作而得到的套接字。函数的返回值有两个部分，第一个部分 cliadd 是通过指针方式获取的客户端的地址，addrlen 告诉我们地址的大小；另一个部分是函数的返回值，这个返回值是一个全新的描述字，代表了与客户端的连接。<br>第一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><p>一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>第一步还是和服务端一样，要建立一个套接字，方法和前面是一样的。</p><p>不一样的是客户端需要调用 connect 向服务端发起请求。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>客户端和服务器端的连接建立，是通过 connect 函数完成的。这是 connect 的构建函数：</p><pre><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code></pre><p>函数的第一个参数 sockfd 是连接套接字，通过前面讲述的 socket 函数创建。第二个、第三个参数 servaddr 和 addrlen 分别代表指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的 IP 地址和端口号。</p><p>客户在调用函数 connect 前不必非得调用 bind 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口。</p><p>如果是 TCP 套接字，那么调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：</p><ul><li>三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。</li><li>客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。产生 RST 的三个条件是：目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；TCP 想取消一个已有连接；TCP 接收到一个根本不存在的连接上的分节。</li><li>客户发出的 SYN 包在网络上引起了”destination unreachable”，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。</li></ul><h2 id="发送和接受"><a href="#发送和接受" class="headerlink" title="发送和接受"></a>发送和接受</h2><p>连接建立的根本目的是为了数据的收发，首先我们先来看一下发送数据。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>发送数据时常用的有三个函数，分别是 write、send 和 sendmsg。</p><pre><code>size_t write (int socketfd, const void *buffer, size_t size)size_t send (int socketfd, const void *buffer, size_t size, int flags)size_t sendmsg(int sockfd, const struct msghdr *msg, int flags)</code></pre><p>第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。<br>如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。<br>如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。</p><p>既然套接字描述符是一种特殊的描述符，那么在套接字描述符上调用 write 函数，应该和在普通文件描述符上调用 write 函数的行为是一致的，都是通过描述符句柄写入指定的数据。</p><p>乍一看，两者的表现形式是一样，内在的区别还是很不一样的。</p><p>对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。<br>对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的。</p><h3 id="发送缓冲区"><a href="#发送缓冲区" class="headerlink" title="发送缓冲区"></a>发送缓冲区</h3><p>当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。</p><p>这里有几种情况：</p><ul><li><p>第一种情况很简单，操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，那么皆大欢喜，我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小。</p></li><li><p>第二种情况是，操作系统内核的发送缓冲区是够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，操作系统内核并不会返回，也不会报错，而是应用程序被阻塞，也就是说应用程序在 write 函数调用处停留，不直接返回。大部分 UNIX 系统的做法是一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回。</p></li></ul><p>发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据。至于什么时候发送到对端的接收缓冲区，或者更进一步说，什么时候被对方应用程序缓冲所接收，对我们而言完全都是透明的。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>套接字描述本身和本地文件描述符并无区别，在 UNIX 的世界里万物都是文件，这就意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。这些函数包括 read 和 write 交换数据的函数。</p><p>先从最简单的 read 函数开始看起，这个函数的原型如下：</p><pre><code>size_t read (int socketfd, void *buffer, size_t size)</code></pre><p>read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；</p><p>这里是最多读取 size 个字节。如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取。</p><pre><code>/* 从 socketfd 描述字中读取 &quot;size&quot; 个字节. */ssize_t readn(int fd, void *vptr, size_t size)&#123;    size_t  nleft;    ssize_t nread;    char    *ptr;    ptr = vptr;    nleft = size;        while (nleft &gt; 0) &#123;        if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;            if (errno == EINTR)                nread = 0;      /* 这里需要再次调用 read */            else                return(-1);        &#125; else if (nread == 0)            break;              /* EOF(End of File) 表示套接字关闭 */        nleft -= nread;        ptr   += nread;    &#125;    return(n - nleft);      /* 返回的是实际读取的字节数 */&#125;</code></pre><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们先看一下最初的过程，服务器端通过 socket，bind 和 listen 完成了被动套接字的准备工作，被动的意思就是等着别人来连接，然后调用 accept，就会阻塞在这里，等待客户端的连接来临；客户端通过调用 socket 和 connect 函数之后，也会阻塞。接下来的事情是由操作系统内核完成的，更具体一点的说，是操作系统内核网络协议栈在工作。<br>下面是具体的过程：</p><ul><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，指明客户端打算连接的服务器的端口，客户端进入 SYNC_SENT 状态；</li><li>服务器端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack&#x3D;J+1，随机产生一个序号值seq&#x3D;K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ul><p><img src="https://s1.ax1x.com/2023/07/27/pCxuSmD.png" alt="pCxuSmD.png"><br>这样就连接成功了</p><h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>两次为什么不行<br>防止失效的连接请求报文段被服务端接收，从而产生错误。<br>我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。<br>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</p><p>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p>如果是四次握手呢？无疑是做了无用功，因为三次握手，已经让双方都确认了接收数据的能力，再多次握手，也不过是确定了已经确定的事情。</p><h3 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h3><p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p><p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p><h3 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h3><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。</p><p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p><p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。</p><h3 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h3><p>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p><p>这里就涉及到SYN攻击<br>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务。<br>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接对象。</li></ul><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p><p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；<ul><li>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</li><li>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 cookie 值；</li><li>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li><li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li><li>最后应用程序通过调用 accpet() 接口，从「 Accept 队列」取出的连接。</li></ul></li><li>减少 SYN+ACK 重传次数</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br><img src="https://s1.ax1x.com/2023/07/27/pCxu2He.png" alt="pCxu2He.png"></p><p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p><ul><li>第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</li><li>第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</li><li>第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</li><li>第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</li></ul><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h3><p>建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。</p><p>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h3 id="第一次挥手丢失了，会发生什么"><a href="#第一次挥手丢失了，会发生什么" class="headerlink" title="第一次挥手丢失了，会发生什么"></a>第一次挥手丢失了，会发生什么</h3><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。</p><p>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 close 状态。</p><h3 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h3><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。</p><p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><p>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。<br>对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭<br>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p><p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态</p><h3 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h3><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。<br>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><p>具体过程：</p><ul><li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li></ul><h3 id="第四次挥手丢失会发生什么？"><a href="#第四次挥手丢失会发生什么？" class="headerlink" title="第四次挥手丢失会发生什么？"></a>第四次挥手丢失会发生什么？</h3><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。</p><p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</p><p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p><p>具体过程：</p><p>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。<br>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</p><h3 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h3><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。有以下两个原因：</p><p>第一点：保证TCP协议的全双工连接能够可靠关闭：<br>由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于CLOESD状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT，如果第四次挥手ACK报文没到达服务端，接收方会重新发送第三次挥手的报文给客户端，客户端收到之后，就知道之前第四次挥手的 ACK 报文丢失了，然后再次发送 ACK 报文。确保正确地结束这次连接。<br>第二点：保证这次连接的重复数据段从网络中消失<br>如果Client端发送最后的ACK直接进入CLOSED状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。</p><p>IME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p><p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p>可以看到 2MSL时长 这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><h3 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h3><p>关闭的连接的函数有两种函数：</p><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。<br>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。<br>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p><p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。<br>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN。</p><h3 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h3><p>当被动关闭方在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><h3 id="CLOSE-WAIT-和TIME-WAIT-的状态和意义"><a href="#CLOSE-WAIT-和TIME-WAIT-的状态和意义" class="headerlink" title="CLOSE-WAIT 和TIME-WAIT 的状态和意义"></a>CLOSE-WAIT 和TIME-WAIT 的状态和意义</h3><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p><p>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。<br>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p><h3 id="Time-wait过多有什么危害"><a href="#Time-wait过多有什么危害" class="headerlink" title="Time_wait过多有什么危害?"></a>Time_wait过多有什么危害?</h3><p>内存资源占用、端口资源占用(一个TCP连接至少消耗一个端口)，每端口，无法建立新连接。<br>服务器资源受限:服务器监听一个端口，会把连接丢给线程处理，可以继续监听端口，但是线程池处理不了那么多连接。</p><h3 id="Time-wait状态过多的优化"><a href="#Time-wait状态过多的优化" class="headerlink" title="Time_wait状态过多的优化?"></a>Time_wait状态过多的优化?</h3><p>什么时候产生: 首先调用close()发起主动关闭的一方，再发送最后一个ACK之后。<br>为何产生:  确保最后一个ACK到达，保证TCP全双工连接可靠释放;使旧的数据包过期消失。什么时候会产生大量Time_wait:当请求量比较大的时候，而且所有的请求都是短连接的时候。<br>如何避免: 多IP增加随机端口;内核参数调优（服务器设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口)﹔使用长连接(Connection: keep-alive) 、 Linux参数net.ipv4.tcp_tw_reuse和 tcp_timestamps开启，复用处于TIME_WAIT的socket为新的连接所用。</p><h2 id="TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制"></a>TCP 重传、滑动窗口、流量控制、拥塞控制</h2><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>但在错综复杂的网络，并不一定能正常的数据传输，万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用重传机制解决。<br>常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p>RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。<br>超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。</p><ul><li>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p><p>估计往返时间，通常需要采样以下两个：</p><ul><li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li><li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li></ul><p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。</p><p>也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>于是就可以用「快速重传」机制来解决超时重发的时间等待</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>TCP 还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。<br>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。<br>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。</p><h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment）， 选择性确认。</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。<br>发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。<br>如果要支持 SACK，必须双方都要支持。</p><h4 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h4><p>Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p><p>下面举例两个例子，来说明 D-SACK 的作用。<br>例子一号：ACK 丢包</p><ul><li>接收方发给发送方的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li>于是接收方发现数据是重复收到的，于是回了一个 SACK &#x3D; 3000<del>3500，告诉发送方 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。</li><li>这样发送方就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li></ul><p>例子二号：网络延时</p><ul><li>数据包（1000~1499） 被网络延迟了，导致发送方没有收到 Ack 1500 的确认报文。</li><li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了接收方；</li><li>所以接收方回了一个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</li><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li></ul><p>可见，D-SACK 有这么几个好处：</p><ul><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。<br>这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。</p><p>为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。<br>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p><ul><li>客户端向服务端发送请求数据报文。服务端作为发送方</li><li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号是 321。</li><li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，RCV.NXT 也就指向 321，这意味着客户端期望的下一个报文的序列号是 321，接着发送确认报文给服务端。</li><li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法再继续发送数据。</li><li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，RCV.NXT 也就指向 441，接着发送确认报文给服务端。</li><li>服务端收到对 80 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 321，于是可用窗口 Usable 增大到 80。</li><li>服务端收到对 120 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 441，于是可用窗口 Usable 增大到 200。</li><li>服务端可以继续发送了，于是发送了 160 字节的数据后，SND.NXT 指向 601，于是可用窗口 Usable 减少到 40。</li><li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，RCV.NXT 也就是指向了 601，接着发送确认报文给服务端。</li><li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 SND.UNA 指针偏移了 160 后指向 601，可用窗口 Usable 也就增大至了 200。</li></ul><p>如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</p><p>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。<br>为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</p><p>如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。<br>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；<br>如果接收窗口不是 0，那么死锁的局面就可以被打破了。<br>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</p><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p><p>到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</p><p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了。<br>糊涂窗口综合症的现象是可以发生在发送方和接收方：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据<br>于是，要解决糊涂窗口综合症，就要同时解决上面两个问题就可以了：</li><li>让接收方不通告小窗口给发送方</li><li>让发送方避免发送小数据</li></ul><p>接收方通常的策略如下:</p><ul><li>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。</li><li>等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</li></ul><p>发送方通常的策略如下:</p><p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p><ul><li>条件一：要等到窗口大小 &gt;&#x3D; MSS 并且 数据大小 &gt;&#x3D; MSS；</li><li>条件二：收到之前发送数据的 ack 回包；</li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….<br>TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。<br>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。</p><p>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 cwnd 变化的规则：</p><ul><li>只要网络中没有出现拥塞，cwnd 就会增大；</li><li>但网络中出现了拥塞，cwnd 就减少；<br>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</li></ul><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p><p>慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。<br>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 cwnd &#x3D; 1，表示可以传一个 MSS 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。<br>可以看出慢启动算法，发包的个数是指数性的增长。<br>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</li><li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li><li>当 cwnd &gt;&#x3D; ssthresh 时，就会使用「拥塞避免算法」。</li></ul><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。<br>接上前面的慢启动的栗子，现假定 ssthresh 为 8：<br>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。<br>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li><p>超时重传</p></li><li><p>快速重传<br>这两种使用的拥塞发送算法是不同的，接下来分别来说说。<br>当发生了「超时重传」，则就会使用拥塞发生算法。<br>这个时候，ssthresh 和 cwnd 的值会发生变化：</p></li><li><p>ssthresh 设为 cwnd&#x2F;2，</p></li><li><p>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）<br>还有更好的方式，就是前面的「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。<br>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p></li><li><p>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</p></li><li><p>ssthresh &#x3D; cwnd;</p></li><li><p>进入快速恢复算法</p></li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p><p>进入快速恢复之前，cwnd 和 ssthresh 已被更新了：<br>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;<br>ssthresh &#x3D; cwnd;<br>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表存储格式</title>
      <link href="/p/de74da3e.html"/>
      <url>/p/de74da3e.html</url>
      
        <content type="html"><![CDATA[<p>在 MySQL 中，表的行格式是指表中存储的行数据在磁盘上的存储方式。MySQL 支持多种行格式，不同的行格式有不同的特点和适用场景。在函数中，我们使用 switch 语句根据传入的 enum 值来确定对应的行格式，并返回相应的字符串。</p><p>以下是对应关系的解释：</p><ul><li>ast.RowFormatDefault：表示默认行格式，没有显式指定行格式时使用的默认值。</li><li>ast.RowFormatFixed：表示固定行格式，适用于具有固定长度的行数据。</li><li>ast.RowFormatCompact：表示紧凑行格式，适用于大部分情况下的行数据。</li><li>ast.RowFormatCompressed：表示压缩行格式，适用于对数据进行压缩以减少存储空间的情况。</li><li>ast.RowFormatDynamic：表示动态行格式，适用于具有可变长度的行数据。</li><li>ast.RowFormatRedundant：表示冗余行格式，适用于具有较大数据行的情况。</li></ul><p>如果传入的 enum 值没有对应的行格式，函数将返回空字符串 “”。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字面量</title>
      <link href="/p/ddc66992.html"/>
      <url>/p/ddc66992.html</url>
      
        <content type="html"><![CDATA[<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。</p><pre><code>#include &lt;chrono&gt;#include &lt;complex&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;i * i = &quot; &lt;&lt; 1i * 1i &lt;&lt; endl;    cout &lt;&lt; &quot;Waiting for 500ms&quot; &lt;&lt; endl;    this_thread::sleep_for(500ms);    cout &lt;&lt; &quot;Hello world&quot;s.substr(0, 5) &lt;&lt; endl;&#125;</code></pre><p>输出结果为：</p><pre><code>i * i = (-1,0)Waiting for 500msHello</code></pre><p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 basic_string 字面量的后缀。<br>上面使用了 using namespace std，这会同时引入std 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p><pre><code>std::literals::complex_literalsstd::literals::chrono_literalsstd::literals::string_literals</code></pre><p>在产品项目中，一般不会（也不应该）全局使用 using namespace std<br>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 _打头。比如，假如我们有下面的长度类：</p><pre><code>struct length &#123;    double value;    enum unit &#123;        metre,        kilometre,        millimetre,        centimetre,        inch,        foot,        yard,        mile,    &#125;;    static constexpr double factors[] =        &#123;1.0, 1000.0, 1e-3,        1e-2, 0.0254, 0.3048,        0.9144, 1609.344&#125;;    explicit length(double v, unit u = metre) &#123;        value = v * factors[u];    &#125;&#125;;length operator+(length lhs, length rhs) &#123;    return length(lhs.value + rhs.value);&#125;// 可能有其他运算符</code></pre><p>我们可以手写 length(1.0, length::metre) 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p><pre><code> 1.0_m + 10.0_cm</code></pre><p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p><pre><code>length operator&quot;&quot; _m(long double v)&#123;    return length(v, length::metre);&#125;length operator&quot;&quot; _cm(long double v)&#123;    return length(v, length::centimetre);&#125;</code></pre><h2 id="二进制字面量"><a href="#二进制字面量" class="headerlink" title="二进制字面量"></a>二进制字面量</h2><p>我们知道c++有16进制，8进制，10进制表示方法，但是没有二进制<br>从 C++14 开始，我们对于二进制也有了直接的字面量：</p><pre><code>unsigned mask = 0b111000000;</code></pre><p>这在需要比特级操作等场合还是非常有用的。<br>遗憾的是， I&#x2F;O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p><pre><code>#include &lt;bitset&gt;cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;</code></pre><p>输出结果是：</p><pre><code>111000000</code></pre><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。C++14 开始，允许在数字型字面量中任意添加 ‘ 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。比如说：</p><ul><li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li><li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li><li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li><li>二进制数字使用三位的分隔，对应文件系统的权限分组</li></ul><p>一些例子如下：</p><pre><code>unsigned mask = 0b111&#39;000&#39;000;long r_earth_equatorial = 6&#39;378&#39;137;double pi = 3.14159&#39;26535&#39;89793;const unsigned magic = 0x44&#39;42&#39;47&#39;4E;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torm框架学习</title>
      <link href="/p/14433829.html"/>
      <url>/p/14433829.html</url>
      
        <content type="html"><![CDATA[<h1 id="torm"><a href="#torm" class="headerlink" title="torm"></a>torm</h1><p>TORM（Type-safe ORM）是一个强大的 Go 语言 ORM 库，具有以下特性</p><ul><li>精细化查询、插入、更新字段控制</li><li>类型安全</li><li><ul><li>软删除支持</li></ul></li><li>Id、创建、更新字段自动填充</li><li>分库分表支持</li><li>读写分离支持</li><li>使用 Hook 机制灵活拓展如 Prometheus 上报，自动加解密等</li><li>快，相比其他 ORM 框架性能损耗更少</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/p/1f4ac2fb.html"/>
      <url>/p/1f4ac2fb.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20,155,232,844,224,682,496.</p><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><pre><code>class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;stk;        map&lt;char,char&gt;table;        table.insert(&#123;&#39;(&#39;,&#39;)&#39;&#125;);        table.insert(&#123;&#39;[&#39;,&#39;]&#39;&#125;);        table.insert(&#123;&#39;&#123;&#39;,&#39;&#125;&#39;&#125;);        for(auto c:s)        &#123;            if(c==&#39;(&#39;||c==&#39;[&#39;||c==&#39;&#123;&#39;)            &#123;                stk.push(c);            &#125;            else            &#123;                if(stk.size()&amp;&amp;table[stk.top()]==c)                &#123;                    stk.pop();                &#125;                else&#123;                    return false;                &#125;            &#125;        &#125;        if(stk.size())return false;        return true;    &#125;&#125;;</code></pre><p>坑点有很多，比如每次pop需要注意栈非空，匹配结束如果栈有值则失败，思路想的时候很好代码实现总是遗漏要点。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/p/2362a8ea.html"/>
      <url>/p/2362a8ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr) &#123;            ListNode* next = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;;</code></pre><h2 id="判断环形链表"><a href="#判断环形链表" class="headerlink" title="判断环形链表"></a>判断环形链表</h2><pre><code>class Solution &#123;public:    bool hasCycle(ListNode* head) &#123;        ListNode* slow = head;        ListNode* fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if (fast == slow) &#123;    // 如果快慢指针相遇                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><pre><code>class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead = new ListNode(-1);        ListNode* prev = preHead;        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;            if (l1-&gt;val &lt; l2-&gt;val) &#123;                prev-&gt;next = l1;                l1 = l1-&gt;next;            &#125; else &#123;                prev-&gt;next = l2;                l2 = l2-&gt;next;            &#125;            prev = prev-&gt;next;        &#125;        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev-&gt;next = l1 == nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;</code></pre><h2 id="删除倒数节点"><a href="#删除倒数节点" class="headerlink" title="删除倒数节点"></a>删除倒数节点</h2><pre><code>class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        auto first=head;        auto second=first;        for(int i=0;i&lt;n;i++)&#123;            second=second-&gt;next;        &#125;        if(second==nullptr)return head-&gt;next;        second=second-&gt;next;        while(second!=nullptr)        &#123;            first=first-&gt;next;            second=second-&gt;next;        &#125;        auto temp=first-&gt;next;        first-&gt;next=temp-&gt;next;        delete temp;        return head;    &#125;&#125;;</code></pre><h2 id="返回中点"><a href="#返回中点" class="headerlink" title="返回中点"></a>返回中点</h2><pre><code>class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        auto slow=head;        auto fast=head;        while(fast&amp;&amp;fast-&gt;next)        &#123;            slow=slow-&gt;next;            fast=fast-&gt;next-&gt;next;        &#125;        return slow;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly与Rust实践</title>
      <link href="/p/13592136.html"/>
      <url>/p/13592136.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly与Rust实践"><a href="#WebAssembly与Rust实践" class="headerlink" title="WebAssembly与Rust实践"></a>WebAssembly与Rust实践</h1><div class="row">    <embed src="../../../pdf/WebAssembly与Rust实践.pdf" width="100%" height="550" type="application/pdf"></div><p>注：pdf为本人编写，不需要用图床比较方便，用图太多实在不想整理到博客了，下面内容不全，真心求教大佬们有没有什么魔法可以markdown粘贴图片绑定图床自动生成链接。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Rust编程语言和WebAssembly（Wasm）都是由Mozilla推动的前沿技术，并且它们在许多方面相互补充。<strong>Rust正致力于成为WebAssembly的首选编程语言</strong>。<br>Rust语言的最大特色之一是在保证系统性能的同时提供内存安全性。通过其所有权系统、借用检查器和生命周期规则，Rust可以在编译时捕获内存安全错误，避免了许多常见的内存错误，如空指针引用、数据竞争等。这使得Rust成为开发高性能、安全和可靠系统级软件的理想选择。<br>WebAssembly是一种可移植的低级字节码格式，可以在Web环境中运行。它的目标是在不同平台和语言之间提供统一的执行环境，并以接近原生的性能运行代码。WebAssembly允许以高效且安全的方式在Web浏览器中执行性能敏感的任务，同时保持与底层平台的兼容性。<br>Rust语言在与WebAssembly的结合方面有很多优势。Rust从诞生之初就考虑到与C语言的兼容性，使得使用Rust编写的代码可以直接与C语言的二进制接口（ABI）进行交互。这使得Rust成为编写WebAssembly模块的理想语言之一。Rust的Cargo包管理工具也为构建、打包和发布WebAssembly模块提供了便利。通过使用Rust和WebAssembly，开发人员可以借助Rust语言的安全性和性能优势，同时利用WebAssembly的跨平台和高性能特性，构建出功能强大、高效且安全的Web应用程序、浏览器扩展、游戏和其他Web平台的应用。</p><h2 id="安装WebAssembly开发环境"><a href="#安装WebAssembly开发环境" class="headerlink" title="安装WebAssembly开发环境"></a>安装WebAssembly开发环境</h2><p>Rust是目前WebAssembly生态中支持力度最强的一种语言。开源社区中不仅有Rust语言开发的WebAssembly虚拟机，还有基于WebAssembly模块的管理工具。<br>Rust语言默认安装的是生成本地应用的开发环境，因此WebAssembly开发环境需要单独安装。<br>首先查看有哪些环境可以安装：</p><pre><code> rustup target list | grep wasm</code></pre><p>运行结果如下所示：<br>• rustup target add wasm32-wasi：<br>    ◦ 这个指令将把wasm32-wasi目标加入到Rust工具链中。wasm32-wasi是用于WebAssembly系统接口(WASI)的目标，WASI是一种与操作系统无关的WebAssembly运行环境，允许在不同平台上运行WebAssembly模块。<br>• rustup target add wasm32-unknown-emscripten：<br>    ◦ 为了将 wasm32-unknown-emscripten 目标添加到 Rust 工具链，需要运行以下命令。wasm32-unknown-emscripten 是 Emscripten 工具链提供的一个目标，它能够将 Rust 代码编译为适用于浏览器环境的 WebAssembly 模块。<br>• rustup target add wasm32-unknown-unknown：<br>    ◦ 此命令将在 Rust 工具链中添加 wasm32-unknown-unknown 目标。wasm32-unknown-unknown 目标是一个通用的 WebAssembly 目标，适用于在不特定于操作系统或运行时环境的情况下构建 WebAssembly 模块。</p><p>了解环境之后，我们可以通过以下命令安装：</p><pre><code>rustup target add wasm32-wasirustup target add wasm32-unknown-emscriptenrustup target add wasm32-unknown-unknown</code></pre><p>为了方便测试和运行WebAssembly模块，还需要安装wasmer虚拟机环境。使用Scoop：</p><pre><code>scoop install wasmer</code></pre><p>安装成功之后，输入以下命令查看wasmer版本信息：</p><pre><code>wasmer -h</code></pre><h2 id="将Rust编译为wasm"><a href="#将Rust编译为wasm" class="headerlink" title="将Rust编译为wasm"></a>将Rust编译为wasm</h2><p>我们仍然使用刚才的入门测试程序，打印你好，世界！<br>然后，在编译时指定目标为wasm32-wasi：</p><pre><code>cargo build --target=wasm32-wasi</code></pre><p>在src同级目录下面，target&#x2F;wasm32-wasi&#x2F;debug&#x2F;内已经生成了对应的hello.wasm文件。<br>最后，通过wasmer工具运行该程序文件</p><pre><code>wasmer run target/wasm32-wasi/debug/hello.wasm</code></pre><p>可以看到程序正常输出</p><h2 id="导入和导出函数"><a href="#导入和导出函数" class="headerlink" title="导入和导出函数"></a>导入和导出函数</h2><h3 id="导出main-函数"><a href="#导出main-函数" class="headerlink" title="导出main()函数"></a>导出main()函数</h3><p>当在 Rust 中构建 WebAssembly 模块时，导入和导出函数是实现与宿主环境进行交互的关键部分。通过导入函数，可以在 Rust 模块中调用宿主环境中提供的功能，而通过导出函数，可以将 Rust 函数暴露给宿主环境使用。<br>上面测试时编译目标为wasm32-wasi，因此程序只能在宿主支持的WASI虚拟机环境运行。现在，我们设置编译目标为wasm32-unknown-unknown（即纯WebAssembly环境），然后查看其导出的函数。<br>输入以下命令重新构建：</p><pre><code>cargo build --target wasm32-unknown-unknown</code></pre><p>默认生成.&#x2F;target&#x2F;wasm32-unknown-unknown&#x2F;debug&#x2F;hello.wasm</p><p>可以看到我们已经导出了main函数。</p><p>我们还可以在Node.js环境，通过console.dir()调试函数查看导出的内容，在wasm对应目录下创建hello.js文件：</p><pre><code>const fs = require(&#39;fs&#39;);//readFileSync文件读取会阻塞代码的执行，直到读取完成const buf = fs.readFileSync(&#39;./hello.wasm&#39;);WebAssembly.instantiate(new Uint8Array(buf)).then(function(result) &#123;    console.dir(result.instance.exports);&#125;);</code></pre><p>运行代码，得到以下输出:</p><p>这说明普通的应用程序默认导出了main()函数。</p><h3 id="导入宿主打印函数"><a href="#导入宿主打印函数" class="headerlink" title="导入宿主打印函数"></a>导入宿主打印函数</h3><p>WebAssembly是一个与宿主环境隔离的虚拟机，因此WebAssembly模块不能直接访问宿主环境的控制台或文件系统等资源。为了在WebAssembly模块中输出信息，需要通过与宿主环境的交互来完成输出操作。<br>我们假定Node.js宿主环境提供了一个console_log()函数，用于输出一个整数值：</p><pre><code>function console_log(x) &#123;    console.log(x);&#125;</code></pre><p>这样就可以通过console_log()函数输出信息了。src&#x2F;main.rs内容修改如下：</p><pre><code>extern &quot;C&quot; &#123;    fn console_log(a: i32);&#125;fn main() &#123;    unsafe &#123;        console_log(42);    &#125;&#125;</code></pre><p>其中，紧跟extern “C”后的大括弧内是宿主导入函数声明，它们都是以C语言ABI规范导入。由于外部函数的实现是由宿主环境提供的，而不是由Rust代码控制的，因此我们无法保证这些函数的安全性和正确性。为此，我们需要将调用外部函数的代码放在unsafe语句块中，这样编译器就会知道该代码可能存在不安全操作，并需要我们自行确保其正确性和安全性。<br>对应Node.js环境的启动代码如下</p><pre><code>const fs = require(&#39;fs&#39;);const buf = fs.readFileSync(&#39;./hello.wasm&#39;);function console_log(x) &#123; console.log(x); &#125;WebAssembly.instantiate(new Uint8Array(buf), &#123;    env: &#123; &quot;console_log&quot;: console_log &#125;&#125;).then(function(result) &#123;    result.instance.exports.main();&#125;);</code></pre><h1 id="TODO-更新"><a href="#TODO-更新" class="headerlink" title="TODO 更新"></a>TODO 更新</h1>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust简单入门</title>
      <link href="/p/3b2bd29.html"/>
      <url>/p/3b2bd29.html</url>
      
        <content type="html"><![CDATA[<h1 id="Rust简单入门"><a href="#Rust简单入门" class="headerlink" title="Rust简单入门"></a>Rust简单入门</h1><p>Rust的特点<br>• 零开销抽象<br>• 没有gc<br>• 内存模型没有高度封装<br>• 语法干净正交，没有C++那么繁琐。<br>• 安全性。Rust语法引入所有权和生命期概念，在编译期就能检查出一部分内存管理错误，这是rust的一个杀手锏的特性。<br>• 现代语言特性。语言特性吸收了现代语言的大量优秀特性，支持多范式。</p><h2 id="Rust环境安装"><a href="#Rust环境安装" class="headerlink" title="Rust环境安装"></a>Rust环境安装</h2><h3 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h3><p>访问Rust语言官方网站的安装地址<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br>先下载rustup安装程序再安装,安装的所有工具在~&#x2F;.cargo&#x2F;bin目录下，我们需要将该目录添加到PATH环境变量。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOJrF.png" alt="pChOJrF.png"></p><p>打开安装程序后，我们会发现需要依赖的windowsAPI库，我们采用下载vs installer的方式获取对应库。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOUa9.png" alt="pChOUa9.png"></p><p>安装vs install以后重新打开rustup安装程序，选择默认安装。<br>安装完成后，我们需要将~&#x2F;.cargo&#x2F;bin目录添加到PATH环境变量。<br>我们可以通过以下方式查看rustup、rustc和cargo工具的版本信息：</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOwP1.png" alt="pChOwP1.png"></p><p>其中，rustup是Rust工具的管理工具，rustc是Rust程序编译器，cargo是Rust工程的管理工具</p><h3 id="Rust程序测试"><a href="#Rust程序测试" class="headerlink" title="Rust程序测试"></a>Rust程序测试</h3><p>我们从“你好，世界”这个例子开始测试。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChO08x.md.png" alt="pChO08x.md.png"></p><p>其中，fn是关键字，表示定义一个函数，定义的函数的名字是main。main()函数的参数在小括弧中列出（这里的main()函数没有参数），函数体位于大括弧内。这里main()函数体中只有一个语句，就是用println!宏输出一个字符串并换行。</p><h3 id="Cargo管理工程"><a href="#Cargo管理工程" class="headerlink" title="Cargo管理工程"></a>Cargo管理工程</h3><p>Rust 编程语言引以为傲的一个重要特性是其工程管理工具 Cargo。Cargo 是 Rust 官方提供的构建系统和包管理器，被广泛认可为行业标杆。、<br>以下是 Cargo 的一些主要特性和优势：<br>• 依赖管理：Cargo 提供了强大的依赖管理功能。通过 Cargo.toml 文件，可以定义项目的依赖项和版本约束，能够轻松地引入、更新和管理外部库。<br>• 构建系统：Cargo 提供了一个集成的构建系统，使得构建、编译和测试 Rust 项目变得简单而高效。它自动处理依赖关系、编译顺序和编译标志等，开发者只需要专注于编写代码而不必手动管理构建过程。<br>• 项目管理：Cargo 提供了一组命令行工具，用于创建、初始化和管理 Rust 项目。通过简单的命令，您可以创建新项目、生成文档、运行测试、发布软件包等，提高开发者的效率和工作流程。<br>• 社区集成：Cargo 和 Rust 社区紧密结合，通过 Cargo 可以方便地共享、发布和发现 Rust 库和工具。Cargo 提供了 Cargo Crates 网站<a href="https://crates.io/">https://crates.io</a> Rust 生态系统中集中管理和发布库的中央仓库。<br>• 多工作区支持：Cargo 允许在单个项目中管理多个工作区，每个工作区可以拥有自己的依赖关系和构建配置。这对于大型项目或拥有多个模块的项目特别有用，可以更好地组织和管理代码。<br>工程一般以目录的方式组织，因此我们先创建一个空的目录（目录的名字自由选择），其中包含一个Cargo.toml文件。</p><pre><code>[package]name = &quot;hello&quot;version = &quot;0.1.0&quot;</code></pre><p>Cargo.toml是一种TOML格式的工程文件（TOML格式和ini格式类似，但是其功能更加强大）。其中，[package]部分包含工程的基本信息：name字段表示工程的名字，version字段表示工程的版本。<br>然后，创建一个src目录，在目录中创建一个main.rs文件：</p><pre><code>fn main() &#123;    println!(&quot;你好，世界&quot;);&#125;</code></pre><p>Cargo工具默认以src&#x2F;main.rs为程序的入口文件，因此只需要输入<br>cargo run就可以编译并运行程序了</p><p><img src="https://s1.ax1x.com/2023/07/13/pChXhTJ.png" alt="pChXhTJ.png"></p><p>Cargo底层依然是调用rustc编译器工具。但是，Cargo不仅可以管理可执行程序和库，还可以对其他第三方库的依赖进行管理，同时支持自定义的构建脚本。<br>cargo-generate是一个开发人员工具，通过利用预先存在的 git 存储库作为模板，帮助开发者快速启动和运行新的 Rust 项目。</p><pre><code>cargo install cargo-generate</code></pre><h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><p>Rust还提供了本地文档用于帮助学习和了解Rust。<br>我们可以在终端运行：</p><pre><code>rustup doc</code></pre><p>打开文档。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChj9pt.png" alt="pChj9pt.png"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly跨语言调用</title>
      <link href="/p/bf55081a.html"/>
      <url>/p/bf55081a.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly跨语言调用"><a href="#WebAssembly跨语言调用" class="headerlink" title="WebAssembly跨语言调用"></a>WebAssembly跨语言调用</h1><p>WebAssembly (Wasm) 可以在多种编程语言之间进行跨语言调用。它提供了一种标准化的接口，使得不同语言的代码可以相互调用和交互。<br>选择一种编程语言（例如 Rust、C++、Go 等）编写Wasm 模块。使用相应的编译器或工具链将代码编译为 Wasm 模块文件。然后导入 Wasm 模块到目标语言：在目标语言的代码中，使用相应的 Wasm 运行时库或框架来导入和执行 Wasm 模块。不同的语言可能有不同的 Wasm 运行时库可用，例如wasmer、wasmtime 等。</p><h2 id="Go和Rust调用实例"><a href="#Go和Rust调用实例" class="headerlink" title="Go和Rust调用实例"></a>Go和Rust调用实例</h2><h3 id="被调用方Rust"><a href="#被调用方Rust" class="headerlink" title="被调用方Rust"></a>被调用方Rust</h3><p>首先我们需要将被编译的程序编译成wasm文件<br>这里我们用go程序调用rust程序<br>用cargo init  add创建一个rust文件，更改add.rs</p><pre><code>fn main()&#123;&#125;#[no_mangle]pub extern &quot;C&quot; fn sum(x: i32, y: i32) -&gt; i32 &#123;    x + y&#125;</code></pre><p>将该文件编译为wasm</p><pre><code>cargo build --target wasm32-unknown-unknown --release</code></pre><p>现在被调用者我们已经处理完了，下面我们编写调用方代码。</p><h3 id="调用方Go"><a href="#调用方Go" class="headerlink" title="调用方Go"></a>调用方Go</h3><p>这里我们参照<a href="https://github.com/wasmerio/wasmer-go%E9%87%87%E7%94%A8wasmer%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">https://github.com/wasmerio/wasmer-go采用wasmer库进行处理</a><br>需要注意的是目前该库并不支持windows，需要在linux环境下使用</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOkgf.png" alt="pChOkgf.png"></p><p>创建相应go文件调用生成的wasm文件</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;    wasmer &quot;github.com/wasmerio/wasmer-go/wasmer&quot;)func main() &#123;    // 换成生成add.wasm的路径    wasmBytes, _ := ioutil.ReadFile(&quot;add/target/wasm32-unknown-unknown/release/add.wasm&quot;)    // Create an Engine    engine := wasmer.NewEngine()    // Create a Store    store := wasmer.NewStore(engine)    // Let&#39;s compile the module.    module, err := wasmer.NewModule(store, wasmBytes)    if err != nil &#123;        fmt.Println(&quot;Failed to compile module:&quot;, err)    &#125;    // Create an empty import object.    importObject := wasmer.NewImportObject()    // Let&#39;s instantiate the WebAssembly module.    instance, err := wasmer.NewInstance(module, importObject)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to instantiate the module:&quot;, err))    &#125;    // Now let&#39;s execute the `sum` function.    sum, err := instance.Exports.GetFunction(&quot;sum&quot;)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to get the `add_one` function:&quot;, err))    &#125;    result, err := sum(1, 2)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to call the `add_one` function:&quot;, err))    &#125;    fmt.Println(&quot;Results of `sum`:&quot;, result)&#125;</code></pre><p>注意：<br>• 12行需要换成生成add.wasm的相对&#x2F;绝对路径<br>• 需要拉取对应仓库<br>• 更多具体api参照<a href="https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer">https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer</a></p><p>之后我们直接运行程序，可以看到跨语言调用成功</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOuUs.png" alt="pChOuUs.png"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++进程优雅退出</title>
      <link href="/p/53dbe2a2.html"/>
      <url>/p/53dbe2a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-进程的优雅退出"><a href="#C-进程的优雅退出" class="headerlink" title="C++进程的优雅退出"></a>C++进程的优雅退出</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="通过原子变量"><a href="#通过原子变量" class="headerlink" title="通过原子变量"></a>通过原子变量</h3><p>原子变量是线程安全的，我们可以通过atomic变量控制线程开始结束</p><pre><code>#include &lt;csignal&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;// 用于确定关闭状态的全局布尔变量std::atomic&lt;bool&gt; shutdownFlag(false);// 信号处理函数void signalHandler(int signal) &#123;    // 也可以使用 switch/case 进行控制    if (signal == SIGINT) &#123;        std::cout &lt;&lt; &quot;收到 SIGINT 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125; else if (signal == SIGTERM) &#123;        std::cout &lt;&lt; &quot;收到 SIGTERM 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125;    shutdownFlag = true;&#125;int main() &#123;    // 设置 SIGINT 和 SIGTERM 的信号处理函数    std::signal(SIGINT, signalHandler);    std::signal(SIGTERM, signalHandler);    // 服务器的主循环    while (!shutdownFlag) &#123;        // 在此处处理连接        std::this_thread::sleep_for(std::chrono::seconds(1));        std::cout &lt;&lt; &quot;服务器正在运行...&quot; &lt;&lt; std::endl;    &#125;    // 启动优雅关闭过程    std::cout &lt;&lt; &quot;正在启动优雅关闭...&quot; &lt;&lt; std::endl;        // 在这里可以进行清理操作，例如：    // 逐个关闭仍在进行中的连接，    // 保存数据，    // 正确关闭套接字等        std::cout &lt;&lt; &quot;优雅关闭完成。程序正在退出。&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>在上述例子中，我们捕获了SIGINT和SIGTERM信号，并根据这些信号进行了相应的处理。<br>SIGINT信号通常由用户在终端中按下中断键（如CTRL+C）时发送。它是一种用户主动发出的中断信号，用于通知程序终止执行。通过捕获SIGINT信号并设置相应的处理逻辑，我们可以在收到该信号时执行特定的操作，例如优雅地关闭服务器或执行其他清理任务。<br>而SIGTERM信号通常由操作系统或其他程序发送，用于请求程序正常终止。这种信号可能是远程管理工具、容器编排系统或其他管理机制发送的。与SIGINT信号类似，通过捕获SIGTERM信号并设置相应的处理逻辑，我们可以实现平滑关闭的过程，让程序有机会完成一些清理操作，确保数据的完整性和一致性。<br>通过设置信号处理函数来捕获这两个信号，并在接收到信号时设置原子变量shutdownFlag为true，以触发服务器的优雅关闭过程。这样可以在接收到这些信号时执行一些特定的操作，例如向用户发送关闭通知、保存数据、关闭连接等。</p><h3 id="休眠线程以及条件变量"><a href="#休眠线程以及条件变量" class="headerlink" title="休眠线程以及条件变量"></a>休眠线程以及条件变量</h3><p>但是如果线程大部分时间都在休眠怎么办？ 比如某一个线程仅偶尔执行一些工作，其间有长时间的睡眠。 如果终止信号到达，睡眠必须立即中断。 此外，如果向应用程序发送SIGTERM，并且应用程序没有在超时时间内终止，那么应用程序将被强行kill。<br>对于这个问题解决方式就是使用条件变量condition_variable::wait()，让线程休眠，直到经过特定时间跨度或满足条件。常用的方式就是使用条件变量，使用std::condition_variable::notify_one和std::condition_variable::notify_all 可以将线程从睡眠中唤醒，std::condition_variable的成员函数notify_one()与notify_all()是用来唤醒阻塞在wait（）的线程。假如有多个线程调用condition_variable::wait()陷入休眠之后。condition_variable的实现中有一个等待队列来保存堵塞在它之上的线程。当其他线程调用notify_one()时，只唤醒等待队列中的第一个线程；其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()才会唤醒。如果是调用notify_all()：会唤醒所有等待队列中阻塞的线程，但是存在锁争用，只有一个线程能够获得锁。队列中的其他线程，会不断尝试获得锁，当第一个唤醒的线程释放锁之后，剩余的线程就能获得锁继续执行。<br>但是notify_{one,all} 不是信号安全的，因此不能在信号处理程序中使用。所以signal handlers are out</p><blockquote><p>信号就像硬件中断一样，会打断正在执行的指令序列。信号处理函数无法判断捕获到信号的时候，进程在何处运行。如果信号处理函数中的操作与打断的函数的操作相同，而且这个操作中有静态数据结构等，当信号处理函数返回的时候（当然这里讨论的是信号处理函数可以返回），恢复原先的执行序列，可能会导致信号处理函数中的操作覆盖了之前正常操作中的数据。</p></blockquote><h3 id="采用sigwait"><a href="#采用sigwait" class="headerlink" title="采用sigwait"></a>采用sigwait</h3><p>sigwait()函数是一个POSIX函数，它允许线程挂起其执行，直到在给定的信号集中指定的某个信号成为待处理信号。该函数接受信号（从待处理信号列表中删除它），并将信号编号存储在sig变量中。<br>通过使用sigwait或sigwaitinfo，多线程应用程序可以在启动时阻塞所有信号，并有一个专用线程等待信号。这样，我们可以利用所有可用的同步原语。</p><pre><code>#include &lt;signal.h&gt;int sigwait(const sigset_t *set, int *sig);</code></pre><p>• set参数是指向信号集的指针，信号集是表示一组信号的数据结构。<br>• sig参数是一个指向整数的指针，成功完成函数后，接收到的信号编号将存储在其中。<br>以下是sigwait()的示例用法：</p><pre><code>#include &lt;condition_variable&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;signal.h&gt;int main()&#123;    // 阻塞当前线程和后续生成的线程中的信号    sigset_t sigset;    sigemptyset(&amp;sigset);    sigaddset(&amp;sigset, SIGINT);    sigaddset(&amp;sigset, SIGTERM);    pthread_sigmask(SIG_BLOCK, &amp;sigset, nullptr);    std::atomic&lt;bool&gt; shutdown_requested(false);    std::mutex cv_mutex;    std::condition_variable cv;    // 信号处理函数，在收到信号时设置shutdown_requested为true，    // 并通过条件变量cv通知其他等待的线程。    auto signal_handler = [&amp;shutdown_requested, &amp;cv, &amp;sigset]() &#123;        int signum = 0;        // 等待信号的到达：        sigwait(&amp;sigset, &amp;signum);        shutdown_requested.store(true);        // 通知所有等待的工作线程检查其断言：        cv.notify_all();        return signum;    &#125;;    // 将信号处理函数放在一个独立的线程中运行。    auto ft_signal_handler = std::async(std::launch::async, signal_handler);    auto worker = [&amp;shutdown_requested, &amp;cv_mutex, &amp;cv]() &#123;        while( shutdown_requested.load() == false )        &#123;        std::unique_lock lock(cv_mutex);        cv.wait_for(            lock,            // 最多等待一小时            std::chrono::hours(1),            // 当条件变量被唤醒并且断言为true时，停止等待：            [&amp;shutdown_requested]() &#123; return shutdown_requested.load(); &#125;);        &#125;        return shutdown_requested.load();    &#125;;    // 生成一组工作线程    std::vector&lt;std::future&lt;bool&gt;&gt; workers;    for( int i = 0; i &lt; 10; ++i )        workers.push_back(std::async(std::launch::async, worker));    std::cout &lt;&lt; &quot;等待SIGTERM或SIGINT信号（按下[CTRL]+[c]）...\n&quot;;    // 等待信号处理函数完成    int signal = ft_signal_handler.get();    std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signal &lt;&lt; &quot;\n&quot;;    // 等待工作线程    for( auto&amp; future : workers )        std::cout &lt;&lt; &quot;工作线程观察到关机请求: &quot;                &lt;&lt; std::boolalpha                &lt;&lt; future.get()                &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;正常关机\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2><p>Signal Wrangler  是一个小型的仅需要包含标头的库，更加方便管理信号。<br>Dependencies<br>• C++17<br>• Clang or GCC<br>• linux<br>• pthread<br>• cmake (recommended, but optional)<br>• Catch2 for testing</p><pre><code>#include &lt;sgnl/AtomicCondition.h&gt;#include &lt;sgnl/SignalHandler.h&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;thread&gt;void Worker(const sgnl::AtomicCondition&lt;bool&gt;&amp; exit_condition)&#123;    auto predicate = [&amp;exit_condition]() &#123;        return exit_condition.get();    &#125;;    while (true)    &#123;        exit_condition.wait_for(std::chrono::minutes(1), predicate);        if (exit_condition.get())        return;        /* ... 执行工作 ... */    &#125;&#125;int main()&#123;    sgnl::AtomicCondition&lt;bool&gt; exit_condition(false);    auto handler = [&amp;exit_condition](int signum) &#123;        std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signum &lt;&lt; &quot;\n&quot;;        if (signum == SIGTERM || signum == SIGINT)        &#123;        exit_condition.set(true);        // 唤醒所有等待的线程        exit_condition.notify_all();        // 停止等待信号        return true;        &#125;        // 继续等待信号        return false;    &#125;;    // 阻塞当前线程中的信号。    // 后续生成的线程将继承信号屏蔽。    sgnl::SignalHandler signal_handler(&#123;SIGINT, SIGTERM, SIGUSR1&#125;);    std::future&lt;int&gt; ft_sig_handler =        std::async(            std::launch::async,            &amp;sgnl::SignalHandler::sigwait_handler,            &amp;signal_handler,            std::ref(handler));    std::vector&lt;std::future&lt;void&gt;&gt; futures;    for (int i = 0; i &lt; 10; ++i)        futures.push_back(            std::async(                std::launch::async,                Worker,                std::ref(exit_condition)));    // 发送 SIGUSR1 信号    std::this_thread::sleep_for(std::chrono::milliseconds(100));    kill(0, SIGUSR1);    // 发送 SIGTERM 信号    kill(0, SIGTERM);    std::this_thread::sleep_for(std::chrono::milliseconds(100));    for (auto&amp; future : futures)        future.wait();    int last_signal = ft_sig_handler.get();    std::cout &lt;&lt; &quot;退出（收到信号 &quot; &lt;&lt; last_signal &lt;&lt; &quot;）\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h2><p>C++20实现优雅退出的一个方式是通过<a href="https://whl963854.github.io/p/324821f5.html">jthread</a>来进行实现C++20 jthread通过这种方式我们不用像传统做法定义一个变量进行控制，线程本身就可以控制子线程的运行以及停止。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void task()&#123;    while (true)    &#123;        // 执行任务        std::cout &lt;&lt; &quot;Performing task...\n&quot;;        std::this_thread::sleep_for(std::chrono::seconds(1));        // 检查是否收到停止请求        if (std::jthread::stop_requested())        &#123;            std::cout &lt;&lt; &quot;Stop requested. Exiting...\n&quot;;            break;        &#125;    &#125;&#125;int main()&#123;    std::jthread thread(task);    // 等待一段时间或等待某个条件满足    std::this_thread::sleep_for(std::chrono::seconds(5));    // 请求停止子线程    thread.request_stop();    // 继续等待一段时间，确保子线程完成当前任务    std::this_thread::sleep_for(std::chrono::seconds(2));    // std::jthread的析构函数会自动调用join()，等待子线程执行完毕    // 主线程退出，整个进程结束    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go进程的优雅退出</title>
      <link href="/p/d080713b.html"/>
      <url>/p/d080713b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go进程的优雅退出"><a href="#Go进程的优雅退出" class="headerlink" title="Go进程的优雅退出"></a>Go进程的优雅退出</h1><h2 id="退出的反面模式"><a href="#退出的反面模式" class="headerlink" title="退出的反面模式"></a>退出的反面模式</h2><p>反面模式（anti-pattern）是指在实践中明显出现但又低效或是有待优化的设计模式。在进程退出过程中如果直接退出会导致资源无法及时释放，关闭打开的连接以及完成正在进行的请求和处理等方面问题。如果是无GC的语言可能还会出现内存泄漏等问题。</p><h3 id="Block-artificially"><a href="#Block-artificially" class="headerlink" title="Block artificially"></a>Block artificially</h3><p>第一个反面模式是在主 goroutine中使用无限循环来阻塞程序的执行，但是退出的时候并不等待任何东西。收到信号就退出，以下是一个这种反模式的简单实现示例：</p><pre><code>package mainfunc KeepProcessAlive() &#123;    var ch chan int    &lt;-ch&#125;func main() &#123;    ...    KeepProcessAlive()&#125;</code></pre><p>当ch收到数据解除阻塞，主进程也随之运行结束，没有对资源进行释放。</p><h3 id="os-Exit"><a href="#os-Exit" class="headerlink" title="os.Exit()"></a>os.Exit()</h3><p>第二种反面模式就是在其他 go 协程仍在运行的时候就调用os.Exit(1)，这本质上等于 SIGKILL，没有机会关闭打开的连接以及完成正在进行的请求和处理。</p><pre><code>go func() &#123;        &lt;-ch                os.Exit(1)&#125;()go func () &#123;    for ... &#123;    &#125;&#125;()</code></pre><p>当func收到数据之后立刻调用os.Exit()终止进程，也没有任何关闭打开的连接以及完成正在进行的请求和处理的行为。<br>以上两种行为都是十分不可取的，也可以说他们的退出不是“优雅”的。</p><h2 id="在Go中优雅退出"><a href="#在Go中优雅退出" class="headerlink" title="在Go中优雅退出"></a>在Go中优雅退出</h2><p>为了正常关闭服务，需要了解两件事：</p><ul><li>如何等待所有正在运行的go例程退出</li><li>如何将终止信号传播到多个 goroutine<br>Go 提供了实现上面两点要求所需的所有工具，可以很方便的让我们优雅退出进程。</li></ul><h3 id="等待-go-routine-完成"><a href="#等待-go-routine-完成" class="headerlink" title="等待 go-routine 完成"></a>等待 go-routine 完成</h3><p>Go 提供了足够的方法来控制并发。让我们看看等待go-routine有哪些方法。</p><h4 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h4><p>最简单的解决方案，使用通道原语。</p><ol><li>我们创建一个空的结构通道make(chan struct{}, 1)（空结构不需要内存）。</li><li>每个子 goroutine完成后都应该发布到通道（defer在这里很有用）。</li><li>父 goroutine应该从通道消耗与预期 goroutine 一样多的次数。</li></ol><p>下面来看一个例子：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    wait := make(chan struct&#123;&#125;, 2)    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第一个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第二个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    // 等待两个 goroutine 完成    &lt;-wait    &lt;-wait&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    // 捕捉操作系统中断信号（如 Ctrl+C）    signals := make(chan os.Signal, 1)    signal.Notify(signals, os.Interrupt, syscall.SIGTERM)    go func() &#123;        &lt;-signals        fmt.Println(&quot;接收到中断信号&quot;)        cancel() // 取消上下文    &#125;()    run(ctx)    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.goCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loop接收到中断信号第一个 goroutine 停止循环第二个 goroutine 停止循环Main done</code></pre><p><strong>注：这在等待单个 go  routine 时非常有用。</strong></p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>通道在有多个 goroutine的情况下解决方案可能不太优雅。sync.WaitGroup是一个标准库包，这是更惯用的实现上述目标的方式。WaitGroup 是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题。</p><p>Go 标准库中的 WaitGroup 提供了三个方法</p><ul><li>func (wg *WaitGroup) Add(delta int)用来设置 WaitGroup 的计数值；</li><li>func (wg *WaitGroup) Done()用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li><li>func (wg *WaitGroup) Wait()调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><p>使用 WaitGroup 的时候，一定要等所有的 Add 方法调用之后再调用 Wait，否则就可能导致 panic 或者不期望的结果。</p><p>下面是一个示例。</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h4 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h4><p>sync&#x2F;errgroup包有一种更好的方法实现上面的功能。</p><ul><li>两个errgroup的方法.Wait和.Go相对于WaitGroup更具可读性并且更易于维护。</li><li>此外，errgroup会进行错误传播并取消上下文，以便在发生错误时终止其他 goroutine</li></ul><p>下面来看示例：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;golang.org/x/sync/errgroup&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    g, gCtx := errgroup.WithContext(ctx)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;)    err := g.Wait()    if err != nil &#123;        fmt.Println(&quot;Error group:&quot;, err)    &#125;    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h3 id="控制进程终止"><a href="#控制进程终止" class="headerlink" title="控制进程终止"></a>控制进程终止</h3><p>上面我们已经弄清楚如何正确地传达进程的状态并等待它们，但是我们很多时候并不能一直等待进程运行结束，还需要实现对程序的终止的控制,将终止信号传播到多个 goroutine。<br>我们从一个非常简单的“Hello in a loop”示例开始：</p><pre><code>func main() &#123;    for &#123;        time.Sleep(1 * time.Second)        fmt.Println(&quot;Hello in a loop&quot;)    &#125;&#125;</code></pre><h4 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h4><p>通过信号量可以监听到系统发出的关停，程序意外关闭、退出、重启等，可以记录相关信息和退出前的操作。所以我们需要监听操作系统信号自主控制信号对应的事件：</p><pre><code>exit := make(chan os.Signal, 1) signal.Notify(exit, os.Interrupt, syscall.SIGTERM)</code></pre><p>• 我们需要使用 os.Interrupt 通过 Ctrl+C（即 SIGINT）正常关闭<br>• syscall.SIGTERM是常用的终止信号，也是docker容器的默认信号（可以修改） ， kubernetes也使用该信号。</p><p>注：信号具体功能如下所示：</p><table><thead><tr><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>SIGHUP</td><td>当终端断开时，将发送该信号给终端控制进程。SIGHUP 信号还可用于守护进程。</td></tr><tr><td>SIGINT</td><td>当用户键入终端中断字符（如：Ctrl + C），终端驱动程序将发送该信号给前台进程组。默认行为是终止进程。</td></tr><tr><td>SIGQUIT</td><td>当用户键入终端退出字符（如：Ctrl + \），该信号将发送给前台进程组。默认情况下，该信号终止进程，并生成可用于调试的核心转储文件。</td></tr><tr><td>SIGILL</td><td>进程试图非法执行机器语言指令，系统将向该进程发送该信号。</td></tr><tr><td>SIGTRAP</td><td>用于实现断点调试功能以及 strace 命令所执行的系统调用跟踪功能。</td></tr><tr><td>SIGABRT</td><td>当进程调用 abort 函数时，系统向该进程发送该信号。默认情况下，该信号会终止进程，并生成核心转储文件。</td></tr><tr><td>SIGBUS</td><td>总线错误，表示发生了某种内存访问错误。当使用 mmap() 创建的内存映射时，如果试图访问的地址超出了底层内存映射文件的结尾，会产生该错误。</td></tr><tr><td>SIGFPE</td><td>在发生致命的算术运算错误时发出。包括浮点运算错误、溢出以及除数为0等其他算术错误。</td></tr><tr><td>SIGKILL</td><td>必杀信号，处理器程序无法阻塞、忽略或捕获，总能杀死进程（僵尸进程除外）。</td></tr><tr><td>SIGUSR1</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGSEGV</td><td>试图访问未分配给自己的内存，或试图往没有写权限的内存地址写入数据。</td></tr><tr><td>SIGUSR2</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGPIPE</td><td>当进程向管道、FIFO 或套接字写入信息时，如果没有相应的读进程，系统将产生该信号（管道破裂）。</td></tr><tr><td>SIGALRM</td><td>经调用 alarm() 或 setitimer() 设置的实时定时器一旦到期，内核将产生该信号。</td></tr><tr><td>SIGTERM</td><td>用来终止进程的标准信号，也是 kill 和 killall 命令所发送的默认信号。建议首先尝试使用该信号来终止进程，而将 SIGKILL 作为最后手段。</td></tr><tr><td>SIGCHLD</td><td>当父进程的某个子进程退出时，内核将向父进程发送该信号。</td></tr><tr><td>SIGCONT</td><td>该信号发送给已停止的进程，使其恢复运行。</td></tr><tr><td>SIGSTOP</td><td>进程收到该信号将停止运行，处理器程序无法将其阻塞、忽略或捕获，总能停止进程。</td></tr><tr><td>SIGTSTP</td><td>作业控制的停止信号，当用户在键盘输入挂起字符（如：Ctrl + Z）时，将发送该信号给前台进程组，使其停止运行。</td></tr><tr><td>SIGTTIN</td><td>在作业控制 shell 下运行时，若后台进程组试图对终端进行 read() 操作，终端驱动程序则将发送该信号。该信号默认将停止进程。</td></tr><tr><td>SIGTTOU</td><td>类似于 SIGTTIN，但在写终端（或修改终端模式）时收到。</td></tr><tr><td>SIGURG</td><td>系统发送该信号给一个进程，表示套接字上存在带外（紧急）数据。</td></tr><tr><td>SIGXCPU</td><td>当进程的 CPU 时间超出对应的资源限制时，将发送此信号给进程。</td></tr><tr><td>SIGXFSZ</td><td>如果进程试图增大文件而突破对进程文件大小的资源限制时，将发送该信号给进程。</td></tr><tr><td>SIGVTALRM</td><td>虚拟时钟信号，类似于 SIGALRM，但计算的是该进程占用的 CPU 时间。</td></tr><tr><td>SIGPROF</td><td>类似于 SIGALRM 和 SIGVTALRM，但包括该进程用的 CPU 时间以及系统调用的时间。</td></tr><tr><td>SIGWINCH</td><td>窗口大小改变时发出该信号。</td></tr><tr><td>SIGIO</td><td>文件描述符准备就绪，可以开始进行输入&#x2F;输出操作。</td></tr><tr><td>SIGPWR</td><td>电源故障信号。</td></tr><tr><td>SIGSYS</td><td>如果进程发起的系统调用有误，将产生该信号。</td></tr></tbody></table><p>监听 SIGINT 和 SIGKILL 信号</p><blockquote><p>ctrl+c 产生了一个 SIGINT（中断信号）。<br>kill 9 发送一个 SIGKILL 信号 终止进程的信号来结束进程。</p></blockquote><h4 id="中断循环"><a href="#中断循环" class="headerlink" title="中断循环"></a>中断循环</h4><p>现在我们有了捕获信号的方法，现在我们需要找到一种中断循环的方法。</p><h5 id="非阻塞通道选择"><a href="#非阻塞通道选择" class="headerlink" title="非阻塞通道选择"></a>非阻塞通道选择</h5><p>select 语句允许在多个通道操作中选择可用的操作进行处理。当 select 语句执行时，它会等待其中一个 case 条件满足，并执行相应的操作。<br>下面是一个简单的 hello for 循环：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    c := make(chan os.Signal, 1) // 我们需要保留缓冲区大小为1，以确保通道不会被阻塞    signal.Notify(c, os.Interrupt, syscall.SIGTERM)    for &#123;        select &#123;        case &lt;-c:            fmt.Println(&quot;打破循环&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;循环中的Hello&quot;)        &#125;    &#125;&#125;</code></pre><p>通过这种方式，程序可以同时监听操作系统信号和定时器事件，根据不同的事件类型执行相应的操作。</p><pre><code>$ go run main.go循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello打破循环</code></pre><p>当接收到信号时，程序会退出循环并终止运行；而在每次定时器超时后，程序会打印出 “循环中的Hello”。这样，程序可以在接收到信号或每秒定时打印信息的情况下进行灵活的处理。</p><h5 id="使用Context来实现"><a href="#使用Context来实现" class="headerlink" title="使用Context来实现"></a>使用Context来实现</h5><p>Context（上下文）是Go语言中一个非常有用的接口，应该在所有阻塞函数中使用和传播。它可以实现取消操作在整个程序中的传播。<br>在直接或间接用于外部依赖项的每个方法或函数中，context.Context作为第一个参数是一个良好的做法。https :&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;context</p><h6 id="Channel共享问题"><a href="#Channel共享问题" class="headerlink" title="Channel共享问题"></a>Channel共享问题</h6><p>让我们看看上下文属性如何在更复杂的情况下提供帮助。<br>使用通道并行运行多个循环（反例）：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    exit := make(chan os.Signal, 1)    signal.Notify(exit, os.Interrupt, syscall.SIGTERM)    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: hello&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: ciao&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>该代码中使用了两个 goroutine，每个 goroutine 都使用 select 语句监听操作系统信号和定时器事件。exit 通道被多个 goroutine 共享，并且每个 goroutine 都在监听 exit 通道。当其中一个 goroutine 接收到终止信号时，其他 goroutine 也会接收到信号，但只有一个 goroutine 会打印相应的消息并退出。其他 goroutine 则会继续运行并打印定时器事件的消息。<br>这会导致一个问题：wg.Wait() 语句将一直等待直到所有 goroutine 完成，但只有一个 goroutine 会接收到终止信号并退出，而另一个 goroutine 则会一直运行下去。<br>对于广播通知的需求，可以使用context包来完成。context包提供了一种在多个goroutine之间传递取消信号的机制。</p><h6 id="使用-Context-终止"><a href="#使用-Context-终止" class="headerlink" title="使用 Context 终止"></a>使用 Context 终止</h6><p>让我们尝试通过引入context.WithCancel来解决这个问题</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        exit := make(chan os.Signal, 1)        signal.Notify(exit, os.Interrupt, syscall.SIGTERM)        cancel()    &#125;()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>当调用返回的取消函数或关闭父上下文的 Done 通道时，返回的上下文的 Done 通道将关闭。所有通过该上下文创建的 goroutine 中的 select 语句中的 &lt;-ctx.Done() 分支会被触发，也就是收到一个已关闭的通道。</p><pre><code>PS D:\workplace\gopath\src\wps\context_stop&gt;  go run .\main.goBreak the loopBreak the loopMain done</code></pre><p>这种行为实现了上下文的广播特性，在所有使用相同上下文的 goroutine 中，无论是直接调用取消函数还是关闭 Done 通道，都会导致所有的 &lt;-ctx.Done() 分支被执行。<br>这种广播机制使得可以在多个 goroutine 之间同时传递取消信号，而不仅仅限于单个 goroutine。通过这种方式，可以实现一次性取消多个相关 goroutine 的执行。</p><h6 id="NotifyContext"><a href="#NotifyContext" class="headerlink" title="NotifyContext"></a>NotifyContext</h6><p>在 go 1.16 中，信号包中引入了一个新的有用方法，singal.NotifyContext：</p><pre><code>func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)</code></pre><p>创建一个新的上下文并监听指定的操作系统信号。当收到这些信号之一时，上下文将被取消，触发相关的操作。<br>使用 NotifyContext 可以将上面的示例简化为：</p><pre><code>func main() &#123;    ctx, stop := context.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)    defer stop()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>将信号通过ctx进行监听，利用ctx就可以控制协程结束。</p><pre><code>PS D:\workplace\gopath\src\wps\notify_context&gt; go run .\main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h2 id="优雅的方法"><a href="#优雅的方法" class="headerlink" title="优雅的方法"></a>优雅的方法</h2><p>到目前为止，我们已经看到了几种优雅地终止一段长时间运行的代码的技术。</p><h3 id="使用-ctx-进行阻止"><a href="#使用-ctx-进行阻止" class="headerlink" title="使用 ctx 进行阻止"></a>使用 ctx 进行阻止</h3><p>这是最常见的方法，也更容易理解和实施。<br>• 调用一个方法<br>• 传递一个上下文<br>• 如果发生错误或上下文被取消&#x2F;超时，它将返回。</p><pre><code>// 调用:err := srv.Run(ctx, ...)// 实现func (srv *Service) Run(ctx context.Context, ...) error &#123;    // ...    // ...    for &#123;        // ...        select &#123;        case &lt;-ctx.Done():            // 根据业务逻辑需求，决定是否返回上下文错误            return ctx.Err()        &#125;    &#125;    // 如果不需要返回其他错误，可以直接返回 nil    return nil&#125;</code></pre><h3 id="Setup-x2F-Shutdown"><a href="#Setup-x2F-Shutdown" class="headerlink" title="Setup&#x2F;Shutdown"></a>Setup&#x2F;Shutdown</h3><p>在某些情况下，使用阻塞方式的ctx代码不是最合适的方法，特别是希望控制何时执行.Shutdown()方法时。不过，需要注意确保调用.Shutdown()以优雅地关闭服务器，避免资源泄漏的情况发生。</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>服务依赖数据库才能正常工作，我们需要确保服务不再运行后才执行db的关闭操作。通过在defer中调用db.Shutdown()，我们确保它在g.Wait返回后运行。</p><pre><code>// calling:func () &#123;    err := db.Setup() // will not block    defer db.Shutdown()    svc := Service&#123;        DB: db    &#125;    g.Run(...        svc.Run(ctx, ...)    )    g.Wait()&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优雅退出是指在进程终止前给予进程清理剩余请求的时间，等待子协程&#x2F;线程完成当前任务后再发起进程退出，以确保不会丢失任何数据。相比于暴力退出，优雅退出可以对未完成的任务和数据进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程通信</title>
      <link href="/p/53ad465c.html"/>
      <url>/p/53ad465c.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>如果我们希望在本进程fork出一个子进程，可以使用os.StartProcess方法，它会fork出一个子进程后返回这个子进程的pid。</p><pre><code>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) &#123;    testlog.Open(name)    return startProcess(name, argv, attr)&#125;</code></pre><p>但是我们一般不这么做，因为 os.StartProcess 是一个比较底层的接口，一般是提供给go内部其他的方法去使用的。我们可以使用os.Command方法创建一个命令，并调用cmd.Start()方法运行命令，Start()方法内部其实就是调用的os.StartProcess()方法去fork一个子进程。</p><p>我们先来看Command方法，该方法返回一个*Cmd类型</p><pre><code>func Command(name string, arg ...string) *Cmd</code></pre><p>Cmd定义如下</p><pre><code>type Cmd struct &#123;        // Path is the path of the command to run.        //        // This is the only field that must be set to a non-zero        // value. If Path is relative, it is evaluated relative        // to Dir.        Path string        // Args holds command line arguments, including the command as Args[0].        // If the Args field is empty or nil, Run uses &#123;Path&#125;.        //        // In typical use, both Path and Args are set by calling Command.        Args []string        // Env specifies the environment of the process.        // Each entry is of the form &quot;key=value&quot;.        // If Env is nil, the new process uses the current process&#39;s        // environment.        // If Env contains duplicate environment keys, only the last        // value in the slice for each duplicate key is used.        Env []string        // Dir specifies the working directory of the command.        // If Dir is the empty string, Run runs the command in the        // calling process&#39;s current directory.        Dir string        // Stdin specifies the process&#39;s standard input.        // If Stdin is nil, the process reads from the null device (os.DevNull).        // If Stdin is an *os.File, the process&#39;s standard input is connected        // directly to that file.        // Otherwise, during the execution of the command a separate        // goroutine reads from Stdin and delivers that data to the command        // over a pipe. In this case, Wait does not complete until the goroutine        // stops copying, either because it has reached the end of Stdin        // (EOF or a read error) or because writing to the pipe returned an error.        Stdin io.Reader        // Stdout and Stderr specify the process&#39;s standard output and error.        //        // If either is nil, Run connects the corresponding file descriptor        // to the null device (os.DevNull).        //        // If Stdout and Stderr are the same writer, and have a type that can be compared with ==,        // at most one goroutine at a time will call Write.        Stdout io.Writer        Stderr io.Writer        // ExtraFiles specifies additional open files to be inherited by the        // new process. It does not include standard input, standard output, or        // standard error. If non-nil, entry i becomes file descriptor 3+i.        ExtraFiles []*os.File        // SysProcAttr holds optional, operating system-specific attributes.        // Run passes it to os.StartProcess as the os.ProcAttr&#39;s Sys field.        SysProcAttr *syscall.SysProcAttr        // Process is the underlying process, once started.        Process *os.Process        // ProcessState contains information about an exited process,        // available after a call to Wait or Run.        ProcessState *os.ProcessState        // contains filtered or unexported fields&#125;</code></pre><p>然后利用cmd调用Start函数，</p><pre><code>func (c *Cmd) Start() error</code></pre><p>Start开始执行以后并不阻塞。如果Start函数返回成功，则c.Process字段将被设置相关内容。在成功调用开始之后，必须调用Wait方法释放关联的系统资源。</p><p>这样，通过上述标准库提供的函数，我们就可以<strong>创建子进程</strong>了，下面我们来看一下如何进行<strong>进程间通信</strong>。</p><h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>操作系统信号（signal，以下简称信号）是IPC中唯一一种异步的通信方法，它的本质是用软件来模拟硬件的中断机制。信号用来通知某个进程有某个事件发生了。<br>每一个信号都有一个以“SIG”为前缀的名字，例如SIGINT、SIGQUIT以及SIGKILL等。在操作系统内部，这些信号都由正整数表示，这些正整数称为信号编号。在Linux的命令行终端下，我们可以使用kill  -l命令来查看当前系统所支持的信号</p><p>接口类型os.Signal 的声明如下：</p><pre><code>type Signal interface &#123;    String() string    Signal() // 与其他 Stringers 区分开来&#125;</code></pre><p>实现了os.Signal接口的类型就是1种信号量，或者说只要实现了Signal和String方法的类型就是1种信号量。比如像syscall.Signal类型，它的底层类型是int，但是它实现了os.Signal接口类型，因此syscall.Signal就是信号量类型（其下有多种信号量，每一个整型数字代表1中信号）。<br>os.Signal的Signal()的实现是一个空方法，syscall.Signal的Singal()是一个空方法，其他实现os.Signal的类型其Signal()也是空方法。Signal()方法的作用仅仅是为了标识这个实现了该方法的类型是一个信号量类型而已。<br>我们可以通过os.Signal的Signal()代码包os&#x2F;signal中的Notify 函数对信号进行接收</p><pre><code>func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</code></pre><p>这个函数需要传入一个channel，signal.Notify方法内部做的事就是接收到来自操作系统进程的信号并将这个信号发送给这个channel。 只有第二参sig中规定的信号量才会发送到chan中，其他信号量不会（而是执行系统默认操作）。然后在用户程序中异步的从这个channel接收信号就可以捕获来自操作系统发送的信号。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>下面是一个Notify调用示例：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>运行结果如下，可以看到我们已经对信号捕获成功：</p><pre><code>$ go run main.goStart running^CReceive signal from the operating system: interrupt^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^Z[2]+  Stopped                 go run main.go</code></pre><p>上面我们已经能够对信号进行捕获，现在想从主进程将信号传递到子进程。Cmd保存了子进程的信息，我们查看Cmd结构，可以找到Process(*os.Process)字段有一个Signal函数。</p><pre><code>type Process struct &#123;        Pid int        // contains filtered or unexported fields&#125;func (p *Process) Signal(sig Signal) error</code></pre><p>该函数的作用就是像进程发送信号，如果发送失败则会返回错误，我们可以通过Cmd对象获取对应的Process，然后调用该进程的signal函数像该子进程发送所需要的信号。<br>现在我们已经能够从父进程向子进程发送信号，下面我们创建一个子进程写一个示例，创建main.go文件：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;time&quot;)func main() &#123;    // 创建一个用于执行外部命令的 *exec.Cmd 对象    cmd := exec.Command(&quot;./child&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr        // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;启动子进程出错: &quot;+err.Error())        return    &#125;    // 等待一段时间，然后发送信号    time.Sleep(time.Millisecond * 500)    err = cmd.Process.Signal(os.Interrupt)    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;发送信号出错: &quot;+err.Error())        return    &#125;    // 等待子进程结束    err = cmd.Wait()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;等待子进程结束出错: &quot;+err.Error())    &#125;    return&#125;</code></pre><p>该函数通过 exec 包启动了一个子进程，并在一段时间后向子进程发送中断信号。子进程存储在child.go当中，我们直接运行child.go的编译的可执行文件。下面是子进程一个简单实现：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;)func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    fmt.Println(&quot;started&quot;)    &lt;-stop    fmt.Println(&quot;stopped&quot;)&#125;</code></pre><p>运行结果如下所示：</p><pre><code>$ go run main.gostartedstopped</code></pre><p>可以看到我们已经成功将信号传入了子函数当中。<br>结合Go进程的优雅退出(待附链接，金山文档容易链接失效，等待更新到博客再更新)<br>我们可以创建graceful_shutdown.go：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;time&quot;)func grace() &#123;    fmt.Println(&quot;处理剩余资源&quot;)    time.Sleep(2 * time.Second)&#125;func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    for &#123;        select &#123;        case &lt;-stop:            fmt.Println(&quot;收到父进程信号&quot;)            grace()            fmt.Println(&quot;子进程退出&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;子进程运行&quot;)        &#125;    &#125;&#125;</code></pre><p>模拟主进程收到信号传递给子进程的过程，我们将main.go文件也进行改写</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;os/signal&quot;    &quot;time&quot;)func main() &#123;    cmd := exec.Command(&quot;./grace_shutdown&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr    // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;Start: &quot;+err.Error())        return    &#125;    // 创建一个接收信号的通道    sigChannel := make(chan os.Signal, 1)    // 监听中断信号    signal.Notify(sigChannel, os.Interrupt)    for &#123;        select &#123;        case &lt;-sigChannel:            fmt.Println(&quot;父进程收到系统信号&quot;)            // 发送信号给子进程            err = cmd.Process.Signal(os.Interrupt)            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Signal: &quot;+err.Error())                return            &#125;            // 等待子进程结束            err = cmd.Wait()            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Wait: &quot;+err.Error())            &#125;            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;wait...&quot;)        &#125;    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.gowait...子进程运行wait...子进程运行wait...子进程运行^C父进程收到系统信号收到父进程信号处理剩余资源子进程退出</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非零段划分</title>
      <link href="/p/40034.html"/>
      <url>/p/40034.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,…,Aj 是一个非零段     当且仅当以下条件同时满足：    ·1≤i≤j≤n；    ·对于任意的整数 k，若 i≤k≤j，则 Ak＞0；    ·i=1 或 Ai-1=0；    ·j=n 或 Aj+1=0。    下面展示了几个简单的例子：    ·A = [3,1,2,0,0,2,0,4,5,0,2]中的4个非零段依次为[3, 1, 2],[2],[4, 5]和[2]；    ·A = [2, 3, 1, 4, 5] 仅有 1 个非零段；    ·A = [0, 0, 0] 则不含非零段（即非零段个数为 0）。    现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。    试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，    可取 p = 1，即不对 A 做任何修改。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入格式    从标准输入读入数据。    输入的第一行包含一个正整数 n。    输入的第二行包含 n 个用空格分隔的自然数 A1, A2, … , An。    输出格式    输出到标准输出。    仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组cnt[]，cnt[i] 表示海平面下降到i时，岛屿数量的变化。差分法是最简洁的解题程序。数组元素d[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中为后缀和）中找出最大值就是所要的结果。程序代码中，STL算法函数unique()用来去除相邻重复的元素。语句“a[0] = a[n + 1] = 0;”用来设置边界值，起辅助计算作用，可以简化程序代码。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* CCF202109-2 非零段划分 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000;const int M = 10000;int a[N + 2], d[M + 1];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    a[0] = a[n + 1] = 0;    n = unique(a, a + n + 2) - a - 1;    memset(d, 0, sizeof d);    for (int i = 1; i &lt; n; i++)        if (a[i - 1] &lt; a[i] &amp;&amp; a[i] &gt; a[i + 1]) d[a[i]]++;        else if (a[i - 1] &gt; a[i] &amp;&amp; a[i] &lt;a[i + 1]) d[a[i]]--;    int ans = 0, sum = 0;   // 差分前缀和即为答案    for (int i = M; i &gt;= 1; i--)        sum += d[i], ans = max(ans, sum);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;&#125;</code></pre><p>来源：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">https://blog.csdn.net/tigerisland45/article/details/120598581</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻宝大作战</title>
      <link href="/p/59129.html"/>
      <url>/p/59129.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p><p>某天，小 P 获得了一张神秘的藏宝图。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br>简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br>地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br>其中 A[i][j]&#x3D;1 表示坐标 (i,j) 处种有一棵树，A[i][j]&#x3D;0 则表示坐标 (i,j) 处没有树。<br>换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p><p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br>并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br>具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br>理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br>对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]&#x3D;B[i][j]。<br>当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p><p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br>请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p><p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]&#x3D;B[0][0]&#x3D;1，表示了宝藏埋藏的位置。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p><p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p><p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p><p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br>需要注意，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p><p><strong>样例 1 输入</strong></p><pre><code>5 100 20 01 12 23 34 40 0 10 1 01 0 0</code></pre><p><strong>样例 1 输出</strong></p><pre><code>3</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>对stl掌握的不好，只能用数组碰运气来做。浪费很多时间，最后只拿了200分，第三题本来可以骗几个用例分数的，，，，，我采用的是记录稀疏矩阵，然后根据横坐标纵坐标排序，最后采用O(n)枚举的暴力做法。代码又臭又长，如下所示（不看也罢）：</p><p> <strong>代码实现</strong></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */struct Zb&#123;    int x;    int y;&#125;zb[1050],cbt[60];int ss[60][60];int cmp(struct Zb a,struct Zb b)&#123;    if(a.x==b.x)&#123;        return a.y&lt;b.y;    &#125;    else return a.x&lt;b.x;    &#125;int main(int argc, char** argv) &#123;    int n,L,s ;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;L,&amp;s);    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;zb[i].x,&amp;zb[i].y);    &#125;        sort(zb,zb+n,cmp);        int t,count=0;        for(int i=s;i&gt;=0;i--)&#123;            for(int j=0;j&lt;=s;j++)&#123;                scanf(&quot;%d&quot;,&amp;ss[i][j]);                if(ss[i][j]==1)&#123;                    cbt[count].y=j;                    cbt[count].x=i;                    count++;                &#125;            &#125;        &#125;        sort(cbt,cbt+count,cmp);        int vcount =0;        for(int i=0;i&lt;n;i++)&#123;            int flag=0;            int k=i+1;            int countzb=0;            if(zb[i].x&gt;L-s||zb[i].y&gt;L-s)flag=1;            while(zb[k].x-zb[i].x&lt;=s&amp;&amp;k&lt;n)&#123;                if(abs(zb[k].x-zb[i].x)&lt;=s&amp;&amp;zb[k].y-zb[i].y&lt;=s&amp;&amp;zb[k].y-zb[i].y&gt;=0)&#123;                    if(ss[abs(zb[k].x-zb[i].x)][abs(zb[k].y-zb[i].y)]!=1)&#123;                        flag=1;                        break;                    &#125;                     countzb++;                &#125;                k++;            &#125;            if(countzb+1!=count)flag=1;            if(flag==0)&#123;                    vcount++;            &#125;        &#125;        printf(&quot;%d&quot;,vcount);     return 0;&#125;</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p>对于较大数据10^9，如果用二维数组vector的话无法开辟那么大空间，换成二维map来存储可以解决较大数据问题。解决好两个图的存储问题之后，接下来就是找到符合要求的可能埋有宝藏地点个数，无非就是两个条件：一是满足藏宝图可以在绿化图某块区域完美对上，二是满足藏宝图在绿化图中不出界。可以利用这两个条件去判断每一个符合条件的绿树点。如果两个条件都满足即有可能此处为藏宝点。<br><strong>代码实现</strong></p><pre><code>#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;cmath&gt;using namespace std;//pair&lt;int ,int&gt;和int对应map&lt;int,map&lt;int,int&gt; &gt;mp;struct node&#123;    int x,y;&#125;point[1001];int g[51][51];//地图int main()&#123;    int n,L,S;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;point[i].x&gt;&gt;point[i].y;        mp[point[i].x][point[i].y]=1;    &#125;    //输入也是一个坑    for(int i=S;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=S;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        int flag=1;        int x=point[i].x,y=point[i].y;        for(int j=0;j&lt;=S;j++)&#123;            for(int k=0;k&lt;=S;k++)&#123;                if(x+S&gt;L||y+S&gt;L||mp[x+j][y+k]!=g[j][k])&#123;                    flag=0;                    break;                &#125;            &#125;            if(!flag) break;        &#125;        if(flag) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;</code></pre><p><a href="https://blog.csdn.net/victory066/article/details/125819918">作者原文</a><br><a href="https://blog.csdn.net/victory066/article/details/125819918">https://blog.csdn.net/victory066/article/details/125819918</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防疫大数据</title>
      <link href="/p/43256.html"/>
      <url>/p/43256.html</url>
      
        <content type="html"><![CDATA[<h1 id="防疫大数据"><a href="#防疫大数据" class="headerlink" title="防疫大数据"></a>防疫大数据</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。具体而言，在每天夜里，西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地区的信息，以及当天疫情风险地区的信息。数据中心需要根据这些信息，生成一份存在风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://imgse.com/i/x6kjot"><img src="https://s1.ax1x.com/2022/10/20/x6kjot.png" alt="x6kjot.png"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出到标准输出。<br>输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格分隔的若干整数。其中第一个整数表示当天的日期，接下来的各个整数为按从小到大排序的存在风险的用户列表。</p><p><strong>样例 1 输入</strong></p><pre><code>91 4 10 1 1-1 1 1-1 2 10 2 20 30 3 11 2 21 3 20 00 00 00 00 00 15 4 11 0 1</code></pre><p><strong>样例 1 输出</strong></p><pre><code>0 11 1 32 1 33 1 34 1 35 1 36 1 378</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>无脑做，不知道哪里有问题，只有20分，哭死（）</p><p> <strong>代码实现</strong></p><pre><code>？？？忘保存了！！！</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p><strong>代码实现</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;set&lt;LL&gt; sd[1050], su;struct node&#123;    LL d, u, r;&#125;a;vector&lt;node&gt; v[1050];LL n, ri, mi, d, u, r, pi;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) // i:生成名单这一天    &#123;        cin &gt;&gt; ri &gt;&gt; mi;                for (int j = 0; j &lt; ri; j ++ ) // ri个风险地区        &#123;            cin &gt;&gt; pi;            for (int k = i; k &lt; i + 7; k ++ ) sd[k].insert(pi); // pi地区i ~ i+6天都是风险地区        &#125;                for (int j = 0; j &lt; mi; j ++ ) //         &#123;            cin &gt;&gt; d &gt;&gt; u &gt;&gt; r;            if (d &lt; 0) continue;            if (!sd[d].count(r)) continue; // 到访的地区在到访的那一日不处于风险状态,肯定无风险            v[i].push_back(&#123;d, u, r&#125;); // 存储第i天的漫游数据        &#125;                // 对漫游信息进行判断,从第i-6天开始.因为7天前的用户漫游数据有可能到现在还是风险的        for (int j = max(0, i - 6); j &lt;= i; j ++ )        &#123;            for (int k = 0; k &lt; v[j].size(); k ++ )            &#123;                d = v[j][k].d;                u = v[j][k].u;                r = v[j][k].r;                                // 1.该用户的d要在7日内                // 2.该用户在近7日内到访的地区在到访的那一日处于风险状态                // 3.上述存在风险的地区自到访日(d)至生成名单当日(i)持续处于风险状态                bool flag = 1;                if (d &lt;= i - 7) continue; // 要求1                for (int l = d; l &lt;= i; l ++ ) // 要一直持续到当前i这一天 要求2&amp;3                    flag = flag &amp; sd[l].count(r);                if (flag) su.insert(u);            &#125;        &#125;                cout &lt;&lt; i &lt;&lt; &quot; &quot;;        for (auto it : su) cout &lt;&lt; it &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        su.clear();    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中数字出现的个数</title>
      <link href="/p/34639.html"/>
      <url>/p/34639.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组中数字出现的个数"><a href="#数组中数字出现的个数" class="headerlink" title="数组中数字出现的个数"></a>数组中数字出现的个数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>输入：</p><pre><code>1 2 3 4 4 2</code></pre><p>输出：</p><pre><code>1 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code>这里只想到了如何快速获得一个只出现一次的数字，没有想到分组异或相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ret = 0;        for (int n : nums)            ret ^= n;        int div = 1;        while ((div &amp; ret) == 0)            div &lt;&lt;= 1;        int a = 0, b = 0;        for (int n : nums)            if (div &amp; n)                a ^= n;            else                b ^= n;        return vector&lt;int&gt;&#123;a, b&#125;;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组游戏</title>
      <link href="/p/64084.html"/>
      <url>/p/64084.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。小猫咪表示“我太难了”你能帮帮它么?</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>输入说明：</p><pre><code>会有多组询问首先输入一个数字t (1&lt;=t&lt;=10)接下来有t组数据每组数据里，首先会有一个数n，表示接下来这个数列的长度为n然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><p>输出描述:</p><pre><code>对于每一个提问，请依次输出最多可以选取多少个数</code></pre><p>备注:</p><pre><code>每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题目相对比较简单，注意从左到右依次取，并且取的过程中sum一直非负，而不是最后sum非负，<br>思路:</p><pre><code>从左到右依次遍历，遇到正数或者零直接选，遇到负数则分两种情况，情况1:选了之后sum &gt;= 0，那么直接选。情况2︰选了之后sum &lt; ，那么从已经选择的负数中置换出一个最小的。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main() &#123;    int t;cin &gt; t;    while(t--)&#123;        int n;        while (cin &gt;&gt;n) &#123;            vector&lt;int&gt; nums(n);            for(auto &amp;e : nums) cin &gt;&gt; e;            LL sum = e, cnt = e;            priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;            for(auto &amp;e : nums)&#123;                if(e &gt;= e) &#123;//遥到正数直接选                    sum += e;                    cnt+t;                &#125;                else &#123;                    if(sum + e &gt;= e)&#123;//情况                        sum += e;                        pq.push(e);cnt++;                    &#125;                    else &#123; //情况                        pq. push(e);                        sum += e;                        sum -= pq.top();                        pq. pop();                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; cnt &lt;&lt; endl;    &#125;    return e;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/p/14283.html"/>
      <url>/p/14283.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    示例 1:        输入: s = &quot;abcabcbb&quot;        输出: 3         解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。    示例 2:        输入: s = &quot;bbbbb&quot;        输出: 1        解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。    示例 3:        输入: s = &quot;pwwkew&quot;        输出: 3        解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。             请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    采用双指针的做法，通过一个桶记录字符是否出现过以及出现的位置，在O(n)的时间内解决问题</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期差值</title>
      <link href="/p/1868.html"/>
      <url>/p/1868.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>求出两个日期之间的相差的天数，相邻日期算两天</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>示例 1:    输入: 20200111         20200112    输出: 2 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一道比较简单的题，只要月份天数闰年平年，注重细节就好了，记录这道题仅仅是熟悉一个思路比较清晰的方法。</p><p>不妨假设第一个日期早于第二个日期（否则交换即可)。<br>这种求日期之间相差天数的题目有一个很直接的思路，即令日期不断加1天，直到第一个日期等于第二个日期为止，即可统计出答案。具体处理时，如果当加了一天之后天数d等于当前月份m所拥有的天数加1，那么就令月份m加1、同时置天数d为1号（即把日期变为下一个月的1号);如果此时月份m变为了13，那么就令年份y加1、同时置月份m为1月（即把日期变为下一年的1月)。<br>为了方便直接取出每个月的天数，不妨给定一个二维数组int month[13][2]，用来存放每个月的天数，其中第二维为0时表示平年，为1时表示闰年。<br>注意:如果想要加快速度，只需要先把第一个日期的年份不断加1，直到与第二个日期的年份相差1为止，期间根据平年或是闰年来累加365天或者366天即可。之后再进行不断令天数加1的操作。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #include &lt;cstdio&gt;    int month[13][2] =&#123; //平年和闰年的每个月的天数    &#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,    &#123;31, 31&#125;,&#123;31,31&#125;, &#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;    &#125;    bool isLeap(int year) &#123;//判断是否是闰年        return (year % 4== 0 &amp;&amp; year % 100 = 0) &amp;&amp;(year % 400== 0);    &#125;    int main() &#123;        int timel, yl,ml,dl;        int time2, y2,m2,d2;        while(scanf( &quot;%d%d&quot;,&amp;timel,&amp;time2) !=EOF)&#123;            if(time1 &gt;time2)&#123; 1/第一个日期晚于第二个日期,则交换                int temp=timel;                timel = time2;                time2 = temp;            &#125;            y1 = time1 / 10000, ml = time1 % 10000 / 100,d1 = timel % 100;            y2 = time2 / 10000, m2 = time2 % 10000 / 100,d2 = time2 % 100;            int ans =1;//记录结果            //第一个日期没有达到第二个日期时进行循环            //即!((y1 == y2) &amp;&amp; (ml == m2) &amp;&amp;(d1 == d2))            while(yl&lt; y2 || ml&lt; m2 || d1&lt;d2)&#123;                d1++;//天数加1                if(d1 == month [m1] [isLeap(y1)] +1)&#123;//满当月天数                    m1++;//日期变为下个月的1号                    dl =1;                &#125;                if(m1 ==13) &#123; //月份满12个月                    y1++;//日期变为下一年的1月m1=1;                &#125;                ans++;//累计            &#125;        &#125;    return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长字符串链</title>
      <link href="/p/53127.html"/>
      <url>/p/53127.html</url>
      
        <content type="html"><![CDATA[<h1 id="最长字符串链"><a href="#最长字符串链" class="headerlink" title="最长字符串链"></a>最长字符串链</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给出一个单词数组 words ，其中每个单词都由小写英文字母组成。</p><p>如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。</p><p>例如，”abc” 是 “abac” 的 前身 ，而 “cba” 不是 “bcad” 的 前身<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k &#x3D;&#x3D; 1 的 单词链 。</p><p>从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。 </p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>示例 1：</p><pre><code>输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]输出：4解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]</code></pre><p>示例 2:</p><pre><code>输入：words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]输出：5解释：所有的单词都可以放入单词链 [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;].</code></pre><p>示例 3:</p><pre><code>输入：words = [&quot;abcd&quot;,&quot;dbqca&quot;]输出：1解释：字链[&quot;abcd&quot;]是最长的字链之一。[&quot;abcd&quot;，&quot;dbqca&quot;]不是一个有效的单词链，因为字母的顺序被改变了。</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><pre><code>1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 16words[i] 仅由小写英文字母组成。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们将问题分解成几个子问题，我们先来看单词链的判断，单词链相邻单词必然满足长度相差一且长度较长的单词&#x3D;长度短的单词+任意位置插入一个字母，也就是说如果没有插入字母两个字符串是完全相同的，插入一个字母以后，除了那一个位置以外的所有字母都是一一对应的。那么我们可以根据这个对短单词进行遍历，一一与长单词进行对应，如果不相同则跳过这个字母，比对后面的字母，如果跳过次数不等于1，则两个单词不能组成单词链。<br>接下来我们分析题目，需要求最长单词链，我们仔细观察可以发现最长单词链是满足最优子结构性的，例如长度为最大为m的单词组成的最长链必须由单词+最长的单词长度最大为m-1的单词链组成。<br>定义</p><pre><code>dp[i]表示以单词i为结尾的最长的单词链长度</code></pre><p>初始化</p><pre><code>至少一个单词，初始化为1</code></pre><p>计算</p><pre><code>预处理先按照字符串长度升序排列从短到长来计算, 对于当前单词去找序号比它小的 j 情况： 如果相等，则 max(d[i], d[j]+1)</code></pre><p>代码 </p><pre><code>class Solution &#123;    // a是否是b的前身    bool isFor(string&amp; a, string&amp; b) &#123;        int asize=a.size();        int bsize=b.size();        if(bsize - asize== 1) &#123;            int i = 0, j = 0;            while(i &lt; asize &amp;&amp; j &lt; bsize) &#123;                if(a[i] == b[j]) i++;                j++;            &#125;            if(i == asize) return true;        &#125;        return false;    &#125;public:    int longestStrChain(vector&lt;string&gt;&amp; words) &#123;        if(words.size() &lt; 2)            return words.size();                vector&lt;int&gt; dp(words.size(), 1);        int res = 1;                // 按字符串长度递增排序        sort(words.begin(), words.end(),             [](string a, string b) &#123;return a.size() &lt; b.size();&#125;);                for(int i = 0; i &lt; words.size(); i++) &#123;            for(int j = i - 1; j &gt;= 0; j--) &#123;                if(isFor(words[j], words[i])) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-string-chain">https://leetcode.cn/problems/longest-string-chain</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/p/52608.html"/>
      <url>/p/52608.html</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串求他的最长回文子串</p><h2 id="方法1-暴力法"><a href="#方法1-暴力法" class="headerlink" title="方法1 暴力法"></a>方法1 暴力法</h2><p>略；</p><h2 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2 动态规划"></a>方法2 动态规划</h2><p>给定一个字符串s，设[p,q]是他的一个从p到q的回文字串，那么当p+1&lt;&#x3D;q-1的时候，[p+1，q-1]必定也是s的一个子串；<br>由此我们可以找到动态规划的递推表达式：</p><p>设：</p><pre><code>dp[i][i]=1; //单个字符是回文串dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串</code></pre><p>思考状态转移方程：</p><pre><code>根据头尾字符是否相等，需要分类讨论：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></pre><p>最终代码如下：</p><pre><code>string longestPalindrome(string s) &#123;    int slen=s.size();    vector&lt;vector&lt;bool&gt;&gt; dp(slen, vector&lt;bool&gt;(slen, 0));    int maxlenth = 0;    int left = 0;    int right = 0;    for (int i = slen - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; slen; j++) &#123;            if (s[i] == s[j]) &#123;                if (j - i &lt;= 1) &#123;                    dp[i][j] = true;                &#125;                 else if (dp[i + 1][j - 1]) &#123;                     dp[i][j] = true;                &#125;            &#125;            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxlenth) &#123;                maxlenth = j - i + 1;                left = i;                right = j;            &#125;        &#125;    &#125;    return s.substr(left, maxlenth);&#125;</code></pre><h2 id="方法三-中心拓展法"><a href="#方法三-中心拓展法" class="headerlink" title="方法三 中心拓展法"></a>方法三 中心拓展法</h2><p>我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1)P(i+1,j−1) 扩展到 P(i,j)P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</p><pre><code>class Solution &#123;public:    string longestPalindrome(string s) &#123;        int lans=0;        int length=s.size();        int left=0;        string ans=&quot;&quot;;        for(int i=0;i&lt;length;i++)&#123;            int j=1;            int tans=0;            while(i-j&gt;=0&amp;&amp;i+j&lt;length&amp;&amp;s[i-j]==s[i+j])&#123;                tans++;                j++;            &#125;            if(lans&lt;tans*2+1)&#123;                lans=tans*2+1;                left=i-tans;            &#125;            j=0;            tans=0;            while(i-j&gt;=0&amp;&amp;i+j+1&lt;length&amp;&amp;s[i-j]==s[i+j+1])&#123;                    tans++;                    j++;            &#125;            if(lans&lt;tans&lt;&lt;1)&#123;                lans=tans&lt;&lt;1;                left=i-tans+1;            &#125;            if(lans&gt;(length-i)*2)break;        &#125;        ans=s.substr(left,lans);        return ans;    &#125;&#125;;</code></pre><h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><pre><code>int countSubstrings(string s) &#123;    int n = s.size();    string t = &quot;$#&quot;;    for (const char &amp;c: s) &#123;        t += c;        t += &#39;#&#39;;    &#125;    n = t.size();    t += &#39;!&#39;;    auto f = vector &lt;int&gt; (n);    int iMax = 0, rMax = 0, ans = 0;    for (int i = 1; i &lt; n; ++i) &#123;        // 初始化 f[i]        f[i] = (i &lt;= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;        // 中心拓展        while (t[i + f[i]] == t[i - f[i]]) ++f[i];        // 动态维护 iMax 和 rMax        if (i + f[i] - 1 &gt; rMax) &#123;            iMax = i;            rMax = i + f[i] - 1;        &#125;        // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整        ans += (f[i] / 2);    &#125;    return ans;&#125;</code></pre><p>本题目重点需要说明的是马拉车算法；<br>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。那么我们如何统一奇数对称和偶数对称情况呢？<br>在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。<br><a href="https://imgse.com/i/p9eh1Mt"><img src="https://s1.ax1x.com/2023/04/23/p9eh1Mt.png" alt="处理后的字符串.png"></a></p><p>首先我们用一个数组 P 保存从中心扩展的最大个数。我们用 C 表示回文串的中心，用 R 表示回文串的右边半径坐标，所以 R &#x3D; C + P[ C ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。求 P [ i ] 的时候，如下图。</p><p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。<br><a href="https://imgse.com/i/p9ehrLV"><img src="https://s1.ax1x.com/2023/04/23/p9ehrLV.png" alt="p9ehrLV.png"></a></p><p>但是，利用对称性并不一定能完全得到结果<br><a href="https://imgse.com/i/p9ehzOP"><img src="https://s1.ax1x.com/2023/04/23/p9ehzOP.png" alt="p9ehzOP.png"></a><br>当我们要求 P [ i ] 的时候，P [ mirror ] &#x3D; 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i<br>此外如果，mirror因为碰到边界而截止<br><a href="https://imgse.com/i/p9e44hQ"><img src="https://s1.ax1x.com/2023/04/23/p9e44hQ.png" alt="p9e44hQ.png"></a><br>此时P [ i_mirror ] &#x3D; 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” &#x3D;&#x3D; “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><p>总之，综合思想就是利用对称性降低复杂度，使得我们判断过的部分避免反复计算，总体是时间复杂度大概是2n，即O(n);</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>棘手怀念摧毁</title>
      <link href="/p/12758.html"/>
      <url>/p/12758.html</url>
      
        <content type="html"><![CDATA[<h1 id="棘手怀念摧毁"><a href="#棘手怀念摧毁" class="headerlink" title="棘手怀念摧毁"></a>棘手怀念摧毁</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p><img src="/p/12758.htm/%E6%A3%98%E6%89%8B%E6%80%80%E5%BF%B5%E6%91%A7%E6%AF%81.png"></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>输入格式:第一行有三个整数n,m，A ;<br>第二行有n个数ai，表示每头大象的愤怒值。<br>输出格式:一个整数表示新大象住下后象棚最大的愤怒值。</p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>样例1</p><pre><code>输入:   3 2 50        60 100 70输出:270</code></pre><p>备注<br>其中:1≤m≤n ≤5* 106，0 ≤ai, A ≤100。【样例解释】<br>1.当新大象在第一个位置时(50,60,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 60,100 + max 100,70，即60＋100＋100&#x3D;260。<br>2.当新大象在第二个位置时( 60,50,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 50,100 + max 100,70，即60＋100+100&#x3D; 260。<br>3.当新大象在第三个位置时( 60,100,50,70 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,50 + max 50,70，即100＋100＋70 &#x3D; 270。<br>4.当新大象在第四个位置时( 60,100,70,50 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,70 + max 70,50，即70＋100＋100 &#x3D; 270。<br>整个象棚的愤怒值的最大值为max 260,260,270,270 &#x3D; 270。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>779 第k个语法符号</title>
      <link href="/p/65488.html"/>
      <url>/p/65488.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><pre><code>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）例子:输入: N = 1, K = 1输出: 0输入: N = 2, K = 1输出: 0输入: N = 2, K = 2输出: 1输入: N = 4, K = 5输出: 1解释:第一行: 0第二行: 01第三行: 0110第四行: 01101001来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/k-th-symbol-in-grammar</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    可以将第n个数字串平均分两部分，前半部分和第n-1数字串相同，后半部分则是第n-1数字串按位取反    那么我们可以判断k的位置，从而不断缩小数字串的长度，最终到第一个字符串；</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    int kthGrammar(int n, int k)&#123;    int sign=1;    while(1)&#123;        if(k&lt;=(1&lt;&lt;(n-1)))&#123;            n--;        &#125;        if(n&amp;&amp;k&gt;(1&lt;&lt;(n-1)))&#123;            k=k-(1&lt;&lt;(n-1));            sign*=-1;        &#125;        if(k==1)&#123;            return sign&gt;0?0:1;        &#125;    &#125;&#125;                                                                                      </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><p>经过观察发现这道题的解其实就是对K-1进行了一个奇偶校验，因此连N这个参数都用不着，O(1)时间空间复杂度求解</p><pre><code>    int kthGrammar(int N, unsigned int K) &#123;        K -= 1;        K ^= K &gt;&gt; 1;        K ^= K &gt;&gt; 2;        K = (K &amp; 0x11111111U) * 0x11111111U;        return (K &gt;&gt; 28) &amp; 1;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计子矩阵</title>
      <link href="/p/35775.html"/>
      <url>/p/35775.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定一个 N × M 的矩阵 A , 请你统计有多少个子矩阵 (最小 1 × 1, 最大 N × M ) 满足子矩阵中所有数的和不超过给定的整数 K  ?</p><p>输入格式<br>第一行包含三个整数 N , M 和 K .</p><p>之后 N行每行包含 M 个整数, 代表矩阵 A.</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入：    3 4 10    1 2 3 4    5 6 7 8    9 10 11 12输出：19</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>首先，求取一个矩阵的和可以采用二维前缀和简化计算，降低复杂度。其次，不难想到，我们可以枚举左上角坐标以及右下角坐标求出所有满足条件的矩阵，但是这样复杂度就是n^4，时间复杂度相对难以接受。所以我们应该想办法降低复杂度，根据题目要求，不大于k,那么一个矩阵的子矩阵大于k则该矩阵就无需判断，这样利用双指针，我们可以在O(n)的时间求出这一行的矩阵。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include &lt;iostream&gt;using namespace std;int a[510][510];int sum1(int x1,int y1,int x2,int y2)&#123;    return a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1];&#125;int main()&#123;    int n,m,k;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);    long long int ans=0;    int temp;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;        scanf(&quot;%d&quot;,&amp;temp);        a[i][j]=a[i-1][j]+a[i][j-1]+temp-a[i-1][j-1];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = i; j &lt;= n; ++j) &#123;                for (int l = 1, r = 1; r &lt;= m; ++r) &#123;                    while (l &lt;= r &amp;&amp; sum1(i, l, j, r) &gt; k) l++;                    ans += r - l + 1;                &#125;            &#125;        &#125;    cout &lt;&lt; ans;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超过一半的数字</title>
      <link href="/p/61876.html"/>
      <url>/p/61876.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="/p/61401.html"/>
      <url>/p/61401.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一-暴力法"><a href="#一-暴力法" class="headerlink" title="一 暴力法"></a>一 暴力法</h4><pre><code>—略—</code></pre><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><pre><code>其实这道题很明显就满足最优子结构性，如果想用最少的硬币兑换money，这对硬币的子集的总金额所需硬币数一定是最少的，否则用更少的硬币替换这个子集的硬币，则总money所需硬币数一定比原来少。现在的问题是如何获得状态方程。假设硬币的金额有m1,m2...mx,需要兑换的总金额为money，金额为money的硬币数存在f[money]中，那么f[money]一定可以由f[money-m1]+1,f[money-m2]+1...f[money-mx]+1中的一个或者多个组成，上面已经说明最优子结构，这样，我们只需要找f[money-m1],f[money-m2]...f[money-mx]中的最小值。问题不断分解，分解到f[m1],f[m2]...f[mx]这些确定值上面（都为1）。按照这个思路，我们反向进行迭代最终就可以求得f[money];    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int Max = amount + 1;        vector&lt;int&gt; dp(amount + 1, Max);        dp[0] = 0;        for (int i = 1; i &lt;= amount; ++i) &#123;            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;                if (coins[j] &lt;= i) &#123;                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &gt; amount ? -1 : dp[amount];    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/">https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香槟塔</title>
      <link href="/p/52292.html"/>
      <url>/p/52292.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</code></pre><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.00000解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</code></pre><p>示例 2:</p><pre><code>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.50000解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</code></pre><p>示例 3:</p><pre><code>输入: poured = 100000009, query_row = 33, query_glass = 17输出: 1.00000</code></pre><p>提示：</p><pre><code>0 &lt;= poured &lt;= 1090 &lt;= query_glass &lt;= query_row &lt; 100</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>本弱鸡一直在纠结是不是数学问题，暴力的话poured是不是够用，每层减少对应数目，但是最后还是算不出来，最终也没有做出来。贴一个官方题解。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;</code></pre><p>public:<br>    double champagneTower(int poured, int query_row, int query_glass) {<br>        vector<double> row &#x3D; {(double)poured};<br>        for (int i &#x3D; 1; i &lt;&#x3D; query_row; i++) {<br>            vector<double> nextRow(i + 1, 0.0);<br>            for (int j &#x3D; 0; j &lt; row.size(); j++) {<br>                double volume &#x3D; row[j];<br>                if (volume &gt; 1) {<br>                    nextRow[j] +&#x3D; (volume - 1) &#x2F; 2;<br>                    nextRow[j + 1] +&#x3D; (volume - 1) &#x2F; 2;<br>                }<br>            }<br>            row &#x3D; nextRow;<br>        }<br>        return min(1.0, row[query_glass]);<br>    }<br>};</double></double></p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/">https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/p/9615.html"/>
      <url>/p/9615.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。    设计一个算法来计算你所能获取的最大利润。    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入：[7,1,5,3,6,4]    输出：5    解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，暴力法"><a href="#一，暴力法" class="headerlink" title="一，暴力法"></a>一，暴力法</h4><pre><code>—略—</code></pre><h4 id="二，一次遍历"><a href="#二，一次遍历" class="headerlink" title="二，一次遍历"></a>二，一次遍历</h4><pre><code>    如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，      我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么，      我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。因此，我们只需要遍历价格数组      一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖      出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                //不能超过n的值，并不是所有节点都有十个子节点                step += min((long long)n + 1, last) - first;                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><h4 id="三，本弱鸡的解法"><a href="#三，本弱鸡的解法" class="headerlink" title="三，本弱鸡的解法"></a>三，本弱鸡的解法</h4><pre><code>    最近算法课刚刚学习了最大子数组和，所以本弱鸡依葫芦画瓢，从最后一项向前遍历，每一项都等于      减去前一项以后的值。这样就将某两点的最大差值问题变成了该数组之间的最大子数组和问题。注意，      计算子数组和时忽略掉第零项。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        for(int i=prices.size()-1;i&gt;0;i--)&#123;            prices[i]=prices[i]-prices[i-1];        &#125;        int sum=0,maxProfit=0;        for(int i=1;i&lt;prices.size();i++)&#123;            sum+=prices[i];            if(sum&gt;maxProfit)maxProfit=sum;            if(sum&lt;0)sum=0;        &#125;        return maxProfit;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/p/9616.html"/>
      <url>/p/9616.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。在每一天，你可能会决定购买      或出售股票。你在任何时候最多只能持有一股股票。你也可以购买它，然后在同一天出售。返回你能获      得的最大利润。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: prices = [7,1,5,3,6,4]    输出: 7    解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5的时候卖出,       这笔交易所能获得利润 = 5-1 = 4 。    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6） 的时候卖出,       这笔交易所能获得利润 = 6-3 = 3 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，动态规划"><a href="#一，动态规划" class="headerlink" title="一，动态规划"></a>一，动态规划</h4><pre><code>    考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。    定义状态 dp[i][0] 表示第i天交易完后手里没有股票的最大利润，dp[i][1] 表示第i天交易完后手里      持有一支股票的最大利润（i 从 0 开始）。    考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有      股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将      其卖出，并获得prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])    再来考虑dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即      dp[i−1][1]，或者前一天结束时还没有股票，即dp[i−1][0]，这时候我们要将其买入，并减少prices[i]      的收益。可以列出如下的转移方程：                dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125;    对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 0dp[0][0]=0，dp[0][1]=−prices[0]。    因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收      益，因此这时候 dp[n−1][0]的收益必然是大于dp[n−1][1] 的，最后的答案即为dp[n−1][0]。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n = prices.size();        int dp[n][2];        dp[0][0] = 0, dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; ++i) &#123;            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);        &#125;        return dp[n - 1][0];    &#125;&#125;;</code></pre><h4 id="二，（贪心算法）本弱鸡的解法"><a href="#二，（贪心算法）本弱鸡的解法" class="headerlink" title="二，（贪心算法）本弱鸡的解法"></a>二，（贪心算法）本弱鸡的解法</h4><pre><code>    因为可以不限制购买，所以只要是顺序对就把他加入。同时要注意的是，连续的顺序对，比如&#123;1，2，3，4&#125;，      实际购买情况是第一天买入第四天卖出，做题顺序不等于实际购买顺序。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int sum=0;        for(int i=1;i&lt;prices.size();i++)&#123;            if(prices[i]&gt;prices[i-1])sum+=prices[i]-prices[i-1];        &#125;        return sum;    &#125;    &#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/p/63859.html"/>
      <url>/p/63859.html</url>
      
        <content type="html"><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>全排列 一般把1~ n 这 n 个整数按某个顺序摆放的结果称为这 n 个整数的一个排列，而全排列指这 n 个整数能形成的所有排列。<br>例如对1、2、3这三个整数来说，(1,2,3)、(1,3,2)、(2,1,3)、(2,3,1 、(3,1,2)、(3,2, I ）就是1<del>3的全排列。<br>从递归的角度去考虑，如果把问题描述成“输出1</del> n 这 n 个整数的全排列”，那么它就可以被分为若干个子问题：“输出以1开头的全排列”“输出以2开头的全排列”…“输出以 n 开头的全排列”。于是不妨设定一个数组 P ，用来存放当前的排列；再设定一个散列数组 hash Table ，其中 hashTable [ x ］当整数 x 已经在数组 P 中时为 true 。<br>现在按顺序往 P 的第1位到第 n 位中填入数字。不妨假设当前已经填好了 P [1]~ P [ index -1]，正准备填 P [ index ]。显然需要枚举1~ n ，如果当前枚举的数字 x 还没有在 P [1]~ P [ index -1］中（即 hashTable [ x ]&#x3D; false )，那么就把它填入 P [ index ]，同时将 hashTable [ x ］置为 true ,然后去处理 P 的第 Tndex +1位（即进行递归）；而当递归完成时，再将 hashTable [ x ］还原为 false ,以便让 P [ index ］填下一个数字。<br>当 index 达到 n +1时，说明 P 的第1~ n 位都已经填好了，此时可以把数组 P 输出，表示生成了一个排列，然后直接 return 即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    # include &lt; cstdio &gt;    const int maxn =1l;    //P为当前排列， hashTable 记录整数 x 是否已经在 P 中     int n , P [maxn], hashTable[maxn]=&#123;false&#125;;    //当前处理排列的第 index 号位    void generateP ( int index )&#123;        if ( index = n +1)&#123;//递归边界，已经处理完排列的1~ n 位            for ( int i = 1 ; i &lt;= n ; i ++)&#123;                printf (&quot;%d&quot;, P [ i ]);//输出当前排列            &#125;            printf (&quot;\n &quot;);            return ;        &#125;        for ( int ×=1;×&lt;= n ;×++)&#123;//枚举1~ n ，试图将×填入 P [ index ]            if ( hashTable [ x ]== false )&#123;//如果×不在P[0]~P [index-1］中             P [ index ]= X ;//令 P 的第 index 位为×，即把×加入当前排列             hashTable [ x ]= true ;//记 x 已在 P 中            generateP ( index +1);//处理排列的第 index +1号位            hashTable [ x ]= false ;//已处理完 P [ index ］为×的子问题，还原状态            &#125;        &#125;    &#125;    int main ()&#123;        n =3;//欲输出1~3的全排列        generateP (1);//从 P [1］开始填         return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前k个高频词</title>
      <link href="/p/49651.html"/>
      <url>/p/49651.html</url>
      
        <content type="html"><![CDATA[<h1 id="前k个高频词"><a href="#前k个高频词" class="headerlink" title="前k个高频词"></a>前k个高频词</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><pre><code> 给你一个整数数组nums和一个整数k ，请你返回其中出现频率前k高的元素。 你可以按任意顺序返回答案。 </code></pre><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</code></pre><p>注意：</p><pre><code>求前 k 大，用小根堆，求前 k 小，用大根堆。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>方法一：桶+快排</strong></p><p>思路与算法：<br>本弱鸡的思路是先用桶把每个数字出现的次数记录下来，然后通过快排按照桶的大小将高频词前k排序出来。</p><p>代码略</p><p>复杂度分析</p><p><strong>时间复杂度：</strong>O(NlogN)，其中 N 为数组的长度。我们首先遍历原数组，并使用桶记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，取出不为0的数组范围O(N),然后采取快排取出前n大数组，总复杂度 O(NlogN)。<br><strong>空间复杂度</strong> 随着数据范围改变而改变</p><p><strong>方法二：堆</strong></p><p>思路与算法：<br>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。</p><p>最简单的做法是给「出现次数数组」排序。但由于可能有 O(N) 个不同的出现次数（其中 N 为原数组长度），故总的算法复杂度会达到 O(NlogN)，不满足题目的要求。</p><p>在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：</p><p>如果堆的元素个数小于 k，就可以直接插入堆中。<br>如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。<br>遍历完成后，堆中的元素就代表了「出现次数数组」中前 kk 大的值。</p><pre><code>class Solution &#123;public:    static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) &#123;        return m.second &gt; n.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v : nums) &#123;            occurrences[v]++;        &#125;        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp);        for (auto&amp; [num, count] : occurrences) &#123;            if (q.size() == k) &#123;                if (q.top().second &lt; count) &#123;                    q.pop();                    q.emplace(num, count);                &#125;            &#125; else &#123;                q.emplace(num, count);            &#125;        &#125;        vector&lt;int&gt; ret;        while (!q.empty()) &#123;            ret.emplace_back(q.top().first);            q.pop();        &#125;        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：</strong>O(Nlogk)，其中 N 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(logk) 的时间，共需 O(Nlogk) 的时间。二者之和为 O(Nlogk)。<br><strong>空间复杂度：</strong>O(N)。哈希表的大小为 O(N)，而堆的大小为 O(k)，共计为 O(N)。</p><p><strong>方法三：快排</strong></p><p>我们可以使用基于快速排序的方法，求出「出现次数数组」的前 k 大的值。<br>在对数组 arr[l…r] 做快速排序的过程中，我们首先将数组划分为两个部分 arr[i…q−1] 与 arr[q+1…j]，并使得 arr[i…q−1] 中的每一个值都不超过 arr[q]，且arr[q+1…j] 中的每一个值都大于 arr[q]。<br>于是，我们根据 k 与左侧子数组 arr[i…q−1] 的长度（为 q-iq−i）的大小关系：<br>如果k≤q−i，则数组 arr[l…r]前k大的值，就等于子数组arr[i…q−1]前k大的值。<br>否则，数组 arr[l…r] 前 k 大的值，就等于左侧子数组全部元素，加上右侧子数组 arr[q+1…j] 中前 k−(q−i) 大的值。<br>原版的快速排序算法的平均时间复杂度为O(NlogN)。我们的算法中，每次只需在其中的一个分支递归即可，因此算法的平均时间复杂度降为 O(N)O(N)。</p><pre><code>class Solution &#123;public:    void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) &#123;        int picked = rand() % (end - start + 1) + start;        swap(v[picked], v[start]);        int pivot = v[start].second;        int index = start;        for (int i = start + 1; i &lt;= end; i++) &#123;            if (v[i].second &gt;= pivot) &#123;                swap(v[index + 1], v[i]);                index++;            &#125;        &#125;        swap(v[start], v[index]);        if (k &lt;= index - start) &#123;            qsort(v, start, index - 1, ret, k);        &#125; else &#123;            for (int i = start; i &lt;= index; i++) &#123;                ret.push_back(v[i].first);            &#125;            if (k &gt; index - start + 1) &#123;                qsort(v, index + 1, end, ret, k - (index - start + 1));            &#125;        &#125;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v: nums) &#123;            occurrences[v]++;        &#125;        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; kv: occurrences) &#123;            values.push_back(kv);        &#125;        vector&lt;int&gt; ret;        qsort(values, 0, values.size() - 1, ret, k);        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：O(N^2)</strong><br>设处理长度为N的数组的时间复杂度为f(N)。由于处理的过程包括一次遍历和一次子分支的递归，最好情况下，有 f(N)&#x3D;O(N)+f(N&#x2F;2)，根据主定理，能够得到f(N)&#x3D;O(N)。<br>最坏情况下，每次取的中枢数组的元素都位于数组的两端，时间复杂度退化为O(N^2)。但由于我们在每次递归的开始会先随机选取中枢元素，故出现最坏情况的概率很低。<br><em>平均情况下，时间复杂度为 O(N)。</em><br><strong>空间复杂度：O(N)</strong><br>哈希表的大小为O(N)，用于排序的数组的大小也为 O(N)，快速排序的空间复杂度最好情况为 O(logN)，最坏情况为 O(N)。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匹配子序列的单词数</title>
      <link href="/p/39967.html"/>
      <url>/p/39967.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。例如， “ace” 是 “abcde” 的子序列。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>略</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>采用桶的思想，预先将对应字符下一次出现的位置保存下来，避免一次又一次遍历造成的重复时间损失。看大神的做法桶的基础上还可以采用二分查找，奈何本弱鸡不会stl的二分查找，把官方题解粘下来以供学习。以及通过多指针的方式来进行求解，这也是难以想到的方式，同样官方题解粘下来以供学习。</code></pre><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><pre><code>class Solution &#123;public:int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;    vector&lt;int&gt; temp[27];    int len[27];    int ans=0;    int length=s.size();    for(int i=0;i&lt;length;i++)    &#123;        temp[s[i]-&#39;a&#39;].push_back(i);    &#125;    for(auto word:words)    &#123;        for(int i=0;i&lt;27;i++)        &#123;            len[i]=0;        &#125;        int wordlen=word.size();        int curpos=0;        int i=0;        for(;i&lt;wordlen;i++)        &#123;            int pos=word[i]-&#39;a&#39;;            while(len[pos]&lt;temp[pos].size()&amp;&amp;curpos&gt;temp[pos][len[pos]])len[pos]++;            if(len[pos]&lt;temp[pos].size())            &#123;                curpos=temp[pos][len[pos]];                len[pos]++;            &#125;            else            &#123;                break;            &#125;        &#125;        if(i==wordlen)        &#123;            ans++;        &#125;     &#125;    return ans;&#125;</code></pre><p>};</p><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><pre><code>class Solution &#123;public:    int numMatchingSubseq(string s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;vector&lt;int&gt;&gt; pos(26);        for (int i = 0; i &lt; s.size(); ++i) &#123;            pos[s[i] - &#39;a&#39;].push_back(i);        &#125;        int res = words.size();        for (auto &amp;w : words) &#123;            if (w.size() &gt; s.size()) &#123;                --res;                continue;            &#125;            int p = -1;            for (char c : w) &#123;                auto &amp;ps = pos[c - &#39;a&#39;];                auto it = upper_bound(ps.begin(), ps.end(), p);                if (it == ps.end()) &#123;                    --res;                    break;                &#125;                p = *it;            &#125;        &#125;        return res;    &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode.cn/problems/number-of-matching-subsequences/solution/pi-pei-zi-xu-lie-de-dan-ci-shu-by-leetco-vki7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="代码实现3"><a href="#代码实现3" class="headerlink" title="代码实现3"></a>代码实现3</h3><pre><code>class Solution &#123;public:    int numMatchingSubseq(string s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;queue&lt;pair&lt;int, int&gt;&gt;&gt; queues(26);        for (int i = 0; i &lt; words.size(); ++i) &#123;            queues[words[i][0] - &#39;a&#39;].emplace(i, 0);        &#125;        int res = 0;        for (char c : s) &#123;            auto &amp;q = queues[c - &#39;a&#39;];            int size = q.size();            while (size--) &#123;                auto [i, j] = q.front();                q.pop();                ++j;                if (j == words[i].size()) &#123;                    ++res;                &#125; else &#123;                    queues[words[i][j] - &#39;a&#39;].emplace(i, j);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode.cn/problems/number-of-matching-subsequences/solution/pi-pei-zi-xu-lie-de-dan-ci-shu-by-leetco-vki7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/p/967.html"/>
      <url>/p/967.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入: head = [1,2,3,4,5]输出: [5,4,3,2,1]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    有迭代和递归两种做法</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>迭代做法</strong></p><pre><code>class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode prev = nullptr;        ListNode curr = head;        while (curr != null) &#123;            ListNode next = curr.next;            curr.next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;</code></pre><p><strong>递归做法</strong></p><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;            return head;        &#125;        ListNode* ret = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return ret;    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同构字符串</title>
      <link href="/p/20114.html"/>
      <url>/p/20114.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给定两个字符串 s 和 t ，判断它们是否是同构的。如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入：s = &quot;egg&quot;, t = &quot;add&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;foo&quot;, t = &quot;bar&quot;输出：false</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;paper&quot;, t = &quot;title&quot;输出：true</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 5 * 104t.length == s.lengths 和 t 由任意有效的 ASCII 字符组成</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>创建两个桶数组，然后分别存放该字符出现的位置，如果产生冲突就返回false。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/isomorphic-strings">https://leetcode.cn/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/p/59828.html"/>
      <url>/p/59828.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: [10,2]输出: &quot;102&quot;</code></pre><p>示例 2:</p><pre><code>输入: [3,30,34,5,9]输出: &quot;3033459&quot;</code></pre><p> </p><p>提示:</p><pre><code>0 &lt; nums.length &lt;= 100</code></pre><p>说明:</p><pre><code>输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>这里的神来之笔是return a+b&lt;b+a这个操作，巧妙的对数组进行排列。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    string minNumber(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;string&gt;snum;        string res;        for(auto num:nums)&#123;            snum.push_back(to_string(num));        &#125;        sort(snum.begin(),snum.end(),cmp);        for(auto s:snum)&#123;            res+=s;        &#125;        return res;    &#125;    static bool cmp(const string&amp;a,const string b)&#123;        return a+b&lt;b+a;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序的第k大数字</title>
      <link href="/p/3457.html"/>
      <url>/p/3457.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。  </code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: n = 13, k = 2    输出: 10    解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    这里的字典树其实就是一个十叉树，我们只需要构建一个十叉树，然后进行先序遍历就好了。但是      仔细想一下，n的范围一旦很大，对于空间的开销是难以想象的。所以我们要根据十叉树的思想，来      模拟遍历。根据十叉树的性质，每一层中的个数十上一层树的十倍，比如1000~9999就是100~999的      十倍，那么以100~199为前缀的第四层结点个数等于第三层节点个数。也就是说如果从某一棵树第n层      的节点总和大于k的话，那么第k大的元数必定在n-1层。根据这个性质，我们从1为根节点的子树开始      遍历，如果第一层中的结点数大于k，那么第k大的数在第一棵子树上，否则在剩下子树中。遍历下去，      直到找到结果。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                step += min((long long)n + 1, last) - first;//不能超过n的值，并不是所有节点都有十个子节点                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><p>来源：力扣（LeetCode）<br>    链接：<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order</a><br>    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号生成</title>
      <link href="/p/38710.html"/>
      <url>/p/38710.html</url>
      
        <content type="html"><![CDATA[<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1：</p><pre><code>输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p>示例 2：</p><pre><code>输入：n = 1输出：[&quot;()&quot;]</code></pre><p> </p><p>提示：</p><pre><code>1 &lt;= n &lt;= 8</code></pre><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p><strong>本弱鸡的解题思路</strong><br>暴力枚举加剪枝，如果右括号数量比左括号数量多，则进行剪枝，否则依次枚举添加左括号和添加右括号，如果左右括号数量相等，则只能添加左括号。当左括号数目为n，停止添加左括号，只添加右括号。当左右括号数量都为n，将其填入结果vector当中。</p><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt;ans;    vector&lt;string&gt; generateParenthesis(int n) &#123;        dfs(&quot;&quot;,n,n);        return ans;    &#125;    void dfs(string temp,int left,int right)&#123;        if(left==0&amp;&amp;right==0)&#123;            ans.push_back(temp);        &#125;        else&#123;            if(left!=0)&#123;                dfs(temp+&#39;(&#39;,left-1,right);            &#125;            if(left&lt;right)&#123;                dfs(temp+&#39;)&#39;,left,right-1);            &#125;        &#125;    &#125;&#125;;</code></pre><p>不论是时间还是空间花费都比较多<br><strong>执行用时：4 ms, 在所有 C++ 提交中击败了65.31%的用户<br>内存消耗：13.5 MB, 在所有 C++ 提交中击败了35.99%的用户</strong></p><h3 id="dfs（大佬做法）"><a href="#dfs（大佬做法）" class="headerlink" title="dfs（大佬做法）"></a>dfs（大佬做法）</h3><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; res;        func(res, &quot;&quot;, 0, 0, n);        return res;    &#125;        void func(vector&lt;string&gt; &amp;res, string str, int l, int r, int n)&#123;        if(l &gt; n || r &gt; n || r &gt; l) return ;        if(l == n &amp;&amp; r == n) &#123;res.push_back(str); return;&#125;        func(res, str + &#39;(&#39;, l+1, r, n);        func(res, str + &#39;)&#39;, l, r+1, n);        return;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：14.6 MB, 在所有 C++ 提交中击败了22.09%的用户</strong></p><p>不清楚为什么时间效率会差这么多，感觉都要遍历同样多的节点数。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>解题思路</strong><br>可以把一个（）看作最小单位元进行处理，每次在最后一个（后面开始加入（），一直加到末尾，例如：<br>【（）】<br>【（（））】 【（）（）】<br>【（（（））） 】【（（）（））】 【（（））（）】 【（）（）（）】 【（）（（））】<br><strong>……</strong></p><p>10<br>1100 1010<br>111000 110100 110010 101100 101010<br>……</p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if(n == 1) return &#123;&quot;()&quot;&#125;;        vector&lt;string&gt; tmp = generateParenthesis(n - 1);        vector&lt;string&gt; res;        for(int i = 0; i &lt; tmp.size(); i ++)&#123;            int last = tmp[i].size() - 1;            while(tmp[i][last - 1] != &#39;(&#39;) last --;            for(int j = last; j &lt;= tmp[i].size(); j++)&#123;                res.push_back(&quot;&quot; + tmp[i]);                res.back().insert(j, &quot;()&quot;);            &#125;        &#125;                return res;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：7 MB, 在所有 C++ 提交中击败了98.07%的用户</strong></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>作者<a href="https://leetcode.cn/u/yuyu-13/">：yuyu-13</a><br>题解链接：<a href="https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a><br><strong>解题思路</strong></p><p>当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i&#x3D;n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。</p><p>那么，剩下 n-1 组括号有可能在哪呢？</p><p><strong>【这里是重点，请着重理解】</strong></p><p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p><p>既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：</p><p>“(“ + 【i&#x3D;p时所有括号的排列组合】 + “)” + 【i&#x3D;q时所有括号的排列组合】</p><p>其中 p + q &#x3D; n-1，且 p q 均为非负整数。</p><p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p><p><em>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</em></p><p><strong>代码：</strong><br><strong>具体代码如下：</strong>（<strong>时间击败百分之 95，内存击败百分之 99.65）</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if (n == 0) return &#123;&#125;;        if (n == 1) return &#123; &quot;()&quot; &#125;;        vector&lt;vector&lt;string&gt;&gt; dp(n+1);        dp[0] = &#123; &quot;&quot; &#125;;        dp[1] = &#123; &quot;()&quot; &#125;;        for (int i = 2; i &lt;= n; i++) &#123;            for (int j = 0; j &lt;i; j++) &#123;                for (string p : dp[j])                    for (string q : dp[i - j - 1]) &#123;                        string str = &quot;(&quot; + p + &quot;)&quot; + q;                        dp[i].push_back(str);                    &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/generate-parentheses">https://leetcode.cn/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Easy Strings Merging</title>
      <link href="/p/47143.html"/>
      <url>/p/47143.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><pre><code>给定 nn 个 01 串，每次你可以从某个串开头移除一个字符并把它加入一个新串 SS 的末尾。最大化 SS 中相邻两个字符相同的对数。(P8001)</code></pre><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><pre><code>第一行一个正整数 nn 表示串的个数。接下来 nn 行，每行一个 01 字符串。</code></pre><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><pre><code>一行一个整数表示答案。</code></pre><h5 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h5><pre><code>    输入 ：                                  输出：9    3    0011    0110    1100</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    暴力模拟！！！！！！！！！！用的c语言，没有用String类，只能拿到75分。暂未解决空间溢出问题。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #pragma warning(disable:4996)    #include&lt;stdio.h&gt;    #include&lt;string.h&gt;    char a[10001][10001];    int b[1001];    int c[1001];    int check[1001];    int main() &#123;        int sum1 = 0, sum2 = 0,flag=0;        int n, i, temp;        scanf(&quot;%d&quot;, &amp;n);        temp = n;        for (i = 0; i &lt; n; i++) &#123;            scanf(&quot;%s&quot;, a[i]);            c[i] = strlen(a[i]);        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (!check[i]&amp;&amp;b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum1--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum1--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        temp = n;        for (i = 0; i &lt; n; i++) &#123;            b[i] = 0;            check[i] = 0;        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum2--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum2--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        if (sum1 &gt; sum2)printf(&quot;%d&quot;, sum1);        else printf(&quot;%d&quot;, sum2);        return 0;    &#125;                                                                                 </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><pre><code>    暂时无</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯安全</title>
      <link href="/p/410e30c.html"/>
      <url>/p/410e30c.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯安全–搞rust数据库方向"><a href="#腾讯安全–搞rust数据库方向" class="headerlink" title="腾讯安全–搞rust数据库方向"></a>腾讯安全–搞rust数据库方向</h1><h2 id="描述一下IO多路复用"><a href="#描述一下IO多路复用" class="headerlink" title="描述一下IO多路复用"></a>描述一下IO多路复用</h2><h2 id="描述一下多路复用怎么和协程配合的"><a href="#描述一下多路复用怎么和协程配合的" class="headerlink" title="描述一下多路复用怎么和协程配合的"></a>描述一下多路复用怎么和协程配合的</h2><h2 id="io-uring和epoll之间的区别（因为我前面对协程和epoll的配合使用回答的时候说了io-uring）"><a href="#io-uring和epoll之间的区别（因为我前面对协程和epoll的配合使用回答的时候说了io-uring）" class="headerlink" title="io_uring和epoll之间的区别（因为我前面对协程和epoll的配合使用回答的时候说了io_uring）"></a>io_uring和epoll之间的区别（因为我前面对协程和epoll的配合使用回答的时候说了io_uring）</h2><h2 id="atomic中release-x2F-acquire-x2F-relaxed三种内存序的区别"><a href="#atomic中release-x2F-acquire-x2F-relaxed三种内存序的区别" class="headerlink" title="atomic中release&#x2F;acquire&#x2F;relaxed三种内存序的区别"></a>atomic中release&#x2F;acquire&#x2F;relaxed三种内存序的区别</h2><h2 id="为什么用sendfile，sendfile和普通方式读写的区别？"><a href="#为什么用sendfile，sendfile和普通方式读写的区别？" class="headerlink" title="为什么用sendfile，sendfile和普通方式读写的区别？"></a>为什么用sendfile，sendfile和普通方式读写的区别？</h2><h2 id="为什么sendfile在文件大-1GB以上-的情况下不好用？（我自己挖的坑，因为记得看到过文章描述sendfile的缺点的时候说大文件最好不要用"><a href="#为什么sendfile在文件大-1GB以上-的情况下不好用？（我自己挖的坑，因为记得看到过文章描述sendfile的缺点的时候说大文件最好不要用" class="headerlink" title="为什么sendfile在文件大(1GB以上)的情况下不好用？（我自己挖的坑，因为记得看到过文章描述sendfile的缺点的时候说大文件最好不要用"></a>为什么sendfile在文件大(1GB以上)的情况下不好用？（我自己挖的坑，因为记得看到过文章描述sendfile的缺点的时候说大文件最好不要用</h2><h2 id="描述了一下我网络库中对整个文件发送和数据发送的统一抽象封装"><a href="#描述了一下我网络库中对整个文件发送和数据发送的统一抽象封装" class="headerlink" title="描述了一下我网络库中对整个文件发送和数据发送的统一抽象封装"></a>描述了一下我网络库中对整个文件发送和数据发送的统一抽象封装</h2><h2 id="项目中有用到引用计数-定时器实现心跳处理，这个具体怎么实现的？"><a href="#项目中有用到引用计数-定时器实现心跳处理，这个具体怎么实现的？" class="headerlink" title="项目中有用到引用计数+定时器实现心跳处理，这个具体怎么实现的？"></a>项目中有用到引用计数+定时器实现心跳处理，这个具体怎么实现的？</h2><h2 id="描述了一下我两个层级的定时器实现（优先队列底层定时器-时间轮的上层定时器）"><a href="#描述了一下我两个层级的定时器实现（优先队列底层定时器-时间轮的上层定时器）" class="headerlink" title="描述了一下我两个层级的定时器实现（优先队列底层定时器+时间轮的上层定时器）"></a>描述了一下我两个层级的定时器实现（优先队列底层定时器+时间轮的上层定时器）</h2><h2 id="优先队列怎么实现的？"><a href="#优先队列怎么实现的？" class="headerlink" title="优先队列怎么实现的？"></a>优先队列怎么实现的？</h2><h2 id="有了解过数据库相关的知识吗？数据库是如何执行的？"><a href="#有了解过数据库相关的知识吗？数据库是如何执行的？" class="headerlink" title="有了解过数据库相关的知识吗？数据库是如何执行的？"></a>有了解过数据库相关的知识吗？数据库是如何执行的？</h2><h2 id="火山引擎有了解过吗（这一块不强求？"><a href="#火山引擎有了解过吗（这一块不强求？" class="headerlink" title="火山引擎有了解过吗（这一块不强求？"></a>火山引擎有了解过吗（这一块不强求？</h2><h2 id="有了解过编译器相关的知识吗？"><a href="#有了解过编译器相关的知识吗？" class="headerlink" title="有了解过编译器相关的知识吗？"></a>有了解过编译器相关的知识吗？</h2><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>a0&#x3D;[1]<br>a1&#x3D;[1,2,1]<br>a2&#x3D;[a1,3,a1]<br>an&#x3D;[an-1,n,an-1]<br>1.求出len(an)的数学公式表达（等比数列<br>2.已知k，求出a[k]的值，用最快的方式定位到a[k]应该用哪个表达式而不是一个个递归先算出（二分</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯天美</title>
      <link href="/p/3a9ea38.html"/>
      <url>/p/3a9ea38.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯天美"><a href="#腾讯天美" class="headerlink" title="腾讯天美"></a>腾讯天美</h1><h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP-包头字段…-标志位"><a href="#TCP-包头字段…-标志位" class="headerlink" title="TCP 包头字段… 标志位"></a>TCP 包头字段… 标志位</h3><h3 id="gt-建立连接过程，终止连接过程"><a href="#gt-建立连接过程，终止连接过程" class="headerlink" title="-&gt; 建立连接过程，终止连接过程"></a>-&gt; 建立连接过程，终止连接过程</h3><h3 id="gt-TIME-WAIT-CLOSE-WAIT-分析，属于哪一方？"><a href="#gt-TIME-WAIT-CLOSE-WAIT-分析，属于哪一方？" class="headerlink" title="-&gt; TIME_WAIT, CLOSE_WAIT 分析，属于哪一方？"></a>-&gt; TIME_WAIT, CLOSE_WAIT 分析，属于哪一方？</h3><h3 id="TCP-建立连接过程-gt-SYN-ACK-包能不能拆开来发"><a href="#TCP-建立连接过程-gt-SYN-ACK-包能不能拆开来发" class="headerlink" title="TCP 建立连接过程 -&gt; SYN + ACK 包能不能拆开来发"></a>TCP 建立连接过程 -&gt; SYN + ACK 包能不能拆开来发</h3><h3 id="TCP-和-UDP-区别-gt-如何在-UDP-基础上保证可靠性"><a href="#TCP-和-UDP-区别-gt-如何在-UDP-基础上保证可靠性" class="headerlink" title="TCP 和 UDP 区别 -&gt; 如何在 UDP 基础上保证可靠性"></a>TCP 和 UDP 区别 -&gt; 如何在 UDP 基础上保证可靠性</h3><h3 id="TCP-流量控制和拥塞控制"><a href="#TCP-流量控制和拥塞控制" class="headerlink" title="TCP 流量控制和拥塞控制"></a>TCP 流量控制和拥塞控制</h3><h3 id="长连接和短链接"><a href="#长连接和短链接" class="headerlink" title="长连接和短链接"></a>长连接和短链接</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程间通信方式…-pipe-共享内存-socket-signal"><a href="#进程间通信方式…-pipe-共享内存-socket-signal" class="headerlink" title="进程间通信方式… pipe, 共享内存, socket, signal"></a>进程间通信方式… pipe, 共享内存, socket, signal</h3><h3 id="gt-哪几种常见的-signal-SIGSEGV…-gt-正常终止程序的信号？-gt-kill-进程，几号信号？"><a href="#gt-哪几种常见的-signal-SIGSEGV…-gt-正常终止程序的信号？-gt-kill-进程，几号信号？" class="headerlink" title="-&gt; 哪几种常见的 signal? SIGSEGV… -&gt; 正常终止程序的信号？-&gt; kill 进程，几号信号？"></a>-&gt; 哪几种常见的 signal? SIGSEGV… -&gt; 正常终止程序的信号？-&gt; kill 进程，几号信号？</h3><h3 id="select-和-epoll-区别"><a href="#select-和-epoll-区别" class="headerlink" title="select 和 epoll 区别"></a>select 和 epoll 区别</h3><h3 id="查看磁盘、cpu-占用、内存占用命令"><a href="#查看磁盘、cpu-占用、内存占用命令" class="headerlink" title="查看磁盘、cpu 占用、内存占用命令"></a>查看磁盘、cpu 占用、内存占用命令</h3><h3 id="gdb-使用-gt-多线程程序切换到某线程栈帧-gt-如何查看寄存器值"><a href="#gdb-使用-gt-多线程程序切换到某线程栈帧-gt-如何查看寄存器值" class="headerlink" title="gdb 使用 -&gt; 多线程程序切换到某线程栈帧 -&gt; 如何查看寄存器值"></a>gdb 使用 -&gt; 多线程程序切换到某线程栈帧 -&gt; 如何查看寄存器值</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="redis-基本数据结构…-zset-gt-zset-底层实现？-gt-skiplist-和-red-black-tree-对比？"><a href="#redis-基本数据结构…-zset-gt-zset-底层实现？-gt-skiplist-和-red-black-tree-对比？" class="headerlink" title="redis 基本数据结构… zset-&gt; zset 底层实现？-&gt; skiplist 和 red-black tree 对比？"></a>redis 基本数据结构… zset-&gt; zset 底层实现？-&gt; skiplist 和 red-black tree 对比？</h3><h3 id="项目存储相关-gt-哪些常见的存储引擎？rocksdb-gt-与-mysql-存储引擎对比？-gt-LSM-Tree-工作原理？"><a href="#项目存储相关-gt-哪些常见的存储引擎？rocksdb-gt-与-mysql-存储引擎对比？-gt-LSM-Tree-工作原理？" class="headerlink" title="项目存储相关 -&gt; 哪些常见的存储引擎？rocksdb-&gt; 与 mysql 存储引擎对比？-&gt; LSM Tree 工作原理？"></a>项目存储相关 -&gt; 哪些常见的存储引擎？rocksdb-&gt; 与 mysql 存储引擎对比？-&gt; LSM Tree 工作原理？</h3><h3 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql 存储引擎"></a>mysql 存储引擎</h3><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><h3 id="反转字符串数组"><a href="#反转字符串数组" class="headerlink" title="反转字符串数组"></a>反转字符串数组</h3><h3 id="两个栈实现队列。"><a href="#两个栈实现队列。" class="headerlink" title="两个栈实现队列。"></a>两个栈实现队列。</h3><h3 id="栈实现队列、"><a href="#栈实现队列、" class="headerlink" title="栈实现队列、"></a>栈实现队列、</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="一千五百万行数据如何快速找到某一行数据，给出方案，设计数据库表结构"><a href="#一千五百万行数据如何快速找到某一行数据，给出方案，设计数据库表结构" class="headerlink" title="一千五百万行数据如何快速找到某一行数据，给出方案，设计数据库表结构"></a>一千五百万行数据如何快速找到某一行数据，给出方案，设计数据库表结构</h3><p>井盖为什么是圆的</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云智</title>
      <link href="/p/d809ecd7.html"/>
      <url>/p/d809ecd7.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯云智"><a href="#腾讯云智" class="headerlink" title="腾讯云智"></a>腾讯云智</h1><p>不背面经一个实习都找不到！！！！！！！！！！！！！</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="怎么判断一个sql语句性能问题"><a href="#怎么判断一个sql语句性能问题" class="headerlink" title="怎么判断一个sql语句性能问题"></a>怎么判断一个sql语句性能问题</h3><p>可以通过慢日志查询：<br>慢日志全称为慢查询日志（Slow Query Log），主要用来记录在 MySQL 中执行时间超过指定时间的 SQL 语句。通过慢查询日志，可以查找出哪些语句的执行效率低，以便进行优化。</p><p>默认情况下，MySQL 并没有开启慢日志，可以通过修改 slow_query_log 参数来打开慢日志。与慢日志相关的参数介绍如下：</p><p>slow_query_log：是否启用慢查询日志，默认为0，可设置为0、1，1表示开启。<br>slow_query_log_file：指定慢查询日志位置及名称，默认值为host_name-slow.log，可指定绝对路径。<br>long_query_time：慢查询执行时间阈值，超过此时间会记录，默认为10，单位为s。<br>log_output：慢查询日志输出目标，默认为file，即输出到文件。<br>log_timestamps：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，建议改为 SYSTEM 系统时区。<br>log_queries_not_using_indexes：是否记录所有未使用索引的查询语句，默认为off。<br>min_examined_row_limit：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0。<br>log_slow_admin_statements：慢速管理语句是否写入慢日志中，管理语句包含 alter table、create index 等，默认为 off 即不写入。<br>一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。</p><p>查询到限制性能的mysql语句后我们可以采用Explain命令进行分析<br>Explain命令在解决数据库性能上是第一推荐使用命令，在 mysql 里被称作执行计划, 大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看 SQL 语句的执行效果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。</p><blockquote><p>Explain语法：explain select … from … [where …]</p></blockquote><p>例如：explain select * from news;</p><p>输出：</p><pre><code>+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+</code></pre><p>下面对各个属性进行了解：</p><ol><li><strong>id</strong>: SELECT查询的序列号</li><li><strong>select_type</strong>: select_type表示select的类型，可能取值如下：<ul><li>SIMPLE：简单SELECT（不使用UNION或子查询）</li><li>PRIMARY：最外层的SELECT查询</li><li>UNION：UNION中的第二个或后续的SELECT语句</li><li>DEPENDENT UNION：UNION中的第二个或后续的SELECT语句，取决于外部查询</li><li>UNION RESULT：UNION的结果</li><li>SUBQUERY：子查询中的第一个SELECT</li><li>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外部查询</li><li>DERIVED：派生表的SELECT（FROM子句的子查询）</li></ul></li><li><strong>table</strong>: 显示该行数据关联的表名</li><li><strong>type</strong>: 连接使用的方式和访问类型。常见取值及其意义：<ul><li>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</li><li>要达到range级别及以上才算较好，最好达到ref级别，否则可能存在性能问题</li></ul></li><li><strong>possible_keys</strong>: 列出MySQL可能使用的索引</li><li><strong>key</strong>: MySQL实际选择使用的键（索引）。若未使用索引，则为NULL</li><li><strong>key_len</strong>: MySQL选择使用的键的长度。若键为NULL，则长度为NULL。较短的键长度通常更好，前提是不损失精确性</li><li><strong>ref</strong>: 与key一起用于从表中选择行的列或常量</li><li><strong>rows</strong>: MySQL估计查询时必须检查的行数</li><li><strong>Extra</strong>: 包含MySQL解决查询的详细信息。常见取值及其解释：<ul><li>Distinct：一旦找到与行匹配的联接行，就不再搜索</li><li>Not exists：优化的LEFT JOIN，一旦找到与LEFT JOIN条件匹配的行，就不再搜索</li><li>Range checked for each record (index map:#)：没有找到理想的索引，对于每个来自前面表的行组合，MySQL检查使用哪个索引，并用它从表中返回行</li><li>Using filesort：查询可能需要优化。MySQL需要进行额外的步骤来确定如何对返回的行进行排序</li><li>Using index：列数据是从仅仅使用了索引中的信息而没有读取实际行的表返回的</li><li>Using temporary：查询需要优化。MySQL创建一个临时表来存储结果</li><li>Using where：使用WHERE从句来限制返回给用户的行。若不想返回表中的全部行且连接类型为ALL或index，可能存在问题</li></ul></li></ol><p>其中 type、key、rows、Extra 这几个字段比较重要:</p><ul><li>type 表示 mysql 访问数据的方式，常见的有全表扫描（all）、遍历索引（index）、区间查询（range）、常量或等值查询（ref、eq_ref）、主键等值查询（const）、当表中只有一条记录时（system）。下面是效率从最好到最差的一个排序。<br>  system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li><li>key 表示查询过程实际会用到的索引名称。</li><li>rows 表示查询过程中可能需要扫描的行数，这个数据不一定准确，是mysql 抽样统计的一个数据。</li><li>Extra 表示一些额外的信息，通常会显示是否使用了索引，是否需要排序，是否会用到临时表等。</li></ul><p>具体可以参照：<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490262&idx=1&sn=a67f610afa984ecca130a54a3be453ab&source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490262&amp;idx=1&amp;sn=a67f610afa984ecca130a54a3be453ab&amp;source=41#wechat_redirect</a></p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP粘包问题（原因）"><a href="#TCP粘包问题（原因）" class="headerlink" title="TCP粘包问题（原因）"></a>TCP粘包问题（原因）</h3><p>TCP 协议是流式协议。即协议的内容是像流水一样的字节流，内容与内容之间没有明确的分界标志，需要我们人为地去给这些协议划分边界。而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。<br>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。<br>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><p>对于粘包和拆包问题，常见的解决方案有四种：</p><ul><li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过自定义协议进行粘包和拆包的处理。</li></ul><h3 id="如果网络延迟会发生粘包吗"><a href="#如果网络延迟会发生粘包吗" class="headerlink" title="如果网络延迟会发生粘包吗"></a>如果网络延迟会发生粘包吗</h3><p>发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。</p><h3 id="UDP会出现粘包吗"><a href="#UDP会出现粘包吗" class="headerlink" title="UDP会出现粘包吗"></a>UDP会出现粘包吗</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。<br>对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了</p><h3 id="tcp网络编程说一下会用到哪几个函数"><a href="#tcp网络编程说一下会用到哪几个函数" class="headerlink" title="tcp网络编程说一下会用到哪几个函数"></a>tcp网络编程说一下会用到哪几个函数</h3><h3 id="UDP可以用bind绑定吗"><a href="#UDP可以用bind绑定吗" class="headerlink" title="UDP可以用bind绑定吗"></a>UDP可以用bind绑定吗</h3><p>可以，发送数据一般不需要bind。<br>对于接收数据端，一般在实际应用中都会指定接收XX端口的数据，所以接收数据一般使用bind。</p><h3 id="ARP协议的功能是什么？"><a href="#ARP协议的功能是什么？" class="headerlink" title="ARP协议的功能是什么？"></a>ARP协议的功能是什么？</h3><p>ARP协议的基本功能就是通过目标主机的IP地址，查询目标主机的MAC地址，以保证通信的顺利进行。</p><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="定时器-用什么数据结构：比如数组增删性能较差"><a href="#定时器-用什么数据结构：比如数组增删性能较差" class="headerlink" title="定时器 用什么数据结构：比如数组增删性能较差"></a>定时器 用什么数据结构：比如数组增删性能较差</h3><p>如果需要一个高效的定时器，可以考虑使用最小堆（min-heap）这样的数据结构。最小堆是一个完全二叉树，其中每个节点的值都小于或等于其子节点的值。在定时器中，可以将定时事件按照其触发时间作为键（key）来构建最小堆。这样，根节点就是最小的触发时间，可以快速找到最近要触发的事件。</p><p>使用最小堆的好处是，插入新的定时事件和删除最小事件的复杂度都是O(log n)，其中n是定时事件的数量。因此，无论定时事件的数量如何增减，都可以保持较高的性能。</p><p>相比之下，数组的插入和删除操作的性能较差，特别是在需要频繁地插入和删除元素的情况下。因为数组的插入和删除通常需要移动其他元素来保持连续性，这可能需要较多的时间。</p><h3 id="如果给你十万个高考生的高考成绩，你会选择用什么排序算法，为什么。"><a href="#如果给你十万个高考生的高考成绩，你会选择用什么排序算法，为什么。" class="headerlink" title="如果给你十万个高考生的高考成绩，你会选择用什么排序算法，为什么。"></a>如果给你十万个高考生的高考成绩，你会选择用什么排序算法，为什么。</h3><p>桶，成绩的取值范围是有限的且较小</p><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="1-n的数按字典序排序：写了暴力法-x2F-dfs法"><a href="#1-n的数按字典序排序：写了暴力法-x2F-dfs法" class="headerlink" title="1-n的数按字典序排序：写了暴力法&#x2F;dfs法"></a>1-n的数按字典序排序：写了暴力法&#x2F;dfs法</h3><h3 id="给一串数字加分割点，返回所有可能的IP地址：dfs写了半天，然后没怎么看别的都"><a href="#给一串数字加分割点，返回所有可能的IP地址：dfs写了半天，然后没怎么看别的都" class="headerlink" title="给一串数字加分割点，返回所有可能的IP地址：dfs写了半天，然后没怎么看别的都"></a>给一串数字加分割点，返回所有可能的IP地址：dfs写了半天，然后没怎么看别的都</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滴滴秋储</title>
      <link href="/p/bccf711e.html"/>
      <url>/p/bccf711e.html</url>
      
        <content type="html"><![CDATA[<h1 id="滴滴秋储"><a href="#滴滴秋储" class="headerlink" title="滴滴秋储"></a>滴滴秋储</h1><h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><h3 id="C-内存泄漏问题"><a href="#C-内存泄漏问题" class="headerlink" title="C++内存泄漏问题"></a>C++内存泄漏问题</h3><ul><li>在类的构造函数和析构函数中没有匹配的调用new和delete函数<ul><li>两种情况下会出现这种内存泄露：</li><li>在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；</li><li>在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存。</li></ul></li><li>没有正确地清除嵌套的对象指针</li><li>在释放对象数组时在delete中没有使用方括号</li><li>没有将基类的析构函数定义为虚函数</li></ul><h3 id="详细阐述堆栈的区别"><a href="#详细阐述堆栈的区别" class="headerlink" title="详细阐述堆栈的区别"></a>详细阐述堆栈的区别</h3><p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；<br>（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；<br>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。<br>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。<br>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。<br>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><h3 id="C-多线程并发问题（场景千万级数量级怎么处理）"><a href="#C-多线程并发问题（场景千万级数量级怎么处理）" class="headerlink" title="C++多线程并发问题（场景千万级数量级怎么处理）"></a>C++多线程并发问题（场景千万级数量级怎么处理）</h3><h3 id="承接上个，千万级数组如何求最大k个数？（用最小堆反之最大堆）"><a href="#承接上个，千万级数组如何求最大k个数？（用最小堆反之最大堆）" class="headerlink" title="承接上个，千万级数组如何求最大k个数？（用最小堆反之最大堆）"></a>承接上个，千万级数组如何求最大k个数？（用最小堆反之最大堆）</h3><p>对于千万级的数组求最大k个数，可以使用最小堆（Min-Heap）来解决。最小堆是一种数据结构，它可以维护一个固定大小的堆，保证堆中的元素始终按照升序排列，即堆顶元素是最小值。</p><p>以下是使用最小堆求最大k个数的一般步骤：</p><ul><li><p>创建一个大小为k的最小堆，并将数组的前k个元素放入堆中。</p></li><li><p>遍历数组的剩余元素（从第k+1个元素开始），依次与堆顶元素进行比较。</p><ul><li>a. 如果当前元素大于堆顶元素，则将堆顶元素替换为当前元素，并对堆进行调整（下沉操作）以维持堆的性质。</li><li>b. 如果当前元素小于或等于堆顶元素，则继续遍历下一个元素。</li></ul></li><li><p>遍历完数组后，最小堆中的k个元素即为最大的k个数。</p></li><li><p>最小堆的大小为k，因此在整个过程中，只需要维护k个元素的最小堆，而不需要对整个数组进行排序。这样可以大大减少内存占用和排序的时间复杂度。<br>需要注意的是，在实际编程中，可以使用优先队列（Priority Queue）来实现最小堆的功能，C++中的std::priority_queue就是一个很好的选择。通过设置比较函数为”大于”（greater）的方式，可以将优先队列变成最小堆。<br>下面是一个使用最小堆求最大k个数的示例代码（使用C++的STL）：</p><p>  #include <iostream><br>  #include <vector><br>  #include <queue></queue></vector></iostream></p><p>  std::vector<int> findTopK(const std::vector<int>&amp; nums, int k) {<br>  std::priority_queue&lt;int, std::vector<int>, std::greater<int>&gt; minHeap;<br><br>  for (int num : nums) {<br>      if (minHeap.size() &lt; k) {<br>          minHeap.push(num);<br>      } else if (num &gt; minHeap.top()) {<br>          minHeap.pop();<br>          minHeap.push(num);<br>      }<br>  }<br><br>  std::vector<int> result;<br>  while (!minHeap.empty()) {<br>      result.push_back(minHeap.top());<br>      minHeap.pop();<br>  }<br><br>  return result;<br>  }</int></int></int></int></int></p><p>  int main() {<br>  std::vector<int> nums &#x3D; {10, 4, 7, 2, 9, 5, 1, 3, 8, 6};<br>  int k &#x3D; 3;<br><br>  std::vector<int> topK &#x3D; findTopK(nums, k);<br><br>  std::cout &lt;&lt; “Top “ &lt;&lt; k &lt;&lt; “ numbers: “;<br>  for (int num : topK) {<br>      std::cout &lt;&lt; num &lt;&lt; “ “;<br>  }<br>  std::cout &lt;&lt; std::endl;<br><br>  return 0;<br>  }</int></int></p></li></ul><h3 id="承接上个，千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？"><a href="#承接上个，千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？" class="headerlink" title="承接上个，千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？"></a>承接上个，千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？</h3><p>如果要按照频率对千万级数据范围有限（0到1000）的重复元素进行排序，可以使用哈希表（Hash Table）和最大堆（Max-Heap）的结合来解决。</p><p>以下是一般的步骤：</p><ul><li>创建一个哈希表，用于统计每个元素的频率。哈希表的键为元素值，值为该元素出现的次数。</li><li>遍历数组，将每个元素的频率记录到哈希表中。</li><li>创建一个最大堆，并将哈希表中的元素按照频率加入堆中。堆中的元素可以用一个自定义的数据结构来表示，包括元素值和频率两个属性。</li><li>遍历最大堆，依次取出堆顶元素（频率最高的元素），并将其添加到结果数组中。如果有多个元素频率相同，则按照元素值的大小进行排序。</li><li>最终得到的结果数组即为按频率排序后的结果。</li></ul><p>以下是一个使用哈希表和最大堆排序元素频率的示例代码（使用C++的STL）：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;struct Element &#123;    int value;    int frequency;    Element(int v, int f) : value(v), frequency(f) &#123;&#125;    // 重载小于运算符，用于最大堆的排序    bool operator&lt;(const Element&amp; other) const &#123;        if (frequency == other.frequency) &#123;            return value &gt; other.value;        &#125;        return frequency &lt; other.frequency;    &#125;&#125;;std::vector&lt;int&gt; sortByFrequency(const std::vector&lt;int&gt;&amp; nums) &#123;    std::unordered_map&lt;int, int&gt; frequencyMap;    for (int num : nums) &#123;        frequencyMap[num]++;    &#125;    std::priority_queue&lt;Element&gt; maxHeap;    for (auto entry : frequencyMap) &#123;        maxHeap.push(Element(entry.first, entry.second));    &#125;    std::vector&lt;int&gt; result;    while (!maxHeap.empty()) &#123;        Element element = maxHeap.top();        maxHeap.pop();        for (int i = 0; i &lt; element.frequency; ++i) &#123;            result.push_back(element.value);        &#125;    &#125;    return result;&#125;int main() &#123;    std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 1&#125;;    std::vector&lt;int&gt; sortedByFrequency = sortByFrequency(nums);    std::cout &lt;&lt; &quot;Sorted by frequency: &quot;;    for (int num : sortedByFrequency) &#123;        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>在以上示例中，输入的数组包含了一些重复元素，通过使用哈希表统计元素频率，并使用最大堆对元素按频率排序，得到的结果数组即为按频率排序后的结果。注意，如果有多个元素频率相同，按照元素值的大小进行排序。</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="计算二叉树层高。"><a href="#计算二叉树层高。" class="headerlink" title="计算二叉树层高。"></a>计算二叉树层高。</h3><h3 id="给一个连续非空子数组，找它乘积最大的（动态规划）"><a href="#给一个连续非空子数组，找它乘积最大的（动态规划）" class="headerlink" title="给一个连续非空子数组，找它乘积最大的（动态规划）"></a>给一个连续非空子数组，找它乘积最大的（动态规划）</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket协议</title>
      <link href="/p/5447b09e.html"/>
      <url>/p/5447b09e.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>WebSocket协议是用于解决HTTP通信的无状态、短连接（通常是）和服务端无法主动向客户端推送数据等问题而开发的新型协议，其通信基础也基于 TCP。由于较旧的浏览器可能不支持WebSocket协议，所以使用WebSocket协议的通信双方在进行 TCP三次握手之后，还要额外地进行一次握手，这次参与握手的通信双方的报文格式是基于HTTP改造的。</p><h2 id="WebSocket协议的握手过程"><a href="#WebSocket协议的握手过程" class="headerlink" title="WebSocket协议的握手过程"></a>WebSocket协议的握手过程</h2><p>本节介绍WebSocket协议通信中的最后一次握手过程。最后一次握手开始后，一方向另外一方发送了一个HTTP格式的报文，这个报文的格式大致如下：</p><pre><code>GET /realtime HTTP/1.1Host: 127.0.0.1:9989Connection: UpgradePragma: no-cacheCache-Control: no-cacheUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)Upgrade: websocketOrigin: http://xyz.comSec-WebSocket-Version: 13Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN, zh;q=0.9, en;q=0.8Sec-WebSocket-Key: 1qeAodjyeDJuhGg2WkpKg-Sec-WebSocket-Extensions: permessage-deflater; client_max_window_bits</code></pre><p>对这个格式有如下要求：</p><ol><li>请求方法必须是 GET，且 HTTP 版本必须是 1.1。</li><li>握手必须是一个有效的HTTP请求</li><li>请求必须包含 Host 字段信息。</li><li>请求必须包含 Upgrade 字段信息，值必须为 websocket。</li><li>请求必须包含 Connection 字段信息，值必须为 Upgrade。</li><li>请求必须包含 Sec-WebSocket-Key 字段，该字段值是客户端的标识编码成 base64 格式后的内容。</li><li>请求必须包含 Sec-WebSocket-Version 字段信息，值必须是 13。</li><li>请求必须包含 Origin 字段。</li><li>请求可能包含 Sec-WebSocket-Protocol 字段来规定子协议。</li><li>请求可能包含 Sec-WebSocket-Extensions 字段来规定协议的扩展。</li><li>请求可能包含其他字段，如 cookie 等。</li></ol><p>对端在收到该数据包后如果支持WebSocket协议，则会回复一个HTTP格式的应答，这个应答报文的格式大致如下：<br>    HTTP&#x2F;1.1 101 Switching ProtocolslrinUpgrade: websocket<br>    connection: Upgrade<br>    Sec-NebSocket-Accept: 5wC5L6joP6t131zpj901CNv9Jy4<br>上面列出了应答报文中必须包含的几个字段和对应的值，即<br>Upgrade、Connection、Sec-WebSocket-Accept，注意：第1行必须是HTTP&#x2F;1.1 101 Switching Protocols\r\n。<br>对于Sec-WebSocket-Accept字段，其值是根据对端传过来的SecWebSocket-Key的值经过一定的算法计算出来的，这样应答的双方才能匹配。算法流程如下：</p><ul><li>将 Sec-WebSocket-Key 的值与固定的字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”拼接；</li><li>将拼接后的字符串进行SHA-1处理，然后将结果进行base64编码。</li></ul><p>算法公式如下：<br>    mask &#x3D; “258EAFA5-E914-47DA-95CA-C5ABODC85B11”;<br>    &#x2F;&#x2F;这是算法中要用到的固定字符串accept &#x3D; base64( shal( Sec-webSocket-Key +mask ));</p><h2 id="WebSocket协议的格式"><a href="#WebSocket协议的格式" class="headerlink" title="WebSocket协议的格式"></a>WebSocket协议的格式</h2><p>WebSocket协议除了上文提到的握手过程中使用的是HTTP数据格式，之后的通信双方使用的是另一种自定义格式。每个 WebSocket 数据包都被称为一个 Frame（帧），其格式如下<br><img src="https://s1.ax1x.com/2023/06/17/pCQO0gK.png" alt="pCQO0gK.png"></p><p>下面逐一介绍上文中各字段的含义。<br>第 1字节（上图中第 1个数字 0至第 1个数字 7）的内容如下。</p><ul><li>FIN 标志：占第 1 字节中的第 1 位（bit），即第 1 字节的最高位（1 字节含有 8位（bit）），该标志置 0 时表示当前包未结束，后续有该包的分片；置 1 时表示当前包已结束，后续无该包的分片。我们在解包时如果发现该标志为0，则需要将当前包的包体数据（即Payload Data）缓存起来，与后续的包分片组装在一起才是一个完整的包体数据。</li><li>RSV1、RSV2、RSV3：每个各占 1位，一共 3位，这 3位是保留字段（默认都是0），可以用它们作为通信双方协商好的一些特殊标志。</li><li>opCode：操作类型，占4位。目前的操作类型及其取值如下</li></ul><p>第2字节（上图中第1个数字8至第2个数字5）的内容如下。</p><ul><li>MASK标志：占1位（bit），该标志为1时，表明该Frame在包体长度字段后面携带4字节的masking-key信息，为0时则没有masking key信息。</li><li>Payload len：占7位，表示包体的长度信息。由于Payloadlen值使用了1字节的低 7位（7bit），因此其能表示的长度范围是 0～127，其中126和 127被当作特殊标志使用。当该字段值是 0～125时，表示跟在 masking-key 字段后面的就是包体内容长度；当该值是126时，接下来两字节的内容表示跟在masking-key字段后面的包体内容长度（即图中的Extended Payload Length）。由于两字节表示的最大无符号整数是0xFFFF（十进制是 65535，因此编译器提供了一个宏UINT16_MAX 来表示这个值）。如果包体长度超过65535，包长度就记录不下了，此时应该将Payload len设置为127，以使用更多的字节数<br>表示包体长度。当 Payload len 是 127 时，接下来用 8 字节的内容表示跟在 masking-key字段后面的包体内容长度（Extended PayloadLength）。总结起来，若Payload len在0～125之间，则ExtendedPayload Len不存在，即占0字节；若Payload len等于126，则Extended Payload Length占两字节；若Payload len等于127，则Extended Payload Length占8字节。另外，若 Payload len 等于 125或 126，则接下来存储实际包长信息分别使用两字节或 8字节，其值必须被转换为网络字节序（Big Endian）。</li><li>Masking-key：如果前面的mask标志被设置成1，则该字段存在，占4字节；反之，在Frame中不存在存储Masking-key字段的字节。另外，客户端（主动发起握手请求的一方）向服务端（被动接受握手的另一方）发送的frame信息（包信息）中的mask标志必须是1，而服务端向客户端发送的frame信息中的mask标志是0，客户端发送给服务端的数据帧中存在 4 字节的 masking-key，而服务端发送给客户端的数据帧中不存在Masking-key信息（笔者在Websocket协议的RFC文档中并没有看到有这种强行规定，在研究了一些Websocket库的实现后发现，此结论并不一定成立，客户端发送的数据也可能没有被设置mask标志）。如果存在Masking-key信息，则数据帧中的数据（图中的Payload Data）都是与Masking-key运算后的内容。无论是将原始数据与Masking-key运算后得到传输的数据，还是将传输的数据还原成原始数据，其算法都如下。</li></ul><p>分包的逻辑很简单：假设将一个包分成 3 个包片，那么应该将第 1 个和第 2个包片第1字节的第1位FIN设置为0，将OpCode设置为CONTINUATION_FRAME（也是0）；将第3个包片FIN设置为1，表示该包至此结束，将OpCode设置为想要的类型（如TEXT_FRAME、BINARY_FRAME等）。对端收到该包时，如果发现标志FIN&#x3D;0或OpCode&#x3D;0，则将该包包体的数据暂存起来，直到收到FIN&#x3D;1、OpCode≠0的包，将该包的数据与前面收到的数据放在一起，组装成一个完整的业务数据。示例代码如下：</p><pre><code>//某次解包后得到包体payloadData，根据FIN标志判断，//如果FIN= true，则说明一个完整的业务数据包已经收完整了1/调用processPackage函数处理该业务数据//否则暂存于m_strParsedData中//每次处理完一个完整的业务包数据，就将暂存区m_strParsedData中的数据清空if (FIN)&#123;    msLrParsedData.append (payloadData);    processPackage (m strParsedData) ;    mstrParsedData.clear ();&#125;else&#123;    m_strParsedData.append(payloadData);&#125;</code></pre><h2 id="WebSocket协议的压缩格式"><a href="#WebSocket协议的压缩格式" class="headerlink" title="WebSocket协议的压缩格式"></a>WebSocket协议的压缩格式</h2><p>WebSocket协议对于包体也支持压缩，是否需要开启压缩，需要通信双方在握手时进行协商。再看一下握手时主动发起一方的包内容：</p><pre><code>GET /realtime HTTP/1.1Host: 127.0.0.1:9989Connection: UpgradePragma: no-cacheCache-Control: no-cacheUser-Agent: Mozilla/5.0 (Windows NT 10.0; win64; x64)Upgrade: websocketOrigin: http://xyz.comSec-WebSocket-Version: 13Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Sec-WebSocket-Key: IgcAwodjyPDJuhGgzwkpKg--Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</code></pre><p>在该包中，在 Sec-WebSocket-Extensions 字段中有一个值permessage-deflate，这是Websocket数据包是否支持压缩功能的标志。如果发起方支持压缩功能，则在发起握手的数据包中添加该标志，若对端收到后也支持压缩功能，则在应答的包中也设置该标志；如果没有该标志，则表示不支持压缩。例如：</p><pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: 5wC5L6joP6t131zp901CNv9Jy4=Sec-WebSocket-Extensions: permessage-deflate; client_no_context_takeover</code></pre><p>如果双方都支持压缩，则此后通信包中的包体部分都是经过压缩的，反之是未经过压缩的。在解包得到包体（即Payload Data）后，如果握手时有压缩标志并且对方也回复了支持压缩，则需要对该包体进行解压缩；同理，在发送数据之前组装产生 WebSocket 包时，需要先对包体（即Payload Data）进行压缩<br>收包后解压缩的示例代码如下：</p><pre><code>bool MywebSocketSession::processPackage(const std::string&amp; data) &#123;    std::string out;    // 根据握手时确定的客户端是否支持压缩的标志位 mbclientcompressed 进行处理    if (mbclientcompressed) &#123;        // 解压缩        if (!Z1ibUtil::inflate(data, out)) &#123;            LOGE(&quot;uncompress failed, dataLength: %d&quot;, data.length());            return false;        &#125; else &#123;            out = data;        &#125;    &#125; else &#123;        out = data;    &#125;    LOGI(&quot;received data: %s&quot;, out.c_str());    return Process(out);&#125;</code></pre><p>对包进行压缩的算法如下：</p><pre><code>size_t dataLength = data.length();std::string destbuf;if (mbClientCompressed) &#123;    // 进行压缩    if (!Z1ibUtil::deflate(data, destbuf)) &#123;        LOGE(&quot;compress buf error, data: %s&quot;, data.c_str());        return;    &#125; else &#123;        destbuf = data;    &#125;&#125;LOGI(&quot;destbuf.length(): %d&quot;, destbuf.length());</code></pre><p>压缩和解压缩算法即gzip压缩算法。压缩和解压缩的函数为zlib库的deflate（压缩）和inflate（解压缩）函数，在使用 zlib 的 deflate 函数进行压缩时，压缩完毕后要将压缩后的字节流末尾多余的4字节删掉，这是因为deflate函数在压缩后会将内容为00 00 ff ff的特殊标志放入压缩后的缓冲区中，这个<br>标志不是我们需要的正文内容。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字编程</title>
      <link href="/p/1bcba982.html"/>
      <url>/p/1bcba982.html</url>
      
        <content type="html"><![CDATA[<h1 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 - Socket"></a>套接字 - Socket</h1><p>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）表示，区分不同应用程序进程间的网络通信和连接,主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。</p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>中国大陆一共有344514560个。占全球可用IPv4地址数量超过8%。<br>如果加上香港的12614144个，也仅仅是8.3%。<br><strong>查看IP</strong></p><pre><code># linux$ ifconfig# windows$ ipconfig# 测试网络是否畅通# 主机a: 192.168.1.11# 当前主机: 192.168.1.12$ ping 192.168.1.11     # 测试是否可用连接局域网$ ping www.baidu.com    # 测试是否可用连接外网# 特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的# 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</code></pre><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>在计算机的世界中有两种字节序</p><ul><li>大端字节序：高地址存低位，低地址存高位</li><li>小端字节序：低地址存低位，高地址存高位</li></ul><p>TCP&#x2F;IP协议规定，网络数据流应采用大端字节序，即低地址高字节。如果你的主机不是采用大端字节序就转为大端字节序在发送数据流时就回转换成大端字节序，如果你是大端字节序就不进行转换。我们使用的 PC 机，数据的存储默认使用的是小端。</p><pre><code>#include &lt;arpa/inet.h&gt;// u:unsigned// 16: 16位, 32:32位// h: host, 主机字节序// n: net, 网络字节序// s: short// l: int// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换// 将一个短整形从主机字节序 -&gt; 网络字节序uint16_t htons(uint16_t hostshort);// 将一个整形从主机字节序 -&gt; 网络字节序uint32_t htonl(uint32_t hostlong);// 将一个短整形从网络字节序 -&gt; 主机字节序uint16_t ntohs(uint16_t netshort)// 将一个整形从网络字节序 -&gt; 主机字节序uint32_t ntohl(uint32_t netlong);</code></pre><p>虽然 IP 地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述，下面的函数描述了如何将一个字符串类型的 IP 地址进行大小端转换：</p><pre><code>// 主机字节序的IP地址转换为网络字节序// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形int inet_pton(int af, const char *src, void *dst); </code></pre><p>参数:</p><pre><code>af: 地址族 (IP 地址的家族包括 ipv4 和 ipv6) 协议AF_INET: ipv4 格式的 ip 地址AF_INET6: ipv6 格式的 ip 地址src: 传入参数，对应要转换的点分十进制的 ip 地址: 192.168.1.100dst: 传出参数，函数调用完成，转换得到的大端整形 IP 被写入到这块内存中返回值：成功返回 1，失败返回 0 或者 - 1#include &lt;arpa/inet.h&gt;// 将大端的整形数, 转换为小端的点分十进制的IP地址        const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code></pre><p>参数:</p><pre><code>af: 地址族协议AF_INET: ipv4 格式的 ip 地址AF_INET6: ipv6 格式的 ip 地址src: 传入参数，这个指针指向的内存中存储了大端的整形 IP 地址dst: 传出参数，存储转换得到的小端的点分十进制的 IP 地址size: 修饰 dst 参数的，标记 dst 指向的内存中最多可以存储多少个字节</code></pre><p>返回值:</p><pre><code>成功：指针指向第三个参数对应的内存地址，通过返回值也可以直接取出转换得到的 IP 字符串失败: NULL</code></pre><p>还有一组函数也能进程 IP 地址大小端的转换，但是只能处理 ipv4 的 ip 地址：</p><pre><code>// 点分十进制IP -&gt; 大端整形in_addr_t inet_addr (const char *cp);// 大端整形 -&gt; 点分十进制IPchar* inet_ntoa(struct in_addr in);</code></pre><h2 id="Socket-的-2-种类型"><a href="#Socket-的-2-种类型" class="headerlink" title="Socket 的 2 种类型"></a>Socket 的 2 种类型</h2><p>Socket 是一个抽象概念，代表了通信双方的端点（Endpoint），通信双方通过Socket 发送或接收数据。<br>在 Winsock 里，用数据类型SOCKET 作为 Windows Sockets 对象的句柄，就好像一个窗口的句柄HWND、一个打开的文件的文件指针一样。下面我们会看到，在 Winsock API 的许多函数里，都会用到 SOCKET 类型的参数。</p><p>Socket 有 2 种类型：</p><ul><li>流类型（Stream Sockets）。<ul><li>流式套接字提供了一种可靠的、面向连接的数据传输方法，使用传输控制协议 TCP。</li></ul></li><li>数据报类型（Datagram Sockets）。<ul><li>数据报套接字提供了一种不可靠的、非连接的数据包传输方式，使用用户数据报协议 UDP。</li></ul></li></ul><h2 id="Socket-I-x2F-O-的-2-种模式"><a href="#Socket-I-x2F-O-的-2-种模式" class="headerlink" title="Socket I&#x2F;O 的 2 种模式"></a>Socket I&#x2F;O 的 2 种模式</h2><p>一个 SOCKET 句柄可以看成代表了一个 I&#x2F;O 设备。在 Windows Sockets 里，有 2 种 I&#x2F;O 模式：</p><ul><li>阻塞式 I&#x2F;O（blocking I&#x2F;O）<br>在阻塞方式下，收发数据的函数在调用后一直要到传送完毕或者出错才能完成，在阻塞期间，除了等待网络操作的完成不能进行任何操作。阻塞式 I&#x2F;O 是一个 Winsock API 函数的缺省行为。 </li><li>非阻塞式 I&#x2F;O（non-blocking I&#x2F;O）<br>对于非阻塞方式，Winsock API 函数被调用后立即返回；当网络操作完成后，由 Winsock 给应用程序发送消息（Socket Notifications）通知操作完成，这时应用程序可以根据发送的消息中的参数对消息做出响应。Winsock 提供了 2 种异步接受数据的方法：一种方法是使用 BSD 类型的函数 select（），另外一种方法是使用 Winsock 提供的专用函数WSAAsyncSelect（）。</li></ul><h2 id="套接字部分库函数列表"><a href="#套接字部分库函数列表" class="headerlink" title="套接字部分库函数列表"></a>套接字部分库函数列表</h2><h3 id="WSAStartup（）"><a href="#WSAStartup（）" class="headerlink" title="WSAStartup（）"></a>WSAStartup（）</h3><p>函数原型：</p><pre><code>int WSAStartup (WORD wVersionRequested,LPWSADATA lpWSAData);</code></pre><p>参数</p><pre><code>wVersionRequested[in] 表示欲使用的Windows Sockets API 版本；这是个WORD 类型的整数，高字节定义的是次版本号，低字节定义的是主版本号。lpWSAData[in] 指向 WSAData 资料的指针。WSAData 是结构数据类型，描述了关于 Windows Sockecs 底层实现的相关信息。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回如下错误代码：WSASYSNOTREADY：底层网络子系统没有准备好。WSAVERNOTSUPPORTED：Winsock 版本信息号不支持。WSAEINPROGRESS：阻塞式 Winsock1.1 存在于进程中。WSAEPROCLIM：已经达到 Winsock 使用量的上限。WSAEFAULT：lpWSAData 不是一个有效的指针。</code></pre><p>函数功能</p><pre><code>这个函数是应用程序应该第一个调用的 Winsock API 函数，以完成一系列初始化的工作。</code></pre><p>相关数据结构</p><pre><code>WSADATA 的定义如下：typedef struct WSAData &#123;     WORD wVersion;     WORD wHighVersion;    char   szDescription[WSADESCRIPTION_LEN+1];    char szSystemStatus[WSASYS_STATUS_LEN+1];     unsigned short iMaxSockets;    unsigned short   iMaxUdpDg;     char FAR *lpVendorInfo;&#125; WSADATA, FAR * LPWSADATA;</code></pre><p>其中，各结构成员的含义为:</p><pre><code>wVersion应用程序应该使用的 Winsock 版本号。wHighVersion DLL 所支持的最高版本号。通常应该等于 wVersion。 szDescription 以 0 结尾的 ASCII 字符串，关于 Winsock 底层实现的描述信息。szSystemStatus 以 0 结尾的 ASCII 字符串，关于 Winsock 底层状态或者配置信息。iMaxSockets 一个进程最多可使用的套接字数，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。iMaxUdpDg 最大的 UDP 报文大小，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。对于 Winsock 2.0，应该使用getsockopt函数取得 SO_MAX_MSG_SIZE。lpVendorInfo Winsock 开发厂商信息，，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。对于 Winsock 2.0，应该使用 getsockopt函数取得PVD_CONFIG。</code></pre><p>示例代码</p><pre><code>#include &lt;winsock.h&gt;//对于 Winsock 2, include &lt;winsock2.h&gt;WSADATA wsaData;int nRc = WSAStartup(0x0101, &amp; wsaData); if(nRc)&#123;    //Winsock 初始化错误    return;&#125;if(wsaData.wVersion != 0x0101)&#123;    //版本支持不够    //报告错误给用户，清除 Winsock，返回WSACleanup();    return;&#125;</code></pre><h3 id="socket（）"><a href="#socket（）" class="headerlink" title="socket（）"></a>socket（）</h3><p>函数原型</p><pre><code>SOCKET socket(int af, int type, int protocol);</code></pre><p>参数</p><pre><code>af[in] 指定地址族（address family），一般填AF_INET（使用 Internet 地址）。AF_INET(ipv6)type[in] 指定 SOCKET 的类型：SOCK_STREAM（流类型），SOCK_DGRAM（数据报类型）。protocol[in] 指定 af 参数指定的地址族所使用的具体一个协议。建议设为 0，那么它就会根据地址格式和 SOCKET 类型， 自动为你选择一个合适的协议。另外 2 个常用的值为：IPPROTO_UDP 和 IPPROTO_TCP。</code></pre><p>返回值</p><pre><code>函数执行成功返回一个新的 SOCKET，失败则返回 INVALID_SOCKET。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>所有的通信在建立之前都要创建一个 SOCKET。</code></pre><p>示例代码</p><pre><code>//创建数据报 socketSCOKET udpSock = socket(AF_INET,SOCK_DGRAM, IPPROTO_UDP);//创建流 socketSCOKET tcpSock = socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);</code></pre><h3 id="bind（）"><a href="#bind（）" class="headerlink" title="bind（）"></a>bind（）</h3><p>函数原型</p><pre><code>int bind(SOCKET sockfd, const struct sockaddr FAR* name, int namelen);</code></pre><p>参数</p><pre><code>sockfd[in] 一个需要绑定的SOCKET，例如用 socket 函数创建的 SOCKET。name[in] 指向描述通信对象地址信息的结构体 sockaddr 的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。namelen[in] name 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>成功地创建了一个 SOCKET 后，用bind 函数将SOCKET 和主机地址绑定。</code></pre><p>相关数据结构</p><pre><code>struct sockaddr &#123;    u_shortsa_family;    charsa_data[14];&#125;;sa_family地址族，比如AF_INET，2 个字节大小。sa_data用来存放地址和端口，14 个字节大小。</code></pre><p>sockaddr 结构是一个通用的结构（因为 Winsock 支持的协议族不只是TCP&#x2F;IP）。对 TCP&#x2F;IP 协议，用如下结构来定义地址和端口。</p><pre><code>typedef unsigned short  uint16_t;typedef unsigned int    uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;typedef unsigned short int sa_family_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))struct sockaddr_in &#123;    shortsin_family;    u_shortsin_port;     structin_addrsin_addr;     charsin_zero[8];&#125;;sin_family地址族，设为AF_INET。sin_port端口号。如果端口号为 0，Winsock 会自动为应用程序分配一个值在 1024-5000 间的一个端口号，所以客户端一般把 sin_port 设为 0。sin_addr为 in_addr 结构类型，用来指定 IP 地址。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。结构 in_addr 下面介绍。sin_zero8 字节的数组，值全为 0。这个 8 个字节用来填充结构sockaddr_in，使其大小等于结构 sockaddr（16 字节）。结构 in_addr 用来指定 IP 地址，其定义为：struct in_addr &#123;    union &#123;        struct &#123;             u_char s_b1,s_b2,s_b3,s_b4;        &#125; S_un_b;                 struct &#123;            u_short s_w1,s_w2;         &#125; S_un_w;                u_long S_addr;    &#125; S_un;&#125;;</code></pre><p>对于 IP 地址 10.14.25.90，sockaddr_in 结构中的 sin_addr 可以这样赋值：</p><pre><code>sin_addr. S_un .S_un_b. s_b1 = 10; sin_addr. S_un .S_un_b. s_b2 = 14; sin_addr. S_un .S_un_b. s_b3 = 25; sin_addr. S_un .S_un_b. s_b4 = 90;</code></pre><p>或者</p><pre><code>sin_addr. S_un . S_un_w. s_w1 = (14&lt;&lt;8)|10; sin_addr. S_un . S_un_w. s_w2 = (90&lt;&lt;8)|25;</code></pre><p>或者</p><pre><code>sin_addr. S_un . S_addr = (90&lt;&lt;24)|(25&lt;&lt;16)|(14&lt;&lt;8)|10;</code></pre><p>或者</p><pre><code>sin_addr. S_un . S_addr = inet_addr(“10.14.25.90”);</code></pre><p>这里的 inet_addr 函数可以将字符串形式的 IP 地址转换为 unsigned long 形式的值。</p><p>示例代码</p><pre><code>SOCKET sServSock; sockaddr_in addr;//创建 socketsServSock = socket(AF_INET, SOCK_STREAM, 0); addr.sin_family = AF_INET;//htons 和 htonl 函数把主机字节顺序转换为网络字节顺序，分别用于//短整型和长整型数据addr.sin_port = htons(5050); addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);// LPSOCKADDR 类型转换是必须的int nRc = bind(sServSock, (LPSOCKADDR)&amp;addr, sizeof(addr) );</code></pre><h3 id="listen（）"><a href="#listen（）" class="headerlink" title="listen（）"></a>listen（）</h3><p>函数原型</p><p>int listen (SOCKET s,int backlog);</p><p>参数</p><pre><code>s[in] 一个已经绑定但未连接的 SOCKET。backlog[in] 等待连接的队列的长度，可取 SOMAXCONN。如果某个客户程序要求连接的时候，服务器已经与其他客户程序连接，则后来的连接请求会放在等待队列中，等待服务器空闲时再与之连接。当等待队列达到最大长度（backlog 指定的值）时，再来的连接请求都将被拒绝。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>对于服务器的程序，当申请到 SOCKET,并将通信对象指定为INADDR_ANY 之后，就应该等待一个客户机的程序来要求连接，listen 函数就是把一个SOCKET 设置为这个状态。</code></pre><h3 id="accept（）"><a href="#accept（）" class="headerlink" title="accept（）"></a>accept（）</h3><p>函数原型</p><pre><code>SOCKET accept (SOCKET s, struct sockaddr FAR* addr,int FAR* addrlen );</code></pre><p>参数</p><pre><code>s[in] 一个已经处于listen 状态的 SOCKET。addr[out] 指向 sockaddr 结构体的指针，里面包含了客户端的地址和端 口。addrlen[out] int 型指针，指向的内容为 addr 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>如果函数执行成功，会建立并返回一个新的 SOCKET 来与对方通信，新建的 SOCKET 与原来的 SOCKET（函数的第一个参数 s）有相同的特性，包括端口号。原来的 SOCKET 继续等待其他的连接请求。而新生成的SOCKET 才是与客户端通信的实际 SOCKET。所以一般将参数中的 SOCKET 称作“监听”SOCKET，它只负责接受连接，不负责通话；而对于函数返回的 SOCKET，把它称作“会话”SOCKET，它负责与客户端通话。如果失败则返回 INVALID_SOCKET。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>accept 函数从等待连接的队列中取第一个连接请求，并且创建一个新的 SOCKET 来负责与客户端会话。</code></pre><p>示例代码</p><pre><code>SOCKET sServSock;//服务器监听 socket sockaddr_in addr;int nSockErr;int nNumConns = 0;//当前请求连接数SOCKET sConns[5];//会话 SOCKET 数组sockaddr ConnAddrs[5];//请求连接的客户端地址int nAddrLen;//创建服务器监听 socketsServSock = socket(AF_INET, SOCK_STREAM, 0);addr.sin_family = AF_INET; addr.sin_port = htons(5050);addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);if( bind(sServSock,(LPSOCKADDR)&amp;addr,sizeof(addr)) == SOCKET_ERROR )&#123;    nSockErr = WSAGetLastError();    //绑定出错处理&#125;//监听客户端请求连接if( listen(sServSock, 2)==SOCKET_ERROR)&#123;    nSockErr = WSAGetLastError();    //出错处理&#125;while( nNumConns &lt; 5)&#123;    //每当收到客户端连接请求，创建新的会话 SOCKET，保存在sConns 数组中    //客户端地址保存在 ConnAddrs 数组中    sConns[nNumConns] = accept(sServSock,ConnAddrs[nNumConns], &amp;nAddrLen);     if(sConns[nNumConns] == INVALID_SOCKET)    &#123;        nSockErr = WSAGetLastError();        //创建会话 SOCKET 出错处理    &#125;    else    &#123;        //创建会话 SOCKET 成功，启动新的线程与客户端会话        StartNewHandlerThread(sConns[nNumConns]);        //当前请求连接数+1         nNumConns ++;    &#125;&#125;</code></pre><h3 id="connect（）"><a href="#connect（）" class="headerlink" title="connect（）"></a>connect（）</h3><p>函数原型</p><pre><code>int connect (SOCKET s, const struct sockaddr FAR* name,intnamelen );</code></pre><p>参数</p><pre><code>s[in] 一个未连接SOCKET，一般是由 socket 函数建立的。name[in] 指向描述通信对象地址信息的结构体 sockaddr 的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。namelen[in] name 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>向对方主动提出连接请求。</code></pre><h3 id="send（）"><a href="#send（）" class="headerlink" title="send（）"></a>send（）</h3><p>函数原型</p><pre><code>int send (SOCKET s, char * buf, int len ,int flags);</code></pre><p>参数</p><pre><code>s[in] 一个已经连接的SOCKET。buf[in] 指向要传输的数据的缓冲区的指针。len[in] buf 的长度。flags[in]指定函数调用的方式。一般不使用，指定为0。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>通过已经连接的 SOCKET 发送数据。</code></pre><h3 id="recv（）"><a href="#recv（）" class="headerlink" title="recv（）"></a>recv（）</h3><p>函数原型</p><pre><code>int recv (SOCKET s, char * buf, int len ,int flags);</code></pre><p>参数</p><pre><code>s[in]   一个已经连接的SOCKET。buf[out] 指向接收数据的缓冲区的指针。len[in] buf 的长度。flags[in]指定函数调用的方式。一般不使用，指定为0。</code></pre><p>返回值</p><pre><code>函数执行成功返回接收到数据的字节数。如果失败则返回 SOCKET_ERROR。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>通过已经连接的 SOCKET 接收数据。当读到的数据字节少于规定接受的数目（len）时，就把数据全部接收，并返回实际接收到的字节数；当读到的数据多于规定的值时，在流方式下剩余的数据由下个 recv 读出，在数据报方式下多余的数据被丢弃。</code></pre><h3 id="sendto（）"><a href="#sendto（）" class="headerlink" title="sendto（）"></a>sendto（）</h3><p>函数原型</p><pre><code>int sendto (SOCKET s, char * buf, int len ,int flags,struct sockaddr_in * to, int tolen);</code></pre><p>参数</p><pre><code>s[in] 一个 SOCKET(可能已连接)。buf[in] 指向要传输的数据的缓冲区的指针。len[in] buf 的长度。flags[in] 指定函数调用的方式。一般取 0。to[in] 指向目标地址结构体的指针。tolen[in] 目标地址结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>该函数一般用于通过无连接的 SOCKET 发送数据报文，报文的接受者由 to 参数指定。</code></pre><h3 id="recvfrom（）"><a href="#recvfrom（）" class="headerlink" title="recvfrom（）"></a>recvfrom（）</h3><p>函数原型</p><pre><code>int recvfrom (SOCKET s, char * buf, int len ,int flags,struct sockaddr_in * from, int * fromlen);</code></pre><p>参数</p><pre><code>s[in] 一个已经绑定的SOCKET。buf[out] 指向接收数据的缓冲区的指针。len[in] buf 的长度。flags[in] 指定函数调用的方式。一般取 0。from[out] 指向源地址结构体的指针。fromlen[in/out] 源地址结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>该函数一般用于通过无连接的 SOCKET 接收数据报文，报文的发送者由 from 参数指定。</code></pre><h3 id="closesocket（）"><a href="#closesocket（）" class="headerlink" title="closesocket（）"></a>closesocket（）</h3><p>函数原型</p><pre><code>int closesocket (SOCKET s);</code></pre><p>参数</p><pre><code>s[in] 要关闭的 SOCKET。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>关闭指定的 SOCKET。</code></pre><h2 id="Winsock-2-0"><a href="#Winsock-2-0" class="headerlink" title="Winsock 2.0"></a>Winsock 2.0</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Winsock 1.1 原先设计的时候把API 限定在 TCP&#x2F;IP 的范畴里，它不象 Berkerly 模型那样支持多种协议。而 Winsock<br>2.0 正规化了一些其它的协议（如 ATM、IPX&#x2F;SPX 和DECNet 协议）的API。<br>Winsock 2.0 之所以能支持多种协议，是因为 Winsock 2.0 在 Windows Sockets DLL 和底层协议栈之间定义了一个<br>SPI（Service Provider Interface）接口，这样，通过一个 Windows Sockets DLL 可以同时访问底层不同厂商的协议栈。<br>Winsock 2.0 不仅允许多种协议栈的并存，而且从理论上讲，它还允许创造一个与网络协议无关的应用程序。Winsock<br>2.0 可以基于服务的需要透明地选择协议，应用程序可以适用于不同的网络名和网络地址。<br>Winsock 2.0 还扩展了它的API 函数集，当然 Winsock 2.0 是向下兼容的，可以把 Winsock 1.1 的代码原封不动地用在 Winsock 2.0 中。</p><h3 id="Winsock-2-0-新特性"><a href="#Winsock-2-0-新特性" class="headerlink" title="Winsock 2.0 新特性"></a>Winsock 2.0 新特性</h3><p>下面列出了一些 Winsock 2.0 的重要新特性：</p><ul><li>多重协议支持：SPI 接口使得新的协议可以被支持。</li><li>传输协议独立：根据服务提供不同的协议。</li><li>多重命名空间：根据需要的服务和解析的主机名选择协议。</li><li>分散和聚集： 从多个缓冲区接受和发送数据。</li><li>重叠 I&#x2F;O 和事件对象：增强吞吐量。</li><li>服务质量（Qos）：协商和跟踪网络带宽。</li><li>条件接受：可以选择性地决定是否接受连接。</li><li>Socket 共享：多个进程可以共享一个 SOKCKET 句柄。</li></ul><h3 id="Winsock-2-0-新增函数"><a href="#Winsock-2-0-新增函数" class="headerlink" title="Winsock 2.0 新增函数"></a>Winsock 2.0 新增函数</h3><p>下面列出了一些 Winsock 2.0 的重要新增函数：</p><ul><li><p>WSAAccept（）：accept（）函数的扩展版本，支持条件接受和套接字分组。</p></li><li><p>WASCloseEvent（）：释放一个时间对象。</p></li><li><p>WSAConnect（）：connect（）函数的扩展版本，支持连接数据交换和Qos 规范。</p></li><li><p>WSACreatEvent（）：创建一个事件对象。</p></li><li><p>WSADuplicateSocket（）：为一个共享套接字创建一个新的套接字。</p></li><li><p>WSAEnumNetworkEvents（）：检查是否有网络事件发生。</p></li><li><p>WSAEnumProtocols（）：得到每个可用的协议的信息。</p></li><li><p>WSAEventSelect（）：把一个网络事件和一个事件对象连接。</p></li><li><p>WSAGetOverlappedResu（）：得到重叠操作的完成状态。</p></li><li><p>WSAHtonl（）：htonl（）函数的扩展版本。</p></li><li><p>WSAHtons（）：htons（）函数的扩展版本。</p></li><li><p>WSAIoctl（）：ioctlsocket（）函数允许重叠操作的扩展版本。</p></li><li><p>WSANtohl（）：ntohl（）函数的扩展版本。</p></li><li><p>WSANtohs（）：ntohs（）函数的扩展版本。</p></li><li><p>WSARecv（）：recv（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSARecvDisconnect（）：终止套接字的接受操作。</p></li><li><p>WSARecvFrom（）：recvfrom（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSAResetEvent（）：重新初始化事件对象。</p></li><li><p>WSASend（）：send（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSARecvDisconnect（）：终止套接字的接受操作。</p></li><li><p>WSASendDisconnect（）：终止套接字的发送操作。</p></li><li><p>WSASendTo（）：sendto（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSASetEvent（）：设置事件对象。</p></li><li><p>WSASocket（）：socket（）函数的扩展版本。它以一个 PROTOCOL_INFO 结构作为输入参数，并且允许创建重叠套接字，还允许创建套接字组。</p></li><li><p>WSAWaitForMultipleEvents（）：阻塞多个事件对象。</p></li></ul><p>关于这些函数的具体细节，请查阅 MSDN。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>在 tcp 的服务器端，有两类文件描述符</p><ul><li>监听的文件描述符<ul><li>只需要有一个</li><li>不负责和客户端通信，负责检测客户端的连接请求，检测到之后调用 accept 就可以建立新的连接</li></ul></li><li>通信的文件描述符<ul><li>负责和建立连接的客户端通信</li><li>如果有 N 个客户端和服务器建立了新的连接，通信的文件描述符就有 N 个，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul><p>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</p><ul><li>读数据: 通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</li><li>写数据: 通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</li></ul><p>监听的文件描述符:</p><ul><li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据，说明有新的客户端连接</li><li>调用 accept () 函数，这个函数会检测监听文件描述符的读缓冲区</li><li>检测不到数据，该函数阻塞</li><li>如果检测到数据，解除阻塞，新的连接建立</li></ul><p>通信的文件描述符:</p><ul><li>客户端和服务器端都有通信的文件描述符</li><li>发送数据：调用函数 write () &#x2F;send ()，数据进入到内核中<ul><li>数据并没有被发送出去，而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据，内核会将数据发送到网络中</li></ul></li><li>接收数据：调用的函数 read () &#x2F;recv (), 从内核读数据<ul><li>数据如何进入到内核程序猿不需要处理，数据进入到通信的文件描述符的读缓冲区中</li><li>数据进入到内核，必须使用通信的文件描述符，将数据从读缓冲区中读出即可</li></ul></li></ul><p>服务器端代码示例：</p><pre><code>// server.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    // 1. 创建监听的套接字    //基于TCP 所以选择流式协议    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if(lfd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 将socket()返回值和本地的IP端口绑定到一起    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址    // 这个宏可以代表任意一个IP地址    // 这个宏一般用于本地的绑定操作    addr.sin_addr.s_addr = INADDR_ANY;  // 这个宏的值为0 == 0.0.0.0    //inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = bind(lfd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;bind&quot;);        exit(0);    &#125;    // 3. 设置监听    ret = listen(lfd, 128);    if(ret == -1)    &#123;        perror(&quot;listen&quot;);        exit(0);    &#125;    // 4. 阻塞等待并接受客户端连接    struct sockaddr_in cliaddr;    int clilen = sizeof(cliaddr);    int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;clilen);    if(cfd == -1)    &#123;        perror(&quot;accept&quot;);        exit(0);    &#125;    // 打印客户端的地址信息    char ip[24] = &#123;0&#125;;    printf(&quot;客户端的IP地址: %s, 端口: %d\n&quot;,        inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, sizeof(ip)),ntohs(cliaddr.sin_port));    // 5. 和客户端通信    while(1)    &#123;        // 接收数据        char buf[1024];        memset(buf, 0, sizeof(buf));        int len = read(cfd, buf, sizeof(buf));        if(len &gt; 0)        &#123;            printf(&quot;客户端say: %s\n&quot;, buf);            write(cfd, buf, len);        &#125;        else if(len  == 0)        &#123;            printf(&quot;客户端断开了连接...\n&quot;);            break;        &#125;        else        &#123;            perror(&quot;read&quot;);            break;        &#125;    &#125;    close(cfd);    close(lfd);    return 0;&#125;</code></pre><p>客户端代码示例：</p><pre><code>// client.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    // 1. 创建通信的套接字    int fd = socket(AF_INET, SOCK_STREAM, 0);    if(fd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 连接服务器    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;connect&quot;);        exit(0);    &#125;    // 3. 和服务器端通信    int number = 0;    while(1)    &#123;        // 发送数据        char buf[1024];        sprintf(buf, &quot;你好, 服务器...%d\n&quot;, number++);        write(fd, buf, strlen(buf)+1);                // 接收数据        memset(buf, 0, sizeof(buf));        int len = read(fd, buf, sizeof(buf));        if(len &gt; 0)        &#123;            printf(&quot;服务器say: %s\n&quot;, buf);        &#125;        else if(len  == 0)        &#123;            printf(&quot;服务器断开了连接...\n&quot;);            break;        &#125;        else        &#123;            perror(&quot;read&quot;);            break;        &#125;        sleep(1);   // 每隔1s发送一条数据    &#125;    close(fd);    return 0;&#125;</code></pre><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li>accept()：如果服务器端没有新客户端连接，阻塞当前进程 &#x2F; 线程，如果检测到新连接解除阻塞，建立连接</li><li>read()：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程 &#x2F; 线程，检测到数据解除阻塞，接收数据</li><li>write()：如果通信的套接字写缓冲区被写满了，阻塞当前进程 &#x2F; 线程（这种情况比较少见）<br>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用 accept() 函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被 accept() 阻塞就无法通信，被 read() 阻塞就无法和客户端建立新连接。</li></ul><p>因此得出一个结论，基于上述处理方式，在单线程 &#x2F; 单进程场景下，服务器是无法处理多连接的，解决方案也有很多：</p><ul><li>使用多线程实现</li><li>使用多进程实现</li><li>使用 IO 多路转接（复用）实现</li><li>使用 IO 多路转接 + 多线程实现</li></ul><p>多进程并发<br>如果要编写多进程版的并发服务器程序，首先要考虑，创建出的多个进程都是什么角色，这样就可以在程序中对号入座了。在 Tcp 服务器端一共有两个角色，分别是：监听和通信，监听是一个持续的动作，如果有新连接就建立连接，如果没有新连接就阻塞。关于通信是需要和多个客户端同时进行的，因此需要多个进程，这样才能达到互不影响的效果。进程也有两大类：父进程和子进程，通过分析我们可以这样分配进程：</p><p>父进程：</p><ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用 accept() 函数</li><li>创建子进程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子进程资源：子进程退出回收其内核 PCB 资源，防止出现僵尸进程</li><li>子进程：负责通信，基于父进程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。</li><li>发送数据：send() &#x2F; write()</li><li>接收数据：recv() &#x2F; read()</li></ul><p>在多进程版的服务器端程序中，多个进程是有血缘关系，对应有血缘关系的进程来说，还需要想明白他们有哪些资源是可以被继承的，哪些资源是独占的，以及一些其他细节：</p><ul><li>子进程是父进程的拷贝，在子进程的内核区 PCB 中，文件描述符也是可以被拷贝的，因此在父进程可以使用的文件描述符在子进程中也有一份，并且可以使用它们做和父进程一样的事情。</li><li>父子进程有用各自的独立的虚拟地址空间，因此所有的资源都是独占的</li><li>为了节省系统资源，对于只有在父进程才能用到的资源，可以在子进程中将其释放掉，父进程亦如此。</li><li>由于需要在父进程中做 accept() 操作，并且要释放子进程资源，如果想要更高效一下可以使用信号的方式处理</li></ul><p>服务器端代码示例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;// 信号处理函数void callback(int num)&#123;    while(1)    &#123;        pid_t pid = waitpid(-1, NULL, WNOHANG);        if(pid &lt;= 0)        &#123;            printf(&quot;子进程正在运行, 或者子进程被回收完毕了\n&quot;);            break;        &#125;        printf(&quot;child die, pid = %d\n&quot;, pid);    &#125;&#125;int childWork(int cfd);int main()&#123;    // 1. 创建监听的套接字    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if(lfd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 将socket()返回值和本地的IP端口绑定到一起    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址    // 这个宏可以代表任意一个IP地址    // 这个宏一般用于本地的绑定操作    addr.sin_addr.s_addr = INADDR_ANY;  // 这个宏的值为0 == 0.0.0.0    //    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = bind(lfd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;bind&quot;);        exit(0);    &#125;    // 3. 设置监听    ret = listen(lfd, 128);    if(ret == -1)    &#123;        perror(&quot;listen&quot;);        exit(0);    &#125;    // 注册信号的捕捉    struct sigaction act;    act.sa_flags = 0;    act.sa_handler = callback;    sigemptyset(&amp;act.sa_mask);    sigaction(SIGCHLD, &amp;act, NULL);    // 接受多个客户端连接, 对需要循环调用 accept    while(1)    &#123;        // 4. 阻塞等待并接受客户端连接        struct sockaddr_in cliaddr;        int clilen = sizeof(cliaddr);        int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;clilen);        if(cfd == -1)        &#123;            if(errno == EINTR)            &#123;                // accept调用被信号中断了, 解除阻塞, 返回了-1                // 重新调用一次accept                continue;            &#125;            perror(&quot;accept&quot;);            exit(0);        &#125;        // 打印客户端的地址信息        char ip[24] = &#123;0&#125;;        printf(&quot;客户端的IP地址: %s, 端口: %d\n&quot;,            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, sizeof(ip)),            ntohs(cliaddr.sin_port));        // 新的连接已经建立了, 创建子进程, 让子进程和这个客户端通信        pid_t pid = fork();        if(pid == 0)        &#123;            // 子进程 -&gt; 和客户端通信            // 通信的文件描述符cfd被拷贝到子进程中            // 子进程不负责监听            close(lfd);            while(1)            &#123;                int ret = childWork(cfd);                if(ret &lt;=0)                &#123;                    break;                &#125;            &#125;            // 退出子进程            close(cfd);            exit(0);        &#125;        else if(pid &gt; 0)        &#123;            // 父进程不和客户端通信            close(cfd);        &#125;    &#125;    return 0;&#125;// 5. 和客户端通信int childWork(int cfd)&#123;    // 接收数据    char buf[1024];    memset(buf, 0, sizeof(buf));    int len = read(cfd, buf, sizeof(buf));    if(len &gt; 0)    &#123;        printf(&quot;客户端say: %s\n&quot;, buf);        write(cfd, buf, len);    &#125;    else if(len  == 0)    &#123;        printf(&quot;客户端断开了连接...\n&quot;);    &#125;    else    &#123;        perror(&quot;read&quot;);    &#125;    return len;&#125;</code></pre><h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。根据多进程的处理思路，就可以这样设计了：</p><p><strong>主线程：</strong></p><ul><li><p>负责监听，处理客户端的连接请求，也就是在父进程中循环调用 accept() 函数</p></li><li><p>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</p></li><li><p>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响 accept()，直接做线程分离即可。<br><strong>子线程：</strong></p></li><li><p>负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。</p></li><li><p>发送数据：send() &#x2F; write()</p></li><li><p>接收数据：recv() &#x2F; read()<br>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，下面来分析一些其中的一些细节：</p></li><li><p>同一地址空间中的多个线程的栈空间是独占的</p></li><li><p>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此需要注意数据覆盖问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。</p></li></ul><p>代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;struct SockInfo&#123;    int fd;                      // 通信    pthread_t tid;               // 线程ID    struct sockaddr_in addr;     // 地址信息&#125;;struct SockInfo infos[128];void* working(void* arg)&#123;    while(1)    &#123;        struct SockInfo* info = (struct SockInfo*)arg;        // 接收数据        char buf[1024];        int ret = read(info-&gt;fd, buf, sizeof(buf));        if(ret == 0)        &#123;            printf(&quot;客户端已经关闭连接...\n&quot;);            info-&gt;fd = -1;            break;        &#125;        else if(ret == -1)        &#123;            printf(&quot;接收数据失败...\n&quot;);            info-&gt;fd = -1;            break;        &#125;        else        &#123;            write(info-&gt;fd, buf, strlen(buf)+1);        &#125;    &#125;    return NULL;&#125;</code></pre><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p><p><strong>注：</strong><br>本文参照了苏丙榅的博客 链接: <a href="https://subingwen.cn/linux/concurrence/#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91">https://subingwen.cn/linux/concurrence/#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91</a><br>以及华中科技大学计算机网络与通信实验指导书</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器开发中的常用模块设计</title>
      <link href="/p/73d6ffa7.html"/>
      <url>/p/73d6ffa7.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务器开发中的常用模块设计"><a href="#服务器开发中的常用模块设计" class="headerlink" title="服务器开发中的常用模块设计"></a>服务器开发中的常用模块设计</h1><h2 id="断线自动重连的应用场景和逻辑设计"><a href="#断线自动重连的应用场景和逻辑设计" class="headerlink" title="断线自动重连的应用场景和逻辑设计"></a>断线自动重连的应用场景和逻辑设计</h2><p>在有连接依赖关系的服务与服务之间或客户端与服务器之间，自动重连功能都是非常重要的功能。自动重连功能一般适用于以下4种场景。</p><ul><li>在一组服务之间，如果其中一些服务（主动连接方，以下简称A）需要与另一些服务（被动连接方，以下简称B）建立TCP长连接，而A没有自动连接B的功能，那么在部署或者测试这些服务时，必须先启动 B 再启动 A，因为一旦先启动 A，A 此时尝试连接B（由于B还没有启动）就会失败，之后A再也不会连接B了（即使B随后被启动），从而导致整个系统不能正常工作。</li><li>在部署或测试时，先启动 B再启动 A，A与 B之间的连接在运行期间可能由于网络波动等原因断开，整个系统不能再正常工作。</li><li>如果我们想升级 B，则更新完程序后重启 B 时也必须重启A。如果这种依赖链较长（例如 A连接 B，B连接 C，C连接 D，D连接E，等等），那么更新某个程序的效率会很低，更新成本非常高。</li><li>对于客户端软件来说，如果因为用户的网络短暂故障导致客户端与服务器失去连接，那么等网络恢复后，较好的用户体验是客户端检测到用户网络变化时自动与服务器重连，以便用户及时收到最新的消息。</li></ul><p>以上场景说明了断线自动重连机制的重要性，那么如何设计好的断线重连机制呢？<br>重连本身的功能开发很简单，其实就是调用套接字的connect函数不断重试，重试的技巧非常有讲究，如下所述。</p><ul><li>对于服务端程序，例如 A 连接 B，如果连接不上，整个系统则将无法工作。所以开发 A服务时，重连的逻辑可以很简单：A一旦发现与 B断开了连接，就立即尝试与B重新连接，如果连接不上，则隔一段时间再重试（一般设置为 3秒或5秒即可），一直到连接成功为止。当然，在此期间可以发送报警邮件或者输出错误日志，让开发人员或者运维人员尽快干预，尽快解决问题。</li><li>对于客户端软件，以上做法也是可以的，但不是最优的做法。客户端所处的网络环境比服务器程序所处的网络环境一般要恶劣得多，以相等的时间间隔定时重连，一般作用不大（例如用户拔掉了网线）。因此对于客户端软件，出现断线时会尝试去重连，如果连接不上，则会隔一个比前一次时间间隔更长的时间间隔去重连，例如这个时间间隔可以是2秒、4秒、8秒、16秒等。但是这样做也存在一个问题：随着重连次数的增加，重连的时间间隔会越来越大（也可以设置<br>一个最大的重连时间间隔，之后恢复到之前较小的时间间隔），如果在某个时刻网络连接已经恢复正常（例如用户重新插上网线），程序就需要等待一个很长的时间间隔（如16秒）才能恢复连接，用户体验同样不好。解决办法：如果网络发生波动，程序就应该检测网络状态，如果网络状态恢复正常，就应该立即进行一次重连，而不是一成不变地按照设置的时间间隔重连。</li></ul><p>操作系统提供了检测网络状态变化的 API 函数，例如对于Windows，可以使用IsNetworkAlive 函数去检测；对于 Android，在网络变化时会发送消息类型是WifiManager.NETWORK_STATE_CHANGED_ACTION的广播通知。还需要注意的是，如果客户端网络断开，那么应该在界面的某个地方显式地告诉用户当前的连接状态，并告诉用户当前正在进行断线重连，应该有一个可以让用户放弃断线重连或者立即进行一次断线重连的功能。<br>综上所述，服务器程序之间的重连可以被设计成等时间间隔的定时重连。对于客户端程序，要结合依次放大重连时间间隔、网络状态变化时立即重连或用户主动发起重连三个因素来设计。</p><p>1.不需要重连的情形<br>不需要重连的情形一般有：①用户使用客户端主动放弃重连；因为一些业务上的要求，禁止客户端重连。举个例子，如果某业务系统的账户在同一时刻不允许多个设备同时在线，某个账户在机器A上登录，接着又在机器B上登录，那么在机器A上登录的账户将被服务器踢下线，此时机器A上客户端的逻辑就应该被设计成禁止自动重连。<br>2.技术上的断线重连和业务上的断线重连<br>技术上的断线重连指的是调用connect函数连接。在实际开发中，大多数系统只实现技术上的重连成功（即connect连接成功）是没有任何意义的，在网络连接成功后，还需要再次向服务器发送账号验证信息等（如登录数据包），在这些信息验签成功后，才叫作真正的重连成功。这里说的发送账号验证信息并验签成功就是指业务上的重连成功。在复杂的系统中可能需要连续进行几个验签流程。因此，我们若想设计完备的断线重连机制，则不仅要考虑技术上的重连，还要考虑业务上的重连。</p><h2 id="保活机制与心跳包"><a href="#保活机制与心跳包" class="headerlink" title="保活机制与心跳包"></a>保活机制与心跳包</h2><p>在实际开发中，我们经常需要处理在下面两种情形中遇到的问题。</p><ul><li>情形一：在通常情况下，服务器与某个客户端一般不在同一个网络中，它们之间可能经过数个路由器和交换机，如果其中某个必经路由器或者交换器出现了故障，并且在一段时间内没有恢复，则会导致这之间的链路不再畅通，而此时服务器与客户端之间也没有数据进行交换。由于 TCP 连接是状态机，所以对于这种情形，无论是客户端还是服务器，都无法感知与对方的连接是否正常，我们一般称这类连接为“死链”。</li><li>情形二：一个客户端在连接服务器以后，如果长时间没有和服务器有数据来往，则可能会被防火墙程序关闭连接，有时我们并不想被关闭连接。例如，对于一个即时通信软件，服务器没有消息时，我们确实不会和服务器有任何数据交换，但是如果连接被关闭，有新的消息到来，我们就再也无法收到消息了，这就违背了“即时通信”的设计要求。</li></ul><p>对于情形一中的死链，只要我们此时在任意一端向对端发送一个数据包，即可检测链路是否正常，我们称这类数据包为“心跳包”，称这种操作为“心跳检测”。若一个连接长时间没有正常数据来往，也没有心跳包来往，就可以认为这个连接已不存在。为了节约服务器连接资源，可以通过关闭socket来回收连接资源。<br>情形二中的应用场景要求必须保持客户端与服务器之间的连接正常，这就是我们通常所说的“保活”。如上文所述，当服务器与客户端在一定时间内没有有效的业务数据来往时，我们只需向对端发送心跳包即可实现保活。根据上面的分析，这里再强调一下，心跳检测一般有两个作用：保活和检测死链。</p><h3 id="TCP-keepalive选项"><a href="#TCP-keepalive选项" class="headerlink" title="TCP keepalive选项"></a>TCP keepalive选项</h3><p>操作系统的TCP&#x2F;IP协议栈提供了keepalive选项用于socket的保活。在Linux上，我们可以通过代码启用一个 socket的心跳检测（即每隔一定的时间间隔就发送一个心跳检测包给对端）：</p><pre><code>//on为1时表示打开keepalive选项，为0时表示关闭,0是默认值int on=l;setsockopt(fd,SOL_SOCKET,SO_KEEPALIVE,6on,sizeof(on));</code></pre><p>但是，keepalive选项默认发送心跳检测数据包的时间间隔是7200 秒（两小时），时间间隔实在太长，即使开启它，也不具有实用性。<br>当然，我们可以通过继续设置 keepalive 相关的三个选项来改变这个时间间隔，它们分别是TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT，示例代码如下：</p><pre><code>// 发送keepalive报文的时间间隔int val = 7200;setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;val, sizeof(val));// 两次重试报文的时间间隔int interval = 75;setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;interval, sizeof(interval));int cnt = 9;setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;cnt, sizeof(cnt));</code></pre><p>TCP_KEEPIDLE选项设置了发送 keepalive 报文的时间间隔，发送时如果对端回复ACK，则本端TCP协议栈认为该连接依然存活，继续等7200秒后再发送keepalive报文；如果对端回复RESET，则说明对端进程已经重启，本端的应用程序应该关闭该连接。如果对端没有任何回复，则本端进行重试，如果重试9次<br>（TCP_KEEPCNT值）仍然不可达，前后重试的间隔为75秒（TCP_KEEPINTVL值），则向应用程序返回ETIMEOUT （无任何应答）或EHOST错误信息。<br>我们可以使用以下命令查看Linux上这3个值的设置情况：</p><pre><code>[ root@mycentos *]# sysetl -a | grep keepalivenet.ipv4.top_keepalive_intl=75net.ipv4.tep keepalive probes9net.ip4.tcp keepalive time = 7200</code></pre><p>在Windows上设置keepalive及设置对应选项的代码略有不同，示例代码如下：</p><pre><code>// 开启keepalive选项char on = 1;setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, &amp;on, sizeof(on));// 设置超时详细信息DWORD cbBytesReturned;tcp_keepalive klive;klive.onoff = 1; // 启用保活klive.keepalivetime = 7200; // 保活时间为7200秒klive.keepaliveinterval = 10000; // 重试间隔为10秒（注意单位是毫秒）WSAIoctl(socket, SIO_KEEPALIVE_VALS, &amp;klive, sizeof(tcp_keepalive), NULL, 0, &amp;cbBytesReturned, NULL, NULL);</code></pre><h3 id="应用层的心跳包机制设计"><a href="#应用层的心跳包机制设计" class="headerlink" title="应用层的心跳包机制设计"></a>应用层的心跳包机制设计</h3><p>我们在使用keepalive选项时，需要对每个连接中的socket进行设置，而这不一定是必需的，可能产生大量无意义的带宽浪费，而且keepalive选项不能与应用层很好地交互，因此在实际的服务开发中，还是建议在应用层设计自己的心跳包机制，如何设计呢？</p><p>从技术上来讲，心跳包其实就是一个预先规定好格式的数据包，在程序中启动一个定时器定时发送即可，这是最简单的实现思路。但是，若通信的两端有频繁的数据来往，什么时候到了下一个发心跳包的时间点，就什么时候发送一个心跳包，这其实是对流量的浪费。既然通信双方不断地有正常的业务数据包来往，那么这些数据包本身可以起到保活作用，为什么还要浪费流量发送这些心跳包呢？所以，对于用于保活的心跳包，最佳做法是记录最近一次收发数据包的时间，<br>在每次收数据和发数据时都更新这个时间。而心跳检测计时器在每次检测时都将这个时间与当前系统时间做比较，如果时间间隔大于允许的最大时间间隔（在实际开发中根据需求，将其设置成15～45秒不等），则发送一次心跳包。总而言之，就是在与对端之间没有数据来往达到一定时间间隔时，才发送一次心跳包。</p><p>发送心跳包的伪代码如下：</p><pre><code>bool CIUSocket::send()&#123;    int nSentBytes = 0;    int nRet = 0;    while (true)    &#123;        nRet = ::send(m_hSocket, m_strSendBuf.c_str(), m_strSendBuf.length(), 0);        if (nRet == SOCKET_ERROR)        &#123;            if (::WSAGetLastError() == WSAEWOULDBLOCK)                break;            else            &#123;                LOG_ERROR(&quot;Send data error, disconnect server: %s, port: %d.&quot;, m_strServer.c_str(), m_nPort);                Close();                return false;            &#125;        &#125;        else if (nRet &lt; 1)        &#123;            LOG_ERROR(&quot;Send data error, disconnect server: %s, port: %d.&quot;, m_strServer.c_str(), m_nPort);            Close();            return false;        &#125;        m_strSendBuf.erase(0, nRet);        if (m_strSendBuf.empty())            break;        Sleep(1);        // 记录最近一次发送数据包的时间        std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);        m_nLastDataTime = (long)time(NULL);    &#125;    return true;&#125;bool CIUSocket::Recv()&#123;    int nRet = 0;    char buffer[1024];    while (true)    &#123;        nRet = ::recv(m_hSocket, buffer, 1024, 0);        if (nRet == SOCKET_ERROR)        &#123;            if (::WSAGetLastError() == WSAEWOULDBLOCK)                break;            else            &#123;                LOG_ERROR(&quot;Recv data error, errorNO=%d.&quot;, ::WSAGetLastError());                Close();                return false;            &#125;        &#125;        else if (nRet &lt; 1)        &#123;            LOG_ERROR(&quot;Recv data error, errorNO=%ld.&quot;, ::WSAGetLastError());            Close();            return false;        &#125;        m_strRecvBuf.append(buffer, nRet);        Sleep(1);        std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);        // 记录最近一次收取数据包的时间        m_nLastDataTime = (long)time(NULL);    &#125;    return true;&#125;void CIUSocket::RecvThreadProc()&#123;    LOG_INFO(&quot;Recv data thread start...&quot;);    int nRet = 0;    while (!m_bStop)    &#123;        // 若检测到数据，则收数据        nRet = CheckReceivedData();        if (nRet == 1)        &#123;            // 有数据            if (!Recv())            &#123;                m_pRecvMsgThread-&gt;NotifyNetError();                continue;            &#125;            DecodePackages();        &#125;        else if (nRet == 0)        &#123;            // 无数据            long nLastDataTime = 0;            std::lock_guard&lt;std::mutex&gt; guard(m_mutexLastDataTime);            nLastDataTime = m_nLastDataTime;            if (m_nHeartbeatInterval &gt; 0)            &#123;                // 若当前系统时间与上一次收发数据包的时间间隔超过了m_nHeartbeatInterval                // 则发送一次心跳包                if ((long)time(NULL) - nLastDataTime &gt; m_nHeartbeatInterval)                    SendHeartbeatPackage();            &#125;        &#125;    &#125;    LOG_INFO(&quot;Recv data thread finish...&quot;);&#125;</code></pre><p>同理，检测心跳包的一端，应该是在与对端没有数据来往达到一定时间间隔时才做一次心跳检测。<br>做心跳检测的一端的伪代码如下：</p><p>一般是客户端主动向服务端发送心跳包，服务端做心跳检测来决定是否断开连接。从客户端的角度来说，客户端为了让自己得到服务端的正常服务，有必要主动和服务端保持正常的连接状态，而服务端不会局限于某个特定的客户端。如果客户端不能主动和其保持连接，就会主动回收与该客户端的连接。当然，服务端在收到客户端的心跳包时，应该给客户端一个心跳应答。</p><h3 id="有代理的心跳包机制设计"><a href="#有代理的心跳包机制设计" class="headerlink" title="有代理的心跳包机制设计"></a>有代理的心跳包机制设计</h3><p>前面设计了通用的心跳包机制，但是该机制在一种情况下不适用</p><p><img src="https://img1.imgtp.com/2023/06/17/vM7UkhZQ.png" alt="1687015197130.png"></p><p>在我们的服务程序与客户端之间存在代理服务时，后端服务与代理服务之间是长连接，代理服务与客户端之间也是长连接，且后端服务器的业务类型是订阅类型，也就是说客户端一旦订阅某个类型的主题，就很少或者不再向服务器发送消息了，而后端服务会不断地将客户端订阅的特定主题数据下发给客户端（如股票交易中的行情服务</p><p>如果后端服务更新心跳包时间戳时使用了最后一次的上行数据或者下行数据的发包时间，则可能无法检测到客户端是否已经断开。因为在某一时刻，客户端和代理服务之间的网络连接可能已经断开，但代理服务与后端服务之间的连接是正常的，这很常见。对于大多数企业应用，后端服务和代理服务一般位于同一个内网环境下，二者之间的网络状态通常很好。既然后端服务与代理服务之间的连接正常，那么后端服务的下行数据会一直畅通，但此时客户端与代理服务可能已经断开好一会儿了，由于后端服务通过下行数据更新了最后一次心跳时间，所以会导致心跳检测机制误判后端服务与客户端的连接状态。在这种情形下，如果分析后端服务日志，就会发现后端一直有正常发包记录，而从客户端日志（或者从客户端的表现）来看，客户端的这路连接早已断开，在断开的这段时间内已经收不到服务器的数据包了，示意图如下。</p><p><img src="https://img1.imgtp.com/2023/06/17/uL68pHwk.png" alt="1687015253484.png"></p><p>因此，我们应该将更新数据包的时间戳机制改为只通过后端服务的上行数据来统计，这样超过某段时间后若仍然没有上行数据，则说明客户端已经断开（在这段时间内，服务端既没有收到客户端的业务数据包，也没有收到客户端的心跳数据包）。</p><h3 id="带业务数据的心跳包"><a href="#带业务数据的心跳包" class="headerlink" title="带业务数据的心跳包"></a>带业务数据的心跳包</h3><p>上面介绍的心跳包是从纯技术角度来说的，在实际应用中，我们有时需要定时或者不定时地从服务端更新一些数据，我们可以把这类数据放在心跳包中，定时或者不定时更新。这类带业务数据的心跳包就不仅起到技术上的作用（保活和检测死链）了，也起到传递有效业务数据的作用，实现起来也很容易：在心跳包数据结构中加上需要的业务字段信息，然后在定时器中定时发送即可。</p><h3 id="心跳包与流量"><a href="#心跳包与流量" class="headerlink" title="心跳包与流量"></a>心跳包与流量</h3><p>在通常情况下，与服务端保持连接的多个客户端中，同一时间段的活跃用户（这里指的是与服务器有频繁数据往来的客户端）一般不会太多。当连接数较多时，进出服务器程序的数据包通常是心跳包（为了保活），所以为了减轻网络带宽的压力和节省流量，尤其是针对一些3G或4G手机应用，我们在设计心跳包数据格式时应该尽量减小心跳包的数据大小。</p><h3 id="心跳包与调试"><a href="#心跳包与调试" class="headerlink" title="心跳包与调试"></a>心跳包与调试</h3><p>如前文所述，对于心跳包，服务端的逻辑一般是在一定的时间间隔内没有收到客户端心跳包时主动断开连接。在开发和调试程序的过程中，我们可能需要将程序通过断点中断下来，这个过程可能是几秒到几十秒不等。等程序恢复执行时，连接可能因为心跳检测逻辑已经断开。在调试过程中，我们更多地关注业务数据处理逻辑是否正确，不想被一堆无意义的心跳包数据干扰。鉴于以上原因，我们一般在调试模式下通过配置开关变量或者条件编译选项关闭心跳包检测逻辑。代码示例如下。<br>（1）通过开关变量控制心跳包检测逻辑开启：</p><pre><code>if(config.heartbeatCheckEnabled)&#123;    EnableHearbeatcheck();&#125;</code></pre><p>（2）通过条件编译控制心跳包检测逻辑开启：<br>    &#x2F;&#x2F;这里设置了在非调试模式下才开启心跳包检测功能并<br>    #ifndef_DEBUG<br>        EnableHearbeatcheck();<br>    #endif</p><h3 id="心跳包与日志"><a href="#心跳包与日志" class="headerlink" title="心跳包与日志"></a>心跳包与日志</h3><p>在实际生产环境下，我们一般会将程序收到的和发出去的数据包写入日志中，但无业务信息的心跳包信息是个例外，一般会刻意地不将其写入日志中。这是因为心跳包数据一般较多，如果写入日志，则会导致日志文件变得很大，且充斥大量无意义的心跳包日志，所以一般在写日志时屏蔽心跳包信息的写入。这里的建议是，可以将心跳包信息是否写入日志做成一个配置开关，一般处于关闭状态，在需要时再开启。例如，对于一个WebSocket服务，ping和pong是心跳包数据，通过下面的示例代码可以按需输出心跳日志信息：</p><pre><code>void BusinessSession::send(std::string_view strResponse)&#123;    bool success = WebSocketSession::send(strResponse);    if (success)    &#123;        bool enablePingPongLog = Singleton&lt;Config&gt;::Instance().m_bPingPongLogEnabled;        // 对其他消息正常打印，对心跳消息则根据enablePingPongLog变量的值按需打印        if (strResponse != &quot;pong&quot; || enablePingPongLog)        &#123;            LOGI(&quot;Message sent to client [%s], sessionId: %s, clientId: %s, accountId: %s, frontId: %s, msg: %s&quot;,                getClientInfo(), m_strSessionId.c_str(), m_strClientId.c_str(),                m_strAccountId.c_str(), BusinessSession::m_strFrontId.c_str(),                strResponse.data());        &#125;    &#125;&#125;</code></pre><h2 id="日志模块的设计"><a href="#日志模块的设计" class="headerlink" title="日志模块的设计"></a>日志模块的设计</h2><p>日志模块是应用程序的一个重要组件</p><h3 id="为什么需要日志"><a href="#为什么需要日志" class="headerlink" title="为什么需要日志"></a>为什么需要日志</h3><p>对于生产环境下的服务器或者产品，一般不允许开发人员直接调用调试器排查问题，这时，我们可以通过打印日志，将当时的程序行为上下文现场记录下来，然后从日志系统中找到某次不正常的行为的上下文信息。<br>本节将从技术和业务两个方面来介绍日志系统相关的设计与开发，即：如何从程序开发角度设计一款功能强大、性能优越、使用方便的日志系统；使用日志系统时应该记录哪些行为和数据，以做到既简洁、不啰嗦，又能方便、快捷地定位问题。</p><h3 id="日志系统的技术实现"><a href="#日志系统的技术实现" class="headerlink" title="日志系统的技术实现"></a>日志系统的技术实现</h3><p>日志的最初原型是将程序运行的状态打印出来，对于C&#x2F;C++来说，就是利用printf、std：：cout等控制台输出函数，将日志信息输出到控制台。<br>对于商业项目，为了方便排查问题，我们一般不将日志输出到控制台，而是输出到文件或者数据库系统中。不管输出到哪里，其基本思路都是相同的，这里以写文件为例进行详细介绍。<br>1.同步写日志<br>同步写日志指在输出日志的地方将日志即时写入文件中，被广泛应用于相当多的客户端软件中。之所以使用这种方式，主要是因为它设计简单而且不影响使用体验。有的读者可能会有顾虑：客户端软件一般存在于界面上，而界面部分所属的逻辑就是程序的主线程，如果采用这种同步写日志方式，若写日志时的写文件是磁盘 I&#x2F;O 操作，其他部分是 CPU操作，则前者要慢很多，势必造成 CPU等待且主线程卡在写文件处，使界面卡顿，使用体验不好。这种顾虑确实是存在的，但是我们一般不用担心，主要有两个原因</p><ul><li>对于客户端程序，即使在主线程（UI线程）中同步写文件，其单次或者几次磁盘操作累加时间，与人（用户）的可感知时间相比，也是非常小的，也就是说用户根本感觉不到这种同步写文件造成的延迟。当然，如果在UI线程里面写日志，尤其是在一些高频操作中（如Windows的界面绘制消息 WM_PAINT处理逻辑中），一定要控制写日志的长度和次数，否则会因为频繁写文件或一次写入数据过多造成界面卡顿。</li><li>客户端程序除了 UI线程，还有与界面无关的其他工作线程，在这些线程中直接写文件一般不会对使用体验产生影响。</li></ul><p>下面给一个具体的例子。<br>日志类的.h文件：</p><pre><code>#ifndef LOG_H#define LOG_Henum LOG_LEVEL&#123;    LOG_LEVEL_INFO,    LOG_LEVEL_WARNING,    LOG_LEVEL_ERROR&#125;;#define LOG_INFO(...) CIULog::Log(LOG_LEVEL_INFO, __FUNCSIG__, __LINE__, __VA_ARGS__)#define LOG_WARNING(...) CIULog::Log(LOG_LEVEL_WARNING, __FUNCSIG__, __LINE__, __VA_ARGS__)#define LOG_ERROR(...) CIULog::Log(LOG_LEVEL_ERROR, __FUNCSIG__, __LINE__, __VA_ARGS__)class CIULog&#123;public:    static bool Init(bool bToFile, bool bTruncateLongLog, LPCTSTR pszLogFileName);    static void Uninit();    static void setLevel(LOG_LEVEL nLevel);    static bool Log(LOG_LEVEL nLevel, LPCTSTR pszFmt, ...);    static bool Log(LOG_LEVEL nLevel, PCSTR pszFunctionSig, int nLineNo, LPCTSTR pszFmt, ...);    static bool Log(LOG_LEVEL nLevel, PCSTR pszFunctionSig, int nLineNo, PCSTR pszFmt, ...);private:    CIULog();    ~CIULog();    CIULog(const CIULog&amp; rhs);    CIULog&amp; operator=(const CIULog&amp; rhs);    static void GetTime(char* pszTime, int nTimeStrLength);private:    static bool m_bToFile;    static HANDLE m_hLogFile;    static bool m_bTruncateLongLog;    static LOG_LEVEL m_nLogLevel;&#125;;#endif // LOG_H</code></pre><p>日志的cpp文件如下:</p><pre><code class="cpp">#include &quot;stdafx.h&quot;#include &quot;1ULog.h&quot;#include &quot;EncodingUti1.h&quot;#include &lt;tchar.h&gt;#ifndef LOG_OUTPUT#define LOG_OUTPUT#endif#define MAX_LINE_LENGTH 256bool CIULog::m_bToFile = false;bool CIULog::m_bTruncateLongLog = false;HANDLE CIULog::m_hLogFile = INVALID_HANDLE_VALUE;LOG_LEVEL CIULog::m_nLogLevel = LOG_LEVEL_INFO;bool CIULog::Init(bool bToFile, bool bTruncateLongLog, PCTSTR pszLogFileName)&#123;#ifdef LOG_OUTPUT    m_bToFile = bToFile;    m_bTruncateLongLog = bTruncateLongLog;    if (pszLogFileName == NULL || pszLogFileName[0] == NULL)        return false;    TCHAR szHomePath[MAX_PATH] = &#123; 0 &#125;;    GetModuleFileName(NULL, szHomePath, MAX_PATH);    for (int i = _tcslen(szHomePath); i &gt;= 0; --i)    &#123;        if (szHomePath[i] == _T(&#39;\\&#39;))        &#123;            szHomePath[i] = _T(&#39;\0&#39;);            break;        &#125;    &#125;    TCHAR szLogDirectory[MAX_PATH] = &#123; 0 &#125;;    _stprintf_s(szLogDirectory, _T(&quot;%s\\Logs&quot;), szHomePath);    DWORD dwAttr = ::GetFileAttributes(szLogDirectory);    if (!((dwAttr != 0xFFFFFFFF) &amp;&amp; (dwAttr &amp; FILE_ATTRIBUTE_DIRECTORY)))    &#123;        TCHAR cPath[MAX_PATH] = &#123; 0 &#125;;        TCHAR cTmpPath[MAX_PATH] = &#123; 0 &#125;;        TCHAR* lpPos = NULL;        _tcscpy_s(cPath, szLogDirectory);        lpPos = _tcschr(cPath, _T(&#39;\\&#39;));        while (lpPos != NULL)        &#123;            if (lpPos == cPath)            &#123;                lpPos++;            &#125;            else            &#123;                TCHAR cTmp = *lpPos;                *lpPos = _T(&#39;\0&#39;);                _tcsncpy_s(cTmpPath, cPath, MAX_PATH);                ::CreateDirectory(cTmpPath, NULL);                *lpPos = cTmp;            &#125;            lpPos = _tcschr(lpPos, _T(&#39;\\&#39;));        &#125;    &#125;    TCHAR szLogFilePath[MAX_PATH];    _stprintf_s(szLogFilePath, _T(&quot;%s\\%s&quot;), szLogDirectory, pszLogFileName);    m_hLogFile = ::CreateFile(szLogFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);    if (m_hLogFile == INVALID_HANDLE_VALUE)        return false;#endif // end LOG_OUTPUT    return true;&#125;void CIULog::Uninit()&#123;#ifdef LOG_OUTPUT    if (m_hLogFile != INVALID_HANDLE_VALUE)    &#123;        ::CloseHandle(m_hLogFile);        m_hLogFile = INVALID_HANDLE_VALUE;    &#125;#endif // end LOG_OUTPUT&#125;void CIULog::SetLevel(LOG_LEVEL nLevel)&#123;    m_nLogLevel = nLevel;&#125;bool CIULog::Log(long nLevel, PCTSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime, ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[WARNING]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[ERROR]&quot;;    strDebugInfo += strLevel;    // Current thread information    char szThreadID[32] = &#123; 0 &#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %lu]&quot;, dwThreadID);    strDebugInfo += szThreadID;    // Log message    std::wstring strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vsctprintf(pszFmt, ap); // Capacity must include the trailing null character    if (nLogMsgLength &gt; 0)    &#123;        strLogMsg.resize(nLogMsgLength + 1);        _vstprintf_s((TCHAR*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    &#125;    va_end(ap);    // Correct the length if the string content is correct but the length is not    strLogMsg.resize(wcslen(strLogMsg.c_str()));    // If truncation is enabled, take only the first MAX_LINE_LENGTH characters of long log messages    if (m_bTruncateLongLog &amp;&amp; strLogMsg.length() &gt; MAX_LINE_LENGTH)        strLogMsg = strLogMsg.substr(0, MAX_LINE_LENGTH);    std::string strLogMsgAscii;    strLogMsgAscii = EncodingUtil::UnicodeToAnsi(strLogMsg);    strDebugInfo += strLogMsgAscii;    strDebugInfo += &quot;\r\n&quot;;    if (m_bToFile)    &#123;        if (m_hLogFile == INVALID_HANDLE_VALUE)            return false;        SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;        ::WriteFile(m_hLogFile, strDebugInfo.c_str(), strDebugInfo.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);    &#125;    OutputDebugStringA(strDebugInfo.c_str());#endif // end LOG_OUTPUT    return true;&#125;bool CIULog::Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCTSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    // Time    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime, ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    // Error level    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[WARNING]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[ERROR]&quot;;    strDebugInfo += strLevel;    // Current thread information    char szThreadID[32] = &#123; 0 &#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %lu]&quot;, dwThreadID);    strDebugInfo += szThreadID;    // Function signature    char szFuncsig[512] = &#123; 0 &#125;;    sprintf_s(szFuncsig, ARRAYSIZE(szFuncsig), &quot;[%s:%d]&quot;, pszFunctionSig, nLineNo);    strDebugInfo += szFuncsig;    // Log message    std::wstring strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vscwprintf(pszFmt, ap); // Capacity must include the trailing null character    if (nLogMsgLength &gt; 0)    &#123;        strLogMsg.resize(nLogMsgLength + 1);        _vstprintf_s((TCHAR*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    &#125;    va_end(ap);    // Correct the length if the string content is correct but the length is not    strLogMsg.resize(wcslen(strLogMsg.c_str()));    // If truncation is enabled, take only the first MAX_LINE_LENGTH characters of long log messages    if (m_bTruncateLongLog &amp;&amp; strLogMsg.length() &gt; MAX_LINE_LENGTH)        strLogMsg = strLogMsg.substr(0, MAX_LINE_LENGTH);    std::string strLogMsgAscii;    strLogMsgAscii = EncodingUtil::UnicodeToAnsi(strLogMsg);    strDebugInfo += strLogMsgAscii;    strDebugInfo += &quot;\r\n&quot;;    if (m_bToFile)    &#123;        if (m_hLogFile == INVALID_HANDLE_VALUE)            return false;        SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;        ::WriteFile(m_hLogFile, strDebugInfo.c_str(), strDebugInfo.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);    &#125;    OutputDebugStringA(strDebugInfo.c_str());#endif // end LOG_OUTPUT    return true;&#125;bool CTOLog::Log(long nLevel, PCSTR pszFunctionSig, int nLineNo, PCSTR pszFmt, ...)&#123;#ifdef LOG_OUTPUT    if (nLevel &lt; m_nLogLevel)        return false;    // Time    char szTime[64] = &#123; 0 &#125;;    GetTime(szTime, ARRAYSIZE(szTime));    std::string strDebugInfo(szTime);    // Error level    std::string strLevel(&quot;[INFO]&quot;);    if (nLevel == LOG_LEVEL_WARNING)        strLevel = &quot;[WARNING]&quot;;    else if (nLevel == LOG_LEVEL_ERROR)        strLevel = &quot;[ERROR]&quot;;    strDebugInfo += strLevel;    // Current thread information    char szThreadID[32] = &#123; 0 &#125;;    DWORD dwThreadID = ::GetCurrentThreadId();    sprintf_s(szThreadID, ARRAYSIZE(szThreadID), &quot;[ThreadID: %lu]&quot;, dwThreadID);    strDebugInfo += szThreadID;    // Function signature    char szFuncSig[512] = &#123; 0 &#125;;    sprintf_s(szFuncSig, ARRAYSIZE(szFuncSig), &quot;[%s:%d]&quot;, pszFunctionSig, nLineNo);    strDebugInfo += szFuncSig;    // Log message    std::string strLogMsg;    va_list ap;    va_start(ap, pszFmt);    int nLogMsgLength = _vscprintf(pszFmt, ap); // Capacity must include the trailing null character    if (nLogMsgLength &gt; 0)    &#123;        strLogMsg.resize(nLogMsgLength + 1);        vsprintf_s((char*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, ap);    &#125;    va_end(ap);    // Correct the length if the string content is correct but the length is not    strLogMsg.resize(strlen(strLogMsg.c_str()));    // If truncation is enabled, take only the first MAX_LINE_LENGTH characters of long log messages    if (m_bTruncateLongLog &amp;&amp; strLogMsg.length() &gt; MAX_LINE_LENGTH)        strLogMsg = strLogMsg.substr(0, MAX_LINE_LENGTH);    std::string strDebugInfoMsg = strDebugInfo + strLogMsg + &quot;\r\n&quot;;    if (m_bToFile)    &#123;        if (m_hLogFile == INVALID_HANDLE_VALUE)            return false;        ::SetFilePointer(m_hLogFile, 0, NULL, FILE_END);        DWORD dwBytesWritten = 0;        ::WriteFile(m_hLogFile, strDebugInfoMsg.c_str(), strDebugInfoMsg.length(), &amp;dwBytesWritten, NULL);        ::FlushFileBuffers(m_hLogFile);    &#125;    ::OutputDebugStringA(strDebugInfoMsg.c_str());#endif // end LOG_OUTPUT    return true;&#125;void CIULog::GetTime(char* pszTime, int nTimeStrLength)&#123;    SYSTEMTIME st = &#123; 0 &#125;;    ::GetLocalTime(&amp;st);    sprintf_s(pszTime, nTimeStrLength, &quot;[%04d-%02d-%02d %02d:%02d:%02d:%03d]&quot;,        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);&#125;</code></pre><p>在以上代码中根据日志级别定义了3个宏：LOG_INFO、LOG_WARNING、LOG_ERROR，要使用该日志模块，则只需在程序启动处调用CIULog：：Init函数初始化日志：</p><pre><code>SYSTEMTIME st = &#123; 0 &#125;;::GetLocalTime(&amp;st);TCHAR szLogFileName[MAX_PATH] = &#123; 0 &#125;;_stprintf_s(szLogFileName, MAX_PATH, _T(&quot;%s\\Logs\\V%04d%02d%02d%02d%02d%02d.log&quot;), g_SzHomePath, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);CIULog::Init(true, false, szLogFileName);</code></pre><p>当然，最佳做法是在程序退出处调用CIULog：：Uninit回收日志模块相关的资源：</p><pre><code>CIULog::Uninit();</code></pre><p>做好这些准备工作以后，如果想在程序的某个地方写一条日志，则只需这样写：</p><pre><code>// Print an INFO-level logLOG_INFO(&quot;Request login: Account=%s, Password=%s, Status=%ld, LoginType=%d.&quot;, pLoginRequest-&gt;m_szAccountName, pLoginRequest-&gt;m_szPassword, pLoginRequest-&gt;m_nStatus, (long)pLoginRequest-&gt;m_nLoginType);// Print a WARNING-level logLOG_WARNING(&quot;Some warning...&quot;);// Print an ERROR-level logLOG_ERROR(&quot;Received data error, errorNO=%d.&quot;, GetLastError());</code></pre><p>出现的问题一<br>从上面的日志输出来看，这种同步的日志输出方式也存在时间顺序不正确的问题（时间戳大的日志比时间戳小的日志靠前）。这是由于多线程同时写日志到同一个文件时，产生日志的时间和实际写入磁盘的时间不是一个原子操作。下图展示了该问题出现的根源。</p><p><img src="https://img1.imgtp.com/2023/06/18/LrgtJTL3.png" alt="1687017718178.png"></p><p>好在这种时间顺序不正确的问题只出现在不同的线程之间，对于同一个线程的不同时间的日志记录顺序肯定是正确的，所以并不影响我们使用日志。<br>2）出现的问题二<br>多个线程同时将日志写入同一个日志文件中还存在一个问题，就是假设线程 A 在某个时刻向日志文件中追加的内容为“AAAAA”，线程 B 在同一时刻向日志文件中追加的内容为“BBBBB”，线程C在同一时刻向日志文件中追加的内容为“CCCCC”，那么最终的日志文件中的内容会不会出现“AABBCCABCAACCBB”这种格式呢？在类UNIX系统上（包括Linux），同一个进程内针对同一个FILE<em>的操作是线程安全的，也就是说，在这类操作系统上得到的日志结果A、B、C的各个字母组一定是连续的，最终得到的日志内容可能是“AAAAACCCCCBBBBB”或“AAAAABBBBBCCCCC”等连续格式，绝不会出现A、B、C字母交错的现象。<br>而在Windows上，对FILE</em>的操作并不是线程安全的。这种同步日志的实现方式，一般用于低频写日志的软件系统中（如客户端软件），所以可以认为这种多线程同时写日志到一个文件中是可行的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单个服务的基本结构</title>
      <link href="/p/db446a40.html"/>
      <url>/p/db446a40.html</url>
      
        <content type="html"><![CDATA[<h1 id="单个服务的基本结构"><a href="#单个服务的基本结构" class="headerlink" title="单个服务的基本结构"></a>单个服务的基本结构</h1><p>我们通常希望服务器程序能满足高性能、高并发的要求，那什么是高性能、高并发呢？从技术角度来讲，服务器程序的“高性能”指服务器程序能流畅、低延迟地应答客户端的各类请求；“高并发”指服务器程序可以在同一时间支持较多的客户端连接和数据请求。如果一个服务器程序只能简单地接受 n 个客户端连接请求（n 可能很大），但不能同时流畅地处理这些客户端请求，就算不上高性能、高并发。如何将单个服务的性能做到最优呢？一个服务的性能不仅取决于<br>服务所在机器的硬件配置（内存、CPU、磁盘、网络带宽等），还取决于软件层面上服务器程序的逻辑结构设计。</p><h2 id="网络通信组件的效率问题"><a href="#网络通信组件的效率问题" class="headerlink" title="网络通信组件的效率问题"></a>网络通信组件的效率问题</h2><p>一个服务器程序要对外提供服务，就需要与外部程序通信，这些外部程序往往是分散在不同机器上的不同进程（即客户端），一般采用网络通信（一般用得最多的是socket通信）。因此网络通信组件是服务器程序的基础组件，其设计得好坏直接影响服务器对外服务的能力</p><h3 id="高效网络通信框架的设计原则"><a href="#高效网络通信框架的设计原则" class="headerlink" title="高效网络通信框架的设计原则"></a>高效网络通信框架的设计原则</h3><p>业务的不同导致网络通信框架在一些细节上的设计略有不同，但网络通信框架的设计方法大多是通用的、有规律可循的.</p><h4 id="尽量少等待"><a href="#尽量少等待" class="headerlink" title="尽量少等待"></a>尽量少等待</h4><p>目前，流行的网络通信框架虽然有很多，例如libevent、libuv、Boost Asio等，但实现这些网络通信框架的技术手段往往大同小异。一个好的网络通信框架至少要解决以下 7个问题。</p><ul><li><p>如何检测有新的客户端连接到来？</p><ul><li>WebSocket 服务器可以使用监听套接字来侦听传入的连接请求。当有新的客户端连接请求到达时，服务器会触发相应的事件或回调函数，从而可以检测到新的客户端连接。</li></ul></li><li><p>如何接受客户端的连接请求？</p><ul><li>服务器端可以使用网络编程库或框架提供的接口来接受客户端的连接请求。通常会使用类似 <code>accept()</code> 函数的方法来接受传入的连接请求，并创建一个新的套接字与客户端进行通信。</li></ul></li><li><p>如何检测客户端是否有数据发送过来？</p><ul><li>WebSocket 服务器可以使用非阻塞 I&#x2F;O 或事件驱动的方式来检测客户端是否有数据发送过来。这可以通过轮询套接字状态、使用事件监听器或回调函数等方式来实现。</li></ul></li><li><p>如何接收客户端发送的数据？</p><ul><li>一旦服务器检测到客户端有数据发送过来，服务器可以读取套接字接收缓冲区中的数据来接收客户端发送的数据。这可以使用类似 <code>recv()</code> 函数的方法来接收数据。</li></ul></li><li><p>如何检测异常的客户端连接？检测到之后，如何处理？</p><ul><li>WebSocket 服务器可以使用心跳机制或超时检测来监测客户端连接的异常。如果服务器检测到连接异常，例如连接断开或超时，可以根据具体情况进行处理，例如关闭对应的套接字和释放相关资源。</li></ul></li><li><p>如何向客户端发送数据？</p><ul><li>WebSocket 服务器可以使用类似 <code>send()</code> 函数的方法将数据发送给客户端。服务器将数据写入套接字发送缓冲区，待下一次发送操作时会将数据传输给客户端。</li></ul></li><li><p>如何在客户端发送完数据后关闭连接？</p><ul><li>服务器可以发送关闭帧（Close Frame）给客户端来请求关闭连接。发送关闭帧后，服务器等待客户端响应关闭帧，确认连接关闭后，服务器可以关闭对应的套接字和释放相关资源。</li></ul></li></ul><p>这些操作可以根据所使用的编程语言、网络库或框架的特定接口来实现。具体实现方式可能会有所差异，请参考相应的文档或参考示例代码来进行具体操作。<br>有网络编程基础的读者，都能解决上面的一些问题。例如：对第1、3个问题，使用I&#x2F;O Multiplexing（之后简称“I&#x2F;O复用”）技术的select、poll、epoll等相关套接字函数；对第2个问题，使用socketAPI accept函数；对第4个问题，使用recv函数；对第6个问题，使用send函数。的确如此，这些基础的socket API构成了网络通信的基础，无论网络通信框架设计得如何巧妙，都是利用这些基础的socketAPI构建出来的。<br>所以如何巧妙组织这些基础的 socket API，成为解决问题的关键。服务器的高性能、高并发实际上只是一个技术实现所达到的效果而已，不管怎样，从程序设计的角度来说，高性能、高并发服务只是一个或一组程序。一般来说，能尽量满足尽量少等待原则的程序就是高性能的（高效的）。这里说的“高性能”不是指“忙得忙死、闲得闲死”，而是都可以闲着，但只要有“活儿干”，尽量一起干以达到工作效率最优。<br>这里举几个工作效率不是最优的网络通信的例子：</p><ul><li>默认情况下，在recv函数没有数据时，线程会阻塞在recv函数调用处；</li><li>默认情况下，如果TCP窗口不是足够大，则数据无法发出，send函数也会阻塞当前调用线程；</li><li>默认情况下，connect函数发起连接时会有一定时长的阻塞；</li><li>向对端发送一段数据，接着使用recv函数接收对端的应答数据，如果对端一直不应答，当前调用线程就会阻塞在recv函数调用处。<br>以上例子所展现的都不是高效网络编程方式，因为它们都不满足尽量少等待原则。在网络通信中，有些等待不是必需的。那么，有没有一种方法，使上述过程不需要等待？最好是不仅不需要等待，而且在网络操作完成时能通知我们，利用等待的时间让程序做其他事情。答案是肯定的，使用I&#x2F;O复用技术即可。</li></ul><h4 id="尽量减少做无用功的时间"><a href="#尽量减少做无用功的时间" class="headerlink" title="尽量减少做无用功的时间"></a>尽量减少做无用功的时间</h4><p>目前Windows支持的I&#x2F;O复用技术有select、WSAAsyncSelect、WSAEventSelect和IOCP （完成端口），Linux支持的I&#x2F;O复用技术有select、poll和epoll模型。前面已经详细介绍过这些I&#x2F;O复用函数的用法，这里讨论一些深层次的内容。以上列举的I&#x2F;O复用函数可以分为以下两个级别。</p><ul><li>第1级别：select和poll。</li><li>第2级别：WSAAsyncSelect、WSAEventSelect、IOCP、epoll。</li></ul><p>这种划分级别的依据是什么呢？<br>先来分析第1级别的函数。select和poll函数在本质上还是在一定时间内主动查询在一组 socket句柄（一个或是多个）上是否有网络事件（可读事件、可写事件或出错事件等），也就是说，我们必须每隔一段时间就主动做这些检测操作。如果在这段时间内检测到一些网络事件，检测操作消耗的时间就没有白费；如果在这段时间内没有事件呢？那就相当于做了无用功，是对系统资源的一种浪费。原因是，假设一个服务器有多个连接，在CPU 时间片有限的情况下，我们花费了一定时间检测一部分 socket的网络事件，却发现什么事件都没有，而我们在这段时间内可能有其他事情需要处理，那我们为什么要花时间去做这种检测呢？把这个时间用在我们需要做的事情上不是更好吗？所以对于服务器网络通信组件来说，要想高效，就应该尽量避免花时间主动查询一些socket是否有网络事件，而是等到这些socket有网络事件时让系统主动通知我们，我们再去处理。这就是第2级别的函数做的事情。<br>第2级别的函数相当于变主动查询为被动通知，即网络事件发生时，系统会通知我们处理。只不过第 2 级别的函数通知我们的方式各不相同，WSAAsyncSelect 函数利用Windows窗口消息队列的事件机制将通知发给我们设置的窗口过程函数，IOCP模型利用GetQueuedCompletionStatus 函数从挂起状态唤醒并返回，epoll 模型利用 epoll_wait 函数返回就绪事件。例如，connect函数发起连接时，如果将连接socket设置为非阻塞模式，程序就不需要等待 connect 函数的返回结果，可以立即返回；等连接完成之后，WSAAsyncSelect 函数会产生FD_CONNECT事件，告知我们连接是否成功，epoll模型会生成EPOLLOUT事件通知我们。又例如，socket有数据可读时，WSAAsyncSelect函数会产生FD_READ事件，epoll模型会产生EPOLLIN事件，等等。<br>总之，对网络通信组件的性能有高要求时，尽量不要主动查询各个 socket事件，而是等待操作系统通知我们。基于上面的讨论，这里提出第 2个原则：尽量减少做无用功的时间。在服务程序资源足够的情况下，这样做可能体现不出什么优势，但是对于有大量的任务要处理、需要支持高并发服务的情况，这样做优势很明显。<br>对于高性能的服务，同样是I&#x2F;O复用API，为什么不使用select、poll函数了。另外，使用I&#x2F;O复用API，如果某个socket失效，就应该及时从I&#x2F;O复用API上移除该socket，否则可能造成死循环或者浪费CPU检测周期的问题</p><h2 id="检测网络事件的高效做法"><a href="#检测网络事件的高效做法" class="headerlink" title="检测网络事件的高效做法"></a>检测网络事件的高效做法</h2><p>根据上文介绍的两个原则，我们在高性能服务器设计中一般将socket设置成非阻塞模式，利用I&#x2F;O复用函数检测各个 socket上的事件（读、写、出错等事件）。当然，阻塞的socket通信模式并非一无是处。<br>下面回答本章开头提出的7个问题。</p><p>对于第1、2个问题，在默认情况下，如果没有新的客户端连接请求，则对监听socket （调用bind和 listen函数的 socket）调用accept函数会阻塞调用线程，使用 I&#x2F;O复用函数以后，如果epoll_wait 函数检测到监听 socket 有 EPOLLIN 事件，或者WSAAsyncSelect函数检测到有 FD_ACCEPT 事件，就表明此时有新连接到来，再调用 accept 函数就不会阻塞调用线程了。</p><p>对于第 3、4 个问题，调用 accept 函数返回的新 socket 也应该被设置成非阻塞模式，而且应该在 epoll_wait 或 WSAAsyncSelect函数报告这个 socket 有可读事件时收取数据，这样才不会做无用功。那么一次性收取多少数据合适呢？可以根据自己的实际需求来决定，甚至可以在一个循环中反复调用recv（或read）函数。对于非阻塞模式的socket，如果没有数据可读，则 recv （或 read）函数会立即返回（返回值是-1），此时得到的错误码EWOULDBLOCK（或EAGAIN）表明当前已经没有数据了。代码示例如下：</p><pre><code>bool CMySocket::Recv() &#123;    int nRet = 0;    while (true) &#123;        char buff[512];        nRet = recv(m_hSocket, buff, 512, 0);        if (nRet == SOCKET_ERROR) &#123;            // 调用 recv 函数，直到错误码是 WSAEWOULDBLOCK            if (errno == WSAEWOULDBLOCK) &#123;                break;            &#125; else &#123;                return false;            &#125;        &#125; else if (nRet &lt; 0) &#123;            return false;        &#125; else if (nRet == 0) &#123;            break;        &#125;        m_strRecvBuf.append(buff, nRet);    &#125;    return true;&#125;</code></pre><p>对于第5个问题，同样，若I&#x2F;O复用函数（如epoll_wait、WSAAsyncSelect）收到异常事件（如 EPOLLERR）或关闭事件（如FD_CLOSE）的通知，我们就知道有异常产生了，对异常的处理一般是关闭相应的socket。另外，如果send&#x2F;recv（或 read&#x2F;write）函数操作某个socket时返回0，则一般可以认为对端关闭了连接，对于本端，此时这路连接也没有存在的必要了，我们可以关闭本端对应的socket。需要说明的是，TCP连接是状态机，I&#x2F;O复用函数一般无法检测出两个端点之间路由错误导致的链路问题，所以对于这种情形，我们需要通过定时器结合心跳包来检测。</p><p>对于第6个问题，向客户端发送数据比收取数据稍微麻烦一点，也是需要讲究技巧的。对于epoll模型的水平触发模式（LevelTrigger），我们首先不能像检测读事件一样一开始就注册检测写事件标志，因为一旦注册了检测写事件标志，则在一般情况下，只要对端正常收取数据，对应的socket就通常是可写的，这会导致频繁触发写事件通知。但并不是每次有写事件触发时都有数据要发送，所以正确的做法是：在epoll模型水平触发模式下，如果有数据要发送，则先调用send或write函数尝试直接发送；如果发送不了或者只发送出去部分数据，则将剩余的数据先缓存起来（需要一个缓冲区来存放剩余的数据，即“发送缓冲区”），再为该socket注册检测写事件标志，等下次写事件触发时再发送剩余的数据；如果剩下的数据还是不能完全发送完，则继续等待下一次写事件触发通知，在下一次写事件触发通知后，继续发送数据。如此反复，直到所有数据都发送出去为止。一旦所有数据都发送出去了，就及时为 socket 移除检测写事件标志，避免再次触发无用的写事件通知。上面提到的发送缓冲区不仅用来存放本次没有发送完的数据，还用来存放发送过程中上层传来的需要发送的新数据。为了保证顺序，新数据应该被追加在当前剩余数据的后面。每次有写事件触发时，我们都应该按数据的先后依次从发送缓冲区中取出再发送，即“先来的数据先发送，后来的数据后发送”。</p><p>对于第7个问题，比较难处理，因为这里的“发送完”不一定是真的发送完，发送数据用的send或write函数即使返回成功，也只能说明向操作系统网络协议栈里面写入数据成功，并不代表数据被成功发送到网络。至于最后操作系统协议栈中的数据能否被发送出去及何时被发送出去，很难判断，发送出去后对方是否收到，就更难判断了。所以，我们目前只能简单地认为 send或者write函数返回我们期望的字节数时，就算数据发送完成。在这种情形下发送“完”数据后，就可以关闭连接了。当然，我们也可以使用 shutdown函数达到“半关闭”效果（即只关闭socket的发送或接收通道）。socket有个linger选项，可以设置某个socket在关闭时，剩下的数据最多可以逗留的时间。如果在逗留的时间内数据还不能完全发送出去，那剩余的数据就真的被操作系统丢弃了。</p><h3 id="连接的被动关闭与主动关闭"><a href="#连接的被动关闭与主动关闭" class="headerlink" title="连接的被动关闭与主动关闭"></a>连接的被动关闭与主动关闭</h3><p>在实际应用中，连接的被动关闭指我们检测到了连接的异常事件（例如，触发EPOLLERR事件、send&#x2F;recv函数返回0使对端关闭连接），这时这路连接已经没有存在的必要了，需要被迫关闭连接。而主动关闭连接指我们主动调用close&#x2F;closesocket函数关闭socket来关闭某个连接，例如客户端向服务端发送了非法数据（如网络攻击中的一些刺探性数据包），这时服务端出于安全考虑，需要主动关闭与该客户端的连接</p><h4 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h4><p>网络通信双方之间的连接根据保持状态分为长连接和短连接，长连接指长时间保持通信双方的连接状态，是相对于短连接而言的。<br>长连接操作通常为：连接→数据传输→保持连接→数据传输→保持连接→……→关闭连接，在没有数据交换时需要定时发送保活心跳包，以维持连接状态。长连接主要用于通信双方频繁通信的场景中，缺点是通信双方要增加相应的逻辑维护连接的状态，连接信息本身也需要一定的系统消耗；优点是可以进行实时数据交换。<br>短连接操作通常为：连接→数据传输→关闭连接，在没有数据交换时直接关闭连接即可。短连接一般用于数据传输完成后即可关闭或者对通信双方的状态信息实时性要求不高的场景中。例如We b服务器一般使用短连接与浏览器通信，在We b服务器将页面信息发送给浏览器后即可关闭连接，在需要时可再次建立连接。短连接的优点是通信双方无须长时间维护连接状态信息，可节省连接资源；缺点是如果传输数据的频率较高，则可能需要频繁建立和关闭连接，也无法实时推送消息。<br>“We b服务器一般使用短连接与浏览器通信”严格来讲是不准确的，在一些HTTP 通信中，通信双方可能会接受对端 HTTP 包头中keepalive 选项的建议，在多次通信之间保持连接状态。<br>另外，虽然在大多数场景下HTTP通信双方都使用短链接，不支持服务端的消息推送，但HTTP 2.0协议标准就支持服务端的推送。</p><h2 id="原始的服务器结构"><a href="#原始的服务器结构" class="headerlink" title="原始的服务器结构"></a>原始的服务器结构</h2><p>单个服务器的结构是随着业务需求的升级而不断演进的。原始的服务器结构，是创建好监听socket，在一个循环里面接受新的连接并产生对应的客户端fd，然后利用这个客户端fd与客户端通信（收发数据）。在一个循环里面接受新的连接并产生对应的客户端 fd，然后利用这个客户端 fd与客户端通信的示例代码如下</p><pre><code>    #include &lt;sys/types.h&gt;    #include &lt;sys/socket.h&gt;    #include &lt;arpa/inet.h&gt;    #include &lt;unistd.h&gt;    #include &lt;iostream&gt;    #include &lt;string.h&gt;    int main() &#123;        // 1. 创建一个监听socket        int listenfd = socket(AF_INET, SOCK_STREAM, 0);        if (listenfd == -1) &#123;            std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;            return -1;        &#125;        // 2. 初始化服务器地址        struct sockaddr_in bindaddr;        memset(&amp;bindaddr, 0, sizeof(bindaddr));        bindaddr.sin_family = AF_INET;        bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);        bindaddr.sin_port = htons(3000);        if (bind(listenfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;            std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;            return -1;        &#125;        // 3. 启动监听        if (listen(listenfd, SOMAXCONN) == -1) &#123;            std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;            return -1;        &#125;        while (true) &#123;            struct sockaddr_in clientaddr;            socklen_t clientaddrlen = sizeof(clientaddr);            // 4. 接受客户端连接            int clientfd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);            if (clientfd == -1) &#123;                std::cout &lt;&lt; &quot;accept error.&quot; &lt;&lt; std::endl;                continue;            &#125;            char recvBuf[32] = &#123;0&#125;;            // 5. 从客户端接收数据            int ret = recv(clientfd, recvBuf, sizeof(recvBuf) - 1, 0);            if (ret &gt; 0) &#123;                std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;                // 6. 将收到的数据原封不动地发送给客户端                ret = send(clientfd, recvBuf, strlen(recvBuf), 0);                if (ret != strlen(recvBuf)) &#123;                    std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                &#125; else &#123;                    std::cout &lt;&lt; &quot;send data to client successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;                &#125;            &#125; else if (ret == 0) &#123;                std::cout &lt;&lt; &quot;client disconnected.&quot; &lt;&lt; std::endl;        &#125; else &#123;            std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;        &#125;        close(clientfd);    &#125;    // 7. 关闭监听socket    close(listenfd);    return 0;&#125;</code></pre><p>将以上代码抽出主干部分并整理成如下伪代码：</p><pre><code>int main&#123;    //1.初始化阶段    while (true)    &#123;        //2.利用accept函数接受连接,产生客户端fd        //3.利用步骤2中的fd与某个客户万通信    &#125;    //4.资源清理    return 0;&#125;</code></pre><p>在以上流程中，程序在每轮循环中都只能处理一个客户端连接请求，要处理下一个客户端连接请求，就必须等当前操作完成后进入下一轮循环才行。采用这种结构的缺点很明显：不支持并发，更不支持高并发。</p><h2 id="一个连接对应一个线程模型"><a href="#一个连接对应一个线程模型" class="headerlink" title="一个连接对应一个线程模型"></a>一个连接对应一个线程模型</h2><p>因为原始的服务器结构不支持并发，所以随着计算机引入多线程模型，软件开发者想出了另一种服务器结构，即为每一个客户端连接都创建一个线程，这样多个线程就可以并行执行，在每个独立的线程中为对应的客户端提供服务。示例代码如下：</p><pre><code>// 监听线程UINT WINAPI MyMainThread(LPVOID lpVoid)&#123;    SOCKET sListenSocket = reinterpret_cast&lt;SOCKET&gt;(lpVoid);    SOCKET sClientSocket;    while (true)    &#123;        // 等待客户连接        sockaddr_in clientAddr;        int clientAddrLength = sizeof(clientAddr);        sClientSocket = accept(sListenSocket, reinterpret_cast&lt;struct sockaddr*&gt;(&amp;clientAddr), &amp;clientAddrLength);        if (sClientSocket == INVALID_SOCKET)            break;        LOG_NORMAL(&quot;New client connected: %s:%d&quot;, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));        // 启动客户端线程        UINT nThreadID;        HANDLE hThread = reinterpret_cast&lt;HANDLE&gt;(_beginthreadex(NULL, 0, MyChildThread, reinterpret_cast&lt;LPVOID&gt;(sClientSocket), 0, &amp;nThreadID));        CloseHandle(hThread);    &#125;    closesocket(sListenSocket);    return 0;&#125;// 接收数据线程UINT WINAPI MyChildThread(LPVOID lpVoid)&#123;    SOCKET sClientSocket = reinterpret_cast&lt;SOCKET&gt;(lpVoid);    CLIENT_ITEM clientItem = &#123; 0 &#125;;    int nCmd = HandleClientMain(sClientSocket, clientItem);    LOG_NORMAL(&quot;Client cmd: %d&quot;, nCmd);    if (nCmd == -1)    &#123;        closesocket(sClientSocket);    &#125;    else if (nCmd == CONN_MAIN)    &#123;        LoginTrans(sClientSocket, &amp;clientItem);    &#125;    else    &#123;        InterTrans(sClientSocket, &amp;clientItem, nCmd);    &#125;    return 0;&#125;</code></pre><p>如以上代码所示，在某个线程MyMainThread中（可以是主线程，也可以是非主线程）调用 accept 函数接受客户端连接，在连接建立后，为每个新连接都创建一个工作线程（MyChildThread）。当然，为了让工作线程正常处理所负责的连接上的来往数据，这里利用线程函数参数将 socket句柄传给工作线程（注意以上代码中创建线程的_beginthreadex函数的第4个参数sClientSocket）。显然，这种一个连接一个线程的做法也不支持高并发，当连接数达到一定量时，会创建很多 MyChildThread 线程，CPU 在线程之间的切换也是一笔不小的开销，CPU 时间片最后都浪费在各个线程之间的切换上了，严重影响程序的执行效率。</p><h2 id="one-thread-one-loop思想"><a href="#one-thread-one-loop思想" class="headerlink" title="one thread one loop思想"></a>one thread one loop思想</h2><p>基于Reactor模式，这里引出one thread one loop（一个线程对应一个循环）思想。</p><h3 id="one-thread-one-loop程序的基本结构"><a href="#one-thread-one-loop程序的基本结构" class="headerlink" title="one thread one loop程序的基本结构"></a>one thread one loop程序的基本结构</h3><p>one thread one loop中的线程指的是网络线程，也就是说，在每个网络线程函数里面都有一个循环（loop），每个循环的流程都如下所示，因此每个网络线程都做着同样的事情。这个循环流程如下：</p><pre><code>#include &lt;pthread.h&gt;// 线程函数void* threadFunc(void* thread_arg)&#123;    // 这里做一些需要的初始化工作    bool exitFlag = false;    while (!exitFlag)    &#123;        // 步骤一: 利用select/poll/epoll等I/O复用技术分离出读写事件        // TODO: 在这里处理读写事件        // 步骤二: 处理读事件或写事件        // TODO: 在这里处理读事件或写事件        // 步骤三: 做其他事情        // TODO: 在这里做其他事情        // 这里做一些清理工作        // TODO: 在这里进行清理工作    &#125;    return NULL;&#125;</code></pre><p>关键部分是线程函数里面的 while循环部分，步骤一利用I&#x2F;O复用技术分离出 socket读写事件；步骤二处理读事件和写事件，需要注意的是，在Linux上除了socket对象，其他类型的对象（如管道、文件句柄）也可以被挂到I&#x2F;O复用函数上。这里暂时先讨论socket对象，以处理读事件为例进行说明</p><ul><li>对于监听socket，我们认为处理监听socket的读事件一般就是接受新连接等操作，我们不仅可以接受新连接，还可以多做一点事情，例如将accept函数返回的客户端socket绑定到I&#x2F;O复用函数上，以及创建连接对象等。</li><li>对于普通的 socket，在不考虑出错的情况下，处理普通socket的读事件实际上就是调用recv或者read函数收取数据，或者进一步对收到的数据进行解包，并做一些业务逻辑处理。举个例子，假设收到的数据经解包后是登录请求，则可以接着处理这些登录请求，并应答客户端。在这种场景下，处理读事件实际上包括收数据、解包、处理数据、应答客户端这4个步骤。<br>处理socket的写事件，一般是做发送数据操作。</li></ul><h3 id="线程的分工"><a href="#线程的分工" class="headerlink" title="线程的分工"></a>线程的分工</h3><p>根据上文介绍的线程函数中的循环结构，服务端为了能流畅处理多个客户端连接请求，一般在某个线程 A 里面调用 accept 函数产生新的客户端连接并生成相应的 socket，然后将这些新连接的 socket传递给另外数个工作线程 B1、B2、B3、B4 等，这些工作线程负责处理这些新连接上的网络 I&#x2F;O 事件（即收发数据），这些工作线程还同时处理系统中的另一些事务。在实际开发中，线程 A 往往对应进程的主线程，为了叙述方便，在下文中除了特别强调，否则将A线程称为主线程，将B1、B2、B3、B4等称为工作线程。将工作线程的代码框架用伪代码表示如下</p><pre><code>while (!m bouitElag)&#123;    epoll_or_select_func();    handle_io_events():    handle_other_things;&#125;</code></pre><p>在 epoll_or_select_func（）中通过select&#x2F;poll&#x2F;epoll等I&#x2F;O复用函数去检测 socket上的网络事件，若检测到这些事件，则下一步调用handle_io_events（）处理这些事件（一般是收发数据），在做完之后可能还要处理其他任务，这时调用handle_other_things（）即可。主线程（线程A）和工作线程（线程B1、B2、B3、B4等）分工策略的优点如下。</p><ul><li>线程 A 只需处理新来的连接即可，不用处理普通 socket的网络 I&#x2F;O 事件。如果在线程A里面既处理新连接又处理网络I&#x2F;O事件，则可能由于线程忙于处理网络I&#x2F;O事件，无法及时处理新的客户端连接请求。</li><li>线程A接受连接产生新的 socket，我们可以根据一定的负载均衡策略，将这些socket分配给各个工作线程。round robin（轮询策略）是其中一种很简便、常用的策略，该策略在不考虑中途有连接断开的情况下将 A线程产生的新 socket 依次分配给各个工作线程，将第1个分配给B1，将再来的一个分配给B2，再将一个分配给B3……如此反复。线程 A 会记录各个工作线程上的 socket 数量，这样可以平衡资源利用率，避免一些工作线程“忙死”而另一些工作线程“闲死”的情况出现。</li><li>在工作线程不满负载的情况下，可以让工作线程处理其他任务。例如现在有 4个工作线程，但只有3个连接，工作线程B4就可以在handle_other_things（）中处理其他任务。</li></ul><p>在上述 while 循环里面，epoll_or_selec_func（）中的 poll、select、epoll_wait 等函数一般设置了一个超时时间。如果将超时时间设置为0，那么在没有任何网络I&#x2F;O事件和其他任务需要处理的情况下，这些工作线程实际上会空转，白白浪费了 CPU时间片。如果将超时时间设置为大于0，则在没有网络I&#x2F;O事件但handle_other_things（）中有其他任务需要处理时，poll、select、epoll_wait等函数会在挂起指定时间后才能返回，导致handle_other_things（）中的任务不能及时执行。那这里该怎么设置I&#x2F;O复用函数的超时时间呢？<br>其实解决问题的思路不在于超时时间的设置，我们想达到的效果是：如果没有网络I&#x2F;O事件和其他任务要处理，那么这些工作线程最好直接挂起而不是空转；如果有其他任务要处理，那么这些工作线程要能立刻处理这些任务，而不是在 poll、select、epoll_wait等函数处挂起指定时间后才处理其他任务。<br>解决方案是，我们仍然会给poll、select、epoll_wait等函数设置一定的超时时间（大于0），但对于handle_other_things函数的执行，会采取一种特殊的唤醒策略。以Linux的epoll_wait函数为例，不管在epollfd上有没有socket fd，我们都会为epollfd挂载一个特殊的fd，这个fd被称为wakeup fd（唤醒fd）。当我们有其他任务需要立即处理时（也就是需要handle_other_thing（）立刻执行时），向这个唤醒fd上随便写入1字节的内容，这个唤醒fd就立即变成可读的了，epoll_wait函数会立即被唤醒并返回，接下来就可以马上执行<br>handle_other_thing 函数了，这样其他任务就可以得到立即处理；反之，在没有其他任务也没有网络I&#x2F;O事件时，epoll_or_select_func函数就挂在那里什么也不做。poll、select函数的处理策略与epoll_wait相同</p><h3 id="唤醒机制的实现"><a href="#唤醒机制的实现" class="headerlink" title="唤醒机制的实现"></a>唤醒机制的实现</h3><p>本节讲解唤醒机制的实现。</p><h4 id="唤醒机制在Linux上的实现"><a href="#唤醒机制在Linux上的实现" class="headerlink" title="唤醒机制在Linux上的实现"></a>唤醒机制在Linux上的实现</h4><p>唤醒机制在Linux上的实现方式有以下几种。</p><ul><li><p>使用管道fd（pipe）<br>创建一个管道，将管道的一端（管道fd中的一个）绑定到epollfd上，需要唤醒时，向管道的另一端（管道fd中的另一个）写入1字节，工作线程会被立即唤醒。创建管道的相关API函数如下：</p><p>  #include &lt;unistd.h&gt;<br>  #include &lt;fcntl.h&gt;<br>  int pipe(int pipefd[2]);<br>  int pipe2(int piperd[2], int flags);</p></li><li><p>使用Linux 2.6新增的eventfd<br>eventfd的使用方法与管道fd一样，将调用eventfd函数返回的eventfd绑定到epollfd上，需要唤醒时，向这个eventfd上写入一字节，I&#x2F;O复用函数会被立即唤醒。创建eventfd函数签名如下：</p><p>  #include &lt;sys&#x2F;eventfd.h&gt;<br>  int eventfd(unsigned int initval, int flags);</p></li><li><p>使用socketpair<br>socketpair 是一对相互连接的socket，相当于服务端和客户端的两个端点，每一端都可以读写数据，向其中一端写入数据后，就可以从另一端读取数据了。创建socketpair的函数签名如下：</p></li></ul><pre><code class="cpp">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int sv[2]);</code></pre><ul><li><code>domain</code>：指定协议域，常见的值包括 <code>AF_UNIX</code>（Unix 域套接字）和 <code>AF_INET</code>（IPv4 套接字）等。</li><li><code>type</code>：指定 socket 类型，常见的值包括 <code>SOCK_STREAM</code>（字节流套接字）和 <code>SOCK_DGRAM</code>（数据报套接字）等。</li><li><code>protocol</code>：指定协议，通常传递 <code>0</code> 表示由系统自动选择合适的协议。</li><li><code>sv[2]</code>：用于存储创建的两个 socket 文件描述符的数组。<code>sv[0]</code> 是服务端的 socket 文件描述符，<code>sv[1]</code> 是客户端的 socket 文件描述符。<br>调用这个函数返回的两个文件描述符是 sv[0]和 sv[1]，即socketpair函数的第 4个参数是一个输出参数，向 sv[0]、sv[1]中的任何一个 fd 写入字节后，就可以从另一个 fd 中读取写入的字节了。我们将读取方的fd绑定到epollfd上，在需要时向写入方的fd写入1字节，工作线程就会立即被唤醒。注意：与创建普通socket稍微不同的是，使用socketpair函数创<br>建socketpair时，必须将第1个参数domain设置为AF_UNIX。</li></ul><h4 id="唤醒socket在Windows上的实现"><a href="#唤醒socket在Windows上的实现" class="headerlink" title="唤醒socket在Windows上的实现"></a>唤醒socket在Windows上的实现</h4><p>在 Windows上使用 select 函数作为 I&#x2F;O 复用函数时，由于Windows的 select 函数只支持绑定套接字这种类型的句柄，因此在Windows上一般只能模仿Linux创建socketpair的思路，即手动创建两个 socket；然后调用connect、accept 函数建立一个连接，相当于将其中一个socket作为客户端socket（用来调用connect函数的socket），去连接某个监听socket，将另外一个socket作为监听端接受连接后（调用accept函数）返回的socket；然后将读取数据的那一端的socket绑定到select函数上并检测其可读事件。当然，这种创建<br>唤醒socket的做法同样适用于Linux。如下图所示，在以上一段文字中共有3个socket：一端调用connect函数发起连接请求的socket（记为socketA）；另一端的监听socket（记为socketB）；利用 socketB 调用 accept 函数返回的socket（记为 socketC）。其中的 socketA 和socketC就是唤醒socket（在Linux上称之为唤醒fd）。</p><p><img src="https://s1.ax1x.com/2023/06/17/pCQxReS.png" alt="pCQxReS.png"></p><p>创建唤醒fd（socket）的具体实现如下：</p><pre><code>#ifdef _WIN32bool EventLoop::createWakeupFd()&#123;    m_wakeupFdListen = sockets::createOrDie();    m_wakeupFdSend = sockets::CreateOrDie();    // 在 Windows 上需要创建一对 socket    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);    bindaddr.sin_port = 0;    sockets::setReuseAddr(m_wakeupFdListen, true);    sockets::bindOrDie(m_wakeupFdListen, bindaddr);    sockets::listenOrDie(m_wakeupFdListen);    struct sockaddr_in serveraddr;    int serveraddrlen = sizeof(serveraddr);    if (getsockname(m_wakeupFdListen, (struct sockaddr*)&amp;serveraddr, &amp;serveraddrlen) &lt; 0)    &#123;        // 让程序挂掉        LOGF(&quot;Unable to bind address info, EventLoop: 0x%lx&quot;, this);        return false;    &#125;    int useport = ntohs(serveraddr.sin_port);    LOGD(&quot;wakeup fd use port: %d&quot;, useport);    if (::connect(m_wakeupFdSend, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)    &#123;        // 让程序挂掉        LOGF(&quot;Unable to connect to wakeup peer, EventLoop: 0x%lx&quot;, this);        return false;    &#125;    struct sockaddr_in clientaddr;    socklen_t clientaddrlen = sizeof(clientaddr);    m_wakeupFdRecv = ::accept(m_wakeupFdListen, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);    if (m_wakeupFdRecv &lt; 0)    &#123;        // 让程序挂掉        LOGF(&quot;Unable to accept wakeup peer, EventLoop: 0x%lx&quot;, this);        return false;    &#125;    sockets::setNonBlockAndCloseOnExec(m_wakeupFdSend);    sockets::setNonBlockAndCloseOnExec(m_wakeupFdRecv);#else    // 在 Linux 上只需要一个 eventfd 就可以实现读写    m_wakeupFd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);    if (m_wakeupFd &lt; 0)    &#123;        // 让程序挂掉        LOGF(&quot;Unable to create wakeup eventfd, EventLoop: 0x%lx&quot;, this);        return false;    &#125;#endif    return true;&#125;</code></pre><p>在以上代码中有一个实现细节需要注意：在 Windows 上，作为服务端的一方，创建一个监听socket（代码中的m_wakeupFdListen）后，需要调用bind函数绑定特定的IP和端口号，这里不要使用一个固定的端口号。一旦使用固定的端口号，服务在某个机器上运行时就可能会因为端口号已经被占用，导致bind函数调用失败，无法创建出唤醒socket，进而影响程序的功能。唤醒 fd 是程序的关键，所以在以上代码中，createWakeupfd 函数中的任意一步操作失败，都会导致唤醒fd无法创建，主动打印一条Fatal级别的日志并让程序退出，这表明<br>关键性的初始化步骤无法完成。所以，我们将端口号设置为 0，操作系统会为我们分配一个可用的端口号。但主动连接的一方调用connect函数时需要指定明确的 IP 地址和端口号，这时调用 getsockname 函数获取操作系统为 bind函数分配的端口号就可以了。整个流程图如下图<br>所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pCQzpS1.png" alt="pCQzpS1.png"></p><p>唤醒函数的实现如下：</p><pre><code>bool EventLoop::wakeup()&#123;    uint64_t one = 1;#ifdef _WIN32    int32_t n = sockets::write(m_wakeupFdSend, reinterpret_cast&lt;char*&gt;(&amp;one), sizeof(one));#else    int32_t n = sockets::write(m_wakeupFd, reinterpret_cast&lt;char*&gt;(&amp;one), sizeof(one));#endif    if (n != sizeof(one))    &#123;#ifdef _WIN32        DWORD error = ::WSAGetLastError();        LOGSYSERR(&quot;EventLoop::wakeup() writes %d bytes instead of 8, fd:%d, error: %d&quot;, n, m_wakeupFdSend, static_cast&lt;int32_t&gt;(error));#else        int error = errno;        LOGSYSERR(&quot;EventLoop::wakeup() writes %d bytes instead of 8, fd:%d, error: %d, errorinfo: %s&quot;, n, m_wakeupFd, error, strerror(error));#endif        return false;    &#125;    return true;&#125;</code></pre><p>无论使用哪种类型的fd作为唤醒fd，一定要在唤醒后及时将唤醒fd中的数据读出来，即消耗掉这个fd中的数据，否则fd会因为有数据不断触发读事件，失去唤醒的作用。<br>从唤醒fd中读取数据：</p><pre><code>bool EventLoop::handleRead()&#123;    uint64_t one = 1;#ifdef _WIN32    int32_t n = sockets::read(m_wakeupFdRecv, reinterpret_cast&lt;char*&gt;(&amp;one), sizeof(one));#else    int32_t n = sockets::read(m_wakeupFd, reinterpret_cast&lt;char*&gt;(&amp;one), sizeof(one));#endif    if (n != sizeof(one))    &#123;#ifdef _WIN32        DWORD error = ::WSAGetLastError();        LOGSYSERR(&quot;EventLoop::wakeup() read %d bytes instead of 8, fd:%d, error:%d&quot;,                n, m_wakeupFdRecv, static_cast&lt;int32_t&gt;(error));#else        int error = errno;        LOGSYSERR(&quot;EventLoop::wakeup() read %d bytes instead of 8, fd:%d, error:%d, errorinfo: %s&quot;,                n, m_wakeupFd, error, strerror(error));#endif        return false;    &#125;    return true;&#125;</code></pre><p>可以在唤醒fd的读事件触发后调用唤醒fd读取数据函数EventLoop：：handleRead（）。</p><h4 id="handle-other-things方法的实现逻辑"><a href="#handle-other-things方法的实现逻辑" class="headerlink" title="handle_other_things方法的实现逻辑"></a>handle_other_things方法的实现逻辑</h4><p>在了解唤醒机制之后，我们来看一下 handle_other_things 方法的实现逻辑。handle_other_things方法可以被设计成从其他任务集合中取出任务来执行的方法：</p><pre><code>void EventLoop::handle_other_things()&#123;    std::vector&lt;otherThingFunctor&gt; otherThingFunctors;    m_callingPendingFunctors = true;    &#123;        // 这对大括号用于减少锁m_mutex的范围        std::unique_lock&lt;std::mutex&gt; lock(m_mutex);        otherThingFunctors.swap(m_pendingOtherThingFunctors);    &#125;    size_t thingCount = otherThingFunctors.size();    for (size_t i = 0; i &lt; thingCount; ++i)    &#123;        otherThingFunctors[i]();    &#125;    m_callingPendingFunctors = false;&#125;</code></pre><p>m_pendingOtherThingFunctors是一个类成员变量，为一个存放其他任务的集合，这里使用了std：：vector，工作线程本身会从这个容器中取出任务来执行，我们将任务封装成一个个函数对象（OtherThingFunctor），从容器中取出后直接执行即可。这里使用了一个特殊的小技巧：为了减小锁对象m_mutex（也是成员变量）加锁的范围，并提高程序执行效率，这里使用了一个局部变量otherThingFunctors 将成员变量 m_pendingOtherThingFunctors中的数据倒换进这个局部变量中。添加“other_things”时，可以在任意线程中添加，也就是说，可以在网络线程之外的线程中添加任务，因此可能涉及多个线程同时操作 m_pendingOtherThingFunctors对象，所以需要对其进行加锁保护。添加other_things的代码如下：</p><pre><code>void EventLoop::queueInLoop(const Functor&amp; cb)&#123;    &#123;        // 这对大括号用于减少锁m_mutex的范围        std::unique_lock&lt;std::mutex&gt; lock(m_mutex);        m_pendingOtherThingFunctors.push_back(cb);    &#125;    // 如果在其他线程调用了这个函数，    // 则立即尝试唤醒 handle_other_things 方法所在的线程    if (!isInLoopThread() || m_callingPendingFunctors)    &#123;        wakeup();    &#125;&#125;</code></pre><p>最后，在某些业务场景中，other_things 可能有多种类型，因此可以存在多个handle_other_things方法，程序结构演变如下：</p><pre><code>while (!m_bQuitFlag)&#123;    epoll_or_select_func();  // 执行事件监听，等待事件发生    handle_io_events();  // 处理IO事件    handle_other_things1();  // 处理其他事情1    handle_other_things2();  // 处理其他事情2    handle_other_things3();  // 处理其他事情3    // 根据实际需要，可以有更多的 handle_other_things() 函数调用&#125;</code></pre><p>另外，handle_other_things（）系列的方法可以在one thread one loop结构中的while循环内部的任意位置，不一定非要放在handle_io_events 函数后面，我们有时也称<br>handle_other_things（）为钩子函数（Hook Functions），例如：</p><pre><code>while (!m_bQuitFlag)&#123;    handle_other_things1();  // 处理其他事情1    epoll_or_select_func();  // 执行事件监听，等待事件发生    handle_other_things2();  // 处理其他事情2    handle_io_events();  // 处理IO事件    handle_other_things3();  // 处理其他事情3    // 根据实际需要，可以有更多的 handle_other_things() 函数调用&#125;</code></pre><h4 id="带定时器的程序结构"><a href="#带定时器的程序结构" class="headerlink" title="带定时器的程序结构"></a>带定时器的程序结构</h4><p>如果想在one thread one loop结构的线程中做一些定时任务，则需要定时器功能，我们可以在线程循环执行流中加上检测和处理定时器事件的逻辑，通常将其放在程序循环执行流的第1步。加上定时器逻辑后，程序结构如下：</p><pre><code>while (!m_bQuitFlag)&#123;    check_and_handle_timers();  // 检查和处理定时器事件    epoll_or_select_func();  // 执行事件监听，等待事件发生    handle_io_events();  // 处理IO事件    handle_other_things();  // 处理其他事情&#125;</code></pre><p>这里需要注意的是，在 epoll_or_select_func（）中使用的 I&#x2F;O复用函数的超时时间要尽量不大于check_and_handle_timers（）中所有定时器的最小时间间隔，以免定时器的逻辑处理延迟较大。</p><h4 id="one-thread-one-loop的效率保障"><a href="#one-thread-one-loop的效率保障" class="headerlink" title="one thread one loop的效率保障"></a>one thread one loop的效率保障</h4><p>在整个 loop 结构中，为了保证各个步骤高效执行，除了epoll_or_select_func 步骤中的I&#x2F;O复用函数可能会造成等待，在任何其他步骤中都不能有阻塞整个流程或者耗时的操作。如果业务决定了在定时器逻辑（对应check_and_handle_timers函数）、读写事件处理逻辑（对应 handle_io_events 函数）或其他自定义逻辑（对应handle_other_things 函数）中有耗时的操作，就需要再开新的业务线程去处理这些耗时的操作，I&#x2F;O线程（loop所在的线程）本身不能处理耗时的操作。业务线程在处理耗时操作完毕后，可以将处理结果或者数据通过特定方式返回给I&#x2F;O线程.</p><h2 id="收发数据的正确做法"><a href="#收发数据的正确做法" class="headerlink" title="收发数据的正确做法"></a>收发数据的正确做法</h2><p>在网络通信中，我们可能既要通过 socket 发送数据，也要通过socket 收取数据。那么，一般的网络通信框架是如何收发数据的呢？<br>注意，这里讨论的是基于先使用I&#x2F;O复用函数（select、poll、epoll等）判断 socket 读写事件再来收发数据，其他情形比较简单，不再赘述。<br>以服务端为例，服务端接受客户端连接后，会产生一个与客户端连接对应的 socket （在Linux上也叫作fd，为了叙述方便，下文称之为clientfd），我们可以通过这个clientfd收取从客户端发来的数据，也可以通过这个clientfd将数据发往客户端。但是收与发在操作流程上是有明显区别的。</p><h3 id="如何收取数据"><a href="#如何收取数据" class="headerlink" title="如何收取数据"></a>如何收取数据</h3><p>对于收取数据，在接受连接并得到clientfd后，我们会将该clientfd绑定到相应的I&#x2F;O复用函数上并监听其可读事件。不同I&#x2F;O复用函数的可读事件标志不一样，例如对于poll模型，可读标志是POLLIN；对于epoll模型，可读事件标志是EPOLLIN。在可读事件触发后，我们调用 recv函数从 clientfd上收取数据（这里不考虑出错情况），根据不同的业务需求，我们可能会收取部分数据或一次性收完所有数据。我们会将收取到的数据放入接收缓冲区，然后做解包操作。这就是收取数据的全部流程。对于使用epoll的LT模式（水平触发模式），我们可以在每次读事件触发后都只收取部分数据；但对于 ET模式（边缘触发模式），我们必须在每次读事件触发后都将fd上的数据全部收完。收完数据的标志是recv或read函数返回-1，错误码errno等于EWOULDBLOCK （EAGAIN，这两个宏的值一样）。这就是收取数据的正确做法</p><h3 id="如何发送数据"><a href="#如何发送数据" class="headerlink" title="如何发送数据"></a>如何发送数据</h3><p>对于发送数据，使用epoll的ET模式这种场景除外，使用epoll的LT模式或者其他I&#x2F;O 复用函数时，我们通常都不会一开始就为clientfd 注册监听可写事件的标志，这是因为只要对端正常收取数据，就一般不会出现因 TCP窗口太小导致本端 send或 write函数无法写成功的问题。因此在大多数情况下，本端的clientfd都是可写的,如果注册了监听可写事件标志，则会导致可写事件通知一直触发，而此时不一定有数据需要发送。所以，如果有数据需要发送，则一般都是先调用send或者write函数直接发送，如果在发送过程中 send 函数或 write 函数返回-1，并且错误码是 EWOULDBLOCK（或 EAGAIN），则表明此时 TCP 窗口已经太小，数据已经无法再发送。如果仍然有剩下的部分数据未发送，我们才会为clientfd注册监听可写事件标志，并将剩余的数据存入自定义的socket发送缓冲区（应用层设计的socket发送缓冲区）中，等到写事件触发后再接着将发送缓冲区中剩余的数据发送出去。如果仍然有部分数据不能发送出去，则继续注册监听可写事件标志，当已经无数据需要发送时，应该立即移除对写事件的监听。这是目前主流网络库的做法。<br>如果在监听写事件期间，业务层又产生了新的数据需要发送，我们就需要将这些新来的数据放到刚才剩余的待发数据的后面，即下次写事件触发后，先发送旧的数据再接着发送后来的新数据。<br>直接尝试发送消息的处理逻辑如下：</p><pre><code>void Tcpconnection::sendMessage(const void* data, size_t len) &#123;    int32_t nwrote = 0;    size_t remaining = len;    bool faultError = false;    // 当前未监听可写事件，并且发送缓冲区中没有遗留数据    if (!m_channel-&gt;isWriting() &amp;&amp; m_outputBuffer.readableBytes() == 0) &#123;        // 直接发送数据        nwrote = sockets::write(m_channel-&gt;fd(), data, len);        if (nwrote &gt;= 0) &#123;            remaining = len - nwrote;        &#125;    &#125; else &#123;        nwrote = 0;    &#125;    // 错误码不等于 EWOULDBLOCK，说明发送出错    if (errno != EWOULDBLOCK) &#123;        if (errno == EPIPE || errno == ECONNRESET) &#123;            faultError = true;        &#125;    &#125;    // 发送未出错且还有剩余字节未发送出去    if (!faultError &amp;&amp; remaining &gt; 0) &#123;        // 将剩余部分加入发送缓冲区中        m_outputBuffer.append(static_cast&lt;const char*&gt;(data) + nwrote, remaining);        if (!m_channel-&gt;isWriting()) &#123;            // 注册可写事件            m_channel-&gt;enableWriting();        &#125;    &#125;&#125;</code></pre><p>当数据不能一次性全部发送出去时，为相应的client注册监听写事件标志。写事件触发后的处理逻辑如下：</p><pre><code>void Tcpconnection::handleWrite() &#123;    // 将发送缓冲区中的数据发送出去    int32_t n = sockets::write(m_channel-&gt;fd(), m_outputBuffer.peek(), m_outputBuffer.readableBytes());    if (n &gt; 0) &#123;        // 发送了多少数据，就从发送缓冲区中移除多少数据        m_outputBuffer.retrieve(n);        // 如果发送缓冲区中已经没有剩余数据，则移除监听可写事件        if (m_outputBuffer.readableBytes() == 0) &#123;            // 移除监听可写事件            m_channel-&gt;disableWriting();        &#125;    &#125; else &#123;        // 发送数据出错处理        handleClose();    &#125;&#125;</code></pre><p>使用epoll LT模式注册监听一次写事件后，在写事件触发时会尝试继续发送数据，如果此时数据还不能全部发送完，就不用再次注册监听写事件标志了，因为上次注册的监听写事件标志继续有效；对于epoll ET模式，先注册监听写事件标志，写事件触发后，会尝试继续发送数据，如果此时数据还不能全部发送完，则需要再次注册监听写事件标志，以便让写事件下次再触发（给予再次发送数据的机会）。当然，这只是理论情况，在实际开发中，对于一段数据反复发送都不能完全发送完的场景（例如对端先不收，后面每隔很长时间再收1字节），我们就可以设置一个最大发送次数或最大发送总时间限制，超过这些限制后，我们可以认为对端出了问题，应该立即清空发送缓冲区并关闭相应的连接。<br>这里总结检测一个fd的读写事件的区别。</p><ul><li>使用select、poll或epoll LT模式时，可以直接为待检测fd注册监听读事件标志。</li><li>使用select、poll或epoll LT模式时，不要直接为待检测fd注册监听可写事件标志，应该先尝试发送数据，若 TCP 窗口太小发不出去，则再为待检测 fd 注册监听可写事件标志，一旦数据发送完，就应该立即移除监听写事件标志。</li><li>使用epoll ET模式时，如果需要发送数据，则每次都要为fd注册监听写事件标志。对于监听fd，一般只监听其读事件，监听fd没有写事件处理逻辑。</li></ul><h3 id="不要多个线程同时利用一个socket收（发）数据"><a href="#不要多个线程同时利用一个socket收（发）数据" class="headerlink" title="不要多个线程同时利用一个socket收（发）数据"></a>不要多个线程同时利用一个socket收（发）数据</h3><p>TCP 通信是全双工的，收取数据和发送数据是独立的，所以利用同一个 socket 收取数据和发送数据不会相互影响。这里建议不要多个线程同时利用一个socket收取数据（或发送数据），指的不是说收取数据和发送数据必须被放在同一个线程里面进行，相反，在实际开发中，有不少应用对同一个 socket收取数据使用一个线程，发送数据使用另一个线程，但是需要额外做一些工作以同步收发两个线程中socket的出错状态。但是一定不要多个线程同时使用一个 socket发送数据，或者多个线程同时使用一个socket收取数据。<br>TCP数据是有序的，以发送数据为例，如果多个线程同时对一个socket调用send函数，最终对端收到的数据顺序就无法保证了。例如现在有 3 个线程分别要发送 A、B、C三个数据块，对端期望收到的顺序是 A、B、C，但由于发送端使用了 3 个线程发送，所以对端收到的数据顺序不一定是A、B、C，除非使用一定的线程同步策略让三个线程按A、B、C 的顺序发送数据，但这种同步策略是非常麻烦的，而且没有必要。与其写这样的逻辑，还不如将其放在一个线程中操作。<br>同理，对于收取数据，多个线程会同时调用 recv 函数，每个线程都可能收取部分数据，那么最终按什么顺序将这些数据还原成发送端发送的数据顺序呢？<br>不仅是socket，管道亦如此，不建议多个线程同时在同一个管道上进行读操作（或写操作）。<br>那么“我们平时所说的多线程上传或者下载文件，不是多线程同时对一个文件内容做读写吗？”这是不一样的，多线程上传或下载文件的原理是将文件按一定的大小切割成不同的内容块，<br>然后开启多个连接，每个线程都操作一个连接对指定编号的文件内容块进行读写操作，在各个线程都完工后，按内容编号将文件重新组织起来。这在本质上并不是多个线程同时操作一个socket，而是每个线程都只操作属于自己的文件块</p><h2 id="发送、接收缓冲区的设计要点"><a href="#发送、接收缓冲区的设计要点" class="headerlink" title="发送、接收缓冲区的设计要点"></a>发送、接收缓冲区的设计要点</h2><h3 id="为什么需要发送缓冲区和接收缓冲区"><a href="#为什么需要发送缓冲区和接收缓冲区" class="headerlink" title="为什么需要发送缓冲区和接收缓冲区"></a>为什么需要发送缓冲区和接收缓冲区</h3><p>网络层在发送数据的过程中，由于 TCP 窗口太小，会导致数据无法发送出去，而上层可能不断产生新的数据，此时就需要将数据先存储起来，以便等socket可写时再次发送，这个存储数据的地方就叫作发送缓冲区。对于接收缓冲区也是一样的道理，在收到数据后，我们可以直接对其进行解包，但是这样做并不好，有三个理由。</p><ul><li>理由一：除去一些通用协议格式（例如HTTP），大多数业务使用的都是自定义协议格式，也就是说对一个数据包里面数据格式的解读应该是业务层应该做的。不同的业务一般有不同的协议格式，协议格式与具体的业务有关，网络通信层一般不知道也不需要知道上层协议数据的具体格式。为了让网络层更加通用，网络通信层应该与业务层解耦。</li><li>理由二：即使知道协议格式，由于TCP是流式协议，某一次收到的数据长度也不一定够一个完整的包大小，此时需要一个地方将这些不完整的数据先缓存起来，以便等数据足够一个包大小时再处理。</li><li>理由三：即便接收到的数据足够一个包，但出于一些特殊的业务逻辑要求，我们仍需将收到的数据暂时缓存起来，等满足一定条件时再取出来处理。</li></ul><p>鉴于以上理由，我们的网络层确实需要一个接收缓冲区，将收取的数据按需存放在该缓冲区里面，交由专门的业务线程或者业务逻辑从接收缓冲区中取出数据，并解包处理业务。</p><h3 id="如何设计发送缓冲区和接收缓冲区"><a href="#如何设计发送缓冲区和接收缓冲区" class="headerlink" title="如何设计发送缓冲区和接收缓冲区"></a>如何设计发送缓冲区和接收缓冲区</h3><p>根据前面的描述，无论是发送缓冲区还是接收缓冲区，一般都建议将其设计成一个内存连续的存储容器<br>当然，我们也可以将发送缓冲区和接受缓冲区设计成不连续的内存，例如链表结构，每个链表的节点都是一个存储数据的内存块。这种设计在存取数据时相对麻烦。<br>在通常情况下，发送缓冲区和接收缓冲区根据功能至少需要提供两类接口，即存数据的接口和取数据的接口。对于发送缓冲区，由于上层交给网络层的数据是有序的，所以若某次需要发送的数据未发完，则其剩余的数据一定排在后续产生的数据前面；对于接收缓冲区，由于其不断从socket上读取数据，所以后面读到的数据一定排在前面读到的数据后面。<br>另外，应该将发送缓冲区和接收缓冲区的容量设置成多大呢？预分配的内存太小时可能不够用，太大时可能造成浪费，所以答案是像std：：string、vector 一样，设计出一个容量可以动态增加的结构，按需分配，容量不够时可以扩展容量。既然是用于收发数据的缓冲区，所以我们可能需要向其中写入或者从其中读取各种数据类型，例如char、short、int32、int64、string等，这是我们在设计缓冲区对象时需要考虑的情形，也就是说，需要缓冲区结构提供写入和读取这些数据类型的接口。<br>对于接收缓冲区，我们可能需要从接收缓冲区中寻找特殊的标志，例如若某个业务的数据包以“\n”为结束标志，我们就需要在其中寻找“\n”标志以确定缓冲区中的数据长度是否至少足够一个包的长度。<br>下图演示了一种缓冲区设计结构，这种结构的缓冲区在创建时会自动分配一块固定大小的内存，如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClivBq.png" alt="pClivBq.png"></p><p>在这个结构中，内存是连续的，而且由预留空间和存储数据的空间组成。其中，预留空间可以做一些特殊用途使用，例如存储一些元数据信息等，预留空间的大小可以被设置为0，它不是必需的；存储数据的空间由于同时提供读数据和写数据功能，所以分别使用一个读指针和写指针来标明读写位置。当缓冲区是空的时，读写指针的位置相同。在写入一段数据后，该缓冲区的结构如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClixH0.png" alt="pClixH0.png"></p><p>此时该缓冲区中已存储数据的范围是读指针位置～写指针位置的区间，下一次需要读取数据时，应该从缓冲区的读指针位置开始读，最大可以读取的数据长度等于写指针位置减去读指针位置的值。假设读取了n字节，n小于最大可读取数据的长度，则该缓冲区结构如下图所示</p><p><img src="https://s1.ax1x.com/2023/06/17/pClFi34.png" alt="pClFi34.png"></p><p>下一次写数据时会从写指针的位置继续写。为了更清楚地说明问题，假设预留的空间大小为prependableBytes，读指针使用readerIndex，写指针使用writerIndex，总缓冲区长度为size，现在需要写入m字节，则会有以下几种情形。</p><ul><li>当 m≤size-writerIndex时（即将写入的数据长度小于或等于写指针位置到缓冲区结束位置），可以直接在writerIndex位置写入。</li><li>当 m&gt;size-writerIndex 时，从 writerIndex 位置一直到缓冲区结束位置的内容已经不够写入了，可以对当前缓冲区未充分利用的内存进行整理。哪里有未充分使用的内存呢？为了充分利用空间，我们不会一开始就扩容，而是把未利用的空间充分利用，方法是：从预留空间结束位置到读指针之前的位置，该空间的数据已经被读取，先将读指针位置挪到预留空间结束处（即起始位置），然后将原来读指针之后的数据也挪到起始位置，最后将写指针向前挪到数据结束的位置。挪动后的缓冲区结构如下图所示。</li></ul><p><img src="https://s1.ax1x.com/2023/06/17/pClFFgJ.png" alt="pClFFgJ.png"></p><p>挪动之后，如果剩余空间足够写入 m字节的数据，则在新的writerIndex位置写入；如果挪动之后，剩余的空间仍然不够写入 m字节，则需要重新扩展缓冲区，即新建一个更大的缓冲区，将现有的缓冲区结构和数据复制过去。扩容示意图如下所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClFVD1.png" alt="pClFVD1.png"></p><p>关于接收缓冲区和发送缓冲区，需要另外强调几点。</p><ul><li>对于服务端程序来说，由于需要同时服务多个客户端，而每一路连接都会有一个接收缓冲区和发送缓冲区（per-socket buffer），所以不同连接从socket上读取出来但还没有被业务处理的数据，会被放在自己对应的接收缓冲区中；因TCP窗口太小暂时发不出去的数据，会被存放在自己所属连接的发送缓冲区中。服务进程、网络通信组件、连接对象和发送缓冲区、接收缓冲区的关系示意图如下图所示。</li><li>缓冲区的容量上限一般是有限制的，尤其对于服务程序，由于需要支持多个连接，所以为了节约内存，每个连接的接收缓冲区和发送缓冲区的初始容量一般都不会设置得很大。在缓冲区容量不足时应按需扩展，但一定要设置一个上限值，且这个上限值一般不会太大。</li></ul><p>对于发送缓冲区，如果较长时间内发送缓冲区中的数据都未发送出去，我们就可以认为这路连接出问题了，可以将该缓冲区回收并关闭连接。<br>同理，对于接收缓冲区，如果接收缓冲区中的数据一直滞留甚至积压，我们就要好好检查自己处理数据的逻辑是否有问题，看看为何不能及时处理数据。当然，在实际开发中还会遇到这样一种情况：对端短时间内向服务端发送了大量数据，此时我们需要做一个限制策略，例如3秒内某路连接接收缓冲区中的数据已经达到30MB，这时可以设置一个标志，不再从该路连接的 socket上继续读取数据，直到接收缓冲区中的数据被处理掉一部分，再清除该标志，以便继续从该连接的 socket上收取数据。这是一种常见的对单个连接限流的策略。</p><h3 id="服务端发送数据时对端一直不接收的问题"><a href="#服务端发送数据时对端一直不接收的问题" class="headerlink" title="服务端发送数据时对端一直不接收的问题"></a>服务端发送数据时对端一直不接收的问题</h3><p>这类问题一般出现在跨部门尤其是与外部开发人员合作时。假设现在有这样一种情形：我们的服务器对外提供服务，已经规定好协议格式，客户端由外部人员开发。<br>我们的服务端在向对端（客户端）发送数据时，对端可能因为一些问题（可能是逻辑bug或者其他一些问题）一直不从socket上收取数据，但服务端可能会定期产生一些数据发送给客户端，在发送一段时间后，由于 TCP 窗口太小，导致数据发送不出去，这样待发送的数据会在服务端相应连接的发送缓冲区中积压很久。如果我们不做任何处理，则服务很快会因为内存耗尽而被操作系统杀死。对于这种情况，一般建议从以下两方面增加防御措施。</p><ul><li><p>为每路连接的发送缓冲区大小设置上限（如 2MB，可以根据单个数据包的大小和业务情况来定），设置方法在上文中已经介绍过了。当某路连接上的数据发送不出去时，在将数据存入发送缓冲区前，先判断缓冲区的最大剩余空间（包括允许扩容后的容量），如果剩余空间已经小于我们要放入的数据大小，也就是说缓冲区中的数据大小超过了我们规定的缓冲区容量上限，我们就认为该连接出了问题，关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）即可。示例代码如下</p><pre><code class="cpp">size_t remainingLen = m_outputBuffer.remainingBytes();// 如果加入缓冲区中的数据长度超出了发送缓冲区的最大剩余量if (remainingLen &lt; dataToAppend.length()) &#123;    // 关闭连接    forceClose();    return;&#125;m_outputBuffer.append(static_cast&lt;const char*&gt;(dataToAppend.c_str()), dataToAppend.length());</code></pre></li><li><p>如果因为一些原因（可能是逻辑bug）导致一部分数据已经被积压在发送缓冲区中一段时间了，此后服务端未产生新的待发送的数据，此时发送缓冲区的数据容量未超过缓冲区上限。对此种情形若不做任何处理，发送缓冲区的数据就会一直积压，白白浪费系统资源。对于这种情形，我们一般会设置一个定时器，每隔一段时间（如6秒）检查一下在各路连接的发送缓冲区中是否还有数据未发送出去，也就是说，如果一个连接超过一定时间还存在未发送出去的数据，我们也认为该路连接出现问题，需要关闭该路连接并回收相应的资源（如清空缓冲区、回收套接字资源等）。示例代码如下   </p><pre><code class="cpp">// 每 3 秒检测一次const int SESSION_CHECK_INTERVAL = 6000;setTimer(SESSION_CHECK_TIMER_ID, SESSION_CHECK_INTERVAL);void CSessionManager::OnTimer() &#123;    for (auto iter = m_mapSession.begin(); iter != m_mapSession.end(); ++iter) &#123;        if (!CheckSession(iter-&gt;second)) &#123;            // 关闭 session，回收相关的资源            iter-&gt;second-&gt;ForceClose();            iter = m_mapSession.erase(iter);        &#125;    &#125;&#125;// 检测在相应连接的发送缓冲区中是否还有未发送的数据bool CSessionManager::CheckSession(CSession* pSession) &#123;    return pSession-&gt;GetConnection().m_outputBuffer.IsEmpty();&#125;</code></pre></li></ul><p>以上代码每隔6秒就会检测所有Session对应的Connection对象，如果发现发送缓冲区非空，则说明该连接的发送缓冲区中的数据已驻留6秒，将关闭该连接并清理资源。</p><h2 id="后端服务中的定时器设计"><a href="#后端服务中的定时器设计" class="headerlink" title="后端服务中的定时器设计"></a>后端服务中的定时器设计</h2><p>定时器模块是后端服务常用的功能之一，用于周期性地执行某些任务的场景中。设计定时器模块的方法很多，但关键是定时器的效率问题。让我们先从最简单的开始。</p><h3 id="最简单的定时器"><a href="#最简单的定时器" class="headerlink" title="最简单的定时器"></a>最简单的定时器</h3><p>一个最简单的定时器功能可以按如下思路实现：</p><pre><code>void* threadFunc(void* arg) &#123;    while (mbRunning) &#123;        // Sleep for 3 seconds        sleep(3);        // Check heartbeat for all sessions        checkSessionHeartbeat();    &#125;    return NULL;&#125;</code></pre><p>以上代码在一个独立的线程中每隔3秒对所有Session做一次心跳检测。这是一个非常简单的实现逻辑，有些读者可能会觉得这样做有点“简单粗暴”。其实，这段代码来源于一个真实的商业项目，至今仍然工作得很好。在一些特殊场景下，我们确实可以按这种思路来实现定时器，只不过可能将sleep函数换成一些可以设置超时或等待时间的、让线程挂起或等待的函数（如select、poll等）。但是上述实现定时器的方法适用场景太少，one thread one loop结构中的定时器才是重点.</p><h3 id="定时器设计的基本思路"><a href="#定时器设计的基本思路" class="headerlink" title="定时器设计的基本思路"></a>定时器设计的基本思路</h3><p>根据实际的场景需求，我们的定时器对象一般需要一个唯一标识、过期时间、重复次数、定时器到期时触发的动作，因此一个定时器对象可以被设计成如下结构</p><pre><code>typedef std::function&lt;void()&gt; TimerCallback;class Timer &#123;public:    Timer();    ~Timer();    void run(TimerCallback callback);    // Other implementations will be gradually completed in the following text...private:    int64_t m_id;    time_t m_expiredTime;    int32_t m_repeatedTimes;    TimerCallback m_callback;&#125;;</code></pre><p>注意，正如前面强调，在定时器回调函数 m_callback中不能有耗时或者阻塞线程的操作，如果存在这种操作，则为了不影响整个循环流的执行，需要将这些耗时或者阻塞的操作移到其他线程中。<br>使用定时器的one thread one loop结构如下：</p><pre><code>while (!m_bQuitFlag) &#123;    checkAndHandleTimers();    epollOrSelectFunc();    handleIOEvents();    handleOtherThings();&#125;</code></pre><p>我们在 check_and_handle_timers 函数中对各个定时器对象进行了处理（检测是否到期，如果到期，则调用相应的定时器函数完成定时任务）。先从最简单的情形开始讨论，将定时器对象放在一个std：：list对象中</p><pre><code>// Assuming the definition of Timer classvoid EventLoop::checkAndHandleTimers() &#123;    for (auto it = m_listTimers.begin(); it != m_listTimers.end(); ) &#123;        Timer* timer = *it;                // Check if the timer has expired        if (timer-&gt;isExpired()) &#123;            timer-&gt;run();            ++it;        &#125; else &#123;            ++it;        &#125;    &#125;&#125;</code></pre><p>为了方便管理所有定时器对象，我们可以专门新建一个TimerManager类对定时器对象进行管理，该对象提供了增加、移除和判断定时器是否到期等的接口：</p><pre><code>class TimerManager &#123;public:    TimerManager();    ~TimerManager();    int64_t addTimer(int32_t repeatedTimes, int64_t interval, const TimerCallback&amp; timerCallback);    bool removeTimer(int64_t timerId);    void checkAndHandleTimers();private:    std::list&lt;Timer*&gt; m_listTimers;&#125;;</code></pre><p>check_and_handle_timers函数的实现如下：</p><pre><code>void EventLoop::checkAndHandleTimers() &#123;    m_timerManager.checkAndHandleTimers();&#125;</code></pre><p>addTimer、removeTimer、checkAndHandleTimers的实现如下：</p><pre><code>int64_t TimerManager::addTimer(int32_t repeatedTimes, int64_t interval, const TimerCallback&amp; timerCallback) &#123;    Timer* pTimer = new Timer(repeatedTimes, interval, timerCallback);    m_listTimers.push_back(pTimer);    return pTimer-&gt;getId();&#125;bool TimerManager::removeTimer(int64_t timerId) &#123;    for (auto iter = m_listTimers.begin(); iter != m_listTimers.end(); ++iter) &#123;        if ((*iter)-&gt;getId() == timerId) &#123;            delete *iter;            m_listTimers.erase(iter);            return true;        &#125;    &#125;    return false;&#125;void TimerManager::checkAndHandleTimers() &#123;    for (auto iter = m_listTimers.begin(); iter != m_listTimers.end();) &#123;        if ((*iter)-&gt;isExpired()) &#123;            (*iter)-&gt;run();            if ((*iter)-&gt;getRepeatedTimes() &lt;= 0) &#123;                Timer* deletedTimer = *iter;                iter = m_listTimers.erase(iter);                delete deletedTimer;                continue;            &#125;        &#125;        ++iter;    &#125;&#125;</code></pre><p>在向 addTimer 函数传递必要的参数后创建一个 Timer 对象，并返回唯一标识该定时器对象的ID，后续就可以通过定时器ID操作这个定时器对象了。这里的定时器ID使用了一个单调递增的int64_t类型的整数，我们也可以使用其他类型，例如uid，只要能唯一区分每个定时器对象即可。当然，在这里的设计逻辑中，可能存在多个线程多个EventLoop，每个 EventLoop 都含有一个 m_timerManager 对象，但我们希望所有定时器 ID 都能够全局唯一，所以这里每次生成定时器ID 时都使用了一个整型原子变量的ID基数，将它设置为Timer对象的静态成员变量，在每次需要生成新的定时器ID时都将其递增1即可。这里利用C++11的std：：mutex对s_initialId进行保护：</p><p>完整代码：<br>Timer.h</p><pre><code>#ifndef __TIMER_H__#define __TIMER_H__#include &lt;functional&gt;typedef std::function&lt;void()&gt; TimerCallback;class Timer&#123;public:    /**    * @param repeatedTimes 定时器重复次数，设置为-1表示一直重复下去    * @param interval      下一次触发的时间间隔    * @param timerCallback 定时器触发后的回调函数    */    Timer(int32_t repeatedTimes, int64_t interval, const TimerCallback&amp; timerCallback);    ~Timer();    int64_t getId() const    &#123;        return m_id;    &#125;    int64_t getExpiredTime() const    &#123;        return m_expiredTime;    &#125;    bool isExpired();    int32_t getRepeatedTimes() const    &#123;        return m_repeatedTimes;    &#125;    void run();    //其他实现暂且省略private:    //定时器的id，唯一标识一个定时器    int64_t                     m_id;    //定时器的到期时间    time_t                      m_expiredTime;    //定时器重复触发的次数    int32_t                     m_repeatedTimes;    //定时器触发后的回调函数    TimerCallback               m_callback;    //触发时间间隔                    int64_t                     m_interval;    //定时器id基准值    static std::atomic&lt;int&gt;     s_initialId;&#125;;#endif //!__TIMER_H__</code></pre><p>Timer.cpp</p><pre><code>#include &quot;Timer.h&quot;#include &lt;time.h&gt;std::atomic&lt;int&gt; Timer::s_initialId = 0;Timer::Timer(int32_t repeatedTimes, int64_t interval, const TimerCallback&amp; timerCallback)&#123;    m_repeatedTimes = repeatedTimes;    m_interval = interval;    //当前时间加上触发间隔得到下一次的过期时间    m_expiredTime = (int64_t)time(nullptr) + interval;    m_callback = timerCallback;    //生成一个唯一的id    ++s_initialId;    m_id = s_initialId;&#125;bool Timer::isExpired()&#123;    int64_t now = time(nullptr);    return now &gt;= m_expiredTime;&#125;void Timer::run()&#123;    m_callback();    if (m_repeatedTimes &gt;= 1)    &#123;        --m_repeatedTimes;    &#125;    m_expiredTime += m_interval;&#125;</code></pre><p>TimerManager.h</p><pre><code>#ifndef __TIMER_MANAGER_H__#define __TIMER_MANAGER_H__#include &lt;stdint.h&gt;#include &lt;list&gt;#include &quot;Timer.h&quot;//std::list&lt;Timer*&gt; m_listTimers;// void EventLoop::check_and_handle_timers()// &#123;//     for (auto&amp; timer : m_listTimers)//     &#123;//         if (timer-&gt;isExpired())//         &#123;//             timer-&gt;run();//         &#125;//     &#125;// &#125;struct TimerCompare  &#123;      bool operator () (const Timer* lhs, const Timer* rhs)      &#123;          return lhs-&gt;getExpiredTime() &lt;  rhs-&gt;getExpiredTime();    &#125;&#125;; void defaultTimerCallback()&#123;&#125;class TimerManager&#123;public:    TimerManager() = default;    ~TimerManager() = default;    /** 添加定时器    * @param repeatedCount 重复次数    * @param 触发间隔    * @    * @return 返回创建成功的定时器id    */    int64_t addTimer(int32_t repeatedCount, int64_t interval, const TimerCallback&amp; timerCallback);    /** 移除指定id的定时器    * @param timerId 待移除的定时器id    * @return 成功移除定时器返回true，反之返回false    */    bool removeTimer(int64_t timerId);    /** 检测定时器是否到期，如果到期则触发定时器函数    */    void checkAndHandleTimers();private:    std::list&lt;Timer*&gt; m_listTimers;&#125;;#endif //!__TIMER_MANAGER_H__</code></pre><p>TimerManager.cpp</p><pre><code>#include &quot;TimerManager.h&quot;    int64_t TimerManager::addTimer(int32_t repeatedCount, int64_t interval, const TimerCallback&amp; timerCallback)&#123;    Timer* pTimer = new Timer(repeatedCount, interval, timerCallback);    m_listTimers.push_back(pTimer);    //对定时器对象按过期时间从小到大排序    m_listTimers.sort(TimerCompare());    return pTimer-&gt;getId();&#125;bool TimerManager::removeTimer(int64_t timerId)&#123;    for (auto iter = m_listTimers.begin(); iter != m_listTimers.end(); ++iter)    &#123;        if ((*iter)-&gt;getId() == timerId)        &#123;                m_listTimers.erase(iter);                return true;        &#125;    &#125;    return false;&#125;void TimerManager::checkAndHandleTimers()&#123;    //遍历过程中是否调整了部分定时器的过期时间    bool adjusted = false;    Timer* deletedTimer;       for (auto iter = m_listTimers.begin(); iter != m_listTimers.end(); )    &#123;        if ((*iter)-&gt;isExpired())        &#123;            (*iter)-&gt;run();                        if ((*iter)-&gt;getRepeatedTimes() == 0)            &#123;                //定时器不需要再触发时从集合中移除该对象                deletedTimer = *iter;                iter = m_listTimers.erase(iter);                delete deletedTimer;                continue;            &#125;            else             &#123;                ++iter;                //标记下集合中有定时器调整了过期时间                adjusted = true;            &#125;        &#125;        else        &#123;            //找到大于当前系统时间的定时器对象就不需要继续往下检查了，退出循环            break;        &#125;// end if          &#125;// end for-loop    //由于调整了部分定时器的过期时间，需要重新排序一下    if (adjusted)    &#123;        m_listTimers.sort(TimerCompare());    &#125;&#125;</code></pre><p>以上就是定时器的基本设计思路，我们一定要明白在这个流程中一个定时器对象具有哪些属性，以及如何管理定时器对象。当然，这里自顶向下一共有三层，分别是 EventLoop、TimerManager、Timer，其中TimerManager 对象不是必需的，在一些设计中直接用EventLoop封装的相应方法对Timer对象进行管理。理解one thread one loop中定时器的设计思路之后，我们来看看上述定时器实现中的性能问题</p><h3 id="定时器逻辑的性能优化"><a href="#定时器逻辑的性能优化" class="headerlink" title="定时器逻辑的性能优化"></a>定时器逻辑的性能优化</h3><p>上述定时器实现存在严重的性能问题，即每次检测定时器对象是否触发时都要遍历整个定时器集合，移除定时器对象时也需要遍历整个定时器集合。我们其实可以将定时器对象按过期时间从小到大排序，这样检测定时器对象时，只要从最小过期时间开始检测即可，一旦找到过期时间大于当前时间的定时器对象，就不需要继续检测后面的定时器对象了。</p><h4 id="定时器对象集合的数据结构优化"><a href="#定时器对象集合的数据结构优化" class="headerlink" title="定时器对象集合的数据结构优化"></a>定时器对象集合的数据结构优化</h4><p>我们可以在每次将定时器对象添加到集合时都自动进行排序，如果仍然使用 std：：list作为定时器集合，则可以给 std：：list 自定义一个排序函数（从小到大排序），代码实现如下：</p><pre><code>// Timer.hclass Timer &#123;public:    // Other member functions and variables        int64_t getExpiredTime() const &#123;        return m_expiredTime;    &#125;        // Other member functions&#125;;// TimerManager.hstruct TimerCompare &#123;    bool operator()(const Timer* lhs, const Timer* rhs) const &#123;        return lhs-&gt;getExpiredTime() &lt; rhs-&gt;getExpiredTime();    &#125;&#125;;class TimerManager &#123;public:    // Other member functions and variables    private:    std::list&lt;Timer*&gt; m_listTimers;    std::priority_queue&lt;Timer*, std::vector&lt;Timer*&gt;, TimerCompare&gt; m_timerQueue;    // Other member variables&#125;;</code></pre><p>每次添加定时器时都调用自定义排序函数对象 TimerCompare</p><pre><code>int64_t TimerManager::addTimer(int32_t repeatedCount, int64_t interval, const TimerCallback&amp; timerCallback) &#123;    Timer* pTimer = new Timer(repeatedCount, interval, timerCallback);    m_listTimers.push_back(pTimer);        // Sort the timer objects based on their expired time in ascending order    m_listTimers.sort(TimerCompare());        return pTimer-&gt;getId();&#125;</code></pre><p>将定时器对象按过期时间从小到大排好序后，检测各个定时器对象是否触发时不用再遍历整个定时器对象集合，只要从过期时间最小的定时器对象开始检测，一直找到过期时间大于当前系统时间的定时器对象就可以停止检测了，实现逻辑如下：</p><p>在以上代码中有个细节需要注意：假设现在的系统时刻是now，定时器集合中定时器的过期时间从小到大依次为t1、t2、t3、t4、t5……tn，假设t4 &lt; now &lt; t5，即此刻t1、t2、t3、t4对应的定时器会触发，触发后，会从t1、t2、t3、t4中减去相应的时间间隔，更新后的t1′、t2′、t3′、t4′就不一定小于 t5～tn了，因此需要再次对定时器集合进行排序。但是存在一种情形：t1～t5触发后对应的触发次数正好变为0，因此需要从定时器列表中移除它们，在这种情形下就不需要对定时器列表进行排序了。因此以上代码使用了一个adjusted变<br>量记录是否有过期时间被更新且未被从列表中移除的定时器对象，如果有，则之后再次对定时器集合进行排序。上述设计虽然解决了定时器遍历效率低下的问题，但是无法解决移除一个定时器时仍然需要遍历的问题，使用链表结构的std：：list插入非常方便，但定位某个具体元素的效率较低。我们可以将std：：list 转换成 std：：map，当然，我们仍然需要对 std：：map 中的定时器对象按过期时间进行自定义排序。</p><pre><code>void TimerManager::checkAndHandleTimers() &#123;    bool adjusted = false;    Timer* deletedTimer;        for (auto iter = m_listTimers.begin(); iter != m_listTimers.end();) &#123;        if ((*iter)-&gt;isExpired()) &#123;            // Execute the timer task in the run function, which may adjust the expired time            (*iter)-&gt;run();                        if ((*iter)-&gt;getRepeatedTimes() &lt;= 0) &#123;                // Remove the timer object from the collection if it doesn&#39;t need to trigger anymore                deletedTimer = *iter;                iter = m_listTimers.erase(iter);                delete deletedTimer;                continue;            &#125;            else &#123;                ++iter;                // Mark the flag as adjusted if the expired time of a timer is adjusted during the iteration                adjusted = true;            &#125;        &#125;        else &#123;            // If a timer object with an expired time greater than the current system time is found,            // there is no need to continue checking, exit the loop            break;        &#125;    &#125;        // Since some timer objects&#39; expired times have been adjusted, it&#39;s necessary to re-sort the collection    if (adjusted) &#123;        m_listTimers.sort(TimerCompare());    &#125;&#125;</code></pre><p>为了提高定时器的效率，我们一般采用两种常用的方法：时间轮和时间堆。<br>时间轮的基本思想是将现在时刻t加上一个时间间隔interval，以interval为步长，将各个定时器对象的过期时间按步长分布在不同的时间槽（time slot）中，当在一个时间槽中出现多个定时器对象时，这些定时器对象按加入槽的顺序串成链表，时间轮的示意图如下所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClAyNV.png" alt="pClAyNV.png"></p><p>因为每个时间槽的时间间隔都是一定的，因此对时间轮中的定时器对象的检测会有两种方法。</p><ul><li>在每次检测时都判断当前系统时间处于哪个时间槽中，比该槽序号小的槽中的所有定时器都已到期，执行对应的定时器函数之后，移除不需要重新触发的定时器，或重新计算需要下一次触发的定时器对象的时间并重新计算，将其移到新的时间槽中。这适用于oneloop one thread结构。</li><li>在每次检测时都假设当前时间与之前相比跳动了一个时间轮的间隔，适用场景较少，不适用于one loop one thread结构。时间轮实际上是将一个链表按时间分组，这虽然提高了一些效率，但还是存在问题，尤其是某个时间槽对应的链表较长时。时间堆指利用数据结构中小根堆（Min Heap）到期时间的大小来组织定时器对象，如下图所示，图中小根堆的各个节点都代表一个定时器对象，它们按过期时间从小到大排列。使用小根堆在管理定时器对象和执行效率上都要优于前面方案中的 std：：list 和std：：map，这是目前一些主流网络库中涉及定时器部分的实现，例如Libevent。笔者在实际项目中会使用 stl 提供的优先队列即 std：：priority_queue 作为定时器的实现，使用std：：priority_queue 的排序方式是从小到大，这是因为 std：：priority 从小到大排序时，其内部实现的数据结构也是小根堆。</li></ul><h3 id="对时间的缓存"><a href="#对时间的缓存" class="headerlink" title="对时间的缓存"></a>对时间的缓存</h3><p>在使用定时器功能时，免不了要使用获取操作系统时间的函数，而在大多数操作系统上，获取系统时间的函数都属于系统调用，一次系统调用相于one thread one loop结构中的其他逻辑来说可能耗时更多。因此为了提高效率，在一些对时间要求精度不是特别高的情况下，我们可能会缓存一些时间，在较近的下次如果需要系统时间，则可以使用上次缓存的时间，而不是再次调用获取系统时间的函数。目前有不少网络库和商业服务在定时器逻辑这一块都使用了这一策略</p><pre><code>while (!m_bQuitFlag) &#123;    // Get the system time and cache it for later use    auto cachedTime = get_system_time_and_cache();    // Perform some quick operations using the cached system time    do_something_quickly_with_system_timer();    // Use the cached time to check and handle timers    use_cached_time_to_check_and_handle_timers();    epoll_or_select_func();    handle_io_events();    handle_other_things();&#125;</code></pre><p>最后总结一下：定时器的实现原理和逻辑并不复杂，关键点是如何为定时器对象集合设计出高效的数据结构，使每次从定时器集合中增加、删除、修改和遍历定时器对象时都更高效。另外，为了进一步提高定时器逻辑的执行效率，在某些场景下，我们可以利用上次缓存的系统时间来避免再一次调用获取时间的系统API的开销。定时器的设计还有其他一些需要考虑的问题，例如定时器逻辑如何解决服务器机器时间被人为提前或者延后，以及定时器事件的时间精度等，可以自行研究和解决。</p><h2 id="处理业务数据时是否一定要单独开线程"><a href="#处理业务数据时是否一定要单独开线程" class="headerlink" title="处理业务数据时是否一定要单独开线程"></a>处理业务数据时是否一定要单独开线程</h2><p>一个loop的主要结构一般如下：</p><pre><code>while (!m_bQuitFlag) &#123;    epoll_or_select_func();    handle_io_events();    handle_other_things();&#125;</code></pre><p>对于一些业务逻辑处理较简单、不会太耗时的应用来说，handle_io_events方法除了可以用来收发数据，也可以直接用来做业务逻辑处理。在这种情形下，handle_io_events方法的逻辑结构如下</p><pre><code>void handle_io_events() &#123;    // 收发数据    recv_or_send_data();    // 解包并处理数据    decode_packages_and_process();&#125;</code></pre><p>其中，在recv_or_send_data方法中调用send&#x2F;recv API进行网络数据收发操作。以收数据为例，收完数据并将其存入接收缓冲区后，接下来进行解包处理，然后进行业务处理。比如对于一个登录数据包的处理，其业务一般是验证登录的账户和密码是否正确并记录其登录行为等。从程序函数调用堆栈来看，这些业务处理逻辑其实是直接在网络收发数据线程中处理的，即网络线程调用 handle_io_events 方法，在 handle_io_events 方法中调用decode_packages_and_process方法，在decode_packages_and_process方法中做具体的业务逻辑处理，示意图如下。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClEFgg.png" alt="pClEFgg.png"></p><p>为了让网络层与业务层脱耦，在网络层中通常会提供一些回调函数的接口，我们可以将这些回调函数指向具体的业务处理函数。以libevent网络库的用法为例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;event2/event.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8080// 自定义的连接回调函数void listener_cb(struct evconnlistener* listener, evutil_socket_t fd, struct sockaddr* addr, int socklen, void* arg) &#123;    // 处理新的连接    printf(&quot;New connection accepted.\n&quot;);    // ...&#125;// 自定义的信号回调函数void signal_cb(evutil_socket_t sig, short events, void* arg) &#123;    // 处理信号事件    printf(&quot;Signal event received.\n&quot;);    // ...&#125;int main(int argc, char** argv) &#123;    struct event_base* base;    struct evconnlistener* listener;    struct event* signal_event;    struct sockaddr_in sin;    base = event_base_new();    memset(&amp;sin, 0, sizeof(sin));    sin.sin_family = AF_INET;    sin.sin_port = htons(PORT);    // 创建监听器并绑定回调函数    listener = evconnlistener_new_bind(base, listener_cb, (void*)base,        LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin));    if (!listener) &#123;        fprintf(stderr, &quot;Could not create a listener!\n&quot;);        return 1;    &#125;    // 创建信号事件并添加回调函数    signal_event = evsignal_new(base, SIGINT, signal_cb, (void*)base);    if (!signal_event || event_add(signal_event, NULL) &lt; 0) &#123;        fprintf(stderr, &quot;Could not create/add a signal event!\n&quot;);        return 1;    &#125;    // 启动事件循环    event_base_dispatch(base);    // 释放资源    evconnlistener_free(listener);    event_free(signal_event);    event_base_free(base);    printf(&quot;Done.\n&quot;);    return 0;&#125;</code></pre><p>以上代码根据libevent自带的helloworld示例修改而来，其中listener_cb和signal_cb是自定义的回调函数，有相应的事件触发后，libevent的事件循环会调用我们设置的回调，在这些回调函数中，我们可以编写自己的业务逻辑代码。<br>这种基本的服务器结构如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClEw8O.png" alt="pClEw8O.png"></p><p>以上示意图展示了这个结构的基本逻辑，在这结构的基础上可以延伸出很多变体。在解包、业务逻辑处理部分（位于handle_io_events（）的decode_packages_and_process方法中），如果业务逻辑处理过程比较耗时（例如，从数据库取大量数据、写文件），就会导致网络线程在这些操作上停留时间很长，很久以后才能执行下一次循环，影响网络事件的检测和数据收发的及时性，导致整个程序的效率低下。<br>因此对于这种情形，我们需要将业务处理逻辑单独拆分出来交给另外的业务工作线程处理，业务工作线程可以是单独一个线程，也可以是含有一组线程的线程池，业务数据从网络线程组流向业务线程组。这样的程序结构如下图所示</p><p><img src="https://s1.ax1x.com/2023/06/17/pClE02D.png" alt="pClE02D.png"></p><p>在上图中，对于网络线程将业务数据包交给业务线程的流程，可以使用一个共享的业务数据队列来实现，此时网络线程是生产者，业务线程从业务数据队列中取出任务去处理，业务线程是消费者。业务线程在处理完成后如需将结果数据发送出去，则再将数据交给网络线程。这时，经过处理的数据会从业务线程再次流向网络线程，那么如何将数据从业务线程交给网络线程呢？以发送数据为例，一般有三种方法。</p><ul><li>直接调用相应的发送数据的方法，如果我们的网络线程本身也会调用这些发送数据的方法，那么此时网络线程和业务线程可能同时对发送数据的方法进行调用，相当于多个线程同时调用 socket send 函数，这样可能导致同一个连接上的数据顺序有问题。此时应该利用锁机制，保证同一时刻只有一个线程可以调用发送数据的方法。这里给出一段伪代码，假设TcpConnection对象表示某路连接，则无论是网络线程还是业务线程，在处理完数据后需要发送数据时都会调用TcpConnection：：sendData 方法，TcpConnection：：sendData方法的实现如下<pre><code class="cpp">#include &lt;mutex&gt;#include &lt;string&gt;class Tcpconnection &#123;public:    void sendData(const std::string&amp; data) &#123;        std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForConnection);        // 在这里调用 socket 的 send 函数        // ...    &#125;private:    std::mutex m_mutexForConnection;&#125;;</code></pre></li></ul><p>但是，该方法在设计上存在不足之处，即发送数据应该是网络层的事情，不能由其他模块（这里指业务线程）越俎代庖。</p><ul><li>在存在定时器结构的情况下，业务线程可以将需要发送的数据放入另一个共享区域中（例如相应的 TcpConnection对象的一个成员变量中），定时器定时将其从这个共享区域中取出来，再发送出去。该方法的优点是网络线程做了它该做的事情，缺点是需要添加定时器，程序逻辑变得复杂，而且定时器每隔一段时间才会触发，发送的数据可能会有一定的延迟。</li><li>利用线程执行流中的handle_other_things方法，这个函数可以在需要执行时通过唤醒机制唤醒。业务线程将数据放入某个共享区域中作为“其他事情”，然后在handle_other_things 函数中执行数据的发送。如果读到这里时仍能思路清晰，则说明读者已经大致明白一个不错的服务器框架的实现方式了。</li></ul><p>在实际应用中，很多程序的业务逻辑处理其实是不耗时的，也就是说，这些业务逻辑的处理速度很快。由于CPU核数有限，所以在线程数量超过CPU数量时，各个线程（网络线程和业务线程）也不是真正地并行执行，即使开了一组业务线程也不一定真正地并发执行。在这种业务逻辑处理不耗时的情况下，可以在网络线程里面直接处理业务逻辑，这样并不会影响网络线程的执行效率。前面讲到，在handle_io_events方法中会直接处理业务逻辑，如果在处理业务逻辑时会产生新的任务，则可以将这些新任务作为“其他事情”投递给网络线程，最终的网络线程的handle_other_things方法会处理这些新任务。此时的服务器程序结构如下图所示。再次强调：利用 handle_io_events 或 handle_other_things 方法处理业务逻辑，仅适用于业务逻辑中不会有耗时操作的场景，如果在handle_io_events方法或handle_other_things方法中有耗时操作，则还需要单独开业务线程。虽然线程数量超过 CPU数量时，各个线程不会真正并行，但那是操作系统线程调度的事情，做应用层开发时不必关心这一点。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClEgat.png" alt="pClEgat.png"></p><h2 id="非侵入式结构与侵入式结构"><a href="#非侵入式结构与侵入式结构" class="headerlink" title="非侵入式结构与侵入式结构"></a>非侵入式结构与侵入式结构</h2><p>在通常情况下，一个后端服务器的结构是无法固定下来的，因为我们不知道在服务的技术框架上面会搭建什么业务，结构随着业务的不同而不同。如果是这样的话，我们是不是就无法讨论和抽象出一个可以适用于大多数业务场景的服务程序结构了呢？其实未必，大多数服务都会与其他服务或客户端进行网络通信，那么这个服务一定包含网络通信模块。这样的话，网络通信模块将是不同业务的服务都有的一部分。以此为支点，我们尝试继续探究一套适用于大多数业务的通用程序结构。<br>在假设网络通信框架结构确定的情况下，根据通信数据从网络框架中流入流出的情况，我们将服务程序的结构分为非侵入式结构和侵入式结构两种</p><h3 id="非侵入式结构"><a href="#非侵入式结构" class="headerlink" title="非侵入式结构"></a>非侵入式结构</h3><p>非侵入式结构更简单一点，我们先来讨论它。非侵入式，指的是一个服务中的所有通信或业务数据都在网络通信框架内部流动，也就是说没有外部数据源注入网络通信模块或从网络通信模块中流出。举个例子，一个IM服务程序，在通常情况下，无论是单聊消息还是群聊消息，其核心业务本身的数据流都是在网络通信模块内部流动的。单聊时，A用户向B用户发送一条消息，实际上消息流是从A用户的Connection对象传递到B用户的Connection 对象上的，然后通过 B 的Connection 对象的发送方法将数据发送出去。群聊也一样，数据从一个用户的Connection对象同时传递给其他多个用户的Connection对象。无论是哪种情况，这些Connection对象都是网络通信模块的内部结构</p><h3 id="侵入式结构"><a href="#侵入式结构" class="headerlink" title="侵入式结构"></a>侵入式结构</h3><p>如果有外部消息流入网络通信模块或从网络通信模块流出，就相当于有外部消息“侵入”网络通信结构，我们把这种服务器结构称为侵入式服务结构，示意图如下所示。<br>侵入式服务器的结构除网络通信组件外，其他组件的结构设计可以多种多样。来看两种通用结构。</p><ul><li><p>通用结构一：业务线程（或称数据源线程）将数据处理后交给网络通信组件发送。</p></li><li><p>通用结构二：网络解包后需要将任务交给专门的业务线程处理，处理完后需要再次通过网络通信组件发送出去。<br>通用结构一其实是通用结构二的后半部分，因此这里重点讨论通用结构二。<br>在one thread one loop思想下，每个网络线程的基本结构都如下</p><p>  while (!m_bouitFlag) {<br>  epoll_or_select_func();<br>  handle_io_events();<br>  handle_other_things();<br>  }</p></li></ul><p>若handle_io_events收完网络数据后解包，则由于解包后得到的任务处理逻辑比较耗时，所以需要把这些任务交给专门的业务线程处理。业务线程可以是一组工作的消费者线程，我们可以将这些任务放在某个队列中。这里网络组件的线程（网络线程）是生产者，业务工作线程是消费者，我们可以使用互斥体、临界区（CriticalSection，Windows系统特有）或条件变量等技术协调生产者和消费者，也就是说会涉及一个公共队列系统。这是一种常用的实现，数据会从网络组件流向业务组件。<br>接下来，如果业务组件需要对处理后的数据做网络通信操作，则此时如何将处理后的数据由业务组件交给网络组件呢？一般有两种方法，下面会详细讲解这两种方法</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>直接通过某些标识（如业务对应的socket fd、sessionID 等）找到这些数据在网络组件中对应的session，利用这些session将数据直接发送出去。<br>例如，在某个场景下，业务组件在处理完数据后需要将这些数据发送给所有用户，示例代码如下：</p><pre><code>void WebSocketSessionManager::pushDataToAll(const std::string&amp; dataToPush) &#123;    std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForSession);    for (auto&amp; session : m_mapsessions) &#123;        session.second-&gt;pushSomeData(dataToPush);    &#125;&#125;</code></pre><p>在以上代码中，业务组件只要拿到网路组件管理所有 session 的对象WebSocketSessionManager即可，然后利用WebSocketSessionManager对象的pushDataToAll方法将数据发送给所有用户。dataToPush 是需要发送给所有用户的数据，因此在pushDataToAll 方法中遍历所有 Session 对象（Session 对象被记录在 m_mapSessions 中）并通过Session对象挨个发送dataToPush。如果业务组件处理后的数据是发送给某个用户的，则示例代码如下：</p><pre><code>bool WebsocketSessionManager::pushDataToSingle(const std::string&amp; accountID, const std::string&amp; dataToPush) &#123;    std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForSession);    for (auto&amp; session : m_mapsessions) &#123;        if (session.second-&gt;isAccountIDMatched(accountID)) &#123;            session.second-&gt;pushSomeData(dataToPush);            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>以上代码中的业务组件根据数据中的accountID定位到网络组件中的具体session，然后将数据发送给该session对应的用户。这是业务组件处理完数据后向网络线程传送数据的常用方法，但存在如下两个缺点。<br>缺点一<br>这里从调用关系来看，实际上是业务线程调用网络线程相关的接口函数发送数据的，也就是说，其本质上是业务组件直接发起的网络操作。如果按功能来划分，则发送数据应该属于网络线程的功能，业务线程不应该发送数据。由于Session对象属于网络线程（网络线程管理着Session对象的生命周期），而这里的业务线程直接操作了Session对象，因此在以上示例代码中使用了 mutex（成员变量m_mutexForSession）在相应的发送函数中对Session对象集合m_mapSessions进行保护。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClVki6.png" alt="pClVki6.png"></p><p>虽然这种做法不太合理，但实际上很多服务程序都在这么做：当业务组件调用这些发送方法时，通过 mutex将这些session锁定。然而这样做存在一个效率问题，这里还是以上面向所有用户发送数据的示例来说明这个问题：</p><pre><code>void WebSocketSessionManager::pushDataToAll(const std::string&amp; dataToPush) &#123;    std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForSession);    for (auto&amp; session : m_mapSessions) &#123;        session.second-&gt;pushSomeData(dataToPush);    &#125;&#125;</code></pre><p>这段代码实际上调用了每个session对象的pushSomeData方法（加粗代码行），如果Session对象的pushSomeData方法耗时较长（耗时较长是相对来说的，在实际开发中要避免让这个函数耗时过长），则由于记录 Session对象的 m_mapSessions对象此时正被业务模块（业务线程）使用，所以如果网络线程想修改m_mapSessions对象，就必须等业务线程调用WebSocketSessionManager：：pushDataToAll函数结束，这可能会影响网络线程的执行效率。因此有些开发者会这么设计：</p><pre><code>void WebSocketSessionManager::pushDataToAll(const std::string&amp; dataToPush) &#123;    std::map&lt;int64_t, BusinessSession*&gt; mapLocalSessions;    &#123;        std::lock_guard&lt;std::mutex&gt; scoped_lock(m_mutexForSession);        // 从m_mapSessions拷贝session对象指针到mapLocalSessions        mapLocalSessions = m_mapSessions;    &#125;        // 这里使用mapLocalSessions，让网络线程继续操作m_mapSessions    for (auto&amp; session : mapLocalSessions) &#123;        session.second-&gt;pushSomeData(dataToPush);    &#125;&#125;</code></pre><p>以上代码使用了一个临时变量 mapLocalSessions 将在m_mapSessions 中记录的Session指针复制一份出来，这样的话，m_mutexForSession锁保护的范围就大幅度减小了，业务线程可以尽快释放对m_mapSessions的占用，网络线程可以很快地使用m_mapSessions。<br>这个看似很不错的设计方案，却存在着严重的错误：记录在m_mapSessions 和mapLocalSessions 中的各个Session指针都指向一个对象，倘若此时某个连接断开，网络线程就会销毁 m_mapSessions中相应的 Session 对象，然而业务线程还可能拿着这个Session对象的指针继续操作（这里是发数据），此时这个指针已经是一个野指针了，所以会导致程序崩溃。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClVMdI.png" alt="pClVMdI.png"></p><p>有的读者会说，在mapLocalSessions中记录的Session对象不要使用原始指针，可以使用一个智能指针，但该智能指针不管理该Session的生命周期，如下所示：</p><pre><code>std: :map&lt;int64_t,std::weak_ptr&lt;BusinessSession&gt;&gt; mapLocalSessions;</code></pre><p>在决定是否使用一个Session对象前，这样做可以及时发现该Session对象是否有效，但若业务线程正在使用某个 Session 对象，进入session.second-&gt;pushSomeData函数后，Session被网络线程回收了，则业务线程访问该Session对象的任何成员变量时都会因访问非法内存而导致程序崩溃。所以，这是不正确的设计，在这种场景下千万不要使用这种减小<br>锁范围的技术。为保证性能，应该尽量让session.second-&gt;pushSomeData函数的实现逻辑运行起来更快一点。</p><p>缺点二<br>方法一在一些场景中存在严重错误，假设我们的服务存在如下两条信息流。</p><ul><li>信息流一：业务组件产生的数据需要发送。</li><li>信息流二：网络线程本身与客户端或者下游服务交互后产生的数据也要发送。<br>这两类数据如果被发送给同一个连接，但这两类数据有一定的顺序要求，则这样会很糟糕：因为在这样的设计中，业务线程会间接使用某个Session发送数据，网络线程会直接使用同一个Session发送数据，相当于多个线程同时调用send函数在同一个socket上发送数据，这样的话，每个单独的数据包不一定会出错，但是多个数据包之间的顺序就可能不正确了。来看一个交易系统的行情推送服务，在客户端订阅了某类行情信息后，行情推送服务的网络模块会通过一个内部的 RPC 请求服务去拉取一个全量数据t并推送给客户端，同时行情推送服务的业务模块会从RocketMQ中取出增量数据t1、d2、t3、d4等（t系列增量数据用于改造全量数据t），然后侵入网络组件发送给客户端。客户端在收到增量数据后会以全量数据为基础，对全量数据进行增删改操作，也就是说在用户未收到全量数据之前，会丢弃其收到的增量数据（业务场景决定客户端无法在收到全量数据之前对增量数据进行缓存）。但在被丢弃的增量数据中可能有一部分属于这个全量数据，客户端在收到全量数据后再利用后续新收到的增量数据去改造全量数据，这样改造后的全量数据就可能不正确了</li></ul><p><img src="https://s1.ax1x.com/2023/06/17/pClV3Jf.png" alt="pClV3Jf.png"></p><p>这就是方法一不适用的场景，即侵入网络组件的其他组件产生的数据有多个源，且多个源有顺序要求。反过来说，如果侵入网络组件产生的数据源只有一个，或者有多个数据源但数据源之间的数据没有顺序依赖，则这种设计是适用的。<br>方法一不适用的场景示意图如下</p><p><img src="https://s1.ax1x.com/2023/06/17/pClV8W8.png" alt="pClV8W8.png"></p><p>那么对于有多个数据源且数据源之间的数据有顺序依赖的情况，有没有办法继续使用方法一呢？有：可以在多个数据源处理完数据后，交给一个专门将数据源排序的组件，再由排序组件统一调用网络组件的数据发送模块。需要注意的是，也要将网络组件内部产生的需要发送的数据交给排序组件。示意图如下</p><p><img src="https://s1.ax1x.com/2023/06/17/pClVJSS.png" alt="pClVJSS.png"></p><p>对这种场景可以举一个例子，我们在做交易系统的行情推送服务时，由于推送的数据有多个来源，有的来源于RocketMQ模块，有的来源于管理后台接口，有的来源于网络通信模块内部，所以需要将这三类数据按一定的顺序发送给用户。笔者就是采用以上示意图展示的结构来设计的，对其中的排序组件使用了一个队列，让来自不同数据源的数据按一定顺序进入队列中，排序组件从队列中挨个取出排好序的数据，接着调用网络通信组件的数据发送模块进行发送。</p><p>方法二<br>方法一是在业务组件里面直接调用网络组件的，有点越俎代庖。<br>方法二是将业务组件需要发送的数据交给网络组件自己去发送的，常用的实现方法是将对应的数据加入数据所属的那个连接的网络线程中。再来看看这个结构：</p><pre><code>while (!m_bQuitFlag) &#123;    epoll_or_select_func();    handle_io_events();    handle_other_things();&#125;</code></pre><p>可以使用另一个队列，业务组件将数据交给这个队列，然后告知对应的网络组件中的线程需要收取任务并执行。这个逻辑在前面介绍过了，即利用唤醒机制执行handle_other_things函数。这里给出一种实现，业务组件调用 EventLoop：：runInLoop 方法将数据交给队列，EventLoop：：runInLoop方法的实现如下：</p><pre><code>void EventLoop::runInLoop(const Functor&amp; taskCallback) &#123;    if (isInLoopThread()) &#123;        taskCallback();    &#125; else &#123;        queueInLoop(taskCallback);    &#125;&#125;</code></pre><p>以上代码中的taskCallback是需要执行的任务，由于业务线程和网络线程不是同一个线程，因此会执行EventLoop：：queueInLoop方法，这样任务就被放到EventLoop的成员变量m_pendingFunctors容器中了，然后调用唤醒函数 wakeup。EventLoop：：queueInLoop方法的实现如下：</p><pre><code>void EventLoop::queueInLoop(const Functor&amp; taskCallback) &#123;    std::unique_lock&lt;std::mutex&gt; lock(m_mutex);    m_pendingFunctors.push_back(taskCallback);    if (!isInLoopThread() || m_doingOtherThings) &#123;        wakeup();    &#125;&#125;</code></pre><p>通过这个流程，可以让网络组件本身去发送业务组件交给它的数据。<br>希望读者能深刻理解侵入式服务结构和非侵入式服务结构的特点和细节，以及侵入式服务结构中网络组件与业务组件交换数据的两种方法，根据实际业务设计出高质量的服务框架。</p><h2 id="带有网络通信模块的服务器的经典结构"><a href="#带有网络通信模块的服务器的经典结构" class="headerlink" title="带有网络通信模块的服务器的经典结构"></a>带有网络通信模块的服务器的经典结构</h2><p>我们将监听 socket称为 listenfd，将由调用accept函数返回的 socket称为clientfd。</p><h3 id="为何要将listenfd设置成非阻塞模式"><a href="#为何要将listenfd设置成非阻塞模式" class="headerlink" title="为何要将listenfd设置成非阻塞模式"></a>为何要将listenfd设置成非阻塞模式</h3><p>我们知道，如果需要使用I&#x2F;O复用函数统一管理各个fd，则需要将clientfd设置成非阻塞模式，那么 listenfd 一定要被设置成非阻塞模式吗？答案是不一定——只要不用 I&#x2F;O复用函数去管理 listenfd就可以了。如果 listenfd 不被设置成非阻塞模式，那么 accept 函数在没有新连接时就会阻塞。<br>1.结构一：listenfd为阻塞模式，为listenfd独立分配一个接受连接线程有很多服务程序结构确实采用了阻塞模式的 listenfd，为了不让accept函数在没有连接时因阻塞对程序的其他逻辑执行流造成影响，我们通常将 accept函数放在一个独立的线程中。这个线程的伪代码如下：</p><pre><code>void* acceptThreadFunc(void* param) &#123;    // 可以在这里做一些初始化工作        while (!退出标志) &#123;        struct sockaddr_in clientAddr;        socklen_t clientAddrLen = sizeof(clientAddr);                // 没有连接时，线程会被阻塞在 accept 函数处        int clientFd = accept(listenFd, (struct sockaddr*)&amp;clientAddr, &amp;clientAddrLen);        if (clientFd == -1) &#123;            // 出错了，可以在此做一些清理资源动作，例如关闭 listenFd            break;        &#125;                // 将 clientFd 交给其他 I/O 线程的工作复用函数        // 由于跨线程操作，所以需要使用锁对公共操作的资源进行保护    &#125;        return nullptr;&#125;</code></pre><p>其他I&#x2F;O线程的结构依旧是利用I&#x2F;O复用函数处理clientfd的onethread one loop结构，这里以epoll_wait为例：</p><pre><code>void* ioThreadFunc(void* param) &#123;    // 可以在这里做一些初始化工作        while (!退出标志) &#123;        epoll_event epollEvents[1024];                // 所有 clientFd 都被挂载到 epollFd，由 epoll_wait 统一检测读写事件        int numEvents = epoll_wait(epollFd, epollEvents, 1024, 1000);                // 在 epoll_wait 返回时处理对应 clientFd 上的读写事件                // 其他一些操作    &#125;        return nullptr;&#125;</code></pre><p>当然，这里的I&#x2F;O线程可以存在多个，结构示意图如下。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClVTSO.png" alt="pClVTSO.png"></p><p>将clientfd从accept_thread_func交给io_thread_func的方法也有很多，这里以使用一个互斥锁进行实现为例：</p><pre><code>std::vector&lt;int&gt; g_vecClientfds;std::mutex g_clientfdMutex;void* acceptThreadFunc(void* param) &#123;    // 可以在这里做一些初始化工作        while (!退出标志) &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);                // 没有连接时，线程会被阻塞在 accept 函数处        int clientfd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);                if (clientfd != -1) &#123;            // 出错了，可以在此做一些清理资源动作，例如关闭 listenfd            break;        &#125;                // 将 clientfd 交给其他 I/O 线程的复用函数        // 由于是跨线程操作，所以需要使用锁对公共操作的资源进行保护        std::lock_guard&lt;std::mutex&gt; scopedLock(g_clientfdMutex);        g_vecClientfds.push_back(clientfd);    &#125;&#125;void ioThreadFunc(void* param) &#123;    // 可以在这里做一些初始化工作        while (退出标志) &#123;        epoll_event epoll_events[1024];                // 将所有 clientfd 都挂载到 epollfd，由 epoll_wait 统一检测读写事件        int numEvents = epoll_wait(epollfd, epoll_events, 1024, 1000);                // 在 epoll_wait 返回时处理对应 clientfd 的读写事件                // 其他一些操作                // 从共享变量 g_vecClientfds 中取出新的 clientfd        retrieveNewClientfds(epollfd);    &#125;&#125;void retrieveNewClientfds(int epollfd) &#123;    std::lock_guard&lt;std::mutex&gt; scopedLock(g_clientfdMutex);        if (!g_vecClientfds.empty()) &#123;        // 遍历 g_vecClientfds 取出各个 fd，设置 fd 挂载到所在线程的 epollfd 上        // 在全部取出后，清空 g_vecClientfds        for (auto&amp; fd : g_vecClientfds) &#123;            // 设置 fd 挂载到 epollfd 上的操作        &#125;                g_vecClientfds.clear();    &#125;&#125;</code></pre><p>注意，在以上代码中由于要求 clientfd 是非阻塞模式的，所以将设置 clientfd 为非阻塞模式的逻辑放在accept_thread_func或io_thread_func中均可。<br>以上代码有点效率问题：某个时刻accept_thread_func向g_vecClientfds中添加了一个clientfd，如果此时io_thread_func函数正阻塞在epoll_wait处，我们就要唤醒epoll_wait</p><p>结构二：listenfd为阻塞模式，使用同一个one thread oneloop结构处理listenfd的事件<br>单独为listenfd分配一个线程毕竟是对资源的一种浪费，有读者可能想到这样一种方案：listenfd虽然被设置为阻塞模式，但可以将listenfd挂载到某个loop的epollfd上，在epoll_wait返回且listenfd上有读事件时，调用accept函数就不会阻塞了。伪代码如下：</p><pre><code>void* ioThreadFunc(void* param) &#123;    // 可以在这里做一些初始化工作        while (退出标志) &#123;        epoll_event epoll_events[1024];                // listenfd 和 clientfd 都被挂载到 epollfd 中，由 epoll_wait 统一检测读写事件        int numEvents = epoll_wait(epollfd, epoll_events, 1024, 1000);                if (如果在 listenfd 上有事件) &#123;            // 此时调用 accept 函数就不会阻塞            int clientfd = accept(listenfd, ...);                        // 对 clientfd 做进一步处理            // 其他一些操作        &#125;                // 其他一些操作    &#125;&#125;</code></pre><p>如以上代码所示，在这种情况下确实可以将listenfd设置成阻塞模式，调用accept函数时也不会造成流程阻塞。但这样的设计存在严重的效率问题：在每一轮循环中一次只能接受一个连接（每次循环都仅调用了一次accept函数），如果客户端的连接数较多，则这种处理速度可能跟不上客户端的连接请求速度，所以要在一个循环里面处理accept函数，但实际情形是我们无法确定下一轮调用accept函数时，在backlog队列中是否还有新连接，如果没有，则由于listenfd是阻塞模式，所以调用accept函数会阻塞。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClZA7n.png" alt="pClZA7n.png"></p><p>结构三：listenfd为非阻塞模式，使用同一个one thread oneloop结构处理listenfd的事件<br>将listenfd设置为非阻塞模式后，我们就不会有以上窘境了。伪代码如下：</p><pre><code>void* io_thread_func(void* param) &#123;    // 可以在这里做一些初始化工作        while (退出标志) &#123;        epoll_event epoll_events[1024];                // listenfd 和 clientfd 都被挂载到 epollfd 中，由 epoll_wait 统一检测读写事件        int numEvents = epoll_wait(epollfd, epoll_events, 1024, 1000);                if (如果在 listenfd 上有事件) &#123;            while (true) &#123;                // 此时调用 accept 函数就不会阻塞                int clientfd = accept(listenfd, ...);                                if (clientfd == -1) &#123;                    // 错误码是 EWOULDBLOCK，说明此时已经没有新连接了                    // 可以退出内层的 while 循环                    if (errno == EWOULDBLOCK)                        break;                                        // 被信号中断时重新调用一次 accept 函数即可                    else if (errno == EINTR)                        continue;                                        else &#123;                        // 对其他情况都认为出错                        // 做一次错误处理逻辑                    &#125;                &#125;                                else &#123;                    // 正常接受连接                    // 对 clientfd 做进一步处理                    // 结束内层的 if                &#125;            &#125;        &#125;                // 其他一些操作        // 结束外层的 while 循环    &#125;&#125;</code></pre><p>将 listenfd 设置成非阻塞模式还有一个好处：我们可以自己定义在一次 listenfd 读事件处理中最多接受多少连接，该逻辑也很容易实现，将以上代码中内层while循环的判断条件从true改成判定特定的次数即可：</p><pre><code>void* io_thread_func(void* param) &#123;    // 可以在这里做一些初始化工作        // 每次处理的最大连接数量    const int MAX_ACCEPTS_PER_CALL = 200;    // 当前数量    int currentAccept = 0;        while (退出标志) &#123;        epoll_event epoll_events[1024];                // 将 listenfd 和 clientfd 都挂载到 epollfd 上，由 epoll_wait 统一检测读写事件        int numEvents = epoll_wait(epollfd, epoll_events, 1024, 1000);                if (listenfd 上有事件) &#123;            currentAccept = 0;                        while (currentAccept &lt; MAX_ACCEPTS_PER_CALL) &#123;                // 此时调用 accept 函数不会阻塞                int clientfd = accept(listenfd, ...);                                if (clientfd == -1) &#123;                    // 错误码是 EWOULDBLOCK，说明此时已经没有新连接了                    // 可以退出内层的 while 循环了                    if (errno == EWOULDBLOCK)                        break;                                        // 被信号中断时重新调用一次 accept 函数即可                    else if (errno == EINTR)                        continue;                                        else &#123;                        // 对其他情况认为出错                        // 做一次错误处理逻辑                    &#125;                &#125;                                else &#123;                    // 累加处理数量                    ++currentAccept;                                        // 正常接受连接                    // 对 clientfd 做进一步处理                    // 结束内层的 if                &#125;            &#125;        &#125;                // 其他操作        // 结束外层的 while 循环    &#125;&#125;</code></pre><h3 id="基于one-thread-one-loop结构的经典服务器结构"><a href="#基于one-thread-one-loop结构的经典服务器结构" class="headerlink" title="基于one thread one loop结构的经典服务器结构"></a>基于one thread one loop结构的经典服务器结构</h3><p>理解listenfd为什么被建议设置成非阻塞模式后，我们将listenfd挂载到某个loop所属的epollfd上与clientfd统一处理就没有疑问了。接下来进一步讨论这一结构。<br>1.listenfd单独使用一个loop，clientfd被分配至其他loop这在实际商业服务器中是比较常用的一个结构，listenfd被单独挂载到一个线程 loop的epollfd上（这个线程一般是主线程），为了表述方便，我们将这个线程称为主线程，将对应的 loop称为主loop。产生新的 clientfd并将其按一定的策略挂载到其他线程 loop的epollfd上，我们将这些线程称为工作线程，将对应的loop称为工作loop。<br>例如使用轮询策略（round robin），我们可以将clientfd均匀地分配给其他工作线程，如下图所示</p><p><img src="https://s1.ax1x.com/2023/06/17/pClZehV.png" alt="pClZehV.png"></p><p>对轮询策略可以做一些优化：将clientfd挂载到各个工作loop上之后，由于连接断开时，工作loop会移除连接对应的clientfd，所以在一段时间后，各个工作loop上的clientfd数量都可能不一样，会出现数量差别很大的极端情况，因此主 loop 在分配新产生的clientfd时可以先查询各个工作loop上当前实际的clientfd数量，把当前新产生的clientfd分配给持有clientfd最少的工作loop，如下图所示</p><p><img src="https://s1.ax1x.com/2023/06/17/pClZu1U.md.png" alt="pClZu1U.md.png"></p><p>当然，我们也可以根据一定的策略比重分配 clientfd。假设现在有 4 个工作线程（对应 4 个工作 loop），其分配比重为 1：4：4：1，在程序运行一段时间后没有断开连接的情况，则这4个工作loop上的clientfd数量比例在理论上应该也是1：4：4：1。2.listenfd不单独使用一个loop，将所有clientfd都按一定策略分配给各个loop</p><p>对于一些建立和断开连接操作不是很频繁的场景，实际上没必要让listenfd单独使用一个线程，因为如果在这种场景下让listenfd单独使用一个Loop，这个线程在大多数情况下就可能处于空闲状态，而负责clientfd的其他线程可能比较忙碌，例如对于用户量较大的即时通信服务器、实时对战类型的游戏服务器，接受连接并不是高频操作，连接上的数据收发操作才是高频操作。如果采用listernfd单独使用一个线程的策略，则不仅浪费资源，效率也不高，所以应该让listenfd所在的线程也参与clientfd读写事件的处理。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClZlnJ.md.png" alt="pClZlnJ.md.png"></p><p>3.listenfd和所有clientfd均使用一个Loop<br>这是上述情形的特例，一般用于整个 loop 都是高效的内存操作的情形，例如Redis-server的I&#x2F;O线程情形，即单线程I&#x2F;O情形。事实上，本章介绍的one thread one loop思想及clientfd在多个loop之间的分配策略同样适用于多进程模型，例如Nginx，只不过在像Nginx这样的服务中使用单个进程来接受和处理连接后，主线程变成了主进程（Master Process），工作线程变成了工作进程（WorkerProcess），原来在同一个进程地址空间中可直接将一个clientfd数据投递给其他线程的方式，变成了利用进程通信技术将clientfd从主进程传递给工作进程。不管怎样，无论是主进程还是工作进程中的主线程结构、loop结构，这些进程中的主线程都是one thread one loop结构</p><h3 id="服务器的性能瓶颈"><a href="#服务器的性能瓶颈" class="headerlink" title="服务器的性能瓶颈"></a>服务器的性能瓶颈</h3><p>从线程维度来看，可以分为网路线程和业务处理线程，其中网络线程的执行逻辑一般比较固定，业务线程的执行逻辑则随着业务的不同而不同。<br>在机器物理资源有限的情况下，我们假定某个服务线程数量也是有限的。为了合理分配线程资源，让程序性能最大化，我们需要找到程序的性能瓶颈在哪里。按照业务类型的不同，我们一般将服务器程序归为两类：I&#x2F;O密集型和计算密集型。</p><ul><li>I&#x2F;O密集型指在程序业务上没有复杂的计算或者耗时的业务逻辑要处理，在大多数情况下是频繁的网络收发操作，这类服务有IM服务、交易系统中的行情推送服务、实时对战游戏的服务等。</li><li>计算密集型指在程序业务逻辑中存在耗时的计算，这类服务有数据处理服务、调度服务等。如果服务是I&#x2F;O密集型的，我们就需要将线程数量向网络通信组件倾斜，反过来，如果服务是计算密集型的，我们就应该将线程数量向业务模块倾斜。假设现在的总线程数量是 10 个，那么对于 I&#x2F;O 密集型服务，我们的网络线程数量可以被设置为大于 5，而业务线程数量<br>小于5；反过来，对于计算密集型服务，我们可以将网络线程数量设置为小于5，业务线程数量大于5，具体数量可以根据网络通信逻辑与业务处理逻辑在整个服务中的资源占用比例决定，谁的占用资源率大，倾斜给谁的线程数量就应该越多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程应该掌握的socket函数</title>
      <link href="/p/8f29bb10.html"/>
      <url>/p/8f29bb10.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程应该掌握的socket函数"><a href="#网络编程应该掌握的socket函数" class="headerlink" title="网络编程应该掌握的socket函数"></a>网络编程应该掌握的socket函数</h1><p>Windows和Linux上常用的socket API函数并不多，除了特定操作系统提供的一些基于自身系统特性的API，大多数socket API都源于BSD Socket（Berkeley Sockets，伯克利套接字），因此这些socket函数在不同的平台上都有相似的签名和参数。<br>一个 socket 句柄，在 Windows 上叫作“socket”，在 Linux上叫作“file descriptor”（即fd），它们的含义是一样的，监听 socket（或叫监听 fd）即 listen socket（或listenfd）。<br>这里有一个简单的函数列表，给出了一些常见的socket函数:</p><table><thead><tr><th>函数名</th><th>简要说明</th></tr></thead><tbody><tr><td>socket</td><td>创造某种类型的套接字</td></tr><tr><td>bind</td><td>将一个 socket 绑定到一个 IP 地址与端口的二元组上</td></tr><tr><td>listen</td><td>将一个 socket 变为监听状态</td></tr><tr><td>connect</td><td>试图建立一个 TCP 连接，一般用于客户端</td></tr><tr><td>accept</td><td>尝试接收一个连接，一般用于服务端</td></tr><tr><td>send</td><td>通过一个 socket 发送数据</td></tr><tr><td>recv</td><td>通过一个 socket 收取数据</td></tr><tr><td>select</td><td>判断一组 socket 上的读写和异常事件</td></tr><tr><td>gethostbyname</td><td>通过域名获取机器地址</td></tr><tr><td>close</td><td>关闭一个套接字，回收该 socket 对应的资源。在 Windows 中对应的是 closesocket</td></tr><tr><td>shutdown</td><td>关闭 socket 收发通道</td></tr><tr><td>setsockopt</td><td>设置一个套接字选项</td></tr><tr><td>getsockopt</td><td>获取一个套接字选项</td></tr></tbody></table><h2 id="TCP网络通信的基本流程"><a href="#TCP网络通信的基本流程" class="headerlink" title="TCP网络通信的基本流程"></a>TCP网络通信的基本流程</h2><p>不管是多么复杂的服务器或客户端程序，其网络通信的基本原理一定如下所述。<br>对于服务器，其通信流程一般如下所述。</p><ul><li>调用socket函数创建socket（监听socket）。</li><li>调用bind函数将socket绑定到某个IP和端口的二元组上。</li><li>调用listen函数开启监听。</li><li>当有客户端请求连接上来时，调用 accept 函数接收连接，产生一个新的 socket （客户端socket）。</li><li>基于新产生的socket调用send或recv函数，开始与客户端进<br>行数据交流。</li><li>通信结束后，调用close函数关闭监听socket。</li></ul><p>对于客户端，其通信流程一般如下所述。</p><ul><li>调用socket函数创建客户端socket。</li><li>调用connect函数尝试连接服务器。</li><li>连接成功后调用send或recv函数，开始与服务器进行数据交<br>流。</li><li>通信结束后，调用close函数关闭监听socket。</li></ul><p><img src="https://s1.ax1x.com/2023/06/14/pCnl75t.png" alt="pCnl75t.png"></p><p>服务端的实现代码：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123;    // 1. 创建一个监听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1) &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 3. 启动监听    if (listen(listenfd, SOMAXCONN) == -1) &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    while (true) &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);        // 4. 接受客户端连接        int clientfd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);        if (clientfd != -1) &#123;            char recvBuf[32] = &#123;0&#125;;            // 5. 从客户端接收数据            int ret = recv(clientfd, recvBuf, 32, 0);            if (ret &gt; 0) &#123;                std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;                // 6. 将收到的数据原封不动地发给客户端                ret = send(clientfd, recvBuf, strlen(recvBuf), 0);                if (ret != strlen(recvBuf)) &#123;                    std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                &#125; else &#123;                    std::cout &lt;&lt; &quot;send data to client successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;                &#125;            &#125; else &#123;                std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;            &#125;            close(clientfd);        &#125;    &#125;    // 7. 关闭监听socket    close(listenfd);    return 0;&#125;</code></pre><p>客户端的实现代码如下：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT 3000#define SEND_DATA &quot;helloworld&quot;int main(int argc, char* argv[]) &#123;    // 1. 创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1) &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)) == -1) &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 3. 向服务器发送数据    int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);    if (ret != strlen(SEND_DATA)) &#123;        std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;    // 4. 从服务器接收数据    char recvBuf[32] = &#123;0&#125;;    ret = recv(clientfd, recvBuf, 32, 0);    if (ret &gt; 0) &#123;        std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;recv data error, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125;    // 5. 关闭socket    close(clientfd);    return 0;&#125;</code></pre><p>通过以上代码，服务端在地址0.0.0.0：3000启动了一个监听，客户端连接服务器成功后，向服务器发送字符串“helloworld”；服务器收到后，将收到的字符串原封不动地发给了客户端</p><h2 id="设计跨平台网络通信库时的一些socket函数用法"><a href="#设计跨平台网络通信库时的一些socket函数用法" class="headerlink" title="设计跨平台网络通信库时的一些socket函数用法"></a>设计跨平台网络通信库时的一些socket函数用法</h2><p>这里说的跨平台，指的是在 Windows和 Linux上使用相关 socket函数，虽然二者的设计均参考了Berkeley Sockets，但是在演化过程中仍然存在不少区别。</p><h3 id="socket数据类型"><a href="#socket数据类型" class="headerlink" title="socket数据类型"></a>socket数据类型</h3><p>在Windows上，一个socket对象的类型是SOCKET，它是一个句柄对象（本质上也是int类型）。在Linux上，一个socket对象的类型是int。我们习惯将socket对象在Windows上称为socket，在Linux上称为fd。所以在很多网络库中使用了如下定义来包裹一个跨平台使用的socket类型</p><pre><code>#ifdef WIN32typedef SOCKET SOCKETTYPE;#elsetypedef int SOCKETTYPE;#endif</code></pre><p>这样就可以同时在Windows和Linux上使用SOCKET_TYPE类型代表socket了。无论是 Windows还是 Linux，创建一个套接字的函数 socket调用失败时均会返回-1。Windows为这种情形定义了一个INVALID_HANDLE_VALUE宏：</p><pre><code>#define INVALID_HANDLE_VALUE(-1)</code></pre><p>在Linux上不存在INVALID_HANDLE_VALUE宏，我们可以通过上述语句定义它。</p><h3 id="在Windows上调用socket函数"><a href="#在Windows上调用socket函数" class="headerlink" title="在Windows上调用socket函数"></a>在Windows上调用socket函数</h3><p>Linux 程序可以直接使用socket函数，但是对于Windows平台，必须先调用 WSAStartup函数显式地将与socket函数相关的dll文件加载到进程地址空间中，在程序退出时需要调用WSACleanup函数卸载相关的dll文件。这两个函数的用法示例如下：</p><pre><code>#include &lt;winsock2.h&gt; // 添加此头文件，用于使用Socket相关函数bool InitSocket() &#123;    // 指定版本号    WORD wversionRequested = MAKEWORD(2, 2);    WSADATA wsaData;    int nErrorID = ::WSAStartup(wversionRequested, &amp;wsaData);    if (nErrorID != 0) &#123;        return false;    &#125;    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) &#123;        UninitSocket();        return false;    &#125;    return true;&#125;void UninitSocket() &#123;    ::WSACleanup();&#125;</code></pre><p>需要注意的是，WSAStartup函数和 WSACleanup 函数是进程相关的，任何一个线程都可以调用。对于 WSAStartup 函数，某个线程调用一次之后，其他线程可以正常使用；反过来，如果某个线程不再使用相关的 socket 函数，则其调用 WSACleanup 函数时，会导致其他线程无法继续使用相关的 socket 函数。因此，我们在调用WSACleanup 函数之前应该确保整个程序不再有使用socket函数的地方。鉴于此，一般在进程退出时才调用该函数。</p><h3 id="关闭socket函数"><a href="#关闭socket函数" class="headerlink" title="关闭socket函数"></a>关闭socket函数</h3><p>出于历史原因，Windows从来没有以良好兼容的方式实现Berkeley套接字API。关闭套接字的接口时，在Linux（Unix）中使用close函数，在Windows中使用closesocket函数，问题是Windows也定义了一个close函数，该函数还不能用于关闭socket。如果调用该函数关闭socket，则会导致程序崩溃。这是让很多开发者犯错的地方。可以这样进行包装：</p><pre><code>#ifndef WIN32#define closesocket(s) close(s)#endif</code></pre><p>这样在Linux上就可以使用closesocket关闭socket了。</p><h3 id="获取socket函数的错误码"><a href="#获取socket函数的错误码" class="headerlink" title="获取socket函数的错误码"></a>获取socket函数的错误码</h3><p>若某个 socket函数调用失败时，在Windows上则需要调用WSAGetLastError（）这个API获取错误码，在 Linux上则直接使用errno变量获取错误码。所以我们可能会在一些网络库中看到如下代码：</p><pre><code>#ifdef WIN32#define GetSocketError() WSAGetLastError()#else#define GetSocketError() errno#endif</code></pre><p>这样就可以使用GetSocketError函数统一进行处理了。</p><h3 id="套接字函数的返回值"><a href="#套接字函数的返回值" class="headerlink" title="套接字函数的返回值"></a>套接字函数的返回值</h3><p>无论是Windows还是Linux，大多数socket函数在调用失败后都会返回-1，在Windows上为这种情形专门定义了一个宏SOCKET_ERROR：</p><pre><code>#define SOCKET_ERROR (-1)</code></pre><p>可以在Linux上也定义这样一个宏，这样就方便统一书写了：</p><pre><code>#ifndef WIN32#define SOCKET_ERROR (-1)#endif</code></pre><h3 id="select函数第1个参数的问题"><a href="#select函数第1个参数的问题" class="headerlink" title="select函数第1个参数的问题"></a>select函数第1个参数的问题</h3><p>select 函数的原型如下：</p><pre><code class="cpp">int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);</code></pre><p>参数说明：</p><ul><li><code>nfds</code>：监视的文件描述符集中所有文件描述符的范围（最大文件描述符+1）。</li><li><code>readfds</code>：读取文件描述符集，包含希望监视读操作的文件描述符。</li><li><code>writefds</code>：写入文件描述符集，包含希望监视写操作的文件描述符。</li><li><code>exceptfds</code>：异常文件描述符集，包含希望监视异常情况的文件描述符。</li><li><code>timeout</code>：超时时间，指定<code>select</code>函数阻塞等待的最长时间。可以设置为<code>NULL</code>表示永久阻塞，或者指定一个时间间隔。</li></ul><p>返回值：</p><ul><li>如果有就绪的文件描述符，返回就绪文件描述符的总数。</li><li>如果超时时间到达，返回0。</li><li>如果出错，返回-1，并设置<code>errno</code>来指示具体错误原因。</li></ul><p>使用示例如下：</p><pre><code>fd_set writeset;FD_ZERO(&amp;writeset);FD_SET(m_hSocket, &amp;writeset);struct timeval tv;tv.tv_sec = 3;tv.tv_usec = 100;select(m_hSocket + 1, NULL, &amp;writeset, NULL, &amp;tv);</code></pre><p>无论是Windows还是Linux，select函数的参数readfds、writefds和exceptfds都是一个包含一组socket描述符数组的结构体。在Linux上，第1个参数nfds必须被设置为readfds、writefds或exceptfds，所有socket描述符句柄中的最大值都加1。但是在Windows上，select函数不使用第1个参数nfds，可以随意设置，这个参数用于保持与Berkeley套接字兼容。一般为了兼容，在 Windows 上也会将这个参数的值设置为这三个 fd_set 集合中的最大套接字值加1。</p><h3 id="错误码WSAEWOULDBLOCK和EWOULDBLOCK"><a href="#错误码WSAEWOULDBLOCK和EWOULDBLOCK" class="headerlink" title="错误码WSAEWOULDBLOCK和EWOULDBLOCK"></a>错误码WSAEWOULDBLOCK和EWOULDBLOCK</h3><p>在某些套接字的函数操作不能立即完成时，在 Windows 上会返回错误码WSAEWOULDBLOCK，该错误码在Linux上对应错误码EWOULDBLOCK（在Linux还存在一个错误码EAGAIN，与此同义）。<br>为了统一写法，我们可以在Windows上使用如下代码来兼容：</p><pre><code>#ifdef WIN32#define EWOULDBLOCK WSAEWOULDBLOCK#endif</code></pre><p>对于I&#x2F;O复用技术，Windows和Linux都支持：select模型；Linux特有的poll、epoll模型；Windows特有的WSAPoll和完成端口模型（IOCP）。<br>此外，在Windows和 Linux上有许多自己特有的 API和网络通信模型，Windows自我扩展的套接字函数一般以WSAWindows SocketAPI）开头，例如WSASend、WSARecv等。Windows 提供了方便使用的WSAEventSelect 和 WSAAsyncSelect 等网络通信模型，Linux 则提供了 accept4、socketpair 等方便使用的 API。</p><h2 id="bind函数重难点分析"><a href="#bind函数重难点分析" class="headerlink" title="bind函数重难点分析"></a>bind函数重难点分析</h2><h3 id="对bind函数如何选择绑定地址"><a href="#对bind函数如何选择绑定地址" class="headerlink" title="对bind函数如何选择绑定地址"></a>对bind函数如何选择绑定地址</h3><p>我们来看TCP连接中，bind相关代码</p><pre><code>struct sockaddr_in bindaddr;bindaddr.sin_family = AF_INET;bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);bindaddr.sin_port = htons(3000);if (bind(listenfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;    std::cout &lt;&lt; &quot;Failed to bind listen socket.&quot; &lt;&lt; std::endl;    return -1;&#125;</code></pre><p>其中bind的地址使用了一个宏，叫INADDR_ANY，关于这个宏的解释为：如果应用程序不关心 bind 绑定的 IP，则可以使用INADDR_ANY （如果是 IPv6，则对应in6addr_any），底层的（协议栈）服务会自动选择一个合适的 IP地址，这样在多个网卡机器上选择IP地址会变得简单。也就是说，INADDR_ANY相当于地址0.0.0.0。再详细解释一下，假设我们在一台机器上开发一个服务器程序，则使用bind函数时，我们有多个IP地址可以选择。首先，这台机器的外网IP地址是120.55.94.78，在当前局域网中的地址是192.168.1.104。同时，这台机器有本地回环地址127.0.0.1。如果只想在本机上进行访问，那么对 bind 函数中的地址可以使用 127.0.0.1；如果服务只想被局域网中的内部机器访问，那么bind函数中的地址可以使用192.168.1.104这样的局域网地址；如果希望这个服务可以被公网访问，那么可以使用地址 0.0.0.0 或INADDR_ANY。</p><h3 id="bind函数的端口号问题"><a href="#bind函数的端口号问题" class="headerlink" title="bind函数的端口号问题"></a>bind函数的端口号问题</h3><p>网络通信程序的基本逻辑是客户端连接服务器，即从客户端的地址：端口连接到服务器的地址：端口上。在 TCP 通信双方中，一般服务端的端口号是固定的，而客户端的端口号是连接发起时由操作系统随机分配的（不会分配已被占用的端口）。端口号是一个C short类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下，压力测试程序在理论上最多只能发起 65 000 多个连接。在实际情况下，由于当时操作系统中的很多端口可能已被占用，所以实际可以使用的端口比这个更少，例如，一<br>般规定端口号为1024以下的端口是保留端口，不建议用户程序使用。<br>而对于Windows系统，MSDN甚至明确地说明：Vista及以后的Windows，可用的动态端口范围是49152～65535；而Windows Server及更早的系统，可用的动态端口范围是 1025～5000（我们可以通过修改注册表来改变这一设置）如果将 bind 函数中的端口号设置为0，那么操作系统会随机为程序分配一个可用的监听端口。当然，服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的IP地址和端口号。<br>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然：在一些特殊的应用中，我们需要客户端程序以指定的端口号连接服务器，此时我们就可以在客户端程序中调用bind函数绑定一个具体的端口了。<br>我们用代码来验证以上内容。为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。</p><h4 id="客户端代码不绑定端口"><a href="#客户端代码不绑定端口" class="headerlink" title="客户端代码不绑定端口"></a>客户端代码不绑定端口</h4><p>修改后的服务器代码如下：</p><pre><code class="cpp">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;int main(int argc, char* argv[]) &#123;    // 1. 创建一个监听 socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1) &#123;        std::cout &lt;&lt; &quot;Failed to create listen socket.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;        std::cout &lt;&lt; &quot;Failed to bind listen socket.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 3. 启动监听    if (listen(listenfd, SOMAXCONN) == -1) &#123;        std::cout &lt;&lt; &quot;Failed to start listening.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 记录所有客户端连接的容器    std::vector&lt;int&gt; clientfds;    while (true) &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);        // 4. 接受客户端连接        int clientfd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);        if (clientfd == -1) &#123;            std::cout &lt;&lt; &quot;Failed to accept client connection.&quot; &lt;&lt; std::endl;            continue;        &#125;        char recvBuf[32] = &#123;0&#125;;        // 5. 从客户端收取数据        int ret = recv(clientfd, recvBuf, 32, 0);        if (ret &gt; 0) &#123;            std::cout &lt;&lt; &quot;Received data from client: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;            // 6. 将收到的数据原封不动地发送给客户端            ret = send(clientfd, recvBuf, strlen(recvBuf), 0);            if (ret != strlen(recvBuf)) &#123;                std::cout &lt;&lt; &quot;Failed to send data.&quot; &lt;&lt; std::endl;            &#125; else &#123;                std::cout &lt;&lt; &quot;Sent data to client successfully: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;            &#125;        &#125; else if (ret == 0) &#123;            std::cout &lt;&lt; &quot;Connection closed by client.&quot; &lt;&lt; std::endl;        &#125; else &#123;            std::cout &lt;&lt; &quot;Failed to receive data.&quot; &lt;&lt; std::endl;        &#125;        // 7. 关闭客户端连接        close(clientfd);    &#125;    // 8. 关闭监听 socket    close(listenfd);    return 0;&#125;</code></pre><p>修改后的客户端代码如下：</p><pre><code class="cpp">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT 3000#define SEND_DATA &quot;helloworld&quot;int main(int argc, char* argv[]) &#123;    // 1. 创建一个 socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1) &#123;        std::cout &lt;&lt; &quot;Failed to create client socket.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)) == -1) &#123;        std::cout &lt;&lt; &quot;Failed to connect to the server.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 3. 向服务器发送数据    int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);    if (ret != strlen(SEND_DATA)) &#123;        std::cout &lt;&lt; &quot;Failed to send data.&quot; &lt;&lt; std::endl;        return -1;    &#125;    std::cout &lt;&lt; &quot;Sent data successfully. Data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;    // 4. 从服务器接收数据    char recvBuf[32] = &#123;0&#125;;    ret = recv(clientfd, recvBuf, 32, 0);    if (ret &gt; 0) &#123;        std::cout &lt;&lt; &quot;Received data successfully. Data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;Failed to receive data.&quot; &lt;&lt; std::endl;    &#125;    // 5. 关闭 socket    close(clientfd);    // 仅为了保持客户端程序不退出    while (true) &#123;        sleep(3);    &#125;    return 0;&#125;</code></pre><p>将程序编译好后，我们先启动 server，再启动 3 个客户端。然后通过 lsof命令查看当前机器上的 TCP连接信息。为了更清楚地显示结果，这里已经将不相关的连接信息去掉了，结果如下：</p><pre><code>[root@localhost ~]# lsof -i -PnCOMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1445  root   3u   IPv4  21568      0t0  TCP *:3000 (LISTEN)server   1445  root   4u   IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)server   1445  root   5u   IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)server   1445  root   6u   IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)client   1447  root   3u   IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)client   1448  root   3u   IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)client   1449  root   3u   IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)</code></pre><p>上面的结果显示，server进程（进程ID是 1445）在 3000端口开启了监听，有 3个client 进程（进程 ID 分别是 1447、1448、1449）分别通过端口号 40818、40820、40822连到server进程上。作为客户端的一方，端口号是系统随机分配的。</p><h4 id="客户端代码不绑定端口-1"><a href="#客户端代码不绑定端口-1" class="headerlink" title="客户端代码不绑定端口"></a>客户端代码不绑定端口</h4><p>服务端代码不变，改变客户端代码，绑定0号端口：</p><pre><code class="cpp">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT 3000#define SEND_DATA &quot;helloworld&quot;int main(int argc, char* argv[]) &#123;    // 1. 创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1) &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(0);        if (bind(clientfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;        std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        // 2. 连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);        if (connect(clientfd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)) == -1) &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        // 3. 向服务器发送数据    int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);    if (ret != strlen(SEND_DATA)) &#123;        std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        std::cout &lt;&lt; &quot;send data successfully, data: &quot; &lt;&lt; SEND_DATA &lt;&lt; std::endl;        // 4. 从服务器接收数据    char recvBuf[32] = &#123;0&#125;;    ret = recv(clientfd, recvBuf, 32, 0);    if (ret &gt; 0) &#123;        std::cout &lt;&lt; &quot;recv data successfully, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;    &#125;        // 5. 关闭socket    close(clientfd);        // 这里仅仅是为了让客户端程序不退出    while (true) &#123;        sleep(3);    &#125;        return 0;&#125;</code></pre><p>再次编译客户端程序并启动 3 个 client 进程，用 lsof 命令查看机器上的 TCP连接情况，结果如下：</p><pre><code>[root@localhost ~]# lsof -i -PnCOMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1593  root   3u   IPv4  21807      0t0  TCP *:3000 (LISTEN)server   1593  root   4u   IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)server   1593  root   5u   IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)server   1593  root   6u   IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)client   1595  root   3u   IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)client   1611  root   3u   IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)client   1627  root   3u   IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)</code></pre><p>通过上面的结果，我们发现3个client进程使用的端口号仍然是系统随机分配的，也就是说，绑定0号端口和不绑定的效果是一样的</p><h4 id="客户端绑定一个固定端口"><a href="#客户端绑定一个固定端口" class="headerlink" title="客户端绑定一个固定端口"></a>客户端绑定一个固定端口</h4><p>这里使用了20000端口，可以根据自己的喜好选择不同端口，只要保证所选择的端口号当前没有被其他程序占用即可。服务器代码保<br>持不变，将客户端绑定代码中的端口号从0改成20000。这里为了节省篇幅，只贴出修改处的代码：</p><pre><code class="cpp">struct sockaddr_in bindaddr;bindaddr.sin_family = AF_INET;bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);bindaddr.sin_port = htons(20000);if (bind(clientfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;    std::cout &lt;&lt; &quot;bind socket error.&quot; &lt;&lt; std::endl;    return -1;&#125;</code></pre><p>再次重新编译程序，先启动一个客户端，此时的TCP连接状态如下：</p><pre><code>[root@localhost testsocket]# lsof -i -PnCOMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver   1676  root   3u   IPv4  21933      0t0  TCP *:3000 (LISTEN)server   1676  root   4u   IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)client   1678  root   3u   IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)</code></pre><p>在进行技术面试的时候，面试官有时会问 TCP网络通信的客户端程序中的 socket是否可以调用bind函数，相信读到这里，你已经有答案了。</p><h2 id="select函数的用法和原理"><a href="#select函数的用法和原理" class="headerlink" title="select函数的用法和原理"></a>select函数的用法和原理</h2><p>select函数是网络通信编程中很常用的一个函数，我们应该熟练掌握它。虽然它是BSD标准之一的socket函数，但在Linux和Windows上，其行为表现还是有点区别的。先来看看Linux上的select函数。</p><h3 id="Linux上的select函数"><a href="#Linux上的select函数" class="headerlink" title="Linux上的select函数"></a>Linux上的select函数</h3><p>select函数用于检测在一组socket中是否有事件就绪。这里的事<br>件就绪一般分为如下三类。</p><ul><li><p>读事件就绪</p><ul><li>在socket内核中，接收缓冲区中的字节数大于或等于低水位标记SO_RCVLOWAT，此时调用recv或read函数可以无阻塞地读该文件描述符，并且返回值大于0。</li><li>TCP连接的对端关闭连接，此时本端调用recv或read函数对socket进行读操作，recv或read函数会返回0值。</li><li>在监听socket上有新的连接请求。</li><li>在socket上有未处理的错误。</li></ul></li><li><p>写事件就绪</p><ul><li>在socket内核中，发送缓冲区中的可用字节数（发送缓冲区的空闲位置大小）大于或等于低水位标记SO_SNDLOWAT时，可以无阻塞地写，并且返回值大于0。</li><li>socket的写操作被关闭（调用了 close或 shutdown 函数）时，对一个写操作被关闭的socket进行写操作，会触发SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或失败时。</li></ul></li><li><p>异常事件就绪<br>在socket上收到带外数据，函数签名如下：</p><p>  int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);</p></li></ul><p>参数说明：</p><ul><li><code>nfds</code>：待检查的文件描述符（socket）的最大值加1。</li><li><code>readfds</code>：指向可读文件描述符集合的指针。如果该文件描述符集合中的某个文件描述符可读，则对应的位将被置为1。</li><li><code>writefds</code>：指向可写文件描述符集合的指针。如果该文件描述符集合中的某个文件描述符可写，则对应的位将被置为1。</li><li><code>exceptfds</code>：指向异常文件描述符集合的指针。如果该文件描述符集合中的某个文件描述符发生异常，则对应的位将被置为1。</li><li><code>timeout</code>：指向等待时间的指针，可以设定等待的超时时间，如果为NULL则表示阻塞等待。</li></ul><p>返回值：</p><ul><li>如果有文件描述符发生了可读、可写或异常等事件，则返回这些事件发生的文件描述符的数量。</li><li>如果超时时间到达，没有任何事件发生，则返回0。</li><li>如果出现错误，则返回-1，并设置errno。</li></ul><p>timeout：这是一个超时时间，即在指定的时间内检测文件描述符的事件。timeout是一个timeval类型的结构体，它包含两个成员：</p><ul><li>tv_sec：表示超时时间的秒数部分。</li><li>tv_usec：表示超时时间的微秒数部分。<br>select函数将在超时时间到达之前，或者有文件描述符的可读、可写、异常事件发生时返回。</li></ul><h2 id="socket的阻塞模式和非阻塞模式"><a href="#socket的阻塞模式和非阻塞模式" class="headerlink" title="socket的阻塞模式和非阻塞模式"></a>socket的阻塞模式和非阻塞模式</h2><p>对 socket 在阻塞和非阻塞模式下各个 socket 函数的表现进行深入理解，是掌握网络编程的基本要求之一，也是重点和难点。在阻塞和非阻塞模式下，我们常讨论的具有不同行为表现的socket 函数一般有connect、accept、send和recv。在Linux上对socket进行操作时也包括 write函数和read函数。下面对send函数的讨论也适用于write函数，对recv函数的讨论也适用于read函数。在正式讨论以上4个函数之前，先解释阻塞模式和非阻塞模式的概念。阻塞模式指当某个函数执行成功的条件当前不满足时，该函数会阻塞当前执行线程，程序执行流在超时时间到达或执行成功的条件满足后恢复继续执行。非阻塞模式则恰恰相反，即使某个函数执行成功的条件当前不能满足，该函数也不会阻塞当前执行线程，而是立即返回，继续执行程序流。</p><h3 id="如何将socket设置为非阻塞模式"><a href="#如何将socket设置为非阻塞模式" class="headerlink" title="如何将socket设置为非阻塞模式"></a>如何将socket设置为非阻塞模式</h3><p>无论是Windows还是Linux，默认创建的socket都是阻塞模式的。在Linux上，我们可以使用fcntl函数或ioctl函数给创建的socket增加O_NONBLOCK标志来将socket设置为非阻塞模式。示例代码如下</p><pre><code class="cpp">#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int setNonBlocking(int sockfd) &#123;    int oldSocketFlag = fcntl(sockfd, F_GETFL, 0);    if (oldSocketFlag == -1) &#123;        // 处理获取套接字标志位失败的情况        return -1;    &#125;    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(sockfd, F_SETFL, newSocketFlag) == -1) &#123;        // 处理设置套接字标志位失败的情况        return -1;    &#125;    return 0;&#125;</code></pre><p>当然，Linux上的socket函数也可以直接在创建时将socket设置为非阻塞模式，socket函数签名如下：</p><pre><code class="c">int socket(int domain, int type, int protocol);</code></pre><p>该函数的参数解释如下：</p><ul><li><code>domain</code>：指定套接字的协议域，例如<code>AF_INET</code>表示IPv4协议，<code>AF_INET6</code>表示IPv6协议，<code>AF_UNIX</code>表示本地通信域等。</li><li><code>type</code>：指定套接字的类型，例如<code>SOCK_STREAM</code>表示面向连接的字节流套接字（如TCP），<code>SOCK_DGRAM</code>表示无连接的数据报套接字（如UDP）等。</li><li><code>protocol</code>：指定协议类型，通常设置为0以自动选择与给定<code>domain</code></li></ul><p>给type参数增加一个SOCK_NONBLOCK标志即可，例如：</p><pre><code>int s = socket (AF_INET,SOCK_STREAM | SOCK_NONBLOCK,IPPROTO_TCP);</code></pre><p>不仅如此，在 Linux 上利用 accept 函数返回的代表与客户端通信的 socket 也提供了一个扩展函数accept4，直接将accept函数返回的socket设置为非阻塞的：</p><pre><code>int accept(int sockfd,structsockaddr*addr,socklen_t*addrlen);int accept4(int sockfd,structsockaddr*addr,socklen_t*addrlen,int flags);</code></pre><p>只要将 accept4 函数的最后一个参数 flags 设置为SOCK_NONBLOCK 即可。也就是说以下代码是等价的：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;fcntl.h&gt;int main() &#123;    int listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    if (listenfd &lt; 0) &#123;        // 错误处理    &#125;    // 绑定和监听 listenfd...    struct sockaddr_in clientaddr;    socklen_t addrlen = sizeof(clientaddr);    int clientfd = accept(listenfd, (struct sockaddr*) &amp;clientaddr, &amp;addrlen);    if (clientfd != -1) &#123;        int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);        int newSocketFlag = oldSocketFlag | O_NONBLOCK;        fcntl(clientfd, F_SETFL, newSocketFlag);        // 使用非阻塞的 clientfd 进行后续操作    &#125;    return 0;&#125;</code></pre><p>在Windows上可以调用ioctlsocket函数将socket设置为非阻塞模式，ioctlsocket函数签名如下：</p><pre><code class="c">#include &lt;winsock2.h&gt;int ioctlsocket(SOCKET s, long cmd, u_long* argp);</code></pre><p>该函数的参数解释如下：</p><ul><li><code>s</code>：要设置的套接字。</li><li><code>cmd</code>：指定要执行的命令，通常为<code>FIONBIO</code>（用于设置非阻塞模式）。</li><li><code>argp</code>：指向一个<code>u_long</code>类型的变量，用于传递额外的参数。</li></ul><p>将cmd参数设置为FIONBIO，将argp设置为0，即可将socket设置为阻塞模式，而将argp设置为非0，即可将其设置为非阻塞模式。</p><pre><code>#include &lt;winsock2.h&gt;int main() &#123;    // 初始化 Winsock    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;        // 错误处理    &#125;    // 创建套接字    SOCKET sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    if (sockfd == INVALID_SOCKET) &#123;        // 错误处理    &#125;    // 将套接字设置为非阻塞模式    u_long mode = 1;  // 1 表示非阻塞模式，0 表示阻塞模式    if (ioctlsocket(sockfd, FIONBIO, &amp;mode) != 0) &#123;        // 错误处理    &#125;    // 使用非阻塞的套接字进行后续操作    // 关闭套接字    closesocket(sockfd);    // 清理 Winsock    WSACleanup();    return 0;&#125;</code></pre><p>要使用ioctlsocket函数，则必须使用WindowsServer 2003及之后的版本。在Windows上对一个socket调用了WSAAsyncSelect或WSAEventSelect函数后，再调用 ioctlsocket 函数将该 socket 设置为非阻塞模式会失败，我们必须先调用WSAAsyncSelect 函数将lEvent参数设置为0或调用WSAEventSelect函数将 lNetworkEvents参数设置为 0，这样会清除已经设置的socket相关标志位，接着调用ioctlsocket函数将该socket设置为阻塞式才会成功。因为调用<br>WSAAsyncSelect或 WSAEventSelect 函数时会自动将socket设置为非阻塞模式。<br>注意：无论是Linux的fcntl函数，还是Windows的ioctlsocket函数，都建议判断函数返回值以确定是否调用成功。</p><h3 id="send和recv函数在阻塞和非阻塞模式下的表现"><a href="#send和recv函数在阻塞和非阻塞模式下的表现" class="headerlink" title="send和recv函数在阻塞和非阻塞模式下的表现"></a>send和recv函数在阻塞和非阻塞模式下的表现</h3><p>send和recv函数其实名不符实。send函数在本质上并不是向网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区中，至于数据什么时候会从网卡缓冲区中真正地发到网络中，要根据TCP&#x2F;IP协议栈的行为来确定。如果socket设置了TCP_NODELAY选项（即禁用 nagel 算法），存放到内核缓冲区的数据就会被立即发出去；反之，一次放入内核缓冲区的数据包如果太小，则系统会在多个小的数据包凑成一个足够大的数据包后才会将数据发出去。<br>recv函数在本质上并不是从网络上收取数据，而是将内核缓冲区中的数据拷贝到应用程序的缓冲区中。当然，在拷贝完成后会将内核缓冲区中的该部分数据移除。</p><p><img src="https://s1.ax1x.com/2023/06/15/pCKlqxK.png" alt="pCKlqxK.png"></p><p>通过上图可以知道，不同的程序在进行网络通信时，发送的一方会将内核缓冲区的数据通过网络传输给接收方的内核缓冲区。在应用程序A与应用程序B建立TCP连接之后，假设应用程序A不断调用send函数，则数据会不断拷贝至对应的内核缓冲区中，如果应用程序B一直不调用recv函数，那么在应用程序B的内核缓冲区被填满后，应用程序A的内核缓冲区也会被填满，此时应用程序A继续调用send函数会是什么结果呢？具体的结果取决于该socket是否是阻塞模式，这里先给出结论：</p><ul><li>当socket是阻塞模式时，继续调用send&#x2F;recv函数，程序会阻塞在send&#x2F;recv调用处；</li><li>当socket是非阻塞模式时，继续调用send&#x2F;recv函数，send&#x2F;recv函数不会阻塞程序执行流，而是立即出错并返回，我们会得到一个相关的错误码，在Linux上该错误码为EWOULDBLOCK 或EAGAIN（这两个错误码的值相同），在 Windows 上该错误码为WSAEWOULDBLOCK。</li></ul><h4 id="socket阻塞模式下send函数的表现"><a href="#socket阻塞模式下send函数的表现" class="headerlink" title="socket阻塞模式下send函数的表现"></a>socket阻塞模式下send函数的表现</h4><p>服务端代码（blocking_server.cpp）如下：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123;    // 1. 创建一个监听 socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1) &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr*)&amp;bindaddr, sizeof(bindaddr)) == -1) &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    // 3. 启动监听    if (listen(listenfd, SOMAXCONN) == -1) &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    while (true) &#123;        struct sockaddr_in clientaddr;        socklen_t clientaddrlen = sizeof(clientaddr);        // 4. 接受客户端连接        int clientfd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddrlen);        if (clientfd != -1) &#123;            // 只接受连接，不调用recv收取任何数据            std::cout &lt;&lt; &quot;accept a client connection.&quot; &lt;&lt; std::endl;        &#125;    &#125;    close(listenfd);    return 0;&#125;</code></pre><p>客户端代码（blocking_client.cpp）如下：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT 3000#define SEND_DATA &quot;helloworld&quot;int main(int argc, char* argv[]) &#123;    // 1. 创建一个 socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1) &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 2. 连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)) == -1) &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    // 3. 不断向服务器发送数据，直到出错并退出循环    int count = 0;    while (true) &#123;        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);        if (ret != strlen(SEND_DATA)) &#123;            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;            break;        &#125; else &#123;            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;            count++;        &#125;    &#125;    // 4. 关闭套接字    close(clientfd);    return 0;&#125;</code></pre><p>blocking_client会不断向blocking_server发送helloworld字符串，在每次发送成功后，都会打印计数器count的值，计数器count的值会不断增加。在程序运行一段时间后，计数器count的值不再增加且程序不再有输出。操作过程及输出结果如下：</p><pre><code>send data successfully, count = 35534send data successfully, count = 35535send data successfully, count = 35536send data successfully, count = 35537send data successfully, count = 35538send data successfully, count = 35539</code></pre><p>此时程序不再有输出，程序阻塞在send函数调用处.<br>以上示例验证了如果一端一直发送数据，对端应用层一直不收取数据（或收取数据的速度慢于发送的速度），则两端的内核缓冲区很快就会被填满，导致发送端调用send函数被阻塞。这里说的内核缓冲区其实有个专门的名字，即 TCP 窗口。也就是说，在 socket阻塞模式下，send函数在TCP窗口太小时会阻塞当前程序的执行流（即阻塞send函数所在线程的执行）。另外，在上面的例子中，我们每次都发送一个“helloworld”（10 字节），一共发送了355 390次（每次测试的结果都略有不同），可以粗略算出TCP窗口大约等于1.7M（10×355390&#x2F;2）。</p><h3 id="socket非阻塞模式下send函数的表现"><a href="#socket非阻塞模式下send函数的表现" class="headerlink" title="socket非阻塞模式下send函数的表现"></a>socket非阻塞模式下send函数的表现</h3><p>再来验证非阻塞socket的send表现，服务端的代码不变，我们将blocking_client.cpp中的socket设置为非阻塞的，修改后的代码如下</p><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;        //连接成功以后，我们再将clientfd设置为非阻塞模式，    //不能在创建时就设置，这样会影响到connect函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        //3.不断地向服务器发送数据，或者出错退出    int count = 0;    while (true)    &#123;        int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);        if (ret == -1)         &#123;            //非阻塞模式下，send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK            if (errno == EWOULDBLOCK)            &#123;                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;                continue;            &#125;             else if (errno == EINTR)            &#123;                //如果被信号中断，则继续重试                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;                continue;            &#125;             else             &#123;                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                break;            &#125;        &#125;        else if (ret == 0)        &#123;            //对端关闭了连接，我们也关闭            std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;            close(clientfd);            break;        &#125;         else        &#123;            count ++;            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;        &#125;    &#125;        //4.关闭socket    close(clientfd);        return 0;&#125;</code></pre><p>运行nonblocking_client一段时间后，对端和本端的TCP窗口已满，数据发送不出去，但是send函数不会阻塞，而是立即返回，返回值是-1（在Windows<br>上返回SOCKET_ERROR，这个宏的值也是-1），此时得到的错误码是EWOULDBLOCK。</p><h3 id="socket阻塞模式下recv函数的表现"><a href="#socket阻塞模式下recv函数的表现" class="headerlink" title="socket阻塞模式下recv函数的表现"></a>socket阻塞模式下recv函数的表现</h3><p>在了解send函数的行为后，我们再来看一下阻塞模式下recv函数的表现。我们不需要修改服务端的代码，修改客户端的代码即可。如果服务端不向客户端发送数据，则此时客户端调用recv函数的执行流会阻塞在recv函数调用处。修改后，客户端的代码如下：</p><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;        char recvbuf[32] = &#123;0&#125;;    //3.直接调用recv函数，程序会阻塞在recv函数调用处    int ret = recv(clientfd, recvbuf, 32, 0);    if (ret &gt; 0)     &#123;        std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;    &#125;     else     &#123;        std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;    &#125;        //4. 关闭socket    close(clientfd);    return 0;&#125;</code></pre><p>运行程序既没有输出recv函数调用成功的信息，也没有输出recv函数调用失败的信息。程序阻塞在recv函数调用处</p><h3 id="socket非阻塞模式下recv函数的表现"><a href="#socket非阻塞模式下recv函数的表现" class="headerlink" title="socket非阻塞模式下recv函数的表现"></a>socket非阻塞模式下recv函数的表现</h3><p>在非阻塞模式下，如果当前无数据可读，则recv函数将立即返回，返回值为-1，错误码为EWOULDBLOCK。将客户端的代码修改一下：  </p><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;        //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;        while (true)    &#123;        char recvbuf[32] = &#123;0&#125;;        //由于clientfd被设置成了非阻塞模式，所以无论是否有数据，recv函数都不会阻塞程序        int ret = recv(clientfd, recvbuf, 32, 0);        if (ret &gt; 0)         &#123;            //收到了数据            std::cout &lt;&lt; &quot;recv successfully.&quot; &lt;&lt; std::endl;        &#125;         else if (ret == 0)        &#123;            //对端关闭了连接            std::cout &lt;&lt; &quot;peer close the socket.&quot; &lt;&lt; std::endl;            break;        &#125;         else if (ret == -1)         &#123;            if (errno == EWOULDBLOCK)            &#123;                std::cout &lt;&lt; &quot;There is no data available now.&quot; &lt;&lt; std::endl;            &#125;             else if (errno == EINTR)             &#123;                //如果被信号中断了，则继续重试recv函数                std::cout &lt;&lt; &quot;recv data interrupted by signal.&quot; &lt;&lt; std::endl;            &#125; else            &#123;                //真的出错了                break;            &#125;        &#125;    &#125;        //3. 关闭socket    close(clientfd);    return 0;&#125;</code></pre><p>执行结果与我们预期的一模一样，recv函数在无数据可读的情况下并不会阻塞程序执行流，所以会一直有“There is no data available now.”相关的输出</p><h3 id="非阻塞模式下send和recv函数的返回值总结"><a href="#非阻塞模式下send和recv函数的返回值总结" class="headerlink" title="非阻塞模式下send和recv函数的返回值总结"></a>非阻塞模式下send和recv函数的返回值总结</h3><p>以下是<code>send</code>和<code>recv</code>函数各种返回值的含义的总结：</p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>正整数</td><td>发送或接收的数据字节数</td></tr><tr><td>0</td><td>连接已关闭，对于<code>recv</code>函数表示对方已关闭连接</td></tr><tr><td>-1</td><td>发生错误，可通过<code>errno</code>变量获取具体错误代码</td></tr><tr><td>EAGAIN&#x2F;EWOULDBLOCK</td><td>在非阻塞模式下，表示操作被阻塞，稍后再试</td></tr><tr><td>EINTR</td><td>调用被信号中断，可以选择重新调用<code>send</code>或<code>recv</code>函数继续操作</td></tr><tr><td>EMSGSIZE</td><td>发送的数据超出了套接字发送缓冲区的大小限制</td></tr><tr><td>ECONNRESET</td><td>连接被对方重置，表示对方主动关闭连接</td></tr><tr><td>EPIPE</td><td>连接已断开，对于<code>send</code>函数表示对方已关闭连接</td></tr><tr><td>EHOSTUNREACH&#x2F;EHOSTDOWN</td><td>无法到达或目标主机不可用</td></tr><tr><td>ENETDOWN</td><td>网络连接已断开</td></tr><tr><td>ENOTCONN</td><td>套接字未连接</td></tr></tbody></table><h4 id="返回值大于-0"><a href="#返回值大于-0" class="headerlink" title="返回值大于 0"></a>返回值大于 0</h4><p>当send和recv函数的返回值大于 0时，表示发送或接收多少字节。需要注意的是，在这种情形下，我们一定要判断 send 函数的返回值是不是我们期望发送的字节数，而不是简单判断其返回值大于0。</p><pre><code>int n = send(socket, buf, buf_length, 0);if (n &gt; 0) &#123;    printf(&quot;send data successfully\n&quot;);&#125;</code></pre><p>以上代码虽然返回值n大于0，但在实际情况下，由于对端的TCP窗口可能因为缺少一部分字节就满了，所以 n 的值可能为（0，buf_length）。当 0 &lt; n &lt; buf_length 时，虽然此时send函数调用成功，但在业务上并不算正确，因为有部分数据并没有被发送出去。我们可能在一次测试中测不出n小于buf_length的情况，但不代表实际上不存在。所以，建议要么在返回值n等于buf_length时才认为正确，要么在一个循环中调用send函数，如果数据一次性发送不完，则记录偏移量，下一次从偏移量处接着发送，直到全部发送完为止：</p><ol><li>不推荐的方式：</li></ol><pre><code class="c">int n = send(socket, buf, buf_length, 0);if (n == buf_length) &#123;    printf(&quot;send data successfully\n&quot;);&#125;</code></pre><p>在不推荐的方式中，使用<code>send</code>函数发送数据，并将返回值与<code>buf_length</code>进行比较。如果相等，则认为发送成功，并打印相应的消息。然而，这种方式并不准确，因为<code>send</code>函数可能在一个请求中无法完全发送所有数据。因此，比较返回值与<code>buf_length</code>可能导致错误的判断。</p><ol><li>推荐的方式：</li></ol><pre><code class="c">bool SendData(const char* buf, int buf_length) &#123;    // 已发送的字节数    int sent_bytes = 0;    int ret = 0;    while (true) &#123;        ret = send(m_hSocket, buf + sent_bytes, buf_length - sent_bytes, 0);        if (ret == -1) &#123;            if (errno == EWOULDBLOCK) &#123;                // 如果发送不出去，则应该缓存尚未发出去的数据                break;            &#125;        &#125; else if (ret == 0) &#123;            return false;        &#125; else &#123;            sent_bytes += ret;            if (sent_bytes &gt;= buf_length) &#123;                break;            &#125;        &#125;    &#125;    return true;&#125;</code></pre><p>在推荐的方式中，通过循环根据偏移量逐步发送数据。使用一个变量<code>sent_bytes</code>来记录已发送的字节数，通过调用<code>send</code>函数发送剩余的数据。在循环中进行错误处理，如检查返回值、处理<code>EWOULDBLOCK</code>错误等。如果所有数据都成功发送，则返回<code>true</code>，否则返回<code>false</code>。</p><h4 id="返回值等于-0"><a href="#返回值等于-0" class="headerlink" title="返回值等于 0"></a>返回值等于 0</h4><p>在通常情况下，如果 send 或 recv 函数返回 0，我们就认为对端关闭了连接，我们这端也关闭连接即可，这是实际开发时最常见的处理逻辑。send函数主动发送0字节时也会返回0，这是一种特例</p><h4 id="返回值小于0"><a href="#返回值小于0" class="headerlink" title="返回值小于0"></a>返回值小于0</h4><p>对于send或recv函数返回值小于0的情况（即返回-1），根据前面的讨论，此时并不表示send或者recv函数一定调用出错。这里以下表进行说明</p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>-1</td><td>发生错误，可通过<code>errno</code>变量获取具体错误代码</td></tr><tr><td>EAGAIN&#x2F;EWOULDBLOCK</td><td>在非阻塞模式下，表示操作被阻塞，稍后再试</td></tr><tr><td>EINTR</td><td>调用被信号中断，可以选择重新调用<code>send</code>或<code>recv</code>函数继续操作</td></tr><tr><td>EMSGSIZE</td><td>发送的数据超出了套接字发送缓冲区的大小限制</td></tr><tr><td>ECONNRESET</td><td>连接被对方重置，表示对方主动关闭连接</td></tr><tr><td>EPIPE</td><td>连接已断开，对于<code>send</code>函数表示对方已关闭连接</td></tr><tr><td>EHOSTUNREACH&#x2F;EHOSTDOWN</td><td>无法到达或目标主机不可用</td></tr><tr><td>ENETDOWN</td><td>网络连接已断开</td></tr><tr><td>ENOTCONN</td><td>套接字未连接</td></tr></tbody></table><p>此表展现的是非阻塞模式下socket的send和recv返回值，对于阻塞模式下的 socket，如果返回值是-1（在 Windows上即SOCKET_ERROR），则一定表示出错。</p><h3 id="阻塞与非阻塞socket的各自适用场景"><a href="#阻塞与非阻塞socket的各自适用场景" class="headerlink" title="阻塞与非阻塞socket的各自适用场景"></a>阻塞与非阻塞socket的各自适用场景</h3><p>阻塞的socket函数在调用send、recv、connect、accept等函数时，如果特定的条件不满足，就会阻塞其调用线程直至超时，非阻塞的 socket恰恰相反。这并不意味着非阻塞模式比阻塞模式模式好，二者各有优缺点。<br>非阻塞模式一般用于需要支持高并发多QPS的场景（如服务器程序），但是正如前文所述，这种模式让程序的执行流和控制逻辑变得复杂；相反，阻塞模式逻辑简单，程序结构简单明了，常用于一些特殊场景中。非阻塞模式的使用非常普遍，这里不再举例，这里举两个可以使用阻塞模式的应用场景。<br>应用场景一：某程序需要临时发送一个文件，文件分段发送，每发送一段，对端都会给予一个响应，该程序可以单独开一个任务线程，在这个任务线程函数里面，使用先 send后recv再send再recv的模式，每次send和recv都是阻塞模式的。<br>应用场景二：A端与B端之间的通信只有问答模式，即A端每发送给B端一个请求，B端必定会给A端一个响应，除此以外，B端不会向A端推送任何数据，此时A端就可以采用阻塞模式，在每次send完请求后，都可以直接使用阻塞式的recv函数接收一定要有的应答包。</p><h2 id="发送0字节数据的效果"><a href="#发送0字节数据的效果" class="headerlink" title="发送0字节数据的效果"></a>发送0字节数据的效果</h2><p>send或recv函数返回0表示对端关闭了连接。有人可能认为如果发送了0字节数据，那么send函数也会返回0，对端会接收到0字节数据。真是这样吗？<br>我们通过一个例子来看看发送一个长度为 0 的数据，send 函数的返回值是什么，对端是否会接收到0字节数据。<br>server端的代码如下</p><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;int main(int argc, char* argv[])&#123;    //1.创建一个侦听socket    int listenfd = socket(AF_INET, SOCK_STREAM, 0);    if (listenfd == -1)    &#123;        std::cout &lt;&lt; &quot;create listen socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.初始化服务器地址    struct sockaddr_in bindaddr;    bindaddr.sin_family = AF_INET;    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);    bindaddr.sin_port = htons(3000);    if (bind(listenfd, (struct sockaddr *)&amp;bindaddr, sizeof(bindaddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;bind listen socket error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;    //3.启动侦听    if (listen(listenfd, SOMAXCONN) == -1)    &#123;        std::cout &lt;&lt; &quot;listen error.&quot; &lt;&lt; std::endl;        close(listenfd);        return -1;    &#125;        int clientfd;     struct sockaddr_in clientaddr;    socklen_t clientaddrlen = sizeof(clientaddr);    //4. 接受客户端连接    clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);    if (clientfd != -1)    &#123;                 while (true)        &#123;            char recvBuf[32] = &#123;0&#125;;            //5. 从客户端接受数据,客户端没有数据来的时候会recv函数会阻塞            int ret = recv(clientfd, recvBuf, 32, 0);            if (ret &gt; 0)             &#123;                std::cout &lt;&lt; &quot;recv data from client, data: &quot; &lt;&lt; recvBuf &lt;&lt; std::endl;            &#125;             else if (ret == 0)            &#123;                //“假设recv返回值为0时是收到了0个字节”                std::cout &lt;&lt; &quot;recv 0 byte data.&quot; &lt;&lt; std::endl;                continue;            &#125;             else            &#123;                //出错                std::cout &lt;&lt; &quot;recv data error.&quot; &lt;&lt; std::endl;                break;            &#125;        &#125;    &#125;        //关闭客户端socket    close(clientfd);    //7.关闭侦听socket    close(listenfd);    return 0;&#125;</code></pre><p>以上代码的监听端口号是3000，如果客户端一直没有数据，则程序会阻塞在recv函数</p><p>client端的代码如下：</p><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)    &#123;        std::cout &lt;&lt; &quot;connect socket error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;        //连接成功以后，我们再将 clientfd 设置成非阻塞模式，    //不能在创建时就设置，这样会影响到 connect 函数的行为    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //3. 不断向服务器发送数据，或者出错退出    int count = 0;    while (true)    &#123;        //发送 0 字节的数据        int ret = send(clientfd, SEND_DATA, 0, 0);        if (ret == -1)         &#123;            //非阻塞模式下send函数由于TCP窗口太小发不出去数据，错误码是EWOULDBLOCK            if (errno == EWOULDBLOCK)            &#123;                std::cout &lt;&lt; &quot;send data error as TCP Window size is too small.&quot; &lt;&lt; std::endl;                continue;            &#125;             else if (errno == EINTR)            &#123;                //如果被信号中断，我们继续重试                std::cout &lt;&lt; &quot;sending data interrupted by signal.&quot; &lt;&lt; std::endl;                continue;            &#125;             else             &#123;                std::cout &lt;&lt; &quot;send data error.&quot; &lt;&lt; std::endl;                break;            &#125;        &#125;        else if (ret == 0)        &#123;            //发送了0字节            std::cout &lt;&lt; &quot;send 0 byte data.&quot; &lt;&lt; std::endl;        &#125;         else        &#123;            count ++;            std::cout &lt;&lt; &quot;send data successfully, count = &quot; &lt;&lt; count &lt;&lt; std::endl;        &#125;                //每三秒发一次        sleep(3);    &#125;        //5. 关闭socket    close(clientfd);    return 0;&#125;</code></pre><p>send函数发送0字节数据，此时send函数返回0，但client端的操作系统协议栈并不会把这些数据发送出去，因此，server端也会一直没有输出。</p><p>通过上面的测试，可以知道存在以下两种情形让send函数的返回值为0：</p><ul><li>对端关闭连接时，我们正好尝试调用send函数发送数据；</li><li>本端尝试调用send函数发送0字节数据。<br>而 recv 函数只有在对端关闭连接时才会返回 0，对端发送 0 字节数据，本端的 recv函数是不会收到0字节数据的。然而，发送一个0字节数据是没有任何意义的，在实际开发要避免写出可能调用send函数发送0字节数据的代码。</li></ul><h2 id="connect函数在阻塞和非阻塞模式下的行为"><a href="#connect函数在阻塞和非阻塞模式下的行为" class="headerlink" title="connect函数在阻塞和非阻塞模式下的行为"></a>connect函数在阻塞和非阻塞模式下的行为</h2><p>当socket使用阻塞模式时，connect函数会一直到有明确的结果才会返回（或连接成功或连接失败），如果服务器地址“较远”或者网络状况不好，连接速度较慢，则程序可能会在 connect 函数处阻塞好一会儿（如两三秒之久）。虽然这一般也不会对依赖于网络通信的程序造成什么影响，但在实际项目中，我们一般倾向于使用异步connect技术（非阻塞connect），一般有如下步骤。</p><ul><li><p>创建socket，将socket设置为非阻塞模式。</p></li><li><p>调用 connect 函数，此时无论 connect 函数是否连接成功，都会立即返回；如果返回-1，则并不一定表示连接出错，如果此时错误码是EINPROGRESS，则表示正在尝试连接。</p></li><li><p>调用select函数，在指定的时间内判断该socket是否可写，如果可写，则说明连接成功，反之认为连接失败。<br>代码如下：</p><p>  #include &lt;sys&#x2F;types.h&gt;<br>  #include &lt;sys&#x2F;socket.h&gt;<br>  #include &lt;arpa&#x2F;inet.h&gt;<br>  #include &lt;unistd.h&gt;<br>  #include <iostream><br>  #include &lt;string.h&gt;<br>  #include &lt;stdio.h&gt;<br>  #include &lt;fcntl.h&gt;<br>  #include &lt;errno.h&gt;</iostream></p><p>  #define SERVER_ADDRESS  “127.0.0.1”<br>  #define SERVER_PORT     3000<br>  #define SEND_DATA       “helloworld”</p><p>  int main(int argc, char* argv[])<br>  {<br>  &#x2F;&#x2F;1.创建一个socket<br>  int clientfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);<br>  if (clientfd &#x3D;&#x3D; -1)<br>  {<br>      std::cout &lt;&lt; “create client socket error.” &lt;&lt; std::endl;<br>      return -1;<br>  }<br><br>  &#x2F;&#x2F;将clientfd设置成非阻塞模式<br>  int oldSocketFlag &#x3D; fcntl(clientfd, F_GETFL, 0);<br>  int newSocketFlag &#x3D; oldSocketFlag | O_NONBLOCK;<br>  if (fcntl(clientfd, F_SETFL,  newSocketFlag) &#x3D;&#x3D; -1)<br>  {<br>      close(clientfd);<br>      std::cout &lt;&lt; “set socket to nonblock error.” &lt;&lt; std::endl;<br>      return -1;<br>  }<br><br>  &#x2F;&#x2F;2.连接服务器<br>  struct sockaddr_in serveraddr;<br>  serveraddr.sin_family &#x3D; AF_INET;<br>  serveraddr.sin_addr.s_addr &#x3D; inet_addr(SERVER_ADDRESS);<br>  serveraddr.sin_port &#x3D; htons(SERVER_PORT);<br>  for (;;)<br>  {<br>      int ret &#x3D; connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));<br>      if (ret &#x3D;&#x3D; 0)<br>      {<br>          std::cout &lt;&lt; “connect to server successfully.” &lt;&lt; std::endl;<br>          close(clientfd);<br>          return 0;<br>      }<br>      else if (ret &#x3D;&#x3D; -1)<br>      {<br>          if (errno &#x3D;&#x3D; EINTR)<br>          {<br>              &#x2F;&#x2F;connect 动作被信号中断，重试connect<br>              std::cout &lt;&lt; “connecting interruptted by signal, try again.” &lt;&lt; std::endl;<br>              continue;<br>          }<br>          else if (errno &#x3D;&#x3D; EINPROGRESS)<br>          {<br>              &#x2F;&#x2F;连接正在尝试中<br>              break;<br>          }<br>          else<br>          {<br>              &#x2F;&#x2F;真的出错了，<br>              close(clientfd);<br>              return -1;<br>          }<br>      }<br>  }<br><br>  fd_set writeset;<br>  FD_ZERO(&amp;writeset);<br>  FD_SET(clientfd, &amp;writeset);<br>  struct timeval tv;<br>  tv.tv_sec &#x3D; 3;<br>  tv.tv_usec &#x3D; 0;<br>  &#x2F;&#x2F;3.调用select函数判断socket是否可写<br>  if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) &#x3D;&#x3D; 1)<br>  {<br>      std::cout &lt;&lt; “[select] connect to server successfully.” &lt;&lt; std::endl;<br>  }<br>  else<br>  {<br>      std::cout &lt;&lt; “[select] connect to server error.” &lt;&lt; std::endl;<br>  }<br><br>  close(clientfd);<br><br>  return 0;<br>  }</p></li></ul><p>我们把服务端程序关掉，再启动客户端，这时应该会连接失败，程序输出结果：</p><pre><code>[root@localhost testsocket]# ./nonblocking_connect[select] connect to server successfully.</code></pre><p>为了区别到底是通过调用connect函数判断连接成功的，还是通过调用select函数判断连接成功的，select的输出内容中都加上了[select]标签以示区别<br>（1）在 Windows 上，一个 socket 没有建立连接之前，我们使用 select 函数检测其是否可写，能得到正确的结果（不可写），连接成功后检测，会变为可写。所以，上述介绍的异步connect写法流程在Windows上是没有问题的。<br>（2）在Linux上一个socket没有建立连接之前，用select函数检测其是否可写，我们也会得到可写的结果，所以上述流程并不适用于Linux。Linux上正确的做法是，connect之后，不仅要调用 select检测是否可写，还要调用 getsockopt检测此时 socket是否出错，通过错误码来检测和确定是否连接上，错误码为0时表示连接上，反之表示未连接上。完整的代码如下：</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SERVER_ADDRESS &quot;127.0.0.1&quot;#define SERVER_PORT     3000#define SEND_DATA       &quot;helloworld&quot;int main(int argc, char* argv[])&#123;    //1.创建一个socket    int clientfd = socket(AF_INET, SOCK_STREAM, 0);    if (clientfd == -1)    &#123;        std::cout &lt;&lt; &quot;create client socket error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //将clientfd设置成非阻塞模式    int oldSocketFlag = fcntl(clientfd, F_GETFL, 0);    int newSocketFlag = oldSocketFlag | O_NONBLOCK;    if (fcntl(clientfd, F_SETFL,  newSocketFlag) == -1)    &#123;        close(clientfd);        std::cout &lt;&lt; &quot;set socket to nonblock error.&quot; &lt;&lt; std::endl;        return -1;    &#125;    //2.连接服务器    struct sockaddr_in serveraddr;    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);    serveraddr.sin_port = htons(SERVER_PORT);    for (;;)    &#123;        int ret = connect(clientfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));        if (ret == 0)        &#123;            std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;            close(clientfd);            return 0;        &#125;        else if (ret == -1)        &#123;            if (errno == EINTR)            &#123;                //connect 动作被信号中断，重试connect                std::cout &lt;&lt; &quot;connecting interruptted by signal, try again.&quot; &lt;&lt; std::endl;                continue;            &#125;            else if (errno == EINPROGRESS)            &#123;                //连接正在尝试中                break;            &#125;            else            &#123;                //真的出错了，                close(clientfd);                return -1;            &#125;        &#125;    &#125;    fd_set writeset;    FD_ZERO(&amp;writeset);    FD_SET(clientfd, &amp;writeset);    struct timeval tv;    tv.tv_sec = 3;    tv.tv_usec = 0;    //3.调用select函数判断socket是否可写    if (select(clientfd + 1, NULL, &amp;writeset, NULL, &amp;tv) != 1)    &#123;        std::cout &lt;&lt; &quot;[select] connect to server error.&quot; &lt;&lt; std::endl;        close(clientfd);        return -1;    &#125;    int err;    socklen_t len = static_cast&lt;socklen_t&gt;(sizeof err);    //4.调用getsockopt检测此时socket是否出错    if (::getsockopt(clientfd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;len) &lt; 0)    &#123;        close(clientfd);        return -1;    &#125;    if (err == 0)        std::cout &lt;&lt; &quot;connect to server successfully.&quot; &lt;&lt; std::endl;    else        std::cout &lt;&lt; &quot;connect to server error.&quot; &lt;&lt; std::endl;    close(clientfd);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络库的分层设计</title>
      <link href="/p/a5662a20.html"/>
      <url>/p/a5662a20.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络库的分层设计"><a href="#网络库的分层设计" class="headerlink" title="网络库的分层设计"></a>网络库的分层设计</h1><blockquote><p>对于计算机科学领域中的任何问题，都可以通过增加一个间接的中间层来解决</p></blockquote><p>这句话几乎概括了计算机软件体系结构的设计要点。计算机软件体系结构从上到下都是按照严格的层次结构设计的，不仅整个体系如此，体系里面的每个组件如OS本身、很多应用程序、软件系统甚至很多硬件结构也如此。</p><h2 id="网络库设计中的各个层"><a href="#网络库设计中的各个层" class="headerlink" title="网络库设计中的各个层"></a>网络库设计中的各个层</h2><p>常见的网络通信库根据功能也可以分成很多层，根据离业务的远近从上到下依次是Session层、Connection层、Channel层、Socket层，其中Session层属于业务层，Connection层、Channel层、Socket层属于技术层，示意图如下。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClFw8g.png" alt="pClFw8g.png"><br>下面依次介绍各层的作用。</p><h3 id="Session层"><a href="#Session层" class="headerlink" title="Session层"></a>Session层</h3><p>Session层处于顶层，在设计上不属于网络框架本身，用于记录各种业务状态数据和处理各种业务逻辑。在业务逻辑处理完毕后，如果需要进行网络通信，则依赖Connection层进行数据收发。例如一个IM服务的Session类可能有如下接口和成员数据</p><pre><code>typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;typedef const TcpConnectionPtr&amp; CTcpConnectionPtrR;class ChatSession &#123;public:    ChatSession(CTcpConnectionPtrR conn, int sessionId);    virtual ~ChatSession();        int32_t GetSessionId();    int32_t GetUserId();    std::string GetUsername();    int32_t GetClientType();    int32_t GetUserStatus();    int32_t GetUserClientType();    void SendUserStatusChangeMsg(int32_t userId, int type, int status = 0);    TcpConnectionPtr GetConnectionPtr();        // Call the lower-level connection layer methods to send data    void Send(int32_t cmd, int32_t seq, const std::string&amp; data);    void Send(int32_t cmd, int32_t seq, const char* data, int32_t dataLength);    void Send(const std::string&amp; data);    void Send(const char* data, int32_t length);private:    int32_t m_id; // session id    onlineUserInfo m_userinfo; // user information for this session    int32_t m_seq; // current session data packet sequence number    bool m_isLogin; // whether the user for this session is logged in    std::weak_ptr&lt;TcpConnection&gt; m_tmpConn; // reference to the lower-level connection        // Various business logic processing methods    bool Process(CTcpConnectionPtrR conn, const char* inBuf, size_t bufLength);    void onHeartbeatResponse(CTcpConnectionPtrR conn);    void OnRegisterResponse(const std::string&amp; data, CTcpConnectionPtrR conn);    void onLoginResponse(const std::string&amp; data, CTcpConnectionPtrR conn);    void onGetFriendListResponse(CTcpConnectionPtrR conn);    void OnFindUserResponse(const std::string&amp; data, CTcpConnectionPtrR conn);    void OnChangeUserStatusResponse(const std::string&amp; data, CTcpConnectionPtrR conn);&#125;;</code></pre><p>在以上代码中除了业务状态数据和业务接口，还有一个send系列的函数，这个函数依赖Connection对象进行数据收发。</p><p>但是，Session对象并不拥有Connection对象，也就是说Session对象不控制Connection对象的生命周期。这是因为虽然Session对象的主动销毁（如收到非法的客户端数据并关闭Session对象）会引起Connection对象的销毁，但Connection对象本身也可能因为网络出错等原因被销毁，进而引起Session对象被销毁。</p><p>因此，在上述类接口描述中，ChatSession类使用了一个std::weak_ptr来引用TCPConnection对象。这是需要注意的地方。</p><h3 id="Connection层"><a href="#Connection层" class="headerlink" title="Connection层"></a>Connection层</h3><p>Connection 层是技术层的顶层，每一路客户端连接都对应一个 Connection 对象，该层一般用于记录连接的各种状态信息。</p><p>常见的状态信息有连接状态、数据收发缓冲区信息、数据流量信息、本端和对端的地址和端口号信息等，同时提供对各种网络事件的处理接口，这些接口或被本层自己使用，或被Session层使用。</p><p>Connection持有一个Channel对象，而且掌管Channel对象的生命周期。</p><p>一个Connection对象可以提供的接口和记录的数据状态如下：</p><pre><code>class TcpConnection &#123;public:    TcpConnection(EventLoop* loop,                const std::string&amp; name,                int sockfd,                const InetAddress&amp; localAddr,                const InetAddress&amp; peerAddr);    ~TcpConnection();    const InetAddress&amp; localAddress() const;    const InetAddress&amp; peerAddress() const;    bool connected() const;    void send(const void* message, int len);    void send(const std::string&amp; message);    void send(Buffer* message);    void shutdown();    void forceClose();    void setConnectionCallback(const ConnectionCallback&amp; cb);    void setMessageCallback(const MessageCallback&amp; cb);    void setCloseCallback(const CloseCallback&amp; cb);    void setErrorCallback(const ErrorCallback&amp; cb);    Buffer* getInputBuffer();    Buffer* getOutputBuffer();private:    enum State &#123;        kDisconnected,        kConnecting,        kConnected,        kDisconnecting    &#125;;    void handleRead(Timestamp receiveTime);    void handleWrite();    void handleClose();    void handleError();    void sendInLoop(const std::string&amp; message);    void sendInLoop(const void* message, size_t len);    void shutdownInLoop();    void forceCloseInLoop();    void setState(State s);    State state_;    std::shared_ptr&lt;Channel&gt; channel_;    InetAddress localAddr_;    InetAddress peerAddr_;    ConnectionCallback connectionCallback_;    MessageCallback messageCallback_;    CloseCallback closeCallback_;    ErrorCallback errorCallback_;    Buffer inputBuffer_;    Buffer outputBuffer_;    CFlowStatistics flowStatistics_;&#125;;</code></pre><h3 id="Channel层"><a href="#Channel层" class="headerlink" title="Channel层"></a>Channel层</h3><p>Channel层一般持有一个socket句柄，是实际进行数据收发的地方，因而一个Channel对象会记录当前需要监听的各种网络事件（读写和出错事件）的状态，同时提供对这些事件状态的查询和增删改接口。</p><p>在部分网络库的实现中，Channel对象管理着socket对象的生命周期，因此Channel对象需要提供创建和关闭socket对象的接口；而在另外一些网络库的实现中由Connection对象直接管理socket对象的生命周期，也就是说没有Channel层。</p><p>所以，Channel层不是必需的。</p><p>由于TCP收发数据是全双工的（收发走独立的通道，互不影响），所以<strong>收发逻辑一般不会有依赖关系，但收发操作一般会被放在同一个线程中进行</strong>，这样做的目的是防止在收发过程中改变socket状态时，对另一个操作产生影响。假设收发操作分别使用一个线程，在一个线程中收数据时因出错而关闭了连接，但另一个线程可能正在发送数据，这样就会出问题。</p><pre><code>class Channel &#123;public:    Channel(EventLoop* loop, int fd);    ~Channel();    void handleEvent(Timestamp receiveTime);    int fd() const;    int events() const;    void setRevents(int revt);    void addRevents(int revt);    void removeEvents();    bool isNoneEvent() const;    bool enableReading();    bool disableReading();    bool enableWriting();    bool disableWriting();    bool disableAll();    bool isWriting() const;private:    const int fd_;    int events_;    int revents_;&#125;;</code></pre><h3 id="Socket层"><a href="#Socket层" class="headerlink" title="Socket层"></a>Socket层</h3><p>严格来说，并不存在Socket层，这一层通常只是对常用的socket函数进行封装，例如屏蔽不同操作系统操作socket函数的差异性来实现跨平台，方便上层使用。</p><p>如果存在 Channel 层，则 Socket 层的上层就是 Channel 层；如果不存在Channel层，则Socket层的上层就是Connection层。</p><p>Socket层也不是必需的，因此很多网络库都没有Socket层。</p><p>下面是某Socket层对常用socket函数的功能进行一层简单封装的接口示例：</p><pre><code>namespace sockets &#123;#ifdef WIN32    typedef int SOCKET;#else    typedef int SOCKET;#endif    SOCKET createOrDie();    SOCKET createNonblockingOrDie();    void setNonBlockAndCloseOnExec(SOCKET sockfd);    void setReuseAddr(SOCKET sockfd, bool on);    void setReusePort(SOCKET sockfd, bool on);    int connect(SOCKET sockfd, const struct sockaddr_in&amp; addr);    void bindOrDie(SOCKET sockfd, const struct sockaddr_in&amp; addr);    void listenOrDie(SOCKET sockfd);    int accept(SOCKET sockfd, struct sockaddr_in* addr);    int32_t read(SOCKET sockfd, void* buf, int32_t count);#ifndef WIN32    ssize_t readv(SOCKET sockfd, const struct iovec* iov, int iovcnt);#endif    int32_t write(SOCKET sockfd, const void* buf, int32_t count);    void close(SOCKET sockfd);    void shutdownWrite(SOCKET sockfd);    void toIpPort(char* buf, size_t size, const struct sockaddr_in&amp; addr);    void toIp(char* buf, size_t size, const struct sockaddr_in&amp; addr);    void fromIpPort(const char* ip, uint16_t port, struct sockaddr_in* addr);    int getSocketError(SOCKET sockfd);    struct sockaddr_in getLocalAddr(SOCKET sockfd);    struct sockaddr_in getPeerAddr(SOCKET sockfd);&#125;</code></pre><p>在实际开发中，有的服务在设计网络通信模块时会将Connection层与Channel层合并成一层，当然，这取决于业务的复杂程度。所以在某些服务代码中只看到 Connection对象或者Channel对象时，请不要觉得奇怪。<br>另外，对于服务端程序，抛开业务本身，从技术层面上来说，我们需要一个 Server对象（如TcpServer）来集中管理多个Connection对象，这也是网络库自身需要处理好的部分。一个TcpServer对象可能需要提供如下函数接口和状态数据：</p><pre><code>class TcpServer &#123;public:    typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;    enum Option &#123;        kNoReusePort,        kReusePort,    &#125;;    TcpServer(EventLoop* loop,            const InetAddress&amp; listenAddr,            const std::string&amp; nameArg,            Option option = kReusePort);    TcpServer();    void addConnection(int sockfd, const InetAddress&amp; peerAddr);    void removeConnection(const TcpConnectionPtr&amp; conn);private:    int nextConnId_;    std::map&lt;std::string, TcpConnectionPtr&gt; connections_;&#125;;</code></pre><p>对于客户端程序来说，同样可以设计出一个 TCPClient 对象来管理各个Connector（连接器对象）。Session对象虽然与Connection对象一一对应，但在业务层（网络通信框架之外）需要有专门的类来管理这些 Session 对象的生命周期，我们一般把这个专门的类称为SessionManager或者SessionFactory</p><h2 id="将Session进一步分层"><a href="#将Session进一步分层" class="headerlink" title="将Session进一步分层"></a>将Session进一步分层</h2><p>不同的服务，其业务可能千差万别，在实际开发中，我们可以根据业务场景将Session层进一步拆分成多个层，使每一层都专注于自己的业务逻辑。例如，假设现在有一个需要支持聊天消息压缩的即时通信服务，我们可以将Session划分为三个层，从上到下依次是ChatSession、CompressionSession 和 TcpSession。ChatSession 负责处理聊天业务本身，CompressSession负责数据的解压缩，TcpSession 负责将数据加工成网络层需要的格式或者将网络层发送的数据还原成业务需要的格式（如数据装包和解包），示意图如下。</p><p><img src="https://s1.ax1x.com/2023/06/17/pClFjRe.png" alt="pClFjRe.png"></p><h2 id="连接信息与EventLoop-x2F-Thread的对应关系"><a href="#连接信息与EventLoop-x2F-Thread的对应关系" class="headerlink" title="连接信息与EventLoop&#x2F;Thread的对应关系"></a>连接信息与EventLoop&#x2F;Thread的对应关系</h2><p>综合各层对象，一个socket（fd）只对应一个Channel对象、一个Connection对象及一个 Session 对象，这组对象构成了一路连接信息（技术加业务上的）。结合前面介绍的one thread one loop思想，每一路连接信息都只能属于一个loop，也就是说只属于某个线程；但是反过来，一个 loop或者一个线程可以同时拥有多个连接信息，这就保证了我们只会在同一个线程里面处理特定的socket收发事件。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络通信协议设计</title>
      <link href="/p/485abdb0.html"/>
      <url>/p/485abdb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信协议设计"><a href="#网络通信协议设计" class="headerlink" title="网络通信协议设计"></a>网络通信协议设计</h1><p>在计算机技术体系中存在很多网络通信协议。通信协议实质上就是一段数据，通信双方事先约定好按规定的格式去编码和解码，最终达到传输消息的目的。TCP&#x2F;IP 是目前各种计算机设备最常用的协议。当然，TCP&#x2F;IP 也是一个协议簇，包含一组协议，其中靠近应用层且最常用的是TCP和UDP。</p><h2 id="理解TCP"><a href="#理解TCP" class="headerlink" title="理解TCP"></a>理解TCP</h2><p>TCP是流式协议。流式协议，即协议的内容是流水一样的字节流，内容与内容之间没有明确的分界标志，需要我们人为地给这些内容划分边界。举个例子，A与B进行TCP通向，A先后给B发送了两个大小分别是100字节和200字节的数据包，那么B是如何收到数据包的呢？B可能先后收到100、200字节；也可能先后收到50、250字节；或者先后收到100、100、100字节；或者先后收到20、20、60、100、50、50字节……<br>A一共向 B发送了 300字节，B可能以一次或者多次总数为300字节的任意形式收到。假设A向B发送了两个大小分别是100字节和200字节的数据包，则作为发送方的A来说，A是知道如何划分这两个数据包的界限的，但是对于 B来说，如果不人为规定将多少字节作为一个数据包，则 B每次是不知道应该把收到的数据中的多少字节作为一个有效的数据包的，而规定每次把多少数据作为一个包就是协议格式需要定义的内容之一。</p><p>经常会有新手写出类似下面这样的代码。<br>发送端：</p><pre><code>//省略创建socket、建立连接等部分不相关的逻辑char buf[] = &quot;the quick brown fox jumps over a lazy dog.&quot;;int n = send(socket, buf,strlen(buf),0);//省略出错处理逻辑</code></pre><p>接收端：</p><pre><code>//省略创建socket、建立连接等部分不相关的逻辑char recvBuf[50] = &#123;0&#125;;int n = recv (socket, recvBuf,50,0);//省略出错处理逻辑printf (&quot; recvBuf: %s&quot;, recvBuf);</code></pre><p>在以上代码中，发送端向接收端发送了一串字符“the quickbrown fox jumps over a lazy dog.”，接收端收到后将其打印了出来。<br>类似这样的代码在本机上一般会工作得很好，接收端也如期打印出期望的字符串，但是这样的代码在局域网或者公网环境下会出问题，即接收端打印的字符串可能并不完整；如果发送端连续多次发送字符串，则接收端打印的字符串可能不完整或者是乱码。打印的代码不完整的原因很好理解：对端某次收到的数据小于完整字符串的长度，recvBuf数组开始被清空成\0，收到部分字符串后，该字符串的末尾仍然是\0，printf 函数寻找以\0 为结束标志的字符结束输出。乱<br>码的原因：如果某次收入的数据不仅包含一个完整的字符串，还包含下一个字符串的部分内容，那么 recvBuf 数组将被填满，printf 函数输出时仍会寻找以\0为结束标志的字符结束输出，这样读取的内存就越界了，一直找到\0为止；而越界后的内存可能是一些不可读字符，显示乱码。</p><h2 id="如何解决粘包问题"><a href="#如何解决粘包问题" class="headerlink" title="如何解决粘包问题"></a>如何解决粘包问题</h2><p>进行技术面试时，面试官经常会问：“网络通信时，如何解决粘包、丢包或者包乱序问题？”这其实考察的就是网络基础知识。如果使用TCP进行通信，则在大多数场景下是不存在丢包和包乱序问题的。因为 TCP通信是可靠的通信方式，TCP栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发送到目的地；如果使用UDP进行通信，且不允许少量丢包，就要自己在UDP的基础上实现类似TCP这种有序和可靠的传输机制了（例如RTP、RUDP）。所以将该问题拆解后，就只剩下如何解决粘包的问题。<br>什么是粘包？粘包就是连续向对端发送两个或者两个以上的数据包，对端在一次收取中收到的数据包数量可能大于1个，当大于1个时，可能是几个（包括一个）包加上某个包的部分，或者干脆几个完整的包在一起。当然，也可能收到的数据只是一个包的部分，这种情况一般也叫作半包<br>粘包示意图如下图所示:</p><p><img src="https://s1.ax1x.com/2023/06/16/pCQnOSK.png" alt="pCQnOSK.png"></p><p>无论是半包问题还是粘包问题，因为 TCP 是流式数据格式，所以其解决思路还是从收到的数据中把包与包的边界区分出来。如何区分呢？一般有以下三种方法。</p><ul><li><p>固定包长的数据包。固定包长，即每个协议包的长度都是固定的。假如我们规定每个协议包的大小都是64字节，每收满64字节，就取出来解析（如果不够，就先存起来），则这种通信协议的格式简单但灵活性差。如果包的内容长度小于指定的字节数，对剩余的空间就需要填充特殊的信息，例如\0（如果不填充特殊的内容，那么如何区分包里面的正常内容与填充信息呢）；如果包的内容超过指定的字节数，又得分包分片，则需要增加额外的处理逻辑——在发送端进行<br>分包分片，在接收端重新组装包片。</p></li><li><p>以指定的字符（串）为包的结束标志。这种协议包比较常见，即在字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如 FTP或SMTP，在一个命令或者一段数据后面加上\r\n（即 CRLF）表示一个包的结束。对端收到数据后，每遇到一个“\r\n”，就把之前的数据当作一个数据包。这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包的内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错<br>误地当成包结束标志而误解析。</p></li><li><p>包头+包体格式。这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头必须包含一个字段来说明接下来的包体有多大。例如：</p><p>  struct msg header{<br>  int32_t bodysize;<br>  int32_t cmd;<br>  };</p></li></ul><p>就是一个典型的包头格式，bodySize指定了这个包的包体是多大。由于包头的大小是固定的（这里是size（int32_t）+sizeof（int32_t）&#x3D;8字节），所以对端先收取包头大小的字节内容（当然，如果不够，则还是将其先缓存起来，直到收够为止），然后解析包头，根据包头中指定的包体大小收取包体，等包体收够了，就组装成一个完整的包来处理。在某些实现中，包头中的bodySize可能被另一个叫作packageSize的字段代替，这个字段用于表示整个包的大小（即包头加上包体的大小），这时，我们只要用 packageSize 减去包头大小（这里是sizeof（msg_header））就能算出包体的大小，原理同上。<br>在使用大多数网络库时，我们通常需要根据协议的格式自己对数据包分界和解析，一般的网络库不提供这种功能是因为需要支持不同的协议。由于协议的不确定性，网络库无法预先提供具体的解包代码。当然，这不是绝对的，也有一些网络库提供了这种功能。在 JavaNetty 网络框架中提供了 ixedLengthFrameDecoder类处理长度是定长的协议包，提供了 DelimiterBasedFrameDecoder 类处理将特殊字符作为结束符的协议包，提供了 ByteToMessageDecoder 类处理自定义格式的协议包（可用来处理包头+包体这种格式的数据包）。然而，在继承ByteToMessageDecoder的子类中，我们需要根据自己的协议的具体格式重写 decode 方法对数据包进行解包。</p><h2 id="解包与处理"><a href="#解包与处理" class="headerlink" title="解包与处理"></a>解包与处理</h2><p>在理解前面介绍的数据包的三种格式后，这里介绍应该如何处理前述三种格式的数据包。其处理流程都是一样的，这里以包头+包体这种格式的数据包来说明。流程图如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/16/pCQudt1.png" alt="pCQudt1.png"></p><p>假设我们的包头格式如下：</p><pre><code>//强制1字节对齐pragma pack (push, 1)//协议头struct msg headerint32_t bodysize;//包体大小;#pragma pack (pop)</code></pre><p>那么上面的流程实现代码如下：</p><pre><code>// 包的最大字节数限制为10MB#define MAX_PACKAGE_SIZE (10 * 1024 * 1024)void ChatSession::OnRead(const std::shared_ptr&lt;TepConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receiveTime)&#123;    while (true)    &#123;        if (pBuffer-&gt;readableBytes() &lt; static_cast&lt;size_t&gt;(sizeof(msg_header)))        &#123;            // 不够一个包头大小，直接退出            return;        &#125;        // 取包头信息        msg_header header;        memcpy(&amp;header, pBuffer-&gt;peek(0, sizeof(msg_header)));        // 包头有错误，立即关闭连接        if (header.bodysize &lt; 0 || header.bodysize &gt; MAX_PACKAGE_SIZE)        &#123;            // 客户端发送非法数据包，服务器主动关闭它            LOGE(&quot;Illegal package, bodysize: %lld, close TcpConnection, client: %s&quot;,                header.bodysize, conn-&gt;peerAddress().toIpPort().c_str());            conn-&gt;forceClose();            return;        &#125;        // 收到的数据不够一个完整的包        if (pBuffer-&gt;readableBytes() &lt; static_cast&lt;size_t&gt;(header.bodysize + sizeof(msg_header)))        &#123;            return;        &#125;        pBuffer-&gt;retrieve(sizeof(msg_header));        // inbuf 用来存放当前要处理的包        std::string inbuf;        inbuf.append(pBuffer-&gt;peek(0, header.bodysize));        pBuffer-&gt;retrieve(header.bodysize);        // 解包和业务处理        if (!Process(conn, inbuf.c_str(), inbuf.length()))        &#123;            // 客户端发送非法数据包，服务器主动关闭它            LOGE(&quot;Process package error, close Tcpconnection, client: %s&quot;,                conn-&gt;peerAddress().toIpPort().c_str());            conn-&gt;forceClose();            return;        &#125;    &#125;&#125;</code></pre><p>以上代码中的操作与流程图所示是一致的。pBuffer 是一个自定义的接收缓冲区，这部分代码已经将收到的数据放入这个缓冲区中，所以判断当前已收取的字节数时只需使用这个对象的相应方法即可。在以上代码中有些细节需要强调。</p><ul><li>取包头时应该拷贝一份数据包头大小的数据出来，而不是从缓冲区pBuffer中直接将数据取出来（将取出来的数据从 pBuffer中移除），这是因为若接下来根据包头中的字段得到包体大小时，剩余的数据不够一个包体的大小，则我们还得把这个包头数据放回缓冲区中。为了避免这种不必要的操作，只有缓冲区中的数据大小够整个包的大小（代码中的header.bodysize+sizeof（msg））时，我们才需要把整个包大小的数据从缓冲区中移除。</li><li>通过包头得到包体的大小时，我们一定要对 bodysize的数值进行校验，这里要求bodysize必须大于0且不大于10×1024×1024（即10MB）。当然，我们可以根据实际情况决定bodysize的上下限（大小是0字节的包在某些业务场景下是允许的）。记住，一定要判断这个上下限，因为假设这是一个非法的客户端发来的数据，其 bodysize设置了一个较大的数值，例如1×1024×1024×1024（即 1GB），则我们的逻辑会让我们一直缓存该客户端发来的数据，服务器内存将很快被耗尽，操作系统在检测到我们的进程占用的内存达到一定阈值时会杀死我们的进程，导致服务不能再正常对外服务。如果判断了bodysize字段是否满足自己设置的上下限，则对于非法的bodysize，直接关闭这路连接即可。这也是服务的一种自我保护措施，避免因为非法数据包带来的损失。还有另外一<br>种情况，bodysize也可能不是预期的合理值，即因为网络环境差或者某次数据解析逻辑错误，导致后续的数据错，把不该当包头数据的<br>数据当作了包头，这时解析出来的 bodysize也可能不是合理的值；同样，在这种情形下也会被这段检验逻辑检测到，最终关闭连接。</li><li>注意，整个判断包头、包体及处理包的逻辑都被放在一个while循环里，这是必要的。如果没有这个while循环，则当我们一次性收到多个包时，只会处理一个，下次接着处理就需要等到新的一批数据来临时再次触发这个逻辑。这样造成的结果就是，对端向我们发送了多个请求，我们最多只能应答一个，后面的应答得等到对端再次向我们发送数据才能进行。这就是对粘包逻辑的正确处理</li></ul><h2 id="从struct到TLV"><a href="#从struct到TLV" class="headerlink" title="从struct到TLV"></a>从struct到TLV</h2><p>计算机中有各种格式的网络通信协议，不同的应用场景使用的网络通信协议可能不同，对于一名合格的后端开发者来说，根据应用场景设计合理的网络通信协议是对其的基本要求。那么在设计网络通信协议时，我们需要考虑哪些因素呢？</p><p>假设现在 A与 B之间要传输一个关于用户信息的数据包，则可以将该数据包格式定义成如下形式</p><pre><code>#pragma pack(push, 1)struct userinfo&#123;    // 命令号    int32_t cmd;    // 用户性别    char gender;    // 用户姓名    char name[8];&#125;;#pragma pack(pop)</code></pre><p>这样的协议，其数据结构简单明了，对端只要直接拷贝数据并按顺序解析各个字段就可以了。但是，需求总在变化，例如随着业务的发展，我们需要在这个结构中增加一个字段表示用户的年龄，则可将协议结构修改如下：</p><pre><code>#pragma pack(push, 1)struct userinfo&#123;    // 命令号    int32_t cmd;    // 用户性别    char gender;    // 用户昵称    char name[8];    // 用户年龄    int32_t age;&#125;;#pragma pack(pop)</code></pre><p>在这种情况下，在技术上直接增加一个字段并不能完全解决问题，因为新修改的协议格式在旧的客户端上无法兼容（旧的客户端已经分发出去），这时我们升级服务端的协议格式，会导致旧的客户端无法使用。所以在最初设计协议时，需要增加一个版本号字段，针对不同的版本做不同的处理：</p><pre><code>#pragma pack(push, 1)// 旧的协议, 版本号是1struct userinfo_v1&#123;    // 版本号    short version;    // 命令号    int32_t cmd;    // 用户性别    char gender;    // 用户昵称    char name[8];&#125;;#pragma pack(pop)#pragma pack(push, 1)// 新的协议, 版本号是2struct userinfo_v2&#123;    // 版本号    short version;    // 命令号    int32_t cmd;    // 用户性别    char gender;    // 用户昵称    char name[8];    // 用户年龄    int32_t age;&#125;;#pragma pack(pop)</code></pre><p>可以用以下伪代码来兼容新旧协议：</p><pre><code>//从包中读收一个 short型字段short version = &lt;从包中读取一个short型字段&gt;;if (version == 1)&#123;    //当作旧的协议格式进行处理&#125;else if (version == 2)&#123;    //当作新的协议格式进行处理&#125;</code></pre><p>以上是兼容旧版协议的常见做法，这样也存在一个问题，如果我们的业务需求变化快，则可能需要经常调整协议字段（增、删、改），这样我们的版本号数量会较多，代码会变成类似下面这种形式</p><pre><code>//从包中读取一个 short型字段short version = &lt;从包中读取一个 short型字段&gt;;if (version == 版本号1)&#123;    //对版本号1的格式进行处理&#125;else if(version == 版本号2)&#123;    //对版本号2的格式进行处理&#125;else if (version == 版本号3)&#123;    //对版本号3的格式进行处理&#125;else if (version == 版本号4)&#123;    //对版本号4的格式进行处理&#125;else if (version == 版本号5)&#123;    //对版本号5的格式进行处理&#125;...省略更多内容...</code></pre><p>以上只考虑了协议顶层结构，没有考虑更复杂的嵌套结构，不管怎样，这样的代码会变得越来越难以维护。这里只是为了说明问题，在实际开发中，建议在设计协议时尽量考虑周全，避免反复修改协议的结构。前述协议格式还存在另一个问题：对于name字段，其长度为8字节，这种定长的字段，长度大小不具有伸缩性：若太长，则在很多情况下都用不完，会造成内存和网络带宽的浪费；若太短，则在某些情况下不够用。那么有没有方法来解决呢？<br>方法是有的：对于字符串类型的字段，我们可以在该字段前面加一个表示字符串长度（length）的标志，那么上面的协议在内存中的状态可以表示成如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/16/pCQlCDS.png" alt="pCQlCDS.png"></p><p>这种方法解决了定义字符串类型时太长浪费、太短不够用的问题，但是没有解决修改协议（如新增字段）需要兼容众多旧版本的问题，对于后面的问题，可以通过在每个字段前面都加一个type类型来解决。我们可以使用一个char类型来表示常用的类型，规定如下表所示。</p><p><img src="https://s1.ax1x.com/2023/06/16/pCQlkNj.png" alt="pCQlkNj.png"></p><p>那么对于以上协议，其内存格式变成如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/16/pCQlVCn.png" alt="pCQlVCn.png"></p><p>这样，每个字段的类型就是自解释了，这就是TLV（Type LengthValue）。对这种格式的协议，我们可以方便地增删改字段类型，程序在解析时会根据每个字段的 type得到字段的类型。在实际开发中，TLV类型虽然易于扩展，但也存在以下缺点。</p><ul><li><p>TLV格式因为每个字段都增加了一个type类型，所以占用的空间增大。</p></li><li><p>我们在解析字段时需要额外增加一些判断 type 的逻辑，去判断字段的类型并做相应的处理，如下面的代码所示，对每个字段都需要有这样的逻辑判断，这样的编码方式是非常麻烦的。</p><p>  &#x2F;&#x2F;读取第1字节得到type<br>  if(type &#x3D; Type: :BOOL)<br>  {<br>  &#x2F;&#x2F;boo1型处理<br>  }<br>  else if (type &#x3D;&#x3D; Type ::CHAR)<br>  {<br>  &#x2F;&#x2F; char型处理<br>  }<br>  else if (type &#x3D; Type : :SHORT)<br>  {<br>  &#x2F;&#x2F;short型处理<br>  }<br>  …省略更多的类型…</p></li><li><p>即使我们知道了每个字段的技术类型（相对于业务来说），每个字段的业务含义也仍然需要我们制定文档格式，也就是说，TLV格式只是做到了在技术上自解释。所以在实际开发中，完全遵循 TLV 格式的协议并不多，尤其是针对一些整型类型的字段来说，例如整型字段一旦知道其类型，长度就固定下来了，比如short类型占2字节，int32类型占4字节，因此不必浪费一段空间存储其长度信息</p></li></ul><p>TLV格式还可以嵌套，有的项目在 TLV 格式的基础上扩展了一种 TTLV 格式的协议，即Tag-Type-Length-Value，在每个字段前面都增加了一个Tag类型，这时Type表示数据类型，Ta g的含义由协议双方协定。</p><h2 id="协议的分类"><a href="#协议的分类" class="headerlink" title="协议的分类"></a>协议的分类</h2><p>根据协议的内容是否是文本格式（即人为可读格式），我们将协议分为文本协议和二进制协议，像HTTP的包头部分和FTP等都是典型的文本协议的例子。</p><h2 id="协议设计工具"><a href="#协议设计工具" class="headerlink" title="协议设计工具"></a>协议设计工具</h2><p>虽然 TLV 很简单，但是每做一套新的协议都要从头编解码、调试，而写编解码存在大量的复制粘贴过程，容易出错。<br>因此出现了一种叫作IDL（Interface Description Language）的语言规范，它是一种描述语言，也是一种中间语言。IDL将协议的使用类型规范化，提供跨语言特性。我们可以定义一个描述协议格式的IDL文件，然后通过IDL工具分析IDL文件，就可以生成各种语言版本的协议代码。Google Protobuf库自带的工具protoc就是一个IDL工具。</p><h2 id="包分片"><a href="#包分片" class="headerlink" title="包分片"></a>包分片</h2><p>包分片指的是应用层对包的拆分。当一个包的数据较大，超过一个包的最长长度时，我们需要对包进行分片。有人可能会有疑问：分成多个包就行了，为什么要对包进行分片？在实际应用中一般会根据业务需求对包的类型进行编号，例如使用一个 wCmd表示业务号，但某些业务类型某次携带的数据可能较大，超过了单个包的最大长度，这时需要将该数据拆分成多个包片，但其业务号隶属于同一个包，这就是包分片。理解包分片的原理后，设计包分片的功能就很简单了，这里提供了两种思路。</p><ul><li>设置分片标志。在包头部分设置一个字段来表示当前包是否属于某个大包的分片，分片标志字段一般有 4 种取值类型：无分片标志、包的第 1 个分片标志、包的最后一个分片标志、第1个分片与最后一个分片之间的包分片标志。</li><li>在每个包分片的包头部分都有该包的总分片数量和当前分片编号。对于 TCP 来说，由于其数据传输本身是有序的，所以对于多个分片，只要我们的一端按顺序依次发送，另外一端收包时就一定会按发送的顺序收到，我们也不用考虑包分片的顺序问题。</li></ul><p>看一个具体的包分片的例子。假设现在有如下协议头定义：</p><pre><code>#pragma pack(push, 1)typedef struct tagNtPkgHead&#123;    unsigned char bStartFlag;     // 协议包起始标志0xFF    unsigned char bVer;           // 版本号    unsigned char bEncryptFlag;   // 加密标志(如果不加密，则为0)    unsigned char bFrag;          // 是否有包分片(1:有包分片, 0:无包分片)    unsigned short wLen;          // 总包长    unsigned short wCmd;          // 命令号    unsigned short wSeg;          // 包的序列号，业务使用    unsigned short wCrc;          // crc16校验码    unsigned int dwSID;           // 会话ID    unsigned short wTotal;        // 有包分片时的分片总数    unsigned short wCurSeq;       // 有包分片时的分片序号，从0开始，无分片时也为0&#125; NtPkgHead, *PNtPkgHead;#pragma pack(pop)</code></pre><p>对端处理包分片时的逻辑伪代码如下：</p><pre><code>UINT CsocketClient::TRecvDataThreadProc(LPV0ID lpParam)&#123;    LOG_NORMAL(&quot;Start recv data thread.&quot;);    DWORD dwWaitResult;    std::string strPkg; // 临时存储一个完整的包数据的变量    std::string strTotalPkg;    unsigned short uPkgLen = 0;    unsigned int uBodyLen = 0;    unsigned int uTotalPkgLen = 0;    unsigned int uCmd = 0;    NtPkgHead pkgHead;    unsigned short uTotal = 0;    unsigned short uCurSeq = 0;    int nWaitTimeout = 1;    CsocketClient* pSocketClient = (CsocketClient*)lpParam;    while (!m_bExit)    &#123;        // 检测是否有数据        if (!pSocketClient-&gt;checkReceivedData())        &#123;            // 休眠10毫秒            Sleep(10);            continue;        &#125;        // 按收到的数据，并放入pSocketClient-&gt;m_strRecvBuf中        if (!pSocketClient-&gt;Recv())        &#123;            LOG_ERROR(&quot;Recv data error&quot;);            // 收数据出错，清空接收缓冲区，可以进行一些关闭连接、重连等动作            pSocketClient-&gt;m_strRecvBuf.clear();            pSocketClient-&gt;Reconnect();            continue;        &#125;        // 一定要放在一个循环里解析，因为在当前缓冲区中可能存在多个数据包        while (true)        &#123;            // 判断当前收到的数据是否够一个包头大小            if (pSocketClient-&gt;m_strRecvBuf.length() &lt; sizeof(NtPkgHead))                break;            memset(&amp;pkgHead, 0, sizeof(pkgHead));            memcpy_s(&amp;pkgHead, sizeof(pkgHead), pSocketClient-&gt;m_strRecvBuf.c_str(), sizeof(pkgHead));            // 对包消息头进行检验            if (!checkPkgHead(&amp;pkgHead))            &#123;                // 如果包头检验不通过，则缓冲区里面的数据已经是脏数据了，直接清空，可以做一些关闭连接、重连的动作                pSocketClient-&gt;Reconnect();                break;            &#125;            // 判断当前数据是否够一个完整包的大小            uPkgLen = ntohs(pkgHead.wLen);            if (pSocketClient-&gt;m_strRecvBuf.length() &lt; uPkgLen)                break;            strPkg.clear();            strPkg.append(pSocketClient-&gt;m_strRecvBuf.c_str(), uPkgLen);            // 从接收缓冲区中移除已经处理的数据部分            pSocketClient-&gt;m_strRecvBuf.erase(0, uPkgLen);            uTotal = ntohs(pkgHead.wTotal);            uCurSeq = ntohs(pkgHead.wCurSeq);            // 无分片或者是第1个分片            if (uTotal == 0 || uCurSeq == 0)            &#123;                strTotalPkg.clear();                uTotalPkgLen = 0;            &#125;            uBodyLen = uPkgLen - sizeof(NtPkgHead);            uTotalPkgLen += uBodyLen;            strTotalPkg.append(strPkg, sizeof(NtPkgHead), uBodyLen);            // 如果无分包或者是包的最后一个分片，则将组装后的包发送出去            if (uTotal == 0 || (uTotal != 0 &amp;&amp; uCurSeq + 1 == uTotal))            &#123;                if (uCmd == ntohs(pkgHead.wCmd))                &#123;                    // ProxyPackage是解析出来的业务包定义                    ProxyPackage proxyPackage;                    // 复制业务号                    proxyPackage.nCmd = uCmd;                    // 复制包长度                    proxyPackage.nLength = uTotalPkgLen;                    // 复制包体内容                    proxyPackage.pszJson = new char[uTotalPkgLen];                    memset(proxyPackage.pszJson, 0, uTotalPkgLen * sizeof(char));                    memcpy_s(proxyPackage.pszJson, uTotalPkgLen, strTotalPkg.c_str(), strTotalPkg.length());                    // 将一个完整的包交给业务处理                    pSocketClient-&gt;m_pNetProxy-&gt;AddPackage((const char*)&amp;proxyPackage, sizeof(proxyPackage));                &#125;            &#125;        &#125;    &#125;    LOG_NORMAL(&quot;Exit recv data thread.&quot;);    return 0;&#125;</code></pre><p>以上代码在一个网络数据收取线程中，先检测是否有可读数据，如果有可读数据，则从 socket 上读取该数据并存入接收缓冲区pSocketClient-&gt;m_strRecvBuf 中，然后判断收到的数据是否够一个包头大小（sizeof（NtPkgHead）），如果不够，则退出当前循环，等待后续数据的到来；如果够，则对包头数据进行校验，然后从包头中得到整包的大小（ntohs（pkgHead.wLen），这里表示整包大小的字段wLen 使用了网络字节序，我们调用ntohs函数可以得到本机字节序）。接着判断收到的数据是否够一个整包的大小，如果不够，则退出当前循环等待后续数据的到来；如果够，则根据记录当前包分片序号的变量uCurSeq（uCurSeq&#x3D;：：ntohs（pkgHead.wCurSeq））确定该包是否是某个分片。uCurSeq等于0，说明此次是从一个新的包片或完<br>整的包开始的；从接收缓冲区中将当前包片或者完整包的数据放入变量 strTotalPkg中存储起来（注意，pkgHead.wTotal 和pkgHead.wCurSeq均使用了网络字节序，需要转换成本地字节序）。接着，根据包头字段 pkgHead.wTotal和pkgHead.wCurSeq 转换成本机字节序的值，判断这是否是一个完整的包（当 uTotal&#x3D;&#x3D;0时）或者是最后一个包分片（当uTotal！&#x3D;0&amp;&amp;uTotal&#x3D;&#x3D;uCurSeq+1时），此时strTotalPkg存放的就是一个完整的包数据了，接着将其拷贝出来（这里是拷贝到ProxyPackage结构中）进行业务逻辑处理。如果当前包片只是一个大包的中间包片，则继续进行下一轮数据的处理。在strTotalPkg中存放的数据在到达一个完整的包时，会在业务处理后、下一轮循环存入新的包片数据前清空。</p><h2 id="XML与JSON格式的协议"><a href="#XML与JSON格式的协议" class="headerlink" title="XML与JSON格式的协议"></a>XML与JSON格式的协议</h2><p>XML 和 JSON 这两种格式由于其良好的自我解释性，是开发中使用非常广泛的两种数据格式。<br>一个XML格式的示例如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;&lt;book category=&quot;fiction&quot;&gt;    &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;    &lt;author&gt;J.K. Rowling&lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book category=&quot;fiction&quot;&gt;    &lt;title lang=&quot;en&quot;&gt;The Hobbit&lt;/title&gt;    &lt;author&gt;J.R.R. Tolkien&lt;/author&gt;    &lt;year&gt;2010&lt;/year&gt;    &lt;price&gt;19.99&lt;/price&gt;&lt;/book&gt;&lt;book category=&quot;non-fiction&quot;&gt;    &lt;title lang=&quot;en&quot;&gt;Sapiens: A Brief History of Humankind&lt;/title&gt;    &lt;author&gt;Yuval Noah Harari&lt;/author&gt;    &lt;year&gt;2014&lt;/year&gt;    &lt;price&gt;24.99&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt;</code></pre><p>一个JSON格式的示例如下：</p><pre><code>&#123;&quot;bookstore&quot;: &#123;    &quot;books&quot;: [    &#123;        &quot;category&quot;: &quot;fiction&quot;,        &quot;title&quot;: &quot;Harry Potter&quot;,        &quot;author&quot;: &quot;J.K. Rowling&quot;,        &quot;year&quot;: 2005,        &quot;price&quot;: 29.99    &#125;,    &#123;        &quot;category&quot;: &quot;fiction&quot;,        &quot;title&quot;: &quot;The Hobbit&quot;,        &quot;author&quot;: &quot;J.R.R. Tolkien&quot;,        &quot;year&quot;: 2010,        &quot;price&quot;: 19.99    &#125;,    &#123;        &quot;category&quot;: &quot;non-fiction&quot;,        &quot;title&quot;: &quot;Sapiens: A Brief History of Humankind&quot;,        &quot;author&quot;: &quot;Yuval Noah Harari&quot;,        &quot;year&quot;: 2014,        &quot;price&quot;: 24.99    &#125;    ]&#125;&#125;</code></pre><p>那么 XML和 JSON格式可以单独作为网络通信协议吗？当然可以，但是单独使用XML 或者 JSON 格式作为网络通信协议的服务非常少，其原因是在给数据包分界得到一个个完整的包时非常不便。无论是XML格式还是JSON格式，如果单独作为协议，则一般由于业务数据内容的不同，每个包的长度都不一样，在TCP流式数据中只能采取固定结束符的方式来分割。对于不确定长度的XML和JSON字符串，在频繁进行数据交换的网络通信程序中，每次解包前都得遍历一次XML或<br>JSON字符串以寻找特定的包结束符。例如，对于上面XML格式的示例，就是在流式数据中寻找字符串以作为一个 xml 格式的包结束符；对于上面的json格式，寻找右大括号<code>&#125;</code>作为JSON格式的包结束符，这种寻找特定标记的方式容易造成误判，还需要在此基础上加上其他限定标记。例如，对JSON字符串的最后一个节点可以加一个特殊字段标志作为结束标记。以上述JSON字符串为例，在其末尾增加一个endFlag标志后变成如下形式：</p><pre><code>&#123;&quot;userid&quot;: 1001,&quot;username&quot;: &quot;xiaofang&quot;,&quot;nickname&quot;: &quot;小方&quot;,&quot;facetype&quot;: 0,&quot;gender&quot;: 1,&quot;birthday&quot;: 19900101,&quot;signature&quot;: &quot;生活需要很多的力气呀。xx&quot;,&quot;clienttype&quot;: 1,&quot;endFlag&quot;: 0&#125;</code></pre><p>这样当该 JSON 字符串作为一个数据包时，在判断包结束标志时可以通过寻找”endFlag”：0加一个“}”这样的字符串作为包分界符号。但这种方法很不灵活，JSON字符串在某些系统或库中被解析时，各个字段的位置顺序可能会被调整，也就是说，像”endFlag”：0这样的字段可能会被调整到 JSON字符串的非末尾位置；另外，在 JSON字符串被格式化后，某些字段值后面会被追加\n或\r\n这样的换行符，给程序寻找指定的包结束符带来困扰。所以在通常情况下，XML 或者 JSON 格式不会被单独作为协议格式，而是作为某个协议的一部分出现，例如如下格式：</p><pre><code>struct mSg &#123;// 消息头 header 中说明整个包的大小，减去 header、cmd 和 seq 的大小就是 buf 的长度msgheader header;int32_t cmd;int32_t seq;// buf 是一个字符串，可以是 XML 或者 JSON 格式char* buf;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络边缘</title>
      <link href="/p/2f9ed4ad.html"/>
      <url>/p/2f9ed4ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ul><li>网路边缘<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心<ul><li>互联着的路由器</li><li>网络的网络</li></ul></li><li>网络接入<ul><li>有线或者无线通信链路</li></ul></li></ul><p>从应用往下看都是网络基础设施</p><h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul><li>端系统（主机）<ul><li>运行应用程序</li><li>如Web，email</li><li>在“网络的边缘”</li></ul></li><li>客户&#x2F;服务器模式 C&#x2F;S<ul><li>客户端向服务器请求接受服务</li><li>如Web浏览器&#x2F;服务器；email客户端&#x2F;服务器</li></ul></li><li>对等模式 P2P<ul><li>很少专门的服务器</li><li>如Emule，KozaA</li></ul></li></ul><h3 id="采用网络设施的面向连接的服务"><a href="#采用网络设施的面向连接的服务" class="headerlink" title="采用网络设施的面向连接的服务"></a>采用网络设施的面向连接的服务</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>在端系统之间传输数据<br><strong>握手</strong>：在数据传输之前做好准备</p><ul><li>人类协议中：你好，你好</li><li>两个通信主机之间为连接建立状态<br>面向连接的通信方式：通信方式只有端节点知道</li></ul><p><strong>TCP-传输控制协议</strong></p><ul><li>Internet上面向连接的服务</li></ul><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠的，按顺序的传送数据<ul><li>确认和重传</li></ul></li><li>流量控制<ul><li>发送方不会淹没接收方</li></ul></li><li>拥塞控制<ul><li>当网络拥塞时，发送方降低发送速率</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通信的三种方式</title>
      <link href="/p/d0681926.html"/>
      <url>/p/d0681926.html</url>
      
        <content type="html"><![CDATA[<h4 id="通信的三种方式"><a href="#通信的三种方式" class="headerlink" title="通信的三种方式"></a>通信的三种方式</h4><ul><li><p>客户&#x2F;服务器模型</p></li><li><p>P2P模型</p></li><li><p>混合模型</p></li></ul><h4 id="网络接入"><a href="#网络接入" class="headerlink" title="网络接入"></a>网络接入</h4><ul><li><p>点对点方式接入</p><ul><li>电话线</li><li>电缆&#x2F;光纤混合电路</li><li>光纤到户</li><li>卫星</li></ul></li><li><p>以以太网&#x2F;WIFI的方式</p><ul><li>以太网(有线)</li><li>WiFi(无线)</li></ul></li><li><p>广域无线接入</p></li></ul><h4 id="介质"><a href="#介质" class="headerlink" title="介质"></a>介质</h4><ul><li>导引型介质<ul><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li><li>非导引型介质<ul><li>大气层</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="数据传输的方式"><a href="#数据传输的方式" class="headerlink" title="数据传输的方式"></a>数据传输的方式</h4><ul><li>电路交换网络<ul><li>建立连接</li><li>交换数据</li><li>释放连接</li></ul></li><li>分组交换网络<ul><li>长数据切分成小段</li><li>生成分组，每个数据段加上首部</li><li>发送数据</li><li>接受数据</li><li>恢复原来报文</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快手</title>
      <link href="/p/c2f2ffeb.html"/>
      <url>/p/c2f2ffeb.html</url>
      
        <content type="html"><![CDATA[<h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>leetcode 542 895</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/p/c517589e.html"/>
      <url>/p/c517589e.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><pre><code class="bash">$ 并查集是一种树型的数据结构。</code></pre><h2 id="并查集的用途"><a href="#并查集的用途" class="headerlink" title="并查集的用途"></a>并查集的用途</h2><ol><li>处理不相交的集合的合并、查询问题。</li><li>检查一个图上面是否有一个环。<br>简单说就是先把每一个顶点放在一个独立的集合（树）里，如果顶点之间是邻接的那么就把他们合并为一个<br>集合（树）。一个集合（树）里有一个根结点，如果有两个顶点他们的根结点相同说明他们处于同一个集合<br>（树），那这两个结点邻接必定形成一个环（为什么？ 因n个顶点和n-1条边形成的连通图如果再加一条边<br>一定出现环）。如果他们的根结点不同，就把这两个集合合成一个集合。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>for(int i=1;i&lt;=n;i++)&#123;    father[i]=i;&#125;</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>非递归写法</strong></p><pre><code>int findFather(int x)&#123;    while(x!=father[x])&#123;        x=father[x];    &#125;    return x;&#125;</code></pre><p><strong>递归写法</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    return findfather(father[x]);&#125;</code></pre><p><strong>合并</strong></p><pre><code>void Union(int a,int b)&#123;    int faA =findFather(a);    int faB=findFather(b);    if(faA==faB)return ;    else&#123;        father[faA]=faB;    &#125;&#125;</code></pre><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>非递归写法：</strong></p><pre><code>int findFather(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        father[a]=x;        a=father[z];    &#125;    return x;&#125;</code></pre><p><strong>递归写法：</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    else&#123;        int F=findFather(father[x]);        father[x]=F;        return F;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/p/15bc60d.html"/>
      <url>/p/15bc60d.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><p>每次选取集合中距离最小的点进行拓展，贪心算法；<br>采用邻接矩阵：</p><pre><code>#include &lt;iostream&gt;#include&lt;fstream&gt;const int INF 0x7fffffff;const int N = 10010;using namespace std;int map[N][N], dis[N], mark[N]int main()&#123;    int i, j, n, m, t1, t2, t3, cur, v, min;    cin &gt;&gt; n &gt;&gt; m;    for (i = 1; i &lt;= n; i++) &#123;        for (j = 1; j &lt;= n; j++) &#123;            if (i == j) map[i][j] = 0;            else map[i][j] = INF;        &#125;    &#125;    for (i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;        map[t1][t2] = t3;    &#125;    //初始化dis数组,代表源点到其他顶点的初始路程    for (i = 1; i &lt;= n; i++) &#123;        dis[i] = map[1][i];        mark[i] = 0;    &#125;    //从源点开始    mark[1] = 1;    //Dijkstra算法核心代码--贪心策略    for (i = 1; i &lt;= n - 1; i++) &#123; // 总共需要更新n-1次，对除去源点以外的n-1个点进行松弛        //寻找距离源点最近的顶点        min = INF;        for (j = 1; j &lt;= n; j++) &#123;            if (mark[j] == 0 &amp;&amp; dis[j] &lt; min) &#123;                min = dis[j];                cur = j;            &#125;        &#125;        //cur代表距离源点最近的        mark[cur] = 1;        for (v = 1; v &lt;= n; v++) &#123;            if (map[cur][v] &lt; INF) &#123;                if (dis[v] &gt; dis[cur] + map[cur][v]) &#123;                    dis[v] = dis[cur] + map[cur][v];                &#125;            &#125;        &#125;    &#125;    for (i = 1; i &lt;= n; i++) &#123;        cout &lt;&lt; dis[i];    &#125;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><p>采用邻接表(链式向前星)：</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;const int INF=2147483647;long long dis[10001];bool mark[100001];//STL优先队列（使用pair的情况下）的定义方法。由于要采用小根堆，所以需要这样定义。priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q;int fir[500001],to[500001],val[500001],nex[500001];    int cnt;void add_edge(int a,int b,int c)//链式前向星存图&#123;    to[++cnt]=b;    val[cnt]=c;    nex[cnt]=fir[a];    fir[a]=cnt;&#125;int main()&#123;    int n,m,s;    int u,v,w;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    for(int i=1; i&lt;=m; i++)    &#123;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        add_edge(u,v,w);     &#125;    for(int i=1; i&lt;=n; i++)        dis[i]=inf;    dis[s]=0;//初始化dis数组     q.push(make_pair(0,s));//这里采用C++自带二元组编写    while(q.size())//当堆中还有元素     &#123;        int x=q.top().second;//q.top()取出堆顶，也就是当前距离起点最近的点。         q.pop();//取完就删         if(mark[x]) continue;//如果这个定点标记过了，就不用。        mark[x]=1;//标记一下         for(int i=fir[x]; i; i=nex[i])        &#123;            if(dis[to[i]]&gt;dis[x]+val[i])//dijkstra算法核心语句             &#123;                dis[to[i]]=dis[x]+val[i];                q.push(make_pair(dis[to[i]],to[i]));//每次松弛成功，把关于当前点的信息压入堆。             &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)        cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;     return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>libevent可执行文件生成</title>
      <link href="/p/789273fd.html"/>
      <url>/p/789273fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="libevent可执行文件生成"><a href="#libevent可执行文件生成" class="headerlink" title="libevent可执行文件生成"></a>libevent可执行文件生成</h1><p>本来之前编译的32位已经足够用了，奈何后面程序需要用到protobuf，protobuf是64位编译的，联合使用几十行代码就能报了几百条错误，吓人！搞了好久终于把依赖的库文件重新编译完了。</p><h2 id="编译环境："><a href="#编译环境：" class="headerlink" title="编译环境："></a>编译环境：</h2><ul><li>win10 64位</li><li>vs2019 profession</li><li>libevent 2.1.11</li><li>libevent解压的文件夹目录为：D:\test\libevent-2.1.11-stable.tar\libevent-2.1.11-stable</li></ul><p>cmake之类的之前安装的，具体需要哪些也已经遗忘了，如果提示下载按需下载即可。（抱歉，我是菜狗）<br>其中libevent源代码在<a href="https://libevent.org/%E4%B8%8B%E8%BD%BD">https://libevent.org/下载</a><br><a href="https://imgse.com/i/p9TIbOP"><img src="https://s1.ax1x.com/2023/05/23/p9TIbOP.png" alt="libevent源代码"></a></p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>修改 libevent 目录下的 Makefile.nmake 文件：<br>找到 CFLAGS&#x3D;$(CFLAGS) &#x2F;Ox &#x2F;W3 &#x2F;wd4996 &#x2F;nologo，在后面加上 &#x2F;Zi<br>即改成 CFLAGS&#x3D;$(CFLAGS) &#x2F;Ox &#x2F;W3 &#x2F;wd4996 &#x2F;nologo &#x2F;Zi<br><a href="https://imgse.com/i/p9TIvFg"><img src="https://s1.ax1x.com/2023/05/23/p9TIvFg.png" alt="p9TIvFg.png"></a></p><p>因为我们要编译64位的lib库文件，所以还修改 libevent 目录下的 Makefile.nmake 文件<br>将 LIBFLAGS&#x3D;&#x2F;nologo<br>修改为：LIBFLAGS&#x3D;&#x2F;nologo &#x2F;MACHINE:X64<br><a href="https://imgse.com/i/p9ToFmV"><img src="https://s1.ax1x.com/2023/05/23/p9ToFmV.png" alt="p9ToFmV.png"></a></p><p>打开 libevent 目录下的 mm-internal.h 添加 #include &lt;stdint.h&gt;<br>注意：一定要添加到#ifndef MM_INTERNAL_H_INCLUDED_之前，否则会报错，一堆warning<br><a href="https://imgse.com/i/p9To4BV"><img src="https://s1.ax1x.com/2023/05/23/p9To4BV.png" alt="p9To4BV.png"></a></p><p>找到vs下的命令提示符 x64 Native Tools Command Prompt for VS 2019<br><a href="https://imgse.com/i/p9Tojnx"><img src="https://s1.ax1x.com/2023/05/23/p9Tojnx.png" alt="p9Tojnx.png"></a></p><p>使用控制台命令进入到 libevent 目录下：略<br>执行命令 nmake &#x2F;f Makefile.nmake，（成功的时候只有几行输出，如果有很多行输出，比如变量转换可能导致数据丢失，就说明编译失败了，就算生成了三个 lib 文件，也是失败的）<br><a href="https://imgse.com/i/pCp48wF"><img src="https://s1.ax1x.com/2023/06/03/pCp48wF.png" alt="成功输出"></a><br>成功后，在 libevent 目录下会生成三个文件</p><ul><li>libevent.lib</li><li>libevent_core.lib</li><li>libevent_extras.lib</li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解HTTP</title>
      <link href="/p/ea0da367.html"/>
      <url>/p/ea0da367.html</url>
      
        <content type="html"><![CDATA[<h1 id="理解HTTP"><a href="#理解HTTP" class="headerlink" title="理解HTTP"></a>理解HTTP</h1><p>HTTP（Hypertext Transfer Protocol，超级文本传输协议）是用途最广泛的网络协议之一，但不少开发者只停留在会用工具或库发送HTTP请求阶段。笔者面试过不少求职者，问及 HTTP 的具体格式时，很多求职者都不能回答清楚，有人甚至将HTML文档页面的头部<head>标签当作HTTP数据包的包头。另外，大多数开发者都知道HTTP GET和POST方法，也可以利用一些现成的库或框架发送GET或POST请求，但是对GET或POST方法的数据在协议包中的存放位置一无所知，更不用说服务器如何识别并解析这些数据了。<br>需要用到 HTTP 服务器时，很多人只能依靠 Apache、Nginx 这样现成的 HTTP Web Server，对如何实现一个HTTP服务器无从下手。如果在实际应用场景中，服务端需要支持一些简单HTTP请求，例如某个服务需要提供一个HTTP格式的健康检查接口，则使用Apache、Nginx等HTTP服务器程序实在太“重”，不如自己实现一个简单的HTTP服务。</head></p><h2 id="HTTP格式介绍"><a href="#HTTP格式介绍" class="headerlink" title="HTTP格式介绍"></a>HTTP格式介绍</h2><p>HTTP是建立在TCP之上的应用层协议，其格式如下：</p><pre><code>GET 或 PoST 请求的URL路径(一般是去掉域名的路径）HTTP协议版本号\r\n字段1名:字段1值\r\n字段2名:字段2值\r\n...字段n名:字段n值\r\n\r\nHTTP包体内容</code></pre><p>如上所示，HTTP 由包头（第 1～6 行）和包体（第 7 行以后）两部分组成，包头与包体之间使用一个\r\n 分割，包头的每一行均以\r\n结束，在包头结束时再添加一个\r\n （空行）表示包头结束。也就是说，HTTP在大多数情况下都是文本形式的明文格式，这也是Hypertext Transfer Protocol中text（文本）的名称含义。由于HTTP包头的每一行都以\r\n结束，所以HTTP包头以\r\n\r\n结束，我们在用程序解析HTTP格式的数据时可以通过\r\n\r\n界定包<br>头的结束位置和包体的起始位置。也就是说，HTTP 也分为 head（包头）和 body（包体）两部分.</p><h2 id="GET与POST方法"><a href="#GET与POST方法" class="headerlink" title="GET与POST方法"></a>GET与POST方法</h2><p>HTTP 请求的方法有 GET、POST、HEAD、PUT、DELETE 等，其中GET 和 POST是我们用得最多的方法。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>下面以一个具体的例子说明使用GET方法时的HTTP包格式。<br>假设我们在浏览器中请求访问“http：&#x2F;&#x2F;<a href="http://www.test.org/test.php%E2%80%9D%EF%BC%8C%E5%88%99%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84GET%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BA%E6%88%91%E4%BB%AC%E7%BB%84%E8%A3%85%E7%9A%84HTTP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">www.test.org/test.php”，则这是一个典型的GET方法，浏览器为我们组装的HTTP数据包格式如下：</a></p><pre><code>GET /test.php HTTP/1.1Host: www.test.orgizConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Window: MT 6.1; Win64; x64) AppleWebKit/537,36 (KHTML,1ikeGecko) Chrome/65.0.3325.146 Safari/537.36Accept: text/html,application/xhtm1+xml, application/xml; g=0.9, image/webp , image/apng,/;q=0.8Accept-Encoding: gzip,deflateAccept-Language: zh-CN, zh;q=0.9,en;q=0.8</code></pre><p>上面这个请求只有包头，没有包体，HTTP的包体部分不是必需的，也就是说，GET请求一般没有包体部分。如果GET请求带参数，那么参数一般被附加在请求的URL后面，参数与参数之间使用&amp;分割，例如请求</p><pre><code>http：//www.test.org/test.php？param1=value1&amp;param2=value2&amp;param3=value3 </code></pre><p>有三个参数 param1、param2 和 param3，其对应的参数值分别是 value1、value2、value3。<br>这个请求组装的HTTP报文格式如下：</p><pre><code>GET /test.php?param1=valuelsparam2=value2&amp;param3mvalue3 HTTP/1.1Host: www.test.orgConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleMebKit/537.36 (KHTML, likeGeckol Chrome/65.0.3325.146 Safari/537.36NAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip,deflateAccept-Language: zh-CN, zh;q=0.9,en;q=0.8</code></pre><p>由于浏览器对 URL的长度最大值有限制，因此放在 URL后面的GET参数数量和长度也是有限制的，不同浏览器的最大长度限制值不一样。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST 的四种方式<br>POST 方法中对发送数据编码的方式，也就是 Content-Type 有四种方式，其中默认是 application&#x2F;x-www-form-urlencoded，最方便的是 application&#x2F;json 。</p><p>四种方式包括：</p><ul><li>application&#x2F;x-www-form-urlencoded （URL encoded）</li><li>multipart&#x2F;form-data （键值对型数据）</li><li>application&#x2F;json (Json 类型数据)</li><li>text&#x2F;xml （xml）</li></ul><h4 id="application-x2F-x-www-form-urlencoded"><a href="#application-x2F-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h4><p>POST 中很常见的一种编码数据的方式，如果不设置 Content-type 的值，默认就是 urlencoded 。</p><pre><code>POST http://www.example.com HTTP/1.1    Content-Type:application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</code></pre><p>实际例子：</p><pre><code># python脚本import requestsurl = &quot;http://httpbin.org/post&quot;data = &#123;&quot;name&quot;:&quot;西园公子&quot;,&quot;age&quot;:&quot;666&quot;&#125;headers = &#123;&quot;Content-type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125;content = requests.post(url=url,data=data,).textprint(content)# 网络请求：POST http://httpbin.org/post HTTP/1.1Host    httpbin.orgUser-Agent  python-requests/2.24.0Accept-Encoding gzip, deflateAccept  */*Content-Length  49Content-Type    application/x-www-form-urlencodedConnection  keep-alive# 下面是表单内容name=%E8%A5%BF%E5%9B%AD%E5%85%AC%E5%AD%90&amp;age=666      # 可以看出汉字是使用utf8编码的# 打印&#123;    &quot;args&quot;: &#123;&#125;,     &quot;data&quot;: &quot;&quot;,     &quot;files&quot;: &#123;&#125;,     &quot;form&quot;: &#123;           # form表单内容        &quot;age&quot;: &quot;666&quot;,         &quot;name&quot;: &quot;\u897f\u56ed\u516c\u5b50&quot;        &#125;,     &quot;headers&quot;: &#123;        &quot;Accept&quot;: &quot;*/*&quot;,         &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,         &quot;Content-Length&quot;: &quot;49&quot;,         &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,   # Content-Type        &quot;Host&quot;: &quot;httpbin.org&quot;,         &quot;User-Agent&quot;: &quot;python-requests/2.24.0&quot;,     # 这里面如果爬虫不设置user-agent的话，本ban的几率很大        &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60010906-7a51fef342a967cd24c32235&quot;    &#125;,     &quot;json&quot;: null,     &quot;origin&quot;: &quot;171.90.37.102&quot;,     &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125;</code></pre><p>这里说明一下，requests 是根据传入的键来判断采用那种方法，比如上面的是data&#x3D; 就说明采用 urlencode 的方法编码数据，其他的方法到最后面一并介绍。</p><p>另外这个 <a href="http://httpbin.org/post">http://httpbin.org/post</a> 链接的作用，就是将你向它发送的数据以及header，原样返回，很是方便。</p><h4 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h4><p>这种编码方式，通常是用在客户端向服务端传送大文件数据，如：图片或者文件。<br>首先来解释下什么它的编码方式，首先会生成一个很长的 boundary 字符串分界线，表明下面的都是表单内容，然后紧接着跟的是表单中的第一个键值对中的名称，而后一个换行，跟着值。然后再生成一个boundary 字符串分界线，用于分割不同的键值。之后就重复以上操作，详细的流程请看下方的例子。</p><pre><code># python脚本import requestsfrom requests_toolbelt import MultipartEncoderm = MultipartEncoder(    fields=&#123;&#39;field0&#39;: &#39;value1&#39;, &#39;field1&#39;: &#39;value2&#39;, &#39;field2&#39;: (&#39;filename&#39;, open(&#39;data.txt&#39;, &#39;rb&#39;), &#39;text/plain&#39;)&#125;    )content = requests.post(&#39;http://httpbin.org/post&#39;, data=m,                headers=&#123;&#39;Content-Type&#39;: m.content_type&#125;).textprint(content)print(m.content_type)# 1、网络请求：POST http://httpbin.org/post HTTP/1.1Host: httpbin.orgUser-Agent: python-requests/2.24.0Accept-Encoding: gzip, deflateAccept: */*Content-Type: multipart/form-data; boundary=e48c73a7a42e403d868095dc3d060962Content-Length: 222Connection: keep-alive# 下面是编码的表单内容--e48c73a7a42e403d868095dc3d060962Content-Disposition: form-data; name=&quot;field0&quot;value1--e48c73a7a42e403d868095dc3d060962Content-Disposition: form-data; name=&quot;field1&quot;value2--e48c73a7a42e403d868095dc3d060962--Content-Disposition: form-data; name=&quot;field2&quot;; filename=&quot;filename&quot;Content-Type: text/plainä½ å¥½ï¼è¥¿å­å¬å­ï½--25c88ddc918d40e7a3cd5be0d62476b7--# 2、打印&#123;&quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;           # 发送类型是文件的    &quot;field2&quot;: &quot;\u4f60\u597d\uff0c\u897f\u56ed\u516c\u5b50\uff5e&quot;&#125;, &quot;form&quot;: &#123;                  # 发送类型是非文件的，有些类似 urlencode 的消息主体    &quot;field0&quot;: &quot;value1&quot;,     &quot;field1&quot;: &quot;value2&quot;&#125;, &quot;headers&quot;: &#123;    &quot;Accept&quot;: &quot;*/*&quot;,     &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,     &quot;Content-Length&quot;: &quot;222&quot;,     &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=3123ca302f2c4f0dba1050faa8817ab8&quot;,     &quot;Host&quot;: &quot;httpbin.org&quot;,     &quot;User-Agent&quot;: &quot;python-requests/2.24.0&quot;,     &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60017280-15e1a08d69c4611737583c87&quot;&#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;191.80.857.122&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125;multipart/form-data; boundary=3123ca302f2c4f0dba1050faa8817ab8</code></pre><h4 id="application-x2F-json"><a href="#application-x2F-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h4><p>这个是今天的主角，用的超级多，也非常的方便。设置 header 中Content-type，就告诉服务端数据以 Json 字符串的形式存在，相应的就用 Json 的方法解码数据即可。</p><p>Python 脚本例子：</p><pre><code>import requestsimport jsonurl=&quot;http://httpbin.org/post&quot;p_data = &#123;&quot;name&quot;: &quot;公子哥&quot;, &quot;hobby&quot;: &quot;coding&quot;&#125;content = requests.post(url, json=json.dumps(p_data),                headers=&#123;&#39;Content-Type&#39;: &quot;application/json&quot;&#125;).textprint(content)# 1、原生网络请求POST /post HTTP/1.1Host: httpbin.orgUser-Agent: python-requests/2.24.0Accept-Encoding: gzip, deflateAccept: */*Content-Type: application/jsonContent-Length: 62Connection: keep-alive# 下面是编码成json数据 的表单内容&quot;&#123;\&quot;name\&quot;: \&quot;\\u516c\\u5b50\\u54e5\&quot;, \&quot;hobby\&quot;: \&quot;coding\&quot;&#125;&quot;# 2、打印数据&#123;    &quot;args&quot;: &#123;&#125;,     &quot;data&quot;: &quot;\&quot;&#123;\\\&quot;name\\\&quot;: \\\&quot;\\\\u516c\\\\u5b50\\\\u54e5\\\&quot;, \\\&quot;hobby\\\&quot;: \\\&quot;coding\\\&quot;&#125;\&quot;&quot;,     &quot;files&quot;: &#123;&#125;,     &quot;form&quot;: &#123;&#125;,     &quot;headers&quot;: &#123;        &quot;Accept&quot;: &quot;*/*&quot;,         &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,         &quot;Content-Length&quot;: &quot;62&quot;,         &quot;Content-Type&quot;: &quot;application/json&quot;,     # 这里指定消息主体编码方式        &quot;Host&quot;: &quot;httpbin.org&quot;,         &quot;User-Agent&quot;: &quot;python-requests/2.24.0&quot;,         &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-6001804b-1c8da9b72910a9e1021e02b3&quot;    &#125;,     &quot;json&quot;: &quot;&#123;\&quot;name\&quot;: \&quot;\\u516c\\u5b50\\u54e5\&quot;, \&quot;hobby\&quot;: \&quot;coding\&quot;&#125;&quot;,     # 消息主体内容    &quot;origin&quot;: &quot;171.10.87.122&quot;,     &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125;</code></pre><h4 id="text-x2F-xml"><a href="#text-x2F-xml" class="headerlink" title="text&#x2F;xml"></a>text&#x2F;xml</h4><pre><code>import requests# from requests_toolbelt import MultipartEncoderp_data = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt;    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;    &lt;params&gt;        &lt;param&gt;            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;        &lt;/param&gt;    &lt;/params&gt;&lt;/methodCall&gt;&quot;&quot;&quot;content = requests.post(url=&#39;http://httpbin.org/post&#39;,data=p_data,headers=&#123;&#39;Content-Type&#39;:&#39;text/xml&#39;&#125;).textprint(content)# 2、打印数据&#123;&quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;\n&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;methodCall&gt;\n    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;\n    &lt;params&gt;\n        &lt;param&gt;\n            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;\n        &lt;/param&gt;\n    &lt;/params&gt;\n&lt;/methodCall&gt;\n&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123;&#125;, &quot;headers&quot;: &#123;    &quot;Accept&quot;: &quot;*/*&quot;,     &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,     &quot;Content-Length&quot;: &quot;200&quot;,     &quot;Content-Type&quot;: &quot;text/xml&quot;,     &quot;Host&quot;: &quot;httpbin.org&quot;,     &quot;User-Agent&quot;: &quot;python-requests/2.24.0&quot;,     &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60024d51-775180ce108409b413dc68c6&quot;&#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;106.33.40.219&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;&#125;</code></pre><h4 id="Reuqests-表示这四种方式"><a href="#Reuqests-表示这四种方式" class="headerlink" title="Reuqests 表示这四种方式"></a>Reuqests 表示这四种方式</h4><p>这里集中将这四种方式说明，否则容易搞混淆。</p><pre><code>p_data = &#123;&quot;name&quot;: &quot;西园公子&quot;,&#125;</code></pre><ul><li><p>application&#x2F;x-www-form-urlencoded:</p><p>  这里面是给data&#x3D;传入参数，参数格式是 Python dict字典</p><p>  requests.post(url&#x3D;”<a href="http://httpbin.org/post%22,data=p_data">http://httpbin.org/post&quot;,data=p_data</a>, headers&#x3D;{“Content-type”: “application&#x2F;x-wwww-form-urlencoded”}).json()</p></li><li><p>multipart&#x2F;form-data：</p><p>  和上面的一样也是给data&#x3D;传参，不同的是数据的编码方式不同。</p><p>  from requests_toolbelt import MultipartEncoder</p><p>  m &#x3D; MultipartEncoder(<br>  fields&#x3D;{‘field0’: ‘value1’, ‘field1’: ‘value2’, ‘field2’: (‘filename’, open(‘data.txt’, ‘rb’), ‘text&#x2F;plain’)}<br>  )<br>  requests.post(url&#x3D;”<a href="http://httpbin.org/post%22,data=m">http://httpbin.org/post&quot;,data=m</a>, headers&#x3D;{“Content-type”: “multipart&#x2F;form-data”}).json()</p></li><li><p>application&#x2F;json：</p><p>  这里面是给json&#x3D;传入参数，参数的格式 Json 字符串，所以需要使用 json.dumps()， 将 Python dict 转 Json 字符串（其实就是 Python 的 str 类型，但是接收方会对字符串进行 Json 解码）</p><p>  import json<br>  p_data &#x3D; json.dumps(p_data)<br>  requests.post(url&#x3D;”<a href="http://httpbin.org/post%22,json=p_data">http://httpbin.org/post&quot;,json=p_data</a>, headers&#x3D;{“Content-type”: “application&#x2F;json”}).json()</p></li><li><p>text&#x2F;xml：</p><p>  和前面几个的一样也是给data&#x3D;传参，参数类型是字符串，但是必须按照 xml 的语法写。</p><p>  p_data &#x3D; ‘<?xml version="1.0" encoding="utf-8"?>&lt;soap:Envelope xmlns:xsi&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>“ xmlns:xsd&#x3D;”<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>“ xmlns:soap&#x3D;”<a href="http://schemas.xmlsoap.org/soap/envelope/%22%3E">http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</a><a href="soap:Body">soap:Body</a><Request xmlns="http://tempuri.org/"><jme><JobClassFullName>WeChatJSTicket.JobWS.Job.JobRefreshTicket,WeChatJSTicket.JobWS</JobClassFullName><Action>RUN</Action><Param>1</Param><HostIP>127.0.0.1</HostIP><JobInfo>1</JobInfo><NeedParallel>false</NeedParallel></jme></Request>‘</p><p>  requests.post(url&#x3D;”<a href="http://httpbin.org/post%22,data=p_data">http://httpbin.org/post&quot;,data=p_data</a>, headers&#x3D;{“Content-type”: “text&#x2F;xml”}).json()<br>  可别忘记在 headers 中的 Conent-type，写入相应的编码方式，否则服务端可不知道怎么解码数据了。</p></li></ul><p>post测试可以利用postman进行模拟发送，非常的方便。</p><h2 id="HTTP-chunk编码"><a href="#HTTP-chunk编码" class="headerlink" title="HTTP chunk编码"></a>HTTP chunk编码</h2><p>HTTP在传输过程中如果包体过大，比如使用HTTP上传一个大文件，或者传输动态产生的内容给对端时，传输方无法预先知道传输的内容有多大，这时就可以使用 HTTP chunk编码技术了。<br>HTTP chunk编码的技术原理是将整个HTTP包体分成多个小块，每一块都有自己的字段来说明自身的长度，对端收到这些块后，去除说明的部分，将多个小块合并在一起得到完整的包体内容。传输方在HTTP包头中设置了Transfer-Encoding：chunked来告诉对端这个数据是分块传输的（代替Content-Length字段）。分块传输的编码格式如下：</p><pre><code>[chunkSize1]\r\n[chunkData1]\r\n[chunkSize2]\r\n[chunkData2]\r\n[chunkSize3=0]\r\n\r\n</code></pre><p>在这个编码格式中使用了若干个 chunk，每个 chunk 都为[chunkSize][\r\n] [chunkData][\r\n]，最后以一个chunkSize为0且没有chunkData的chunk结束。每个chunk都由两部分组成，第1部分是该chunk的长度（chunkSize），第2部分是指定长度的内容，每部分都用\r\n 隔开。需要注意的是，最后一个长度为 0 的 chunk 只有chunkSize，没有chunkData，因此其格式变成了[chunkSize&#x3D;0][\r\n][\r\n]。<br>chunkSize 以十六进制的 ASCII 码表示每字节，例如某个chunkSize 部分一共有两字节，第 1 字节的值是 35（十六进制），第 2 字节的值是 36（十六进制），十六进制的 35和十六进制的36在ASCII码表中分别表示阿拉伯数字5和6，因此被HTTP解释为十六进制的56，十六进制的56对应十进制的86，后面紧跟\r\n（0d 0a），再接着是连续的86字节的chunkData。chunk数据以0长度的chunk块结束，也就是30 0d 0a 0d 0a，十六进制的30对应阿拉伯数字0。这个chunk的结构如下图所示。</p><p><img src="https://s1.ax1x.com/2023/06/17/pCQ7Od1.png" alt="pCQ7Od1.png"></p><p>在介绍了 HTTP chunk编码格式后，对端对 chunk格式的解压缩也很容易了。首先，对端要在收到的HTTP头部找到Transfer-Encoding字段，并且其值是chunked，说明这个HTTP数据包是使用chunk技术编码的，接下来按格式对分块进行解析就可以了。</p><ul><li>找到HTTP包体开始的地方（HTTP头部\r\n\r\n的下一个位置）和接下来一个\r\n中间的部分，这是第1个chunkSize的内容。</li><li>假设第1个chunkSize的长度是n字节，则对照ASCII码表将这n字节依次转换成数字，然后将这些数字拼凑起来当成十六进制数值，再转换成十进制，这就是接下来chunkData的长度。</li><li>跳过\r\n，获取下一个数据块的chunkSize和chunkData，直到遇到一个chunkSize为0的数据块。</li><li>将各个数据块的chunkData按顺序拼接，以得到这个HTTP数据包的完整包体。</li></ul><h2 id="HTTP客户端的编码实现"><a href="#HTTP客户端的编码实现" class="headerlink" title="HTTP客户端的编码实现"></a>HTTP客户端的编码实现</h2><p>如果能理解前面讲解的 HTTP格式，就可以自己通过代码组装HTTP报文来发送HTTP请求了，这也是各种HTTP工具和库模拟HTTP请求的基本原理。<br>举个例子，我们要请求“http：&#x2F;&#x2F;<a href="http://www.example.org/1.php%E2%80%9D%E8%BF%99%E4%B8%AA">www.example.org/1.php”这个</a> URL，则先取出URL中的域名部分，即 example.org，然后通过 socket API gethostbyname 函数得到hootina.org这个域名对应的IP地址，因为在这个URL中没有显式指定请求的端口号，所以使用HTTP的默认端口号80。有了IP和端口号之后，我们使用socket API connect函数连接服务器，然后根据上面介绍的格式组装成HTTP包，并利用socket APIsend函数将组装的协议包发出去，如果服务器有应答，就可以使用socket API recv函数接收数据，然后按HTTP格式进行解包（分为解析包头和包体两个步骤）。</p><h2 id="HTTP服务端的实现"><a href="#HTTP服务端的实现" class="headerlink" title="HTTP服务端的实现"></a>HTTP服务端的实现</h2><p>这里简化一些问题，假设客户端发送的请求都是 GET请求，则在客户端发来 HTTP请求之后，我们拿到 HTTP 包就可以做相应的处理。这里以 Flamingo 服务器实现一个支持HTTP格式的注册请求为例，假设用户在浏览器中输入了以下内容，就可以实现一个注册功能：</p><pre><code>http://101.37.25.166:12345/register.do?p=(&quot;username&quot;:&quot;13917043329&quot;,&quot;nickname&quot;:&quot;balloon&quot;, &quot;password&quot;:&quot;123&quot;),</code></pre><p>这里的HTTP使用的是12345端口，而不是默认的80端口。如何监听12345端口属于网络编程基础知识，这里不再赘述。收到数据后按如下逻辑进行处理：</p><pre><code>void HttpSession::OnRead(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn, Buffer* pBuffer, Timestamp receiveTime)&#123;    string inbuf;    inbuf.append(pBuffer-&gt;peek().pBuffer-&gt;readableBytes());    if (inbuf.length() &lt;= 4)        return;    // ... code continues ...    if (end != &quot;\r\n\r\n&quot;)        return;    // ... code continues ...    std::vector&lt;string&gt; lines;    StringUtil::Split(inbuf.lines, &quot;\r\n&quot;);    if (lines.size() &lt; 1 || lines[0].empty())    &#123;        conn-&gt;forceClose();        return;    &#125;    std::vector&lt;string&gt; chunk;    StringUtil::Split(lines[0], &quot; &quot;, chunk);    if (chunk.size() &lt; 3)    &#123;        conn-&gt;forceClose();        return;    &#125;    // ... code continues ...    std::vector&lt;string&gt; part;    StringUtil::Split(chunk[1], &quot;?&quot;, part);    if (part.size() &lt; 2)    &#123;        conn-&gt;forceClose();        return;    &#125;    string url = part[0];    string param = part[1].substr(23);    if (!Process(conn, url, param))    &#123;        LOG_ERROR &lt;&lt; &quot;handle http request error, from: &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot;, request: &quot; &lt;&lt; pBuffer-&gt;retrieveAllAsString();    &#125;    conn-&gt;forceClose();&#125;</code></pre><p>在以上代码中，在接收到的字节流中必须存在\r\n\r\n 标志（即至少有一个 HTTP 包头部分），然后利用\r\n分割得到每一行.</p><h2 id="HTTP与长连接"><a href="#HTTP与长连接" class="headerlink" title="HTTP与长连接"></a>HTTP与长连接</h2><p>在大多数开发者的认知中，一提到HTTP和HTTP请求，就必然要和短连接关联起来，这种认识是不正确的。尽管目前大多数Web服务器实现的HTTP连接基本上都是短连接，但可以在 HTTP头中设置 keepalive字段，该字段用于建议连接的双方使用长连接进行通信，而不是对每次请求都建立新的连接，但这只是一个建议选项，不少Web服务器并不遵循keepalive字段的建议。相反，在实际商业项目中有这样一种场景会使用长连接的HTTP：在一些业务需要对外保密的企业中，一般禁止内部员工通过除浏览器外的任何客户端访问外网，企业内部会安装一些安全软件，这类软件会过滤掉除HTTP格式外的所有数据包。为了应对这种网络场景，可以使用HTTP长连接访问外网，这是很多客户端支持HTTP代理的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式</title>
      <link href="/p/4d69f701.html"/>
      <url>/p/4d69f701.html</url>
      
        <content type="html"><![CDATA[<h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1><p>网络框架的设计离不开 I&#x2F;O 线程模型，线程模型的优劣直接决定了系统的吞吐量、可扩展性、安全性等。目前主流的网络框架几乎都采用了 I&#x2F;O 多路复用的方案。Reactor 模式作为其中的事件分发器，负责将读写事件分发给对应的读写事件处理者。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前主流的网络通信库，比如libevent使用的都是Reactor模式（反应器模式 或 反射器模式）。Reactor模式是一种事件处理设计模式，在I&#x2F;O请求到达后，服务处理程序使用I&#x2F;O复用技术同步地将这些请求派发给相关的请求处理程序。流程图如下。</p><p><img src="https://s1.ax1x.com/2023/06/17/pCQxAGn.png" alt="pCQxAGn.png"></p><p>从流程图来看，该设计模式很简单，但它的设计思想并不简单。它解决了计算机世界中普遍存在的一个问题：请求太多，资源太少。也就是说，一个对外服务的程序，其接受的各种输入输出请求的数量可能是非常多的，但由于服务程序处理能力有限，其处理这些请求的资源数量（即图中的处理程序）是有限的。所以，上图中输入输出的请求数量之和一般远远超过处理程序的数量，多路复用器（I&#x2F;ODemultiplexer）将这些数量众多的输入输出请求分发给有限的处理程序。<br>所以一个Reactor模式结构一般包含以下模块：</p><ul><li>资源请求事件（Resource Request）；</li><li>多路复用器与事件分发器（I&#x2F;O Demultiplexer&amp;EventDispatcher）；</li><li>事件处理器（EventHandler）。<br>这里以目前大多数饭店的运营模式为例来说明Reactor模式。饭店一般由某个服务员负责服务某几桌客户，顾客有需求时（点菜、结账等）可以告诉服务员，由服务员把这些需求转给其他相关人员（将点菜需求转给厨房工作人员，将结账需求转给收银工作人员）。如此操作，即使饭店顾客爆满，靠几个服务员也能有条不紊地运转整个饭店。<br>这里将上述例子对应到具体的服务器程序技术上。以 socket的读写为例，输入输出请求指socket上有数据可读或者需要往socket上写入数据，而I&#x2F;O多路复用器对应操作系统的相关I&#x2F;O复用函数。在Windows上有select技术（函数），在Linux上有select函数、poll函数、epol模型。使用这些I&#x2F;O复用函数后，Reactor模式对应的流程图如下图所示。</li></ul><p><img src="https://s1.ax1x.com/2023/06/17/pCQxeMV.png" alt="pCQxeMV.png"></p><h2 id="Reactor模式的优点"><a href="#Reactor模式的优点" class="headerlink" title="Reactor模式的优点"></a>Reactor模式的优点</h2><ul><li>响应块，不必为单个同步时间所阻塞，虽然Reactor本身依然时同步的。</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免多线程&#x2F;进程的切换开销。</li><li>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源。</li><li>复用性好，Reactor模式本身与具体事件处理逻辑无关，具有很高的复用性。</li></ul><h2 id="Reactor三种模式"><a href="#Reactor三种模式" class="headerlink" title="Reactor三种模式"></a>Reactor三种模式</h2><h3 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h3><p><img src="https://s1.ax1x.com/2023/06/17/pClm5Yq.md.png" alt="pClm5Yq.md.png"></p><p>模型简单，没有多线程、进程通信和竞争的问题，全部都在一个线程中完成。</p><p><strong>缺点：</strong></p><ul><li>性能问题，只有一个线程，无法发挥多核CPU的性能，Handler在处理某个连接业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</li><li>可靠性问题，线程意外终止或进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul><h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p><strong>工作流程</strong></p><ul><li>Reactor对象通过select监听客户端请求事件，收到事件后，通过dispatch进行分发。</li><li>如果建立连接请求，则Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件。</li><li>如果不是连接请求，则由reactor分发调用连接对应的handler来处理。</li><li>handler只负责相应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务。</li><li>worker线程池会分配独立线程完成真正的业务，并将结果返回给handler。</li><li>handler收到响应后，通过send分发将结果返回给client。</li></ul><p><strong>优点</strong>：可以充分利用多核cpu的处理能力<br><strong>缺点</strong>：多线程数据共享和访问比较复杂，rector处理所有的事件的监听和响应，在单线程运行，在高并发应用场景下，容易出现性能瓶颈。</p><h3 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h3><p><img src="https://img1.imgtp.com/2023/06/17/QSOMNfrd.png" alt="1687008572012.png"><br><strong>工作流程</strong></p><ul><li>Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件。</li><li>当Acceptor处理连接事件后，MainReactor将连接分配给SubAcceptor。</li><li>SubAcceptor将连接加入到连接队列进行监听，并创建handler进行各种事件处理。</li><li>当有新事件发生时，SubAcceptor就会调用对应的handler进行各种事件处理。</li><li>handler通过read读取数据，分发给后面的work线程处理。</li><li>work线程池分配独立的work线程进行业务处理，并返回结果。</li><li>handler收到响应的结果后，再通过send返回给client。</li></ul><p><strong>注意</strong>：Reactor主线程可以对应多个Reactor子线程，即SubAcceptor。</p><h3 id="生活案例来理解"><a href="#生活案例来理解" class="headerlink" title="生活案例来理解"></a>生活案例来理解</h3><p>1、单reactor单线程，前台接待员、服务员是同一个人，全程为顾客服务。</p><p>2、单reactor多线程，1个前台接待，多个服务员，接待员只负责接待。</p><p>3、主从reactor多线程，多个前台接待，多个服务员。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wasm</title>
      <link href="/p/a9a8d1fe.html"/>
      <url>/p/a9a8d1fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="wasm"><a href="#wasm" class="headerlink" title="wasm"></a>wasm</h1><p>WASM是“WebAssembly”的缩写。WebAssembly是一种新的代码格式，是一种低级别、代码密集型的虚拟机，可以被浏览器支持，以便在浏览器中高效地运行各种语言的代码。<br>WebAssembly是一种与JavaScript类似的虚拟机，但它并不基于文本，而是一种二进制格式，无需编译器处理即可运行。WebAssembly 可以为那些不想或难以通过JavaScript实现的计算任务提供一种性能非常优秀的运行方式，其中包括数据密集型任务、游戏以及机器学习应用。<br>WebAssembly 在与 JavaScript 应用协同工作方面非常优秀，可以通过JavaScript与WebAssembly代码进行交互，并允许网络应用程序在客户端和服务器之间快速共享代码。由于WASM是一种跨平台、低级别的虚拟机，因此也可以在移动应用、桌面应用等上下文中使用，从而实现高效的多平台代码共享。 </p><p>WebAssembly（WASM）的优势有以下几个方面</p><ul><li>高效性：WASM 可以实现高效的解释和编译，因此可以快速执行计算密集型任务，提高 Web 应用程序的性能。与 JavaScript 相比，它更加接近计算机本身的机器语言，因此可以在不增加时间和内存开销的情况下加快许多任务的执行速度。<br>可移植性：WASM 是一种与平台无关的格式，可以在任何浏览器和操作系统上运行。这意味着，WASM 应用程序不需要为每个平台编写代码或重新编译代码，从而大大降低了开发和维护成本。</li><li>安全性：WASM 代码在运行之前需要通过一系列的检查程序，以确保其不会访问到不安全的资源或内存，并且其执行不会导致不安全的行为。因此，WASM 在安全性方面有着很大的优势，也更容易通过常规的安全审计程序获得通过。</li><li>可组合性：由于 WebAssembly 可以与 JavaScript 代码无缝协作，因此可以简化现有技术栈之间的迁移和相互支持，例如可以将现有的 JavaScript 库包装成 WebAssembly 模块，以更快、更高效地执行计算密集型任务。</li><li>扩展性：WASM 支持多种编程语言，如 C++、Rust 和 Kotlin 等，这可以帮助开发者来扩展现有的技术栈并更快地将不同的代码整合到一个应用程序中。</li></ul><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="Go编译为wasm"><a href="#Go编译为wasm" class="headerlink" title="Go编译为wasm"></a>Go编译为wasm</h3><p>将Golang程序编译为wasm格式，一般有两种方式：</p><ol><li>采用Go原生编译器(Go1.11及以后)进行编译：无需安装第三方编译库，但此种编译的wasm不支持wasi规范</li><li>使用第三方编译工具，例如TinyGo编译器进行编译</li></ol><h3 id="安装tinygo"><a href="#安装tinygo" class="headerlink" title="安装tinygo"></a>安装tinygo</h3><p>参照官方文档<a href="https://tinygo.org/getting-started/overview/">https://tinygo.org/getting-started/overview/</a></p><h4 id="通过-Scoop-快速安装"><a href="#通过-Scoop-快速安装" class="headerlink" title="通过 Scoop 快速安装"></a>通过 Scoop 快速安装</h4><blockquote><p>scoop install tinygo<br>您的$PATH环境变量将通过 scoop 包更新。默认情况下，在~&#x2F;scoop&#x2F;shims&#x2F;tinygo.</p></blockquote><p>可以通过 scoop 升级到最新的 TinyGo 版本：</p><blockquote><p>scoop update tinygo</p></blockquote><p>version您可以通过运行应显示版本号的命令来测试安装是否成功：</p><blockquote><p>tinygo version<br>tinygo version 0.27.0 windows&#x2F;amd64 (using go version go1.20 and LLVM version 15.0.0)</p></blockquote><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>从<a href="https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip%E4%B8%8B%E8%BD%BD%E9%80%82%E7%94%A8%E4%BA%8E">https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip下载适用于</a> Windows 的 TinyGo 二进制文件</p><p>然后解压文件：</p><p>文件夹解压完成后，需要添加your-path\tinygo\bin到您的 PATH。</p><blockquote><p>set PATH&#x3D;%PATH%;”your-path\tinygo\bin”;</p></blockquote><h3 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h3><p>wasm-opt 工具用于优化 WebAssembly 二进制文件，通常随 Emscripten SDK 一起提供。Emscripten SDK 安装过程中需要使用 Python 解释器来执行一些操作。</p><p><a href="https://www.python.org/downloads/windows/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%89%88%E6%9C%ACinstaller">https://www.python.org/downloads/windows/官网下载相应版本installer</a><br>安装过程中记得勾选将python加入到环境变量选项</p><h3 id="Emscripten-SDK"><a href="#Emscripten-SDK" class="headerlink" title="Emscripten SDK"></a>Emscripten SDK</h3><p>Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，</p><p>从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。</p><pre><code># Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk</code></pre><p>再使用如下命令安装配置Emscripten。</p><pre><code># Fetch the latest registry of available tools.git pull# Download and install the latest SDK tools. Need install Python first. ./emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)./emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal./emsdk_env.bat</code></pre><p>完成上述步骤以后，需要将upstream内的bin目录加入到环境变量，或者手动设置 WASMOPT 环境变量</p><pre><code>export WASMOPT=path/to/wasm-opt</code></pre><p>注意，path&#x2F;to&#x2F;wasm-opt 应替换为实际的 wasm-opt 可执行文件路径。</p><h3 id="安装wasm的运行时环境"><a href="#安装wasm的运行时环境" class="headerlink" title="安装wasm的运行时环境"></a>安装wasm的运行时环境</h3><p>运行wasm需要有一个运行时环境，由于浏览器内置了wasm的runtime，因此大部分浏览器内可以直接运行wasm。而在非浏览器环境，则需要有一个运行时来执行wasm<br>wazero is the only zero dependency WebAssembly runtime written in Go.</p><p><a href="https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go">https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go</a><br>可以在这里面下载windows安装版本，默认安装到C:\Program Files\wazero<br>将其加入到环境变量以便可以在其他文件夹运行该文件。</p><h2 id="tinygo将Go代码编译为wasi格式"><a href="#tinygo将Go代码编译为wasi格式" class="headerlink" title="tinygo将Go代码编译为wasi格式"></a>tinygo将Go代码编译为wasi格式</h2><p>创建一个hello文件</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello world!&quot;)&#125;</code></pre><p>构建命令</p><pre><code>tinygo build -o hello.wasm -target=wasi hello.gotarget有两种目标，一种是wasm，主要是运行在web浏览器环境；一种是wasi，即非web环境下运行。-o 参数指定输出的文件路径及名称，-target参数指定编译格式，最后main.go代表需要编译的文件入口。</code></pre><p>运行文件</p><pre><code>wazero run hello.wasm</code></pre><p>得到输出</p><pre><code>Hello world!</code></pre><p>官方wiki指南：<a href="https://github.com/golang/go/wiki/WebAssembly%EF%BC%8CGo%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%98%E6%96%B9%E5%B7%B2%E6%94%AF%E6%8C%81%E5%B0%86%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%BAwasm%E6%A8%A1%E5%9D%97%EF%BC%8C%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%82">https://github.com/golang/go/wiki/WebAssembly，Go编译器官方已支持将代码编译为wasm模块，无需借助第三方编译工具。</a></p><p>将编写好的go程序编译成wasm格式，在编译时需要指定编译参数：</p><pre><code>GOOS=js GOARCH=wasm go build -o ../dist/main.wasm</code></pre><p>获取go官方准备的js胶水文件：</p><pre><code>cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; .</code></pre><p>PS: JS 胶水文件（JavaScript glue file）是指一类用于连接 JavaScript 代码与其他语言的代码的文件。常见的使用 JS 胶水文件的场景包括使用 JavaScript 调用 C&#x2F;C++ 程序、使用 JavaScript 调用 Python 程序等等。JS 胶水文件通常会包含一些 C&#x2F;C++ 或 Python 的函数定义，以及这些函数的映射关系。在 JavaScript 代码中调用这些函数时，JS 胶水文件会将函数调用转换为对应的 C&#x2F;C++ 或 Python 函数调用。JS 胶水文件的实现方式有多种，比较常见的方式包括使用 Node.js 的 ffi 模块、使用 Emscripten 编译 C&#x2F;C++ 代码为 WebAssembly 等。</p><p>创建一个html文件，引入wasm：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const go = new Go();        WebAssembly.instantiateStreaming(fetch(&quot;hello.wasm&quot;), go.importObject).then((result) =&gt; &#123;            go.run(result.instance);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;WebAssembly Demo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后 Web 服务器启动index.html、wasm_exec.js和main.wasm<br>例如，goexec：</p><pre><code># install goexec: go get -u github.com/shurcooL/goexecgoexec &#39;http.ListenAndServe(`:8080`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>这个命令将在当前目录启动一个 Go 的 HTTP 服务器，用于提供您的静态文件。在终端中运行该命令后，您应该可以通过 <a href="http://localhost:8080/">http://localhost:8080/</a> 访问网页，其中 . 是当前目录的路径。如果网页文件是 index.html，那么可以通过 <a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a> 访问它。<br>导航到<a href="http://localhost:8080/index.html%EF%BC%8C%E6%89%93%E5%BC%80">http://localhost:8080/index.html，打开</a> JavaScript 调试控制台，您应该会看到输出。您可以修改程序、重建main.wasm和刷新以查看新的输出。<br>注意：要使goexec命令在类 Unix 系统上运行，您必须将 Go的路径环境变量添加到 shell 的profile.</p><p>go编写的函数如何暴露给js调用<br><a href="https://pkg.go.dev/syscall/js">https://pkg.go.dev/syscall/js</a></p><h3 id="示例-格式化json对象"><a href="#示例-格式化json对象" class="headerlink" title="示例-格式化json对象"></a>示例-格式化json对象</h3><p>json.go :</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;syscall/js&quot;    &quot;time&quot;)func main() &#123;    fmt.Println(&quot;Hello WebAssembly!&quot;)    //注册为全局变量    js.Global().Set(&quot;prettyJSON&quot;, jsonWrapper())    &lt;-make(chan bool)&#125;func prettyJson(input string) (string, error) &#123;    start := time.Now()    var raw interface&#123;&#125;    if err := json.Unmarshal([]byte(input), &amp;raw); err != nil &#123;        return &quot;&quot;, err    &#125;    pretty, err := json.MarshalIndent(raw, &quot;&quot;, &quot; &quot;)    if err != nil &#123;        return &quot;&quot;, err    &#125;    cost := time.Since(start)    fmt.Println(&quot;wasm json耗时: &quot;, cost)    return string(pretty), nil&#125;// 将Go函数封装并返回js.Func对象，才可以被js所调用func jsonWrapper() js.Func &#123;    jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) interface&#123;&#125;&#123;        if len(args) != 1 &#123;            return &quot;Invalid no of arguments passed&quot;        &#125;        inputJSON := args[0].String()        // fmt.Printf(&quot;input %s\n&quot;, inputJSON)        pretty, err := prettyJson(inputJSON)        if err != nil &#123;            fmt.Printf(&quot;unable to convert to json %s\n&quot;, err)            return err.Error()        &#125;        return pretty    &#125;)    return jsonFunc&#125;</code></pre><p>定义html文件：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const go = new Go();        WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject).then((result) =&gt; &#123;            go.run(result.instance);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;WebAssembly Demo&lt;/h1&gt;&lt;input type=&quot;text&quot; id=&quot;jsonInput&quot;&gt;&lt;button id=&quot;btn-wasm&quot;&gt;解析(wasm)&lt;/button&gt;&lt;br /&gt;&lt;textarea id=&quot;prettyJsonArea&quot;&gt;&lt;/textarea&gt;&lt;script src=&quot;handle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>定义handle.js:</p><pre><code>const convertBtnByWasm = document.getElementById(&#39;btn-wasm&#39;);const jsonInput = document.getElementById(&#39;jsonInput&#39;)convertBtnByWasm.addEventListener(&#39;click&#39;, () =&gt; &#123;const content = jsonInput.value;const pretty = window.globalThis.prettyJSON(content);prettyJsonArea.value = pretty&#125;)</code></pre><p><img src="https://s1.ax1x.com/2023/04/24/p9mOfne.png" alt="p9mOfne.png"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly与Go实践</title>
      <link href="/p/f113fd4.html"/>
      <url>/p/f113fd4.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebAssembly与Go实践"><a href="#WebAssembly与Go实践" class="headerlink" title="WebAssembly与Go实践"></a>WebAssembly与Go实践</h1><div class="row">    <embed src="../../../pdf/WebAssembly与Go实践.pdf" width="100%" height="550" type="application/pdf"></div><p>注：pdf为本人编写，金山轻文档写东西实在是太香了，只可惜不支持导出为markdown</p><h2 id="wasm简介"><a href="#wasm简介" class="headerlink" title="wasm简介"></a>wasm简介</h2><h3 id="webassembly的定义"><a href="#webassembly的定义" class="headerlink" title="webassembly的定义"></a>webassembly的定义</h3><p>WASM是“WebAssembly”的缩写。WebAssembly是一种新的代码格式，是一种低级别、代码密集型的与JavaScript类似的虚拟机，但它并不基于文本，而是一种二进制格式，无需编译器处理即可运行WebAssembly 可以为那些不想或难以通过JavaScript实现的计算任务提供一种性能非常优秀的运行方式，其中包括数据密集型任务、游戏以及机器学习应用。<br>WebAssembly 支持多种编程语言,包含 C&#x2F;C++、 Rust、 Go、 Swift、 Kotlin、 AssemblyScript、 Grain，甚至还有 JavaScript 和 Python。</p><p>• 对于编译型语言（比如 C 和 Rust）来说，WasmEdge WebAssembly 提供了一个相比于原生客户端（NaCl）更安全的、受保护的、隔离的并且容器化的运行时。<br>• 对于解释型语言或者是受控型语言（比如 JavaScript 和 Python）来说，WasmEdge WebAssembly 提供了一个比 Docker + 客人操作系统（Guest OS） + 原生解释器这种组合更安全、快速、轻量且容器化的运行时。</p><h3 id="WebAssembly（WASM）的优势"><a href="#WebAssembly（WASM）的优势" class="headerlink" title="WebAssembly（WASM）的优势"></a>WebAssembly（WASM）的优势</h3><p>• 高效性：WASM 可以实现高效的解释和编译，因此可以快速执行计算密集型任务，提高 Web 应用程序的性能。与 JavaScript 相比，它更加接近计算机本身的机器语言，因此可以在不增加时间和内存开销的情况下加快许多任务的执行速度。<br>• 可移植性：WASM 是一种与平台无关的格式，可以在任何浏览器和操作系统上运行。WASM 应用程序不需要为每个平台编写代码或重新编译代码，从而大大降低了开发和维护成本。<br>• 安全性：WASM 代码在运行之前需要通过一系列的检查程序，以确保其不会访问到不安全的资源或内存，并且其执行不会导致不安全的行为。因此，WASM 在安全性方面有着很大的优势。<br>• 可组合性： WebAssembly 可以与 JavaScript 代码无缝协作，可以简化现有技术栈之间的迁移和相互支持，可以将现有的 JavaScript 库包装成 WebAssembly 模块，以更快、更高效地执行计算密集型任务。<br>• 扩展性：WASM 支持多种编程语言，如 C++、Rust 和 Go 等，这可以帮助开发者来扩展现有的技术栈并更快地将不同的代码整合到一个应用程序中。</p><h3 id="什么是-wasi"><a href="#什么是-wasi" class="headerlink" title="什么是 wasi"></a>什么是 wasi</h3><blockquote><p>wasi官网: <a href="https://wasi.dev/">https://wasi.dev/</a></p></blockquote><p>WASI 全称 The WebAssembly System Interface 通俗来讲就是一个对接规范，将 wasm 的应用领域从 web 中拓展到更广阔的各个平台中去。<br>WASI允许WebAssembly环境访问操作系统提供的功能例如文件，文件系统，网络套接字，计时器和随机数生成器。与WebAssembly在导入功能级别限制访问的方式类似，WASI控制对系统功能的访问。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="安装Tinygo"><a href="#安装Tinygo" class="headerlink" title="安装Tinygo"></a>安装Tinygo</h3><p>TinyGo支持一小部分的Go语言标准库和Go语言的大部分语法和特性，相对于Go本身编译具有轻量的特点，用TinyGo编译可以大大缩小编译后程序大小。<br>安装过程参照官方文档<a href="https://tinygo.org/getting-started/overview/">https://tinygo.org/getting-started/overview/</a> 有两种安装方式</p><h4 id="1-通过-Scoop-快速安装"><a href="#1-通过-Scoop-快速安装" class="headerlink" title="1.通过 Scoop 快速安装"></a>1.通过 Scoop 快速安装</h4><p>这种安装方式$PATH环境变量将通过 scoop 包更新。默认情况下，在~&#x2F;scoop&#x2F;shims&#x2F;tinygo.</p><pre><code>&gt; scoop install tinygo</code></pre><p>可以通过 scoop 升级到最新的 TinyGo 版本：</p><pre><code>&gt; scoop update tinygo</code></pre><p>可以通过运行应显示版本号的命令来测试安装是否成功：</p><pre><code>&gt; tinygo versiontinygo version 0.27.0 windows/amd64 (using go version go1.20 and LLVM version 15.0.0)</code></pre><h4 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h4><p>从<a href="https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip%E4%B8%8B%E8%BD%BD%E9%80%82%E7%94%A8%E4%BA%8E">https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip下载适用于</a> Windows 的 TinyGo 二进制文件<br>然后解压文件，文件夹解压完成后，需要添加your-path\tinygo\bin到 PATH 当中。</p><pre><code>&gt; set PATH=%PATH%;&quot;your-path\tinygo\bin&quot;;</code></pre><h3 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h3><p>wasm-opt 工具用于优化 WebAssembly 二进制文件，通常随 Emscripten SDK 一起提供。Emscripten SDK 安装过程中需要使用 Python 解释器来执行一些操作。<br><a href="https://www.python.org/downloads/windows/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%89%88%E6%9C%ACinstaller">https://www.python.org/downloads/windows/官网下载相应版本installer</a><br>安装过程中记得勾选将python加入到环境变量选项，否则需要手动加入。</p><h3 id="Emscripten-SDK"><a href="#Emscripten-SDK" class="headerlink" title="Emscripten SDK"></a>Emscripten SDK</h3><p>Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，<br>从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。</p><pre><code># Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk</code></pre><p>再使用如下命令安装配置Emscripten。</p><pre><code># Fetch the latest registry of available tools.git pull# Download and install the latest SDK tools. Need install Python first. ./emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)./emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal./emsdk_env.bat</code></pre><p>完成上述步骤以后，需要将upstream内的bin目录加入到环境变量，或者手动设置 WASMOPT 环境变量。</p><pre><code>export WASMOPT=path/to/wasm-opt</code></pre><p>export WASMOPT&#x3D;path&#x2F;to&#x2F;wasm-opt</p><h3 id="安装wasm的运行时环境"><a href="#安装wasm的运行时环境" class="headerlink" title="安装wasm的运行时环境"></a>安装wasm的运行时环境</h3><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>运行wasm需要有一个运行时环境，Firefox Quantum、Safari、Edge和Chrome等主流浏览器都支持WebAssembly，内置了wasm的runtime，因此大部分浏览器内可以直接运行wasm。而在非浏览器环境，则需要有一个runtime来执行wasm。</p><h4 id="wazero"><a href="#wazero" class="headerlink" title="wazero"></a>wazero</h4><p>wazero是一种使用Go编写的零依赖wasm运行时环境。它允许Go开发人员在应用程序中轻松执行wasm代码，无需进行额外的依赖。<br><a href="https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go">https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go</a><br>点击上述链接自动下载windows安装版本，默认安装到C:\Program Files\wazero,将对应可执行文件加入到环境变量以便可以在其他文件夹运行该文件。</p><h2 id="将Go编译为wasm"><a href="#将Go编译为wasm" class="headerlink" title="将Go编译为wasm"></a>将Go编译为wasm</h2><p>将Golang程序编译为wasm格式，一般有两种方式：</p><ol><li>使用第三方编译工具，例如TinyGo编译器进行编译。</li><li>采用Go原生编译器(Go1.11及以后)进行编译：无需安装第三方编译库，但此种编译的wasm不支持wasi规范;在 Go1.21 起，Go 将会支持 WASI 的特性。预计先支持 WASI Preview1 标准，WASI Preview2 目前距离标准成熟还为时尚早，后续Preview2标准成熟后会继续支持新标准</li></ol><h3 id="TinyGo编译"><a href="#TinyGo编译" class="headerlink" title="TinyGo编译"></a>TinyGo编译</h3><p>创建一个hello文件</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello world!&quot;)&#125;</code></pre><p>构建命令</p><pre><code>tinygo build -o hello.wasm -target=wasi hello.go</code></pre><p>• target有两种目标，一种是wasm，主要是运行在web浏览器环境；一种是wasi，即非web环境下运行。<br>• -o 参数指定输出的文件路径及名称，-target参数指定编译格式，最后main.go代表需要编译的文件入口。</p><p>运行文件</p><pre><code>wazero run hello.wasm</code></pre><p>得到输出</p><pre><code>Hello world!</code></pre><h3 id="Go编译"><a href="#Go编译" class="headerlink" title="Go编译"></a>Go编译</h3><p>官方wiki指南：<a href="https://github.com/golang/go/wiki/WebAssembly%EF%BC%8CGo%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%98%E6%96%B9%E4%BB%8EGo1.11">https://github.com/golang/go/wiki/WebAssembly，Go编译器官方从Go1.11</a> 开始支持将代码编译为wasm模块。<br>将编写好的go程序编译成wasm格式，在编译时需要指定编译参数：</p><pre><code>GOOS=js GOARCH=wasm go build -o ./main.wasm</code></pre><p>获取go官方准备的js胶水文件：</p><pre><code> cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; .</code></pre><p>PS: JS 胶水文件（JavaScript glue file）是指一类用于连接 JavaScript 代码与其他语言的代码的文件。<br>常见的使用 JS 胶水文件的场景包括使用 JavaScript 调用 Go 程序，使用 JavaScript 调用 C&#x2F;C++ 程序，使用 JavaScript 调用 Python 程序等等。JS 胶水文件通常会包含一些Go， C&#x2F;C++ 或 Python 的函数定义，以及这些函数的映射关系。<br>在 JavaScript 代码中调用这些函数时，JS 胶水文件会将函数调用转换为对应的 Go，C&#x2F;C++ 或 Python 函数调用。<br>JS 胶水文件的实现方式有多种，比较常见的方式包括使用 Node.js 的 ffi 模块、使用 Emscripten 编译Go， C&#x2F;C++ 代码为 WebAssembly 等。</p><p>创建一个html文件，引入wasm：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const go = new Go();        WebAssembly.instantiateStreaming(fetch(&quot;hello.wasm&quot;), go.importObject).then((result) =&gt; &#123;            go.run(result.instance);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;WebAssembly Demo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>当我们运行程序的时候，我们不能直接在浏览器中打开 HTML 文件，因为跨域请求是不支持 file 协议的。我们需要将我们的输出文件运行在HTTP协议上。Web 服务器启动index.html、wasm_exec.js和main.wasm，例如，goexec：</p><pre><code>#install goexec: go get -u github.com/shurcooL/goexecgoexec &#39;http.ListenAndServe(`:8080`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>这个命令将在当前目录启动一个 Go 的 HTTP 服务器，用于提供静态文件。在终端中运行该命令后，可以通过 <a href="http://localhost:8080/">http://localhost:8080/</a> 访问网页，其中  .  是当前目录的路径。如果网页文件是 index.html，那么可以通过 <a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a> 访问它。<br>导航到<a href="http://localhost:8080/index.html%EF%BC%8C%E6%89%93%E5%BC%80">http://localhost:8080/index.html，打开</a> JavaScript 调试控制台，会看到输出。可以修改程序、重建main.wasm和刷新来查看新的输出。<br>注意：要使goexec命令在类 Unix 系统上运行，则必须将 Go的路径环境变量添加到 shell 的profile。</p><h3 id="Go编译wasi（实验）"><a href="#Go编译wasi（实验）" class="headerlink" title="Go编译wasi（实验）"></a>Go编译wasi（实验）</h3><p>在 Go1.21 起，Go 将会支持 WASI 的特性。预计先支持 WASI Preview1[1] 标准，后续 WASI Preview2 成熟后会继续支持新标准。<br>目前最新版本是1.20.6，我们可以通过安装 gotip体验最新版本Go，gotip 是从开发分支上编译并运行 go 的命令。安装命令如下：</p><pre><code>go install golang.org/dl/gotip@latestgotip download</code></pre><p>注意，需要将本地的cc1.exe改为64位的。<br>下载地址<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-snapshot/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-snapshot/</a></p><p>下载完成后，我们将对应路径加入到环境变量（cc1的路径也需要加入）<br>我们写一个简单的 Go Wasm Demo测试一下：</p><pre><code>package mainfunc main() &#123;    println(&quot;你好，WASI！&quot;)&#125;</code></pre><p>接下来我们将上述 Go 程序编译为 .wasm 文件。使用如下编译命令：</p><pre><code> GOARCH=wasm GOOS=wasip1 gotip build -o hello.wasm hello.go</code></pre><p>通过wazero运行生成的文件</p><h2 id="wasm和go交互"><a href="#wasm和go交互" class="headerlink" title="wasm和go交互"></a>wasm和go交互</h2><h3 id="Go调用js代码"><a href="#Go调用js代码" class="headerlink" title="Go调用js代码"></a>Go调用js代码</h3><p>新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 window.alert(“Hello World”)。</p><pre><code>package mainimport&quot;syscall/js&quot;func main() &#123;    alert := js.Global().Get(&quot;alert&quot;)    alert.Invoke(&quot;Hello World!&quot;)&#125;</code></pre><p>然后参照上面步骤编译main程序的方法生成对应wasm文件，复制胶水文件。<br>创建 index.html，引用 main.wasm 和 wasm_exec.js。</p><pre><code>&lt;html&gt;&lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject)        .then((result) =&gt; go.run(result.instance));&lt;/script&gt;&lt;/html&gt;</code></pre><p>使用 goexec 启动 Web 服务<br>浏览器访问 localhost:8080，则会有一个弹出窗口，上面写着 *Hello World!*。</p><h3 id="js调用go函数"><a href="#js调用go函数" class="headerlink" title="js调用go函数"></a>js调用go函数</h3><p>JavaScript 代码调用其他语言生成的wasm，需要使用注册函数<br>假设我们需要注册一个计算斐波那契数列的函数，通过 syscall&#x2F;js 包提供的 API，将函数 fib 注册为 JavaScript 函数，并通过 js.Global().Set() 将其绑定到全局对象上。然后，在 JavaScript 中就可以通过调用 fibFunc() 函数来调用 Go 语言中的 fib 函数，并获得返回值。</p><pre><code>// main.gopackage mainimport &quot;syscall/js&quot;func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    return js.ValueOf(fib(args[0].Int()))&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><p>• 定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。<br>• this 和 args。其中 this 表示函数的执行上下文，对于该函数来说，它没有被使用到，因此被省略了。而 args 是一个包含传递给函数的所有参数的数组。<br>• 使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。<br>• js.ValueOf() 方法是 syscall&#x2F;js 包提供的一个函数，它用于将 Go 的值转换为对应的 JavaScript 值，并返回一个 js.Value 类型的值。</p><p>fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。使用 Go 的并发机制来处理复杂的任务，而不会阻塞 JavaScript 的事件循环。<br>接下来创建index.html在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。</p><pre><code>&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;ans.innerHTML=fibFunc(num.value * 1)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>注：go编写的函数如何暴露给js调用    <a href="https://pkg.go.dev/syscall/js">https://pkg.go.dev/syscall/js</a></p><h3 id="Go实现DOM元素操作"><a href="#Go实现DOM元素操作" class="headerlink" title="Go实现DOM元素操作"></a>Go实现DOM元素操作</h3><p>在上面例子中，Go仅仅注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML中通过js 函数实现的。<br>首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。</p><pre><code>&lt;html&gt;&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;    &lt;p id =&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject)        .then((result) =&gt; go.run(result.instance));&lt;/script&gt;&lt;/html&gt;</code></pre><p>修改 main.go：</p><pre><code>package mainimport (    &quot;strconv&quot;    &quot;syscall/js&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;var (    document = js.Global().Get(&quot;document&quot;)    numEle   = document.Call(&quot;getElementById&quot;, &quot;num&quot;)    ansEle   = document.Call(&quot;getElementById&quot;, &quot;ans&quot;)    btnEle   = js.Global().Get(&quot;btn&quot;))func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    v := numEle.Get(&quot;value&quot;)    if num, err := strconv.Atoi(v.String()); err == nil &#123;        ansEle.Set(&quot;innerHTML&quot;, js.ValueOf(fib(num)))    &#125;    return nil&#125;func main() &#123;    done := make(chan int, 0)    btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。<br>先修改 main.go，使得 fibFunc 支持传入回调函数。</p><pre><code>package mainimport (    &quot;syscall/js&quot;    &quot;time&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    callback := args[len(args)-1]    go func() &#123;        time.Sleep(3 * time.Second)        v := fib(args[0].Int())        callback.Invoke(v)    &#125;()    js.Global().Get(&quot;ans&quot;).Set(&quot;innerHTML&quot;, &quot;Waiting 3s...&quot;)    return nil&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><p>• 使用 go func() 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 callback，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。</p><p>接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc</p><pre><code>&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;fibFunc(num.value * 1, (v)=&gt; ans.innerHTML=v)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>• 为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。<br>• 第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。</p><h2 id="WebAssembly-线性内存"><a href="#WebAssembly-线性内存" class="headerlink" title="WebAssembly 线性内存"></a>WebAssembly 线性内存</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线性内存是一个连续的、字节寻址的内存空间，由一系列的页组成。每一页的大小为 64KB，可以通过 WebAssembly 模块的内存限制指令来设置线性内存的最小页数和最大页数。<br>线性内存的寻址方式是通过一个内存索引值和一个偏移量来定位内存中的某个特定字节。可以使用 WebAssembly 指令来读取和写入线性内存中的字节。此外，WebAssembly 还提供了一些内存相关的指令，比如内存复制、内存填充、内存大小查询等。<br>线性内存是 WebAssembly 中实现高效内存访问的重要机制之一，它不仅可以被 WebAssembly 模块本身访问，还可以被与 WebAssembly 交互的宿主环境（如 JavaScript）访问。通过将数据从宿主环境复制到 WebAssembly 的线性内存中，可以使得 WebAssembly 代码能够对这些数据进行高效的处理，从而实现更高效的跨语言交互。<br>需要注意WebAssembly 的线性内存大小是固定的，因此在 WebAssembly 模块实例化之后，无法再次改变它的大小。如果需要动态地增加或减少内存，可以通过重新实例化一个新的 WebAssembly 模块来实现，但这会涉及到复制原有的线性内存内容，会比较消耗性能。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>首先我们编写，main.go</p><pre><code>// 在 wasm_exec_tiny.js 中定义。别忘了在 index.html 中添加这个脚本。const go = new Go(); const runWasm = async () =&gt; &#123;    const importObject = go.importObject;    // 实例化 wasm 模块    const wasmModule = await wasmBrowserInstantiate(&quot;./main.wasm&quot;, importObject);    // 在进行任何其他操作之前，必须先运行 go 实例，否则 println 等操作将不起作用    go.run(wasmModule.instance);    /**    * 第一部分：在 Wasm 中写入，在 JS 中读取    */    console.log(&quot;在 Wasm 中写入，在 JS 中读取，索引为 0：&quot;);    // 首先，让 wasm 写入我们的缓冲区    wasmModule.instance.exports.storeValueInWasmMemoryBufferIndexZero(24);    // 接下来，让我们创建一个指向我们的 wasm 内存的 Uint8Array    let wasmMemory = new Uint8Array(wasmModule.instance.exports.memory.buffer);    // 然后，让我们获取指向在 wasmMemory 中的缓冲区的指针    let bufferPointer = wasmModule.instance.exports.getWasmMemoryBufferPointer();    // 接着，让我们通过访问 wasmMemory[bufferPointer + bufferIndex] 的索引来读取缓冲区中索引为 0 的已写入的值    // 应该输出 &quot;24&quot;    console.log(wasmMemory[bufferPointer + 0]);     /**    * 第二部分：在 JS 中写入，在 Wasm 中读取    */    console.log(&quot;在 JS 中写入，在 Wasm 中读取，索引为 1：&quot;);    // 首先在缓冲区的索引 1 上写入值    wasmMemory[bufferPointer + 1] = 15;    // 然后，让 wasm 读取缓冲区中的索引 1，并返回结果    // 应该输出 &quot;15&quot;    console.log(        wasmModule.instance.exports.readWasmMemoryBufferAndReturnIndexOne()    ); &#125;;runWasm();</code></pre><p>利用共享内存空间我们可以在js以及Go之间传递数据，相对来说也很方便，实现高效的跨语言交互。</p><h2 id="wasm的不足"><a href="#wasm的不足" class="headerlink" title="wasm的不足"></a>wasm的不足</h2><h3 id="交互复杂"><a href="#交互复杂" class="headerlink" title="交互复杂"></a>交互复杂</h3><p>虽然Wasm可以独立运行，但由于 wasm 模块运行在一个隔离的沙盒环境中，与主体应用的 JavaScript 或其他语言的代码有着明确的内存分隔，在Web环境中，WASM 代码无法直接访问浏览器的 Web API（如 DOM 操作、网络请求等），而必须通过 JavaScript 来进行中介，Wasm与JavaScript之间的交互是通过JavaScript的API进行的。复杂数据类型需要进行编解码，对于除“数字、字符串”以外的类型（例如：对象、数组）需要先编码成二进制再存放到 WASM 的内存段里。在使用WebAssembly 进行开发时，仍然需要编写一定量的JavaScript 代码来与浏览器交互，这会引入一些性能损耗和额外的复杂性。与 JavaScript 胶水代码的交互带来的性能损耗在一定程度上抵消了 WASM 本身带来的性能红利。</p><h3 id="生态仍不完善"><a href="#生态仍不完善" class="headerlink" title="生态仍不完善"></a>生态仍不完善</h3><p>Wasm 技术的生态系统仍在不断发展和成熟，相关工具和库的数量和质量仍然有待提高，缺乏一些成熟的工具支持。这可能会影响到开发效率和稳定性，比如仍然需要通过JavaScript与实际的数据库进行通信，然后利用其他语言进行数据处理。<br>编译工具依赖：将普通的编程语言代码编译为 wasm 格式时，需要使用特定的编译工具，例如 Emscripten、TinyGo、wasm-pack 等。这些编译工具通常需要额外的配置和学习成本，并且可能在不同的平台和开发环境中具有不同的使用方式，可能会导致在开发和部署过程中出现一些困难。<br>运行时环境依赖：在运行 wasm 插件时，需要在主体应用中提供相应的运行时环境，例如浏览器的 JavaScript 运行时或者服务器端的 wasm 运行时。这意味着如果目标环境不支持 wasm 运行时，或者运行时环境的版本不兼容，那么 wasm 插件将无法正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于xfx torm的学习开发和容器化打包部署</title>
      <link href="/p/2ecd4e0f.html"/>
      <url>/p/2ecd4e0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于xfx-torm的学习开发和容器化打包部署"><a href="#基于xfx-torm的学习开发和容器化打包部署" class="headerlink" title="基于xfx torm的学习开发和容器化打包部署"></a>基于xfx torm的学习开发和容器化打包部署</h1><h2 id="stage-生成代码"><a href="#stage-生成代码" class="headerlink" title="stage 生成代码"></a>stage 生成代码</h2><p>stage 可以帮助开发人员定义并产出规范的工程项目。利用 stage 我们可以用极快的速度生产：</p><pre><code>mkdir -p ./src/hellocd ./src/hellostage initecho &quot;get /hello 200 &#123;greeting: string&#125;;&quot; &gt;&gt; spec/hello.xidlstage gengo mod tidymake build./run serve</code></pre><p>编译后的 hello 是一个可以直接运行的服务器程序。可以通过 curl 命令验证服务器是否运行正常：</p><pre><code>curl http://localhost:8080/hello</code></pre><p>stage init 命令类似于 git init 命令，将一个目录初始化为规范工程，它产生了一个 spec&#x2F;hello.xidl 文件，这个文件用来定义程序接口规格，默认情况下 stage 定义好了最基本的命令行接口。</p><pre><code>stage init</code></pre><p>然后向 hello.xidl 追加了一条 &#x2F;hello 的定义，这是一种紧凑型的接口定义语言。</p><pre><code>echo &quot;get /hello 200 &#123;greeting: string&#125;;&quot; &gt;&gt; spec/hello.xidl</code></pre><p>stage gen 命令会根据接口规格描述产生工程代码。</p><pre><code>stage gen</code></pre><p>注：<br>需要配置完成go环境以后使用stage<br>需要将stage.exe 加入到环境变量方便我们在其他文件夹内使用该命令<br>make命令需要下载MinGW 并且配置make环境变量</p><h2 id="利用docker搭建数据库MYSQL"><a href="#利用docker搭建数据库MYSQL" class="headerlink" title="利用docker搭建数据库MYSQL"></a>利用docker搭建数据库MYSQL</h2><p>点击 <a href="https://yeasy.gitbook.io/docker_practice/install/windows">链接</a> 下载 Docker Desktop for Windows<br>下载完成后</p><pre><code>docker pull mysql</code></pre><p>拉取mysql镜像后，创建mysql容器</p><pre><code># ~/docker/conf/mysql目录下为mysql配置文件# ~/docker/data/mysql目录下为mysql数据文件# 本机的3306和33060端口分别映射docker内部的3306和33060端口# 数据库root密码为crane# -d后台运行dockerdocker run --name mysql -v ~/docker/conf/mysql:/etc/mysql/conf.d -v ~/docker/data/mysql:/var/lib/mysql -p 3306:3306 -p 33060:33060 -e MYSQL_ROOT_PASSWORD=crane -d mysql</code></pre><p>部分会用到的docker命令：</p><pre><code>docker ps -a查看容器列表docker inspect — 查看关于容器的信息docker kill — 立即停止容器中的主要进程docker stop — 停止正在运行的容器docker start — 启动一个已有的容器docker run — 创建一个新的容器并且启动它docker build — 构建一个镜像</code></pre><p>注：<br>通过主机ip以及映射到主机的3306端口来访问mysql<br>或者使用localhost+ip连接数据库，但是容器化部署项目以后该方式会有问题</p><h2 id="产生DAO代码"><a href="#产生DAO代码" class="headerlink" title="产生DAO代码"></a>产生DAO代码</h2><pre><code>go install ksogit.kingsoft.net/o/stage/v2@latest# v2go get ksogit.kingsoft.net/o/xfx@dev2</code></pre><p>新建一个用户相关 API 的工程：</p><pre><code>mkdir ./src/usercd ./src/userstage init</code></pre><p>然后往 spec&#x2F;user.xidl 文件中追加创建用户的接口定义：</p><pre><code>schema user &#123;    id: string    name: string&#125;schema user_create_request &#123;    name: string&#125;@name &quot;create_user&quot;post /users    . user_create_request    200 user;</code></pre><p>通过运行 stage gen 后，stage 产生了 NewCreateUserService 的代码，我们只要关注这个 service 进行编写相关的业务代码即可。 但是，这个例子中核心模型 user 是需要入库的，因此，我们还需要编写枯燥的 DAO 来辅助 service 对 user 进行相关的持久化操作。我们可以通过stage解决这个问题，stage 产生 DAO 代码是靠 @table 和 @column 两个注解来进行定义的：</p><pre><code>@table &quot;tb_user;ORM(torm)&quot;schema user &#123;    @column &quot;pk;ai&quot;    id: string    name: string&#125;schema user_create_request &#123;    name: string&#125;@name &quot;create_user&quot;post /users    . user_create_request    200 user;</code></pre><p>@table 指示 user 采用 “tb_user” 作为表名。@column 指示了 id 是主键(pk)和自增长(ai)字段。 ORM(torm) 指定了要用的 ORM 库</p><p>stage gen 针对这种定义主要做了三件事：</p><p>一、将 DAO 相关的代码产生到工程目录下的 dao 子目录中。</p><pre><code>dao├── mysql_db.go├── mysql_interface.go├── runtime.go├── mysql_tx.go├── user_batch_insert.go├── user_builder.go├── user_constants.go├── user_delete.go├── user_insert.go├── user_model.go├── user_order.go├── user_select.go├── user_set.go├── user_update.go├── user_where.go└── util.go</code></pre><p>二、产生后端服务对接代码。</p><pre><code>// Code generated by xfx; DO NOT EDIT.package ctximport (    &quot;user/dao&quot;)type backingServices struct &#123;    MysqlDB  *dao.MysqlDB&#125;func newBackingServices(c *ModuleContext) *backingServices &#123;    var mysqlDB *dao.MysqlDB    &#123;        writeWithoutPrepare, err := opts.GetBool(&quot;mysql-db-write-without-prepare&quot;, false)        if err != nil &#123;            panic(err)        &#125;        mysqlDB = dao.NewMysqlDB(            c.AppContext.TORM(&quot;MYSQL&quot;),            dao.WithUniversalSQL(writeWithoutPrepare),        )    &#125;    return &amp;backingServices&#123;        MysqlDB: mysqlDB,    &#125;&#125;</code></pre><p>三、在工程目录中的 env 文件中配置数据库信息。</p><pre><code>export USER_TORM_NAMES=&quot;MYSQL&quot;export USER_DB_MYSQL_HOST=&quot;your IP&quot;export USER_DB_MYSQL_PORT=&quot;3306&quot;export USER_DB_MYSQL_NAME=&quot;test&quot;export USER_DB_MYSQL_USER=&quot;root&quot;export USER_DB_MYSQL_PASSWD=&quot;your password&quot;export USER_DB_MYSQL_PARAMS=&quot;loc=Local&amp;parseTime=True&amp;charset=utf8&quot;export USER_DB_MYSQL_VERBOSE=&quot;false&quot;export USER_DB_MYSQL_MAX_IDLE_CONNS=&quot;30&quot;export USER_DB_MYSQL_MAX_OPEN_CONNS=&quot;150&quot;# export USER_DB_SAMPLE_READ_CIRCUIT_BREAKER=&quot;&quot;# export USER_DB_SAMPLE_WRITE_CIRCUIT_BREAKER=&quot;&quot;# export USER_DB_SAMPLE_READ_RETRY=&quot;&quot;# export USER_DB_SAMPLE_WRITE_RETRY=&quot;&quot;</code></pre><p>最后，可以用 make 进行构建工程了。</p><pre><code>make build</code></pre><p>注：<br>配置env文件需要删除注释…<br>需要在mysql中提前创建对应的数据库<br>ip可以用本机ip访问，也可以使用localhost，容器化部署以后用本机ip</p><h2 id="利用生成的代码进行数据持久化"><a href="#利用生成的代码进行数据持久化" class="headerlink" title="利用生成的代码进行数据持久化"></a>利用生成的代码进行数据持久化</h2><p>Endpoint（端点）是一个网络服务的访问地址，客户端可以通过该地址与服务进行交互。在Web服务中，Endpoint通常指一个URL（Uniform Resource Locator，统一资源定位符），用于描述服务所在的网络位置以及可用的操作。Endpoint可以被认为是一个API的入口点，客户端可以使用它来访问服务并执行各种操作，例如获取数据、执行业务逻辑或进行状态更改。在SOAP协议中，Endpoint通常由一个地址（URL）和一个绑定（Binding）组成，它定义了如何对服务进行调用以及如何进行消息传输。在RESTful服务中，Endpoint通常由HTTP方法和URL组成，用于定义可以对资源执行的操作。</p><p>我们在创建User对象的时候，把name初始化</p><pre><code>func NewCreateUserService(moduleCtx *ctx.ModuleContext) CreateUserFunc &#123;    return func(ctx context.Context, request *CreateUserRequest) (*CreateUserResponse, error) &#123;        //验证标签合法        err := validator.Validate(request)        if err != nil &#123;            return nil, err        &#125;        out := NewCreateUserResponse()        out.Name = request.Name        return &amp;out, nil    &#125;&#125;</code></pre><p>我们在Endpoint中调用数据库代码，将id和user持久化到数据库。</p><pre><code>func (h *CreateUser) Endpoint(app xfx.App) endpoint.Endpoint &#123;    callService := srv.NewCreateUserService(ctx.Get(app))    return func(w http.ResponseWriter, r *http.Request) error &#123;        w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)        in, err := parseCreateUserRequest(w, r)        if err != nil &#123;            return rw.WriteError(w, r, el.Adapt(err))        &#125;        in.EscapeStrings()        out, err := callService(r.Context(), in)        if err != nil &#123;            return rw.WriteError(w, r, err)        &#125;        moduleCtx := ctx.Get(app)        db:=moduleCtx.MysqlDB        db.User().Insert(&amp;dao.UserSet&#123;            Name:dao.String(out.Name),        &#125;).Exec(context.Background())        userBuilder :=db.User().Select().Where(func(b *dao.UserWhereBuilder) &#123;            b.IdGT(0)        &#125;)        userid,_ := userBuilder.Count(context.Background())        out.Id =fmt.Sprintf(&quot;%d&quot;, userid)        return rw.WriteJson(w, 200, out)    &#125;&#125;</code></pre><p>注：<br>term的使用方式<a href></a></p><h2 id="将该服务打包成镜像"><a href="#将该服务打包成镜像" class="headerlink" title="将该服务打包成镜像"></a>将该服务打包成镜像</h2><p>配置Dockerfile文件</p><pre><code>ARG GIT_BRANCHARG BASE_IMAGE=hub-mirror.wps.cn/priopen/golang-nodejs-builder:1.18.7-alpine-v3ARG USERARG PASSWORDFROM $&#123;BASE_IMAGE&#125; as golang-build# 根据CI配置克隆目录修改PROJECT_NAME参数ARG PROJECT_NAME=userARG APP_NAME=userENV PROJECT_NAME=$&#123;PROJECT_NAME&#125;ENV APP_NAME=$&#123;APP_NAME&#125;ENV GIT_BRANCH=$&#123;GIT_BRANCH&#125;ENV TERM=xtermRUN export GONOSUMDB=*.kingsoft.netRUN export GOPRIVATE=*.kingsoft.netRUN git config --global --add url.&quot;git@ksogit.kingsoft.net:&quot;.insteadof &quot;https://ksogit.kingsoft.net/&quot;RUN git config --global credential.helper cacheRUN git config --global user.name &quot;xxxxxxxxxx&quot;RUN git config --global user.password &quot;xxxxxxxxxxxxxx&quot;RUN git config --global user.email &quot;xxxxxx@kingsoft.com&quot;# 指定当前工作目录为 /opt/$&#123;PROJECT_NAME&#125;/$&#123;APP_NAME&#125;WORKDIR /opt/$&#123;PROJECT_NAME&#125;# ADD ./docker /optCOPY . /opt/$&#123;PROJECT_NAME&#125;RUN echo http://mirrors.aliyun.com/alpine/v3.15/main/ &gt; /etc/apk/repositories &amp;&amp; \    echo http://mirrors.aliyun.com/alpine/v3.15/community/ &gt;&gt; /etc/apk/repositoriesRUN source /opt/$PROJECT_NAME/env# 执行 make 命令生成代码，并进行构建RUN /usr/local/go/bin/go build -o user -v -ldflags &quot; \    -X user/cmds.GitHash=$(shell git rev-parse HEAD 2&gt; /dev/null) \    -X user/cmds.BuildTime=$(shell date &quot;+%Y-%m-%dT%H:%M:%SZ&quot;)&quot;FROM hub-mirror.wps.cn/priopen/golang-runner:1.17.13-alpine# 根据CI配置克隆目录修改PROJECT_NAME参数ENV PROJECT_NAME=userENV APP_NAME=userWORKDIR /opt/$&#123;PROJECT_NAME&#125;COPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/docker ./dockerCOPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/$&#123;APP_NAME&#125; ./COPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/env ./RUN chmod +x ./docker/start.shRUN chmod +x ./docker/livenessProbe.shRUN chmod +x ./docker/readinessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/docker/livenessProbe.sh /usr/local/bin/livenessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/docker/readinessProbe.sh /usr/local/bin/readinessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/env /usr/local/bin/envRUN /bin/bash -c &quot;source /opt/$&#123;PROJECT_NAME&#125;/env&quot;EXPOSE 80 8081ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;,&quot;/opt/$&#123;PROJECT_NAME&#125;/docker/start.sh&quot;]</code></pre><p>配置完Dockerfile以后，使用</p><pre><code>docker build -t user .</code></pre><p>构建一个名字为user的镜像,构建完成后，由该镜像构建一个容器</p><pre><code>docker run user -p 8080:8080</code></pre><p>注：<br>构建过程中需要export GONOSUMDB&#x3D;<em>.kingsoft.net  export GOPRIVATE&#x3D;</em>.kingsoft.net  否则会因为权限问题无法拉取xfx&#x2F;o&#x2F;wps 的仓库。<br>需要更新一下env配置，RUN &#x2F;bin&#x2F;bash -c “source &#x2F;opt&#x2F;${PROJECT_NAME}&#x2F;env” 否则运行会产生错误</p><h2 id="测试服务是否启动成功"><a href="#测试服务是否启动成功" class="headerlink" title="测试服务是否启动成功"></a>测试服务是否启动成功</h2><p>我们利用postman 来发送post请求<br><a href="https://imgse.com/i/p9AquZV"><img src="https://s1.ax1x.com/2023/04/21/p9AquZV.png" alt="p9AquZV.png"></a><br>这里需要解决跨域请求的问题，我们要在headers中加入<br><a href="https://imgse.com/i/p9AqdIO"><img src="https://s1.ax1x.com/2023/04/21/p9AqdIO.png" alt="p9AqdIO.png"></a></p><p>最终我们启动mysql服务，然后启动user服务<br><a href="https://imgse.com/i/p9AqyQA"><img src="https://s1.ax1x.com/2023/04/21/p9AqyQA.png" alt="p9AqyQA.png"></a><br>测试最终的执行效果,可以看到我们已经将内容持久化数据库并且id自增存储，返回的json和存储内容一致。<br><a href="https://imgse.com/i/p9AqhFS"><img src="https://s1.ax1x.com/2023/04/21/p9AqhFS.png" alt="p9AqhFS.png"></a><br><a href="https://imgse.com/i/p9AqIzj"><img src="https://s1.ax1x.com/2023/04/21/p9AqIzj.png" alt="p9AqIzj.png"></a><br><a href="https://imgse.com/i/p9AOLPU"><img src="https://s1.ax1x.com/2023/04/21/p9AOLPU.png" alt="p9AOLPU.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes介绍</title>
      <link href="/p/39432f30.html"/>
      <url>/p/39432f30.html</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes介绍"><a href="#kubernetes介绍" class="headerlink" title="kubernetes介绍"></a>kubernetes介绍</h1><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><p>Kubernetes 为你提供：<br>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。<br>• 存储编排<br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。<br>• 自动部署和回滚<br>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。<br>• 自动完成装箱计算<br>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来为容器分配资源。<br>• 自我修复<br>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。<br>• 密钥与配置管理<br>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TB级数据排序</title>
      <link href="/p/587dffa2.html"/>
      <url>/p/587dffa2.html</url>
      
        <content type="html"><![CDATA[<h1 id="TB级数据排序"><a href="#TB级数据排序" class="headerlink" title="TB级数据排序"></a>TB级数据排序</h1><p>这个经典的算法问题我们一般称之为外部排序，这里的“外”指的其实就是外部存储的意思<br>读写较慢的外存，相比快速但昂贵的内存而言，有着更低廉的成本，通常是硬盘，它可以存放更大的数据。当我们不能直接在内存中进行排序，而需要借助外存去处理极大量数据的排序时，就需要使用外部排序算法了</p><p>如果遇到这样的面试题，首先可以来向面试官确认一下已有的硬件环境，比如面试官可能会告诉你，你现在有 1GB 的内存可用。那么我们知道整个 1TB 的文件，至少要读 1024次才能遍历一遍，所以直接在内存里排序显然是不现实的。</p><p>但是文件其实是可以一部分一部分读的，如果内存中一次放不下全部的数据，也许我们可以将文件分成若干段，分别读入内存中，并采用常见的内排序算法（比如堆排序），对这段可以在内存中存储的段落进行排序；得到若干个有序的文件段后，最后通过一些合并的方式，得到整体有序的文件.当然在这个过程里会有大量的中间结果，比如那些有序的文件片段，这些我们都需要借助外存存储，这个思路就是最常见的一种外部排序的方式。</p><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>基于归并思想的外排过程整体分为两个阶段：</p><p><strong>部分排序阶段</strong><br>我们根据内存大小，将待排序的文件拆成多个部分，使得每个部分都是足以存入内存中的。然后选择合适的内排序算法，将多个文件部分排序，并输出到容量可以更大的外存临时文件中，每个临时文件都是有序排列的，我们将其称之为一个“顺段”。</p><p><strong>归并阶段</strong><br>我们对前面的多个“顺段”进行合并，思想和归并排序其实是一样的。以 2 路归并为例，每次都将两个连续的顺段合并成一个更大的顺段。因为内存限制，每次可能只能读入两个顺段的部分内容，所以我们需要一部分一部分读入，在内存里将可以确定顺序的部分排列，并输出到外存里的文件中，不断重复这个过程，直至两个顺段被完整遍历。这样经过多层的归并之后，最终会得到一个完整的顺序文件</p><p>假设现在有含有 1000 个记录的文件，而内存最多只能读取 100 个记录。那么我们要做的第一步就是先把 1000 个记录拆成十个文件，每个文件有 100 个记录，读入后在内存中排序得到 10 个有序的临时文件，并输出到外存也就是硬盘中.然后我们进行多次归并操作，每次都把相邻的文件合并。在这个例子中可以看到只需要进行 4 轮归并，就得到了一个最终有序的文件。</p><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>那整个过程里，运行时间主要和哪些因素有关呢？在第一个阶段部分排序中，由于内存可以装下每个顺段的所有元素，所以几种主流的O(nlogn) 的算法都是可以的，其中快速排序在大部分场景下是最快的，因此我们可以首选快速排序。<br>比较复杂的是归并阶段。因为内存不足以装下所有需要排序的元素，所以 O(nlogn) 的堆排和快排都已经没办法被应用在外排的场景中了，但基于分治思想的归并排序却依然可以很好地发挥作用。<br>而且相比很多其他排序方式比如选择排序、冒泡排序，归并排序 O(nlogn) 的复杂度已经是理论上相当好的复杂度了。当然在一些特定场景下我们也可以用一些线性排序算法比如桶排序来解决外部排序问题。但是和内排中的归并排序不同，外部排序场景下，我们还有个非常大的时间消耗就是 IO，也就是输入输出。<br>相比内存中的读写操作，在磁盘中的读写是一个慢得多的过程，两者之间可能有千倍以上的时间开销差距。所以考虑外排效率时，非常重要的一点就是我们要尽量减少从磁盘中读取数据的耗时，而这主要关系要访问多少次外存。每一层我们读取外存的数据总量其实是一样的，本质上就是将所有的数据都遍历一遍。而内存大小是一样的，所以每一层中读取外存的次数也就是一样的，那么显然关系我们读取次数的多少主要就取决于所需归并的层数了。因此，我们要做的事情就是让归并的层数<br>越低越好。</p><h3 id="如何降低归并层数"><a href="#如何降低归并层数" class="headerlink" title="如何降低归并层数"></a>如何降低归并层数</h3><p>我们先算出归并层数，以 2 路归并为例，每次合并两个连续的顺段，如果上一层有 n 个顺段，到下一层就会有 n&#x2F;2 个顺段，每一层的顺段都会减少一半，直至只剩一个顺段，也就是需要的排序结果。因而，假设初始一共有 n 个顺段，那么我们大致需要 log2n 层。同样的道理，如果进行 k 路归并，每一层的顺段数量都会变成上一层的 1&#x2F;k，所以就大概只需要 logk(n) 层即可完成整个归并。<br>为了增加归并路数，也就是尽量增加 k。另外为了降低初始 n 个顺段的数量，我们会做的事情也很简单，就是在第一次进行逐段内排序的时候尽可能多地将数据读入内存中并进行内排。但是增加 k 的大小，其实也会导致每次归并的时候合并的成本变大，一个显著的问题就是在 k 路归并中，我们需要从 k 个元素中选择出最小的元素，代价比 2 路归并的更高。如果<br>用最暴力的方式，遍历 k 个元素，每次选择最小的元素的过程将产生 O(k) 的时间复杂度，这一定程度上会抵消前面通过增加 k 减少磁盘 IO 所带来的时间提升。</p><p>但是我们仔细想想这个问题，选择 k 个元素中的最小元素，显然有优于暴力遍历 O(k) 复杂度的算法。堆就可以解决这个问题。而败者树，则是解决从 k 个元素中选取最小元素并可以动态更新的另一种方法，也是更广泛运用于多路归并中的算法，我们来学习一下它的思路。</p><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树也被称为，淘汰赛树，也就是 Tournament Tree，思想来自体育比赛。我们知道在淘汰赛中，每一场比赛都有两个参与者，其中胜者可以晋级下一轮。整体可以画成一颗树的形状.败者树算法就是基于这一思想实现的，我们用叶子节点存储所有待比较的元素，对叶子结点两两比赛，在它们共同的父节点中存储失败者；然后对获胜者节点再两两比较，得到更上一层的败者，取出胜者继续往上比较，这个过程和归并的思路其实也是比较相似的；这样一层一层往上比较，最后就可以得到一颗锦标赛状的树。<br>因为除了叶子结点外的每一层的父节点存储的都是其子节点中的失败者，所以我们称其为败者树。根节点我们会稍微做一点特别的处理，除了在根结点存储失败者，同时，我们在根节点之上会悬挂上整棵树的最终获胜者<br>和堆一样，我们也会需要对败者树进行类似于出队的操作；</p><p><img src="https://s1.ax1x.com/2023/07/07/pCc5xUJ.png" alt="pCc5xUJ.png"></p><p>和堆一样，我们也会需要对败者树进行类似于出队的操作；在上面的例子中，就是我们需要将 1 从败者树中取出，寻找下一个最小的元素。这里有两种情况，一种是我们取出 1 之后，用一个新的元素替代 1，另一种就是取出 1 之后不再添加新的元素，分别对应某一路元素被取出之后仍有元素未取完，和该路元素已经全部取出的情况。在这两种情况中，我们其实都只需要对整个树重新比赛一次即可，只是在第二种情况里，我们会用一个无限大的数字替换 1，因为无限大的数字一定不会在这次重赛中胜出</p><p>假设取出 1 之后，我们用 8 来替换 1 原来的位置，由于每个父节点存储的都是两个子节点中的失败者，所以我们只要用更新的值和父节点的值比较，也就是和之前两个子节点中的失败者比较。因为原来的获胜者已经被取走了，这里的父节点现在存储的其实就是这颗子树中原来的亚军，如果我们要看这次新来的选手能否能成为新的冠军，只需要和原来的亚军进行一次比较即可；当然这次比较结束后，两者中的胜者还需要到更上一层继续比较。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>我们假设一共有 k 个节点。首先，初始化的过程需要花费 O(k) 的时间，因为对于 k 个子节点，一共只需要进行 k-1 场比赛即可完成淘汰赛。然后在归并排序的每一次合并中，只需要进行 replay 操作，从新元素到根路径上逐一重赛。在每一层中，只需要进行一次比较。由于树是平衡的，从叶子结点到根路径仅包含O(logk) 元素。所以，总的时间复杂度为 O(klog k) 。</p><p>现在有了败者树的加持，多路归并排序就可以比较高效地解决外部排序的问题了。对于1TB 任意文本的排序问题，大致思路就是：</p><ul><li>先用内排序算法，尽可能多的加载源文件，将其变成 n 个有序顺段。</li><li>在内存有限的前提下每 k 个文件为一组，每次流式地从各个文件中读取一个单词，借助败者树选出字典序最低的一个，输出到文件中，这样就可以将 k 个顺段合并到一个顺段中了；反复执行这样的操作，直至所有顺段被归并到同一个顺段。</li></ul><p>看起来我们每次从文件中只读取了一个单词，但操作系统在读文件的时候是会按页为单位读取并缓存下来的，所以某一次磁盘访问之后的若干次访问，其实都会直接命中 cache，也就是说，并不是每次从败者树中取出元素时都会真的产生磁盘 IO，</p><p>当然在工业级实现中肯定还是有很多优化空间的。比如待合并的文件比较大的时候，我们可以利用二分搜索对文件进行分段，并行地合并</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/p/37489.html"/>
      <url>/p/37489.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法及其时间和空间复杂度"><a href="#十大排序算法及其时间和空间复杂度" class="headerlink" title="十大排序算法及其时间和空间复杂度"></a>十大排序算法及其时间和空间复杂度</h1><p><img src="/p/37489.htm/TenSort.png" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>算法描述：</p><ul><li>⽐较相邻的元素。如果第⼀个⽐第⼆个⼤，就交换它们两个；</li><li>对每⼀对相邻元素作同样的⼯作，从开始第⼀对到结尾的最后⼀对，这样在最后的元素应该会是最⼤的数；</li><li>针对所有的元素重复以上的步骤，除了最后⼀个；</li><li>重复步骤 1~3，直到排序完成。</li></ul><p>代码如下：</p><pre><code>void BubbleSort(std::vector&lt;int&gt; &amp;nums, int n)&#123;     if (n &lt;= 1) return;    bool is_swap;    for (int i = 1; i &lt; n; ++i)    &#123;         //设定⼀个标记，若为false，则表示此次循环没有进⾏交换，也就是待排序列已经有序，排序已经完成。        is_swap = false;        for (int j = 1; j &lt; n - i + 1; ++j)         &#123;             if (nums[j] &lt; nums[j-1])            &#123;                //表示有数据交换                std::swap(nums[j], nums[j-1]); is_swap = true;            &#125;        &#125;        //没有数据交换，提前退出        if (!is_swap) break;    &#125;&#125;</code></pre><p>冒泡排序空间复杂度为O(1)，是⼀种原地排序算法。<br>冒泡排序的最好情况时间复杂度O(n)、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>冒泡排序是一种稳定的排序算法。</p><h2 id="插⼊排序"><a href="#插⼊排序" class="headerlink" title="插⼊排序"></a>插⼊排序</h2><p>算法描述：分为已排序和未排序的区间，初始已排序区间只有⼀个元素–就是数组第⼀个；遍历未排序的每⼀个元素在已排序区间⾥找到合适的位置插⼊并保证数据⼀直有序。</p><p>代码如下：</p><pre><code>void InsertSort(std::vector&lt;int&gt; &amp;nums,int n) &#123;     if (n &lt;= 1) return;    for(int i = 0; i &lt; n; ++i) &#123;        for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums [j-1]; --j) &#123;            std::swap(nums[j],nums[j-1]);        &#125;    &#125;&#125;</code></pre><p>插入排序空间复杂度为O(1)，是⼀种原地排序算法。<br>插入排序的最好情况时间复杂度 O(n)、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>插入排序是一种稳定的排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最⼩的元素，将其放到已排序区间的末尾。</p><pre><code>void SelectSort(std::vector&lt;int&gt; &amp;nums, int n) &#123;     if (n &lt;= 1) return;    int mid;    for (int i = 0; i &lt; n - 1; ++i)    &#123;         mid = i;        for (int j = i + 1; j &lt; n; ++j) &#123;             if (nums[j] &lt; nums[mid])             &#123;                mid = j;            &#125;        &#125;        std::swap(nums[mid],nums[i]);    &#125;&#125;</code></pre><p>选择排序空间复杂度为O(1)，是⼀种原地排序算法。<br>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>选择排序是一种不稳定的排序算法。</p><p><strong>【时间,空间复杂度&#x2F;是否稳定？】</strong></p><p>那选择排序是稳定的排序算法吗？答案是否定的，选择排序是⼀种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最⼩值，并和前⾯的元素交换位置，这样破坏了稳定性.<br>【思考】冒泡排序和插⼊排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插⼊排序要⽐冒泡排序更受欢迎呢？<br>【思路】冒泡排序不管怎么优化，元素交换的次数是⼀个固定值，是原始数据的逆序度。插⼊排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，⽽插⼊排序只需要 1 个。把执⾏⼀个赋值语句的时间粗略地计为单位时间，处理相同规模的数，插⼊排序⽐冒泡排序减少三倍的单位时间！</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><strong>算法描述：</strong><br>先找到⼀个枢纽；在原来的元素⾥根据这个枢纽划分;⽐这个枢纽⼩的元素排前⾯；⽐这个枢纽⼤的元素排后⾯；两部分数据依次递归排序下去直到最终有序。</p><p>代码如下：</p><pre><code>void QuickSort(std::vector&lt;int&gt; &amp;nums,int l,int r)&#123;     if (l + 1 &gt;= r) return;    int first = l, last = r - 1 ,key = nums[first];     while (first &lt; last)    &#123;        while (first &lt; last &amp;&amp; nums[last] &gt;= key) last--;//右指针 从右向左扫描 将⼩于piv的放        到左边        nums[first] = nums[last];        while (first &lt; last &amp;&amp; nums[first] &lt;= key) first++;//左指针 从左向右扫描 将⼤于piv的        放到右边        nums[last] = nums[first];    &#125;    nums[first] = key;//更新piv    quick_sort(nums, l, first);//递归排序 //以L为中间值，分左右两部分递归调⽤    quick_sort(nums, first + 1, r);&#125;</code></pre><p>非递归算法：</p><pre><code>//划分算法int Partition( int a[], int low, int high )&#123;    //假设每次都以第一个元素作为枢轴值，进行一趟划分：    int pivot = a[low];        while( low&lt;high )    &#123;        while( low&lt;high &amp;&amp; a[high]&gt;=pivot )        --high;        a[low] = a[high];  //停下来做交换         while( low&lt;high &amp;&amp; a[low]&lt;=pivot )        ++low;        a[high] = a[low];  //停下来做交换     &#125;        a[low] = pivot;  //pivot的最终落点     return low;&#125;//非递归快排void QuickSort(int a[], int left, int right)&#123;    //手动利用栈来存储每次分块快排的起始点    //栈非空时循环获取中轴入栈    stack&lt;int&gt; s;    if( left&lt;right )    &#123;        int boundary = Partition(a,left,right);                if( boundary-1&gt;left ) //确保左分区存在         &#123;            //将左分区端点入栈             s.push(left);            s.push(boundary-1);        &#125;        if( boundary+1&lt;right ) //确保右分区存在         &#123;            s.push(boundary+1);            s.push(right);        &#125;                while( !s.empty() )        &#123;            //得到某分区的左右边界             int r = s.top();            s.pop();              int l = s.top();            s.pop();                        boundary = Partition(a,l,r);            if( boundary-1&gt;l ) //确保左分区存在             &#123;                 //将左分区端点入栈                 s.push(l);                s.push(boundary-1);            &#125;            if( boundary+1&lt;r ) //确保右分区存在             &#123;                s.push(boundary+1);                s.push(r);            &#125;        &#125;    &#125;&#125;</code></pre><p>快速排序空间复杂度为O(1)，是⼀种原地排序算法。<br>快速排序的最好情况时间复杂度 O(nlogn)、最坏情况 O(n^n)平均情况时间复杂度都为 O(nlogn)。<br>快速排序是一种不稳定的排序算法。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法描述：归并排序是⼀个稳定的排序算法，归并排序的时间复杂度任何情况下都是    O(nlogn)，归并排序不是原地排序算法<br>⽤两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第⼀个元素。⽐较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;&#x3D;A[j]，我们就把 A[i] 放⼊到临时数组 tmp，并且 i 后移⼀位，否则将 A[j] 放⼊到数组 tmp，j 后移⼀位。</p><p>代码如下：<br>    void mergeCount(int a[],int L,int mid,int R)<br>    {<br>        int *tmp &#x3D; new int[L+mid+R];<br>        int i&#x3D;L;<br>        int j&#x3D;mid+1; int k&#x3D;0;<br>        while( i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;R )<br>        {<br>            if(a[i] &lt; a[j])<br>                tmp[k++] &#x3D; a[i++];<br>            else<br>                tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F;判断哪个⼦数组中有剩余的数据<br>        while( i&lt;&#x3D;mid )<br>        {<br>            tmp[k++] &#x3D; a[i++];<br>        }<br>        while( j&lt;&#x3D;R)<br>        {<br>            tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F; 将 tmp 中的数组拷⻉回 A[p…r]<br>        for(int p&#x3D;0; p&lt;k; ++p){<br>            a[L+p] &#x3D; tmp[p]; delete tmp;<br>        }<br>    }<br>    void mergeSort(int a[],int L,int R) {<br>        &#x2F;&#x2F;递归终⽌条件 分治递归<br>        &#x2F;&#x2F; 将 A[L…m] 和 A[m+1…R] 合并为 A[L…R]<br>        if( L&gt;&#x3D;R ) { return; } int mid &#x3D; L + (R - L)&#x2F;2; mergeSort(a,L,mid); mergeSort(a,mid+1,R); mergeCount(a,L,mid,R);<br>    }</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>算法描述：利⽤堆这种数据结构所设计的⼀种排序算法。堆积是⼀个近似完全⼆叉树的结构，并同时满⾜堆积的性质：即⼦结点的键值或索引总是⼩于（或者⼤于）它的⽗节点。堆排序可以⽤到上⼀次的排序结果，所以不像其他⼀般的排序⽅法⼀样，每次都要进⾏n-1次的⽐较，复杂度为O(nlogn)。<br>算法步骤：<br>1、利⽤给定数组创建⼀个堆H[0..n-1]（我们这⾥使⽤最⼩堆），输出堆顶元素<br>2、以最后⼀个元素代替堆顶，调整成堆，输出堆顶元素<br>3、把堆的尺⼨缩⼩ 1<br>4、重复步骤 2，直到堆的尺⼨为 1<br>建堆：将数组原地建成⼀个堆，不借助额外的空间，采⽤从上往下的堆化（对于完全⼆叉树来说，下标是 n&#x2F;2+1到n的节点都是叶⼦节点，不需要堆化）。<br>排序：”删除堆顶元素“：当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后在通过堆化的⽅法，将剩下的n-1个元素重新构建成堆，堆化完成之后，在取堆顶的元素，放到下标为 n-1 的位置，⼀直重复这个过程，直到最后 堆中只剩下标 1 的⼀个元素。<br>优点：O(nlogn)，原地排序，最⼤的特点：每个节点的值⼤于等于(或⼩于等于)其⼦树节点缺点：相⽐于快排，堆排序数据访问的⽅式没有快排友好；数据的交换次数要多于快排。<br>    void HeapSort(int a[], int n)<br>    {<br>        for(int i&#x3D;n&#x2F;2; i&gt;&#x3D;1; –i)<br>        {<br>            Heapify(a, n, i);<br>        }<br>        int k &#x3D; n;<br>        while( k &gt; 1)<br>        {<br>            swap(a[1],a[k]);<br>            –k;<br>            Heapify(a,k,1);<br>        }<br>    }</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>算法描述：将数组分到有限数量的桶⾥。每个桶再个别排序（有可能再使⽤别的排序算法或是以递归⽅式继续使⽤ 桶排序进⾏排序）。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>扩展：如果在⾯试中有⾯试官要求你写⼀个   O(n)   时间复杂度的排序算法，可不要傻乎乎的说这不可能！虽然前⾯基于⽐较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要 满⾜⼀定的范围的整数，⽽且计数排序需要⽐较多的辅助空间。<br>算法描述：其基本思想是，⽤待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序 序列。<br>假设有 8 个考⽣，分数在 0 到 5 分之间。这 8 个考⽣的成绩我们放在⼀个数组 A[8]中，它们分别是：2，5，3， 0，2，3，0，3。<br>考⽣的成绩从 0 到 5 分，我们使⽤⼤⼩为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考<br>⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到       C[6]的值。</p><p>这是我们的数组，从图中可以看出，分数为 3 分的考⽣有 3 个，⼩于 3 分的考⽣有 4 个，所以，成绩为 3 分的考<br>⽣在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。<br>那我们如何快速计算出，每个分数的考⽣在有序数组中对应的存储位置呢？<br>我们对 C[6] 数组顺序求和，C[6]存储的数据就变成了下⾯这样⼦。C[k]⾥存储⼩于等于分数 k 的考⽣个数。</p><p>我们从后到前依次扫描数组 A。⽐如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到⽬前为⽌，包括⾃⼰在内，分数⼩于等于 3 的考⽣有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中<br>下标为 6 的位置）。当 3 放⼊到数组 R 中后，⼩于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。<br>以此类推，当我们扫描到第 2 个分数为 3 的考⽣的时候，就会把它放⼊数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从⼩到⼤有序排列的了。<br>注意：计数排序只能⽤在数据范围不⼤的场景中，如果数据范围 k ⽐要排序的数据 n ⼤很多，就不适合⽤计数排序了。⽽且，计数排序只能给⾮负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对⼤⼩的情况下，   转化为⾮负整数。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独⽴的“位”来⽐较，⽽且位之间有递进的关系，    如果 a 数据的⾼位⽐ b 数据⼤，那剩下的低位就不⽤⽐较了。除此之外，每⼀位的数据范围不能太⼤，要可以⽤线性排序算法来排序，否则，基数排序的时间复杂度就⽆法做到 O(n) 了。<br>基数排序相当于通过循环进⾏了多次桶排序。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>算法描述：通过将⽐较的全部元素分为⼏个区域来提升插⼊排序的性能。这样可以让⼀个元素可以⼀次性地朝最终 位置前进⼀⼤步。然后算法再取越来越⼩的步⻓进⾏排序，算法的最后⼀步就是普通的插⼊排序，但是到了这步， 需排序的数据⼏乎是已排好的了。</p><pre><code>template&lt;typename T&gt;void shell_sort(T array[], int length) &#123;    int h = 1;    while (h &lt; length / 3) &#123;        h = 3 * h + 1;    &#125;    while (h &gt;= 1) &#123;        for (int i = h; i &lt; length; i++) &#123;            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;                std::swap(array[j], array[j - h]);            &#125;        &#125;        h = h / 3;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/p/ea4681d0.html"/>
      <url>/p/ea4681d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h1><ul><li><p>Pre-Order Traversal ： 到达一个节点后，即刻输出该节点的值，并继续遍历其左右子树。                                VLR</p></li><li><p>In-Order Traversal  ：   到达一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。LVR</p></li><li><p>Post-Order Traversal:   到达一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。                          LRV</p></li></ul><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p><strong>递归实现</strong></p><pre><code>void preOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void preOrderTraverse2(node *root) &#123;    LinkedList&lt;node*&gt; stack = new LinkedList&lt;&gt;();    node *pNode = root;    while (pNode != nullptr || !stack.isEmpty()) &#123;        if (pNode != nullptr) &#123;            System.out.print(pNode.val+&quot;  &quot;);            stack.push(pNode);            pNode = pNode.left;        &#125;         else &#123; //pNode == nullptr &amp;&amp; !stack.isEmpty()            nodeNode node = stack.pop();            pNode = node.right;        &#125;    &#125;&#125;</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if (root == nullptr)        return;    node *p = root;    stack&lt;node*&gt;s;    while (p != nullptr || !s.empty())    &#123;        while (p!=nullptr)        &#123;            s.push(p);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;             p = s.top();            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;//第二次遇见的时候输出            s.pop();            p = p-&gt;rchild;        &#125;    &#125;&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>递归实现</strong></p><pre><code>void postOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);    printf(&quot;%d\n&quot;,root-&gt;data);&#125;</code></pre><p><strong>非递归实现</strong><br>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问。其右孩子还未被访问,所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是 否是第一次出现在栈顶。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == nullptr)        return;    stack&lt;node*&gt;s;    Binode p = root;    node tmp;    while (p!=nullptr || !s.empty())    &#123;        while (p != nullptr)//沿左子树一直往下搜索，直至出现没有左子树的结点        &#123;            node btn = (node)malloc(sizeof(Node));            btn-&gt;btnode = p;            btn-&gt;isfirst = true;            s.push(btn);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;            tmp = s.top();            s.pop();            if (tmp-&gt;isfirst == true)//第一次出现在栈顶            &#123;                tmp-&gt;isfirst = false;                s.push(tmp);                p = tmp-&gt;btnode-&gt;rchild;            &#125;            else//第二次出现在栈顶            &#123;                cout &lt;&lt; tmp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;;                p = nullptr;            &#125;        &#125;    &#125;&#125;</code></pre><p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == nullptr)        return;    stack&lt;node*&gt;s;    node* cur = root, *pre = nullptr;    s.push(root);    while (!s.empty())    &#123;        cur = s.top();        if ((cur-&gt;lchild == nullptr&amp;&amp;cur-&gt;rchild == nullptr) ||            ((pre == cur-&gt;lchild || pre == cur-&gt;rchild) &amp;&amp; pre != nullptr))        &#123;            cout &lt;&lt; cur-&gt;data &lt;&lt; &quot; &quot;;            s.pop();            pre = cur;        &#125;        else        &#123;            if (cur-&gt;rchild != nullptr)                s.push(cur-&gt;rchild);            if (cur-&gt;lchild != nullptr)                s.push(cur-&gt;lchild);        &#125;    &#125;&#125;</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><strong>非递归遍历</strong></p><pre><code>void layerOrderTraverse(node* root)&#123;    queue&lt;node*&gt; q;    q.push(root);    while(!q.empty())&#123;        node*now=q.front();        q.pop();        cout&lt;&lt; now-&gt;data&lt;&lt;endl;        if(now-&gt;lchild!=nullptr)q.push(now-&gt;lchild);        if(now-&gt;rchild!=nullptr)q.push(now-&gt;rchild);    &#125;&#125;</code></pre><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><pre><code>void DFS(node* root)&#123;    Stack&lt;node*&gt; nodeStack;    nodeStack.push(root);    while(!nodeStack.empty())    &#123;        root=nodeStack.top();        printf(format, root-&gt;data);        nodeStack.pop();        if(root-&gt;rChild)        &#123;            nodeStack.push(root-&gt;rChild);        &#125;        if(root-&gt;lChild)        &#123;            nodeStack.push(root-&gt;lChild);        &#125;            &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带权并查集</title>
      <link href="/p/56030.html"/>
      <url>/p/56030.html</url>
      
        <content type="html"><![CDATA[<h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><h2 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h2><p>记录当前并查集集合内的节点个数，简单来说：就是在朴素版的并查集的基础上维护多一个信息size，从而记录当前并查集集合内的节点个数<br>此并查集一般作用于计算连通块中点的数量的题目</p><h3 id="定义并查集-amp-初始化："><a href="#定义并查集-amp-初始化：" class="headerlink" title="定义并查集&amp;初始化："></a>定义并查集&amp;初始化：</h3><pre><code>int p[N], _size[N];for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;        size[i] = 1;&#125;</code></pre><p>p[]存储的是每个点的祖宗节点</p><p>size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</p><h3 id="并查集的查询操作："><a href="#并查集的查询操作：" class="headerlink" title="并查集的查询操作："></a>并查集的查询操作：</h3><p>int find(int x)<br>{<br>    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);</p><pre><code>return p[x];</code></pre><p>}</p><h3 id="并查集的合并操作："><a href="#并查集的合并操作：" class="headerlink" title="并查集的合并操作："></a>并查集的合并操作：</h3><p>bool merge(int x, int y)<br>{<br>    x &#x3D; find(x);<br>    y &#x3D; find(y);</p><pre><code>if (x == y) return false;_size[x] += _size[y];p[y] = x;return true;</code></pre><p>}<br>因为是合并集合，固然也需要将原来集合内的节点总个数加到新合并的集合中</p><h2 id="维护dist的并查集"><a href="#维护dist的并查集" class="headerlink" title="维护dist的并查集"></a>维护dist的并查集</h2><p>简单来说：就是在朴素版的并查集的基础上维护多一个信息dist，从而记录当前节点到根节点之间的距离</p><h3 id="定义并查集-amp-初始化：-1"><a href="#定义并查集-amp-初始化：-1" class="headerlink" title="定义并查集&amp;初始化："></a>定义并查集&amp;初始化：</h3><pre><code>int p[N], _dist[N];for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;        _dist[i] = 0;&#125;</code></pre><p>p[]存储的是每个点的祖宗节点</p><p>d[x]存储的是编号为x的节点到p[x]（祖宗节点）的距离</p><h3 id="并查集的查询操作：-1"><a href="#并查集的查询操作：-1" class="headerlink" title="并查集的查询操作："></a>并查集的查询操作：</h3><pre><code>int find(int x)&#123;    if (p[x] != x)    &#123;        int root = find(p[x]);                _dist[x] += _dist[p[x]];                p[x] = root;    &#125;        return p[x];&#125;</code></pre><p>在路径压缩的过程中，我们需要顺带计算此节点距离祖宗节点的距离，此时我们便需要提前记录每一次递归（即寻找到父亲节点）前的节点的编号<br>即记录下当前所操作的节点编号，这样就能在递归回溯的时候，对记录下的节点进行距离根节点的距离的更新<br>从而可以达到借助路径压缩的优化达到不仅仅是对路径节点的优化，也达到了对dist的优化，即一次查询即可更新路径上所有的点到根节点的距离</p><h3 id="并查集的合并操作：-1"><a href="#并查集的合并操作：-1" class="headerlink" title="并查集的合并操作："></a>并查集的合并操作：</h3><p>bool merge(int x, int y)<br>{<br>    x &#x3D; find(x);<br>    y &#x3D; find(y);</p><pre><code>if (x == y) return false;_dist[y] += _dist[x] + 1;p[y] = x;return true;</code></pre><p>}</p><p>为什么y集合合并到x集合，只需要更新y集合的根节点距离新集合根节点的距离，而不需要将y集合内的所有节点距离新根节点的距离全部更新呢？<br>这是因为：只要后续操作中，需要对原y集合内的某个节点进行查询操作的时候，查询操作便会对此点所在路径上的所有点全部进行数据的更新，即相当于原y集合内的节点的p[x]和_dist[x]都会更新为指向合并后新的根节点和距离新根节点的距离<br>也就是说，只要合并的时候更新好原根节点距离新根节点的距离，后续只需要一次查询操作，便可将数据都更新为最新的了</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络通信故障排查常用命令</title>
      <link href="/p/b21cb050.html"/>
      <url>/p/b21cb050.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信故障排查常用命令"><a href="#网络通信故障排查常用命令" class="headerlink" title="网络通信故障排查常用命令"></a>网络通信故障排查常用命令</h1><p>进行后台开发工作时，有时需要排查和定位一些网络通信问题，下面将介绍一些常用的网络通信故障排查命令</p><h2 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h2><p>ifconfig命令是查看当前系统的网卡和IP地址信息的常用命令。</p><p>以上输出显示了本机当前激活的网卡列表，以及每个激活的网卡（网络设备）的IPv4地址、IPv6地址、子网掩码、广播地址等信息，这里一共有两个网卡，分别是ens33和lo。</p><p>我们可以使用-s选项显示网卡信息的精简列表：</p><p>在默认情况下，ifconfig命令只会显示激活的网卡信息，我们可以使用-a选项显示所有（包括未激活）网卡信息。</p><p>使用ifconfig up命令可激活某个网卡，使用ifconfig down命令可禁用某个网卡，这两个命令的用法如下：</p><p>这里演示这两个命令的用法：</p><p>ifconfig命令还可以将一个IP地址绑定到某个网卡上，或将一个IP地址从某个网卡上解绑，命令如下：</p><p>这里通过实际操作进行演示：</p><p>在以上操作中，网卡ens33绑定了IP地址192.168.206.140，我们使用ifconfig add命令绑定了一个新的IP地址：192.168.206.150，现在就可以使用这个新的IP地址访问原来的网络了。</p><p>同理，如果要解绑这个IP地址，就可以按如下所示操作：</p><p>Windows上与ifconfig相对应的命令是ipconfig，例如在Windows上查看所有网卡信息时可以使用ipconfig&#x2F;all。</p><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>Ping命令是常用的命令之一，一般用于侦测本机到目标主机的网络是否畅通。其使用方法如下：</p><p>上面的输出显示了目标网络可达。在Linux上，如果目标网络不可达，则使用ping命令会一直发送而无输出结果，直到按下Ctrl+C组合键中断才会有统计结果，效果如下：</p><p>在Windows上，这时使用ping命令会返回超时的包数量，而不是一直阻塞。在Linux上，这时使用ping命令会一直发送数据包，直到人工主动中断。在Windows机器上默认会发送4个数据包后停止，如果想一直发送而不停止，则可以使用-t选项。</p><p>当然，ping命令的目标也可以是一个域名，这样通过ping这个域名，就可以得到这个域名解析后的.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/p/eefe591f.html"/>
      <url>/p/eefe591f.html</url>
      
        <content type="html"><![CDATA[<p>多进程并发<br>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也造就了多进程并发的两个缺点：</p><p>在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。<br>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。<br>当多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发并不是一个好的选择。所以就引入了多线程的并发。</p><p>多线程并发<br>多线程并发指的是在同一个进程中执行多个线程。</p><p>优点：有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。</p><p>缺点：由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>恋爱必修课</title>
      <link href="/p/854cfaff.html"/>
      <url>/p/854cfaff.html</url>
      
        <content type="html"><![CDATA[<h1 id="恋爱必修课"><a href="#恋爱必修课" class="headerlink" title="恋爱必修课"></a>恋爱必修课</h1><p>恋爱技能就像太极剑，是让你掩盖破绽、化解矛盾，和自己，也和对方的缺陷达成和解的一种能力。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/p/13375.html"/>
      <url>/p/13375.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><h2 id="万能的帮助命令"><a href="#万能的帮助命令" class="headerlink" title="万能的帮助命令"></a>万能的帮助命令</h2><p>man 是manual的缩写</p><pre><code>man lsman manman 7 conmandsman -a conmands</code></pre><p>help帮助</p><pre><code>help cd 内部命令ls  --help  外部命令可以通过type cd获取外部命令还是内部命令</code></pre><p>info 帮助</p><pre><code>info lsinfo帮助比help更加详细，不过是全英文</code></pre><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录，以平铺的方式列出当前工作目录下的内容</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小，单独使用无用</li><li>-a，显示隐藏文件</li></ul><p>ls -l -a<br>ls -a -l<br>ls -la<br>ls -al<br>以上写法等价</p><h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录(change directory)</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径,必填可以使用绝对路径，相对路径</li><li>选项：-p，可选，表示创建前置路径，创建连续的层级目录（多个文件夹）<ul><li>mkdir .&#x2F;2&#x2F;3&#x2F;4 前置的2，3目录不存在则会报错</li><li>加上-p 即可执行</li></ul></li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li><li><code>回车</code>一行一行看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的文件或者文件夹，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><p>rm命令支持通配符 *，用来做模糊匹配</p><ul><li>符号* 表示通配符，即匹配任意内容（包含空），示例：</li><li>test*，表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li><em>test</em>，表示匹配任何包含test的内容</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><p>如下命令，请千万千万不要在root管理员用户下执行：</p><ul><li>rm -rf &#x2F;</li><li>rm -rf &#x2F;*</li><li>效果等同于在Windows上执行C盘格式化。</li></ul><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径，</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*匹配任意内容（包含空）， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><p>示例：</p><ul><li>test*，表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li><em>test</em>，表示匹配任何包含test的内容</li></ul><p>基于通配符的含义，可以结合find命令做文件的模糊查询。</p><p>语法2按文件大小搜索：<code>find 起始路径 -size +|-n[KMG]</code></p><ul><li>+、- 表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li></ul><p>示例：</p><ul><li>查找小于10KB的文件： find &#x2F; -size -10k</li><li>查找大于100MB的文件：find &#x2F; -size +100M</li><li>查找大于1GB的文件：find &#x2F; -size +1G</li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="96-反引号"><a href="#96-反引号" class="headerlink" title="&#96;反引号"></a>&#96;反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-f，持续跟踪文件修改，随时更新其他终端对于文件的更改ctrl+c退出</li><li>-4 查看尾部四行</li></ul><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221906.png" alt="image-20221027221906247"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221939.png" alt="image-20221027221939899"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户和权限</title>
      <link href="/p/56191.html"/>
      <url>/p/56191.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux用户和权限"><a href="#Linux用户和权限" class="headerlink" title="Linux用户和权限"></a>Linux用户和权限</h1><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><ul><li><code>-</code>符号是可选的，表示是否在切换用户后加载环境变量，建议带上</li><li>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</li><li>切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl + d</li></ul><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222035.png" alt="image-20221027222035337"></p><p>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</p><p>比如：</p><pre><code class="shell">itheima ALL=(ALL)       NOPASSWD: ALL</code></pre><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>Linux系统中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组中</li></ul><p>Linux中关于权限的管控级别有2个级别，分别是：</p><ul><li>针对用户的权限控制</li><li>针对用户组的权限控制</li></ul><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222354.png" alt="image-20221027222354498"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222407.png" alt="image-20221027222407618"></p><h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222446.png" alt="image-20221027222446514"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222512.png" alt="image-20221027222512274"></p></li></ul><h2 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h2><p>rwx到底代表什么</p><ul><li>r表示读权限</li><li>w表示写权限</li><li>x表示执行权限</li></ul><p>针对文件、文件夹的不同，rwx的含义有细微差别</p><ul><li>r，针对文件可以查看文件内容<ul><li>针对文件夹，可以查看文件夹内容，如ls命令</li></ul></li><li>w，针对文件表示可以修改此文件<ul><li>针对文件夹，可以在文件夹内：创建、删除、改名等操作</li></ul></li><li>x，针对文件表示可以将文件作为程序执行<ul><li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li></ul></li></ul><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。<br>注意，只有文件、文件夹的所属用户或root用户可以修改。</p><p>修改文件、文件夹权限<br>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222157.png" alt="image-20221027222157276"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222326.png" alt="image-20221027222326192"></p><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简介</title>
      <link href="/p/4551.html"/>
      <url>/p/4551.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><ul><li>Linux有两种含义<ul><li>一种是Linus编写的操作系统内核</li><li>另一种是广义的操作系统</li></ul></li></ul><p>执行环境</p><ul><li>云主机</li><li>无数据的PC</li><li>虚拟机</li></ul><p>版本</p><ul><li>内核版本<ul><li>主版本号</li><li>次版本号 奇数是开发板，偶数为稳定版</li><li>末版本号</li></ul></li><li>发行版<ul><li>Red Hat Enterprise Linux8</li><li>fedora</li><li>centos</li><li>Debian</li><li>Ubuntu</li></ul></li></ul><h2 id="Linux小技巧"><a href="#Linux小技巧" class="headerlink" title="Linux小技巧"></a>Linux小技巧</h2><p>Linux某些程序的运行，如果想要强制停止它，可以使用快捷键ctrl + c<br>命令输入错误，也可以通过快捷键ctrl + c，退出当前输入，重新输入<br>可以通过快捷键：ctrl + d，退出账户的登录，或者退出某些特定程序的专属页面<br>可以通过history命令，查看历史输入过的命令<br>可以通过：!命令前缀，自动执行上一次匹配前缀的命令<br>可以通过快捷键：ctrl + r，输入内容去匹配历史命令，如果搜索到的内容是你需要的，那么：</p><ul><li>回车键可以直接执行</li><li>键盘左右键，可以得到此命令（不执行）</li></ul><p>光标移动的快捷键</p><ul><li>ctrl + a，跳到命令开头</li><li>ctrl + e，跳到命令结尾</li><li>ctrl + 键盘左键，向左跳一个单词</li><li>ctrl + 键盘右键，向右跳一个单词</li></ul><p>通过快捷键ctrl + l，可以清空终端内容，或通过命令clear得到同样效果</p><h2 id="Linux安装相关设置"><a href="#Linux安装相关设置" class="headerlink" title="Linux安装相关设置"></a>Linux安装相关设置</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00..99)</li><li>%m   月份 (01..12)</li><li>%d   日 (01..31)</li><li>%H   小时 (00..23)</li><li>%M   分钟 (00..59)</li><li>%S   秒 (00..60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220514.png" alt="image-20221027220514640"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220525.png" alt="image-20221027220525625"></p></li><li><p>-d选项日期计算</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220429.png" alt="image-20221027220429831"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220449.png" alt="image-20221027220449312"></p></li></ul></li></ul><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>修改时区为中国时区</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220554.png" alt="image-20221027220554654"></p><h3 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h3><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h3 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h3><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><pre><code class="shell">TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;# 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</code></pre></li></ol><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221303.png" alt="image-20221027221303037"></p><h3 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221241.png" alt="image-20221027221241123"></p><h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h3><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221129.png" alt="image-20221027221129782"></p><h3 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221149.png" alt="image-20221027221148964"></p><h3 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221201.png" alt="image-20221027221201079"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221210.png" alt="image-20221027221210518"></p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221340.png" alt="image-20221027221340729"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221354.png" alt="image-20221027221354137"></p><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看磁盘占用</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221413.png" alt="image-20221027221413787"></p><h3 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h3><p>查看CPU、磁盘的相关信息</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221440.png" alt="image-20221027221439990"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221514.png" alt="image-20221027221514237"></p><h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><p>查看网络统计</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221545.png" alt="image-20221027221545822"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>临时设置：export 变量名&#x3D;变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h4 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h4><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h3 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h3><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件管理</title>
      <link href="/p/26649.html"/>
      <url>/p/26649.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h1><h2 id="常见目录介绍"><a href="#常见目录介绍" class="headerlink" title="常见目录介绍"></a>常见目录介绍</h2><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。</td></tr><tr><td>&#x2F;home</td><td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示</td></tr><tr><td>&#x2F;usr</td><td>用于存放系统应用程序，比较重要的目录 &#x2F;usr&#x2F;local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。 &#x2F;usr&#x2F;x11r6 存放x window的目录 &#x2F;usr&#x2F;bin 众多的应用程序 &#x2F;usr&#x2F;sbin 超级用户的一些管理程序 &#x2F;usr&#x2F;doc linux文档 &#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件 &#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件 &#x2F;usr&#x2F;man 帮助文档 &#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里 &#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令 &#x2F;usr&#x2F;local&#x2F;lib 本地增加的库</td></tr><tr><td>&#x2F;opt</td><td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td></tr><tr><td>&#x2F;proc</td><td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td></tr><tr><td>&#x2F;root</td><td>超级用户（系统管理员）的主目录（特权阶级^o^）</td></tr><tr><td>&#x2F;sbin</td><td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td></tr><tr><td>&#x2F;dev</td><td>用于存放设备文件。</td></tr><tr><td>&#x2F;mnt</td><td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td></tr><tr><td>&#x2F;boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>&#x2F;lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td></tr><tr><td>&#x2F;tmp</td><td>用于存放各种临时文件，是公用的临时文件存储点。</td></tr><tr><td>&#x2F;var</td><td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td></tr><tr><td>&#x2F;lost+found</td><td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td></tr><tr><td>&#x2F;etc</td><td>配置文件目录</td></tr></tbody></table><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>pwd 显示当前所在目录名称</p><p>ls 列举当前文件名下的所有文件</p><ul><li>ls后面可以加多个文件路径</li><li>ls -l长格式显示 文件类型权限 文件夹内文件个数 创建用户 用户组 大小 最后修改时间 文件名</li><li>ls -a 显示隐藏文件&#x2F;文件夹</li><li>ls -r 逆向排序</li><li>ls -t 按照时间排序</li><li>ls -R 递归显示</li><li>命令选项可以合并使用 例如 ls -l -a -r &#x3D;&#x3D;&#x3D; ls -lar</li></ul><p>cd 更改当前的操作目录</p><ul><li>cd &#x2F;绝对目录</li><li>cd .&#x2F;相对路径</li><li>cd ..&#x2F; 上一级目录</li><li>cd - 回到刚才目录</li></ul><p>mkdir 创建目录</p><ul><li>mkdir &#x2F;a </li><li>mkdir b c d</li><li>目录已存在则创建失败</li><li>mkdir -p &#x2F;a&#x2F;b&#x2F;c 创建多级目录</li></ul><p>rmdir 只能删除空白目录</p><ul><li>rm -r &#x2F;a 需要确认目录内内容</li><li>rm -r -f 不进行提示</li></ul><p>cp 复制文件和目录</p><ul><li>cp  a  &#x2F;tmp</li><li>cp  -r  b  &#x2F;tmp  复制目录加-r</li><li>cp -p 保留原有创建时间</li><li>cp -a 保留原有组和权限</li></ul><p>mv 移动文件 </p><ul><li>mv filea  fileb 重命名</li><li>mv filea  &#x2F;tmp&#x2F;filea 移动</li><li>mv * &#x2F;tmp </li><li>可以使用通配符* ？ 匹配多个字母 单个字母</li></ul><p>文本查看命令 </p><ul><li>cat 文本显示在终端</li><li>head -5 查看文件开头</li><li>tail -3 查看结尾文件</li><li>tail -f 跟踪查看结尾文件</li><li>wc -l 查看文件多少行</li><li>more&#x2F;less  分行显示</li></ul><h2 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h2><p>打包+压缩<br>打包 tar</p><ul><li>c 打包</li><li>x 解包</li><li>f 指定操作类型为文件</li><li>tar cf &#x2F;test.tar  &#x2F;etc 把etc打包成test.tar</li></ul><p>gzip  bzip2进行压缩</p><p>可以同时打包压缩</p><ul><li>tar czf &#x2F;test.tar.gz  &#x2F;etc </li><li>tar cjf &#x2F;test.tar.bz2  &#x2F;etc</li></ul><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><p>实例：</p><ul><li>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</li><li>ln -s &#x2F;etc&#x2F;yum ~&#x2F;yum</li></ul><h2 id="文本编辑器-vi"><a href="#文本编辑器-vi" class="headerlink" title="文本编辑器 vi"></a>文本编辑器 vi</h2><p>vi 进入到vi编辑器  vim是vi向上兼容的版本</p><ul><li>命令模式（Command mode）<ul><li>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。此模型下，不能自由进行文本编辑。</li></ul></li><li>输入模式（Insert mode）<ul><li>也就是所谓的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。</li></ul></li><li>底线命令模式（Last line mode）<ul><li>以：开始，通常用于文件的保存、退出。</li></ul></li></ul><p>vim兼容全部的vi功能，后续全部使用vim命令</p><ul><li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li><li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li><li></li></ul><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png" alt="image-20221027215841573"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png" alt="image-20221027215846581"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png" alt="image-20221027215849668"></p><h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png" alt="image-20221027215858967"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序实体</title>
      <link href="/p/19cd4605.html"/>
      <url>/p/19cd4605.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序实体"><a href="#程序实体" class="headerlink" title="程序实体"></a>程序实体</h1><p>Go 语言中的程序实体包括变量、常量、函数、结构体和接口。 Go 语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。<br>在 Go 语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些</p><h2 id="声明变量有几种方式？"><a href="#声明变量有几种方式？" class="headerlink" title="声明变量有几种方式？"></a>声明变量有几种方式？</h2><p>先看段代码。</p><pre><code>package mainimport (    &quot;flag&quot;    &quot;fmt&quot;)func main() &#123;    var name string // [1]    flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;) // [2]    flag.Parse()    fmt.Printf(&quot;Hello, %v!\n&quot;, name)&#125;</code></pre><p>这是一个很简单的命令源码文件，除了var name string这种声明变量name的方式，还有其他方式吗？你可以选择性地改动注释[1]和[2]处的代码。</p><p>第一种方式需要先对注释[2]处的代码稍作改动，把被调用的函数由flag.StringVar改为flag.String，传参的列表也需要随之修改，这是为了[1]和[2]处代码合并的准备工作。</p><pre><code>var name = flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</code></pre><p>合并后的代码看起来更简洁一些。我把注释[1]处的代码中的string去掉了，右边添加了一个&#x3D;，然后再拼接上经过修改的[2]处代码。</p><p>注意，flag.String函数返回的结果值的类型是<em>string而不是string。类型</em>string代表的是字符串的指针类型，而不是字符串类型。因此，这里的变量name代表的是一个指向字符串值的指针。<br>因此，在这种情况下，那个被用来打印内容的函数调用就需要微调一下，把其中的参数name改为*name，即：fmt.Printf(“Hello,%v!\n”, *name)。</p><p>第二种方式与第一种方式非常类似，它基于第一种方式的代码，赋值符号&#x3D;右边的代码不动，左边只留下name，再把&#x3D;变成:&#x3D;。</p><pre><code>name := flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</code></pre><p>第一种方式中的代码在声明变量name的同时，还为它赋了值，而这时声明中并没有显式指定name的类型。之前的变量声明语句是var name string。这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。</p><p>它只能用于对变量或常量的初始化，就像上述回答中描述的那样。对flag.String函数的调用其实就是一个调用表达式，而这个表达式的类型是*string，即字符串的指针类型。这也是调用flag.String函数后得到结果的类型。随后，Go 语言把这个调用了flag.String函数的表达式类型，直接作为了变量name的类型，这就是“推断”一词所指代的操作了。</p><p>至于第二种方式所用的短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖。我们只能在函数体内部使用短变量声明。在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方</p><h2 id="Go-语言的类型推断可以带来哪些好处？"><a href="#Go-语言的类型推断可以带来哪些好处？" class="headerlink" title="Go 语言的类型推断可以带来哪些好处？"></a>Go 语言的类型推断可以带来哪些好处？</h2><p>在写代码时，我们通过使用 Go 语言的类型推断，而节省下来的键盘敲击次数几乎可以忽略不计。但它真正的好处，往往会体现在我们写代码之后的那些事情上，比如代码重构</p><pre><code>package mainimport (    &quot;flag&quot;    &quot;fmt&quot;)func main() &#123;    var name = getTheFlag()    flag.Parse()    fmt.Printf(&quot;Hello, %v!\n&quot;, *name)&#125;func getTheFlag() *string &#123;    return flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)&#125;</code></pre><p>我们可以用getTheFlag函数包裹（或者说包装）那个对flag.String函数的调用，并把其结果直接作为getTheFlag函数的结果，结果的类型是*string。这样一来，var name &#x3D;右边的表达式，可以变为针对getTheFlag函数的调用表达式了。这实际上是对“声明并赋值name变量的那行代码”的重构。</p><p>我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。<br>在准备工作做完之后，你会发现，你可以随意改变getTheFlag函数的内部实现，及其返回结果的类型，而不用修改main函数中的任何代码<br>我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。在你改变getTheFlag函数的结果类型之后，Go 语言的编译器会在你再次构建该程序的时候，自动地更新变量name的类型。<br>通过这种类型推断，你可以体验到动态类型编程语言所带来的一部分优势，即程序灵活性的明显提升。但在那些编程语言中，这种提升可以说是用程序的可维护性和运行效率换来的<br>Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。</p><h2 id="变量的重声明是什么意思？"><a href="#变量的重声明是什么意思？" class="headerlink" title="变量的重声明是什么意思？"></a>变量的重声明是什么意思？</h2><p>这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。<br>在 Go 语言中，代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。Go 语言本身以及我<br>们编写的代码共同形成了一个非常大的代码块，也叫全域代码块。这主要体现在，只要是公开的全局变量，都可以被任何代码所使用。相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大。接下来，每个源码文件也都是一个代码块，每个函数也是一个代码块，每个if语句、for语句、switch语句和select语句都是一个代码块。甚至，switch或select语句中的case子句也都是独立的代码块。走个极端，我就在main函数中写一对紧挨着的花括号算不算一个代码块？当然也算，这甚至还有个名词，叫“空代码块”。</p><p>变量重声明含义是对已经声明过的变量再次声明。变量重声明的前提条件如下。</p><ol><li>由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。</li><li>变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了</li><li>变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了</li><li>被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li></ol><p>这样来看，变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。</p><pre><code>var err errorn, err := io.WriteString(os.Stdout, &quot;Hello, everyone!\n&quot;)</code></pre><p>我使用短变量声明对新变量n和旧变量err进行了“声明并赋值”，这时也是对后者的重声明</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/p/b21cb050.html"/>
      <url>/p/b21cb050.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>我们所说的I&#x2F;O模型是指网络I&#x2F;O模型,就是服务端如何管理连接，如何请求连接的措施，是用一个进程管理一个连接（PPC），还是一个线程管理一个连接(TPC)，亦或者一个进程管理多个连接(Reactor)。<br>因此IO多路复用中多路就是多个TCP连接（或多个Channel），复用就是指复用一个或少量线程，理解起来就是多个网路IO复用一个或少量线程来处理这些连接。</p><h2 id="常见I-x2F-O模型"><a href="#常见I-x2F-O模型" class="headerlink" title="常见I&#x2F;O模型"></a>常见I&#x2F;O模型</h2><ul><li>同步阻塞IO（Blocking IO）：即传统IO模型</li><li>同步非阻塞IO（Non-blocking IO）：默认常见的socket都是阻塞的，非阻塞IO要求socket被设置成NONBLOCK</li><li>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，也被称为异步阻塞IO，Java中的selector和linux中的epoll都是这种模型</li><li>异步IO（Asychronous IO）：即Proactor设计模式，也被称为异步非阻塞IO</li></ul><p>同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作，完成后才能继续执行。异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后回通知用户线程，或者调用用户线程注册的回调函数。</p><p>​ 阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式，阻塞时指IO操作需要彻底完成后才能返回用户空间，非阻塞时指IO操作被调用后立即返回给用户一个状态值，无需等待IO操作彻底完成。</p><h3 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h3><p>服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发</p><pre><code>// 伪代码描述while(1) &#123;// accept阻塞client_fd = accept(listen_fd)fds.append(client_fd)for (fd in fds) &#123;    // recv阻塞（会影响上面的accept）    if (recv(fd)) &#123;    // logic    &#125;&#125;  &#125;</code></pre><p>服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写事件的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费</p><pre><code>// 伪代码描述while(1) &#123;// accept阻塞client_fd = accept(listen_fd)// 开启线程read数据（fd增多导致线程数增多）new Thread func() &#123;    // recv阻塞（多线程不影响上面的accept）    if (recv(fd)) &#123;    // logic    &#125;&#125;  &#125;</code></pre><h3 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h3><p>服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds集合recv(非阻塞)数据，没有数据则立即返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu</p><pre><code>setNonblocking(listen_fd)// 伪代码描述while(1) &#123;// accept非阻塞（cpu一直忙轮询）client_fd = accept(listen_fd)if (client_fd != null) &#123;    // 有人连接    fds.append(client_fd)&#125; else &#123;    // 无人连接&#125;  for (fd in fds) &#123;    // recv非阻塞    setNonblocking(client_fd)    // recv 为非阻塞命令    if (len = recv(fd) &amp;&amp; len &gt; 0) &#123;    // 有读写数据    // logic    &#125; else &#123;    无读写数据    &#125;&#125;  &#125;</code></pre><h3 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>服务器端采用单线程通过select&#x2F;epoll等系统调用获取fd列表，遍历有事件的fd进行accept&#x2F;recv&#x2F;send，使其能支持更多的并发连接请求</p><pre><code>fds = [listen_fd]// 伪代码描述while(1) &#123;// 通过内核获取有读写事件发生的fd，只要有一个则返回，无则阻塞// 整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞for (fd in select(fds)) &#123;    if (fd == listen_fd) &#123;        client_fd = accept(listen_fd)        fds.append(client_fd)    &#125; elseif (len = recv(fd) &amp;&amp; len != -1) &#123;     // logic    &#125;&#125;  &#125;</code></pre><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><h2 id="IO多路复用的三种实现方式"><a href="#IO多路复用的三种实现方式" class="headerlink" title="IO多路复用的三种实现方式"></a>IO多路复用的三种实现方式</h2><p>select</p><p>poll</p><p>epoll</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程同步对象</title>
      <link href="/p/9ee71673.html"/>
      <url>/p/9ee71673.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux线程同步对象"><a href="#Linux线程同步对象" class="headerlink" title="Linux线程同步对象"></a>Linux线程同步对象</h1><h2 id="Linux互斥体"><a href="#Linux互斥体" class="headerlink" title="Linux互斥体"></a>Linux互斥体</h2><p>Linux互斥体与Windows的临界区对象用法很相似，一般也是通过限制多个线程同时执行某段代码来保护资源的。在Linux中，互斥体对象（mutex）用于保护共享资源，以防止多个线程同时访问或修改该资源。Linux提供了pthread_mutex_t数据结构来表示互斥体对象，并提供了一些函数来进行初始化和操作互斥体。</p><p>有两种方式可以初始化互斥体对象：</p><ol><li>使用PTHREAD_MUTEX_INITIALIZER宏进行初始化：</li></ol><pre><code class="c++">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code></pre><p>这种方式适用于静态分配的互斥体对象，直接通过宏进行初始化。</p><ol start="2"><li>使用pthread_mutex_init函数进行初始化：</li></ol><pre><code class="c++">pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);</code></pre><p>这种方式适用于动态分配的互斥体对象或需要设置额外属性的情况。pthread_mutex_init函数用于初始化互斥体，第一个参数是指向互斥体对象的指针，第二个参数是指向pthread_mutexattr_t结构的指针，用于设置互斥体的属性。如果不需要设置属性，可以将第二个参数设为NULL。<br>如果函数执行成功，则会返回 0；如果执行失败，则会返回 1 个错误码。<br>需要注意的是，在使用互斥体保护资源时，需要使用pthread_mutex_lock函数进行加锁，保证只有一个线程可以进入临界区执行代码。在临界区执行完后，使用pthread_mutex_unlock函数进行解锁，允许其他线程进入临界区。</p><p>当我们不再需要一个互斥体对象时，可以使用<code>pthread_mutex_destroy</code>函数将其销毁。该函数的函数签名如下：</p><pre><code class="c++">int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></pre><p>参数<code>mutex</code>是指向要销毁的互斥体对象的指针。调用<code>pthread_mutex_destroy</code>函数后，互斥体对象将不再可用。<br>如果函数执行成功，则会返回0；如果执行失败，则会返回一个错误码表明出错的原因。这里需要注意两点。</p><ul><li>无须销毁使用PTHREAD_MUTEX_INITIALIZER初始化的互斥体。</li><li>不要销毁一个已经加锁或正在被条件变量使用的互斥体对象，当互斥体处于已加锁状态或者正在和条件变量配合使用时，调用pthread_mutex_destroy函数会返回EBUSY错误。</li></ul><p>以下代码演示了尝试销毁一个被锁定的互斥体对象的过程：</p><pre><code class="c++">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;pthread_mutex_t mutex;void* threadFunc(void* arg) &#123;    // 加锁互斥体    pthread_mutex_lock(&amp;mutex);    printf(&quot;Thread locked mutex\n&quot;);        // 模拟一段耗时操作    sleep(2);        // 解锁互斥体    pthread_mutex_unlock(&amp;mutex);    printf(&quot;Thread unlocked mutex\n&quot;);        return NULL;&#125;int main() &#123;    // 初始化互斥体    pthread_mutex_init(&amp;mutex, NULL);        // 创建线程    pthread_t thread;    pthread_create(&amp;thread, NULL, threadFunc, NULL);        // 等待一段时间，让线程获得锁    sleep(1);        // 销毁互斥体（尝试）    int result = pthread_mutex_destroy(&amp;mutex);    if (result == 0) &#123;        printf(&quot;Mutex destroyed successfully\n&quot;);    &#125; else &#123;        printf(&quot;Failed to destroy mutex\n&quot;);    &#125;        // 等待线程结束    pthread_join(thread, NULL);        return 0;&#125;</code></pre><p>在上面的代码中，我们创建了一个线程，并在其中锁定了互斥体。然后，在主线程中尝试销毁该互斥体对象。运行代码时，会发现尝试销毁失败，因为互斥体被锁定，无法销毁。<br>这是因为互斥体对象在被锁定状态下是不允许被销毁的。如果尝试销毁一个被锁定的互斥体，<code>pthread_mutex_destroy</code>函数将返回一个非零的错误码，表示销毁失败。<br>在实际应用中，应该确保在销毁互斥体之前，先释放互斥体的所有锁定。只有当互斥体处于未锁定状态时，才能安全地销毁它。</p><p>对于互斥体的加锁和解锁操作，我们一般使用以下三个函数：</p><ol><li><p><code>pthread_mutex_lock</code>: 用于加锁互斥体。如果互斥体已经被其他线程锁定，调用线程将被阻塞，直到互斥体被解锁。</p><p>函数签名：</p><pre><code class="c++">int pthread_mutex_lock(pthread_mutex_t* mutex);</code></pre></li><li><p><code>pthread_mutex_trylock</code>: 尝试加锁互斥体，如果互斥体已经被其他线程锁定，则立即返回失败，不会阻塞当前线程。</p><p>函数签名：</p><pre><code class="c++">int pthread_mutex_trylock(pthread_mutex_t* mutex);</code></pre></li><li><p><code>pthread_mutex_unlock</code>: 用于解锁互斥体。解锁之后，其他线程可以再次加锁互斥体。</p><p>函数签名：</p><pre><code class="c++">int pthread_mutex_unlock(pthread_mutex_t* mutex);</code></pre></li></ol><p>参数mutex是我们需要加锁或解锁的互斥体对象，上述函数如果执行成功则返回 0，如果执行失败则返回一个错误码以表示具体的出错原因。具体的错误码随着互斥体对象属性类型的不同而不同。</p><p>在设置互斥体对象的属性时，可以使用 <code>pthread_mutexattr_t</code> 类型的对象。下面是相关函数的签名：</p><ol><li><p><code>int pthread_mutexattr_init(pthread_mutexattr_t* attr);</code><br>该函数用于初始化 <code>pthread_mutexattr_t</code> 对象，使其成为默认值。</p></li><li><p><code>int pthread_mutexattr_destroy(pthread_mutexattr_t* attr);</code><br>该函数用于销毁 <code>pthread_mutexattr_t</code> 对象，释放相关资源。</p></li></ol><p>在创建 <code>pthread_mutex_t</code> 对象之前，可以通过以下函数设置互斥体的属性：</p><ol start="3"><li><p><code>int pthread_mutexattr_settype(pthread_mutexattr_t* attr, int type);</code><br>该函数用于设置互斥体的类型。参数 <code>type</code> 可以取以下值：</p><ul><li><code>PTHREAD_MUTEX_NORMAL</code>: 普通互斥体，默认值。</li><li><code>PTHREAD_MUTEX_ERRORCHECK</code>: 错误检查互斥体，在同一线程中重复加锁会返回错误。</li><li><code>PTHREAD_MUTEX_RECURSIVE</code>: 递归互斥体，允许同一线程多次加锁。</li></ul><p>注意：某些系统可能不支持所有类型，因此需要根据目标平台的支持情况来选择。</p></li></ol><h3 id="互斥体对象的属性"><a href="#互斥体对象的属性" class="headerlink" title="互斥体对象的属性"></a>互斥体对象的属性</h3><h4 id="PTHREAD-MUTEX-NORMAL（普通锁）"><a href="#PTHREAD-MUTEX-NORMAL（普通锁）" class="headerlink" title="PTHREAD_MUTEX_NORMAL（普通锁）"></a>PTHREAD_MUTEX_NORMAL（普通锁）</h4><p>对于属性类型 <code>PTHREAD_MUTEX_NORMAL</code>，它表示普通锁，默认情况下互斥体的属性就是普通锁。当一个线程对普通锁加锁后，其他线程会被阻塞在 <code>pthread_mutex_lock</code> 调用处，直到持有锁的线程释放锁。</p><p>以下是一个验证示例代码：</p><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;int counter = 0;void* increment(void* arg) &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        pthread_mutex_lock(&amp;mutex);        counter++;        pthread_mutex_unlock(&amp;mutex);    &#125;    return NULL;&#125;int main() &#123;    pthread_t thread1, thread2;    pthread_create(&amp;thread1, NULL, increment, NULL);    pthread_create(&amp;thread2, NULL, increment, NULL);    pthread_join(thread1, NULL);    pthread_join(thread2, NULL);    printf(&quot;Counter value: %d\n&quot;, counter);    return 0;&#125;</code></pre><p>在上面的示例中，我们创建了两个线程 <code>thread1</code> 和 <code>thread2</code>，它们都执行 <code>increment</code> 函数，该函数对 <code>counter</code> 变量进行 100000 次加一操作。为了保证操作的原子性，我们使用互斥体 <code>mutex</code> 进行加锁和解锁操作。</p><p>最终，我们打印出 <code>counter</code> 的值，预期结果应该是 200000。这是因为两个线程分别进行了 100000 次加一操作，互斥体保证了对 <code>counter</code> 的访问是线程安全的。</p><p>但是对于一个已经加锁的普通锁（<code>PTHREAD_MUTEX_NORMAL</code>），如果同一个线程再次调用 <code>pthread_mutex_lock</code> 进行加锁操作，那么该线程会被阻塞在第二次的加锁操作处，形成死锁。</p><p>以下是测试代码：</p><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void* thread_func(void* arg) &#123;    printf(&quot;Thread starting...\n&quot;);    // 第一次加锁    pthread_mutex_lock(&amp;mutex);    printf(&quot;Thread acquired lock\n&quot;);    // 第二次加锁，会导致死锁    pthread_mutex_lock(&amp;mutex);    printf(&quot;Thread acquired lock again\n&quot;);    pthread_mutex_unlock(&amp;mutex);    pthread_mutex_unlock(&amp;mutex);    printf(&quot;Thread exiting...\n&quot;);    return NULL;&#125;int main() &#123;    pthread_t thread;    pthread_create(&amp;thread, NULL, thread_func, NULL);    pthread_join(thread, NULL);    return 0;&#125;</code></pre><p>在上面的示例中，我们创建了一个线程 <code>thread</code>，该线程执行 <code>thread_func</code> 函数。在 <code>thread_func</code> 函数中，我们对互斥体 <code>mutex</code> 进行两次加锁操作。这样的操作会导致线程在第二次加锁操作处被阻塞，形成了死锁。<br>在运行代码时，可以观察到程序会卡在第二次加锁操作处，并无法继续执行。这是因为同一个线程对已经加锁的普通锁再次进行加锁操作会导致线程自身无法解锁，从而形成了死锁。</p><h4 id="PTHREAD-MUTEX-ERRORCHECK（检错锁）"><a href="#PTHREAD-MUTEX-ERRORCHECK（检错锁）" class="headerlink" title="PTHREAD_MUTEX_ERRORCHECK（检错锁）"></a>PTHREAD_MUTEX_ERRORCHECK（检错锁）</h4><p>对于属性类型 <code>PTHREAD_MUTEX_ERRORCHECK</code>，在同一个线程多次对已经加锁的互斥体对象进行加锁操作时，<code>pthread_mutex_lock</code> 函数会返回错误码 <code>EDEADLK</code>，表示检测到了死锁。</p><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;pthread_mutexattr_t attr;pthread_mutex_t mutex;void* thread_func(void* arg) &#123;    printf(&quot;Thread starting...\n&quot;);    // 第一次加锁    pthread_mutex_lock(&amp;mutex);    printf(&quot;Thread acquired lock\n&quot;);    // 第二次加锁，会返回 EDEADLK    int result = pthread_mutex_lock(&amp;mutex);    if (result == EDEADLK) &#123;        printf(&quot;Thread detected deadlock\n&quot;);    &#125; else &#123;        printf(&quot;Thread acquired lock again\n&quot;);        pthread_mutex_unlock(&amp;mutex);    &#125;    pthread_mutex_unlock(&amp;mutex);    printf(&quot;Thread exiting...\n&quot;);    return NULL;&#125;int main() &#123;    pthread_mutexattr_init(&amp;attr);    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);    pthread_mutex_init(&amp;mutex, &amp;attr);    pthread_t thread;    pthread_create(&amp;thread, NULL, thread_func, NULL);    pthread_join(thread, NULL);    pthread_mutex_destroy(&amp;mutex);    pthread_mutexattr_destroy(&amp;attr);    return 0;&#125;</code></pre><p>在上述代码中，我们首先使用 <code>pthread_mutexattr_init</code> 函数初始化互斥体属性对象 <code>attr</code>，然后使用 <code>pthread_mutexattr_settype</code> 函数设置属性类型为 <code>PTHREAD_MUTEX_ERRORCHECK</code>，接着使用 <code>pthread_mutex_init</code> 函数初始化互斥体 <code>mutex</code>，确保它使用了设置好的属性。</p><p>在 <code>thread_func</code> 函数中，我们对互斥体进行两次加锁操作，并检查第二次加锁时返回的错误码。如果返回了 <code>EDEADLK</code> 错误码，则输出相应的提示信息。</p><p>当运行代码时，线程在第二次加锁操作处返回了 <code>EDEADLK</code> 错误码，并输出了相应的提示信息，表示检测到了死锁。</p><h4 id="PTHREAD-MUTEX-RECURSIVE"><a href="#PTHREAD-MUTEX-RECURSIVE" class="headerlink" title="PTHREAD_MUTEX_RECURSIVE"></a>PTHREAD_MUTEX_RECURSIVE</h4><p>对于属性类型 <code>PTHREAD_MUTEX_RECURSIVE</code>，它允许同一个线程对持有的互斥体对象进行重复加锁操作，每次成功调用 <code>pthread_mutex_lock</code> 函数时，互斥体对象的锁引用计数会增加 1，而每次成功调用 <code>pthread_mutex_unlock</code> 函数时，锁引用计数会减少 1。只有当锁引用计数为 0 时，其他线程才能获得该锁；否则，其他线程调用 <code>pthread_mutex_lock</code> 时会阻塞在该函数调用处。<br>这种属性类型的互斥体对象可以用于实现递归操作或者在嵌套函数调用中对共享资源进行保护。同一个线程在持有互斥体对象的同时可以多次调用加锁操作，只有在对应数量的解锁操作完成后，其他线程才能获得该锁。这种机制能够确保资源在嵌套函数调用中的正确访问和保护。<br>需要注意的是，在使用 <code>PTHREAD_MUTEX_RECURSIVE</code> 属性的互斥体对象时，要确保加锁和解锁操作的次数匹配，否则可能导致死锁或其他错误。</p><h3 id="互斥体对象的使用要点的总结："><a href="#互斥体对象的使用要点的总结：" class="headerlink" title="互斥体对象的使用要点的总结："></a>互斥体对象的使用要点的总结：</h3><ol><li>在实际开发中，同一个线程对一个互斥体对象反复加锁的场景非常少见。</li><li>为了避免在逻辑中忘记调用 <code>pthread_mutex_unlock</code> 导致死锁，或者在逻辑出口处出现大量重复的解锁代码，建议使用 RAII 技术（资源获取即初始化）来封装互斥体对象。这样可以确保在离开作用域时自动释放互斥体，避免忘记解锁的问题。</li></ol><p>RAII 技术可以通过使用 C++ 的智能指针或封装类来实现。在创建一个封装互斥体的类时，可以在构造函数中调用 <code>pthread_mutex_lock</code>，在析构函数中调用 <code>pthread_mutex_unlock</code>，这样可以确保互斥体对象在离开作用域时自动解锁。这种方式可以简化代码，提高代码的可维护性和可靠性。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量代表一定的资源数量，可以根据当前资源的数量按需唤醒指定数量的资源消费者线程，资源消费者线程一旦获取信号量，就会让资源减少指定的数量，如果资源数量减少为0，则消费者线程将全部处于挂起状态；当有新的资源到来时，消费者线程将继续被唤醒。另外，信号量有“资源有多份，可以同时被多个线程访问”的意思。<br>在Linux中，信号量的常用API函数包括：</p><ol><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value)</code>: 用于初始化一个命名或匿名信号量。参数<code>sem</code>是指向信号量对象的指针，<code>pshared</code>指定信号量的共享方式（0表示线程间共享，非0表示进程间共享），<code>value</code>是信号量的初始值。</li><li><code>int sem_destroy(sem_t *sem)</code>: 用于销毁一个已初始化的信号量对象。参数<code>sem</code>是指向信号量对象的指针。</li><li><code>int sem_wait(sem_t *sem)</code>: 对信号量进行P操作（等待），如果信号量的值大于0，则将其减1；如果值为0，则阻塞等待直到值大于0。</li><li><code>int sem_trywait(sem_t *sem)</code>: 对信号量进行非阻塞的P操作（尝试等待），如果信号量的值大于0，则将其减1；如果值为0，则立即返回并返回错误码。</li><li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout)</code>: 对信号量进行定时等待的P操作，等待一定的时间，如果信号量的值大于0，则将其减1；如果值为0，则阻塞等待直到值大于0或超过指定的超时时间。</li><li><code>int sem_post(sem_t *sem)</code>: 对信号量进行V操作（释放），将信号量的值加1，并唤醒等待该信号量的线程或进程。</li><li><code>int sem_getvalue(sem_t *sem, int *sval)</code>: 获取信号量的当前值，并将其存储在<code>sval</code>指向的整型变量中。</li></ol><p>以上是Linux中信号量的常用API函数，它们定义在<code>&lt;semaphore.h&gt;</code>头文件中，用于实现进程间或线程间的同步和互斥操作。<br>使用以上几个函数时还有几个需要注意的地方。</p><ol><li><p>当多个线程调用 <code>sem_wait</code> 等函数等待同一个信号量时，只会有一个线程被唤醒，即只有一个线程可以成功获取到资源。这是因为这些函数在递减资源计数到1时会锁定信号量对象，确保只有一个线程可以通过。其他线程会在等待队列中等待，直到该线程释放信号量后才有机会获得资源。</p></li><li><p><code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 函数在调用成功时返回值为0，表示成功获取到资源。而在调用失败时返回-1，并通过错误码 <code>errno</code> 来指示失败的原因。可以使用 <code>errno</code> 来判断具体的错误类型，例如 <code>EAGAIN</code> 表示资源当前不可用，<code>ETIMEDOUT</code> 表示超时等。</p></li><li><p><code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 函数可以被Linux信号中断。当信号中断发生时，这些函数会立即返回，并将返回值设置为-1，同时错误码 <code>errno</code> 被设置为 <code>EINTR</code>。这种情况下，通常需要检查是否是由于信号中断而导致的返回，可以重新调用函数来处理信号中断的情况。</p></li><li><p>尽管这些函数的名称没有以 <code>pthread_</code> 为前缀，但是实际使用时仍然需要链接 <code>pthread</code> 库。因为信号量是基于线程库实现的，因此需要链接相应的库以使用这些函数。</p></li></ol><p>下面是一个示例，演示了创建一个生产者线程和五个消费者线程，使用信号量来实现任务的生产和消费：</p><pre><code class="cpp">#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;unistd.h&gt;// 全局变量std::queue&lt;int&gt; taskQueue;  // 任务队列pthread_mutex_t queueMutex; // 任务队列互斥锁sem_t sem;                  // 信号量// 生产者线程函数void* producerThread(void* arg) &#123;    int taskId = 1;    while (true) &#123;        // 生成任务        int task = taskId++;        // 将任务加入队列        pthread_mutex_lock(&amp;queueMutex);        taskQueue.push(task);        pthread_mutex_unlock(&amp;queueMutex);        // 增加信号量资源计数        sem_post(&amp;sem);        sleep(1);    &#125;    return NULL;&#125;// 消费者线程函数void* consumerThread(void* arg) &#123;    while (true) &#123;        // 等待信号量，等待可执行任务        sem_wait(&amp;sem);        // 从队列中获取任务        pthread_mutex_lock(&amp;queueMutex);        int task = taskQueue.front();        taskQueue.pop();        pthread_mutex_unlock(&amp;queueMutex);        // 处理任务        std::cout &lt;&lt; &quot;Consumer thread &quot; &lt;&lt; pthread_self() &lt;&lt; &quot; processing task: &quot; &lt;&lt; task &lt;&lt; std::endl;        // 删除任务对象，避免内存泄漏        // ...        // 可以进行其他操作        sleep(1);    &#125;    return NULL;&#125;int main() &#123;    // 初始化互斥锁和信号量    pthread_mutex_init(&amp;queueMutex, NULL);    sem_init(&amp;sem, 0, 0);    // 创建生产者线程    pthread_t producer;    pthread_create(&amp;producer, NULL, producerThread, NULL);    // 创建消费者线程    const int numConsumers = 5;    pthread_t consumers[numConsumers];    for (int i = 0; i &lt; numConsumers; ++i) &#123;        pthread_create(&amp;consumers[i], NULL, consumerThread, NULL);    &#125;    // 等待生产者线程和消费者线程结束    pthread_join(producer, NULL);    for (int i = 0; i &lt; numConsumers; ++i) &#123;        pthread_join(consumers[i], NULL);    &#125;    // 销毁互斥锁和信号量    pthread_mutex_destroy(&amp;queueMutex);    sem_destroy(&amp;sem);    return 0;&#125;</code></pre><p>在这个示例代码中，主函数创建了一个生产者线程和五个消费者线程。生产者线程循环生成任务，并将任务加入任务队列。每次生产任务后，通过 <code>sem_post</code> 函数增加信号量资源计数。</p><p>消费者线程通过 <code>sem_wait</code> 函数等待可执行的任务。当信号量的资源计数大于0时，其中一个消费者线程会被唤醒，从任务队列中获取任务进行处理。在处理任务后，可以进行其他操作，如删除任务对象，避免内存泄漏。</p><p>在调用sem_wait和sem_post时会对信号量对象进行加锁和解锁，为什么这里还需要使用一个互斥体呢？其实，这个互斥体是用来保护队列tasks的，因为多个线程会同时读写它。</p><p>另外，为了确保线程的正确退出，主函数使用 <code>pthread_join</code> 函数等待生产者线程和消费者线程结束。</p><h2 id="Linux条件变量"><a href="#Linux条件变量" class="headerlink" title="Linux条件变量"></a>Linux条件变量</h2><p>有人说 Linux 条件变量（Condition Variable）是最不容易用错的一种线程同步对象，确实是这样，但必须建立在对条件变量熟练应用的基础之上。</p><h3 id="为什么需要使用条件变量"><a href="#为什么需要使用条件变量" class="headerlink" title="为什么需要使用条件变量"></a>为什么需要使用条件变量</h3><p>在实际应用中，我们常常会有类似如下的需求：</p><pre><code>// 以下是伪代码// m 的类型是 pthread_mutex_t，已经初始化过了int waitForTrue() &#123;    do &#123;        // 加锁互斥体，确保条件判断的原子性        pthread_mutex_lock(&amp;m);        // 验证条件是否为 true        // ...        // 解锁互斥体，让其他线程有机会改变条件        pthread_mutex_unlock(&amp;m);        // 睡眠 n 秒        sleep(n);    &#125; while (condition is false);    return 1;&#125;</code></pre><p>反复判断一个多线程的共享条件是否满足，一直到该条件满足为止。由于该条件被多个线程操作，因此在每次判断之前都需要进行加锁操作，判断完毕后需要进行解锁操作。但是，该逻辑存在严重的效率问题，假设解锁离开临界区后，其他线程修改了条件导致条件满足，则此时程序仍然需要睡眠n秒才能得到反馈。因此我们需要这样一种机制：某个线程 A 在条件不满足的情况下主动让出互斥体，让其他线程操作，线程 A在此处等待条件满足；一旦条件满足，线程 A就可以被立刻唤醒。线程 A之所以可以安心等待，依赖的是其他线程的协作，它确认会有一个线程在发现条件满足以后，向它发送信号并且让出互斥体。如果其他线程不配合（不发送信号、不让出互斥体），就无法实现上述效果。<br>这就是为什么需要条件等待，但条件等待不是条件变量的全部功能。</p><h3 id="条件变量为什么要与互斥体对象结合使用"><a href="#条件变量为什么要与互斥体对象结合使用" class="headerlink" title="条件变量为什么要与互斥体对象结合使用"></a>条件变量为什么要与互斥体对象结合使用</h3><p>为什么条件变量一定要与一个互斥体对象结合使用呢？我们假设条件变量不与互斥体对象结合，来看看是什么效果。以下是伪代码：</p><pre><code>// m的类型是 pthread_mutex_t，并且已经初始化过了，cv是条件变量pthread_mutex_lock(&amp;m);while (condition_ is_false) &#123;    pthread_mutex_unlock(&amp;m);    // 解锁之后，等待之前，可能条件已经满足，信号已经发出，但是该信号可能被错过    pthread_cond_wait(&amp;cv, &amp;m);    pthread_mutex_lock(&amp;m);&#125;pthread_mutex_unlock(&amp;m);</code></pre><p>在以上代码中，假设线程A在执行完pthread_mutex_unlock(&amp;m)后CPU时间片被剥夺，此时另一个线程 B获得该互斥体对象 m，然后发送条件信号，等<br>线程 A重新获得时间片后，由于该信号已经被错过，可能会导致线程A在代码第7行无限阻塞下去。造成这个问题的根源是释放互斥体对象与条件变量等待唤醒不是原子操作，即解锁和等待这两个步骤必须在同一个原子操作中，才能确保cond_wait在唤醒之前不会有其他线程获得这个互斥体对象。</p><h3 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h3><p>对条件变量进行初始化和销毁，可以使用以下 API 函数：</p><ol><li><p><code>pthread_cond_init</code>：用于初始化条件变量。</p><ul><li>函数原型：<code>int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);</code></li><li>参数 <code>cond</code> 是指向条件变量对象的指针。</li><li>参数 <code>attr</code> 是指向条件变量属性对象的指针，可以为 NULL 表示使用默认属性。</li><li>返回值：成功返回 0，失败返回错误码。</li></ul></li><li><p><code>pthread_cond_destroy</code>：用于销毁条件变量。</p><ul><li>函数原型：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li><li>参数 <code>cond</code> 是指向条件变量对象的指针。</li><li>返回值：成功返回 0，失败返回错误码。</li></ul></li></ol><p>在 Linux 系统中，<code>pthread_cond_t</code> 表示条件变量的数据类型。可以使用如下方式初始化一个条件变量：</p><pre><code class="cpp">#include &lt;pthread.h&gt;pthread_cond_t cv = PTHREAD_COND_INITIALIZER;</code></pre><p>上述代码将条件变量 <code>cv</code> 初始化为静态分配的条件变量对象，并使用宏 <code>PTHREAD_COND_INITIALIZER</code> 进行初始化。这种方式适用于静态分配<br>使用示例：</p><pre><code class="cpp">#include &lt;pthread.h&gt;pthread_cond_t cv; // 声明条件变量对象int main() &#123;    // 初始化条件变量    int result = pthread_cond_init(&amp;cv, NULL);    if (result != 0) &#123;        // 处理初始化失败的情况    &#125;    // 使用条件变量    // 销毁条件变量    result = pthread_cond_destroy(&amp;cv);    if (result != 0) &#123;        // 处理销毁失败的情况    &#125;    return 0;&#125;</code></pre><p>注意：在使用条件变量之前，需要先初始化它，使用完毕后再进行销毁操作。确保在销毁条件变量之前，没有线程在等待或使用该条件变量。</p><p>可以使用以下 API 函数等待条件变量被唤醒：</p><pre><code class="cpp">#include &lt;pthread.h&gt;int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code></pre><p>函数 <code>pthread_cond_wait</code> 用于等待条件变量的信号，并在等待期间自动释放关联的互斥体锁，并在被唤醒后重新获得锁。函数的参数 <code>cond</code> 是指向条件变量的指针，<code>mutex</code> 是指向互斥体对象的指针。</p><p>调用 <code>pthread_cond_wait</code> 时，会进行以下操作：</p><ol><li>首先，函数会自动释放 <code>mutex</code> 指向的互斥体锁，以允许其他线程访问临界区。</li><li>然后，线程将进入等待状态，直到接收到条件变量的信号。</li><li>当条件变量的信号被发送并接收到时，线程将重新获得 <code>mutex</code> 指向的互斥体锁，并从 <code>pthread_cond_wait</code> 函数返回。</li></ol><p>需要注意的是，<code>pthread_cond_wait</code> 函数需要在持有互斥体锁的情况下调用，否则行为是未定义的。在调用 <code>pthread_cond_wait</code> 前后，通常需要使用互斥体来保护条件的判断和修改，以确保线程安全性。</p><p>使用示例：</p><pre><code class="cpp">#include &lt;pthread.h&gt;pthread_cond_t cv;pthread_mutex_t mutex;void* thread_function(void* arg) &#123;    // 在获取锁之前做一些准备工作    pthread_mutex_lock(&amp;mutex);    // 检查条件是否满足    while (condition_is_false) &#123;        // 等待条件变量的信号，自动释放互斥体锁        pthread_cond_wait(&amp;cv, &amp;mutex);        // 在被唤醒后重新获得互斥体锁，继续检查条件    &#125;    // 条件满足后的处理    pthread_mutex_unlock(&amp;mutex);    return NULL;&#125;</code></pre><p>在上述示例中，线程在等待条件变量的信号时会自动释放互斥体锁，并在被唤醒后重新获得锁，以继续执行后续操作。</p><p>以下是可以唤醒等待在条件变量上的线程的 API 函数：</p><pre><code class="cpp">#include &lt;pthread.h&gt;int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond);</code></pre><ul><li><code>pthread_cond_signal</code> 函数用于唤醒等待在条件变量上的一个线程。如果有多个线程在等待条件变量上，只会唤醒其中一个线程，具体唤醒哪个线程是不确定的。</li><li><code>pthread_cond_broadcast</code> 函数用于唤醒等待在条件变量上的所有线程。</li></ul><p>这两个函数的参数 <code>cond</code> 是指向条件变量的指针。pthread_cond_signal和pthread_cond_broadcast均返回0，反之均返回具体的错误码值。</p><p>调用 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code> 函数后，等待在条件变量上的线程将被唤醒，并重新开始竞争互斥体锁。被唤醒的线程将继续执行等待后的代码，直到重新获得互斥体锁。</p><p>需要注意的是，为了确保等待线程能够正确地接收到信号，通常在发送信号之前需要先获得相关的互斥体锁，以保证操作的原子性。</p><p>使用示例：</p><pre><code class="cpp">#include &lt;pthread.h&gt;pthread_cond_t cv;pthread_mutex_t mutex;void signal_condition() &#123;    pthread_mutex_lock(&amp;mutex);    // 发送条件变量的信号，唤醒等待的线程    pthread_cond_signal(&amp;cv);    pthread_mutex_unlock(&amp;mutex);&#125;void broadcast_condition() &#123;    pthread_mutex_lock(&amp;mutex);    // 发送条件变量的广播信号，唤醒所有等待的线程    pthread_cond_broadcast(&amp;cv);    pthread_mutex_unlock(&amp;mutex);&#125;</code></pre><p>在上述示例中，通过调用 <code>pthread_cond_signal</code> 函数或 <code>pthread_cond_broadcast</code> 函数，可以唤醒等待在条件变量上的线程。这些线程会在被唤醒后竞争互斥体锁，并继续执行等待后的代码。</p><p>在使用 <code>pthread_cond_wait</code> 函数时，需要注意以下两点：</p><ol><li><p>调用 <code>pthread_cond_wait</code> 前需要对互斥体进行加锁操作：在等待条件时，线程需要持有与条件变量关联的互斥体锁。因此，在调用 <code>pthread_cond_wait</code> 之前，通常需要使用 <code>pthread_mutex_lock</code> 函数对互斥体进行加锁操作，确保在等待条件时互斥体是被当前线程所持有。这样可以避免在等待过程中出现竞态条件。</p></li><li><p>收到条件信号时，<code>pthread_cond_wait</code> 函数会返回并对其绑定的互斥体进行加锁操作：当等待的条件满足并且收到条件信号时，<code>pthread_cond_wait</code> 函数会返回，并且在返回时会对其绑定的互斥体进行加锁操作。这是为了确保线程在返回后可以安全地访问共享资源。因此，在 <code>pthread_cond_wait</code> 的下面，通常会有对互斥体进行解锁的操作，以允许其他线程获得互斥体锁，并且可以继续执行需要保护的临界区代码。</p></li></ol><h3 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a>条件变量的虚假唤醒</h3><p>在多线程编程中，存在一种称为 “虚假唤醒”（spurious wakeup）的情况。即使没有收到条件信号，线程有时也可能被唤醒。因此，在使用条件变量时，需要使用 <code>while</code> 循环来再次检查条件是否满足，以防止虚假唤醒导致的错误行为。<br>虚假唤醒这看起来像个Bug，但它在Linux系统中是实实在在存在的。假设pthread_cond_wait函数被信号中断，则在 pthread_cond_wait 函数返回之后，到重新调用之前，pthread_cond_signal 或pthread_cond_broadcast函数可能已被调用。一旦错失该信号，则可能由于条件信号不再产生，再次调用 thread_cond_wait 函数将导致程序无限等待。为了避免这种情况发生，我们宁可虚假唤醒，也不能再次调用pthread_cond_wait函数，以免陷入无穷等待中。<br>这种虚假唤醒可能发生在以下情况下：</p><ol><li>平台实现：不同的操作系统或编译器对条件变量的实现可能会导致虚假唤醒的问题。</li><li>信号中断：当线程被信号中断唤醒时，可能会发生虚假唤醒。信号中断会打断线程的阻塞状态，使其从 <code>pthread_cond_wait</code> 返回，但并没有实际的条件变化发生。</li><li>在条件满足时发送信号，但等到调用pthread_cond_wait函数的线程得到CPU时间片时，条件又再次不满足了。<br>通过使用 <code>while</code> 循环再次检查条件，可以确保只有在条件满足时线程才继续执行，否则会再次进入等待状态。这样可以防止因为虚假唤醒而引发的错误行为。<br>除了上面的信号因素，还存在一些情况：在条件满足时发送信号，但等到调用pthread_cond_wait函数的线程得到CPU时间片时，条<br>件又再次不满足了。<br>以下是示例代码:</li></ol><pre><code class="cpp">pthread_mutex_t mutex;pthread_cond_t cv;int condition = 0;void* thread_function(void* arg) &#123;    pthread_mutex_lock(&amp;mutex);        // 使用 while 循环来再次检查条件    while (condition == 0) &#123;        pthread_cond_wait(&amp;cv, &amp;mutex);    &#125;        // 条件满足后的处理    // ...    pthread_mutex_unlock(&amp;mutex);    return NULL;&#125;void signal_condition() &#123;    pthread_mutex_lock(&amp;mutex);        // 更新条件    condition = 1;        // 发送条件变量的信号，唤醒等待的线程    pthread_cond_signal(&amp;cv);        pthread_mutex_unlock(&amp;mutex);&#125;</code></pre><p>通过在 <code>while</code> 循环中再次检查条件，即使出现虚假唤醒的情况，线程也会再次等待条件满足，以确保正确的行为。</p><h3 id="条件变量信号丢失的问题"><a href="#条件变量信号丢失的问题" class="headerlink" title="条件变量信号丢失的问题"></a>条件变量信号丢失的问题</h3><p>如果一个条件变量信号在产生时（调用pthread_cond_signal或pthread_cond_broadcast），没有相关线程调用 pthread_cond_wait 捕获该信号，该信号就会永久丢失，再次调用pthread_cond_wait 会导致永久阻塞。我们在设计条件变量信号只会产生一次的逻辑中尤其需要注意这种情况。举个例子，假设现在某个程序中有一批等待条件变量的线程，和一个只产生一次条件变量信号的线程。为了让等待条件变量的线程能够正常运行而不阻塞，编写这段逻辑时一定要确保等待的线程在产生条件变量信号的线程发送条件信号之前调用pthread_cond_wait。</p><h2 id="Linux读写锁"><a href="#Linux读写锁" class="headerlink" title="Linux读写锁"></a>Linux读写锁</h2><h3 id="读写锁的应用场景"><a href="#读写锁的应用场景" class="headerlink" title="读写锁的应用场景"></a>读写锁的应用场景</h3><p>在实际应用中，对共享变量的访问大多有个特点：在大多数情况下，线程只是读取共享变量的值，只在极少数情况下才会真正修改共享变量的值。对于这种情况，读请求之间无须同步，它们之间的并发访问是安全的。然而写请求必须锁住读请求和其他写请求。这在实际应用中是存在的，例如读取一个全局对象的状态属性，这个状态属性的值一般不会变化，偶尔才会被修改。如果使用互斥体完全阻止读请求并发，则会造成性能的损失。</p><h3 id="读写锁的相关API"><a href="#读写锁的相关API" class="headerlink" title="读写锁的相关API"></a>读写锁的相关API</h3><p>在Linux系统中，可以使用以下系统API函数来初始化和销毁读写锁：</p><ol><li><p>初始化读写锁：<code>int pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr)</code></p><ul><li>参数 <code>rwlock</code>：指向要初始化的读写锁对象的指针。</li><li>参数 <code>attr</code>：指向读写锁属性的指针，通常设置为<code>NULL</code>表示使用默认属性。</li><li>返回值：若成功初始化读写锁，则返回0；否则返回错误码。</li></ul></li><li><p>销毁读写锁：<code>int pthread_rwlock_destroy(pthread_rwlock_t* rwlock)</code></p><ul><li>参数 <code>rwlock</code>：指向要销毁的读写锁对象的指针。</li><li>返回值：若成功销毁读写锁，则返回0；否则返回错误码。</li></ul></li></ol><p>当然，如果不需要动态创建或者设置非默认属性的读写锁对象，则也可以使用如下语法初始化一个读写锁对象：</p><pre><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code></pre><p>以下是请求读锁和写锁的系统API接口：</p><p>请求读锁的系统API接口：</p><ol><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)</code>：请求读取锁。如果读取锁可用，则将读取锁分配给调用线程，否则线程将阻塞，直到读取锁可用。</li><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)</code>：尝试请求读取锁。如果读取锁可用，则将读取锁分配给调用线程并返回0，否则立即返回EBUSY，不会阻塞线程。</li><li><code>int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout)</code>：在指定的超时时间内请求读取锁。如果在超时时间内读取锁可用，则将读取锁分配给调用线程并返回0，否则返回ETIMEDOUT。</li></ol><p>请求写锁的系统API接口：</p><ol><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)</code>：请求写入锁。如果写入锁可用，则将写入锁分配给调用线程，否则线程将阻塞，直到写入锁可用。</li><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)</code>：尝试请求写入锁。如果写入锁可用，则将写入锁分配给调用线程并返回0，否则立即返回EBUSY，不会阻塞线程。</li><li><code>int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout)</code>：在指定的超时时间内请求写入锁。如果在超时时间内写入锁可用，则将写入锁分配给调用线程并返回0，否则返回ETIMEDOUT。</li></ol><p>这些API函数可以用于在多线程环境中对读写锁进行加锁操作。</p><p>读写锁的使用规则如下：</p><p>读模式（共享模式）：</p><ul><li>如果当前读写锁已经被某线程以读模式占有，其他线程可以立即获取读锁，而不会被阻塞。</li><li>如果当前读写锁已经被某线程以写模式占有，其他线程请求读锁会被阻塞，直到写锁被释放。</li></ul><p>写模式（独占模式）：</p><ul><li>如果当前读写锁已经被某线程以写模式占有，其他线程无论是请求读锁还是写锁，都会被阻塞，直到写锁被释放。</li><li>在写模式下，不允许其他线程获取读锁或写锁。</li></ul><p>通过读写锁，可以实现对共享资源的并发读取和独占写入的控制，提高系统的并发性和吞吐量。</p><p>释放读锁和写锁都使用同一个接口</p><pre><code>pthread_rwlock_unlock</code></pre><p>该函数用于释放当前线程持有的读锁或写锁。<br>无论是请求读锁还是写锁，都提供了 trylock 的功能（pthread_rwlock_tryrdlock 和pthread_rwlock_trywrlock），调用线程不会阻塞，而是立即返回。如果能成功获得读锁或者写锁，则函数返回0，如果不能获得读锁或写锁，则函数返回非0值，此时错误码errno是EBUSY。当然，无论是请求读锁还是写锁，都提供了限时等待功能。如果不能获取读写锁，则会陷入阻塞，最多等待到参数 abstime设置的时间，如果此时仍然无法获得锁，则返回，错误码errno是ETIMEOUT。</p><h3 id="读写锁的属性"><a href="#读写锁的属性" class="headerlink" title="读写锁的属性"></a>读写锁的属性</h3><p>pthread_rwlock_init函数我们可以知道第2个参数可以设置读写锁的属性，读写锁的属性类型是pthread_rwlockattr_t。glibc引入了如下接口来查询和改变读写锁的类型：</p><pre><code>pthread_rwlockattr_init: 初始化读写锁属性对象。pthread_rwlockattr_destroy: 销毁读写锁属性对象。pthread_rwlockattr_getkind_np: 获取读写锁的类型。pthread_rwlockattr_setkind_np: 设置读写锁的类型。</code></pre><p>其中，函数名中的 _np 表示这些函数是非标准的扩展函数，属于 GNU C 库 (glibc) 的特定扩展。这些函数允许查询和设置读写锁的类型属性，以控制读写锁的行为。</p><p><code>pthread_rwlockattr_setkind_np</code> 函数的第二个参数 <code>pref</code> 用于设置读写锁的类型，它可以取以下值：</p><ul><li><code>PTHREAD_RWLOCK_PREFER_READER_NP</code>: 优先读者模式。在有读者等待时，尽量让其他读者获得读锁，以提高读取操作的并发性。</li><li><code>PTHREAD_RWLOCK_PREFER_WRITER_NP</code>: 优先写者模式。在有写者等待时，尽量让写者获得写锁，以避免读者长时间等待。</li><li><code>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</code>: 优先非递归写者模式。在有写者等待时，只允许以非递归方式获取写锁，以避免写者之间发生死锁情况。</li></ul><p>通过设置读写锁的类型，可以根据应用场景选择适当的读写锁行为，以提高并发性或避免死锁问题。需要注意的是，这些取值是非标准的扩展，具体实现可能因操作系统和库版本而有所差异。在使用时，应注意兼容性和可移植性。</p><h3 id="读写锁应用示例"><a href="#读写锁应用示例" class="headerlink" title="读写锁应用示例"></a>读写锁应用示例</h3><p>读写锁应用示例如下：</p><pre><code>#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int resourceID = 0;pthread_rwlock_t myrwlock;void* read_thread(void* param)&#123;    while (true)    &#123;        //请求读锁        pthread_rwlock_rdlock(&amp;myrwlock);        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;                        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);                        pthread_rwlock_unlock(&amp;myrwlock);    &#125;        return NULL;&#125;void* write_thread(void* param)&#123;    while (true)    &#123;        //请求写锁        pthread_rwlock_wrlock(&amp;myrwlock);        ++resourceID;        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;                        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);                        pthread_rwlock_unlock(&amp;myrwlock);    &#125;        return NULL;&#125;int main()&#123;    pthread_rwlock_init(&amp;myrwlock, NULL);    //创建5个请求读锁线程    pthread_t readThreadID[5];    for (int i = 0; i &lt; 5; ++i)    &#123;        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);    &#125;        //创建一个请求写锁线程    pthread_t writeThreadID;    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);    pthread_join(writeThreadID, NULL);        for (int i = 0; i &lt; 5; ++i)    &#123;        pthread_join(readThreadID[i], NULL);    &#125;        pthread_rwlock_destroy(&amp;myrwlock);    return 0;&#125;</code></pre><p>在上述程序中创建了5个请求读锁的读线程和1个请求写锁的写线程，共享的资源是一个整形变量resourceID，我们编译并执行它以得到输出</p><pre><code>read thread ID:140575861593856, resourceID: 0read thread ID:140575878379264,resourceID: 0read thread ID:140575853201152,resourceID:Oread thread ID:140575869986560,resource1D: Oread thread ID: 140575886771968, resourceID: Oread thread ID: read thread ID: read thread ID: read thread ID:140575861593856140575886771968,resourceID: 0, resourceID:0140575878379264read thread ID: 140575869986560,resourceID:0,resourceID:0140575853201152, resourceID:0read thread ID:read thread ID: read thread ID:140575861593856140575853201152140575886771968,resourceID: , resourceID: 0,resourceID:00read thread ID:140575869986560,resourceID:0</code></pre><p>以上输出结果验证了以下两个结论。</p><ul><li>由于读写锁对象myrwlock使用了默认属性，其行为是请求读锁的线程优先获得锁，请求写锁的线程write_thread很难获得锁，因此在其结果中基本没有请求写锁线程的输出结果。</li><li>由于多个请求读锁的线程read_thread可以自由获得读锁，输出不是原子的，所以多个读线程的输出可能交替，出现“错乱”。</li></ul><p>我们将读写锁对象myrwlock的属性修改成请求写锁优先，再来试一试</p><pre><code>#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int resourceID = 0;pthread_rwlock_t myrwlock;void* read_thread(void* param)&#123;    while (true)    &#123;        //请求读锁        pthread_rwlock_rdlock(&amp;myrwlock);        std::cout &lt;&lt; &quot;read thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;                        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);                        pthread_rwlock_unlock(&amp;myrwlock);    &#125;        return NULL;&#125;void* write_thread(void* param)&#123;    while (true)    &#123;        //请求写锁        pthread_rwlock_wrlock(&amp;myrwlock);        ++resourceID;        std::cout &lt;&lt; &quot;write thread ID: &quot; &lt;&lt; pthread_self() &lt;&lt; &quot;, resourceID: &quot; &lt;&lt; resourceID &lt;&lt; std::endl;                        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);                pthread_rwlock_unlock(&amp;myrwlock);    &#125;        return NULL;&#125;int main()&#123;    pthread_rwlockattr_t attr;    pthread_rwlockattr_init(&amp;attr);    //设置成请求写锁优先    pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);    pthread_rwlock_init(&amp;myrwlock, &amp;attr);    //创建5个请求读锁线程    pthread_t readThreadID[5];    for (int i = 0; i &lt; 5; ++i)    &#123;        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);    &#125;        //创建一个请求写锁线程    pthread_t writeThreadID;    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);    pthread_join(writeThreadID, NULL);        for (int i = 0; i &lt; 5; ++i)    &#123;        pthread_join(readThreadID[i], NULL);    &#125;        pthread_rwlock_destroy(&amp;myrwlock);    return 0;&#125;</code></pre><p>由于将myrwlock设置成请求写锁优先，所以几乎都是write_thread的输出结果。</p><pre><code>read thread ID: 140122217539328, resourceID: 0read thread ID: 140122242717440, resourceID: 0read thread ID: 140122209146624, resourceID: 0write thread ID: 140122200753920, resourceID: 1read thread ID: 140122234324736, resourceID: 1write thread ID: 140122200753920, resourceID: 2write thread ID: 140122200753920, resourceID: 3write thread ID: 140122200753920, resourceID: 4write thread ID: 140122200753920, resourceID: 5write thread ID: 140122200753920, resourceID: 6write thread ID: 140122200753920, resourceID: 7write thread ID: 140122200753920, resourceID: 8write thread ID: 140122200753920, resourceID: 9write thread ID: 140122200753920, resourceID: 10write thread ID: 140122200753920, resourceID: 11write thread ID: 140122200753920, resourceID: 12write thread ID: 140122200753920, resourceID: 13read thread ID: 140122217539328, resourceID: 13write thread ID: 140122200753920, resourceID: 14write thread ID: 140122200753920, resourceID: 15write thread ID: 140122200753920, resourceID: 16write thread ID: 140122200753920, resourceID: 17write thread ID: 140122200753920, resourceID: 18write thread ID: 140122200753920, resourceID: 19write thread ID: 140122200753920, resourceID: 20write thread ID: 140122200753920, resourceID: 21write thread ID: 140122200753920, resourceID: 22write thread ID: 140122200753920, resourceID: 23</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程同步对象</title>
      <link href="/p/9ee71673.html"/>
      <url>/p/9ee71673.html</url>
      
        <content type="html"><![CDATA[<h1 id="Windows线程同步对象"><a href="#Windows线程同步对象" class="headerlink" title="Windows线程同步对象"></a>Windows线程同步对象</h1><h2 id="WaitForSingleObject与WaitForMultipleObjects函数"><a href="#WaitForSingleObject与WaitForMultipleObjects函数" class="headerlink" title="WaitForSingleObject与WaitForMultipleObjects函数"></a>WaitForSingleObject与WaitForMultipleObjects函数</h2><p>在介绍Windows线程同步对象之前，先来介绍两个与之相关的、非常重要的函数：WaitForSingleObject和WaitForMultipleObjects。<br>WaitForSingleObject函数签名如下：<br>    DWORD WaitForSingleObject(HANDLE hHandle,DWORD dwMilliseconds);</p><p>该函数的作用是等待一个内核对象，在 Windows 系统上，一个内核对象通常使用其句柄来操作。参数hHandle是需要等待的内核对象；参数dwMilliseconds是等待这个内核对象的最大时间，时间单位是毫秒，其类型是 DWORD，这是一个 unsigned long 类型。如果我们需要无限等待下去，则可以将这个参数值设置为INFINITE宏。<br>在Windows上，可以使用<code>WaitForSingleObject</code>函数等待以下常见对象：</p><table><thead><tr><th>对象类型</th><th>等待函数</th></tr></thead><tbody><tr><td>互斥体（Mutex）</td><td><code>WaitForSingleObject</code></td></tr><tr><td>临界区（Critical Section）</td><td><code>Sleep</code>（不建议使用）</td></tr><tr><td>信号量（Semaphore）</td><td><code>WaitForSingleObject</code></td></tr><tr><td>事件（Event）</td><td><code>WaitForSingleObject</code></td></tr><tr><td>线程（Thread）</td><td><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></td></tr><tr><td>进程（Process）</td><td><code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code></td></tr><tr><td>文件（File）</td><td><code>ReadFile</code>, <code>WriteFile</code>, 等等（非阻塞IO方式）</td></tr></tbody></table><p>后续会详细介绍Event、Mutex、Semaphore这三种类型的线程同步对象。这里先介绍WaitForSingleObject函数的用法<br><code>WaitForSingleObject</code>函数的返回值一般有以下类型：</p><ul><li><code>WAIT_OBJECT_0</code>: 表示等待对象成功，对象已经变为有信号状态。</li><li><code>WAIT_TIMEOUT</code>: 表示等待超时，等待的时间已经超过设定的超时时间。</li><li><code>WAIT_FAILED</code>: 表示等待失败，发生了错误。可以使用<code>GetLastError</code>函数获取详细的错误代码。</li></ul><p>需要注意的是，<code>WaitForSingleObject</code>函数是一个阻塞函数，调用它会使当前线程进入等待状态，直到被等待的对象发出信号或超时。返回值可以用于判断等待的结果，并根据需要采取相应的操作。<br>WaitForSingleObject只能“等待”单个对象，如果需要同时等待多个对象，则可以使用 WaitForMultipleObjects，除了对象的数量变多，其用法基本和 WaitForSingleObject 一样。<br>在Windows上，<code>WaitForMultipleObjects</code>函数的签名如下：</p><pre><code class="c++">DWORD WaitForMultipleObjects(  DWORD        nCount,  const HANDLE *lpHandles,  BOOL         bWaitAll,  DWORD        dwMilliseconds);</code></pre><p>该函数用于等待多个对象的信号状态，并在满足指定条件时返回。参数说明如下：</p><ul><li><code>nCount</code>: 等待的对象数量，即<code>lpHandles</code>数组中的对象数量。</li><li><code>lpHandles</code>: 指向等待对象句柄数组的指针，即要等待的对象的句柄数组。</li><li><code>bWaitAll</code>: 指定是否等待所有对象的信号状态。若为<code>TRUE</code>，则只有当所有对象都发出信号时，函数才会返回；若为<code>FALSE</code>，则只要有任何一个对象发出信号，函数就会返回。</li><li><code>dwMilliseconds</code>: 等待时间的限制，即最长等待的毫秒数。若为<code>INFINITE</code>，则表示无限等待，直到对象发出信号或函数被中断。</li></ul><p>函数返回值为<code>DWORD</code>类型，表示等待的结果。具体返回值的含义如下：</p><ul><li><code>WAIT_OBJECT_0</code> 到 <code>WAIT_OBJECT_0 + nCount-1</code>: 表示等待的对象中的某个对象已经发出信号。</li><li><code>WAIT_TIMEOUT</code>: 表示等待超时，等待的时间已经超过设定的超时时间。</li><li><code>WAIT_FAILED</code>: 表示等待失败，发生了错误。可以使用<code>GetLastError</code>函数获取详细的错误代码。</li></ul><p>需要注意的是，<code>WaitForMultipleObjects</code>函数是一个阻塞函数，调用它会使当前线程进入等待状态，直到被等待的对象之一发出信号或超时。返回值可以用于判断等待的结果，并根据需要采取相应的操作。</p><h2 id="Windows临界区对象"><a href="#Windows临界区对象" class="headerlink" title="Windows临界区对象"></a>Windows临界区对象</h2><p>在所有 Windows 资源同步对象中，CriticalSection（临界区对象，有时被翻译成“关键段”）都是最简单、易用的，能用于防止多线程同时执行其保护的那段代码（临界区代码），即临界区的代码在某一时刻只允许1个线程执行，示意图如下。<br><img src="https://s1.ax1x.com/2023/06/11/pCZ97OH.png" alt="pCZ97OH.png"></p><p>Windows没有公开CriticalSection数据结构的定义，我们一般使用如下5个API函数操作临界区对象：</p><ol><li><code>InitializeCriticalSection</code>: 用于初始化临界区对象。</li></ol><pre><code class="c++">void InitializeCriticalSection(  LPCRITICAL_SECTION lpCriticalSection);</code></pre><ol><li><code>EnterCriticalSection</code>: 用于进入临界区，即申请对临界区的访问权限。</li></ol><pre><code class="c++">void EnterCriticalSection(  LPCRITICAL_SECTION lpCriticalSection);</code></pre><ol><li><code>LeaveCriticalSection</code>: 用于离开临界区，即释放对临界区的访问权限。</li></ol><pre><code class="c++">void LeaveCriticalSection(  LPCRITICAL_SECTION lpCriticalSection);</code></pre><ol><li><code>DeleteCriticalSection</code>: 用于删除临界区对象，释放相关资源。</li></ol><pre><code class="c++">void DeleteCriticalSection(  LPCRITICAL_SECTION lpCriticalSection);</code></pre><ol><li><code>TryEnterCriticalSection</code>: 尝试进入临界区，如果能成功获取访问权限，则返回<code>TRUE</code>，否则返回<code>FALSE</code>。</li></ol><pre><code class="c++">BOOL TryEnterCriticalSection(  LPCRITICAL_SECTION lpCriticalSection);</code></pre><p>这些函数允许你使用临界区对象实现互斥访问，确保在同一时间只有一个线程可以访问被保护的临界区代码。通过调用这些函数，可以实现线程的同步和互斥，避免多个线程同时访问共享资源引发的竞态条件问题。</p><pre><code>#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;CRITICAL_SECTION g_cs;int g_number = 0;DWORD WINAPI workerThreadProc(LPVOID lpThreadParameter)&#123;    DWORD dwThreadID = GetCurrentThreadId();    while (true)    &#123;        EnterCriticalSection(&amp;g_cs);        std::cout &lt;&lt; &quot;EnterCriticalSection, ThreadID: &quot; &lt;&lt; dwThreadID &lt;&lt; std::endl;        g_number++;        SYSTEMTIME st;        //获取当前系统时间        GetLocalTime(&amp;st);        char szMsg[64] = &#123; 0 &#125;;        sprintf(szMsg, &quot;[%04d-%02d-%02d %02d:%02d:%02d:%03d] No.%d, ThreadID: %d&quot;,            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, g_number, dwThreadID);        std::cout &lt;&lt; szMsg &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;LeaveCriticalSection, ThreadID: &quot; &lt;&lt; dwThreadID &lt;&lt; std::endl;        LeaveCriticalSection(&amp;g_cs);        //睡眠1秒        Sleep(1000);    &#125;    return 0;&#125;int main()&#123;    InitializeCriticalSection(&amp;g_cs);    HANDLE hThreads[5];    for (int i = 0; i &lt; 5; ++i)    &#123;        hThreads[i] = CreateThread(NULL, 0, workerThreadProc, NULL, 0, NULL);        if (hThreads[i] == NULL)        &#123;            std::cerr &lt;&lt; &quot;Failed to create thread.&quot; &lt;&lt; std::endl;            return 1;        &#125;    &#125;    // 主线程等待子线程结束    WaitForMultipleObjects(5, hThreads, TRUE, INFINITE);    // 关闭线程句柄    for (int i = 0; i &lt; 5; ++i)    &#123;        CloseHandle(hThreads[i]);    &#125;    DeleteCriticalSection(&amp;g_cs);    return 0;&#125;</code></pre><p>当其中1个线程离开临界区时，即使此时有其他线程在这个临界区外面等待，由于线程调度的不确定性，此时正在等待的线程也不会有先进入临界区的优势，它和刚离开这个临界区的线程再次竞争进入临界区的机会均等。我们来看一张图，如下所示。</p><p><img src="https://s1.ax1x.com/2023/06/11/pCZC9XQ.png" alt="pCZC9XQ.png"><br>如上所示将线程函数的执行流程绘制成一个流程图，两个线程竞争进入临界区可能存在如下情形。<br>情形一：线程A被唤醒并获得CPU时间片进入临界区，执行流程①；执行临界区代码输出→线程 B 获得 CPU 时间片，执行流程②；失去 CPU 时间片，进入休眠→线程 A执行完临界区代码，离开临界区后执行流程⑤；失去CPU时间片，进入休眠→线程B被唤醒，获得 CPU时间片执行流程③、①，执行临界区代码输出。在这种情形下，线程A和线程B会轮流进入临界区执行代码。<br>情形二：线程A被唤醒并获得CPU时间片进入临界区，执行流程①；执行临界区代码输出→线程 B 获得 CPU 时间片，执行流程③；执行流程②，在临界区外面失去 CPU时间片，进入休眠→线程 A 执行完临界区代码，离开临界区后执行流程④、①。在这种情形下，会出现某个线程连续两次甚至更多次进入临界区执行代码。<br>如果某个线程在尝试进入临界区时因无法阻塞而进入睡眠状态，则其他线程离开这个临界区后，之前因为这个临界区而阻塞的线程可能会被唤醒并再次竞争，也可能不被唤醒。但是存在这样一种特例，假设现在存在两个线程 A和 B，线程 A是离开临界区的线程，且不需要再次进入临界区，那么线程 B在被唤醒时一定可以进入临界区。线程 B 从睡眠状态被唤醒，涉及一次线程的切换，有时这种开销是不必要的。我们可以让线程 B 执行一个简单的循环，等待一段时间后再进入临界区，而不是先睡眠再唤醒。前者与后者相比，执行这个循环的消耗更小。这就是自旋。在这种情形下，Windows 提供了另一个初始<br>化临界区的函数 InitializeCriticalSectionAndSpinCount，这个函数比 InitializeCriticalSection多了一次自旋：<br><code>InitializeCriticalSectionAndSpinCount</code>是一个用于初始化临界区并设置自旋计数的函数。它的函数签名如下：</p><pre><code class="cpp">BOOL InitializeCriticalSectionAndSpinCount(  LPCRITICAL_SECTION lpCriticalSection,  DWORD             dwSpinCount);</code></pre><p>参数说明：</p><ul><li><code>lpCriticalSection</code>：指向要初始化的临界区对象的指针。</li><li><code>dwSpinCount</code>：自旋计数，利用自旋来避免线程因为等待而进入睡眠并再次被唤醒，消除线程上下面切换带来的消耗，提高效率。当然，在实际开发中，这种方式是靠不住的，线程调度是操作系统内核的策略，应用层上的应用不应该假设线程的调度策略按预想的来执行，但是理解线程与临界区之间的原理有助于我们编写更高效的代码。</li></ul><p><code>InitializeCriticalSectionAndSpinCount</code>函数用于初始化临界区对象，并为它设置一个自旋计数。自旋计数是为了减少线程切换带来的开销，当临界区被其他线程占用时，当前线程会进行自旋操作，尝试获取临界区的控制权，而不是立即进入等待状态。</p><p>这个函数在初始化临界区时还会分配一些内部资源，并设置一些状态信息，因此在使用临界区对象之前，必须先调用这个函数进行初始化。</p><p>以下是一个示例代码，演示了如何使用<code>InitializeCriticalSectionAndSpinCount</code>函数初始化临界区对象：</p><pre><code class="cpp">#include &lt;windows.h&gt;#include &lt;iostream&gt;CRITICAL_SECTION g_cs;int main()&#123;    // 初始化临界区并设置自旋计数为1000    if (!InitializeCriticalSectionAndSpinCount(&amp;g_cs, 1000))    &#123;        std::cerr &lt;&lt; &quot;Failed to initialize critical section.&quot; &lt;&lt; std::endl;        return 1;    &#125;    // 使用临界区进行线程同步操作    // 删除临界区    DeleteCriticalSection(&amp;g_cs);    return 0;&#125;</code></pre><p>在这个示例中，我们通过调用<code>InitializeCriticalSectionAndSpinCount</code>函数初始化了临界区对象<code>g_cs</code>，并设置自旋计数为1000。在实际使用中，你可以根据具体的场景需求调整自旋计数的值。最后，在使用完临界区后，需要调用<code>DeleteCriticalSection</code>函数来删除临界区。</p><h2 id="Windows-Event对象"><a href="#Windows-Event对象" class="headerlink" title="Windows Event对象"></a>Windows Event对象</h2><p>创建Event对象的Windows API函数签名如下：</p><pre><code class="cpp">HANDLE CreateEvent(  LPSECURITY_ATTRIBUTES lpEventAttributes,  BOOL                  bManualReset,  BOOL                  bInitialState,  LPCTSTR               lpName);</code></pre><p>参数说明：</p><ul><li><code>lpEventAttributes</code>：指向SECURITY_ATTRIBUTES结构的指针，用于设置事件对象的安全属性，通常为NULL表示默认安全属性。</li><li><code>bManualReset</code>：指定事件对象是手动复位还是自动复位。如果为TRUE，表示手动复位，即在触发事件后需要手动调用ResetEvent函数将事件复位；如果为FALSE，表示自动复位，即在有线程等待事件后自动将事件复位。</li><li><code>bInitialState</code>：指定事件对象的初始状态。如果为TRUE，表示事件初始为有信号状态（触发状态）；如果为FALSE，表示事件初始为无信号状态（非触发状态）。</li><li><code>lpName</code>：事件对象的名称，用于在系统中唯一标识事件对象，可以为NULL表示匿名事件。</li></ul><p>函数返回值：</p><ul><li>如果函数调用成功，返回一个有效的事件对象句柄；</li><li>如果函数调用失败，返回值为NULL。可以通过调用GetLastError函数获取具体的错误代码。</li></ul><p>创建Event对象时，可以根据需要设置事件对象的属性，包括安全属性、手动复位或自动复位、初始状态等。创建完成后，可以使用返回的事件对象句柄来操作事件对象，如等待事件的触发、设置事件的状态等。</p><p>以下是一个示例代码，演示了如何使用CreateEvent函数创建一个事件对象：</p><pre><code class="cpp">#include &lt;windows.h&gt;#include &lt;iostream&gt;int main()&#123;    // 创建一个自动复位的初始状态为无信号的事件对象    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);    if (hEvent == NULL)    &#123;        std::cerr &lt;&lt; &quot;Failed to create event object.&quot; &lt;&lt; std::endl;        return 1;    &#125;    // 使用事件对象进行线程同步操作    // 关闭事件对象句柄    CloseHandle(hEvent);    return 0;&#125;</code></pre><p>在这个示例中，我们通过调用CreateEvent函数创建了一个事件对象，设置了自动复位、初始状态为无信号。创建成功后，我们可以使用事件对象进行线程同步操作。最后，通过调用CloseHandle函数关闭事件对象句柄，释放相关资源。</p><p>来看一个具体的例子，假设现在有两个线程，其中一个是主线程，主线程等待工作线程执行某一项耗时的任务后，将任务结果显示出来。</p><pre><code>#include &lt;Windows.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;bool bTaskCompleted = false;std::string TaskResult;DWORD WINAPI WorkerThreadProc(LPVOID lpThreadParameter)&#123;    // 使用Sleep函数模拟一个耗时的操作    // 睡眠3秒    Sleep(3000);    TaskResult = &quot;Task completed&quot;;    bTaskCompleted = true;    return 0;&#125;int main()&#123;    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    while (true)    &#123;        if (bTaskCompleted)        &#123;            std::cout &lt;&lt; TaskResult &lt;&lt; std::endl;            break;        &#125;        std::cout &lt;&lt; &quot;Task is in progress...&quot; &lt;&lt; std::endl;    &#125;    CloseHandle(hWorkerThread);    return 0;&#125;</code></pre><p>在以上代码中，主线程为了等待工作线程完成任务后获取结果，使用了一个循环去不断查询任务完成标识，这是一种低效的做法：等待的线程（主线程）做了很多无用功，对CPU时间片也是一种浪费。我们使用Event对象改写以上代码</p><pre><code>#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;bool bTaskCompleted = false;std::string TaskResult;HANDLE hTaskEvent = NULL;DWORD WINAPI WorkerThreadProc(LPVOID lpThreadParameter)&#123;    // 使用Sleep函数模拟一个耗时的操作    // 睡眠3秒    Sleep(3000);    TaskResult = &quot;Task completed&quot;;    bTaskCompleted = true;    // 设置事件信号    SetEvent(hTaskEvent);    return 0;&#125;int main()&#123;    // 创建一个命名的手动重置、初始为无信号的事件对象    hTaskEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    DWORD dwResult = WaitForSingleObject(hTaskEvent, INFINITE);    if (dwResult == WAIT_OBJECT_0)    &#123;        std::cout &lt;&lt; TaskResult &lt;&lt; std::endl;    &#125;    CloseHandle(hWorkerThread);    CloseHandle(hTaskEvent);    return 0;&#125;</code></pre><p>在以上代码中，主线程调用WaitForSingleObject函数时会被阻塞，等待事件对象的信号。这个阻塞时间可以用来做其他事情，例如处理其他任务或等待其他资源的就绪。一旦工作线程完成任务并调用了SetEvent函数，事件对象会被设置为有信号状态，主线程会立即得到通知，从WaitForSingleObject处返回。此时任务已经完成，可以获取任务结果。<br>在实际开发中，我们可以利用等待时间来处理其他任务或进行其他操作，而不必一直等待事件对象的信号。只需要在需要时检测事件对象的信号即可。<br>此外，Event对象具有以下两个显著特点：</p><ol><li>与临界区对象（以及互斥对象）相比，Event对象不会使持有者线程成为其所有者（owner），因此Event对象可以同时唤醒多个等待的工作线程。</li><li>手动重置的Event对象一旦变为有信号状态，其信号不会丢失。即使某个线程在Event对象变为有信号状态之前没有调用WaitForSingleObject等待该Event对象的信号，而是在之后才调用，仍然能检测到事件的有信号状态，不会丢失信号。这与后面要介绍的条件变量（Condition Variable）的行为不同，条件变量可能会丢失信号。</li></ol><h2 id="Windows-Mutex对象"><a href="#Windows-Mutex对象" class="headerlink" title="Windows Mutex对象"></a>Windows Mutex对象</h2><p>Windows中的Mutex（Mmutual Exclusive，互斥体）对象在同一时刻最多只能属于1个线程，也可以也不属于任何线程。获得Mutex对象的线程成为该Mutex的拥有者（owner）。我们可以在创建 Mutex 对象时设置 Mutex 是否属于创建它的线程，其他线程如果希望获得该Mutex，则可以调用WaitForSingleObject进行申请。创建Mutex的API是CreateMutex，其函数签名如下：</p><pre><code class="cpp">HANDLE CreateMutex(  LPSECURITY_ATTRIBUTES lpMutexAttributes,  BOOL                  bInitialOwner,  LPCTSTR               lpName);</code></pre><ul><li><code>lpMutexAttributes</code>: 指向<code>SECURITY_ATTRIBUTES</code>结构的指针，用于设置创建的互斥对象的安全属性。如果为NULL，则互斥对象不能被继承。</li><li><code>bInitialOwner</code>: 指定互斥对象的初始所有权状态。如果为<code>TRUE</code>，则创建的互斥对象被创建线程所拥有；如果为<code>FALSE</code>，则创建的互斥对象没有拥有者。</li><li><code>lpName</code>: 互斥对象的名称。可以使用名称来标识和共享互斥对象。如果为<code>NULL</code>，则创建一个匿名互斥对象。</li></ul><p>函数返回一个<code>HANDLE</code>类型的句柄，表示创建的互斥对象。如果创建失败，返回值为<code>NULL</code>。</p><p>当一个线程不再需要该 Mutex 时，可以使用 ReleaseMutex 函数释放 Mutex，让其他需要等待该Mutex的线程有机会获得该Mutex。<br>ReleaseMutex函数签名如下：</p><pre><code class="cpp">BOOL ReleaseMutex(  HANDLE hMutex);</code></pre><ul><li><code>hMutex</code>: 要释放的互斥对象的句柄。</li></ul><p>函数用于释放指定的互斥对象。如果成功释放互斥对象，则返回值为<code>TRUE</code>；如果失败，则返回值为<code>FALSE</code>。</p><pre><code class="cpp">#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;HANDLE g_hMutex = NULL;int g_iResource = 0;DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)&#123;    DWORD dwThreadID = GetCurrentThreadId();    while (true)    &#123;        if (WaitForSingleObject(g_hMutex, 1000) == WAIT_OBJECT_0)        &#123;            g_iResource++;            std::cout &lt;&lt; &quot;Thread: &quot; &lt;&lt; dwThreadID &lt;&lt; &quot; becomes mutex owner, ResourceNo: &quot; &lt;&lt; g_iResource &lt;&lt; std::endl;            ReleaseMutex(g_hMutex);        &#125;        Sleep(1000);    &#125;    return 0;&#125;int main()&#123;    // 创建一个匿名的Mutex对象并设置在默认情况下主线程不拥有该Mutex    g_hMutex = CreateMutex(NULL, FALSE, NULL);    HANDLE hWorkerThreads[5];    for (int i = 0; i &lt; 5; ++i)    &#123;        hWorkerThreads[i] = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    &#125;    for (int i = 0; i &lt; 5; ++i)    &#123;        // 等待工作线程退出        WaitForSingleObject(hWorkerThreads[i], INFINITE);    &#125;    for (int i = 0; i &lt; 5; ++i)    &#123;        CloseHandle(hWorkerThreads[i]);    &#125;    CloseHandle(g_hMutex);    return 0;&#125;</code></pre><p>以上代码创建了一个Mutex对象并在默认情况下主线程不拥有该Mutex。然后创建了5个工作线程，在每个线程中通过<code>WaitForSingleObject</code>等待获取Mutex的所有权，一旦获得所有权，就增加资源计数并输出信息。完成后释放Mutex的所有权。主线程等待工作线程退出，并关闭线程句柄和Mutex句柄。</p><h2 id="Windows-Semaphore对象"><a href="#Windows-Semaphore对象" class="headerlink" title="Windows Semaphore对象"></a>Windows Semaphore对象</h2><p>Semaphore 也是 Windows 多线程同步常用的对象之一。与上面介绍的 Event、Mutex不同，信号量存在一个资源计数的概念。Event对象虽然可以同时唤醒多个线程，却不能精确地控制同时唤醒指定数量的线程，而 Semaphore 能。创建 Semaphore 对象的 API 函数签名如下</p><pre><code class="cpp">#include &lt;Windows.h&gt;HANDLE CreateSemaphore(  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,  LONG                  lInitialCount,  LONG                  lMaximumCount,  LPCSTR                lpName);</code></pre><p><code>CreateSemaphore</code>函数用于创建一个信号量对象，并返回一个句柄。它的参数如下：</p><ul><li><code>lpSemaphoreAttributes</code>: 指向SECURITY_ATTRIBUTES结构的指针，用于设置信号量对象的安全属性。可以为NULL。</li><li><code>lInitialCount</code>: 信号量的初始计数值，表示可用的资源数量。假设初始资源数量为 2，如果有 5个线程正在调用WaitForSingleObject函数等待该信号量，则会有两个线程被唤醒，每调用一次WaitForSingleObject获得Semaphore对象，该对象的资源计数就会减少1。</li><li><code>lMaximumCount</code>: 信号量的最大计数值，表示资源的最大数量。如果使用ReleaseSemaphore不断增加资源计数，资源数量最大不能超过这个值，则这个值必须大于0</li><li><code>lpName</code>: 信号量对象的名称，可以为NULL。Semaphore对象也是可以通过名称跨进程共享的，如果不需要设置名称，则可以将该参数设置为 NULL，设置了名称的Semaphore对象被称为具名信号量，反之被称为匿名信号量。</li><li>返回值：在函数调用成功时返回Semaphore对象的句柄，反之返回NULL。</li></ul><p>创建成功后，<code>CreateSemaphore</code>函数会返回一个信号量对象的句柄，用于后续操作。</p><p>注意：信号量对象的计数值范围为0到<code>lMaximumCount</code>之间。创建时的初始计数值应小于等于最大计数值。</p><p>创建信号量对象后，可以使用以下函数进行操作：</p><ul><li><p><code>WaitForSingleObject</code>: 等待信号量对象的计数值变为大于0，并将计数值减一。</p></li><li><p><code>ReleaseSemaphore</code>: 增加信号量对象的计数值。</p><pre><code class="cpp">#include &lt;Windows.h&gt;BOOL ReleaseSemaphore(HANDLE hSemaphore,LONG   lReleaseCount,LPLONG lpPreviousCount);</code></pre><p>  <code>ReleaseSemaphore</code>函数用于增加信号量对象的计数值，表示释放了一定数量的资源。它的参数如下：</p><ul><li>参数hSemaphore是需要操作的信号量句柄</li><li>参数lReleaseCount是需要增加的资源数量。</li><li>参数 lpPreviousCount 是一个 long 类型的指针，在函数执行成功后，返回上一次资源的数量，如果用不到该参数，则可以将其设置为NULL。</li><li>函数调用成功后，信号量对象的计数值会增加<code>lReleaseCount</code>，表示有新的资源可用。如果指定了<code>lpPreviousCount</code>参数，那么之前的计数值会被写入该参数指向的内存地址。</li><li>注意：<code>lReleaseCount</code>的值应为非负数，且不得超过信号量对象的最大计数值。</li><li>如果函数调用成功，返回值为非零；如果调用失败，返回值为零。</li></ul></li><li><p><code>CloseHandle</code>: 关闭信号量对象的句柄，释放资源。</p></li></ul><p>使用信号量可以实现对有限资源的控制和同步，控制同时访问的线程数量。<br>Windows信号量与Linux信号量的用法基本相同，来看一个具体的例子。<br>假设现在有一个即时通信程序，网络线程不断地从网络上收到聊天消息，其他4个消息处理线程需要对收到的聊天信息进行加工。我们需要根据当前消息的数量唤醒其中 4个工作线程中的一个或多个，这正是信号量使用的典型案例，代码如下：</p><pre><code class="cpp">#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;time.h&gt;HANDLE g_hMsgSemaphore = NULL;std::list&lt;std::string&gt; g_listChatMsg;// 保护g_listChatMsg的临界区对象CRITICAL_SECTION g_CsMsg;DWORD stdcall NetThreadProc(LPVOID lpThreadParameter)&#123;    int nMsgIndex = 0;    while (true)    &#123;        EnterCriticalSection(&amp;g_CsMsg);        // 随机产生1~4条消息        int count = rand() % 4 + 1;        for (int i = 0; i &lt; count; ++i)        &#123;            nMsgIndex++;            SYSTEMTIME st;            GetLocalTime(&amp;st);            char szChatMsg[64];            sprintf(szChatMsg, &quot;[ %04d-%02d-%02d %02d:%02d:%02d:%03d ] A new msg, No.%d&quot;,                    st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, nMsgIndex);            g_listChatMsg.emplace_back(szChatMsg);        &#125;        LeaveCriticalSection(&amp;g_CsMsg);        // 增加count个资源数量        ReleaseSemaphore(g_hMsgSemaphore, count, NULL);    &#125;    return 0;&#125;DWORD stdcall ParseThreadProc(LPVOID lpThreadParameter)&#123;    DWORD dwThreadID = GetCurrentThreadId();    std::string current;    while (true)    &#123;        if (WaitForSingleObject(g_hMsgSemaphore, INFINITE) == WAIT_OBJECT_0)        &#123;            EnterCriticalSection(&amp;g_CsMsg);            if (!g_listChatMsg.empty())            &#123;                current = g_listChatMsg.front();                g_listChatMsg.pop_front();                std::cout &lt;&lt; &quot;Thread: &quot; &lt;&lt; dwThreadID &lt;&lt; &quot; parse msg: &quot; &lt;&lt; current &lt;&lt; std::endl;            &#125;            LeaveCriticalSection(&amp;g_CsMsg);        &#125;    &#125;    return 0;&#125;int main()&#123;    // 初始化随机数种子    srand(time(NULL));    InitializeCriticalSection(&amp;g_CsMsg);    // 创建一个匿名的Semaphore对象，初始资源数量为0    g_hMsgSemaphore = CreateSemaphore(NULL, 0, INT_MAX, NULL);    HANDLE hNetThread = CreateThread(NULL, 0, NetThreadProc, NULL, 0, NULL);    HANDLE hWorkerThreads[4];    for (int i = 0; i &lt; 4; ++i)    &#123;        hWorkerThreads[i] = CreateThread(NULL, 0, ParseThreadProc, NULL, 0, NULL);    &#125;    for (int i = 0; i &lt; 4; ++i)    &#123;        // 等待工作线程退出        WaitForSingleObject(hWorkerThreads[i], INFINITE);        CloseHandle(hWorkerThreads[i]);    &#125;    WaitForSingleObject(hNetThread, INFINITE);    CloseHandle(hNetThread);    CloseHandle(g_hMsgSemaphore);    DeleteCriticalSection(&amp;g_CsMsg);    return 0;&#125;</code></pre><p>在以上代码中，网络线程每次都随机产生 1～4 条聊天消息放入消息容器g_listChatMsg 中，然后根据当前新产生的消息数量调用ReleaseSemaphore 增加相应的资源计数，这样就有相应的处理线程被唤醒，从容器g_listChatMsg中取出消息进行处理。注意：由于会涉及多个线程操作消息容器g_listChatMsg，所以这里使用了一个临界区对象g_csMsg对其进行保护。</p><h2 id="Windows读写锁"><a href="#Windows读写锁" class="headerlink" title="Windows读写锁"></a>Windows读写锁</h2><p>与Linux读写锁的原理相同，Windows系统也有读写锁。Windows系统上的读写锁叫作Slim Reader&#x2F;Writer （SRW） Locks，对应的数据类型叫作SRWLOCK，微软没有公开这个数据结构的细节，只提供了一些API函数对其进行操作：<br>是的，Windows系统上的读写锁被称为Slim Reader&#x2F;Writer (SRW) Locks。SRWLOCK是相应的数据类型，微软提供了一些API函数来操作它。以下是SRW锁的常用API函数：</p><ol><li><strong>InitializeSRWLock</strong>：用于初始化SRW锁对象。</li></ol><pre><code class="cpp">void InitializeSRWLock(PSRWLOCK SRWLock);</code></pre><ol start="2"><li><strong>AcquireSRWLockExclusive</strong>：以独占模式获取SRW锁，用于写操作。</li></ol><pre><code class="cpp">void AcquireSRWLockExclusive(PSRWLOCK SRWLock);</code></pre><ol start="3"><li><strong>TryAcquireSRWLockExclusive</strong>：尝试以独占模式获取SRW锁，如果锁不可用则立即返回。</li></ol><pre><code class="cpp">BOOL TryAcquireSRWLockExclusive(PSRWLOCK SRWLock);</code></pre><ol start="4"><li><strong>ReleaseSRWLockExclusive</strong>：释放已获取的独占模式的SRW锁。</li></ol><pre><code class="cpp">void ReleaseSRWLockExclusive(PSRWLOCK SRWLock);</code></pre><ol start="5"><li><strong>AcquireSRWLockShared</strong>：以共享模式获取SRW锁，用于读操作。</li></ol><pre><code class="cpp">void AcquireSRWLockShared(PSRWLOCK SRWLock);</code></pre><ol start="6"><li><strong>TryAcquireSRWLockShared</strong>：尝试以共享模式获取SRW锁，如果锁不可用则立即返回。</li></ol><pre><code class="cpp">BOOL TryAcquireSRWLockShared(PSRWLOCK SRWLock);</code></pre><ol start="7"><li><strong>ReleaseSRWLockShared</strong>：释放已获取的共享模式的SRW锁。</li></ol><pre><code class="cpp">void ReleaseSRWLockShared(PSRWLOCK SRWLock);</code></pre><p>需要注意的是，SRW锁是一种轻量级的同步机制，适用于较简单的读写场景，但不支持递归锁。如果需要更复杂的同步需求，例如递归锁或条件变量，可以使用CriticalSection、Mutex或Condition Variable等其他同步对象。<br>在Windows系统上，可以使用如下语法初始化一个SRWLOCK对象：</p><pre><code class="cpp">SRWLOCK srwLock = SRWLOCK_INIT;</code></pre><p>此语法使用了宏SRWLOCK_INIT，它是用于初始化SRWLOCK对象的常量。这样就可以在声明SRWLOCK对象的同时进行初始化操作，使其准备好在后续的使用中进行读写操作的同步。<br>与临界区对象不同的是，Windows 不需要显式销毁一个读写锁对象，因此不存在DeleteSRWLock这样的函数用于销毁一个读写锁。</p><h2 id="Windows条件变量"><a href="#Windows条件变量" class="headerlink" title="Windows条件变量"></a>Windows条件变量</h2><p>和Linux的条件变量作用一样，Windows系统在Windows XP和Windows Server 2003版本以后也引入了条件变量（言下之意，Windows XP及以前的版本不支持条件变量）。在 Windows中代表条件变量的结构体对象是 CONDITION_VARIABLE，微软并没有给出对这个结构的具体定义，只提供了一系列API函数去操作这个对象。可以使用如下API函数初始化一个Windows条件变量：</p><pre><code class="cpp">VOID InitializeConditionVariable(CONDITION_VARIABLE* ConditionVariable);</code></pre><p>该函数用于初始化一个条件变量对象。传入的参数是指向条件变量对象的指针，函数将会对该对象进行初始化，使其准备好在后续的使用中进行条件等待和唤醒操作。条件变量的类型是CONDITION_VARIABLE，需要事先定义一个CONDITION_VARIABLE类型的变量，然后将其地址作为参数传递给InitializeConditionVariable函数。</p><p>也可以使用如下语法初始化一个条件变量对象：</p><pre><code class="cpp">CONDITION_VARIABLE ConditionVariable = CONDITION_VARIABLE_INIT;</code></pre><p>这种语法使用了条件变量对象的静态初始化方式。通过将<code>CONDITION_VARIABLE_INIT</code>赋值给条件变量对象，可以将其初始化为默认值。这种方式不需要调用特定的函数进行初始化，而是直接将默认值赋给条件变量对象。<br>这种方式初始化的条件变量对象仅适用于静态全局变量或静态局部变量。对于动态分配的条件变量对象，仍然需要使用<code>InitializeConditionVariable</code>函数进行初始化。</p><p>与临界区（CriticalSection）、读写锁（Slim Reader&#x2F;WriterLocks）一样，Windows的条件变量也是user-mode对象，不可以跨进程共享</p><p>在Windows上使用条件变量时需要配合一个临界区或读写锁，使用临界区的方式和Linux 的条件变量类似，等待资源变为可用的线程调用 SleepConditionVariableCS（）或SleepConditionVariableSRW函数进行等待，这两个函数签名如下：</p><ol><li><p>SleepConditionVariableCS:</p><pre><code class="cpp">BOOL SleepConditionVariableCS(    PCONDITION_VARIABLE ConditionVariable,    PCRITICAL_SECTION CriticalSection,    DWORD dwMilliseconds);</code></pre><p>此函数在临界区的保护下等待条件变量满足。当调用此函数时，线程会释放临界区，并进入睡眠状态，直到条件变量满足或超过指定的时间。线程被唤醒后，会重新获取临界区并继续执行。</p></li><li><p>SleepConditionVariableSRW:</p><pre><code class="cpp">BOOL SleepConditionVariableSRW(    PCONDITION_VARIABLE ConditionVariable,    PSRWLOCK SRWLock,    DWORD dwMilliseconds,    ULONG Flags);</code></pre><p>此函数在读写锁的保护下等待条件变量满足。当调用此函数时，线程会释放读写锁，并进入睡眠状态，直到条件变量满足或超过指定的时间。线程被唤醒后，会重新获取读写锁并继续执行。</p></li></ol><p>这两个函数在等待条件变量时会自动释放对应的临界区或读写锁，并在被唤醒时重新获取。通过配合临界区或读写锁的使用，可以实现线程间的同步和等待机制。在调用SleepConditionVariableCS或SleepConditionVariableSRW函数之前，线程必须持有相应的临界区或读写锁对象，以确保在等待条件变量时不会发生竞争条件。在调用SleepConditionVariableCS或SleepConditionVariableSRW函数后，线程会进入睡眠状态，并释放对应的临界区或读写锁对象，以便其他线程能够访问临界区或读写锁保护的资源。这样可以避免多个线程同时访问资源，确保同步性。当条件变量满足时，唤醒等待的线程后，线程会重新获取相应的临界区或读写锁对象，以便继续执行操作。在操作完成后，如果希望其他线程可以继续操作资源，则需要释放对应的临界区或读写锁对象，使其变为可用状态。这种使用条件变量的方式可以有效地控制线程的等待和唤醒，确保多个线程之间的同步和资源访问的正确性。</p><p>等待资源变为可用的线程在调用SleepConditionVariableCS或者SleepConditionVariableSRW函数后，释放其持有的临界区或读写锁对象，这样其他线程就有机会对共享资源进行修改了。这些线程通过修改共享资源让资源变为可用，可以调用 WakeConditionVariable 或WakeAllConditionVariable唤醒调用SleepConditionVariableCS或者SleepConditionVariableSRW函数等待的线程，前者只唤醒一个等待的线程，后者唤醒所有等待的线程。这两个函数签名如下</p><ol><li>SleepConditionVariableCS：</li></ol><pre><code class="cpp">BOOL SleepConditionVariableCS(  PCONDITION_VARIABLE ConditionVariable,  PCRITICAL_SECTION   CriticalSection,  DWORD               dwMilliseconds);</code></pre><p>该函数使用临界区作为同步对象，它等待在指定的条件变量上，直到满足条件或者超时。如果条件满足，则函数立即返回；如果超时，则函数返回FALSE。只有一个等待线程会被唤醒。</p><ol><li>SleepConditionVariableSRW：</li></ol><pre><code class="cpp">VOID SleepConditionVariableSRW(  PCONDITION_VARIABLE ConditionVariable,  PSRWLOCK            SRWLock,  DWORD               dwMilliseconds,  ULONG               Flags);</code></pre><p>该函数使用读写锁作为同步对象，它等待在指定的条件变量上，直到满足条件或者超时。如果条件满足，则函数立即返回；如果超时，则函数返回。它会唤醒所有等待的线程，使它们都有机会获取锁并检查条件。</p><p>需要注意的是，SleepConditionVariableSRW函数没有返回值，而是通过参数Flags来指定一些行为选项。<br>这两个函数可以根据具体的需求选择合适的函数来进行线程等待和唤醒的操作。</p><h2 id="在多进程之间共享线程同步对象"><a href="#在多进程之间共享线程同步对象" class="headerlink" title="在多进程之间共享线程同步对象"></a>在多进程之间共享线程同步对象</h2><p>在 Windows 上，对某些程序，无论双击其启动图标几次都只会启动一个实例，我们把这类程序叫作单实例程序（Single Instance）。我们可以利用命名的线程资源同步对象实现这个效果<br>这段代码是一个 Windows 程序的入口函数（WinMain），用于处理程序的启动和实例控制。以下是对代码的解释和补充说明：</p><pre><code class="cpp">int APIENTRY_tWinMain(_In_ HINSTANCE hInstance, In_ HINSTANCE hPrevInstance, _In_ LPTSTR lpcmdLine, In_ int nCmdShow)&#123;    // 省略无关代码        if (CheckInstance())    &#123;        HWND hwndPre = FindWindow(szWindowClass, NULL);        if (IsWindow(hwndPre))        &#123;            if (IsIconic(hwndPre))            &#123;                ::SendMessage(hwndPre, WM_SYSCOMMAND, SC_RESTORE | HTCAPTION, 0);            &#125;            ::SetWindowPos(hwndPre, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);            ::SetForegroundWindow(hwndPre);            ::SetFocus(hwndPre);        &#125;        return 0;    &#125;        // 程序运行逻辑        return 0;&#125;</code></pre><p>以上代码在 WinMain 函数开始处先检查是否存在已运行的程序实例，如果存在，则找到运行中的实例程序主窗口并激活。这就是我们看到最小化很多单例程序后双击该程序图标会重新激活最小化程序的实现原理。具体如下：</p><ol><li><p><code>CheckInstance()</code> 函数用于检测是否已经存在程序实例在运行。该函数的具体实现没有提供，可能是通过某种方式来判断程序实例是否已经存在。</p></li><li><p>如果已经存在程序实例，则执行以下操作：</p><ul><li>使用 <code>FindWindow()</code> 函数根据窗口类名 <code>szWindowClass</code>（变量未给出）来查找已经存在的窗口。</li><li>使用 <code>IsWindow()</code> 函数检查找到的窗口句柄是否有效。</li><li>如果窗口处于最小化状态（使用 <code>IsIconic()</code> 函数判断），则通过发送 <code>WM_SYSCOMMAND</code> 消息将窗口还原到正常状态（<code>SC_RESTORE</code>）并激活窗口（<code>HTCAPTION</code>）。</li><li>使用 <code>SetWindowPos()</code> 函数将窗口移动到最前面，并激活窗口。<code>SWP_NOMOVE</code>、<code>SWP_NOSIZE</code>、<code>SWP_SHOWWINDOW</code> 和 <code>SWP_NOACTIVATE</code> 是函数的参数，用于指定窗口的位置、大小和行为。</li><li>使用 <code>SetForegroundWindow()</code> 和 <code>SetFocus()</code> 函数将窗口设置为前台窗口并获得焦点。</li></ul></li><li><p>如果不存在程序实例，则执行程序的运行逻辑。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/p/28384.html"/>
      <url>/p/28384.html</url>
      
        <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote><p>想着凭自己理解去面试而不背面经只会一败涂地 初面挂后感</p></blockquote><h2 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h2><ul><li>互斥条件<ul><li>临界资源是独占资源，进程应互斥且排他的使用这些资源。</li></ul></li><li>占有和等待条件<ul><li>进程在请求资源得不到满足而等待时，不释放已占有资源。</li></ul></li><li>不剥夺条件<ul><li>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</li></ul></li><li>循环等待条件<ul><li>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li></ul></li></ul><h2 id="死锁解决的方法"><a href="#死锁解决的方法" class="headerlink" title="死锁解决的方法"></a>死锁解决的方法</h2><p>主要有一下三种方法：</p><ul><li>死锁防止</li><li>死锁避免</li><li>死锁检测和恢复</li></ul><h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p><strong>破坏互斥条件</strong><br>使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。<br>只读数据文件、磁盘等软硬件资源均可采用这种办法管理；<br>但是许多资源是独占性资源，如可写文件、键盘等只能互斥的占有；<br>所以这种做法在许多场合是不适用的。</p><p><strong>破坏占有和等待条件</strong><br>采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。<br>实现简单，但是严重的减低了资源利用率。<br>因为在每个进程占有的资源中，有些资源在运行后期使用，有些资源在例外情况下才被使用，可能会造成进程占有一些几乎用不到的资源，而使其他想使用这些资源的进程等待。</p><p><strong>破坏不剥夺条件</strong><br>剥夺调度能够防止死锁，但是只适用于内存和处理器资源。</p><ul><li>方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。</li><li>方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。</li></ul><p><strong>破坏循环等待条件</strong><br>给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。<br>采用层次分配策略，将系统中所有的资源排列到不同层次中<br>一个进程得到某层的一个资源后，只能申请较高一层的资源<br>当进程释放某层的一个资源时，必须先释放所占有的较高层的资源<br>当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源</p><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。<br>在程序运行时避免发生死锁。<br><strong>单个资源的银行家算法</strong><br>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。<br>注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。<br>检查一个状态是否安全的算法如下：<br>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。<br>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。<br>重复以上两步，直到所有进程都标记为终止，则状态时安全的。<br>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>对资源的分配加以适当限制可防止或避免死锁发生，但不利于进程对系统资源的充分共享。<br>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ul><li>如果进程 - 资源分配图中无环路，此时系统没有发生死锁。</li><li>如果进程 - 资源分配图中有环路，则可分为以下两种情况：<ul><li>每种资源类中仅有一个资源，则系统发生了死锁。此时，环路是系统发生死锁的充分必要条件，环路中的进程就是死锁进程。</li><li>每种资源类中有多个资源，则环路的存在只是产生死锁的必要不充分条件，系统未必会发生死锁。</li></ul></li></ul><p><strong>每种资源类中仅有一个资源的死锁检测</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>每种资源类中有多个资源的死锁检测</strong></p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><p>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>如果没有这样一个进程，算法终止。</p><h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><ul><li>资源剥夺法<ul><li>剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</li></ul></li><li>进程回退法<ul><li>根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</li></ul></li><li>进程撤销法<ul><li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li><li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li><li>可选择符合下面条件之一的先撤销： <ul><li>CPU消耗时间最少者</li><li>产生的输出量最小者</li><li>预计剩余执行时间最长者 </li><li>分得的资源数量最少者或优先级最低者</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纤程（Fiber）与协程（Routine）</title>
      <link href="/p/932d7faf.html"/>
      <url>/p/932d7faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="纤程（Fiber）与协程（Routine）"><a href="#纤程（Fiber）与协程（Routine）" class="headerlink" title="纤程（Fiber）与协程（Routine）"></a>纤程（Fiber）与协程（Routine）</h1><h2 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h2><p>纤程（Fiber）是 Windows 中的概念。当我们需要异步执行一些任务时，常见的一种做法就是开启一个工作线程，在工作线程中执行我们的任务。但是这样存在两个问题。</p><ul><li>由于线程的调度是由操作系统内核控制的，所以我们无法确定操作系统何时会运行或挂起该线程。</li><li>对于一些轻量级的任务，创建一个新的线程去做，消耗较大。</li></ul><p>那么有没有一种机制，既能新建线程执行任务，又没有新建线程消耗那么大呢？有，这就是纤程!<br>纤程是更轻量级的线程，线程中的线程，一个线程可以包含一个或多个纤程。纤程是在用户模式下实现的，内核对纤程一无所知。纤程拥有自己的寄存器上下文和栈。不用和内核打交道所以效率高。<br>在Windows中，要在某个线程中使用纤程，需要先将该线程切换到纤程模式。可以通过调用<code>ConvertThreadToFiber</code>函数实现线程到纤程的转换。</p><p>函数签名如下：</p><pre><code class="cpp">LPVOID ConvertThreadToFiber(LPVOID lpParameter);</code></pre><p>参数<code>lpParameter</code>是一个可选的参数，可以传递给纤程的入口函数。该函数返回一个纤程的句柄，可以在后续的操作中使用。</p><p>这个函数不仅将当前线程切换成纤程模式，也可以得到线程中的第1个纤程。我们可以通过这个函数的返回值来引用和操作纤程，这个纤程是线程中的主纤程。但是这个主纤程无法指定纤程函数，所以什么也做不了。我们可以通过参数lpParameter向主纤程传递数据，使用如下API函数获取当前纤程的数据：</p><pre><code class="cpp">LPVOID GetFiberData();</code></pre><p>当在不同的纤程之间切换时，也会涉及纤程上下面的切换，包括CPU寄存器数据的切换。在默认情况下，x86系统的CPU浮点状态信息不属于CPU寄存器，不会为每个纤程都维护一份，因此如果在我们的纤程中执行浮点操作，则会导致数据被破坏。为了禁用这种行为，需要用到ConvertThreadToFiberEx函数，该函数签名如下：</p><pre><code class="cpp">LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags);</code></pre><p>参数<code>lpParameter</code>是一个可选的参数，可以传递给纤程的入口函数。参数<code>dwFlags</code>用于指定转换选项，可以使用<code>FIBER_FLAG_FLOAT_SWITCH</code>来禁用浮点状态切换。<br>使用<code>ConvertThreadToFiberEx</code>函数禁用浮点状态切换后，纤程之间的浮点操作将不再导致数据被破坏。但是，由于浮点状态不会被保存和恢复，纤程之间的浮点操作将共享同一份浮点状态，可能会产生意外的结果。</p><p>调用<code>ConvertThreadToFiber</code>函数后，线程将成为一个纤程，不再是一个普通线程，只能在纤程之间切换，无法与其他线程进行同步和通信。要恢复线程的正常功能，可以调用<code>ConvertFiberToThread</code>函数将纤程转换回线程模式。</p><pre><code class="cpp">BOOL ConvertFiberToThread();</code></pre><p>因为默认的主纤程什么都做不了，所以我们在需要时要创建新的纤程，这时会用到API函数：</p><pre><code class="cpp">LPVOID CreateFiber(  SIZE_T    dwStackSize,  LPFIBER_START_ROUTINE lpStartAddress,  LPVOID    lpParameter);</code></pre><p>和创建线程的函数类似，参数dwStackSize指定纤程栈的大小，如果使用默认的大小，则将该值设置为0即可。我们可以将CreateFiber<br>函数的返回值作为操作纤程的句柄</p><p>纤程函数签名的具体形式可能因编程语言而异，但通常包含以下要素：</p><pre><code class="c">LPVOID WINAPI FiberProc(LPVOID lpParameter);</code></pre><p>当不需要使用纤程时，记得调用DeleteFiber删除纤程对象：</p><pre><code class="c">void DeleteFiber (LPVOID lpFiber) ;</code></pre><p>在不同的纤程之间切换时，会用到API函数：</p><pre><code class="c">void SwitchToFiber (LPVOID lpFiber);</code></pre><p>参数lpFiber即前面所说的纤程句柄。<br>和线程存在线程局部存储一样，纤程也可以有自己的局部存储——纤程局部存储，获取和设置纤程局部存储数据时，会用到API函数：</p><ol><li><strong>FlsAlloc</strong>：</li></ol><pre><code class="c">DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);</code></pre><p>该函数用于分配一个新的纤程局部存储索引。它接受一个回调函数指针 <code>lpCallback</code>，该回调函数在纤程退出时被调用。函数返回一个索引值，可以用于后续的访问和操作。</p><ol start="2"><li><strong>FlsFree</strong>：</li></ol><pre><code class="c">BOOL FlsFree(DWORD dwFlsIndex);</code></pre><p>该函数用于释放先前分配的纤程局部存储索引。它接受一个索引值 <code>dwFlsIndex</code> 作为参数，并释放相关的存储空间。函数返回一个布尔值，表示操作是否成功。</p><ol start="3"><li><strong>FlsGetValue</strong>：</li></ol><pre><code class="c">PVOID FlsGetValue(DWORD dwFlsIndex);</code></pre><p>该函数用于获取当前纤程的指定纤程局部存储索引处的值。它接受一个索引值 <code>dwFlsIndex</code> 作为参数，并返回存储在该索引处的数据值。</p><ol start="4"><li><strong>FlsSetValue</strong>：</li></ol><pre><code class="c">BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData);</code></pre><p>该函数用于设置当前纤程的指定纤程局部存储索引处的值。它接受一个索引值 <code>dwFlsIndex</code> 和一个数据值指针 <code>lpFlsData</code> 作为参数，并将数据值存储在该索引处。函数返回一个布尔值，表示操作是否成功。</p><p>在Windows操作系统中，可以使用以下API函数来获取当前执行的纤程句柄：</p><pre><code class="c">LPVOID GetCurrentFiber(void);</code></pre><p>来看一个具体的例子：</p><pre><code class="cpp">#include &lt;windows.h&gt;#include &lt;string&gt;char g_szTime[64] = &quot;time not set...&quot;;LPVOID mainWorkerFiber = NULL;LPVOID pworkerFiber = NULL;void WINAPI workerFiberProc(LPVOID lpFiberParameter)&#123;    while (true)    &#123;        // 假设这是一项很耗时的操作        SYSTEMTIME st;        GetLocalTime(&amp;st);        wsprintfA(g_szTime, &quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, st.wYear, st.wMonth,            st.wDay, st.wHour, st.wMinute, st.wSecond);        printf(&quot;%s\n&quot;, g_szTime);        // 切换回主纤程        //SwitchToFiber(mainWorkerFiber);    &#125;&#125;int main()&#123;    mainWorkerFiber = ConvertThreadToFiber(NULL);    int index = 0;    while (index &lt; 100)    &#123;        index++;        pworkerFiber = CreateFiber(0, workerFiberProc, NULL);        if (pworkerFiber == NULL)            return -1;        // 切换至新的纤程        SwitchToFiber(pworkerFiber);        /******************************************/        //后续代码永远不会执行        memset(g_szTime, 0, sizeof(g_szTime));        strncpy(g_szTime, &quot;time not set...&quot;, strlen(&quot;time not set...&quot;));        printf(&quot;%s\n&quot;, g_szTime);        Sleep(1000);        DeleteFiber(pworkerFiber);    &#125;    // 切换回线程模式    ConvertFiberToThread();    return 0;&#125;</code></pre><p>以上代码只有一个主线程，主线程在第 1 个加粗行切换至新建的纤程 pWorkerFiber。由于在新建的纤程函数中是一个 while无限循环，所以 main 函数中注释后面的代码永远不会执行。<br>我们把workerFiberProc注释行SwitchToFiber(mainWorkerFiber);取消注释，则又可以回到主线程运行。在workerFiberProc函数中的注释行跳回main函数的memset行执行，接着周而复始地进行下一轮循环，直到main函数的while条件不再满足，退出程序。</p><p>纤程从本质上来说是协程（coroutine），Windows 的纤程技术让单个线程能按用户的意愿像线程一样自由切换，且没有线程切换那样的开销和不可控性。Windows最早引入纤程是为了方便地将 UNIX单线程程序迁移到Windows 上。有人提出，调试时，若程序的执行点在纤程函数内部，则调用堆栈对用户是割裂的，这对于习惯看连续性上下面堆栈的用户来说可能不太友好，如下图所示。<br><img src="https://s1.ax1x.com/2023/06/13/pCmoSk4.png" alt="pCmoSk4.png"></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>线程是操作系统的内核对象，多线程编程时线程数过多，会导致上下面频繁切换，这对性能是一种额外的损耗。例如，在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 连接是很不明智的做法，因此现在的主流做法是利用操作系统提供的基于事件模式的异步编程模型，用少量的线程来服务大量的网络连接和 I&#x2F;O。但是采用异步和基于事件的编程模型，让程序代码变得复杂，非常容易出错，也增加了排查错误的难度。<br>协程，可被认为是在应用层模拟的线程。协程避免了线程上下面切换的部分额外损耗，同时具有并发运行的优点，降低了编写并发程序的复杂度。还是以上面的高并发网络服务器为例，可以为每个socket 连接都使用一个协程来处理，在兼顾性能的情况下代码也清晰。<br>协程的概念早于线程提出，但它是非抢占式的调度，无法实现公平的任务调用，也无法直接利用多核 CPU的优势，因此我们不能武断地说协程比线程更高级。目前主流的操作系统原生API并不支持协程技术，新兴的一些高级编程语言如Golang都是在语言的运行时环境中利用线程技术模拟了一套协程。在这些语言中，协程的内部实现都基于线程，思路是维护一组数据结构和 n个线程，真正的执行者还是线程，协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行，这就解决了协程的执行问题。那么协程是怎么切换的呢？以Golang为例，Golang对操作系统的各种 I&#x2F;O函数（如Linux的epoll、select，Windows的IOCP等）进行了封装，这些封装的函数被提供给应用程序使用，其内部调用了操作系统的异步I&#x2F;O函数，当这些异步函数返回busy或blocking时，Golang会利用这个时机将现有的执行序列压栈，让线程拉取另一个协程的代码来执行。由于 Golang从编译器和语言基础库等多个层面对协程做了实现，所以 Golang的协程是目前各类存在协程概念的语言中实现最完整和成熟的，10万个协程同时运行也毫无压力。其优势就是，程序员在编写Golang代码时，可以更多地关注业务逻辑的实现，尽量避免在这些基础构件上耗费太多精力。<br>协程技术之所以这么流行，是因为大多数业务系统都倾向于使用异步编程来提高系统的性能，这就强行地将线性的程序逻辑打乱，使程序逻辑变得非常复杂，对程序状态的管理也变得困难，例如Node.js的层层Callback。而Golang作为名门之后开始进入广大开发者的视野，并且迅速在 Web 后端应用。例如以 Docker 及围绕 Docker 展开的整个容器生态圈为代表，其最大的卖点就是协程技术，至此协程技术开始真正流行。</p><p>腾讯开源了一套C&#x2F;C++版本的协程库libco，目前无时间准备，秋招结束后我会研究一下更新我的blog</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go工作区</title>
      <link href="/p/8ca6511d.html"/>
      <url>/p/8ca6511d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go工作区"><a href="#Go工作区" class="headerlink" title="Go工作区"></a>Go工作区</h1><p>我们学习 Go 语言时，要做的第一件事，都是根据自己电脑的计算架构（比如，是 32 位的计算机还是 64 位的计算机）以及操作系统（比如，是 Windows 还是 Linux），从Go 语言官网下载对应的二进制包，也就是可以拿来即用的安装包。随后，我们会解压缩安装包、放置到某个目录、配置环境变量，并通过在命令行中输入go version来验证是否安装成功。<br>在这个过程中，我们还需要配置 3 个环境变量，也就是 GOROOT、GOPATH 和 GOBIN。</p><ul><li>GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。</li><li>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。</li><li>GOBIN：GO 程序生成的可执行文件（executable file）的路径。</li></ul><h2 id="设置-GOPATH-有什么意义吗？"><a href="#设置-GOPATH-有什么意义吗？" class="headerlink" title="设置 GOPATH 有什么意义吗？"></a>设置 GOPATH 有什么意义吗？</h2><p>GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。<br>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。<br>事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，<br>分别是：</p><ol><li>Go 语言源码的组织方式是怎样的；</li><li>你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使用）；</li><li>你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有用，否则你很可能会走弯路）。</li></ol><h2 id="Go-语言源码的组织方式"><a href="#Go-语言源码的组织方式" class="headerlink" title="Go 语言源码的组织方式"></a>Go 语言源码的组织方式</h2><p>Go 语言的源码是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。<br>一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。<br>代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。<br>每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。就像这样：</p><pre><code>import &quot;github.com/labstack/echo&quot;</code></pre><p>在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。<br>所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。</p><h2 id="了解源码安装后的结果"><a href="#了解源码安装后的结果" class="headerlink" title="了解源码安装后的结果"></a>了解源码安装后的结果</h2><p>源码文件以及安装后的结果文件都会放到哪里呢？我们都知道，源码文件通常会被放在某个工作区的 src 子目录下。<br>那么在安装后如果产生了归档文件（以“.a”为扩展名的文件），就会放进该工作区的 pkg子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。</p><p>源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是</p><pre><code>github.com/labstack/echo</code></pre><p>那么执行命令</p><pre><code>go install github.com/labstack/echo</code></pre><p>生成的归档文件的相对目录就是 github.com&#x2F;labstack， 文件名为 echo.a。上面这个代码包导入路径还有另外一层含义，那就是：该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中。<br>归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。<br>比如，构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。<br>因此，上述代码包的归档文件就会被放置在当前工作区的子目录pkg&#x2F;linux_amd64&#x2F;github.com&#x2F;labstack 中。<br>总之，某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中。</p><p><a href="https://s1.ax1x.com/2023/07/01/pCB2InP.png">pCB2InP.png</a></p><h2 id="构建和安装-Go-程序的过程"><a href="#构建和安装-Go-程序的过程" class="headerlink" title="构建和安装 Go 程序的过程"></a>构建和安装 Go 程序的过程</h2><p>构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。<br>如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。<br>如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。<br>安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。进一步说，如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中。如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量GOBIN指向的目录中。</p><h2 id="go-build-命令一些可选项的用途和用法"><a href="#go-build-命令一些可选项的用途和用法" class="headerlink" title="go build 命令一些可选项的用途和用法"></a>go build 命令一些可选项的用途和用法</h2><p>在运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。如果要强制编译它们，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i。那么我们怎么确定哪些代码包被编译了呢？有两种方法。</p><ol><li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li><li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li></ol><p>下面再说一说与 Go 源码的安装联系很紧密的一个命令：go get。<br>命令go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。<br>最常用的几个标记有下面几种。</p><ul><li>-u：下载并安装代码包，不论工作区中是否已存在它们。</li><li>-d：只下载代码包，不安装代码包。</li><li>-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</li><li>-t：同时下载测试所需的代码包。</li><li>-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</li></ul><p>Go 语言官方提供的go get命令是比较基础的，其中并没有提供依赖管理的功能。目前GitHub 上有很多提供这类功能的第三方工具，比如glide、gb以及官方出品的dep、vgo等等，它们在内部大都会直接使用go get。<br>有时候，我们可能会出于某种目的变更存储源码的代码仓库或者代码包的相对路径。这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用自定义的代码包导入路径。对代码包的远程导入路径进行自定义的方法是：在该代码包中的库源码文件的包声明语句的右边加入导入注释，像这样：</p><pre><code>package semaphore // import &quot;golang.org/x/sync/semaphore&quot;</code></pre><p>这个代码包原本的完整导入路径是github.com&#x2F;golang&#x2F;sync&#x2F;semaphore。这与实际存储它的网络地址对应的。该代码包的源码实际存在 GitHub 网站的 golang 组的 sync 代码仓库的 semaphore 目录下。而加入导入注释之后，用以下命令即可下载并安装该代码包了：</p><pre><code>go get golang.org/x/sync/semaphore</code></pre><p>而 Go 语言官网 golang.org 下的路径 &#x2F;x&#x2F;sync&#x2F;semaphore 并不是存放semaphore包的真实地址。我们称之为代码包的自定义导入路径。<br>不过，这还需要在 golang.org 这个域名背后的服务端程序上，添加一些支持才能使这条命令成功。</p><p>如果你想查阅更详细的文档，那么可以访问 Go 语言官方的命令文档页面，或者在命令行下输入诸如go help build这类的命令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工作区和 GOPATH 的概念和含义是每个 Go 工程师都需要了解的。虽然它们都比较简单，但是说它们是 Go 程序开发的核心知识并不为过。然而，我在招聘面试的过程中仍然发现有人忽略掉了它们。Go 语言提供的很多工具都是在GOPATH 和工作区的基础上运行的，比如上面提到的go build、go install和goget，这三个命令也是我们最常用到的。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zorm学习</title>
      <link href="/p/6e2bd130.html"/>
      <url>/p/6e2bd130.html</url>
      
        <content type="html"><![CDATA[<h1 id="zorm学习"><a href="#zorm学习" class="headerlink" title="zorm学习"></a>zorm学习</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><h3 id="structFieldInfo"><a href="#structFieldInfo" class="headerlink" title="structFieldInfo"></a>structFieldInfo</h3><ul><li><p>exportStructFieldMap :&#x3D; make(map[string]reflect.StructField)</p></li><li><p>privateStructFieldMap :&#x3D; make(map[string]reflect.StructField)</p></li><li><p>dbColumnFieldMap :&#x3D; make(map[string]reflect.StructField)</p></li><li><p>structFieldTagMap :&#x3D; make(map[string]string)</p></li><li><p>dbColumnFieldNameSlice :&#x3D; make([]string, 0)</p></li><li><p>cacheStructFieldInfoMap.Store(exportCacheKey, exportStructFieldMap)                —exportCacheKey</p></li><li><p>cacheStructFieldInfoMap.Store(privateCacheKey, privateStructFieldMap)              —privateCacheKey</p></li><li><p>cacheStructFieldInfoMap.Store(dbColumnCacheKey, dbColumnFieldMap)                  —dbColumnCacheKey</p></li><li><p>cacheStructFieldInfoMap.Store(structFieldTagCacheKey, structFieldTagMap)           —structFieldTagCacheKey</p></li><li><p>cacheStructFieldInfoMap.Store(dbColumnNameSliceCacheKey, dbColumnFieldNameSlice)   —dbColumnNameSliceCacheKey</p></li></ul><ul><li><p>func structFieldInfo(typeOf *reflect.Type) error</p></li><li><p>根据传入的结构体类型，获取该结构体的字段信息，并将其缓存起来，以提高后续的性能</p></li><li><p>func getCacheStructFieldInfo(typeOf *reflect.Type, keyPrefix string) (*interface{}, error)</p></li><li><p>从缓存中获取结构体字段信息，如果缓存中不存在，则通过调用 structFieldInfo 函数来获取并存入缓存</p></li><li><p>func getCacheStructFieldInfoMap(typeOf *reflect.Type, keyPrefix string) (*map[string]reflect.StructField, error) </p></li><li><p>获取对应的几个Map比如exportStructFieldMap，privateStructFieldMap</p></li><li><p>func getDBColumnFieldMap(typeOf *reflect.Type) (*map[string]reflect.StructField, error)</p></li><li><p>获取dbColumnFieldMap</p></li><li><p>func setFieldValueByColumnName(entity interface{}, columnName string, value interface{}) error</p></li><li><p>根据column名字给field赋值value</p></li><li><p>func getDBColumnFieldNameSlice(typeOf <em>reflect.Type) (</em>[]string, error)</p></li><li><p>获取dbColumnFieldNameSlice</p></li><li><p>func getStructFieldTagMap(typeOf *reflect.Type) (*map[string]string, error)</p></li><li><p>获取structFieldTagMap</p></li><li><p>func entityPKFieldName(entity IEntityStruct, typeOf *reflect.Type) (string, error)</p></li><li><p>获取实体类主键属性名称</p></li><li><p>func checkEntityKind(entity interface{}) (*reflect.Type, error)</p></li><li><p>检查entity类型必须是*struct类型或者基础类型的指针</p></li></ul><h3 id="IEntity"><a href="#IEntity" class="headerlink" title="IEntity"></a>IEntity</h3><ul><li><p><code>IEntityStruct</code>：struct实体类的接口，定义了实体类必须实现的方法。</p><ul><li><code>GetTableName() string</code>：获取表名称的方法。</li><li><code>GetPKColumnName() string</code>：获取数据库表的主键字段名称的方法。</li><li><code>GetPkSequence() string</code>：获取主键序列的方法。</li><li><code>GetDefaultValueMap() map[string]interface&#123;&#125;</code>：获取列的默认值Map的方法。</li></ul></li><li><p><code>IEntityMap</code>：使用Map保存数据的接口，用于不方便使用struct的场景。</p><ul><li><code>GetTableName() string</code>：获取表名称的方法。</li><li><code>GetPKColumnName() string</code>：获取数据库表的主键字段名称的方法。</li><li><code>GetEntityMapPkSequence() string</code>：获取主键序列的方法。</li><li><code>GetDBFieldMap() map[string]interface&#123;&#125;</code>：获取数据库字段Map的方法。</li><li><code>GetDBFieldMapKey() []string</code>：按照Set的先后顺序记录数据库字段的方法。</li><li><code>Set(key string, value interface&#123;&#125;) map[string]interface&#123;&#125;</code>：设置数据库字段的值的方法。</li></ul></li><li><p><code>EntityStruct</code>：<code>IEntityStruct</code>接口的基础实现，用于所有的实体类匿名注入，类似实现继承。</p><ul><li><code>GetPKColumnName() string</code>：获取数据库表的主键字段名称的方法的实现。</li><li><code>GetPkSequence() string</code>：获取主键序列的方法的实现。</li><li><code>GetDefaultValueMap() map[string]interface&#123;&#125;</code>：获取列的默认值Map的方法的实现。</li></ul></li><li><p><code>EntityMap</code>：<code>IEntityMap</code>接口的基础实现，可以直接使用或匿名注入。</p><ul><li><code>NewEntityMap(tbName string) *EntityMap</code>：初始化<code>EntityMap</code>的函数，需要传入表名称。</li><li><code>GetTableName() string</code>：获取表名称的方法的实现。</li><li><code>GetPKColumnName() string</code>：获取数据库表的主键字段名称的方法的实现。</li><li><code>GetEntityMapPkSequence() string</code>：获取主键序列的方法的实现。</li><li><code>GetDBFieldMap() map[string]interface&#123;&#125;</code>：获取数据库字段Map的方法的实现。</li><li><code>GetDBFieldMapKey() []string</code>：按照Set的先后顺序记录数据库字段的方法的实现。</li><li><code>Set(key string, value interface&#123;&#125;) map[string]interface&#123;&#125;</code>：设置数据库字段的值的方法的实现。</li><li><code>MarshalJSON() ([]byte, error)</code>：将<code>EntityMap</code>对象转换为JSON格式的方法。</li><li><code>UnmarshalJSON(data []byte) error</code>：将JSON格式的数据解析为<code>EntityMap</code>对象的方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码文件</title>
      <link href="/p/1f84997a.html"/>
      <url>/p/1f84997a.html</url>
      
        <content type="html"><![CDATA[<h1 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h1><h2 id="命令源码文件"><a href="#命令源码文件" class="headerlink" title="命令源码文件"></a>命令源码文件</h2><p>对于 Go 语言学习者来说，你在学习阶段中，也一定会经常编写可以直接运行的程序。这样的程序肯定会涉及命令源码文件的编写，而且，命令源码文件也可以很方便地用 go run 命令启动。<br>命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。<br>如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。<br>例如:</p><pre><code>package main    import &quot;fmt&quot;    func main() &#123;    fmt.Println(&quot;Hello, world!&quot;)&#125;</code></pre><p>如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!</p><p>当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，那么它们也应该<br>声明属于main包。</p><p>无论是 Linux 还是 Windows，几乎所有命令（command）都是可以接收参数（argument）的。通过构建或安装命令源码文件，生成的可执行文件就可以被视为“命令”，既然是命令，那么就应该具备接收参数的能力。</p><h3 id="命令源码文件怎样接收参数"><a href="#命令源码文件怎样接收参数" class="headerlink" title="命令源码文件怎样接收参数"></a>命令源码文件怎样接收参数</h3><p>我们先看一段不完整的代码：</p><pre><code>package mainimport (    // 需在此处添加代码。[1]    &quot;fmt&quot;)var name stringfunc init() &#123;    // 需在此处添加代码。[2]&#125;func main() &#123;    // 需在此处添加代码。[3]    fmt.Printf(&quot;Hello, %s!\n&quot;, name)&#125;</code></pre><p>如果在注释处添加相应的代码，并让程序实现”根据运行程序时给定的参数问候某人”的功能，你会打算怎样做？<br>Go 语言标准库中有一个代码包专门用于接收和解析命令参数。这个代码包的名字叫flag。<br>我们需要在[1]处添加代码”flag”导入flag这个包。<br>其次，人名肯定是由字符串代表的。所以我们要在[2]处添加调用flag包的StringVar函数的代码。</p><pre><code>flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</code></pre><p>函数flag.StringVar接受 4 个参数。</p><ul><li>第 1 个参数是用于存储该命令参数值的地址，具体到这里就是在前面声明的变量name的地址了，由表达式&amp;name表示。</li><li>第 2 个参数是为了指定该命令参数的名称，这里是name。</li><li>第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是everyone。</li><li>第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到。</li></ul><p>还有一个与flag.StringVar函数类似的函数，叫flag.String。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。如果使用它的话，我们就需要把</p><pre><code>var name string</code></pre><p>改为</p><pre><code>var name = flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</code></pre><p>再说最后一个填空。我们需要在[3]处添加代码flag.Parse()。函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</p><h3 id="在运行命令源码文件的时候传入参数"><a href="#在运行命令源码文件的时候传入参数" class="headerlink" title="在运行命令源码文件的时候传入参数"></a>在运行命令源码文件的时候传入参数</h3><p>如果我们把上述代码存成名为 demo2.go 的文件，那么运行如下命令就可以为参数name传值：</p><pre><code>go run demo2.go -name=&quot;Robert&quot;</code></pre><p>运行后，打印到标准输出（stdout）的内容会是：</p><pre><code>Hello, Robert!</code></pre><p>另外，如果想查看该命令源码文件的参数说明，可以这样做：</p><pre><code>go run demo2.go --help</code></pre><p>运行后输出的内容会类似：</p><pre><code>Usage of /var/folders/ts/7lg_tl_x2gd_k1lm5g_48c7w0000gn/T/go-build155438482/b001/exe/dem-name stringThe greeting object. (default &quot;everyone&quot;)exit status 2</code></pre><p>如果我们先构建这个命令源码文件再运行生成的可执行文件，像这样：</p><pre><code>go build demo2.go./demo2 --help</code></pre><p>那么输出就会是</p><pre><code>Usage of ./demo2:-name stringThe greeting object. (default &quot;everyone&quot;)</code></pre><h3 id="怎样自定义命令源码文件的参数使用说明"><a href="#怎样自定义命令源码文件的参数使用说明" class="headerlink" title="怎样自定义命令源码文件的参数使用说明"></a>怎样自定义命令源码文件的参数使用说明</h3><p>这有很多种方式，最简单的一种方式就是对变量flag.Usage重新赋值。flag.Usage的类型是func()，即一种无参数声明且无结果声明的函数类型。<br>flag.Usage变量在声明时就已经被赋值了，所以我们才能够在运行命令 go run demo2.go –help时看到正确的结果。<br>注意，对flag.Usage的赋值必须在调用flag.Parse函数之前。<br>现在，我们把 demo2.go 另存为 demo3.go，然后在main函数体的开始处加入如下代码。</p><pre><code>flag.Usage = func() &#123;    fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, &quot;question&quot;)    flag.PrintDefaults()&#125;</code></pre><p>那么当运行</p><pre><code>go run demo3.go --help</code></pre><p>后，就会看到</p><pre><code>Usage of question:-name stringThe greeting object. (default &quot;everyone&quot;)exit status 2</code></pre><p>现在再深入一层，我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用flag.CommandLine变量的对应方法<br>flag.CommandLine相当于默认情况下的命令参数容器。所以，通过对flag.CommandLine重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。<br>现在我们把main函数体中的那条对flag.Usage变量的赋值语句注销掉，然后在init函数体的开始处添加如下代码：</p><pre><code>flag.CommandLine = flag.NewFlagSet(&quot;&quot;, flag.ExitOnError)flag.CommandLine.Usage = func() &#123;    fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, &quot;question&quot;)    flag.PrintDefaults()&#125;</code></pre><p>再运行命令go run demo3.go –help后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为flag.CommandLine赋值的那条语句改为</p><pre><code>flag.CommandLine = flag.NewFlagSet(&quot;&quot;, flag.PanicOnError)</code></pre><p>后，再运行go run demo3.go –help命令就会产生另一种输出效果。这是由于我们在这里传给flag.</p><p>NewFlagSet函数的第二个参数值是flag.PanicOnError。flag.PanicOnError和flag.ExitOnError都是预定义在flag包中的常量。</p><p>flag.ExitOnError的含义是，告诉命令参数容器，当命令后跟–help或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码2结束当前程序。</p><p>状态码2代表用户错误地使用了命令，而flag.PanicOnError与之的区别是在最后抛出“运行时恐慌（panic）”。</p><p>上述两种情况都会在我们调用flag.Parse函数时被触发。</p><p>下面再进一步，我们索性不用全局的flag.CommandLine变量，转而自己创建一个私有的<br>命令参数容器。我们在函数外再添加一个变量声明：</p><pre><code>var cmdLine = flag.NewFlagSet(&quot;question&quot;, flag.ExitOnError)</code></pre><p>然后，我们把对flag.StringVar的调用替换为对cmdLine.StringVar调用，再把flag.Parse()替换为cmdLine.Parse(os.Args[1:])。其中的os.Args[1:]指的就是我们给定的那些命令参数。这样做就完全脱离了<br>flag.CommandLine。*flag.FlagSet类型的变量cmdLine拥有很多有意思的方法。</p><h2 id="库源码文件"><a href="#库源码文件" class="headerlink" title="库源码文件"></a>库源码文件</h2><p>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。<br>这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中</p><p>那么程序实体是什么呢？在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。<br>我们总是会先声明（或者说定义）程序实体，然后再去使用。比如在命令源码的例子中，我们先定义了变量name，然后在main函数中调用fmt.Printf函数的时候用到了它。再多说一点，程序实体的名字被统称为标识符。标识符可以是任何 Unicode编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。从规则上说，我们可以用中文作为变量的名字。</p><p>怎样把命令源码文件中的代码拆分到其他库源码文件？<br>如果在某个目录下有一个命令源码文件 demo4.go，如下：</p><pre><code>package mainimport (    &quot;flag&quot;)var name stringfunc init() &#123;    flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)&#125;func main() &#123;    flag.Parse()    hello(name)&#125;</code></pre><p>函数hello被声明在了另外一个源码文件中，命名为 demo4_lib.go，并且放在与demo4.go 相同的目录下。如下：</p><pre><code>// 需在此处添加代码。[1]import &quot;fmt&quot;    func hello(name string) &#123;    fmt.Printf(&quot;Hello, %s!\n&quot;, name)&#125;</code></pre><p>那么注释 1 处应该填入什么代码？</p><p>答案很简单，填入代码包声明语句package main。在同一个目录下的源码文件都需要被声明为属于同一个代码包。如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。<br>如此一来，我们就可以运行它们了。比如，我们可以在这些文件所在的目录下运行如下命令并得到相应的结果。</p><pre><code>$ go run demo4.go demo4_lib.go Hello, everyone!</code></pre><p>或者，像下面这样先构建当前的代码包再运行。</p><pre><code>$ go build puzzlers/article3/q1$ ./q1 Hello, everyone!</code></pre><p>在默认情况下，相应的代码包的导入路径会与此一致。我们可以通过代码包的导入路径引用其中声明的程序实体。但是，这里的情况是不同的。<br>注意，demo4.go 和 demo4_lib.go 都声明自己属于main包。源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。</p><p>这个问题考察的是代码包声明的基本规则。这里再总结一下。<br>第一条规则，同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。<br>如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。<br>第二条规则，源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。<br>对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同</p><p>在编写真正的程序时，我们仅仅把代码拆分到几个源码文件中是不够的。我们往往会用模块<br>化编程的方式，根据代码的功能和用途把它们放置到不同的代码包中。</p><h3 id="怎样把命令源码文件中的代码拆分到其他代码包"><a href="#怎样把命令源码文件中的代码拆分到其他代码包" class="headerlink" title="怎样把命令源码文件中的代码拆分到其他代码包"></a>怎样把命令源码文件中的代码拆分到其他代码包</h3><p>我们先不用关注拆分代码的技巧。我在这里仍然依从前面的拆分方法。我把 demo4.go 另存为 demo5.go，并放到一个相对路径为puzzlers&#x2F;article3&#x2F;q2的目录中。<br>然后我再创建一个相对路径为puzzlers&#x2F;article3&#x2F;q2&#x2F;lib的目录，再把demo4_lib.go 复制一份并改名为 demo5_lib.go 放到该目录中。</p><pre><code>package lib5import &quot;fmt&quot;func Hello(name string) &#123;    fmt.Printf(&quot;Hello, %s!\n&quot;, name)&#125;</code></pre><p>可以看到，我在这里修改了两个地方。第一个改动是，我把代码包声明语句由package main改为了package lib5。注意，让声明的包名与其所在的目录的名称不同。第二个改动是，我把全小写的函数名hello改为首字母大写的Hello。</p><p>基于以上改动，我们再来看下面的几个问题。<br>代码包的导入路径总会与其所在目录的相对路径一致吗？<br>库源码文件 demo5_lib.go 所在目录的相对路径是puzzlers&#x2F;article3&#x2F;q2&#x2F;lib，而它却声明自己属于lib5包。在这种情况下，该包的导入路径是puzzlers&#x2F;article3&#x2F;q2&#x2F;lib，还是puzzlers&#x2F;article3&#x2F;q2&#x2F;lib5？<br>首先，我们在构建或者安装这个代码包的时候，提供给go命令的路径应该是目录的相对路<br>径，就像这样：</p><pre><code>go install puzzlers/article3/q2/lib</code></pre><p>该命令会成功完成。之后，当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是:</p><pre><code>pkg/darwin_amd64/puzzlers/article3/q2/lib.a</code></pre><p>为了进一步说明问题，需要先对 demo5.go 做两个改动。第一个改动是，在以import为前导的代码包导入语句中加入puzzlers&#x2F;article3&#x2F;q2&#x2F;lib，也就是试图导入这个代<br>码包。<br>第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用。其中的lib.叫做限<br>定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不<br>同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致<br>现在，我们可以通过运行go run demo5.go命令试一试</p><pre><code>./demo5.go:5:2: imported and not used: &quot;puzzlers/article3/q2/lib&quot; as lib5./demo5.go:16:2: undefined: lib</code></pre><p>第一个错误提示的意思是，我们导入了puzzlers&#x2F;article3&#x2F;q2&#x2F;lib包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。<br>注意，这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包puzzlers&#x2F;article3&#x2F;q2&#x2F;lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。<br>为什么会是这样？根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应</p><p>什么样的程序实体才可以被当前包外的代码引用？<br>名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。<br>通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它</p><p>对于程序实体，还有其他的访问权限规则吗？</p><p>在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：模块级私有。<br>具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go学习</title>
      <link href="/p/d080713b.html"/>
      <url>/p/d080713b.html</url>
      
        <content type="html"><![CDATA[<h3 id="strings-Builder"><a href="#strings-Builder" class="headerlink" title="strings.Builder"></a>strings.Builder</h3><p><code>strings.Builder</code> 是 Go 语言标准库中的一个类型，用于高效地构建字符串。</p><p><code>strings.Builder</code> 类型提供了以下方法：</p><ul><li><code>Write</code>：向字符串构建器中写入字符串内容。</li><li><code>WriteByte</code>：向字符串构建器中写入单个字节。</li><li><code>WriteRune</code>：向字符串构建器中写入单个 Unicode 字符。</li><li><code>WriteString</code>：向字符串构建器中写入字符串。</li><li><code>Len</code>：返回当前字符串构建器中的字符串长度。</li><li><code>Cap</code>：返回当前字符串构建器的容量。</li><li><code>String</code>：返回当前字符串构建器中的字符串内容。</li></ul><p>使用 <code>strings.Builder</code> 可以高效地拼接和构建字符串，特别适用于需要频繁修改字符串的场景，避免了不必要的字符串拷贝和内存分配。</p><p>以下是一个示例代码，展示如何使用 <code>strings.Builder</code> 构建字符串：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;strings&quot;)func main() &#123;    builder := strings.Builder&#123;&#125;    builder.WriteString(&quot;Hello, &quot;)    builder.WriteByte(&#39;W&#39;)    builder.WriteRune(&#39;o&#39;)    builder.WriteString(&quot;rld!&quot;)    result := builder.String()    fmt.Println(result) // Output: Hello, World!&#125;</code></pre><p>在上述示例中，我们创建了一个空的 <code>strings.Builder</code> 对象，然后使用 <code>WriteString</code>、<code>WriteByte</code> 和 <code>WriteRune</code> 方法逐步构建字符串。最后，通过调用 <code>String</code> 方法获取构建的最终字符串并输出结果。<br><code>strings.Builder</code> 类型是可变的，可以在不同的方法调用之间持续修改和操作，以构建所需的字符串内容。完成构建后，通过 <code>String</code> 方法获取最终结果。</p><h3 id="json-Unmarshal"><a href="#json-Unmarshal" class="headerlink" title="json.Unmarshal"></a>json.Unmarshal</h3><p>json.Unmarshal 是 Go 语言标准库中的函数，用于将 JSON 数据解析为指定的结构体对象。json.Unmarshal(data, aux) 是将 JSON 数据 data 解析为结构体对象 aux 的过程。</p><ul><li>data 是包含 JSON 数据的字节切片（[]byte）。</li><li>aux 是一个指向目标结构体对象的指针，用于存储解析后的数据。</li></ul><p>函数调用的结果会根据解析过程的成功与否返回相应的错误值。<br>如果解析成功，data 中的 JSON 数据会被映射到 aux 对象的字段上，完成结构体的填充。如果解析失败，将返回一个非空的错误值，表示解析过程中发生了错误。</p><h3 id="匿名结构体json反序列化"><a href="#匿名结构体json反序列化" class="headerlink" title="匿名结构体json反序列化"></a>匿名结构体json反序列化</h3><pre><code>aux := &amp;struct &#123;    *EntityMapJSON    TableName     string                 `json:&quot;tableName,omitempty&quot;`    DBFieldMap    map[string]interface&#123;&#125; `json:&quot;dbFieldMap,omitempty&quot;`    DBFieldMapKey []string               `json:&quot;dbFieldMapKey,omitempty&quot;`&#125;&#123;    EntityMapJSON: (*EntityMapJSON)(entityMap),    DBFieldMap:    make(map[string]interface&#123;&#125;, 0),    DBFieldMapKey: make([]string, 0),&#125;</code></pre><p>该结构体包含以下字段：</p><ul><li>EntityMapJSON：指针类型，将 EntityMapJSON 结构体作为匿名字段，表示将反序列化后的数据转换为 EntityMapJSON 类型。</li><li>TableName：字符串类型，用于存储表名，并使用 json:”tableName,omitempty” 标签指定在反序列化时将 JSON 字段名称 “tableName” 映射到该字段，并且如果字段值为空则忽略该字段。</li><li>DBFieldMap：map[string]interface{} 类型，用于存储数据库字段和对应的值，并使用 json:”dbFieldMap,omitempty” 标签指定在反序列化时将 JSON 字段名称 “dbFieldMap” 映射到该字段，并且如果字段值为空则忽略该字段。</li><li>DBFieldMapKey：[]string 类型，用于按照字段设置的先后顺序记录数据库字段的键，并使用 json:”dbFieldMapKey,omitempty” 标签指定在反序列化时将 JSON 字段名称 “dbFieldMapKey” 映射到该字段，并且如果字段值为空则忽略该字段。</li></ul><p>在结构体定义的最后，创建了一个指向该结构体的指针 aux。然后对字段进行初始化：</p><ul><li>EntityMapJSON 字段通过 (*EntityMapJSON)(entityMap) 进行赋值，将 entityMap 转换为 EntityMapJSON 类型的指针。</li><li>DBFieldMap 字段使用 make 函数创建了一个空的 map。</li><li>DBFieldMapKey 字段使用 make 函数创建了一个空的字符串切片。</li></ul><p>对于 TableName 字段，其在结构体定义中使用了 omitempty 标签，表示在 JSON 序列化时，如果该字段的值为空，则忽略该字段，不包含在生成的 JSON 数据中。因此，在这里对 TableName 字段进行初始化并不会影响 JSON 反序列化的结果。</p><p>在这段代码中，entityMap.tableName 的值会被赋给 data.TableName 字段，因此无需在 aux 结构体定义中显式初始化 TableName 字段。在 JSON 反序列化时，如果传入的 JSON 数据中存在 “tableName” 字段，它将被解析并赋值给 entityMap.tableName。如果 JSON 数据中不存在 “tableName” 字段，或者该字段的值为空，那么 data.TableName 字段将保持为空字符串，对应的 entityMap.tableName 也将保持为空字符串。</p><h3 id="sql-Tx"><a href="#sql-Tx" class="headerlink" title="sql.Tx"></a>sql.Tx</h3><p><code>sql.Tx</code> 是在Go语言中用于数据库事务的类型，它代表一个数据库事务的操作。<code>sql.Tx</code> 类型实现了 <code>sql.Tx</code> 接口，允许在一个事务中执行多个数据库操作，并提供了回滚（Rollback）和提交（Commit）事务的功能。</p><p>在使用 <code>sql.Tx</code> 进行数据库操作时，可以执行多个 SQL 语句，并确保它们要么全部执行成功并提交事务，要么在发生错误时回滚事务，使数据库保持一致性。</p><p>下面是一个示例代码，演示如何使用 <code>sql.Tx</code> 开始、提交和回滚事务：</p><pre><code class="go">// 假设已经创建了一个名为 db 的数据库连接对象// 开始事务tx, err := db.Begin()if err != nil &#123;    // 处理错误&#125;// 执行 SQL 语句_, err = tx.Exec(&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;, &quot;John&quot;, 30)if err != nil &#123;    // 发生错误，回滚事务    tx.Rollback()    // 处理错误&#125;// 执行其他 SQL 语句...// ...// 提交事务err = tx.Commit()if err != nil &#123;    // 处理错误&#125;</code></pre><p>在上面的示例中，首先使用 <code>db.Begin()</code> 开始了一个事务，返回一个 <code>sql.Tx</code> 对象。然后，使用 <code>tx.Exec()</code> 方法执行 SQL 语句。如果执行过程中出现错误，可以使用 <code>tx.Rollback()</code> 回滚事务。如果所有操作都成功，可以使用 <code>tx.Commit()</code> 提交事务，将更改永久保存到数据库中。</p><p>请注意，<code>sql.Tx</code> 通常与 <code>sql.DB</code> 结合使用，<code>sql.DB</code> 是一个数据库连接池，负责管理数据库连接。在实际使用时，需要先创建一个 <code>sql.DB</code> 对象，然后从该对象获取 <code>sql.Tx</code> 对象进行事务操作。</p><ul><li>tx字段是一个数据库事务对象，用于执行事务操作。</li><li>db字段是一个数据库对象，用于执行非事务性的操作。</li></ul><h3 id="sql-TxOptions"><a href="#sql-TxOptions" class="headerlink" title="sql.TxOptions"></a>sql.TxOptions</h3><p><code>txOptions</code> 是一个指向 <code>sql.TxOptions</code> 类型的指针变量，用于指定数据库事务的选项。<code>sql.TxOptions</code> 类型是一个结构体，用于配置事务的行为。</p><p>通过设置 <code>txOptions</code> 的不同字段，可以自定义事务的隔离级别、只读属性和超时时间等。下面是 <code>sql.TxOptions</code> 结构体的字段：</p><ul><li><code>Isolation</code>：指定事务的隔离级别，默认为 <code>sql.LevelDefault</code>。</li><li><code>ReadOnly</code>：指定事务是否为只读事务，默认为 <code>false</code>。</li><li><code>Timeout</code>：指定事务的超时时间，如果为零值，则表示没有超时限制。</li></ul><p>以下是一个示例，展示如何使用 <code>sql.TxOptions</code> 创建一个自定义的事务选项：</p><pre><code class="go">import &quot;database/sql&quot;// 创建一个自定义的事务选项txOptions := &amp;sql.TxOptions&#123;    Isolation: sql.LevelSerializable,    ReadOnly:  true,    Timeout:   30, // 30 秒&#125;// 开始事务时传入事务选项tx, err := db.BeginTx(context.Background(), txOptions)if err != nil &#123;    // 处理错误&#125;// 执行事务操作...// ...// 提交或回滚事务err = tx.Commit()if err != nil &#123;    // 处理错误&#125;</code></pre><p>在上面的示例中，首先创建了一个 <code>sql.TxOptions</code> 结构体对象，并设置了隔离级别为 <code>sql.LevelSerializable</code>，只读属性为 <code>true</code>，超时时间为 30 秒。然后，在开始事务时，将该事务选项传递给 <code>db.BeginTx()</code> 方法。</p><p>通过使用 <code>sql.TxOptions</code>，可以自定义事务的行为以满足具体的需求，如隔离级别、只读事务和超时限制等。</p><h3 id="FindStringIndex"><a href="#FindStringIndex" class="headerlink" title="FindStringIndex"></a>FindStringIndex</h3><p>var (<br>    fromExpr      &#x3D; “(?i)(^\s<em>select)(\(.</em>?\)|[^()]+)*?(from)”<br>    fromRegexp, _ &#x3D; regexp.Compile(fromExpr)<br>)</p><p>&#x2F;&#x2F; findFromIndexa 查询from在sql中出现的开始位置和结束位置<br>func findSelectFromIndex(strsql *string) []int {<br>    &#x2F;&#x2F; 匹配出来的是完整的字符串,用最后的FROM即可<br>    loc :&#x3D; fromRegexp.FindStringIndex(*strsql)<br>    if len(loc) &lt; 2 {<br>        return loc<br>    }<br>    &#x2F;&#x2F; 最后的FROM前推4位字符串<br>    loc[0] &#x3D; loc[1] - 4<br>    return loc<br>}</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><h4 id="reflect-StructField"><a href="#reflect-StructField" class="headerlink" title="reflect.StructField"></a>reflect.StructField</h4><p><code>reflect.StructField</code> 是 Go 语言反射（reflection）包中的一个类型。它用于描述结构体的字段的信息。</p><p><code>reflect.StructField</code> 包含以下字段：</p><ul><li><code>Name string</code>：字段的名称。</li><li><code>PkgPath string</code>：字段所属的包的导入路径，如果是导出字段，则为空字符串。</li><li><code>Type reflect.Type</code>：字段的类型，表示为 <code>reflect.Type</code>。</li><li><code>Tag reflect.StructTag</code>：字段的标签，表示为 <code>reflect.StructTag</code>。</li><li><code>Offset uintptr</code>：字段在结构体中的偏移量。</li><li><code>Index []int</code>：字段的索引，用于嵌套结构体字段。</li><li><code>Anonymous bool</code>：字段是否为匿名字段。</li><li><code>Exported bool</code>：字段是否为导出字段。</li></ul><p>通过使用 <code>reflect.StructField</code>，我们可以获取和操作结构体字段的名称、类型、标签以及其他相关信息。这些信息对于进行结构体的反射操作和元编程非常有用。</p><h4 id="reflect-1"><a href="#reflect-1" class="headerlink" title="reflect"></a>reflect</h4><p>函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：</p><pre><code>t := reflect.TypeOf(3)  // a reflect.Typefmt.Println(t.String()) // &quot;int&quot;fmt.Println(t)          // &quot;int&quot;</code></pre><p>一个 reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型，并返回一个装载着其动态值的 reflect.Value。和 reflect.TypeOf 类似，reflect.ValueOf 返回的结果也是具体的类型，但是 reflect.Value 也可以持有一个接口值。</p><pre><code>v := reflect.ValueOf(3) // a reflect.Valuefmt.Println(v)          // &quot;3&quot;fmt.Printf(&quot;%v\n&quot;, v)   // &quot;3&quot;fmt.Println(v.String()) // NOTE: &quot;&lt;int Value&gt;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/p/1.html"/>
      <url>/p/1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-回答下面的问题（请编写-Markdown-文档一并上传到仓库）"><a href="#1-回答下面的问题（请编写-Markdown-文档一并上传到仓库）" class="headerlink" title="1. 回答下面的问题（请编写 Markdown 文档一并上传到仓库）"></a>1. 回答下面的问题（请编写 Markdown 文档一并上传到仓库）</h2><h3 id="问题1-根据下面的图片，回答问题"><a href="#问题1-根据下面的图片，回答问题" class="headerlink" title="问题1 : 根据下面的图片，回答问题"></a>问题1 : 根据下面的图片，回答问题</h3><p><a href="https://imgse.com/i/ppf2lbd"><img src="https://s1.ax1x.com/2023/04/02/ppf2lbd.png" alt="ppf2lbd.png"></a></p><h5 id="解释下面概念"><a href="#解释下面概念" class="headerlink" title="解释下面概念"></a>解释下面概念</h5><pre><code>◦ workspace : 工作区，平时存放项目代码的地方◦ staging area :暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件◦ local repository : 仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本;◦ remote repository : 远程仓库，托管代码的服务器</code></pre><h3 id="问题2-：-如何解决-git-冲突"><a href="#问题2-：-如何解决-git-冲突" class="headerlink" title="问题2 ： 如何解决 git 冲突?"></a>问题2 ： 如何解决 git 冲突?</h3><p>删除代码中矛盾的代码或者恢复到以前版本</p><h3 id="问题3-出现下面问题的原因与解决方案是什么"><a href="#问题3-出现下面问题的原因与解决方案是什么" class="headerlink" title="问题3 : 出现下面问题的原因与解决方案是什么?"></a>问题3 : 出现下面问题的原因与解决方案是什么?</h3><pre><code>◦ 更新代码后显示： unable to unlink old ‘xxx/xxx/xx’ : invalid argument    ▪ 原因:因为XXX正在被运行，        ▪ 解决方案:先把它的进程关闭，重试一下就好了。    ◦ 更新代码后显示 :  the following untracked working tree files would be overwritten by checkout    ▪ 原因: Error 所列出的文件在本地的当前分支下未授权给 git 追踪，但同样命名的文件，也即出现在另一个（远程）分支下的同一文件却正在远程仓库或其它分支被 git 进行追踪        ▪ 解决方案: git clean -d -fx 删除当前目录及子文件夹下的未 track 的文件及文件夹◦ 更新代码后显示 : your local changes to the following files would be overwritten by merge…please move or remove them before you merge    ▪ 原因:git merge时本地分支的更改没有保存下来        ▪ 解决方案:暂存到堆栈区◦ 版本回退git reset --hard &#123;hash&#125;后提示：fatal: could not parse object “hash id”    ▪ 原因:切换到master分支后没有更新最新代码        ▪ 解决方案:先通过git pull --rebase更新当前分支代码，然后再执行git reset◦ git push后提示:to https://.git![rejected] localRepo-&gt;remoteRepo(fetch first)error: failed to push some refs to ‘https://.git’Updates were rejected because the remote contain work that you do not have locally.    ▪ 原因:远程包含的事务不在你的本地，在push前需要整合远端，    ▪ 解决方案:拉取远端的代码然后进行整合到本地，再push到远端即可</code></pre><h2 id="2-完成下列操作"><a href="#2-完成下列操作" class="headerlink" title="2. 完成下列操作"></a>2. 完成下列操作</h2><h5 id="下面的操作完成后，"><a href="#下面的操作完成后，" class="headerlink" title="下面的操作完成后，"></a>下面的操作完成后，</h5><pre><code>a. 克隆仓库 git clone + urlb. 提交修改到暂存区 git add .c. 提交修改到远程仓库 git push commit -m &quot;xxxx&quot;d. 从远程仓库下载代码 git pulle. 查看仓库状态 git statusf. 比较文件的不同,即暂存区与工作区的差别 git  diffg. 创建分支/切换分支/查看分支列表 git branch xxx /git check out /git branch -vh. 上传代码到分支上 git push -u origin xxxi. 合并分支到主分支 git merge xxxj. 删除分支 删除远程分支xxx git push origin --delete xxx /删除本地分支xxx  git branch -d xxxk. 回退到某个版本 git reset --hard 版本库地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用方法</title>
      <link href="/p/5226.html"/>
      <url>/p/5226.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><p align="center"><font color="#ff00ff">Git</font></p></h1><h2 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h2><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。</p><h2 id="1-2-查看Git的版本"><a href="#1-2-查看Git的版本" class="headerlink" title="1.2 查看Git的版本"></a>1.2 查看Git的版本</h2><pre><code>    git --verson</code></pre><h2 id="1-3-Git-基本工作流程"><a href="#1-3-Git-基本工作流程" class="headerlink" title="1.3 Git 基本工作流程"></a>1.3 Git 基本工作流程</h2><p><strong>工作区</strong> 就是你在电脑里能看到的目录。<br><strong>暂存区</strong> 英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。<br><strong>版本库</strong> 工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p><h2 id="1-4-Git-使用前配置"><a href="#1-4-Git-使用前配置" class="headerlink" title="1.4 Git 使用前配置"></a>1.4 Git 使用前配置</h2><p>使用git config命令可以设置 Git 的外观和行为，Git 的配置文件有三个级别：</p><ol><li>系统级配置（–system），一般在&#x2F;etc&#x2F;gitconfig</li><li>用户级配置（–global），一般在<del>&#x2F;.gitconfig或</del>&#x2F;.config&#x2F;git&#x2F;config</li><li>仓库级配置（–local），一般在当前仓库的.git文件夹中，即.git&#x2F;config<br>每一个级别会覆盖上一级别的配置。一般没有什么特殊要求的话，推荐直接使用 –global。</li></ol><h3 id="查看-Git-配置"><a href="#查看-Git-配置" class="headerlink" title="查看 Git 配置"></a>查看 Git 配置</h3><pre><code>    $ git config --list    # 查看 Git 配置以及它们所在的文件    $ git config --list --show-origin</code></pre><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：git config –global user.name “提交人姓名” # (对当前系统用户有效)</li><li>配置提交人姓名：git config –global user.email  “提交人邮箱” # (对当前系统用户有效)<br> 作用：识别开发人员，与登陆github的账户无关</li><li>查看git配置信息：git config –list</li></ol><p>注意</p><ol><li>如果要对配置信息进行修改，重复上述命令即可。</li><li>配置只需要执行一次。</li></ol><h2 id="1-5-常用提交步骤"><a href="#1-5-常用提交步骤" class="headerlink" title="1.5 常用提交步骤"></a>1.5 常用提交步骤</h2><ol><li><p>git init  # 初始化git仓库</p></li><li><p>git status  # 查看文件状态</p></li><li><p>git add 文件列表 # 追踪文件</p></li><li><p>git commit -m  “提交信息”  # 向仓库中提交代码(全部文件)<br>vs： git commit -m “提交信息”  文件  # 提交某个文件</p></li><li><p>git log # 显示所有提交记录<br>git log –pretty&#x3D;oneline   # 一行显示版本信息</p></li></ol><p>补充：</p><pre><code>    # 会显示所有关于这个id以及之前的修改记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac     # 加上-1参数表示我们只想看到一行记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac -1 </code></pre><p>而如果想要查看这条提交记录具体修改了什么内容，可以在命令中加入p参数，命令如下:</p><pre><code>    git log Ifa380b502a00b82bfc8d84c5ab5el5b8fbf7dac -1 -p</code></pre><ol start="6"><li><p>git reset  –hard 版本id  # 回退版本</p></li><li><p>git reflog   # 查看所有版本信息</p></li><li><p>git diff  # 表示未使用add命令时的修改</p></li></ol><p>这样可以查看到所有文件的更改内容，比如你只想查看MainActivity.java这个文件的更改内容，可以使用如下命令：</p><pre><code>    git diff app/src/main/java/com/example/providertest/MainActivity.java</code></pre><p>vs：git log 表示最近的改变，git reflog可以看到所有的改变<br>如果文件未被跟踪,即没有使用git add这个命令时,文件为红色,如果使用这个命令,则文件变为绿色。这里涉及到一个知识点，git的本地三个区域+远程仓库<br><a href="https://imgse.com/i/ppf2YPP"><img src="https://s1.ax1x.com/2023/04/02/ppf2YPP.png" alt="ppf2YPP.png"></a></p><p><code>Workspace：</code>工作区，就是你平时存放项目代码的地方;</p><p><code>Index / Stage：</code>暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）;</p><p><code>Repository：</code>仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本;</p><p><code>Remote：</code>远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换;</p><ul><li>git add 是将代码从工作区加入到暂存区</li><li>git commit 是将代码从暂存区递交到本地仓库</li><li>git push则是由本地推送到远程仓库</li></ul><h2 id="1-6-远程仓库-Github"><a href="#1-6-远程仓库-Github" class="headerlink" title="1.6 远程仓库(Github)"></a>1.6 远程仓库(Github)</h2><p>新添加远程仓库</p><pre><code>    git remote add [shortname] [url]</code></pre><p>查看当前的远程库，要查看当前配置有哪些远程仓库，可以用命令：</p><pre><code>    git remote</code></pre><p>提取远程仓库，Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><pre><code>    git fetch</code></pre><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><pre><code>    git merg</code></pre><p>删除远程仓库，删除远程仓库你可以使用命令：</p><pre><code>    git remote rm [别名]</code></pre><h2 id="1-7-创建分支"><a href="#1-7-创建分支" class="headerlink" title="1.7 创建分支"></a>1.7 创建分支</h2><p>多人协作完成一个项目的时候，不同的人需要完成不同的功能，这时候就需要创建分支。</p><pre><code>    # 列出所有本地分支    git branch        # 列出所有远程分支    git branch -r        # 新建一个分支，但依然停留在当前分支    git branch [branchname]        # 新建一个分支，并切换到该分支    git checkout -b [branchname]    # 切换到主分支    $ git checkout master           # 合并指定分支到当前分支    $ git merge [branchname]        # 删除分支    $ git branch -d [branchname]        # 删除远程分支    $ git push origin --delete [branchname]    $ git branch -dr [remote/branch]</code></pre><h2 id="1-8-标签"><a href="#1-8-标签" class="headerlink" title="1.8 标签"></a>1.8 标签</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。<br>Git有commit，为什么还要引入tag？</p><pre><code>    “请把上周一的那个版本打包发布，commit号是6a5819e...”    “一串乱七八糟的数字不好找！”</code></pre><p>如果换一个办法：</p><pre><code>    “请把上周一的那个版本打包发布，版本号是v1.2”    “好的，按照tag v1.2查找commit就行！”</code></pre><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><ul><li>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</tagname></li><li>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></li><li>命令git tag可以查看所有标签。</li><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs&#x2F;tags&#x2F;<tagname>可以删除一个远程标签。</tagname></li></ul><h2 id="开发实际常用的指令"><a href="#开发实际常用的指令" class="headerlink" title="开发实际常用的指令"></a>开发实际常用的指令</h2><h3 id="只导出某个分支的改动"><a href="#只导出某个分支的改动" class="headerlink" title="只导出某个分支的改动"></a>只导出某个分支的改动</h3><pre><code>git log --pretty=%H 要导出的分支名 --not origin/基线分支</code></pre><p>比如A分支基于B分支创建，然后合了C分支到A，这时只想输出A分支的记录，可以这样：</p><pre><code>git log --pretty=%H A --not origin/B</code></pre><p>如果都是远端分支，则都需要加上origin&#x2F;</p><h3 id="在主库提交子库改动"><a href="#在主库提交子库改动" class="headerlink" title="在主库提交子库改动"></a>在主库提交子库改动</h3><p>一般为仓库包含有submodule时的场景，比如Qt5，改了qtbase后，qt5主库也需要commit一条空记录，否则取代码可能取不到最新的</p><p>子库先add commit后切换到主库：git diff HEAD –no-color –submodule –得到子库的改动信息</p><p>然后git add .（.可以换成对应子库），最后git commit 加上前面得到的改动信息</p><p>PS，Qt5仓库可以直接用qrepo update-super</p><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>使用命令行查看日志时不太方便同时查看代码改动，这时候可以借助 Git 可视化工具查看日志。Git 自身带有两个可视化工具，gitk和git-gui，其中gitk是一个历史记录的图形化查看器。只需要使用gitk命令即可打开可视化界面：</p><pre><code>    $ gitk &amp;</code></pre><h3 id="设置提交模板"><a href="#设置提交模板" class="headerlink" title="设置提交模板"></a>设置提交模板</h3><p>对提交信息的格式有相应的要求，可以设置提交模板来规范自己的提交信息，以后提交代码的时候在模板上修改即可。例如，在 C 盘下新建 git_template.txt，填入以下信息：</p><pre><code>    【项目：】【ones:】本次入库概要说明    【原因：】    【改动：】    【影响面：】    【模块：】【公共模块：是/否】【影响版本：不区分版本/Linux/XXXX】</code></pre><p>再运行以下的命令设置提交模板：</p><pre><code>    $ git config --global commit.template C:/git_template.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git开发环境应用</title>
      <link href="/p/e69805ba.html"/>
      <url>/p/e69805ba.html</url>
      
        <content type="html"><![CDATA[<h1 id="git开发环境应用"><a href="#git开发环境应用" class="headerlink" title="git开发环境应用"></a>git开发环境应用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们已经介绍了git <a href="https://whl963854.github.io/p/1.html">https://whl963854.github.io/p/1.html</a><br>但是和开发需求相比还是不够详细以及不具有较强的开发针对性。<br>所以本文主要介绍开发环境下常用的 Git 命令。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="查看本地仓库状态"><a href="#查看本地仓库状态" class="headerlink" title="查看本地仓库状态"></a>查看本地仓库状态</h3><pre><code>$ git status</code></pre><p>可以随时使用该命令查看当前仓库的状态，输出的信息很详细，甚至会提示下一步操作需要的命令，务必多使用该命令且不要忽略 status 输出的信息。</p><h3 id="Git-帮助文档"><a href="#Git-帮助文档" class="headerlink" title="Git 帮助文档"></a>Git 帮助文档</h3><pre><code>$ git help &lt;command&gt;$ git &lt;command&gt; --help# 输出简略的参数选项$ git &lt;command&gt; -h</code></pre><p>使用 help 命令可以查看详细 Git 的帮助文档，如git help status。如果不想要太详细的手册，而只是需要快速参考一下有哪些可用选项，那么可以使用-h参数，如</p><pre><code>git status -h。</code></pre><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><pre><code>$ git init</code></pre><p>将当前文件夹­初始化为一个 git 仓库，也可以在后面指定目录。</p><h3 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h3><pre><code>$ git clone &lt;url&gt;</code></pre><p>clone 代码仓库到本地，可使用 HTTP 和 SSL 传输协议。在 clone 仓库的时候，如果不使用特定参数的话，一般会把远程仓库命名为 origin，且 Git 会自动将本地分支与远程仓库的同名分支建立一种追踪关系（tracking）。如本地的master分支会自动“追踪”origin&#x2F;master分支，这也是我们拉取、推送代码等操作可以不指定分支名的原因。</p><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><pre><code>$ git log</code></pre><p>有很多参数可以选择，使用git log –help可以查看支持的参数，不做过多介绍，开发过程中建议使用 Git 可视化工具。</p><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>使用命令行查看日志时不太方便同时查看代码改动，这时候可以借助 Git 可视化工具查看日志。Git 自身带有两个可视化工具，gitk和git-gui，其中gitk是一个历史记录的图形化查看器。只需要使用gitk命令即可打开可视化界面：</p><pre><code>$ gitk &amp;</code></pre><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>使用git config命令可以设置 Git 的外观和行为，Git 的配置文件有三个级别：</p><ol><li>系统级配置（–system），一般在&#x2F;etc&#x2F;gitconfig</li><li>用户级配置（–global），一般在<del>&#x2F;.gitconfig或</del>&#x2F;.config&#x2F;git&#x2F;config</li><li>仓库级配置（–local），一般在当前仓库的.git文件夹中，即.git&#x2F;config</li></ol><p>每一个级别会覆盖上一级别的配置。一般没有什么特殊要求的话，推荐直接使用 –global。</p><h3 id="查看-Git-配置"><a href="#查看-Git-配置" class="headerlink" title="查看 Git 配置"></a>查看 Git 配置</h3><pre><code>$ git config --list# 查看 Git 配置以及它们所在的文件$ git config --list --show-origin</code></pre><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><pre><code># 设置用户名$ git config --global user.name ﻿&lt;na­me&gt;# 设置邮箱$ git config --global user.email ﻿&lt;em­ail&gt;</code></pre><h3 id="设置文本编辑器"><a href="#设置文本编辑器" class="headerlink" title="设置文本编辑器"></a>设置文本编辑器</h3><p>Git 默认的文本编辑器是 vim，可将其换成 notepad++ 和 vscode 等主流编辑器。下面的命令可以将 Git 的文本编辑器设置为 Notepad++（注意 npp 的安装路径），之后的介绍也会基于文本编辑器是 Notepad++ 的情况说明。</p><pre><code>$ git config --global core.editor &quot;&#39;C:/Program Files/Notepad++/notepad++.exe&#39; -multiInst -notabbar -nosession -noPlugin&quot;</code></pre><h3 id="设置-Git-命令别名"><a href="#设置-Git-命令别名" class="headerlink" title="设置 Git 命令别名"></a>设置 Git 命令别名</h3><p>Git 支持为命令设置别名，但如果还不能很熟练地使用 Git 的话，并不推荐这么做，建议先好好熟悉 Git 命令的使用。使用alias.&lt;别名&gt; &lt;git命令&gt;的形式，就可以为相关的命令设置别名。</p><pre><code>$ git config --global alias.ci commit$ git config --global alias.st status$ git config --global alias.unstage &#39;reset HEAD --&#39;</code></pre><h3 id="设置提交模板"><a href="#设置提交模板" class="headerlink" title="设置提交模板"></a>设置提交模板</h3><p>对提交信息的格式有相应的要求，可以设置提交模板来规范自己的提交信息，以后提交代码的时候在模板上修改即可。例如，在 C 盘下新建 git_template.txt，填入以下信息：</p><pre><code>【项目：】【ones:】本次入库概要说明【原因：】【改动：】【影响面：】【模块：】【公共模块：是/否】【影响版本：不区分版本/Linux/XXXX】</code></pre><p>再运行以下的命令设置提交模板：</p><pre><code>$ git config --global commit.template C:/git_template.txt</code></pre><h3 id="跨平台换行符配置"><a href="#跨平台换行符配置" class="headerlink" title="跨平台换行符配置"></a>跨平台换行符配置</h3><p>跨平台编写代码时可能会遇到 CRLF 问题。这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 macOS 使用回车（CR），Linux 使用换行（LF）一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。<br>Git 可以用core.autocrlf来处理换行符的协作问题。设置为true可以在提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行（一般用于 Windows 平台）。设置为input可以在提交时把回车和换行转换成换行，检出时不转换（一般用于 mac 和 linux平台）。<br>目前 WPS 的要求是关闭跨平台换行符自动转换，所以请设置为false。</p><pre><code>$ git config --global core.autocrlf false</code></pre><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>Git 的分支，其本质是一个指向提交对象的可变指针，创建分支也仅仅只是创建了一个指针。那么 Git 是如何知道当前在哪一个分支上呢？答案是有一个名为 HEAD 的指针会指向当前所在的本地分支（可以将 HEAD 指针想象为当前分支的别名）。<br>分支在 Git 中是一个非常重要的概念，要详细介绍的话难免要说明很多 Git 的原理。考虑到一般开发过程中涉及分支的操作并不是很多，所以只会介绍一些常用的命令。</p><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><p>$ git branch﻿查看本地分支­，后面­添加分­支名即­可创建新分支。<br>4.2 切换分支<br>$ git checkout <branch>4.3 合并分支<br>合并分支一般有两种方式：merge和rebase。虽然 rebase 可以用来合并代码，但开发过程中并不推荐通过 rebase 来合并分支，因为变基是有风险的，不正确的使用反而会造成代码混乱。之所以介绍这个命令，是为了后续说明git pull –rebase。<br>4.3.1 使用 merge 合并代码<br>$ git merge <branch>如果你想将 dev 分支合并到 master 分支，那么首先切换到 master 分支，然后运行git merge dev即可合并代码。如果你本地没有 dev 分支，更新代码抑或运行git merge origin&#x2F;dev。<br>下面是 merge 的参数介绍：<br>• -e, –edit<br>合并之后提交之前，打开外部编辑器，编辑自动生成的提交信息。一般不建议编辑自动生成的合并信息。<br>• –ff 和 –no-ff<br>使用快进合并（fast-forward merge）和不使用快进合并。<br>首先说明一下何为快进合并：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支（没有冲突），那么 Git 在合并两者的时候，只会简单的将指针向前推进，因为这种情况下的合并操作没有需要解决的分歧——这就叫做“快进（fast-forward）”。当使用 fast-forward 模式进行合并时，﻿在能快进的时候将不会创建合并节点（不能快进时仍会创建合并节点），fast-forward 模式是 git merge 默认开启的。而如果不使用 fast-forward 模式，即使合并能够快进合并，Git 也会创建一个新的合并节点。<br>• Git 快进合并<br>• Git 非快进合并<br>可以看到，快进合并的历史记录是一条直线没有分叉，看不出来代码是合并过来的，而非快进合并的历史纪录会多出一个合并节点，为了保证版本演进的清晰，一般希望采用非快进合并。<br>4.3.2 使用 rebase 合并代码<br>rebase 可以用来将某一分支的所有修改都移至另一个分支，以 dev 分支合并到 master 分支举例，就好像将 dev 分支上的所有修改依次重新应用到 master 分支上。这样处理之后的结果，就可以使无法快进合并的分支变成可以使用 merge 快进合并。<br>举例说明，如果你想将 dev 分支合并到 master 分支，那么执行以下操作：<br>$ git checkout dev<br>$ git rebase master</branch></branch></p><h1 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h1><p>$ git checkout master<br>$ git merge dev可以看到，最后还是使用 merge 合并了分支。使用 rebase 合并的意义在于保持提交记录的线性，即用 rebase 解决代码冲突之后再用 merge 的快进合并。再次强调，开发过程中并不推荐通过 rebase 来合并分支。<br>4.4 拉取代码<br>$ git pull –rebase拉取远程仓库的代码推荐使用上面的命令，接下来会说明为什么。<br>4.4.1 git fetch<br>git fetch命令会从远程仓库取回所有分支的更新，但不会修改本地工作目录的内容，拉取后的更新需要本地再合并。如下图所示，运行git fetch后 HEAD 指针并没有变化。<br>这时候运行git status会提示合并，使用git merge或者git rebase可以合并代码。<br>4.4.2 git pull<br>使用 fetch 拉取代码如此繁琐，自然就会有简化的命令。git pull可以取回某个分支的更新并与本地的分支合并，在大多数情况下它等于git fetch + git merge。<br>git pull 使用 merge 进行自动合并，如果本地有未推送的提交且云端有更新，git pull 会自动合并代码，这会在提交历史上生成一个合并节点。毫无疑问，这明显污染了历史记录的整洁。下图很明显地说明了这一点，这样的合并节点对历史记录没有任何作用，因为我们本身并没有对分支进行了合并操作。<br>实际开发过程中，不推荐使用 git pull 更新代码，但介绍一种可以使用 git pull 的情况：<br>﻿如果使用 git merge 合并了一个分支，推送代码的时候发现远程仓库有更新导致需要先更新本地代码，这时如果使用 rebase 更新代码，会导致 git merge 自动生成的 merge 节点丢失。由于 WGS 是根据最后一个提交的 commit id 来判断是否能入库的，如果 merge 节点丢失，会导致无法入库需要重新审批。对于这种情况，可以使用 git pull 更新代码（对于金山的代码平台来说，git pull 自动合并生成的节点是可以入库的，不需要重新提交代码申请）。<br>4.4.3 git pull –rebase<br>指定 –rebase 参数可以让 git pull 以 rebase 模式合并代码，即git pull –rebase等于git fetch + git rebase。rebase会重新应用你本地的提交，这会使历史记录是线性的。在开发过程中，推荐总是使用git pull –rebase更新代码。</p><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>提交代码的一般流程为：将已修改（Modified）的文件或未跟踪（Untracked，一般是新建的文件）的文件添加（add）到暂存区（Staged），再将暂存区的文件提交（commit）到本地分支，最后将本地的提交推送（push）到远程仓库。<br>Git 的工作流和文件状态一般如下图所示：<br>5.1 查看代码改动<br>diff命令可以查看文件的具体改动，提交代码之前首先要确认自己的改动是没有问题的。diff 可以添加参数查看不同情况下的文件改动，但开发过程中建议使用可视化工具而不是命令行，所以这里只会简单介绍。</p><h1 id="查看尚未暂存的文件有哪些修改"><a href="#查看尚未暂存的文件有哪些修改" class="headerlink" title="查看尚未暂存的文件有哪些修改"></a>查看尚未暂存的文件有哪些修改</h1><p>$ git diff</p><h1 id="查看已暂存的文件有哪些修改"><a href="#查看已暂存的文件有哪些修改" class="headerlink" title="查看已暂存的文件有哪些修改"></a>查看已暂存的文件有哪些修改</h1><p>$ git diff –staged</p><h1 id="查看最近一次已提交代码的改动"><a href="#查看最近一次已提交代码的改动" class="headerlink" title="查看最近一次已提交代码的改动"></a>查看最近一次已提交代码的改动</h1><p>$ git diff HEAD~5.2 将代码添加到暂存区</p><h1 id="添加指定文件或目录到暂存区"><a href="#添加指定文件或目录到暂存区" class="headerlink" title="添加指定文件或目录到暂存区"></a>添加指定文件或目录到暂存区</h1><p>$ git add ﻿&lt;di­rec­tor­y&gt;</p><h1 id="将工作区的所有修改添加到暂存区"><a href="#将工作区的所有修改添加到暂存区" class="headerlink" title="将工作区的所有修改添加到暂存区"></a>将工作区的所有修改添加到暂存区</h1><p>$ git add .5.3 提交代码到本地分支</p><h1 id="提交暂存区的代码，并打开文本编辑器编写提交信息"><a href="#提交暂存区的代码，并打开文本编辑器编写提交信息" class="headerlink" title="提交暂存区的代码，并打开文本编辑器编写提交信息"></a>提交暂存区的代码，并打开文本编辑器编写提交信息</h1><p>$ git commit</p><h1 id="将提交信息与命令放在同一行"><a href="#将提交信息与命令放在同一行" class="headerlink" title="将提交信息与命令放在同一行"></a>将提交信息与命令放在同一行</h1><p>$ git commit -m <commit description></commit></p><h1 id="跳过暂存区直接提交修改的代码，即跳过-git-add-的操作"><a href="#跳过暂存区直接提交修改的代码，即跳过-git-add-的操作" class="headerlink" title="跳过暂存区直接提交修改的代码，即跳过 git add 的操作"></a>跳过暂存区直接提交修改的代码，即跳过 git add 的操作</h1><p>$ git commit -a<br>$ git commit -am <commit description>5.4 推送代码到远程仓库<br>$ git push</commit></p><h2 id="撤消改动"><a href="#撤消改动" class="headerlink" title="撤消改动"></a>撤消改动</h2><p>修改代码到推送的过程中，总会遇到想要撤消某些操作的情况，使用相关的 Git 命令可以快速达成我们的目的。但要注意，有些撤消操作是不可逆的，所以注意不要因为自己的操作失败导致改动丢失。不过在 Git 中，只要代码提交过，那一般都是可以恢复的，在讲 Git 引用日志的时候会介绍。<br>6.1 删除未跟踪（untrack）的文件<br>使用git clean命令可以用来删除 untrack 的文件。默认情况下，git clean 命令只会移除没有忽略（ignore）的未跟踪文件，即任何与.gitignore或其他忽略文件中的模式匹配的文件都不会被移除。它有以下参数：<br>• -n 显示会被删除的文件，这意味着“做一次演习然后告诉你将要移除什么”。如果你担心重要的文件被误删，那么建议先使用该参数看一下 git clean 会删除那些文件。<br>• -f <path></path> -f 意味着”确定要移除”(force)，后面可以指定路径，如果不指定路径就是当前目录。<br>• -d 会移除 untrack 的文件夹。<br>• -x 会删除当前目录下的所有 untrack 的文件和文件夹，即使是被忽略的文件，使用该参数要谨慎，很可能不是你想要的结果。<br>$ git clean -f<br>$ git clean -df<br>$ git clean -ndf6.2 撤消对文件的修改<br>使用该命令前请了解撤消的后果，撤消之后无法恢复。</p><h1 id="撤消指定文件的修改"><a href="#撤消指定文件的修改" class="headerlink" title="撤消指定文件的修改"></a>撤消指定文件的修改</h1><p>$ git checkout – <filename></filename></p><h1 id="撤消所有文件的修改，此命令不会删除掉刚新建的文件，因为新建的文件还在是未跟踪状态。"><a href="#撤消所有文件的修改，此命令不会删除掉刚新建的文件，因为新建的文件还在是未跟踪状态。" class="headerlink" title="撤消所有文件的修改，此命令不会删除掉刚新建的文件，因为新建的文件还在是未跟踪状态。"></a>撤消所有文件的修改，此命令不会删除掉刚新建的文件，因为新建的文件还在是未跟踪状态。</h1><p>$ git checkout .6.3 取消暂存的文件（撤消 git add 操作）</p><h1 id="将指定文件从暂存区取消"><a href="#将指定文件从暂存区取消" class="headerlink" title="将指定文件从暂存区取消"></a>将指定文件从暂存区取消</h1><p>$ git reset HEAD <filename></filename></p><h1 id="将所有文件从暂存区取消，即将代码回退到-git-add-之前"><a href="#将所有文件从暂存区取消，即将代码回退到-git-add-之前" class="headerlink" title="将所有文件从暂存区取消，即将代码回退到 git add 之前"></a>将所有文件从暂存区取消，即将代码回退到 git add 之前</h1><p>git reset HEAD .6.4 撤消本地提交（撤消 git commit 操作）<br>使用git reset可以撤消已经提交到本地分支的代码，它的使用形式如下：<br>$ git reset –[mixed | soft | hard] ﻿&lt;co­mmi­t&gt;• –mixed 撤消 commit，并且撤消 git add 操作，不会删除工作空间改动的代码。是默认参数。<br>• –soft 撤消 commit，不撤消 git add 操作，不会删除工作空间改动的代码。代码回到暂存区状态。<br>• –hard 撤消 commit，并且撤消 git add 操作，会删除工作空间改动的代码。代码回到上一次的 commit 状态。</p><h1 id="撤消上一次提交"><a href="#撤消上一次提交" class="headerlink" title="撤消上一次提交"></a>撤消上一次提交</h1><p>$ git reset HEAD~</p><h1 id="撤消近两次提交到暂存区"><a href="#撤消近两次提交到暂存区" class="headerlink" title="撤消近两次提交到暂存区"></a>撤消近两次提交到暂存区</h1><p>$ git reset –soft HEAD<del>26.5 撤消远程仓库的提交（撤消 git push 操作）<br>虽然 Git 提供了命令可以强制修改远程仓库的提交，但这么操作极容易影响到协同开发，一般不推荐强制修改远程仓库的历史。如果想要撤消一条远程仓库的提交，推荐本地回滚代码后再推送到远程仓库。revert命令可以撤消一个已存在的提交并生成一个新的相反的提交（一般不建议修改自动生成的提交信息），然后再将该提交推送到远程仓库即可。<br>$ git revert <commit><br>$ git push6.6 使用 ~ &amp; ^<br>对于不方便记忆的 commit id，开发过程中经常会使用 ~ 和 ^ 去追溯代码。<br>• ref</commit></del> 是 ref<del>1 的简写，表示提交(ref)的第一个父级。ref</del>2表示提交第一个父级的第一个父级，依次类推。<br>• ref^ 是 ref^1 的简写，表示提交(ref)的第一个父级。与 ~ 不同的时，ref^2 表示提交的第二个父级（对于一个 merge 节点会有两个父级），依次类推。<br>^ 和 ~ 可以组合使用，下面举例说明：<br>上面是一个 Git 的历史记录，下图截取了其中的一段记录说明了 ^ 和 ~ 的区别。一般而言，如果你只是想回溯代码，那么使用 ~ 通常能得到你想要的结果。</p><h2 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h2><p>开发过程中经常会遇到需要将一个分支的代码合并到另一个分支的情况。我们一般使用git merge合并分支，但也会遇到只需要合并部分代码的情况，下面会介绍相关的命令。<br>7.1 cherry-pick<br>$ git cherry-pick -sx <commit_id>cherry-pick 可以合并其它分支已有的提交（本地提交或远程提交），它有以下参数：<br>• -x 在提交信息的末尾追加一行（cherry picked from commit …），方便以后查到这个提交是如何产生的，如果你合并的是一个远程仓库的提交，那么建议加上这个参数。<br>• -s 在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。<br>• -e 合并之后提交之前，打开外部编辑器，编辑自动生成的提交信息。一般不需要使用这个参数去编辑提交信息。<br>cherry-pick 也可以使用..合并多个连续的提交。</commit_id></p><h1 id="左开右闭区间，不会包含-commit-a"><a href="#左开右闭区间，不会包含-commit-a" class="headerlink" title="左开右闭区间，不会包含 commit_a"></a>左开右闭区间，不会包含 commit_a</h1><p>$ git cherry-pick <commit_a>..<commit_b></commit_b></commit_a></p><h1 id="左闭右闭区间，包含commit-a"><a href="#左闭右闭区间，包含commit-a" class="headerlink" title="左闭右闭区间，包含commit_a"></a>左闭右闭区间，包含commit_a</h1><p>$ git cherry-pick <commit_a>^..<commit_b>7.2 生成和打入补丁<br>Git 提供了两种补丁方案，一是用git diff生成的 UNIX 标准补丁.diff文件，二是git format-patch生成的 Git 专用.patch文件。.diff不带有 commit 记录信息，而.patch是带有 commit 记录信息的，且每个 commit 对应一个 patch 文件，所以推荐使用 patch 补丁。<br>7.2.1 生成 patch</commit_b></commit_a></p><h1 id="生成最近一次提交的-patch"><a href="#生成最近一次提交的-patch" class="headerlink" title="生成最近一次提交的 patch"></a>生成最近一次提交的 patch</h1><p>$ git format-patch HEAD~</p><h1 id="生成最近几次提交的-patch"><a href="#生成最近几次提交的-patch" class="headerlink" title="生成最近几次提交的 patch"></a>生成最近几次提交的 patch</h1><p>$ git format-patch HEAD~n</p><h1 id="生成某次提交（含）之前几次提交的-patch"><a href="#生成某次提交（含）之前几次提交的-patch" class="headerlink" title="生成某次提交（含）之前几次提交的 patch"></a>生成某次提交（含）之前几次提交的 patch</h1><p>$ git format-patch <commit> -n</commit></p><h1 id="生成某两次提交之间的-patch，左开右闭区间"><a href="#生成某两次提交之间的-patch，左开右闭区间" class="headerlink" title="生成某两次提交之间的 patch，左开右闭区间"></a>生成某两次提交之间的 patch，左开右闭区间</h1><p>$ git format-patch <commit_a>..<commit_b>7.2.2 打入 patch</commit_b></commit_a></p><h1 id="打入-patch-并生成提交"><a href="#打入-patch-并生成提交" class="headerlink" title="打入 patch 并生成提交"></a>打入 patch 并生成提交</h1><p>$ git am –keep-cr xxx.patch</p><h1 id="仅打入-patch-而不会生成提交"><a href="#仅打入-patch-而不会生成提交" class="headerlink" title="仅打入 patch 而不会生成提交"></a>仅打入 patch 而不会生成提交</h1><p>$ git apply xxx.patchgit apply仅仅是应用 patch，而不会生成提交，对于.patch文件，不推荐使用 apply 命令。使用git am不仅能应用 patch 里的改动，还能根据 patch 里面的提交信息生成新的提交，如果你要打入别人的 patch，那么请使用 git am 命令，这会保留原作者的信息。注：am 的意思即为应用（Apply）一系列来自邮箱（Mailbox）的补丁。<br>• 关于 git am 的参数 –keep-cr<br>patch 文件中以 CRLF 结尾的行，git am默认行为会将回车符 CR 移除。加上 –keep-cr 可以防止这一默认行为，即保留回车符。如果不使用该参数，通过 am 打入 patch 时可能会报错。<br>7.2.3 打入补丁时遇到冲突<br>打入补丁时如果遇到冲突会导致失败，这时候可以使用以下命令自动合入 patch 中不冲突的代码改动，同时保留冲突的部分：<br>$ git am –keep-cr –3way xxx.patch–3way参数指示git使用三方合并，这样就与解决合并冲突是一样的，冲突解决好之后运行git am –continue即可。<br>如果上述方法打入patch失败的话，也可以使用下面的命令打入patch。<br>$ git am –keep-cr –reject xxxx.patch这时会生成后缀为.rej的文件，保存没有合并的冲突内容，参考这些文件解决冲突。冲突解决后删除后缀为.rej的文件并将代码添加到暂存区（git add），然后运行git am –continue提交即可。<br>8. 历史记录<br>在多人协同开发的过程中日志的重要性不言而喻，Git 可以查到每一行代码是怎么产生的，好的日志起到了文档的作用，可以帮助其他人快速地熟悉代码，所以提交代码时也应该注意日志的重要性。<br>一个好的提交应该具备以下几个特点：<br>• 一个提交只做一件事情。<br>• 一个提交的改动不应该过多。过多可能意味着这个提交做了太多的事情，也许应该考虑拆分提交。<br>• 提交信息应该能详细说明改动的理由和造成的影响。<br>在基础命令里面稍微介绍了一下 log 命令，一般我们使用git log查看历史记录，log 命令有很多参数可以定制化输出格式。开发过程中建议使用可视化工具查看日志，因为这能同时看到代码改动详情，所以这里不会过多介绍 log 的参数，而是会介绍如何更好地借助 log 帮助开发和如何让 log 保持整洁。<br>8.1 查看字符串改动<br>$ git log -S <string>git log 的-S参数接受一个字符串参数，用来显示那些添加或删除了该字符串的提交。如下图所示：<br>8.2 查看一个文件是何时被删除的</string></p><h1 id="查看一个文件或目录的历史记录"><a href="#查看一个文件或目录的历史记录" class="headerlink" title="查看一个文件或目录的历史记录"></a>查看一个文件或目录的历史记录</h1><p>$ git log – <path></path>在 git log 的最后指定文件名或者目录并用–隔开，则可以只看到文件或者目录的历史改动。如果这个文件被删除了，则可以用来查找这个文件是何时被删除的。<br>8.3 Git 引用日志<br>$ git reflog当你在工作时，Git 会在后台保存一个引用日志（reflog），引用日志记录了 HEAD 和分支引用所指向的历史。Git 会默默地记录每一次改变 HEAD 时它的值。每一次提交或改变分支，引用日志都会被更新。通过使用引用日志，可以恢复丢失的提交。<br>引用日志只存在于本地仓库，它只是一个记录你在自己的仓库里做过什么的日志。引用日志的数据存放在.git&#x2F;logs&#x2F;目录中。<br>8.4 追踪代码改动<br>$ git blame使用 git blame 可以追踪代码里面的每一个改动，如果你发现了代码中的一个 bug，想知道是什么时候由谁引入的，可以使用该命令查找到相关的信息。使用-L参数还可以限制文件中的代码行，默认是所有行。实际开发过程中建议使用 Git 可视化工具。<br>8.5 调整历史记录<br>在开发过程中，很多时候我们都可能需要修订历史记录，也许只是提交信息写错了，或是多条记录里面的某一条记录的代码有问题想要重新修改，又或是一条提交里面代码太多了想要拆分。在代码提交到远程仓库之前，我们都可以在本地随便修改历史记录。然而一旦将代码推送到了远程仓库，那么除非特殊情况，都不建议直接修改远程仓库的历史记录。简而言之，我们应该重视历史记录，如果历史记录有问题，就不应该将代码推送到远程仓库。<br>8.5.1 修改最近一次提交</p><h1 id="修改最后一次提交，或是仅修改最后一次提交的提交信息"><a href="#修改最后一次提交，或是仅修改最后一次提交的提交信息" class="headerlink" title="修改最后一次提交，或是仅修改最后一次提交的提交信息"></a>修改最后一次提交，或是仅修改最后一次提交的提交信息</h1><p>$ git commit –amend如果你只是想修改最近一次提交记录，那么可以使用上面的命令，这个命令会将暂存区的文件提交到上一条记录，如果暂存区没有改动，那这个命令仅仅只是修改提交信息。<br>8.5.2 修改多个提交<br>如果你的本地代码里面有多个提交，而你想要修改的提交记录并不是最近的那条提交，那么你就需要利用其它命令去修改历史记录。<br>Git 其实并没有一个改变历史记录的工具，但是却可以利用变基命令来变基一系列提交，从而达到修改历史记录的目的。通过变基命令，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。通过给git rebase增加-i选项来指定想要重写多久远的历史。<br>$ git rebase -i HEAD<del>n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给git rebase -i命令，即 HEAD</del>3。记住<del>3可能比较容易，因为你正尝试修改最后三次提交，但是注意实际上指定了以前的四次提交，即想要修改提交的父提交。<br>$ git rebase -i HEAD</del>3运行这个命令后 Git 会在文本编辑器上给你一个提交的列表，如下所示：<br>可以注意到，相对于 log 命令，这些提交的显示顺序是相反的，可以把这理解为一个栈，当执行变基时，它会从上至下依次应用。<br>• 调整提交顺序或删除提交<br>可以调整提交的顺序来达到重新排序提交的目的，删除提交行则可以删除相应的提交。例如我把 faf9176 “add utils” 放到最前面，保存后退出历史记录就会变成下图所示：<br>• 修改某一条提交<br>上图中，像 “temp” 这条记录表述不严谨，需要修改提交信息，那么可以将提交前面的pick改为edit，就可以修改相应的提交。<br>变基命令重新应用提交时，遇到edit的提交就会停下来，等待你完成修改。你可以调整你的改动，抑或只是调整提交信息，当完成修改后，运行git rebase –continue就可以继续变基命令。<br>这里我运行git commit –amend修改提交信息：<br>• 合并提交<br>或许你会觉得上图中最近的两条记录可以合成一条记录，因为它们都是对于 README 的改动，没有必要写成两条记录，那么可以使用squash参数合并提交。<br>保存并退出编辑器后，git 会合并相应的提交并弹出新的编辑框来让你合并相关记录的提交信息。<br>当调整完提交信息之后，运行 log 命令可以看到两条提交记录已经被合并了。<br>• 其它<br>变基命令可以做到很多事情，例如你可以使用reword参数来修改某次改动的提交信息，又或是使用edit参数并结合git reset命令来拆分一个很大的提交等等。在操作过程中，Git 都会有相应的提示，开发过程中留意 Git 的提示信息并多尝试使用相关的命令即可，这里不再做过多介绍。<br>最后提醒一下：这是一个变基命令，这意味着这些提交都会被重新应用一次，所以不要修改到已经推送到远程仓库的提交。<br>9. 贮藏改动<br>$ git stash</p><h1 id="也会贮藏未跟踪的文件（不会包含已忽略的文件）"><a href="#也会贮藏未跟踪的文件（不会包含已忽略的文件）" class="headerlink" title="也会贮藏未跟踪的文件（不会包含已忽略的文件）"></a>也会贮藏未跟踪的文件（不会包含已忽略的文件）</h1><p>$ git stash -u有时，当你的工作做到一半的时候，你的代码已经有了一些改动，而这时你需要切换到另外一个分支干活，又或是有更紧急的事情需要处理。这时，你不可能为还没有做完的改动创建一次提交，而针对这种情况，就可以使用git stash命令贮藏代码改动。stash 会贮藏文件的修改并将其保存到一个栈上，而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。<br>默认情况下，git stash只会贮藏已跟踪的文件，如果指定-u参数，stash 也会贮藏未跟踪的文件（不会包含已忽略的文件）。<br>9.1 贮藏列表<br>$ git stash list该命令列出所有贮藏的改动，一条贮藏记录使用stash@{n}表示，注意这是一个栈，最后贮藏的改动会显示在最上面。<br>9.2 应用贮藏改动</p><h1 id="应用最近一次贮藏的改动"><a href="#应用最近一次贮藏的改动" class="headerlink" title="应用最近一次贮藏的改动"></a>应用最近一次贮藏的改动</h1><p>$ git stash apply</p><h1 id="应用最近一次贮藏的改动，并将这条贮藏改动从栈上丢弃"><a href="#应用最近一次贮藏的改动，并将这条贮藏改动从栈上丢弃" class="headerlink" title="应用最近一次贮藏的改动，并将这条贮藏改动从栈上丢弃"></a>应用最近一次贮藏的改动，并将这条贮藏改动从栈上丢弃</h1><p>$ git stash pop</p><h1 id="应用-stash-2-的贮藏改动"><a href="#应用-stash-2-的贮藏改动" class="headerlink" title="应用 stash@{2} 的贮藏改动"></a>应用 stash@{2} 的贮藏改动</h1><p>$ git stash apply stash@{2}9.3 丢弃贮藏改动</p><h1 id="丢弃最近一次贮藏的改动"><a href="#丢弃最近一次贮藏的改动" class="headerlink" title="丢弃最近一次贮藏的改动"></a>丢弃最近一次贮藏的改动</h1><p>$ git stash drop</p><h1 id="丢弃-stash-2-的贮藏改动"><a href="#丢弃-stash-2-的贮藏改动" class="headerlink" title="丢弃 stash@{2} 的贮藏改动"></a>丢弃 stash@{2} 的贮藏改动</h1><p>$ git stash drop stash@{2}</p><h1 id="丢弃所有的贮藏改动，即清空栈"><a href="#丢弃所有的贮藏改动，即清空栈" class="headerlink" title="丢弃所有的贮藏改动，即清空栈"></a>丢弃所有的贮藏改动，即清空栈</h1><p>$ git stash clear10. 关于 krepo<br>krepo 是 WPS 内部的开发工具，可以理解为是对 Git 的封装，以便于同时操作主子库。krepo 的使用不再做过多介绍，具体使用可以看 krepo 的说明文档。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/p/48003.html"/>
      <url>/p/48003.html</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式也称为委托模式。<br>作用： 找一个对象来替我们访问某个对象。<br>意图:  为其他对象提供一种代理以控制对这个对象的访问。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F_20220922190144062739.png" alt="代理模式"></p><h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><p>代理模式的共同优点如下：</p><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li></ol><p>此外，不同类型的代理模式也具有独特的优点，例如：</p><ol><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li><li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</li><li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>租房子模型</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public:    virtual void rentHouse() = 0;&#125;;class Mike :public Person&#123;public:    void rentHouse()    &#123;        cout &lt;&lt; &quot;mike需要租一间房子！&quot; &lt;&lt; endl;    &#125;&#125;;//代理class Intermediary :public Person&#123;public:    Intermediary(Person* person) :m_Person(person) &#123;&#125;public:    void rentHouse()    &#123;        m_Person-&gt;rentHouse();        cout &lt;&lt; &quot;我是中介，我帮你找房子，但是要抽取10%佣金！&quot; &lt;&lt; endl;    &#125;private:    Person* m_Person;&#125;;//场景int main()&#123;    Person* pMike = new Mike;    //找一个中介帮忙租房子    Person* intermediary = new Intermediary(pMike);    intermediary-&gt;rentHouse();    return 0;&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;// 抽象主题类class Subject &#123;public:    virtual ~Subject() &#123;&#125;    virtual void request() = 0;&#125;;// 真实主题类class RealSubject : public Subject &#123;public:    void request() override &#123;        std::cout &lt;&lt; &quot;RealSubject: Handling request.&quot; &lt;&lt; std::endl;    &#125;&#125;;// 代理类class Proxy : public Subject &#123;public:    Proxy(std::string ip, int port) : m_ip(ip), m_port(port), m_subject(nullptr) &#123;&#125;    ~Proxy() &#123; delete m_subject; &#125;    void request() override &#123;        if (!m_subject) &#123;            connect();        &#125;        m_subject-&gt;request();    &#125;private:    std::string m_ip;    int m_port;    RealSubject* m_subject;    void connect() &#123;        std::cout &lt;&lt; &quot;Proxy: Connecting to &quot; &lt;&lt; m_ip &lt;&lt; &quot;:&quot; &lt;&lt; m_port &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;        // 模拟网络连接过程，实例化远程主题对象        m_subject = new RealSubject();    &#125;&#125;;int main() &#123;    // 客户端通过代理对象访问远程主题    Proxy proxy(&quot;127.0.0.1&quot;, 8080);    proxy.request();    return 0;&#125;</code></pre><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><pre><code>#include &lt;iostream&gt;using namespace std;class RefCount    //用于管理对象指针的次数的类&#123;    public:        RefCount():Count(0)&#123;&#125;    public:        void Add()&#123;Count++;&#125;        int Release()&#123;Count--;return Count;&#125;        void Reset()&#123;Count=0;&#125;private:    int Count;&#125;;template &lt;typename T&gt;class SmartPtr&#123;public:    SmartPtr(T* pData) &#123;           //SmartPtr&lt;A&gt; s1(new A(2));        this-&gt;pData = pData;        pRef = new RefCount();     //创建一个管理指针的count对象        pRef-&gt;Add();            //count对象次数加一    &#125;    SmartPtr(const SmartPtr&lt;T&gt;&amp; sp) &#123;    //SmartPtr&lt;A&gt; s2(s1);  以智能指针为入参构造        pData = sp.pData;        pRef = sp.pRef;        pRef-&gt;Add();    &#125;    ~SmartPtr(void)  &#123;        cout&lt;&lt;&quot; ~SmartPtr&quot;&lt;&lt;endl;        if (pRef!=NULL &amp;&amp; pRef-&gt;Release() == 0) &#123; //count对象存在且代理的数量为0            if (pData) &#123;                delete pData;                pData = NULL;            &#125;            if (pRef) &#123;                delete pRef;                pRef = NULL;            &#125;        &#125;    &#125;     T* operator-&gt;() &#123;        return pData;    &#125;    T* Get() &#123;                         //get方法返回指针对象        T* ptr = NULL;                ptr = pData;        return ptr;    &#125;private:    RefCount* pRef;    T* pData;&#125;;   //还有很多其它对象没有实现class A &#123;    public:            int i;            A(int n):i(n) &#123; &#125;;        void show() &#123;            cout&lt;&lt;&quot;I`m class A&quot;&lt;&lt;endl;        &#125;            ~A() &#123; cout &lt;&lt;&quot;class A destructed&quot; &lt;&lt; endl; &#125;&#125;;template &lt;typename T&gt;void test(SmartPtr&lt;T&gt;&amp; sp) &#123;    SmartPtr&lt;A&gt; s3(sp);    s3-&gt;show();&#125;int main() &#123;    SmartPtr&lt;A&gt; s1(new A(2));   //A对象指针托管给s1    s1-&gt;show();    SmartPtr&lt;A&gt; s2(s1);    s2-&gt;show();    test(s2);    cout&lt;&lt;&quot;before destructed&quot;&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出结果</p><pre><code>I`m class AI`m class AI`m class A~SmartPtrbefore destructed~SmartPtr~SmartPtrclass A destructed</code></pre><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul><li><p>智能指针：智能指针主要通过代理一个对象的时候，会记录引用的次数，当次数为0时释放对象</p><ul><li>智能指针是代理模式的具体应用</li><li>智能指针使用引用计数实现时，就是最好的使用代理模式的例子。</li></ul></li><li><p>保护代理：在对一个对象访问的时候，添加对不同权限的处理逻辑，这个也是交给代理做的</p></li><li><p>远程代理：为网络上的对象创建一个局部对象，所有网络通讯操作交给代理去做，让客户可以会忽略这些被代理的对象是不是远程的</p></li><li><p>虚拟代理：创建开销大的对象时候，比如显示一幅大的图片，我们将这个创建的过程交给代理去完成</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/p/65163.html"/>
      <url>/p/65163.html</url>
      
        <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>运用共享技术有效的支持大量细粒度的对象          —–《设计模式》GOF</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p><p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p><p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p><p><strong>内部状态</strong> 指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变；</p><p><strong>外部状态</strong> 指对象得以依赖的一个标记，随环境的改变而改变，不可共享。</p><p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p>如：连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里以《大话设计模式》中创建多个相似的网站为例，实现享元模式代码。</p><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;map&gt;//*************************Flyweight Pattern********************class User&#123;private:    std::string name;public:    User(const std::string&amp; strName): name(strName)&#123;&#125;    std::string GetName() const    &#123;        return name;    &#125;&#125;;class Website&#123;public:    virtual void Use(const User&amp; user) = 0;&#125;;class ConcreteWebsite : public Website&#123;private:    std::string name;public:    ConcreteWebsite(const std::string&amp; strName) : name(strName) &#123;&#125;    void Use(const User&amp; user)    &#123;        std::cout &lt;&lt; &quot;网站分类：&quot; &lt;&lt; name.c_str()&lt;&lt;&quot;, 用户：&quot;&lt;&lt; user.GetName().c_str() &lt;&lt; std::endl;    &#125;&#125;;class WebsiteFactory&#123;private:    std::map&lt;std::string, std::shared_ptr&lt;Website&gt;&gt; websiteObjs;public:    std::shared_ptr&lt;Website&gt; GetWebSiteCategory(const std::string&amp; strKey)    &#123;        if (websiteObjs.find(strKey) == websiteObjs.end())        &#123;            websiteObjs.insert(std::make_pair(strKey, std::make_shared&lt;ConcreteWebsite&gt;(strKey)));        &#125;        return websiteObjs[strKey];    &#125;    int GetWebsiteCount()    &#123;        return websiteObjs.size();    &#125;&#125;;//*******************************Test***************************int main()&#123;    std::shared_ptr&lt;WebsiteFactory&gt; factory = std::make_shared&lt;WebsiteFactory&gt;();    std::shared_ptr&lt;Website&gt; fx = factory-&gt;GetWebSiteCategory(&quot;产品展示&quot;);    std::shared_ptr&lt;User&gt; xiaocai = std::make_shared&lt;User&gt;(&quot;小菜&quot;);    fx-&gt;Use(*xiaocai);    std::shared_ptr&lt;Website&gt; fy = factory-&gt;GetWebSiteCategory(&quot;产品展示&quot;);    std::shared_ptr&lt;User&gt; daniao = std::make_shared&lt;User&gt;(&quot;大鸟&quot;);    fy-&gt;Use(*daniao);    std::shared_ptr&lt;Website&gt; fl = factory-&gt;GetWebSiteCategory(&quot;博客&quot;);    fl-&gt;Use(*xiaocai);    std::shared_ptr&lt;Website&gt; fm = factory-&gt;GetWebSiteCategory(&quot;博客&quot;);    fl-&gt;Use(*daniao);    std::cout &lt;&lt; &quot;网站对象总数：&quot; &lt;&lt; factory-&gt;GetWebsiteCount() &lt;&lt; std::endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="享元模式与单例模式的区别"><a href="#享元模式与单例模式的区别" class="headerlink" title="享元模式与单例模式的区别"></a>享元模式与单例模式的区别</h2><p>（1）享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。</p><p>（2）享元模式是为了节约内存空间，提升程序性能，而单例模式则主要是出于共享状态的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥模式</title>
      <link href="/p/27560.html"/>
      <url>/p/27560.html</url>
      
        <content type="html"><![CDATA[<h1 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>桥接模式是─种非常实用的对象结构型设计模式<br>当系统中某个类存在两个独立变化的维护.则可以通过桥接模式将这个维度分离出来,使两者可以独立扩展<br>桥接模式是一种巧妙的方式处理多层继承存在的问题用抽象关联取代了传统的多层继承将类之间的静态继承关系转换为动态的对象组合关系使得系统更加灵活并且易于扩展，同时有效控制了系统中类的个数，将抽象部分和它的实现部分分离，使它们都可以独立的变化。简单粗暴的说，就是抽象对外提供调用的接口；对外隐瞒实现部分，在抽象中引用实现部分，从而实现抽象对实现部分的调用，而抽象中引用的实现部分可以在今后的开发过程中，切换成别的实现部分。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>未使用桥模式：</p><pre><code>/*** 未使用桥模式* 缺点：类的数量暴增*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~Messager()&#123;&#125;&#125;;// 平台实现class PCMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class PCMessagerPerfect : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerLite : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerPerfect : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;void onProcess&#123;    Messager* meg = new MobileMessaferPerfect();//编译时装配&#125;</code></pre><p>上述实例代码针对Messager基类有两个维度的变化，PC和Message，精简和完整版。此时需要将它们分离开来，充分利用组合的方式。将继承变成组合进行解耦重构。</p><pre><code>/*** 使用桥模式*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;        virtual ~Messager()&#123;&#125;&#125;;class MessagerImp&#123;public:    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~MessagerImp()&#123;&#125;&#125;;// 平台实现class PCMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public Messager&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerLite : public Messager&#123;    MessagerImp *messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerPerfect&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;void onProgress()&#123;    //运行时装配    MessagerImp* mImp = new MessagerImp();    Messager *m = new Messager();&#125;</code></pre><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>1). Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。<br>2). Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。<br>3). Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于的变化维度，这时可以使用Bridge的扩展模式。</p><p><strong>优缺点</strong></p><ul><li>优点<ul><li>分离抽象接口及其实现部分</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了”单一职责原则(SRP)”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了类的个数</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合”开闭原则(OCP)”.</li></ul></li><li>缺点<ul><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就就要针对抽象层进行设计与编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累</li></ul></li></ul><p><strong>使用场景</strong><br>    如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/p/44993.html"/>
      <url>/p/44993.html</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式 Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>在金山WPS企业课程中对此有所实践，当时做的是一个复杂图形以及简单图形面积求解问题，复杂图形可以包含其他复杂图形或者简单图形。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p>何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p>应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p>优点： 1、高层模块调用简单。 2、节点自由增加。</p><p>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p>何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在windows里面无论是对于什么后缀的文件还是目录，我们都可以用删除，添加，重命名等统一的操作，不需要区别对待。手机菜单，话机菜单等等一切目录菜单也是一样的，我们可以用统一的接口操作。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class fileSystem &#123;    public:        string name;        virtual void add(fileSystem* node) = 0;        virtual void rename(string newname) = 0;        virtual void remove(fileSystem* node) = 0;        virtual fileSystem* enter() = 0;        virtual fileSystem* GetNode(int index) &#123;&#125;        void showName() &#123;            cout &lt;&lt;&quot;文件名字:&quot;&lt;&lt;name&lt;&lt;endl;        &#125;&#125;;class dir :public fileSystem &#123;    private:        vector &lt;fileSystem*&gt; file;    public:        dir(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            file.push_back(node);        &#125;        void remove(fileSystem* node) &#123;             for(auto it=file.begin();it!=file.end();it++) &#123;                if(*it == node)                    file.erase(it);            &#125;               &#125;        void rename(string newName) &#123;            name = newName;        &#125;        fileSystem* enter() &#123;      //目录点击去就是显示里面有什么            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的目录&quot;&lt;&lt;endl;            for(auto it=file.begin();it!=file.end();it++) &#123;                cout&lt;&lt;(*it)-&gt;name&lt;&lt;endl;            &#125;            return this;               &#125;        fileSystem* GetNode(int index) &#123;    //电脑会进行按键扫描返回是第几个文件也就是index            return file[index];        &#125;&#125;;class cppfile :public fileSystem &#123;    public:        cppfile(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void remove(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void rename(string newName) &#123;                name = newName;        &#125;        fileSystem* enter() &#123;      //文件就是打开            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的文件&quot;&lt;&lt;endl;            return this;        &#125;&#125;;class txtfile :public fileSystem &#123;    public:        txtfile(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void remove(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void rename(string newName) &#123;            name = newName;        &#125;        fileSystem* enter() &#123;      //文件就是打开            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的文件&quot;&lt;&lt;endl;            return this;        &#125;&#125;;int main() &#123;    fileSystem * d = new dir(&quot;1dir&quot;);     //创建根目录1dir    d-&gt;showName();    d-&gt;add(new txtfile(&quot;2txt&quot;));          //创建三个类型文件    d-&gt;add(new cppfile(&quot;3cpp&quot;));    d-&gt;add(new dir(&quot;4dir&quot;));    d = d-&gt;enter();                       //进入1dir目录，展示下面有哪些文件                  d = d-&gt;GetNode(2);                    //按键扫描，表示接下来操作的是哪个位置上的文件    d = d-&gt;enter();                       //进入4dir目录，展示下面有哪些文件     d-&gt;showName();    d-&gt;add(new cppfile(&quot;5cpp&quot;));          //创建5cpp    d = d-&gt;GetNode(0);                    //按键扫描，表示接下来操作的是哪个位置上的文件    d = d-&gt;enter();    d-&gt;showName();    return 0; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/p/3892.html"/>
      <url>/p/3892.html</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>在软件组件设计中如果责任划分不清淅，使用继承得到的结果往往随着需求的变化子类急剧膨胀，同时充斥着重复代码，这时候需要划清责任。<br>装饰者模式动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。</p><h2 id="装饰者模式原则"><a href="#装饰者模式原则" class="headerlink" title="装饰者模式原则"></a>装饰者模式原则</h2><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实质编程</li><li>为交互对象的松耦合设计而努力</li><li>对扩展开放，对修改关闭</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/p/39554.html"/>
      <url>/p/39554.html</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本两个不兼容的接口之间的桥梁，可以使接口不兼容导致不能一起工作的那些类可以一起工作。它包括类适配器和对象适配器.<br>在GoF的设计模式中，对适配器模式讲了两种类型，</p><ul><li>类适配器模式</li><li>对象适配器模式</li></ul><p>类适配器采用多继承方式，对象适配器采用对适配者Adaptee接口方式。两种方式都能完成Target接口与Adaptee接口对接。</p><p>类适配器模式通过多重继承对一个接口与另一个接口进行匹配，C#、VB.NET、JAVA等语言都不支持多重继承(C++支持)，也就是一个类只有一个父类</p><p>适配器模式主要应用在以下场景：</p><ul><li>新旧接口兼容软件版本升级，部分旧接口还在被使用。需要保留旧的接口，增加新接口，使两者兼容。</li><li>第三方接口的适配在系统功能稳定的情况下，有第三方新的接口需求需要对接。</li><li>统一多个类相同功能的接口例如统一不同类型数据库的访问接口。</li></ul><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="/p/39554.htm/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Usb device connect phone */class CAdapter : public CUsbDisk&#123;public:    CAdapter()    &#123;        mpAdaptee = new CTypeCInterface();    &#125;    ~CAdapter()    &#123;        if (NULL != mpAdaptee) &#123;            delete mpAdaptee;        &#125;    &#125;    void ConnectDevice()    &#123;        if (NULL != mpAdaptee) &#123;            mpAdaptee-&gt;ConnectDevice();        &#125; else &#123;            cout &lt;&lt; &quot;Adapter abnormal. Connect fail!&quot; &lt;&lt; endl;        &#125;    &#125;private:    CTypeCInterface *mpAdaptee;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p> 比如电源适配的，一般家用电都是220V，但是手机充电只需要5V，此时手机充电器就相当于是一个适配器，将220V转成手机充电需要的5V。</p><p>220V电源：</p><pre><code>public class AC220V &#123;    public int output()&#123;        int output = 220;        System.out.println(&quot;输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>需要的5V电源：</p><pre><code>public interface DC5V &#123;    int output();&#125;</code></pre><p>变压器（也就是充电器）：</p><pre><code>public class Transformer implements DC5V&#123;    //包含了220V的属性    private AC220V ac220V ;    public Transformer(AC220V ac220V) &#123;        this.ac220V = ac220V;    &#125;    @Override    public int output() &#123;        int input = ac220V.output();        //经过相应的逻辑转换成需要的5V        int output = input / 44;        System.out.println(&quot;输入&quot;+input+&quot;v,输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>测试类：</p><pre><code>DC5V dc5V = new Transformer(new AC220V());dc5V.output();</code></pre><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p><img src="/p/39554.htm/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Not only connect Usb port, but also connect Type-C port */class CAdapter : public CUsbDisk, public CTypeCInterface&#123;public:    void ConnectDevice()    &#123;        CTypeCInterface::ConnectDevice();    &#125;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对比</strong></p><ul><li>在类适配器中，由于适配器是适配者的子类，所以可以在适配器类中重写一些适配者的方法.使得适配器的灵活性更强</li><li>一个对象适配器可以把多个不同的适配者适配到同一个目标即同一个适配器可以把适配者类和它的子类都适配到目标接口</li></ul><p><strong>使用场景</strong></p><ul><li>系统需要使用现有的类，而此类的接口不符合系统的需要</li><li>需要创建一个可复用的类,该类可以与其他不相关的类或不可预见的类系统工作</li></ul><p><strong>优缺点</strong></p><ul><li>优点——可以让任何两个没有关联的类一起运行，提高了类的复用</li><li>缺点——过度使用适配器，会让系统杂乱无章，不利整体进行把握</li></ul><p>适配器模式主要原理: 在于实现客户接口时，关联上已存在的功能接口。一种使用过多继承方式，一种通过类之间依赖的方式，都能实现。<br>为统一多个功能相同的类接口时，类适配器模式是更适合的。比较典型的例子如，MySql和SQLServer等多种类型数据库的访问接口的统一。<br>《Effective C++》曾告诫程序猿们: C++编程不要轻易使用多继承，除非忍不住！<br>另外，文中也有说过。在软件开发初，无第三方需求接口的情况下，不要考虑此模式的使用。往往适配器模式的使用，会让代码看起来像一个补丁，修修补补。<br>「适配器模式」看起来与「外观模式」相似，都是与外部对接。其实有很大不同: 「外观模式」是定义一套新的接口，而「适配器模式」则是运用已有的接口。「外观模式」是在已有复杂的接口上，再封一层简单的接口，方便客户端使用。「适配器模式」则是结合已有的功能，实现或重载已经存在的客户端接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>门面模式</title>
      <link href="/p/58978.html"/>
      <url>/p/58978.html</url>
      
        <content type="html"><![CDATA[<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h1><p>门面模式也叫做外观模式，实质就是一个封装接口，通常是将一类功能或者一个层次功能用一个函数封装起来，供客户端统一调用。</p><p><strong>缺点</strong>    门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，门面对象可是重中之重，一旦在系统投产后发现有一个小错误，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获</p><p><strong>适用场景</strong></p><ul><li>为一个复杂的模块或子系统提供一个供外界访问的接口，子系统相对独立一外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散，比如一个低水平的技术人员参与项目开发，为降低个人代码质量对整体项目的影响风险，一般的做法是 “画地为牢”，只能在指定的子系统中开发，然后再提供面接口进行访问操作 .</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>写信大致分为四个步骤：先写信件的内容,然后写信封,再把信放到信封中, 投递到信箱中进行邮递。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;//#include&lt;vld.h&gt;using namespace std;//门面模式//写信过程接口class ILetterProcess&#123;public:    //首先要写信的内容    virtual void writeContext(string context) = 0 ;    //其次写信封    virtual void fillEnvelope(string address) = 0 ;    //把信放到信封里    virtual void letterInotoEnvelope() = 0 ;    //然后邮递    virtual void sendLetter() = 0 ;&#125;;//写信过程的实现class LetterProcessImpl : public ILetterProcess&#123;public:    //写信    void writeContext(string context)    &#123;        cout&lt;&lt;&quot;填写信的内容...&quot;+context&lt;&lt;endl;    &#125;    //在信封上填写必要的信息    void fillEnvelope(string address)    &#123;        cout&lt;&lt;&quot;填写收件人地址及姓名...&quot;+address&lt;&lt;endl;    &#125;    //把信放到信封中 , 并封好    void letterInotoEnvelope()    &#123;        cout&lt;&lt;&quot;把信放到信封中...&quot;&lt;&lt;endl;    &#125;    //塞到邮箱中 , 邮递    void sendLetter()    &#123;        cout&lt;&lt;&quot;邮递信件...&quot;&lt;&lt;endl;    &#125;&#125;;//场景1int main()&#123;    //创建一个处理信件的过程    ILetterProcess* letterProcess = new LetterProcessImpl() ;    //开始写信    letterProcess-&gt;writeContext(&quot;Hello , It&#39;s me , do you know who I am ? I&#39;m you dad . I&#39;d like to ...&quot;);    //开始写信封    letterProcess-&gt;fillEnvelope(&quot;Happy Road No.666 , God Province , Heaven&quot;);    //把信放到信封里 , 并封装好    letterProcess-&gt;letterInotoEnvelope();    //跑到邮局把信塞到邮箱 , 投递    letterProcess-&gt;sendLetter();    delete letterProcess;    return 0;&#125;</code></pre><p>我们回头来看看这个过程 , 它与高内聚的要求相差甚远 , 更不要说迪米特法则 , 接口隔离原则 . 你要知道者4个步骤 , 而且还要知道他们的顺序 , 一旦出错 , 信就不可能邮寄出去 , 这在面向对象的编程中是极度的不合适 , 它根本没有完成一个类所具有的单一职责 .还有 , 如果信件多了就非常麻烦 , 每封信都要这样运转一遍 , 非得累死 , 更别说要发个广告信了 , 那怎么办? 还好, 现在邮局开发了一个新业务 , 你只要把信件的必要信息告诉我 , 我给你发 , 我来完成这4个过程 , 只要把信件交给我就成了 , 其他的不要管 .</p><pre><code>//现代化邮局class ModenPostOffice &#123;public:    ModenPostOffice()    &#123;        letterProcess = new LetterProcessImpl();    &#125;    ~ModenPostOffice()    &#123;        if(letterProcess != nullptr)            delete letterProcess;    &#125;    //写信 , 封装 , 投递  ,一体化    void sendLetter(string context , string address)    &#123;        //帮你写信        letterProcess-&gt;writeContext(context);        //写好信封        letterProcess-&gt;fillEnvelope(address);        //把信放到信封中        letterProcess-&gt;letterInotoEnvelope();        //邮递信件        letterProcess-&gt;sendLetter();    &#125;private:    ILetterProcess* letterProcess ;&#125;;</code></pre><p>这就是门面模式，可以相比于数据库DBMS，以及物理层面比如我们个人使用的电脑，包括usb接口，蓝牙接口，都是稳定的，哪怕不同品牌电脑内部构造不同，也能使用同一个u盘；</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建器模式</title>
      <link href="/p/39856.html"/>
      <url>/p/39856.html</url>
      
        <content type="html"><![CDATA[<h1 id="构建器模式"><a href="#构建器模式" class="headerlink" title="构建器模式"></a>构建器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造者(构建器)–Builder模式, 是将一个复杂对象的构建与表示相分离,是的同样的构建过程可以有不同的创建表示.<br>将一个复杂的对象分解了多个简单的对象, 然后一步步的构建成.达到了将变与不变相分离, 即组成部分是不变的, 但是是每一部分又可以达到灵活选择.<br>Builder模式隐藏了复杂对象的创建过程, 将复杂对象在创建过程加以抽象, 通过子类基础或重载的方式,动态创建具有符合属性的对象.</p><h2 id="Builder优缺点"><a href="#Builder优缺点" class="headerlink" title="Builder优缺点"></a>Builder优缺点</h2><p><strong>优点</strong></p><ul><li>各个具体的构建器都是相互独立的, 利于系统的扩展</li><li>客户端不必知道具体产品内部的实现</li></ul><p><strong>缺点</strong></p><ul><li>产品组成部分必须要相同, 限制了使用范围</li><li>假如产品内部变化复杂, 会增加更多的建造者类</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>隔离复杂对象的创建和使用，同样的方法不同的执行顺序，从而产生不同事件的结果</li><li>初始化对象时，参数很多或者很多参数都具有默认值</li><li>不适合创建差异化很大的产品类，如果产品内部变化负责时，会导致定义很多建造者来实现变化，增加类的数量，增加了运行成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/p/39447.html"/>
      <url>/p/39447.html</url>
      
        <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式是当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类，主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。<br>在实际开发中，我们经常会遇到这种情况；一个对象有多种状态，在每一个状态下，都会有不同的行为。那么在代码中我们经常是这样实现的。</p><pre><code>typedef enum tagState&#123;    state,    state1,    state2&#125;State;void Action(State actionState)&#123;    if (actionState == state)    &#123;        // DoSomething    &#125;    else if (actionState == state1)    &#123;        // DoSomething    &#125;    else if (actionState == state2)    &#123;        // DoSomething    &#125;    else    &#123;        // DoSomething    &#125;&#125;</code></pre><p>这里和策略模式遇到的问题有所相似，思考一下，如果枚举类型中新增了一个枚举，那么我们则需要重新更改这个类，不符合开闭原则；那么我们如何解决这个问题呢，根据以往经验很自然的我们会想到设置个抽象基类，把枚举抽象出来，把状态变成抽象子类，动态绑定。往往状态只需要一个实例，我们可以使用单例模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>1 #include &lt;iostream&gt;2 using namespace std;3 4 class Context;5 6 class State7 &#123;8 public:9      virtual void Handle(Context *pContext) = 0;10 &#125;;11 12 class ConcreteStateA : public State13 &#123;14 public:15      virtual void Handle(Context *pContext)16      &#123;17           cout&lt;&lt;&quot;I am concretestateA.&quot;&lt;&lt;endl;18      &#125;19 &#125;;20 21 class ConcreteStateB : public State22 &#123;23 public:24      virtual void Handle(Context *pContext)25      &#123;26           cout&lt;&lt;&quot;I am concretestateB.&quot;&lt;&lt;endl;27      &#125;28 &#125;;29 30 class Context31 &#123;32 public:33      Context(State *pState) : m_pState(pState)&#123;&#125;34 35      void Request()36      &#123;37           if (m_pState)38           &#123;39                m_pState-&gt;Handle(this);40           &#125;41      &#125;42 43      void ChangeState(State *pState)44      &#123;45           m_pState = pState;46      &#125;47 48 private:49      State *m_pState;50 &#125;;51 52 int main()53 &#123;54      State *pStateA = new ConcreteStateA();55      State *pStateB = new ConcreteStateB();56      Context *pContext = new Context(pStateA);57      pContext-&gt;Request();58 59      pContext-&gt;ChangeState(pStateB);60      pContext-&gt;Request();61 62      delete pContext;63      delete pStateB;64      delete pStateA;65 &#125;</code></pre><p>例2<br>某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾.如果不用状态模式，会产生大量的if…else语句，代码将很不容易改变,，难以拓展。状态转换隐藏在条件语句中，所以并不明显未来加入的代码可能导致bug。</p><pre><code>    #include&lt;iostream&gt;    using namespace std;    //以下为类的定义部分    class TissueMachine;//类的提前引用    //抽象状态    class State&#123;    public:        virtual void insertQuarter()=0;//“投币”按钮被按下        virtual void ejectQuarter()=0;//“退币”按钮被按下        virtual void turnCrank()=0;//“出纸巾”按钮被按下        virtual void dispense()=0;//正在卖出纸巾    &#125;;        //具体状态    class SoldOutState:public State&#123;//纸巾售完状态    private:        TissueMachine* tissueMachine;    public:        SoldOutState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class NoQuarterState:public State&#123;//没有投币状态    private:        TissueMachine* tissueMachine;    public:        NoQuarterState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class HasQuarterState:public State&#123;//有2元钱（已投币状态）    private:        TissueMachine* tissueMachine;    public:        HasQuarterState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class SoldState:public State&#123;//出售纸巾状态    private:        TissueMachine* tissueMachine;    public:        SoldState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;        //上下文    class TissueMachine&#123;    private:        State *soldOutState,*noQuarterState,*hasQuarterState,*soldState,*state;        int count;//纸巾数    public:        TissueMachine(int numbers)&#123;//构造函数，定义初始状态有纸巾售卖机有多少纸巾            soldOutState=new SoldOutState(this);            noQuarterState=new NoQuarterState(this);            hasQuarterState=new HasQuarterState(this);            soldState=new SoldState(this);            this-&gt;count=numbers;            if (count&gt; 0) &#123;                  this-&gt;state=noQuarterState;//开始为没有投币的状态            &#125;        &#125;;        //开放给主函数调用的方法        void insertQuarter()&#123;            state-&gt;insertQuarter();        &#125;        void ejectQuarter()&#123;            state-&gt;ejectQuarter();        &#125;        void turnCrank()&#123;            state-&gt;turnCrank();            state-&gt;dispense();        &#125;        //数据传递的getter与setter        void setState(State* state)&#123;            this-&gt;state=state;        &#125;        State* getHasQuarterState()&#123;            return hasQuarterState;        &#125;        State* getNoQuarterState()&#123;            return noQuarterState;        &#125;        State* getSoldState()&#123;            return soldState;        &#125;        State* getSoldOutState()&#123;            return soldOutState;        &#125;        int getCount()&#123;            return count;        &#125;;        void setCount(int numbers)&#123;            this-&gt;count=numbers;        &#125;;    &#125;;        //具体状态中各个方法的具体实现。    //纸巾售完状态    void SoldOutState::insertQuarter()&#123;        cout&lt;&lt;&quot;机器无纸巾，已退回硬币！&quot;&lt;&lt;endl;    &#125;    void SoldOutState::ejectQuarter()&#123;        cout&lt;&lt;&quot;自动售货机根本没有硬币！&quot;&lt;&lt;endl;    &#125;    void SoldOutState::turnCrank()&#123;        cout&lt;&lt;&quot;机器无纸巾，请不要操作机器&quot;&lt;&lt;endl;    &#125;    void SoldOutState::dispense()&#123;    &#125;    //没有投币状态    void NoQuarterState::insertQuarter()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getHasQuarterState());        cout&lt;&lt;&quot;已投币！&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::ejectQuarter()&#123;        cout&lt;&lt;&quot;自动售货机根本没有硬币！&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::turnCrank()&#123;        cout&lt;&lt;&quot;请投币&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::dispense()&#123;    &#125;    //有2元钱（已投币状态）    void HasQuarterState::insertQuarter()&#123;        cout&lt;&lt;&quot;已投币！请不要重复投币！已退回重复投币！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::ejectQuarter()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());        cout&lt;&lt;&quot;已取币！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::turnCrank()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getSoldState());        cout&lt;&lt;&quot;请等待自动售货机出纸巾！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::dispense()&#123;    &#125;    //出售纸巾状态    void SoldState::insertQuarter()&#123;        cout&lt;&lt;&quot;请等待自动售货机出纸巾！请不要投币！已退回投币！&quot;&lt;&lt;endl;    &#125;    void SoldState::ejectQuarter()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());        cout&lt;&lt;&quot;请等待自动售货机出纸巾！无法取回已消费的硬币！&quot;&lt;&lt;endl;    &#125;    void SoldState::turnCrank()&#123;        cout&lt;&lt;&quot;请等待自动售货机出纸巾！已响应你的操作！&quot;&lt;&lt;endl;    &#125;    void SoldState::dispense()&#123;//售出纸巾动作        if(tissueMachine-&gt;getCount()&gt;0)&#123;            tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());            tissueMachine-&gt;setCount(tissueMachine-&gt;getCount()-1);            cout&lt;&lt;&quot;你的纸巾，请拿好！&quot;&lt;&lt;endl;        &#125;        else&#123;            tissueMachine-&gt;setState(tissueMachine-&gt;getSoldOutState());            cout&lt;&lt;&quot;已退回你的硬币！纸巾已卖光，等待进货！&quot;&lt;&lt;endl;        &#125;    &#125;    //主函数    int main()&#123;        TissueMachine *tissueMachine=new TissueMachine(1);        cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;        tissueMachine-&gt;insertQuarter();//投币        tissueMachine-&gt;turnCrank();//取纸巾        cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;//不投币取纸巾测试        tissueMachine-&gt;turnCrank();         cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;//售完纸巾，投币取纸巾测试        tissueMachine-&gt;insertQuarter();          tissueMachine-&gt;turnCrank();         return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/p/58639.html"/>
      <url>/p/58639.html</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，常常拥有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有的原因而无法和任务的整体结构同时实现。<br>我们希望能够在稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义了一组同类型的算法，在不同的类中封装起来，每种算法可以根据当前场景相互替换，从而使算法的变化独立于使用它们的客户端（即算法的调用者）</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>小王同学的爷爷老王刚开始使用电脑，看着电脑里的各种格式.txt、docx、jpg，瞬间眼花缭乱，身为c++程序员出身的小王，立马拍着胸脯说要给爷爷写个程序，通过程序去自动的打开各种格式文件<br>小王打开电脑，三下五除二就把程序写好了</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG&#125;;class filemanager&#123;    public:    void opentxtfile()&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;    void opendocxfile()&#123;        std::cout&lt;&lt;&quot;word is opened&quot;&lt;&lt;std::endl;    &#125;    void openjpgfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;    void openpngfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;int main()&#123;    FILETYPE openfiletype=FILETYPE::TXT;    filemanager file;    switch (openfiletype)&#123;    case FILETYPE::TXT:        file.opentxtfile();        break;    case FILETYPE::DOCX:        file.opendocxfile();        break;    case FILETYPE::JPG:        file.openjpgfile();        break;    case FILETYPE::PNG:        file.openpngfile();        break;        default:        break;    &#125; &#125;</code></pre><p>爷爷选择了一个txt文件，文件就打开了，爷爷笑靥如花，小王仰起了骄傲的头~<br>过了两天，爷爷给小王打电话，说.avi的视频文件打不开<br>于是小王不得不修改了枚举类</p><pre><code>enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG,    avi&#125;;</code></pre><p>然后又修改了switch case</p><pre><code>case FILETYPE::avi:        file.openavifile();        break;</code></pre><p>随着增加格式越来越多.xlsx .mp3 .mp4 …. switch case 越来越长，而且每次修改的地方较多，一不小心会引起其他bug，小王终于受不了了，买了一本设计模式的书~</p><p>初步优化，小王使用策略模式：<br>抽出open接口</p><pre><code>class openinterface&#123;    public:    virtual void open()=0;    virtual ~openinterface()&#123;&#125;&#125;;</code></pre><p>定义各种文件的实现</p><pre><code>//txt fileclass textfile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;//jpg fileclass jgpfile:public openinterface&#123;public:    void open() override&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>引入管理类</p><pre><code>class openfilemanager&#123;public:    openfilemanager(openinterface* pOpen)&#123;        _pOpen=pOpen;    &#125;    void openfile()&#123;        _pOpen-&gt;open();    &#125;    ~openfilemanager()&#123;        if(_pOpen) delete _pOpen;    &#125;private:    openinterface* _pOpen;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    FILETYPE currentfiletype=FILETYPE::TXT;    if(currentfiletype==FILETYPE::TXT;)&#123;        openfilemanager* pmanager=new openfilemanager(new textfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    if(currentfiletype==FILETYPE::JPG)&#123;        openfilemanager* pmanager=new openfilemanager(new jgpfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    return 0;&#125;</code></pre><p>通过这一步的优化，程序可维护性好了，再增加新功能不会对旧功能产生影响，这就是策略模式~但是 switch case 并没有减少，而且枚举也存在，小王还是不满意</p><p>针对这个例子：<br>修改openfilemanager， 增加个map，程序启动的时候加载到内存里</p><pre><code>class openfilemanager&#123;public:    void add(std::string key,openinterface* pFile)&#123;        _filemap.insert(std::make_pair(key,pFile));    &#125;    void openfile(std::string filetype)&#123;        _filemap[filetype]-&gt;open();    &#125;    ~openfilemanager()&#123;        for(auto iter=_filemap.begin();iter!=_filemap.end();iter++)&#123;            delete iter-&gt;second;        &#125;    &#125;private:    std::unordered_map&lt;std::string,openinterface*&gt; _filemap;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    //init    openfilemanager filemanager;    filemanager.add(&quot;txt&quot;,new textfile);    filemanager.add(&quot;jpg&quot;,new jgpfile);    //open file    filemanager.openfile(&quot;txt&quot;);    return 0;&#125;</code></pre><p>爷爷又来电话，说想打开.pdf文件，小王剑指如飞，增加了如下类</p><pre><code>class pdffile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;pdf is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>初始化的时候增加pdf</p><pre><code>openfilemanager filemanager;     filemanager.add(&quot;txt&quot;,new textfile);     filemanager.add(&quot;jpg&quot;,new jgpfile);filemanager.add(&quot;pdf&quot;,new pdffile);</code></pre><p>小王没一会功夫就把程序交给了爷爷，嘿嘿一笑，深藏功与名</p><h2 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h2><p>Strategt类，定义所有支持的算法的公共接口</p><pre><code>class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;</code></pre><p>ConcreteStrategy 封装了具体的算法或行为，继承Strategy</p><pre><code>class ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;</code></pre><p>Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用</p><pre><code>class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;</code></pre><p>整份代码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define free_ptr(p) if(p) delete p; p = nullptr;//Strategt类，定义所有支持的算法的公共接口class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;//ConcreteStrategy 封装了具体的算法或行为，继承Strategyclass ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;//Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;int main() &#123;    Strategy* concreteStrategyA = new ConcreteStrategyA();    Strategy* concreteStrategyB = new ConcreteStrategyB();    Strategy* concreteStrategyC = new ConcreteStrategyC();    concreteStrategyA-&gt;AlgorithmInterface();    concreteStrategyB-&gt;AlgorithmInterface();    concreteStrategyC-&gt;AlgorithmInterface();    free_ptr(concreteStrategyA);    free_ptr(concreteStrategyB);    free_ptr(concreteStrategyC);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职责链模式</title>
      <link href="/p/52113.html"/>
      <url>/p/52113.html</url>
      
        <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，直到有一个对象处理它为止；</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p>何时使用：在处理消息的时候以过滤很多道。</p><p>关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p>优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p>缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p>使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define SAFE_DELETE(p) if(p)&#123;delete p;p=NULL;&#125;//假期请求的类class HolidayRequest&#123;public:    HolidayRequest(int hour) :m_iHour(hour) &#123;&#125;    int GetHour() &#123; return m_iHour; &#125;private:    int m_iHour;&#125;;//假期处理请求接口class Manager&#123;public:    virtual bool HandleRequest(HolidayRequest *pRequest) = 0;&#125;;//项目经理class PM :public Manager&#123;public:    PM(Manager* handler):m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        if (pRequest-&gt;GetHour() &lt;= 2 || m_pHandler == NULL)        &#123;            cout &lt;&lt; &quot;项目经理说ok&quot; &lt;&lt; endl;            return true;        &#125;        return m_pHandler-&gt;HandleRequest(pRequest);    &#125;private:    Manager* m_pHandler;&#125;;//部门经理class DM :public Manager&#123;public:    DM(Manager* handler) :m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        cout &lt;&lt; &quot;部门经理说Ok了&quot; &lt;&lt; endl;        return true;    &#125;    //部门经理说ok了    bool IsIn()    &#123;        return true;    &#125;private:    Manager* m_pHandler;&#125;;//项目主管class PS :public Manager&#123;public:    PS(Manager* handler) :m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        DM* pDM = dynamic_cast&lt;DM*&gt;(m_pHandler);        if (pDM != NULL)        &#123;            if (pDM-&gt;IsIn())            &#123;                return pDM-&gt;HandleRequest(pRequest);            &#125;        &#125;        cout &lt;&lt; &quot;项目主管说ok&quot; &lt;&lt; endl;        return true;    &#125;    private:    Manager* m_pHandler;&#125;;int main(int argc, char* argv[])&#123;    DM* pDM = new DM(NULL);    PS* pPS = new PS(pDM);    PM* pPM = new PM(pPS);  //在客户端中定义职责链的顺序,逆着来，注意这里    HolidayRequest* pHolidayRequest = new HolidayRequest(10);    pPM-&gt;HandleRequest(pHolidayRequest);  //输出&quot;部门经理说ok了&quot;    SAFE_DELETE(pHolidayRequest);    pHolidayRequest = new HolidayRequest(2);    pPM-&gt;HandleRequest(pHolidayRequest);  //输出&quot;项目经理说ok了&quot;    SAFE_DELETE(pDM);    SAFE_DELETE(pPS);    SAFE_DELETE(pPM);    SAFE_DELETE(pHolidayRequest);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/p/7738.html"/>
      <url>/p/7738.html</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>当一个对象的状态发生改变的时候，如何让依赖他的所有对象得到通知并进行相应的处理。</p><ul><li>稳定点 一对多的依赖关系（一变化 多跟着变化）</li><li>变化点 <ul><li>‘多’增加</li><li>‘多’减少</li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>丈夫下班的时候会告诉孩子和老婆，老公开车要往回走了</p><ul><li>孩子妈收到消息后开始做饭</li><li>孩子收到消息后，就赶紧收起手机，怕挨揍</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>观察者模式的核心思想是 1对多</p><p>传统写法：</p><pre><code>#include &lt;iostream&gt;class Son&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;爸爸回来了，赶紧去写作业&quot;&lt;&lt;std::endl;    &#125;&#125;;class Wife&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;老公回来了，去做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();    &#125;private:    Wife wife;    Son son;&#125;;int main()&#123;    Husband husband;    husband.Gohome();    return 0;&#125;</code></pre><p>这样写的不足如下：</p><p>如果关心丈夫的人变多了，比如老妈、老爸 ，这时候我们不得不去修改Husband的类</p><pre><code>class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();        mom.DoSomething();        ba.DoSomething();    &#125;private:    Wife wife;    Son son;    Mother mom;    Father ba;&#125;;</code></pre><p>人数少的时候，还可以应付，假如关心我的人有1000人，那这时候我们该怎么办</p><p><strong>开始重构，简单观察者模式，面向抽象编程</strong><br>观察者接口</p><pre><code>class ObserverInterface&#123;public:    virtual void dosomething()=0;    virtual ~ObserverInterface()&#123;&#125;&#125;;</code></pre><p>被观察者接口</p><pre><code>class SubjectInterface&#123;public:    virtual void Add(ObserverInterface* obr)=0;    virtual void Remove(ObserverInterface* obr)=0;    virtual void Notify()=0;    virtual ~SubjectInterface()&#123;&#125;&#125;;</code></pre><p>丈夫</p><pre><code>class Husband:public SubjectInterface&#123;public:    void Add(ObserverInterface* obr) override&#123;        observers.push_back(obr);    &#125;    void Remove(ObserverInterface* obr) override&#123;        auto pos=std::find(observers.begin(),observers.end(),obr);        if(pos!=observers.end())&#123;            observers.erase(pos);        &#125;    &#125;    void Notify() override&#123;        for(const auto&amp; obs:observers)&#123;            obs-&gt;dosomething();        &#125;    &#125;private:    std::vector&lt;ObserverInterface*&gt; observers;&#125;;</code></pre><p>孩子妈</p><pre><code>class Wife:public ObserverInterface&#123;public:    void dosomething() override&#123;        std::cout&lt;&lt;&quot;老公快回来了，开始做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>孩子</p><pre><code>class Son:public  ObserverInterface&#123;public:    void dosomething() override &#123;        std::cout&lt;&lt;&quot;爸爸快回来了，不能玩游戏了&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    Husband husband;    ObserverInterface* wife=new Wife;    ObserverInterface* son=new Son;    husband.Add(wife);    husband.Add(son);    //下班了 发消息    husband.Notify();    delete wife;    delete son;&#125;</code></pre><p>这样的好处是：再增加新的观察者，我们就不用修改Husband的类了，只需要添加到vector中就可以<br>不足是：需要自己做内存管理 delete</p><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>使用面向对象的抽象，Observer模式使得我们可以独立的改变目标与观察者，从而使二者之间的依赖关系松耦合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析器模式</title>
      <link href="/p/50156.html"/>
      <url>/p/50156.html</url>
      
        <content type="html"><![CDATA[<h1 id="解析器模式"><a href="#解析器模式" class="headerlink" title="解析器模式"></a>解析器模式</h1><p>解析器模式定义语言的文法，并且建立一个解析器来解释该语言（规定格式和语法的代码）中的句子。它包含抽象表达式，终结符表达式，非终结符表达式，Context环境类。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里参照了李建忠老师的设计模式课程</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;stack&gt;class Expression&#123;public:    virtual int interpreter(std::map&lt;char, int&gt;) = 0;    virtual ~Expression() &#123;&#125;&#125;;//变量表达式class VarExpression :public Expression&#123;public:    VarExpression(const char&amp; k) :key(k) &#123;&#125;    int interpreter(std::map&lt;char, int&gt;var) override    &#123;        return var[key];    &#125;private:    char key;&#125;;class SymbolExpression :public Expression&#123;public:    SymbolExpression(Expression* l, Expression* r) :left(l), right(r) &#123;&#125;protected:    Expression* left;    Expression* right;&#125;;class AddExpression : public SymbolExpression&#123;public:    AddExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) + right-&gt;interpreter(var);    &#125;&#125;;class SubExpression :public SymbolExpression&#123;public:    SubExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) - right-&gt;interpreter(var);    &#125;&#125;;class MulExpression :public SymbolExpression&#123;public:    MulExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) * right-&gt;interpreter(var);    &#125;&#125;;class DivExpression :public SymbolExpression&#123;public:    DivExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) / right-&gt;interpreter(var);    &#125;&#125;;Expression* analyse(std::string expStr)&#123;    std::stack&lt;Expression*&gt; expStack;    Expression* left = nullptr;    Expression* right = nullptr;    for (int i = 0; i &lt; expStr.size(); ++i)    &#123;        switch (expStr[i])        &#123;        case &#39;+&#39;:            // 加法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new AddExpression(left, right));            break;        case &#39;-&#39;:            // 减法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new SubExpression(left, right));            break;        case &#39;*&#39;:            // 乘法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new MulExpression(left, right));            break;        case &#39;/&#39;:            // 除法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new DivExpression(left, right));            break;        default:            // 变量表达式            expStack.push(new VarExpression(expStr[i]));        &#125;    &#125;    Expression* expression = expStack.top();    return expression;&#125;void release(Expression* expression) &#123;    //释放表达式树的节点内存...&#125;int main()&#123;    std::string expStr = &quot;a+b-c+d-e*f/g&quot;;    std::map&lt;char, int&gt; var;    var.insert(std::make_pair(&#39;a&#39;, 5));    var.insert(std::make_pair(&#39;b&#39;, 2));    var.insert(std::make_pair(&#39;c&#39;, 1));    var.insert(std::make_pair(&#39;d&#39;, 6));    var.insert(std::make_pair(&#39;e&#39;, 10));    var.insert(std::make_pair(&#39;f&#39;, 8));    var.insert(std::make_pair(&#39;g&#39;, 4));    Expression* expression = analyse(expStr);    int result = expression-&gt;interpreter(var);    std::cout &lt;&lt; result &lt;&lt; std::endl;    release(expression);    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解析在日常开发经常使用，但是解析器模式可能用的比较少，使用方式就是将一个需要解释执行的语言中的句子表示为一个抽象语法树，完成解析。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问器模式</title>
      <link href="/p/5265.html"/>
      <url>/p/5265.html</url>
      
        <content type="html"><![CDATA[<h1 id="访问器模式"><a href="#访问器模式" class="headerlink" title="访问器模式"></a>访问器模式</h1><p>在软件构建中，由于需求的变化，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中添加，会给子类带来繁重的变更负担，破坏原有设计。<br>访问器模式：表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素类的前提下定义（扩展）作用于这些元素的新操作（变化）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：主要将数据结构与数据操作分离。</p><p>主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p><p>如何解决：在被访问的类里面加一个对外提供接待访问者的接口。</p><p>关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p>优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p><p>缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p>使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>参照李建忠老师的课程代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;class Visitor;class Element&#123;public:    virtual void accept(Visitor&amp; visitor) = 0; //第一次多态辨析    virtual ~Element()&#123;&#125;&#125;;class ElementA : public Element&#123;public:    void accept(Visitor &amp;visitor) override &#123;        visitor.visitElementA(*this);    &#125;&#125;;class ElementB : public Element&#123;public:    void accept(Visitor &amp;visitor) override &#123;        visitor.visitElementB(*this); //第二次多态辨析    &#125;&#125;;class Visitor&#123;public:    virtual void visitElementA(ElementA&amp; element) = 0;    virtual void visitElementB(ElementB&amp; element) = 0;    virtual ~Visitor()&#123;&#125;&#125;;//==================================//扩展1class Visitor1 : public Visitor&#123;public:    void visitElementA(ElementA&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor1 is processing ElementA&quot; &lt;&lt; endl;    &#125;          void visitElementB(ElementB&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor1 is processing ElementB&quot; &lt;&lt; endl;    &#125;&#125;;    //扩展2class Visitor2 : public Visitor&#123;public:    void visitElementA(ElementA&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor2 is processing ElementA&quot; &lt;&lt; endl;    &#125;        void visitElementB(ElementB&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor2 is processing ElementB&quot; &lt;&lt; endl;    &#125;&#125;;        int main()&#123;    Visitor2 visitor;    ElementB elementB;    elementB.accept(visitor);// double dispatch        ElementA elementA;    elementA.accept(visitor);        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/p/28241.html"/>
      <url>/p/28241.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式（Iterator Pattern）是非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>在金山WPS课程中对此有所实现。<br>这种方式在c++当中已经过时了，泛型编程相对于GOF提出的面向对象的迭代器性能更好一些。虚函数需要二次指针间接运算，性能相对较差。c++使用泛型实现的迭代器采用的编译时多态，基于模板来实现的。但是这种设计思路在java等编程语言得到了极大的应用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p>优点： </p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ul><p>缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p><p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>#pragma once#include &lt;string&gt;#include &lt;vector&gt;/*** @brief 简单概述* @brief 迭代器基类*/class Iterator&#123;public:    Iterator() &#123;&#125;    ~Iterator()&#123;&#125;    virtual std::string First() = 0;    virtual std::string Next() = 0;    virtual std::string Current() = 0;    virtual bool IsEnd() = 0;&#125;;/*** @brief 简单概述* @brief 对象基类*/class Object&#123;public:    Object() &#123;&#125;    ~Object()&#123;&#125;    virtual Iterator* CreateIterator() = 0;    virtual int Count() = 0;    virtual void Push(std::string) = 0;    virtual std::string Pop(int) = 0;&#125;;/*** @brief 简单概述* @brief 迭代器子类*/class SubIterator : public Iterator&#123;public:    SubIterator(Object* obj):Iterator(), m_pObj(obj), m_Cur(0)&#123;&#125;    ~SubIterator()&#123;&#125;    std::string First()    &#123;        return m_pObj-&gt;Pop(0);    &#125;    std::string Next()    &#123;        std::string str;        if (m_Cur &lt; m_pObj-&gt;Count() - 1)        &#123;            m_Cur++;            str = m_pObj-&gt;Pop(m_Cur);        &#125;        return str;    &#125;    std::string Current()    &#123;        return m_pObj-&gt;Pop(m_Cur);    &#125;    bool IsEnd()    &#123;        return (m_Cur == m_pObj-&gt;Count()-1);    &#125;private:    Object* m_pObj;    int m_Cur;&#125;;/*** @brief 简单概述* @brief 对象类*/class Children : public Object&#123;public:    Children() : Object(), m_pIterator(NULL) &#123;&#125;    ~Children()&#123;&#125;    Iterator* CreateIterator()    &#123;        if(m_pIterator == NULL)            m_pIterator = new SubIterator(this);        return m_pIterator;    &#125;    int Count()    &#123;        return vec_str.size();    &#125;    void Push(std::string s)    &#123;        vec_str.push_back(s);    &#125;    std::string Pop(int i)    &#123;        std::string str;        if (i &gt;= 0 &amp;&amp; i &lt; vec_str.size())        &#123;            str = vec_str[i];        &#125;        return str;    &#125;private:    std::vector&lt;std::string&gt; vec_str;    Iterator*m_pIterator;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>factory模式</title>
      <link href="/p/59316.html"/>
      <url>/p/59316.html</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为简单工厂模式，工厂方法模式和抽象工厂模式。</p><ul><li>简单工厂       Simple Factory</li><li>工厂方法       Factory Method</li><li>抽象工厂       Abstract Factory</li></ul><p><img src="https://s1.ax1x.com/2023/08/10/pPmfFl4.png" alt="pPmfFl4.png"></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>示例：</p><p>步骤 1<br>创建一个接口。</p><pre><code>class Shape&#123;public:    virtual ~Shape()&#123;&#125;    virtual void draw() = 0;&#125;;</code></pre><p>步骤 2<br>创建实现接口的实体类</p><pre><code>class Circle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a circle&quot; &lt;&lt; std::endl;    &#125;&#125;;class Square:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a square&quot; &lt;&lt; std::endl;    &#125;&#125;;class Rectangle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a rectangle&quot; &lt;&lt; std::endl;    &#125;&#125;;</code></pre><p> 步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><pre><code>class ShapeFactory&#123;public:    std::shared_ptr&lt;Shape&gt; getShape(const std::string &amp; shapType)&#123;        if(shapType == &quot;Square&quot;)&#123;            return std::make_shared&lt;Square&gt;();        &#125;        else if(shapType == &quot;Circle&quot;)&#123;            return std::make_shared&lt;Circle&gt;();        &#125;         else if(shapType == &quot;Rectangle&quot;)&#123;            return std::make_shared&lt;Rectangle&gt;();        &#125;        return nullptr;    &#125;&#125;;</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><pre><code>ShapeFactory factory;auto shape1 = factory.getShape(&quot;Circle&quot;);shape1-&gt;draw();auto shape2 = factory.getShape(&quot;Square&quot;);shape2-&gt;draw();auto shape3 = factory.getShape(&quot;Rectangle&quot;);shape3-&gt;draw();</code></pre><p>步骤 5<br>验证输出。</p><pre><code>draw a circledraw a squaredraw a rectangle</code></pre><p>特点：用户不需要具体关心实例是怎么创建的，只需要输入标识符就可以得到实例，但这种设计不符合开-闭原则，对修改和扩展都是开放的，增加对象类型和删除对象类型都需要重写这个接口。<br>就是把所有对象的创建都封装在了一个ShapeFactory类的getShape函数中，根据传入的参数，选择产生不同的对象，很明显，getShape这个函数做不到“开-闭”原则，即对原有代码修改关闭，对功能扩展开放，这个函数随着新对象的添加，或者原有对象的删除，都会导致该函数的代码修改，而且有可能影响原来的功能，所以这样的设计不能算完美。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Factory Method工厂方法是标准的OOP设计模式之一，主要解决了上面使用简单工厂遇到的问题。工厂方法为每一种产品提供相应的实例工厂进行对象创建，更符合实际的面向对象设计，比如说不同图形，肯定都有自己的绘图工具，每个图形都有自己的工厂在生产。</p><p>产品类型</p><pre><code>class Product&#123;public:    Product(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductA : public Product&#123;public:    ProductA(string name) :Product(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用老外高通芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductB : public Product&#123;public:    ProductB(string name) :Product(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用自研麒麟芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>工厂基类</p><pre><code>class Factory&#123;public:    virtual Product* createProduct() = 0;&#125;;</code></pre><p>生产小米手机的工厂</p><pre><code>class XiaomiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 小米工厂肯定生产小米手机        return new ProductA(&quot;小米手机&quot;);    &#125;&#125;;</code></pre><p>生产华为手机的工厂</p><pre><code>class HuaweiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 华为工厂肯定生产华为手机        return new ProductB(&quot;华为手机&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;Factory&gt; f1(new XiaomiFactory);    unique_ptr&lt;Factory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建产品    unique_ptr&lt;Product&gt; p1(f1-&gt;createProduct());    unique_ptr&lt;Product&gt; p2(f2-&gt;createProduct());    p1-&gt;show();    p2-&gt;show();    return 0;&#125;</code></pre><p>特点：仔细理解上面的工厂方法模式，会发现一个问题，就是每一个实例工厂负责生产一个实例产品，也就是一个产品对应一个工厂，一个工厂对应一个产品，那么小米不仅仅生产手机，还生产耳机，智能手环，智能插座等等相关的小米产品簇，不可能给这每一个产品都创建一个工厂类，那样的话代码中的类就太多了，不好维护，而且也不符合实际情况。<br>所以对于包含产品簇这么一类实体关系的设计，就需要使用Abstract Factory抽象工厂了，你也可以把上面的工厂方法看作只生产一种产品的抽象工厂，本质是相同的。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>经过上面内容的描述，抽象工厂其实就是解决产品簇的产品类设计的。</p><p>产品簇手机类型</p><pre><code>class ProductA&#123;public:    ProductA(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiPhone : public ProductA&#123;public:    XiaomiPhone(string name) :ProductA(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米手机:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiPhone : public ProductA&#123;public:    HuaweiPhone(string name) :ProductA(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个华为手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品簇智能手环类型</p><pre><code>class ProductB&#123;public:    ProductB(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiCircle : public ProductB&#123;public:    XiaomiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiCircle : public ProductB&#123;public:    HuaweiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;        cout &lt;&lt; &quot;获取了一个华为智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>抽象工厂，创建通过一个产品簇的设备产品</p><pre><code>class AbstractFactory&#123;public:    // 工厂里面创建手机的纯虚函数接口    virtual ProductA* createPhone() = 0;    // 工厂里面创建智能手环的纯虚函数接口    virtual ProductB* createSmartCircle() = 0;&#125;;</code></pre><p>生产小米产品簇的工厂</p><pre><code>class XiaomiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 小米工厂肯定生产小米手机        return new XiaomiPhone(&quot;小米x9&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 小米工厂肯定生产小米智能手环        return new XiaomiCircle(&quot;小米智能手环2代时尚版&quot;);    &#125;&#125;;</code></pre><p>生产华为产品簇的工厂</p><pre><code>class HuaweiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 华为工厂肯定生产华为手机        return new HuaweiPhone(&quot;华为荣耀7x&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 华为工厂肯定生产华为智能手环        return new HuaweiCircle(&quot;华为智能手环B3青春版&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;AbstractFactory&gt; f1(new XiaomiFactory);    unique_ptr&lt;AbstractFactory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建手机产品    unique_ptr&lt;ProductA&gt; p1(f1-&gt;createPhone());    unique_ptr&lt;ProductA&gt; p2(f2-&gt;createPhone());    p1-&gt;show();    p2-&gt;show();    // 通过工厂方法创建智能手环产品    unique_ptr&lt;ProductB&gt; p3(f1-&gt;createSmartCircle());    unique_ptr&lt;ProductB&gt; p4(f2-&gt;createSmartCircle());    p3-&gt;show();    p4-&gt;show();    return 0;&#125;</code></pre><p>可以看到，抽象工厂模式把一个产品簇的产品放在一个工厂类中去创建，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。<br>其实仔细想想，抽象工厂也存在一些问题，比如有的工厂生产某一种产品，但有的工厂它不生产该种产品（可能生产其它的产品），但由于都是从一个抽象工厂继承下来的，所以就会多继承一些无用的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/p/46132.html"/>
      <url>/p/46132.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众多设计模式中，单例模式比较常见的一种，该模式需要满足以下两个条件。</p><ul><li>保证一个类只创建一个实例。</li><li>提供对该实例的全局访问点。</li></ul><p>如果系统有类似的实体（有且只有一个，且需要全局访问），那么就可以将其实现为一个单例。</p><p>实际工作中常见的应用举例</p><ul><li>日志类，一个应用往往只对应一个日志实例。</li><li>配置类，应用的配置集中管理，并提供全局访问。</li><li>管理器，比如windows系统的任务管理器就是一个例子，总是只有一个管理器的实例。</li><li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。</li><li>多线程的线程池，数据库</li></ul><h2 id="Lazy-Singleton"><a href="#Lazy-Singleton" class="headerlink" title="Lazy Singleton"></a>Lazy Singleton</h2><p>头文件中</p><pre><code>class Singleton  &#123;public:    static Singleton&amp; Instance()    &#123;        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;        return *instance_;    &#125;private:    Singleton();    ~Singleton();    Singleton(const Singleton&amp;);    Singleton&amp; operator=(const Singleton&amp;);private:    static Singleton* instance_;&#125;;</code></pre><p>实现文件中</p><pre><code>Singleton* Singleton::instance_ = 0;  </code></pre><p>实现中构造函数被声明为私有方法，这样从根本上杜绝外部使用构造函数生成新的实例，同时禁用拷贝函数与赋值操作符（声明为私有但是不提供实现）避免通过拷贝函数或赋值操作生成新实例。<br>提供静态方法Instance()作为实例全局访问点，该方法中先判断有没有现成的实例，如果有直接返回，如果没有则生成新实例并把实例的指针保存到私有的静态属性中。<br>注意，这里Instance()返回的实例的引用而不是指针，如果返回的是指针可能会有被外部调用者delete掉的隐患，所以这里返回引用会更加保险一些。并且直到Instance()被访问，才会生成实例，这种特性被称为延迟初始化（Lazy initialization），这在一些初始化时消耗较大的情况有很大优势。</p><p>Lazy Singleton不是线程安全的，比如现在有线程A和线程B，都通过instance_ &#x3D;&#x3D; NULL的判断，那么线程A和B都会创建新实例。单例模式保证生成唯一实例的规则被打破了。</p><pre><code>instance_ = new Singleton;</code></pre><p>这条语句实际上做了三件事，</p><ul><li>第一件事申请一块内存</li><li>第二件事调用构造函数</li><li>第三件是将该内存地址赋给instance_</li></ul><p>但是不同的编译器表现是不一样的。可能先将该内存地址赋给instance_，然后再调用构造函数。这时线程A恰好申请完成内存，并且将内存地址赋给instance_，但是还没调用构造函数的时候。线程B执行到判断语句，判断instance_此时不为空，则返回该变量，然后调用该对象的函数，但是该对象还没有进行构造，会发生未定义异常。</p><h2 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h2><p>使用local static对象（函数内的static对象）。当第一次访问Instance()方法时才创建实例。</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            static Singleton instance；            return instance；        &#125;    private:        Singleton()；        ~Singleton()；        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);&#125;;</code></pre><p>这里需要注意的是，C++11以后，要求编译器保证内部静态变量的线程安全性，可以不加锁。但C++ 11以前，仍需要加锁。</p><h2 id="双检测锁模式（Double-Checked-Locking-Pattern）"><a href="#双检测锁模式（Double-Checked-Locking-Pattern）" class="headerlink" title="双检测锁模式（Double-Checked Locking Pattern）"></a>双检测锁模式（Double-Checked Locking Pattern）</h2><p>Lazy Singleton的一种线程安全改造是在Instance()中每次判断是否为NULL前加锁，但是加锁是很慢的。<br>而实际上只有第一次实例创建的时候才需要加锁。双检测锁模式被提出来，改造之后大致是这样</p><pre><code>static Singleton&amp; Instance()  &#123;    if (instance_ == NULL)     &#123;        Lock lock; //基于作用域的加锁，超出作用域，自动调用析构函数解锁        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;    &#125;    return *instance_;&#125;</code></pre><p>既然只需要在第一次初始化的时候加锁，那么在这之前判断一下实例有没有被创建就可以了，所以多在加锁之前多加一层判断，需要判断两次所有叫Double-Checked。理论上问题解决了，但是存在内存读写reorder不安全，编译器优化可能先分配内存，把指针分配给instance_，最后new构造，可能存在线程在分配指针后没有构造的时候就返回*instance_。</p><p>在C++11中有全新的内存模型和原子库，可以很方便的用来实现DCLP。</p><h2 id="c-11-以后版本实现"><a href="#c-11-以后版本实现" class="headerlink" title="c++11 以后版本实现"></a>c++11 以后版本实现</h2><p><img src="/p/46132.htm/c++11%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png"></p><h2 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h2><p>在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，pthread_once是很适合用来实现线程安全单例。</p><pre><code>template&lt;typename T&gt;  class Singleton : boost::noncopyable  &#123;    public:        static T&amp; instance()        &#123;            pthread_once(&amp;ponce_, &amp;Singleton::init);            return *value_;        &#125;        static void init()        &#123;            value_ = new T();        &#125;    private:        static pthread_once_t ponce_;    static T* value_;&#125;;template&lt;typename T&gt;  pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template&lt;typename T&gt;  T* Singleton&lt;T&gt;::value_ = NULL;  </code></pre><p>这里的boost::noncopyable的作用是把构造函数, 赋值函数, 析构函数, 复制构造函数声明为私有或者保护。</p><h2 id="Eager-Singleton"><a href="#Eager-Singleton" class="headerlink" title="Eager Singleton"></a>Eager Singleton</h2><p>这种实现在程序开始(静态属性instance初始化)的时就完成了实例的创建。这正好和上述的Lazy Singleton相反。</p><p>头文件中</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            return instance;        &#125;    private:        Singleton();        ~Singleton();        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);    private:        static Singleton instance;&#125;</code></pre><p>实现文件中</p><pre><code>Singleton Singleton::instance;  </code></pre><p>由于在main函数之前初始化，所以没有线程安全的问题，但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 Instance()方法会返回一个未定义的实例。</p><h2 id="内存释放问题"><a href="#内存释放问题" class="headerlink" title="内存释放问题"></a>内存释放问题</h2><h3 id="单独的函数"><a href="#单独的函数" class="headerlink" title="单独的函数"></a>单独的函数</h3><p>不能在析构函数中使用delete instance__，这会导致一直析构和delete操作循环嵌套下去，应该单独生成一个释放内存的函数</p><pre><code>static void delInstance()&#123; // 为了多线程安全，释放操作也要做 double-check    if(m_pInstance != nullptr)     &#123;        std::lock_guard&lt;std::mutex&gt; lck(m_mutex);        if(m_pInstance != nullptr)         &#123;            delete m_pInstance;            m_pInstance = nullptr;        &#125;    &#125;        &#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>我们知道，进程结束时，静态对象的生命周期随之结束，其析构函数会被调用来释放对象。因此，我们可以利用这一特性，在单例类中声明一个内嵌类，该类的析构函数专门用来释放new出来的单例对象，并声明一个该类类型的static对象。<br><img src="/p/46132.htm/%E6%87%92%E6%B1%89%E5%BC%8F%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98.png"></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>用智能指针来释放new出的内存是一种很省心的，内存释放方式，如OSG中的osg::ref_ptr<class t>(本人接触的第一种智能指针)，UE4中的TSharePtr<class t>。当然，这种方式同样也使用于对单例指针的释放.。不过使用智能指针往往会导致的一个问题就是我们无法去主动控制内存的释放，也不知道它什么时候就被释放掉了。偶尔指针越界也挺让人郁闷的，不过对于初学者来说确实是一种不错的选择。</class></class></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多其他大佬讲解的内容目前还不太明白，只能暂时摘录不懂的地方嵌入blog，未来会对本篇文章进行补充和完善。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/p/29711.html"/>
      <url>/p/29711.html</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>用建造者模式描述简单的电脑组装，电脑组装是个复杂的过程，它包括显示器、鼠标、键盘、主机（主机又包括cpu、显卡、主板等）、耳机等等，我们不可能自己去组装电脑，我们是将自己的配置需求告诉老板，老板安排技术人员组装电脑，然后将电脑交给我们。通过组装电脑可以看出建造者模式的特点：都是由各个简单的对象（电脑各个部件）组成，各个部件（各种各样的显卡、各种各样的cpu等）都可以灵活选择，但是创建产品的步骤大同小异（技术人员组装电脑的过程）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>具体电脑类：</p><pre><code>class Computer&#123;public:    Computer() = default;    ~Computer() &#123;&#125;;    void show()    &#123;        cout &lt;&lt; &quot;电脑创建出来了&quot;&lt;&lt;endl;        cout &lt;&lt; &quot;组成部分：&quot; &lt;&lt; endl;        for (auto t = vec.cbegin(); t != vec.cend(); t++)        &#123;            cout &lt;&lt; * t &lt;&lt; endl;        &#125;    &#125;    void setDisplayer(string displayer) &#123;         vec.push_back(displayer);     &#125;    void setMouse(string mouse) &#123; vec.push_back(mouse); &#125;    void setKeyBoard(string keyboard) &#123; vec.push_back( keyboard); &#125;    void setHost(string host) &#123; vec.push_back(host); &#125;private:    vector&lt;string &gt; vec;&#125;;</code></pre><p>抽象建造者类：</p><pre><code>class Builder&#123;public:    Builder() = default;    ~Builder() &#123; delete pCo; &#125;    virtual void buildDisplayer(string display) &#123;&#125;;    virtual void buildMouse(string mouse) &#123;&#125;;    virtual void buildKeyBoard(string keyboard) &#123;&#125;;    virtual void buildHost(string host) &#123;&#125;;    Computer * getResult()    &#123;        return pCo;    &#125;protected:    Computer *pCo = new Computer();&#125;;</code></pre><p>具体建造者类（组装电脑的技术人员）：</p><pre><code>class ConcreteBuilder :public Builder&#123;public:    ConcreteBuilder() = default;    ~ConcreteBuilder() &#123;&#125;;    void buildDisplayer(string display)    &#123;        pCo-&gt;setDisplayer(display);    &#125;    void buildMouse(string mouse)    &#123;        pCo-&gt;setMouse(mouse);    &#125;    void buildKeyBoard(string keyboard)    &#123;        pCo-&gt;setKeyBoard(keyboard);    &#125;    void buildHost(string host)    &#123;        pCo-&gt;setHost(host);    &#125;&#125;;</code></pre><p>指挥者（卖电脑的老板）:</p><pre><code>class Director&#123;public:    Director(Builder *pBu) &#123; pBuilder = pBu; &#125;     ~Director() &#123; delete pBuilder; &#125;;    Computer *Construct(string display,string mouse,string keyboard,string host)    &#123;        pBuilder-&gt;buildDisplayer(display);        pBuilder-&gt;buildMouse(mouse);        pBuilder-&gt;buildKeyBoard(keyboard);        pBuilder-&gt;buildHost(host);        return pBuilder-&gt;getResult();    &#125;private:    Builder *pBuilder;&#125;;</code></pre><p>比如说我们找老板买的电脑配置是三星显示器、牧马人鼠标、机械键盘、联想主机：</p><pre><code>int main()&#123;    Builder *pBu = new ConcreteBuilder();    Director *pDi = new Director(pBu);    Computer *pCo = pDi-&gt;Construct(&quot;三星显示器&quot;,&quot;牧马人鼠标&quot;,&quot;机械键盘&quot;,&quot;联想主机&quot;);    pCo-&gt;show();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="创建者模式和工厂模式的对比"><a href="#创建者模式和工厂模式的对比" class="headerlink" title="创建者模式和工厂模式的对比"></a>创建者模式和工厂模式的对比</h2><p>Factory模式中：</p><ul><li>有一个抽象的工厂</li><li>实现一个具体的工厂 - 汽车工厂</li><li>工厂生产的汽车A，得到汽车产品A</li><li>工厂生产汽车B，得到汽车产品B</li><li>实现了购买者和生产线的隔离，强调的是结果</li></ul><p>Builder模式</p><ul><li>引擎工厂生产引擎产品，得到汽车的部件A</li><li>轮胎工厂生产轮子产品，得到汽车部件B</li><li>底盘工厂生产车身产品，得到汽车部件C</li><li>将这些部件放到一起，形成刚好能够组装成一辆汽车的整体</li><li>这样做，目的是为了实现复杂对象生产线和其部件的解耦。强调的是过程</li></ul><p>两者的区别在于以下几种情况：</p><ul><li><p>工厂模式不考虑对象的组装过程，而直接生成一个我想要的对象。</p></li><li><p>Builder模式先一个个的创建对象的每一个部件，再统一组装成一个对象</p></li><li><p>工厂模式所解决的问题是，工厂生产产品</p></li><li><p>而Builder模式解决的是工厂控制产品 生成器组装各个部件的过程，然后从产品生成器中得到产品。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/p/22548.html"/>
      <url>/p/22548.html</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F_20220922185016499798.png" alt="原型模式"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在有一个简历 Resume 类，如果要批量复制简历对象，有哪些方法呢？</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string sex;    std::string age;public:    Resume() &#123;&#125;;    void SetPersonalInfo(const std::string&amp; name, const std::sting&amp; age)    &#123;        this.name = name;        this.age = age;    &#125;&#125;;int main()&#123;    Resume p1;    p1.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);    Resume p2;    p2.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);&#125;</code></pre><p>上述实现方式非常简单又容易理解，你需要几份简历，就定义几个简历对象。但是，这里有一个很严重的问题：一旦简历内容需要修改，那么所有的简历对象都需要改动。原型模式正是为了解决它而出现的。</p><p>原型模式</p><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string age;    std::string education;public:    Resume()     &#123;        std::cout &lt;&lt; &quot;Construct !&quot; &lt;&lt; std::endl;    &#125;;    Resume(const Resume&amp; resume)    &#123;        this-&gt;name = resume.name;           this-&gt;age = resume.age;        this-&gt;education = resume.education;        std::cout &lt;&lt; &quot;Copy Construct !&quot; &lt;&lt; std::endl;    &#125;    void SetPersonalInfo(const std::string&amp; name, const std::string&amp; age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void SetEducation(const std::string&amp; educatoin)    &#123;        this-&gt;education = educatoin;    &#125;    void PrintResume()    &#123;        std::cout &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age  &lt;&lt; &quot;, &quot; &lt;&lt; education &lt;&lt; std::endl;    &#125;    Resume* Clone()    &#123;        return new Resume(*this);    &#125;&#125;;int main()&#123;    Resume* p1 = new Resume();    p1-&gt;SetPersonalInfo(&quot;Tom&quot;, &quot;25&quot;);    p1-&gt;SetEducation(&quot;master&quot;);    p1-&gt;PrintResume();    Resume* p2 = p1-&gt;Clone();    p2-&gt;SetPersonalInfo(&quot;Jack&quot;, &quot;28&quot;);    p2-&gt;PrintResume();&#125;</code></pre><p>当我们定义了第一个简历对象 p1 时，如果再需要创建一个对象，直接调用 p1 中的克隆 Clone 方法，然后返回一个新的对象 p2. 如果想要定制化简历 p2 时，只需要在 p2 中修改与 p1 差异的地方就可以了。而 Clone 一定要借助于拷贝构造函数才能实现<br>所以，一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，对性能又是大大的提升。</p><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;iostream&gt;using namespace std;//接口class Prototype&#123;public :    Prototype()&#123;&#125;    virtual ~Prototype()&#123;&#125;    virtual Prototype * Clone() = 0;&#125;;//实现class ConcretePrototype : public Prototype&#123;public :    ConcretePrototype():m_counter(0)&#123;&#125;    virtual ~ConcretePrototype()&#123;&#125;    //拷贝构造函数    ConcretePrototype( const ConcretePrototype &amp; rhs)    &#123;        m_counter = rhs .m_counter;    &#125;    //复制自身    virtual ConcretePrototype * Clone()    &#123;        //调用拷贝构造函数        return new ConcretePrototype (*this );    &#125;private :    int m_counter;&#125;;int main(int argc , char **argv)&#123;    //生成对像    ConcretePrototype * conProA = new ConcretePrototype ();    //复制自身    ConcretePrototype * conProB = conProA-&gt;Clone();    delete conProA;    conProA= NULL ;    delete conProB;    conProB= NULL ;    return 0;&#125;</code></pre><p>浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。但我们可能更需要这样的一种需求，把要复制的对象所引用的对象都复制一遍。我们希望是a、b、c三个引用的对象都是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为‘深复制’，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。clone的时候要注意引用拷贝会发生浅拷贝的现象导致多个指针指向同一个内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/p/122fc4b2.html"/>
      <url>/p/122fc4b2.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><ul><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li>一个设计良好的类，应该是兼顾信息和行为并且高内聚。而不同的类之间，应该做到松耦合</li><li>类之间的关系：<ul><li>泛化关系</li><li>实现关系</li><li>依赖关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li></ul></li></ul><p>对于<code>继承</code>、<code>实现</code>这两种关系比较简单，它们体现的是一种类与类、或者类与接口之间的纵向关系。 其他的四种关系则体现的是类与类、或者类与接口之间的引用&#x2F;横向关系。这四种关系所表现的强弱程度来看，从强到弱依次为：组合&gt;聚合&gt;关联&gt;依赖。<br><a href="https://imgse.com/i/pCpc14x"><img src="https://s1.ax1x.com/2023/06/03/pCpc14x.png" alt="类图关系"></a></p><ul><li><p>泛化（继承），描述一种特殊与一般的关系</p><ul><li>实线空心三角箭头</li><li>代码体现：子类继承父类。</li><li>例如，人类与科学家，科学家是人类的一种。</li><li>如果A类继承了B类，那么A和B就存在泛化关系。</li></ul></li><li><p>实现，描述一种具有关系</p><ul><li>虚线空心三角箭头</li><li>代码体现：实现接口或继承某个抽象类。</li><li>例如，飞翔之于鸟，鸟具有飞翔能力。</li><li>实现关系就是A类实现B接口</li></ul></li><li><p>组合，描述一种整体和部分的关系，强调部分不可脱离整体而存在</p><ul><li>实线实心菱形箭头</li><li>代码体现：成员变量。</li><li>例如，头与眼睛，眼睛不可与头分割。</li></ul></li><li><p>聚合，描述一种整体和部分的关系，强调部分可脱离整体而存在</p><ul><li>实线空心菱形箭头</li><li>代码体现：成员变量    </li><li>例如，学校和老师，老师可脱离学校而存在。</li><li>整体与部分可以分开。聚合关系是关联关系的特例，所以它具有关联的导航性和多重性。</li></ul></li><li><p>关联，描述一种比较固定的关系</p><ul><li>实线箭头</li><li>代码体现：成员变量。</li><li>例如，人与住址。</li><li>类B以类属性的形式出现在关联类A中。</li></ul></li><li><p>依赖，描述一种临时关系</p><ul><li>虚线箭头</li><li>代码体现：局部变量、方法的参数和静态方法的调用。</li><li>例如，人与交通工具，人依赖交通工具。</li><li>只要在类中用到了对方，那么它们之间就存在依赖关系。如果没有对方，则编译不能通过。</li><li>A类中用到了B类</li><li>B类是A类的成员属性</li><li>B类作为A类的方法的返回类型</li><li>B类是A类方法中的参数类型</li><li>A类方法中用到B类</li></ul></li></ul><p>在 A 类中引用 B 类的一个引用 b，当 A 类消亡时，b 这个引用所指对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫组合，反之 b 所指的对象还会有另外的引用它，这种情况叫聚合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装抽象继承多态</title>
      <link href="/p/96cd2f17.html"/>
      <url>/p/96cd2f17.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/p/50254.html"/>
      <url>/p/50254.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p><strong>行为型模式（Behavioral Pattern）：</strong>关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。<br>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><p><strong>创建型模式（Creational Pattern）：</strong>对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。<br>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><p><strong>结构型模式（Structural Pattern）：</strong>关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。<br>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><h2 id="面向对象的设计模式"><a href="#面向对象的设计模式" class="headerlink" title="面向对象的设计模式"></a>面向对象的设计模式</h2><p><strong>底层思维</strong>：如何把握机器底层从微观理解对象构造</p><ul><li>语言构造</li><li>编译转换</li><li>内存模型</li><li>运行时机制</li></ul><p><strong>抽象思维</strong>：如何将我们周围的世界抽象为程序代码</p><ul><li>面向对象</li><li>组件封装</li><li>设计模式</li><li>构架模式</li></ul><p><strong>三大面向对象机制</strong></p><ul><li>封装 隐藏内部实现</li><li>继承 复用现有代码</li><li>多态 改写对象行为</li></ul><h3 id="如何解决软件工程的复杂性？"><a href="#如何解决软件工程的复杂性？" class="headerlink" title="如何解决软件工程的复杂性？"></a>如何解决软件工程的复杂性？</h3><p><strong>分解</strong>：分而治之，将大问题分解成多个小问题<br><strong>抽象</strong>：忽视对象非本质细节，去处理和泛化和理想化的对象模型</p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><strong>依赖倒置原则(DIP)</strong></p><ul><li>高层模块（稳定）不应该依赖于低层模块（变化），二者应该都依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>开放封闭原则(OCP)</strong></p><ul><li>对拓展开放，对更改封闭</li><li>类模块应该是可以拓展的，但是不可修改</li></ul><p><strong>单一职责原则(SRP)</strong></p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p><strong>Liskov替换原则(LSP)</strong></p><ul><li>子类必须能够替代他们的基类(is-A)</li><li>继承表达类型抽象</li></ul><p><strong>接口隔离原则(ISP)</strong></p><ul><li>不应该强迫客户程序依赖他们不用的方法</li><li>接口应该小而完备</li></ul><p><strong>优先使用对象组合，而不是类继承</strong></p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p><strong>封装变化点</strong></p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><p><strong>针对接口编程，而不是针对实现编程</strong></p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需或者对象的具体类型，只需获取对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现”高内聚，松耦合”的类型设计方案</li></ul><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><ul><li><code>+</code> –&gt; public</li><li><code>-</code> –&gt; private</li><li><code>#</code> –&gt; protected</li><li>静态成员，下划线表示</li><li>纯虚函数，斜体</li></ul><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><ul><li>Assocation (knows a)<ul><li>一个对象知道另一个对象的存在，该对象持有另一个对象的指针或者引用。</li></ul></li><li>Dependency (uses a)<ul><li>当类Y与类X彼此独立，而类Y是类X成员函数的一个参数，或者X中成员函数的一个局部变量。</li></ul></li><li>Composition (has a)<ul><li>一个类是另一个类的集合或者容器，但被包含的类与容器本身并不具备相同的生命期</li></ul></li><li>Aggregation (has a)<ul><li>组合（composition）是聚合（Aggregation）的增强版。组合和聚合的根本不同在于类与其所持有元素的是否具有相同的生命期，要求必须相同是一种组合关系。</li></ul></li><li>Inheritance (is a)<ul><li>类间的继承关系表达的是一种derived class B is a base class A。</li></ul></li><li>Class template<ul><li>类模板意味着泛型类。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/p/55487.html"/>
      <url>/p/55487.html</url>
      
        <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。（接口隔离）</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p>何时使用：多个类相互耦合，形成了网状结构。</p><p>如何解决：将上述网状结构分离为星型结构。</p><p>关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p>应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p>优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p><p>缺点：中介者会庞大，变得复杂难以维护。</p><p>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p><p>注意事项：不应当在职责混乱的时候使用。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里采用大话设计模式中的例子</p><pre><code>class Mediator;//抽象人class Person&#123;protected:    Mediator *m_mediator; //中介public:    virtual void SetMediator(Mediator *mediator)&#123;&#125; //设置中介    virtual void SendMessage(string message) &#123;&#125;    //向中介发送信息    virtual void GetMessage(string message) &#123;&#125;     //从中介获取信息&#125;;//抽象中介机构class Mediator&#123;public:    virtual void Send(string message, Person *person) &#123;&#125;    virtual void SetA(Person *A) &#123;&#125;  //设置其中一方    virtual void SetB(Person *B) &#123;&#125;&#125;;//租房者class Renter: public Person&#123;public:    void SetMediator(Mediator *mediator) &#123; m_mediator = mediator; &#125;    void SendMessage(string message) &#123; m_mediator-&gt;Send(message, this); &#125;    void GetMessage(string message) &#123; cout&lt;&lt;&quot;租房者收到信息&quot;&lt;&lt;message; &#125;&#125;;//房东class Landlord: public Person&#123;public:    void SetMediator(Mediator *mediator) &#123; m_mediator = mediator; &#125;    void SendMessage(string message) &#123; m_mediator-&gt;Send(message, this); &#125;    void GetMessage(string message) &#123; cout&lt;&lt;&quot;房东收到信息：&quot;&lt;&lt;message; &#125;&#125;;//房屋中介class HouseMediator : public Mediator&#123;private:    Person *m_A; //租房者    Person *m_B; //房东public:    HouseMediator(): m_A(0), m_B(0) &#123;&#125;    void SetA(Person *A) &#123; m_A = A; &#125;    void SetB(Person *B) &#123; m_B = B; &#125;    void Send(string message, Person *person)     &#123;        if(person == m_A) //租房者给房东发信息            m_B-&gt;GetMessage(message); //房东收到信息        else            m_A-&gt;GetMessage(message);    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/p/22977.html"/>
      <url>/p/22977.html</url>
      
        <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>日常生活中，我们经常到饭店去吃饭，当然我们要吃什么会给服务员说，服务员再转告给厨师，点菜可以看做一个请求，看它如何用命令模式实现</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//命令的处理者：厨师class Chef&#123;public:    void cook(string name)    &#123;        cout &lt;&lt; &quot;厨师做一道&quot; &lt;&lt; name &lt;&lt; endl;    &#125;&#125;;//命令抽象类：点菜class Command&#123;protected:    Chef* chef_;public:    Command(Chef* chef) :chef_(chef) &#123;&#125;    virtual void excute() = 0;&#125;;命令具体类:牛肉class BeefCmd :public Command&#123;public:    BeefCmd(Chef *chef) :Command(chef) &#123;&#125;    virtual void excute() override    &#123;        chef_-&gt;cook(&quot;青椒炒牛肉&quot;);    &#125;&#125;;//命令具体类:土豆class PotatoCmd :public Command&#123;public:    PotatoCmd(Chef *_chef) :Command(_chef) &#123;&#125;    virtual void excute()    &#123;        chef_-&gt;cook(&quot;青椒炒土豆丝&quot;);    &#125;&#125;;//命令接受者：服务员class Waiter&#123;private:    Command* cmd_;public:    void ReciveCmd(Command* cmd)    &#123;        cmd_ = cmd;    &#125;    void DealCmd()    &#123;        cmd_-&gt;excute();    &#125;&#125;;//饭店场景int main()&#123;    //服务员    Waiter *waiter = new Waiter;    //厨师    Chef *chef = new Chef;    //客人开始点菜    Command *beef = new BeefCmd(chef);    Command *potato = new PotatoCmd(chef);    //下单    waiter-&gt;ReciveCmd(beef);    waiter-&gt;DealCmd();    waiter-&gt;ReciveCmd(potato);    waiter-&gt;DealCmd();    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点</strong></p><ul><li>将调用操作的对象和实现操作的对象进行了解耦。</li><li>具体命令扩展方便。</li></ul><p><strong>缺点</strong></p><ul><li>有几个具体命令就有多少具体类，可能需要大量具体命令类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/p/56214.html"/>
      <url>/p/56214.html</url>
      
        <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p>何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p><p>如何解决：通过一个备忘录类专门存储对象状态。</p><p>关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p>应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p><p>优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p>缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p>使用场景： 1、需要保存&#x2F;恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p><p>注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在有一个简历 Resume 类，如果要批量复制简历对象，有哪些方法呢？</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string sex;    std::string age;public:    Resume() &#123;&#125;;    void SetPersonalInfo(const std::string&amp; name, const std::sting&amp; age)    &#123;        this.name = name;        this.age = age;    &#125;&#125;;int main()&#123;    Resume p1;    p1.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);    Resume p2;    p2.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);&#125;</code></pre><p>上述实现方式非常简单又容易理解，你需要几份简历，就定义几个简历对象。但是，这里有一个很严重的问题：一旦简历内容需要修改，那么所有的简历对象都需要改动。原型模式正是为了解决它而出现的。</p><p>原型模式</p><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string age;    std::string education;public:    Resume()     &#123;        std::cout &lt;&lt; &quot;Construct !&quot; &lt;&lt; std::endl;    &#125;;    Resume(const Resume&amp; resume)    &#123;        this-&gt;name = resume.name;           this-&gt;age = resume.age;        this-&gt;education = resume.education;        std::cout &lt;&lt; &quot;Copy Construct !&quot; &lt;&lt; std::endl;    &#125;    void SetPersonalInfo(const std::string&amp; name, const std::string&amp; age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void SetEducation(const std::string&amp; educatoin)    &#123;        this-&gt;education = educatoin;    &#125;    void PrintResume()    &#123;        std::cout &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age  &lt;&lt; &quot;, &quot; &lt;&lt; education &lt;&lt; std::endl;    &#125;    Resume* Clone()    &#123;        return new Resume(*this);    &#125;&#125;;int main()&#123;    Resume* p1 = new Resume();    p1-&gt;SetPersonalInfo(&quot;Tom&quot;, &quot;25&quot;);    p1-&gt;SetEducation(&quot;master&quot;);    p1-&gt;PrintResume();    Resume* p2 = p1-&gt;Clone();    p2-&gt;SetPersonalInfo(&quot;Jack&quot;, &quot;28&quot;);    p2-&gt;PrintResume();&#125;</code></pre><p>当我们定义了第一个简历对象 p1 时，如果再需要创建一个对象，直接调用 p1 中的克隆 Clone 方法，然后返回一个新的对象 p2. 如果想要定制化简历 p2 时，只需要在 p2 中修改与 p1 差异的地方就可以了。而 Clone 一定要借助于拷贝构造函数才能实现<br>所以，一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，对性能又是大大的提升。</p><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;iostream&gt;using namespace std;//接口class Prototype&#123;public :    Prototype()&#123;&#125;    virtual ~Prototype()&#123;&#125;    virtual Prototype * Clone() = 0;&#125;;//实现class ConcretePrototype : public Prototype&#123;public :    ConcretePrototype():m_counter(0)&#123;&#125;    virtual ~ConcretePrototype()&#123;&#125;    //拷贝构造函数    ConcretePrototype( const ConcretePrototype &amp; rhs)    &#123;        m_counter = rhs .m_counter;    &#125;    //复制自身    virtual ConcretePrototype * Clone()    &#123;        //调用拷贝构造函数        return new ConcretePrototype (*this );    &#125;private :    int m_counter;&#125;;int main(int argc , char **argv)&#123;    //生成对像    ConcretePrototype * conProA = new ConcretePrototype ();    //复制自身    ConcretePrototype * conProB = conProA-&gt;Clone();    delete conProA;    conProA= NULL ;    delete conProB;    conProB= NULL ;    return 0;&#125;</code></pre><p>浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。但我们可能更需要这样的一种需求，把要复制的对象所引用的对象都复制一遍。我们希望是a、b、c三个引用的对象都是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为‘深复制’，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。clone的时候要注意引用拷贝会发生浅拷贝的现象导致多个指针指向同一个内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/p/14565.html"/>
      <url>/p/14565.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_20220922195857226500.png" alt="模板方法模式"><br>个人理解大概就是覆盖和隐藏的应用</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用模板方法前</p><pre><code>//程序库开发人员class Library &#123;public:    void Step1() &#123;        //...    &#125;    void Step3() &#123;        //...    &#125;    void Step5() &#123;        //...    &#125;&#125;;//应用程序开发人员class Application &#123;public:    bool Step2() &#123;        //...    &#125;    void Step4() &#123;        //...    &#125;&#125;;int main()&#123;    Library lib;    Application app;    lib.Step1();    if (app.Step2()) &#123;        lib.Step3();    &#125;    for (int i = 0; i &lt; 4; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre><p>使用模板方法后</p><pre><code>//程序库开发人员class Library &#123;public:    //稳定 template method    void Run() &#123;        Step1();        if (Step2()) &#123; //支持变化 ==&gt; 虚函数的多态调用            Step3();        &#125;        for (int i = 0; i &lt; 4; i++) &#123;            Step4(); //支持变化 ==&gt; 虚函数的多态调用        &#125;        Step5();    &#125;    virtual ~Library() &#123; &#125;protected:    void Step1() &#123; //稳定        //.....    &#125;    void Step3() &#123;//稳定        //.....    &#125;    void Step5() &#123; //稳定        //.....    &#125;    virtual bool Step2() = 0;//变化    virtual void Step4() = 0; //变化&#125;;//应用程序开发人员class Application : public Library &#123;protected:    virtual bool Step2() &#123;        //... 子类重写实现    &#125;    virtual void Step4() &#123;        //... 子类重写实现    &#125;&#125;;int main()&#123;    Library* pLib = new Application();    pLib-&gt;Run();    delete pLib;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis</title>
      <link href="/p/26793.html"/>
      <url>/p/26793.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Jedis入门"><a href="#Jedis入门" class="headerlink" title="Jedis入门"></a>Jedis入门</h2><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="/p/26793.htm/%5CRedis.assets%5C1652959239813.png" alt="1652959239813"></p><p>1）引入依赖：</p><pre><code class="xml">&lt;!--jedis--&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><pre><code class="java">private Jedis jedis;@BeforeEachvoid setUp() &#123;    // 1.建立连接    // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);    jedis = JedisConnectionFactory.getJedis();    // 2.设置密码    jedis.auth(&quot;123321&quot;);    // 3.选择库    jedis.select(0);&#125;</code></pre><p>3）测试：</p><pre><code class="java">@Testvoid testString() &#123;    // 存入数据    String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;);    System.out.println(&quot;result = &quot; + result);    // 获取数据    String name = jedis.get(&quot;name&quot;);    System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123;    // 插入hash数据    jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;);    jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;);    // 获取    Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;);    System.out.println(map);&#125;</code></pre><p>4）释放资源</p><pre><code class="java">@AfterEachvoid tearDown() &#123;    if (jedis != null) &#123;        jedis.close();    &#125;&#125;</code></pre><h2 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h2><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h3 id="创建Jedis的连接池"><a href="#创建Jedis的连接池" class="headerlink" title="创建Jedis的连接池"></a>创建Jedis的连接池</h3><pre><code class="java">public class JedisConnectionFacotry &#123;     private static final JedisPool jedisPool;     static &#123;         //配置连接池         JedisPoolConfig poolConfig = new JedisPoolConfig();         poolConfig.setMaxTotal(8);         poolConfig.setMaxIdle(8);         poolConfig.setMinIdle(0);         poolConfig.setMaxWaitMillis(1000);         //创建连接池对象         jedisPool = new JedisPool(poolConfig,                 &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;);     &#125;     public static Jedis getJedis()&#123;          return jedisPool.getResource();     &#125;&#125;</code></pre><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h3 id="改造原始代码"><a href="#改造原始代码" class="headerlink" title="改造原始代码"></a>改造原始代码</h3><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><pre><code class="java">    @BeforeEach    void setUp()&#123;        //建立连接        /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/        jedis = JedisConnectionFacotry.getJedis();         //选择库        jedis.select(0);    &#125;   @AfterEach    void tearDown() &#123;        if (jedis != null) &#123;            jedis.close();        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL</title>
      <link href="/p/28345.html"/>
      <url>/p/28345.html</url>
      
        <content type="html"><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h2 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h2><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://i.imgur.com/4tUgFo6.png"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://i.imgur.com/GdqOSsj.png"></p><p>也可以是文档型：</p><p><img src="https://i.imgur.com/zBBQfcc.png"></p><p>甚至可以是图格式：</p><p><img src="https://i.imgur.com/zBnKxWf.png"></p><h2 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h2><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://i.imgur.com/tXYSl5x.png"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre><code class="json">&#123;  id: 1,  name: &quot;张三&quot;,  orders: [    &#123;       id: 1,       item: &#123;     id: 10, title: &quot;荣耀6&quot;, price: 4999       &#125;    &#125;,    &#123;       id: 2,       item: &#123;     id: 20, title: &quot;小米11&quot;, price: 3999       &#125;    &#125;  ]&#125;</code></pre><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h2 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h2><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://i.imgur.com/AzaHOTF.png"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://i.imgur.com/J1MqOJM.png"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><a href="https://imgse.com/i/z7g2qg"><img src="https://s1.ax1x.com/2022/12/16/z7g2qg.png" alt="z7g2qg.png"></a></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataRedis</title>
      <link href="/p/5455.html"/>
      <url>/p/5455.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1652976773295.png" alt="1652976773295"></p><h2 id="导入pom坐标"><a href="#导入pom坐标" class="headerlink" title="导入pom坐标"></a>导入pom坐标</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.7&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;artifactId&gt;redis-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;redis-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--redis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--common-pool--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="yaml">spring:  redis:    host: 192.168.150.101    port: 6379    password: 123321    lettuce:      pool:        max-active: 8  #最大连接        max-idle: 8   #最大空闲连接        min-idle: 0   #最小空闲连接        max-wait: 100ms #连接等待时间</code></pre><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre><code class="java">@SpringBootTestclass RedisDemoApplicationTests &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        redisTemplate.opsForValue().set(&quot;name&quot;, &quot;虎哥&quot;);        // 获取string数据        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;&#125;</code></pre><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h2 id="数据序列化器"><a href="#数据序列化器" class="headerlink" title="数据序列化器"></a>数据序列化器</h2><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://i.imgur.com/OEMcbuu.png"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://i.imgur.com/5FjtWk5.png"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;        // 创建RedisTemplate对象        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置连接工厂        template.setConnectionFactory(connectionFactory);        // 创建JSON序列化工具        GenericJackson2JsonRedisSerializer jsonRedisSerializer =                                         new GenericJackson2JsonRedisSerializer();        // 设置Key的序列化        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // 设置Value的序列化        template.setValueSerializer(jsonRedisSerializer);        template.setHashValueSerializer(jsonRedisSerializer);        // 返回        return template;    &#125;&#125;</code></pre><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://i.imgur.com/XOAq3cN.png"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h2><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://i.imgur.com/zXH6Qn6.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;);        // 获取string数据        Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;    private static final ObjectMapper mapper = new ObjectMapper();    @Test    void testSaveUser() throws JsonProcessingException &#123;        // 创建对象        User user = new User(&quot;虎哥&quot;, 21);        // 手动序列化        String json = mapper.writeValueAsString(user);        // 写入数据        stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json);        // 获取数据        String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;);        // 手动反序列化        User user1 = mapper.readValue(jsonUser, User.class);        System.out.println(&quot;user1 = &quot; + user1);    &#125;&#125;</code></pre><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h2 id="Hash结构操作"><a href="#Hash结构操作" class="headerlink" title="Hash结构操作"></a>Hash结构操作</h2><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testHash() &#123;        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;name&quot;, &quot;虎哥&quot;);        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;age&quot;, &quot;21&quot;);        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:400&quot;);        System.out.println(&quot;entries = &quot; + entries);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见命令</title>
      <link href="/p/31805.html"/>
      <url>/p/31805.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><h2 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="/p/31805.htm/1652887393157.png" alt="1652887393157"></p><p>Redis为了方便学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="/p/31805.htm/1652887648826.png" alt="1652887648826"></p><p>也可以通过Help命令来帮助我们去查看命令</p><p><img src="/p/31805.htm/1652887748279.png" alt="1652887748279"></p><h2 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="/p/31805.htm/1652887865189.png" alt="1652887865189"></p><p>代码如下</p><ul><li>KEYS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;</code></pre><p><strong>在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help del  DEL key [key ...]  summary: Delete a key  since: 1.0.0  group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1  #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3   #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt;127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;#只剩下一个了</code></pre><ul><li>EXISTS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help EXISTS  EXISTS key [key ...]  summary: Determine if a key exists  since: 1.0.0  group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0</code></pre><ul><li>EXPIRE</li></ul><p><strong>内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</strong></p><pre><code class="sh">127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) 8127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; ttl age(integer) -2  #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1  # ttl的返回值就是-1</code></pre><h2 id="Redis命令-String命令"><a href="#Redis命令-String命令" class="headerlink" title="Redis命令-String命令"></a>Redis命令-String命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p>数值类型得字符串Redis会将其转为对应的二进制</p><p><img src="/p/31805.htm/1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><pre><code class="java">127.0.0.1:6379&gt; set name Rose  //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot;</code></pre><ul><li>MSET和MGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot;   //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot;</code></pre><ul><li>INCR和INCRBY和DECY</li></ul><pre><code class="java">127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11    127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值    127.0.0.1:6379&gt; incrby age 2(integer) 15    127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14    127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12    127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11    127.0.0.1:6379&gt; get age &quot;11&quot;</code></pre><ul><li>SETNX</li></ul><pre><code class="java">127.0.0.1:6379&gt; help setnx  SETNX key value  summary: Set the value of a key, only if the key does not exist  since: 1.0.0  group: string127.0.0.1:6379&gt; set name Jack  //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot;</code></pre><ul><li>SETEX</li></ul><pre><code class="sh">127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 5</code></pre><h2 id="Redis命令-Key的层级结构"><a href="#Redis命令-Key的层级结构" class="headerlink" title="Redis命令-Key的层级结构"></a>Redis命令-Key的层级结构</h2><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="/p/31805.htm/1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如项目名称叫 hust，有user和product两种不同类型的数据，可以这样定义key：</p><ul><li><p>user相关的key：<strong>hust:user:1</strong></p></li><li><p>product相关的key：<strong>hust:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>hust:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>hust:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="Redis命令-Hash命令"><a href="#Redis命令-Hash命令" class="headerlink" title="Redis命令-Hash命令"></a>Redis命令-Hash命令</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/p/31805.htm/1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/p/31805.htm/1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><ul><li>HSET和HGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; HSET hust:user:3 name Lucy//大key是 hust:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET hust:user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET hust:user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET hust:user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET hust:user:3 age&quot;17&quot;</code></pre><ul><li>HMSET和HMGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; HMSET hust:user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET hust:user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET hust:user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HGETALL</li></ul><pre><code class="java">127.0.0.1:6379&gt; HGETALL hust:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot;</code></pre><ul><li>HKEYS和HVALS</li></ul><pre><code class="java">127.0.0.1:6379&gt; HKEYS hust:user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS hust:user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HINCRBY</li></ul><pre><code class="java">127.0.0.1:6379&gt; HINCRBY  hust:user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS hust:user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY  hust:user:4 age -2(integer) 20</code></pre><ul><li>HSETNX</li></ul><pre><code class="java">127.0.0.1:6379&gt; HSETNX hust:user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL hust:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX hust:user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL hust:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot;</code></pre><h2 id="Redis命令-List命令"><a href="#Redis命令-List命令" class="headerlink" title="Redis命令-List命令"></a>Redis命令-List命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="/p/31805.htm/.%5CRedis.assets%5C1652943604992.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><pre><code class="java">127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6</code></pre><ul><li>LPOP和RPOP</li></ul><pre><code class="java">127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot;</code></pre><ul><li>LRANGE</li></ul><pre><code class="java">127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot;</code></pre><h2 id="Redis命令-Set命令"><a href="#Redis命令-Set命令" class="headerlink" title="Redis命令-Set命令"></a>Redis命令-Set命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png"></p><p><strong>具体命令</strong></p><pre><code class="java">127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1    127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0    127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1    127.0.0.1:6379&gt; SCARD s1(integer) 2</code></pre><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><pre><code class="java">127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu(integer) 3    127.0.0.1:6379&gt; SADD ls wangwu mazi ergou(integer) 3    127.0.0.1:6379&gt; SCARD zs(integer) 3    127.0.0.1:6379&gt; SINTER zs ls1) &quot;wangwu&quot;    127.0.0.1:6379&gt; SDIFF zs ls1) &quot;zhaoliu&quot;2) &quot;lisi&quot;    127.0.0.1:6379&gt; SUNION zs ls1) &quot;wangwu&quot;2) &quot;zhaoliu&quot;3) &quot;lisi&quot;4) &quot;mazi&quot;5) &quot;ergou&quot;    127.0.0.1:6379&gt; SISMEMBER zs lisi(integer) 1    127.0.0.1:6379&gt; SISMEMBER ls zhangsan(integer) 0    127.0.0.1:6379&gt; SREM zs lisi(integer) 1    127.0.0.1:6379&gt; SMEMBERS zs1) &quot;zhaoliu&quot;2) &quot;wangwu&quot;</code></pre><h2 id="Redis命令-SortedSet类型"><a href="#Redis命令-SortedSet类型" class="headerlink" title="Redis命令-SortedSet类型"></a>Redis命令-SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>SortedSet具有可排序特性，所以经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志类型</title>
      <link href="/p/41558.html"/>
      <url>/p/41558.html</url>
      
        <content type="html"><![CDATA[<h1 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h1><p>MySQL中有七种日志文件，分别是：</p><ul><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>二进制日志（binlog）</li><li>错误日志（errorlog）</li><li>慢查询日志（slow query log）</li><li>通用查询日志（general log）</li><li>中继日志（relay log）</li></ul><h2 id="undo-log-和-redo-log"><a href="#undo-log-和-redo-log" class="headerlink" title="undo log 和 redo log"></a>undo log 和 redo log</h2><p>undo log 和 redo log 其实都不是 MySQL 数据库层面的日志，而是 InnoDB 存储引擎的日志。二者的作用联系紧密，事务的隔离性由锁来实现，原子性、一致性、持久性通过数据库的 redo log 或 redo log 来完成。redo log 又称为重做日志，用来保证事务的持久性，undo log 用来保证事务的原子性和 MVCC。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log 是 InnoDB 引擎特有的日志，先来看一个例子。</p><p>酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存Buffer Pool。这个缓存中包含了磁盘中部分数据页（page）的映射，以此来缓解数据库的磁盘压力。</p><p>当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为脏页，Buffer Pool中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为刷脏页。如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时Buffer Pool中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。</p><p>为了解决这个问题引入了redo log，redo Log它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。和大多数关系型数据库一样，InnoDB 记录了对数据文件的物理更改，并保证总是日志先行，在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。由于 redo log 是顺序整块写入，所以性能要更好。redo log 的存储都是以块(block)为单位进行存储的，每个块的大小为 512 字节。同磁盘扇区大小一致，可以保证块的写入是原子操作。另外 redo log 占用的空间是固定的，会循环写入。文件大小由innodb_log_file_size参数控制。</p><p>重做日志两部分组成：一是内存中的重做日志缓冲(redo log buffer)，是易失的；二是重做日志文件(redo log file)，是持久的。redo log 记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。</p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，在一条语句进行执行的时候，InnoDB 引擎会把新记录写到 redo log 日志中，然后更新内存，更新完成后就算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将 redo log 中的内容更新到磁盘中。</p><p><img src="https://s1.ax1x.com/2023/07/07/pCcAGxx.png" alt="pCcAGxx.png"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。check point检查点简单来说就是把脏页刷到磁盘的时间点，这个时间点之前的数据都已经保存到了持久存储。LSN 是 InnoDB 使用的一个版本标记的计数，它是一个单调递增的值。数据页和 redo log 都有各自的 LSN。每次把 redo log 中的内容写入到实际的数据页之后，就会把 LSN 也同步过去。如果发生了宕机，我们可以根据数据页中的 LSN 值和 redo log 中 LSN 的值判断需要恢复的 redo log 的位置和大小。</p><p>redo log 同样也有自己的缓存，所以也涉及到刷盘策略，是通过innodb_flush_log_at_trx_commit这个参数控制的。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 有两个作用：提供回滚和多版本并发控制下的读(MVCC)，也即非锁定读。在数据修改的时候，不仅记录了redo，还记录了相对应的 undo，如果因为某些原因导致事务失败或回滚了，可以借助该 undo 进行回滚。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。</p><p>有时候应用到行版本控制的时候，也是通过 undo log 来实现的：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p><p>undo log 是采用段(segment)的方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment。</p><p>另外，undo log 也会产生 redo log，因为 undo log 也要实现持久性保护。</p><p>当事务提交的时候，InnoDB 不会立即删除 undo log，因为后续还可能会用到 undo log，如隔离级别为 repeatable read 时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即 undo log 不能删除。</p><p>当事务提交之后，undo log 并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否有其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间。</p><p>在 MySQL 5.7 之前，undo log 存储在共享表空间中，因此有可能大大增加表空间的占用，5.7 之后可以通过配置选择存储在独立的表空间中。</p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为hostname.err，其中，hostname为服务器主机名。<br>log_error 参数控制错误日志是否写入文件及文件名称，默认情况下，错误日志被写入终端标准输出stderr。当然，推荐指定 log_error 参数，自定义错误日志文件位置及名称。<br>下面我们来看一下它的位置。</p><pre><code>mysql&gt; show variables like &#39;%log_error%&#39;;+---------------------+---------------------+| Variable_name       | Value               |+---------------------+---------------------+| log_error           | /var/log/mysqld.log |+---------------------+---------------------+3 rows in set (0.13 sec)</code></pre><p>其中，&#x2F;var&#x2F;log&#x2F;mysqld.log 就是 MySQL 数据库错误日志的路径。</p><p>如果，要想将错误信息写入到错误日志中，还受 MySQL 数据库中 log_warnings 参数的影响，该参数有三个参数，分别是 0、1 和大于 1 三个参数。</p><ul><li>当 log_warnings 的结果为 0 时，不记录警告日志。</li><li>当 log_warnings 的结果为 1 时，记录错误日志，并且将警告日志也记录到错误日志之中。</li><li>当 log_warnings 的结果大于 1 时，除了记录警告日志和错误日志之外，还将连接失败的信息也记录到错误日志。</li></ul><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。<br>几个配置参数：</p><ul><li>slow_query_log 慢查询开启状态</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要 MySQL 的运行帐号的可写权限，一般设置为 MySQL 的数据存放目录）</li><li>long_query_time 查询超过多少秒才记录</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）</li></ul><p>修改参数可以通过配置文件，也可以在数据库中通过SET关键字来设置。</p><p>可以通过以下命令启动慢查询日志、设置指定时间：</p><pre><code>SET GLOBAL slow_query_log=ON/OFF;SET GLOBAL long_query_time=n;</code></pre><p>慢查询日志可以使用 mysqladmin 命令来删除。也可以使用手工方式来删除。mysqladmin 命令的语法如下：</p><pre><code>mysqladmin -uroot -p flush-logs</code></pre><p>执行该命令后，命令行会提示输入密码。输入正确密码后，将执行删除操作。新的慢查询日志会直接覆盖旧的查询日志，不需要再手动删除。</p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>Server 层也有自己的日志，称为 binlog（归档日志）,二进制日志（Binary Log）也可叫作变更日志（Update Log），可以说是MySQL最重要的日志。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，它记录了所有的DDL和DML语句（除了数据查询语句select）,以事件形式记录，还包含语句所执行的消耗的时间。redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。MySQL的二进制日志是事务安全型的。<br><strong>注：</strong></p><pre><code>DDL----Data Definition Language 数据库定义语言 主要的命令有create、alter、drop等，ddl主要是用在定义或改变表(table)的结构,数据类型，表之间的连接和约束等初始工作上，他们大多在建表时候使用。DML----Data Manipulation Language 数据操纵语言主要命令是slect,update,insert,delete,就像它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</code></pre><p>二进制日志有以下功能</p><ul><li><p>恢复（recovery）</p><ul><li>某些数据的恢复需要二进制日志。例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。</li></ul></li><li><p>复制（replication）</p><ul><li>其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或者standby）与一台MySQL数据库（一般称为master或者primary）进行实时同步。</li></ul></li><li><p>审计（audit）</p><ul><li>用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul></li><li><p>除了上面介绍的几个作用外，binlog对于事务存储引擎的崩溃恢复也有非常重要的作用。</p><ul><li>在开启binlog的情况下，为了保证binlog与redo的一致性，MySQL将采用事务的两阶段提交协议。当MySQL系统发生崩溃时，事务在存储引擎内部的状态可能为prepared和commit两种。对于prepared状态的事务，是进行提交操作还是进行回滚操作，这时需要参考binlog：如果事务在binlog中存在，那么将其提交；如果不在binlog中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</li></ul></li></ul><p>mysql binlog常见的选项有一下几个：</p><p>a、–start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地计算机的时间<br>b、–stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地计算机的时间 取值和上述一样<br>c、–start-position：从二进制日志中读取指定position 事件位置作为开始。<br>d、–stop-position：从二进制日志中读取指定position 事件位置作为事件截至<br>e、一般来说开启binlog日志大概会有1%的性能损耗。</p><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数建议也设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><h3 id="两提交协议"><a href="#两提交协议" class="headerlink" title="两提交协议"></a>两提交协议</h3><p>我们来详细说明一下上面的两提交协议</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。<br>假设有下面两条语句：</p><pre><code>create table T(ID int primary key, c int);update T set c=c+1 where ID=2;</code></pre><p><img src="https://s1.ax1x.com/2023/07/07/pCcA7Q0.png" alt="pCcA7Q0.png"><br>假设有一组数据id &#x3D; 2 ; c &#x3D; 0 ;我们来看看不是两提交协议会有什么问题：</p><ul><li><p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></li><li><p>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p></li></ul><h2 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h2><p>通用查询日志（general query log）用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发送给MySQL数据库服务器的所有SQL指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，准确定位问题。</p><ul><li>查看日志是否开启<ul><li>SHOW VARIABLES LIKE ‘general_log’;</li></ul></li><li>开启日志功能<ul><li>SET GLOBAL general_log&#x3D;’ON’;</li></ul></li><li>关闭日志功能<ul><li>SET GLOBAL general_log&#x3D;’OFF’;</li></ul></li><li>看看日志文件保存位置<ul><li>SHOW VARIABLES LIKE ‘general_log_file’;</li></ul></li><li>设置日志文件保存位置<ul><li>SET GLOBAL general_log_file&#x3D;’C:\tmp.log’;</li></ul></li><li>看看日志输出类型 TABLE 或 FILE<ul><li>SHOW VARIABLES LIKE ‘log_output’;</li></ul></li><li>设置输出类型为 TABLE<ul><li>SET GLOBAL log_output&#x3D;’TABLE’;</li></ul></li><li>设置输出类型为FILE<ul><li>SET GLOBAL log_output&#x3D;’FILE’;</li></ul></li></ul><h2 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h2><p>中继日志只在主从服务器架构的从服务器上存在，从服务器（slave）为了与主服务器(Master)保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p><p><a href="https://imgse.com/i/pp5ibLV"><img src="https://s1.ax1x.com/2023/04/04/pp5ibLV.png" alt="pp5ibLV.png"></a></p><ul><li>Master收到客户端请求语句，在语句结束之前向二进制日志写入一条记录，可能包含多个事件</li><li>此时，一个Slave连接到Master，Master的dump线程从binlog读取日志并发送到Slave的IO线程。</li><li>IO线程从master.info读取到上一次写入的最后的位置。</li><li>IO线程写入日志到relay-log中继日志，如果超过指定的relay-log大小，写入轮换事件，创建一个新的relay-log。</li><li>更新master.info的最后位置</li><li>SQL线程从relay-log.info读取进上一次读取的位置</li><li>SQL线程读取日志事件</li><li>在数据库中执行sql</li><li>更新relay-log.info的最后位置</li><li>Slave记录自己的binlog日志</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p><p>好处是“最长恢复时间”更短。</p><p>在一天一备的模式里，最坏情况下需要应用一天的 binlog。比如，你每天 0 点做一次全量备份，而要恢复出一个到昨天晚上 23 点的备份。</p><p>一周一备最坏情况就要应用一周的 binlog 了。</p><p>系统的对应指标就是提到的 RTO（恢复目标时间）。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 RTO 是成本换来的，就需要根据业务重要性来评估。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/p/11557.html"/>
      <url>/p/11557.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助 MySQL 高效获取数据的<strong>有序</strong>的<strong>数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p><strong>分类</strong><br>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。<br>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。<br>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。<br>按「字段个数」分类：单列索引、联合索引。</p><p><strong>✅ 优点</strong></p><ul><li>索引能够提高数据检索的效率，降低数据库的IO成本。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，创建唯一索引</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>加速两个表之间的连接，一般是在外键上创建索引</li></ul><p><strong>❌ 缺点</strong></p><ul><li>需要占用物理空间,建立的索引越多需要的空间越大</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长</li></ul><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。<br>每个结点默认分配16KB大小<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>B+Tree非叶子结点不存储data,只存储索引（冗余），可以在同一节点放更多索引，进而缩小树的高度</li><li>叶子结点使用指针连接（B-tree没有），提高区间访问的性能</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><p>所以建议InnoDB必须建主键，并且推荐使用整形的自增主键。否则Mysql需要帮你维护一个rowid，耗费性能，同时整型比较的效率更高，占用内存更小。自增可以保证节点分裂的次数减少。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><pre><code>select * from user where id = 10;select * from user where name = &#39;Arm&#39;;</code></pre><p>– 备注：id为主键，name字段创建的有索引</p><pre><code>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</code></pre><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><pre><code>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表。</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建索引：</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code></pre><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：</p><pre><code>SHOW INDEX FROM table_name;</code></pre><p>删除索引：</p><pre><code>DROP INDEX index_name ON table_name;</code></pre><p>案例：</p><p>– name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</p><pre><code>create index idx_user_name on tb_user(name);</code></pre><p>– phone手机号字段的值非空，且唯一，为该字段创建唯一索引</p><pre><code>create unique index idx_user_phone on tb_user (phone);</code></pre><p>– 为profession, age, status创建联合索引</p><pre><code>create index idx_user_pro_age_stat on tb_user(profession, age, status);</code></pre><p>– 为email建立合适的索引来提升查询效率</p><pre><code>create index idx_user_email on tb_user(email);</code></pre><p>– 删除索引</p><pre><code>drop index idx_user_email on tb_user;</code></pre><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p><pre><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code></pre><p>例：</p><pre><code>show global status like &#39;Com_______&#39;</code></pre><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>开启慢查询日志开关</p><pre><code>slow_query_log=1</code></pre><p>设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</p><pre><code>long_query_time=2</code></pre><p>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：</p><pre><code>show variables like &#39;slow_query_log&#39;;</code></pre><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p><pre><code>SELECT @@have_profiling;</code></pre><p>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：</p><pre><code>SET profiling = 1;</code></pre><p>查看所有语句的耗时：</p><pre><code>show profiles;</code></pre><p>查看指定query_id的SQL语句各个阶段的耗时：</p><pre><code>show profile for query query_id;</code></pre><p>查看指定query_id的SQL语句CPU的使用情况</p><pre><code>show profile cpu for query query_id;</code></pre><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><pre><code>直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</code></pre><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><ol><li>在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) &#x3D; ‘15’;这里对phone进行操作了</li><li>字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone &#x3D; 17799990015;，此处phone的值没有加引号进行了隐式类型转换。</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like ‘%工程’;，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>不使用哪个索引：</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>必须使用哪个索引：</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h3><p>在说明普通索引和唯一索引对更新语句性能的影响这个问题，先介绍一下 change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>虽然名字叫作 change buffer，实际上它是<strong>可持久化</strong>的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</p><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</p><p>第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h4 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h4><p>上面介绍了使用 change buffer 对更新过程的加速作用以及change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</p><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><h3 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *当中的* 的使用。</p><p>explain 中 extra 字段含义：</p><ul><li>using index condition：查找使用了索引，但是需要回表查询数据</li><li>using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</li></ul><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name&#x3D;’xxx’;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name&#x3D;’xxx’;</p><p>所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p><strong>面试题</strong><br>一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br>select id, username, password from tb_user where username&#x3D;’itcast’;</p><pre><code>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</code></pre><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：create index idx_xxxx on table_name(columnn(n));<br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><pre><code>select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</code></pre><p>show index 里面的sub_part可以看到接取的长度</p><p>使用前缀索引就用不上覆盖索引对查询性能的优化了</p><h3 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h3><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><pre><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code></pre><p>这句只会用到phone索引字段</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="/p/35621.html"/>
      <url>/p/35621.html</url>
      
        <content type="html"><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><pre><code class="mysql">create table user(    id int primary key auto_increment,    name varchar(10) not null unique,    age int check(age &gt; 0 and age &lt; 120),    status char(1) default &#39;1&#39;,    gender char(1));</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><pre><code class="mysql">CREATE TABLE 表名(    字段名 字段类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</code></pre><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-x2F-更新行为"><a href="#删除-x2F-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表空间回收</title>
      <link href="/p/e16fda58.html"/>
      <url>/p/e16fda58.html</url>
      
        <content type="html"><![CDATA[<h1 id="表空间回收"><a href="#表空间回收" class="headerlink" title="表空间回收"></a>表空间回收</h1><p>数据库占用空间太大，把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p><h2 id="参数-innodb-file-per-table"><a href="#参数-innodb-file-per-table" class="headerlink" title="参数 innodb_file_per_table"></a>参数 innodb_file_per_table</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><p>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p><p>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</p><p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p><p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>我们在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><h2 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h2><p>InnoDB 里的数据都是用 B+ 树的结构组织的。<br>假设，我们要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p><img src="https://s1.ax1x.com/2023/07/07/pCcUBxx.png" alt="pCcUBxx.png"></p><p>InnoDB 的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，整个数据页就可以被复用了。但是，数据页的复用跟记录的复用是不同的。</p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置了。</p><p>而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以上图为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID&#x3D;50 的记录需要使用新页的时候，page A 是可以被复用的。</p><p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>进一步地，如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p><p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而重建表，就可以达到这样的目的。</p><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>可以新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。</p><p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p><p>可以使用 alter table A engine&#x3D;InnoDB 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。</p><p>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。引入了 Online DDL 之后，重建表的流程：</p><ul><li>建立一个临时文件，扫描表 A 主键的所有数据页；</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件</li><li>用临时文件替换表 A 的数据文件。</li></ul><p>由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。</p><p>alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁实现 Online，MDL 读锁不会阻塞增删改操作,还可以禁止其他线程对这个表同时做 DDL。</p><p>而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，要很小心地控制操作时间。如果想要比较安全的操作的话，推荐使用 GitHub 开源的 gh-ost 来做。</p><h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><ul><li>DDL 过程如果是 Online 的，就一定是 inplace 的；</li><li>反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图</title>
      <link href="/p/3825.html"/>
      <url>/p/3825.html</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><blockquote><p>特点:</p><p>封装，复用 -----------------------&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p><p>可以接收参数，也可以返回数据 --------&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p><p>减少网络交互，效率提升 -------------&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></blockquote><h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol><li>简单</li></ol><blockquote><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p></blockquote><ol start="2"><li>安全</li></ol><blockquote><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p></blockquote><ol start="3"><li>数据独立</li></ol><blockquote><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>创建</li><li>查询</li><li>修改</li><li>删除</li></ul><p>– 创建视图</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>– 查看创建视图语句：</p><pre><code>SHOW CREATE VIEW 视图名称;</code></pre><p>– 查看视图数据：</p><pre><code>SELECT * FROM 视图名称 ...... ;方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>– 删除视图</p><pre><code> DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</code></pre><p>– 创建视图</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 查询视图</p><pre><code>show create view stu_v_1;select * from stu_v_1;select * from stu_v_1 where id &lt; 3 ;</code></pre><p>– 修改视图</p><pre><code>create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10 ;alter view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 删除视图</p><pre><code>drop view if exists stu_v_1;</code></pre><p>执行下面的SQL，我们会发现，id为 6 和 17 的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id为 17 的记录。</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values( 6 ,&#39;Tom&#39;);insert into stu_v_1 values( 17 ,&#39;Tom22&#39;);</code></pre><p>因为我们在创建视图的时候，指定的条件为 id&lt;&#x3D;10, id为 17 的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。<br>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p><h3 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h3><h4 id="级联。"><a href="#级联。" class="headerlink" title="级联。"></a>级联。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><h3 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h3><h4 id="本地。"><a href="#本地。" class="headerlink" title="本地。"></a>本地。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><blockquote><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p></blockquote><p>A.  聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p><p>B.  DISTINCT</p><p>C.  GROUP BY</p><p>D.  HAVING</p><p>E.  UNION 或者 UNION ALL</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触发器</title>
      <link href="/p/40758.html"/>
      <url>/p/40758.html</url>
      
        <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。<br>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><h4 id="触发器类型-NEW-和-OLD"><a href="#触发器类型-NEW-和-OLD" class="headerlink" title="触发器类型 NEW 和 OLD"></a>触发器类型 NEW 和 OLD</h4><ul><li>INSERT 型触发器   NEW   表示将要或者已经新增的数据</li><li>UPDATE 型触发器   OLD   表示修改之前的数据 , NEW 表示将要或已经修改后的数据</li><li>DELETE 型触发器   OLD   表示将要或者已经删除的数据</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建</p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGIN    trigger_stmt ;END;</code></pre><p>查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>删除</p><pre><code>DROP TRIGGER [schema_name]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ;<br>创建表结构：</p><pre><code>create table user_logs(    id int( 11 ) not null auto_increment,    operation varchar( 20 ) not null comment &#39;操作类型, insert/update/delete&#39;,    operate_time datetime not null comment &#39;操作时间&#39;,    operate_id int( 11 ) not null comment &#39;操作的ID&#39;,    operate_params varchar( 500 ) comment &#39;操作参数&#39;,    primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>定义插入触发器：</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params)     VALUES(        null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:        id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,        profession=&#39;, NEW.profession)    );end;</code></pre><p>定义更新触发器：</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params)     VALUES(        null, &#39;update&#39;, now(), new.id,        concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession)    );end; </code></pre><p>定义删除触发器：</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES    (null, &#39;delete&#39;, now(), old.id,    concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/p/21631.html"/>
      <url>/p/21631.html</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</code></pre><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。<br>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</li></ul><p><strong>A.  我们一起先来分析一下不加全局锁，可能存在的问题。</strong></p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。业务中执行插入订单日志操作。</li><li>最后，又备份了tb_orderlog表。</li><li>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</li></ul><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p><strong>B.  再来分析一下加了全局锁后的情况</strong></p><p> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性。</p><p>既然要全库只读，为什么不使用 set global readonly&#x3D;true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但还是建议用 FTWRL 方式，主要有两个原因：</p><ul><li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li><li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><p>业务的更新不只是增删改数据(DML) ，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>数据备份官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><pre><code>mysqldump -uroot –p1234 itcast &gt; itcast.sql</code></pre><p>释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</code></pre><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><p>表锁的语法是 lock tables … read&#x2F;write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li>加锁：lock tables 表名... read&#x2F;write。</li><li>释放锁：unlock tables &#x2F; 客户端断开连接 。<br>特点:</li></ul><p>A.  读锁</p><p><img src="/p/21631.htm/%E8%AF%BB%E9%94%81.png"></p><p>B.  写锁<br><img src="/p/21631.htm/%E5%86%99%E9%94%81.png"></p><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)。<br>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong><br>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p><p>常见的SQL操作时，所添加的元数据锁：</p><p><img src="/p/21631.htm/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81.png"></p><p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ &#x2F; SHARED_WRITE），之间是兼容的。</p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><pre><code>select object_type,object_schema,object_name,lock_type,lock_duration fromperformance_schema.metadata_locks ;</code></pre><p>虽然 MDL 锁是系统默认会加的，但却是不能忽略的一个机制。事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。<br>所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。<br>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><ul><li>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</li><li>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</li></ul><p>有了意向锁之后 :</p><ul><li>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</li><li>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p><strong>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</strong><br>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><p>A.  意向共享锁与表读锁是兼容的<br>B.  意向排他锁与表读锁、写锁都是互斥的</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>两种行锁的兼容情况如下:<br><img src="/p/21631.htm/%E8%A1%8C%E9%94%81%E5%85%BC%E5%AE%B9%E6%83%85%E5%86%B5.png"></p><h4 id="常见的SQL语句，在执行时，所加的行锁如下："><a href="#常见的SQL语句，在执行时，所加的行锁如下：" class="headerlink" title="常见的SQL语句，在执行时，所加的行锁如下："></a>常见的SQL语句，在执行时，所加的行锁如下：</h4><p><img src="/p/21631.htm/%E6%B7%BB%E5%8A%A0%E8%A1%8C%E9%94%81%E7%B1%BB%E5%9E%8B.png"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><p>A. 普通的select语句，执行时，不会加锁。<br>B. select…lock in share mode，加共享锁</p><ul><li>共享锁与共享锁之间兼容。</li><li>共享锁与排他锁之间互斥。</li><li>排它锁与排他锁之间互斥。</li><li>无索引行锁升级为表锁。</li></ul><p>stu表中数据如下:</p><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><strong>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</strong></p><p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。<br>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p><p>分析一下：</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为 18 的数据，并加上共享锁，我们是只锁定 18 这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个 18 的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值。此时会对 18 加临键锁，并对间隙加锁。</p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p><p>[19]</p><p>(19,25]</p><p>(25,+∞]</p><p>所以数据库数据在加锁是，就是将 19 加了行锁， 25 的临键锁（包含 25 及 25 之前的间隙），正无穷的临<br>键锁(正无穷及之前的间隙)。</p><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。<br>事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li></ul><p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>比如所有事务都要更新同一行的场景<br>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p>怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p><ul><li><p>一种头痛医头的方法，就是如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p></li><li><p>另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p></li></ul><p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。以影院账户为例，假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ul><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li></ul><p>每个顾客买票都需要操作影院的余额，这时候我们可以记录一条交易日志。可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储过程</title>
      <link href="/p/64451.html"/>
      <url>/p/64451.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li><p>封装，复用                  ————-&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p></li><li><p>可以接收参数，也可以返回数据  ————-&gt; 在存储过程中，可以传递参数，也可以接收返回</p></li><li><p>减少网络交互，效率提升       ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol><li><p>创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN    -- SQL语句END ;</code></pre></li><li><p>调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre></li><li><p>查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre></li><li><p>删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre></li></ol><p>命令行中分号会导致错误，需要用delimiter设置结束语句</p><pre><code>delimiter $$</code></pre><p>现在结束语句以$$结束</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p></blockquote><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><blockquote><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p></blockquote><ol><li><p>查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre></li></ol><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION，会话变量。<br>全局变量(GLOBAL): 全局变量针对于所有的会话。<br>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><ol start="2"><li><p>设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre></li></ol><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p><h4 id="演示示例"><a href="#演示示例" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1 ;insert into course(id, name) VALUES ( 6 , &#39;ES&#39;);set global autocommit = 0 ;select @@global.autocommit;</code></pre><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><blockquote><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 &quot;@变量名&quot; 使用就可以。其作用域为当前连接。会话一建立的连接会话二无法使用。</p></blockquote><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ol><li><p>方式一:</p><pre><code> 赋值时，可以使用 = ，也可以使用 := 推荐：= SELECT @var_name := expr [, @var_name := expr] ... ; SELECT 字段名 INTO @var_name FROM 表名;</code></pre></li><li><p>方式二:</p><pre><code> SET @var_name = expr [, @var_name = expr] ... ; SET @var_name := expr [, @var_name := expr] ... ;</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>SELECT @var_name ;</code></pre><h4 id="演示示例-1"><a href="#演示示例-1" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 赋值set @myname = &#39;itcast&#39;;set @myage := 10 ;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><p><strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。</p></blockquote><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><pre><code>select @abc;DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><h4 id="演示示例-2"><a href="#演示示例-2" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>create procedure p2()begin    declare stu_count int default 0 ;    select count(*) into stu_count from student;    select stu_count;end;call p2();</code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>if 用于做条件判断，具体的语法结构为：</p><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p3()begin    declare score int default 58 ;    declare result varchar( 10 );    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;    select result;end;call p3();</code></pre><blockquote><p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。<br>那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？ 答案是肯定的，我们可以通过接下来所讲解的 参数 来解决上述的问题。</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><ul><li>IN 该类参数作为输入，也就是需要调用时传入值</li><li>OUT 该类参数作为输出，也就是该参数可以作为返回值</li><li>INOUT 既可以作为输入参数，也可以作为输出参数</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>根据传入参数score，判定当前分数对应的分数等级，并返回。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p4(in score int, out result varchar( 10 ))begin    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;end;</code></pre><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回 。</p><pre><code>create procedure p5(inout score double)begin    set score := score * 0.5;end;</code></pre><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式： </p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>语法1</strong>：</p><pre><code>CASE case_value    WHEN when_value1 THEN statement_list1    [ WHEN when_value2 THEN statement_list2] ...    [ ELSE statement_list ]END CASE;</code></pre><p>– 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，<br>执行statement_list2， 否则就执行 statement_list</p><p><strong>语法2</strong>：</p><pre><code>CASE    WHEN search_condition1 THEN statement_list1    [WHEN search_condition2 THEN statement_list2] ...    [ELSE statement_list]END CASE;</code></pre><p>– 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</p><blockquote><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p></blockquote><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p><ul><li>1-3月份，为第一季度</li><li>4-6月份，为第二季度</li><li>7-9月份，为第三季度</li><li>10-12月份，为第四季度</li></ul><p>代码如下：</p><pre><code>create procedure p6(in month int)begin    declare result varchar( 10 );    case        when month &gt;= 1 and month &lt;= 3 then            set result := &#39;第一季度&#39;;        when month &gt;= 4 and month &lt;= 6 then            set result := &#39;第二季度&#39;;        when month &gt;= 7 and month &lt;= 9 then            set result := &#39;第三季度&#39;;        when month &gt;= 10 and month &lt;= 12 then            set result := &#39;第四季度&#39;;        else            set result := &#39;非法参数&#39;;    end case ;    select concat(&#39;您输入的月份为: &#39;,month, &#39;, 所属的季度为: &#39;,result);end;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DO    SQL逻辑...END WHILE;</code></pre><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p>计算从1累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p7(in n int)begin    declare total int default 0 ;    while n&gt; 0 do         set total := total + n;        set n := n - 1 ;    end while;    select total;end;</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEAT    SQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2). 案例"></a>2). 案例</h4><p>计算从 1 累加到n的值，n为传入的参数值。(使用repeat实现)</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p8(in n int)begin    declare total int default 0 ;    repeat        set total := total + n;        set n := n - 1 ;        until n &lt;= 0    end repeat;    select total;end;</code></pre><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p><pre><code>[begin_label:] LOOP    SQL逻辑...END LOOP [end_label];</code></pre><ul><li>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</li><li>LEAVE ：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>计算从 1 累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx</p><pre><code>create procedure p9(in n int)begin    declare total int default 0 ;    sum:loop    if n&lt;= 0 then        leave sum;    end if;        set total := total + n;        set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h5 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h5><p>计算从 1 到n之间的偶数累加的值，n为传入的参数值。<br>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx<br>– C. 如果当次累加的数据是奇数, 则直接进入下一次循环. ——–&gt; iterate xx</p><pre><code>create procedure p10(in n int)begin    declare total int default 0 ;    sum:loop        if n&lt;= 0 then            leave sum;        end if;        if n% 2 = 1 then            set n := n - 1 ;            iterate sum;        end if;            set total := total + n;            set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A.  声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B.  打开游标</p><pre><code>OPEN 游标名称 ;</code></pre><p>C.  获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D.  关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>– 逻辑:<br>– A. 声明游标, 存储查询结果集<br>– B. 准备: 创建表结构<br>– C. 开启游标<br>– D. 获取游标中的记录<br>– E. 插入数据到新表中<br>– F. 关闭游标</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。<br>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。</p><h2 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><pre><code>ECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action    CONTINUE: 继续执行当前程序    EXIT: 终止执行当前程序condition_value    SQLSTATE sqlstate_value: 状态码，如 02000    SQLWARNING: 所有以 01 开头的SQLSTATE代码的简写    NOT FOUND: 所有以 02 开头的SQLSTATE代码的简写    SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。<br>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>A.  通过SQLSTATE指定具体的状态码</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02000 时，将关闭游标u_cursor，并退出    declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>B.  通过SQLSTATE的代码简写方式 NOT FOUND 02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02 开头时，将关闭游标u_cursor，并退出    declare exit handler for not found close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        DETERMINISTIC：相同的输入参数总是产生相同的结果        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>具体的错误状态码，可以参考官方文档：**<a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a> <a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a>**</p><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN    -- SQL语句    RETURN ...;END ;</code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h3 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h3><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegin    declare total int default 0 ;    while n&gt; 0 do        set total := total + n;        set n := n - 1 ;    end while;    return total;end;</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错：</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/p/21513.html"/>
      <url>/p/21513.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><p>– 拼接<br><code>SELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);</code><br>– 小写<br><code>SELECT LOWER(&#39;Hello&#39;);</code><br>– 大写<br><code>SELECT UPPER(&#39;Hello&#39;);</code><br>– 左填充<br><code>SELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 右填充<br><code>SELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 去除空格<br><code>SELECT TRIM(&#39; Hello World &#39;);</code><br>– 切片（起始索引为1）<br><code>SELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);</code></p><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><p>– DATE_ADD</p><pre><code>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</code></pre><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><pre><code>select    name,    (case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)from employee;select    name,    (case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;from employee;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/p/29900.html"/>
      <url>/p/29900.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>数据库分为两类模型</p><ul><li>概念模型&#x2F;信息模型</li><li>物理模型和逻辑模型</li></ul><p>基本概念：实体，属性，码，实体型，实体集</p><p>分为三大范式</p><ul><li>第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。</li><li>第二范式：确保表中的每列都和主键相关</li><li>第三范式：确保每列都和主键列直接相关而不是间接相关</li></ul><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）定义数据逻辑结构</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><p>数据库语句后面记得加分号！</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>查询所有数据库：</p><pre><code>SHOW DATABASES;</code></pre><p>查询当前数据库：</p><pre><code>SELECT DATABASE();</code></pre><p>创建数据库：</p><pre><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code></pre><p>使用数据库：</p><pre><code>USE 数据库名;</code></pre><p><strong>注意事项</strong>：UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</p><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查询当前数据库所有表：</p><pre><code>SHOW TABLES;</code></pre><p>查询表结构：</p><pre><code>DESC 表名;</code></pre><p>查询指定表的建表语句：</p><pre><code>SHOW CREATE TABLE 表名;</code></pre><p>创建表：</p><pre><code>CREATE TABLE 表名(    字段1 字段1类型 [COMMENT 字段1注释],    字段2 字段2类型 [COMMENT 字段2注释],    字段3 字段3类型 [COMMENT 字段3注释],    ...    字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];最后一个字段后面没有逗号</code></pre><p>添加字段：</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>修改数据类型：</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></pre><p>修改字段名和字段类型：</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>删除字段：</p><pre><code>ALTER TABLE 表名 DROP 字段名;</code></pre><p>修改表名：</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名</code></pre><p>删除表：</p><pre><code>DROP TABLE [IF EXISTS] 表名;</code></pre><p>删除表，并重新创建该表：</p><pre><code>TRUNCATE TABLE 表名;</code></pre><h4 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h4><p>TRUNCATE语句用于快速且高效地从表中删除所有行，实际上是删除表中的所有数据。与逐行删除的DELETE语句不同，TRUNCATE是一种更快速的操作，它一次性删除所有行，而不会为每个删除的行生成单独的回滚日志。</p><p>TRUNCATE语句的语法如下：</p><pre><code>TRUNCATE TABLE 表名;</code></pre><p>表名是要从中删除所有行的表的名称。<br>以下是使用TRUNCATE语句从名为”customers”的表中删除所有行的示例：</p><pre><code>TRUNCATE TABLE customers;</code></pre><p>当执行TRUNCATE语句时，指定表中的所有数据都将被删除，但表的结构、索引和约束将保持不变。表将变为零行，但仍然存在于数据库中。</p><p>需要注意TRUNCATE语句的以下几点：</p><ul><li>TRUNCATE是DDL（数据定义语言）语句，不是像DELETE那样的DML（数据操作语言）语句。因此，它不能使用ROLLBACK语句进行回滚。</li><li>不能对其他表中的外键约束引用的表使用TRUNCATE操作。在截断表之前，需要禁用或删除这些约束，并在截断后重新启用或重新创建它们。</li><li>TRUNCATE将重置与表相关联的任何自增值或序列计数器。</li><li>该操作无法撤消，在使用TRUNCATE语句之前，确保备份想保留的任何数据。</li></ul><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>指定字段：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>全部字段：</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>批量添加数据：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></pre><p><strong>注意事项</strong></p><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li><li>更新和删除数据</li></ul><p>修改数据：</p><pre><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code></pre><p>例：</p><pre><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></pre><p>删除数据：</p><pre><code>DELETE FROM 表名 [ WHERE 条件 ];</code></pre><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p><strong>编写顺序</strong></p><ol><li>SELECT<br> 字段列表</li><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><p><strong>执行顺序</strong></p><ol><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li><ul><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li></ul></li><li>SELECT<br> 字段列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>查询多个字段：</p><pre><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;</code></pre><p>设置别名</p><pre><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></pre><p>去除重复记录：</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><p>转义：</p><pre><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code></pre><p>&#x2F; 之后的_不作为通配符</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></pre><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr><tr><td>例子：</td><td></td></tr></tbody></table><p>– 年龄等于30</p><pre><code>select * from employee where age = 30;</code></pre><p>– 年龄小于30</p><pre><code>select * from employee where age &lt; 30;</code></pre><p>– 小于等于</p><pre><code>select * from employee where age &lt;= 30;</code></pre><p>– 没有身份证</p><pre><code>select * from employee where idcard is null or idcard = &#39;&#39;;</code></pre><p>– 有身份证</p><pre><code>select * from employee where idcard;select * from employee where idcard is not null;</code></pre><p>– 不等于</p><pre><code>select * from employee where age != 30;</code></pre><p>– 年龄在20到30之间</p><pre><code>select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;</code></pre><p>– 下面语句不报错，但查不到任何信息</p><pre><code>select * from employee where age between 30 and 20;</code></pre><p>– 性别为女且年龄小于30</p><pre><code>elect * from employee where age &lt; 30 and gender = &#39;女&#39;;</code></pre><p>– 年龄等于25或30或35</p><pre><code>select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);</code></pre><p>– 姓名为两个字</p><pre><code>select * from employee where name like &#39;__&#39;;</code></pre><p>– 身份证最后为X</p><pre><code>select * from employee where idcard like &#39;%X&#39;;</code></pre><h3 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h3><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：</p><pre><code>SELECT 聚合函数(字段列表) FROM 表名;</code></pre><p>例：</p><pre><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></pre><p><strong>where 和 having 的区别：</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。<br>例子：</li></ul><p>– 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</p><pre><code>select count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性数量</p><pre><code>select gender, count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性的平均年龄</p><pre><code>select gender, avg(age) from employee group by gender;</code></pre><p>– 年龄小于45，并根据工作地址分组</p><pre><code>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</code></pre><p>– 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</code></pre><p><strong>注意事项</strong></p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></pre><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><p>– 根据年龄升序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;</code></pre><p>– 两字段排序，根据年龄升序排序，入职时间降序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</code></pre><p><strong>注意事项:</strong> 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></pre><p>例子：</p><p>– 查询第一页数据，展示10条</p><pre><code>SELECT * FROM employee LIMIT 0, 10;</code></pre><p>– 查询第二页</p><pre><code>SELECT * FROM employee LIMIT 10, 10;</code></pre><p>注意事项</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><p><strong>DQL执行顺序</strong><br>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>查询用户：</p><pre><code>USE mysql;SELECT * FROM user;</code></pre><p>创建用户:</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>修改用户密码：</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></pre><p>删除用户：</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>例子：</p><p>– 创建用户test，只能在当前主机localhost访问</p><pre><code>create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><p>– 创建用户test，能在任意主机访问</p><pre><code>create user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;test&#39; identified by &#39;123456&#39;;</code></pre><p>– 修改密码</p><pre><code>alter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;</code></pre><p>– 删除用户</p><pre><code>drop user &#39;test&#39;@&#39;localhost&#39;;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>主机名可以使用 % 通配</li></ul><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><p>查询权限：</p><pre><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>授予权限：</p><pre><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;`</code></pre><p>撤销权限：</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h4><p>BLOB（Binary Large Object）是一种数据库中用于存储二进制数据的数据类型。BLOB可以存储大量的二进制数据，例如图像、音频、视频等。</p><p>BLOB类型通常用于需要存储和检索大型二进制文件的场景，而不是简单的文本数据。它可以存储任意长度的二进制数据，并提供对这些数据的读取和写入操作。</p><p>在数据库中，BLOB类型可以有多个子类型，如以下示例：</p><pre><code>TINYBLOB：最大长度为 255 个字节。BLOB：最大长度为 65,535 个字节。MEDIUMBLOB：最大长度为 16,777,215 个字节。LONGBLOB：最大长度为 4,294,967,295 个字节。</code></pre><p>具体的数据库系统可能对BLOB类型有所不同，但通常都提供了类似的概念和功能。</p><p>使用BLOB类型时，您可以将二进制数据插入到表中的BLOB列中，然后通过查询和操作来读取和写入该数据。</p><p>需要注意的是，由于BLOB类型存储的是二进制数据，因此在进行查询、排序和比较时需要特殊处理。一些数据库系统还提供了针对BLOB数据的特定函数和操作，以便更有效地处理这些数据。</p><h4 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a>TEXT</h4><p>TEXT是一种数据库中用于存储文本数据的数据类型。它用于保存较长或可变长度的文本信息。</p><p>TEXT类型通常用于存储大段的文本数据，例如文章内容、日志记录、备注等。它可以存储任意长度的文本，而不会受到固定长度限制。</p><p>在数据库中，TEXT类型可以有多个子类型，如以下示例：</p><pre><code>TINYTEXT：最大长度为 255 个字符。TEXT：最大长度为 65,535 个字符。MEDIUMTEXT：最大长度为 16,777,215 个字符。LONGTEXT：最大长度为 4,294,967,295 个字符。</code></pre><p>具体的数据库系统可能对TEXT类型有所不同，但通常都提供了类似的概念和功能。</p><p>使用TEXT类型时，可以将文本数据插入到表中的TEXT列中，并通过查询和操作来读取和修改该数据。</p><p>需要注意在进行查询、排序和比较时需要考虑文本的编码、大小写等特性。一些数据库系统还提供了针对TEXT数据的特定函数和操作，以便更有效地处理这些数据。</p><h4 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h4><p>ENUM是一种数据库中用于存储枚举（Enumeration）类型的数据类型。枚举类型允许定义一个固定的可选值列表，并将列限制为仅允许这些值之一。</p><p>在数据库中，可以使用ENUM类型来定义一个列，该列的值只能是预定义的一组值之一。例如，有一个名为”gender”的列，将其定义为ENUM类型，并指定可能的值为”male”和”female”。</p><p>ENUM类型的优势之一是它可以提供数据的约束性，确保只有预定义的值可以插入或更新到该列中。它还可以提高查询的可读性，可以更加直观地理解和使用数据。</p><p>使用ENUM类型时，需要在列定义中指定可选的枚举值列表。例如：</p><pre><code>gender ENUM(&#39;male&#39;, &#39;female&#39;)</code></pre><p>上述示例定义了一个名为”gender”的ENUM列，它只允许值为”male”或”female”。</p><h4 id="BINARY"><a href="#BINARY" class="headerlink" title="BINARY"></a>BINARY</h4><p>BINARY是一种数据库中用于存储二进制数据的数据类型。它与BLOB（Binary Large Object）类型不同，BINARY类型是用于存储固定长度的二进制数据。</p><p>BINARY类型不像BLOB类型那样可以存储任意长度的二进制数据，它存储指定长度的二进制数据。BINARY类型在创建时需要指定固定的长度，超出该长度的数据将被截断。</p><p>在数据库中，BINARY类型通常用于存储二进制文件的哈希值、加密数据、图像的缩略图等固定长度的二进制数据。</p><p>例如，MySQL中的BINARY类型可以使用以下语法进行定义：</p><pre><code>column_name BINARY(length)</code></pre><p>其中，<code>column_name</code> 是创建的列的名称，<code>length</code> 是指定的固定长度。</p><p>BINARY类型存储的是二进制数据，因此在进行查询、比较和排序时需要特殊处理。某些数据库系统可能提供了针对BINARY数据的特定函数和操作，以便更有效地处理这些数据。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于数据的存储和传输。它基于JavaScript的对象和数组表示法，并具有易于读写和解析的特点。</p><p>在数据库中，JSON通常用作一种数据类型，用于存储和处理结构化的、半结构化的或无结构的数据。JSON数据类型将数据以JSON格式存储在数据库中，并提供了一些功能来查询、更新和操作这些数据。</p><p>使用JSON类型，可以在一个字段中存储复杂的数据结构，如嵌套的对象和数组。在存储具有动态属性的数据或需要存储和查询非规范化数据的情况非常有用。</p><p>以下是一个示例，定义一个JSON列：</p><pre><code>CREATE TABLE table_name (    column_name JSON);</code></pre><p>上述示例创建了一个名为<code>column_name</code>的JSON列。</p><h4 id="GEOMETRY"><a href="#GEOMETRY" class="headerlink" title="GEOMETRY"></a>GEOMETRY</h4><p>GEOMETRY是一种数据库中用于存储几何数据的数据类型。它用于表示和操作空间数据，如点、线、多边形等。</p><p>GEOMETRY类型是在数据库中处理空间数据的基础。它可以存储和处理各种几何对象，例如二维平面上的点、线、多边形，以及三维空间中的立方体、球体等。</p><p>数据库系统提供了一组函数和操作符，用于在GEOMETRY数据上执行空间操作，如距离计算、交集判断、缓冲区分析等。</p><p>以下是一个示例，展示如何在数据库中定义一个GEOMETRY列：</p><pre><code class="sql">CREATE TABLE table_name (    column_name GEOMETRY);</code></pre><p>需要注意的是，使用GEOMETRY类型存储和处理空间数据需要考虑数据库系统的支持和相应的空间扩展。常见的数据库系统如MySQL、PostgreSQL和SQL Server都提供了对GEOMETRY类型的支持.</p><h3 id="国产数据库"><a href="#国产数据库" class="headerlink" title="国产数据库"></a>国产数据库</h3><h4 id="达梦"><a href="#达梦" class="headerlink" title="达梦"></a>达梦</h4><p>不支持DELETE …ORDER BY<br>不支持UPDATE … LIMIT（高于某些版本能支持）；<br>不支持order by和distinct操作；<br>支持数据库实例级字段及字段值不区分大小写；</p><h4 id="南大通用"><a href="#南大通用" class="headerlink" title="南大通用"></a>南大通用</h4><p>不支持UPDATE … LIMIT（高于某些版本能支持）；<br>创建数据库和表需要指定表空间；<br>默认字段值区分大小写；<br>不支持declare begin xxx end; 语句，需要通过存储过程和函数实现；<br>alter table add column时， varchar(n)  n不能超过4000，modify column无此限制；<br>南大通用通过ODBC连接时，必须在odbc.ini设置字符集 UNICODE&#x3D;UCS-2；<br>南大通用dbproxy适配时，binary&#x2F;varbinary、blob类型列是将原始值转为十六进制存储。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储引擎</title>
      <link href="/p/27905.html"/>
      <url>/p/27905.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。</p><p><strong>MySQL体系结构：</strong></p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><ul><li>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。</li><li>存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。</li><li>默认存储引擎是InnoDB。</li></ul><p>相关操作：</p><p>– 查询建表语句</p><pre><code>show create table account;</code></pre><p>– 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(    ...) ENGINE=INNODB;</code></pre><p>– 查看mysql所支持的存储引擎，以及从中得到mysql默认的存储引擎。</p><pre><code>show engines;</code></pre><p>– 查看mysql 默认的存储引擎</p><pre><code>show variables like &#39;% storage_engine&#39;; </code></pre><p>– 查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</p><pre><code>show create table tablename ; </code></pre><p>– 准确查看某个数据库中的某一表所使用的存储引擎</p><pre><code>show table status from database where name=&quot;tablename&quot; </code></pre><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：</p><pre><code>show variables like &#39;innodb_file_per_table&#39;;</code></pre><p>从idb文件提取表结构数据：（在cmd运行）</p><pre><code>ibd2sdi xxx.ibd</code></pre><p>InnoDB 逻辑存储结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><p>优缺点：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 是 MySQL 早期的默认存储引擎。MyISAM强调了快速读取操作，主要用于高负载的select</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><p>优缺点：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><p>memory存储引擎文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。所以memory存储引擎中的表的生命周期很短，一般只使用一次。</p><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Screenshot_20220920_193246_tv.danmaku.bili_20220920193701368683.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/p/19503.html"/>
      <url>/p/19503.html</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><p>– 查询员工姓名，及关联的部门的名称<br>1.隐式</p><pre><code>select e.name, d.name from employee as e, dept as d where e.dept = d.id;</code></pre><p>2.显式</p><pre><code>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><ul><li><p>左外连接：</p><p>  查询左表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>  相当于查询表1的所有数据，包含表1和表2交集部分数据</p></li><li><p>右外连接：</p><p>  查询右表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p></li></ul><p>例子：</p><p>左</p><pre><code>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</code></pre><p>右</p><pre><code>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</code></pre><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h2 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h2><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><p>– 查询员工及其所属领导的名字</p><pre><code>select a.name, b.name from employee a, employee b where a.manager = b.id;</code></pre><p>– 没有领导的也查询出来</p><pre><code>select a.name, b.name from employee a left join employee b on a.manager = b.id;</code></pre><h2 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h2><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 则对重复结果进行去重处理</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code></p><p><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><p>– 查询销售部所有员工</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>– 根据销售部部门ID，查询员工信息</p><pre><code>select * from employee where dept = 4;</code></pre><p>– 合并（子查询）</p><pre><code>select * from employee where dept = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>– 查询xxx入职之后的员工信息</p><pre><code>select * from employee where entrydate &gt; (select entrydate from employee where name = &#39;xxx&#39;);</code></pre><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><p>– 查询销售部和市场部的所有员工信息</p><pre><code>select * from employee where dept in (select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;);</code></pre><p>– 查询比财务部所有人工资都高的员工信息</p><pre><code>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#39;财务部&#39;));</code></pre><p>– 查询比研发部任意一人工资高的员工信息</p><pre><code>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#39;研发部&#39;));</code></pre><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><p>– 查询与xxx的薪资及直属领导相同的员工信息</p><pre><code>select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#39;xxx&#39;);</code></pre><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><p>– 查询与xxx1，xxx2的职位和薪资相同的员工</p><pre><code>select * from employee where (job, salary) in (select job, salary from employee where name = &#39;xxx1&#39; or name = &#39;xxx2&#39;);</code></pre><p>– 查询入职日期是2006-01-01之后的员工，及其部门信息</p><pre><code>select e.*, d.* from (select * from employee where entrydate &gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept = d.id;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/p/62546.html"/>
      <url>/p/62546.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><p>– 1. 查询张三账户余额</p><pre><code>select * from account where name = &#39;张三&#39;;</code></pre><p>– 2. 将张三账户余额-1000</p><pre><code>update account set money = money - 1000 where name = &#39;张三&#39;;</code></pre><p>– 此语句出错后张三钱减少但是李四钱没有增加<br>    模拟sql语句错误</p><p>– 3. 将李四账户余额+1000</p><pre><code>update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p>– 查看事务提交方式</p><pre><code>SELECT @@AUTOCOMMIT;</code></pre><p>– 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</p><pre><code>SET @@AUTOCOMMIT = 0;</code></pre><p>– 提交事务</p><pre><code>COMMIT;</code></pre><p>– 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>– 设置手动提交后上面代码改为：</p><pre><code>select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><p>操作方式二：</p><p>开启事务：</p><pre><code>START TRANSACTION 或 BEGIN TRANSACTION;</code></pre><p>提交事务：</p><pre><code>COMMIT;</code></pre><p>回滚事务：</p><pre><code>ROLLBACK;</code></pre><p>操作实例：</p><pre><code>start transaction;select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><h2 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h2><ul><li>原子性(Atomicity)：  事务是不可分割的最小操作单元，要么全部成功，要么全部失败<ul><li>由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li></ul></li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态<ul><li>一致性由其他三大特性保证、程序代码要保证业务上的一致性</li></ul></li><li>隔离性(Isolation)：  数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行<ul><li>隔离性由MVCC来保证</li></ul></li><li>持久性(Durability)： 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的<ul><li>持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复。</li></ul></li></ul><p>事务的原子性指一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。</p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态;如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。<br>另一部分是业务数据的一致性，这需要程序代码来保证。比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。</p><p>事务的隔离性指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>事务的持久性指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。持久性意味着事务操作最终要持久化到数据库中，持久性是由 内存+redo log来保证的，MySQL的InnoDB在修改数据的时候，同时在内存和redo log记录这次操作，宕机的时候可以从redo log中恢复数据。</p><h2 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>设置事务隔离级别：</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code></pre><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h2 id="事务是否是隔离的"><a href="#事务是否是隔离的" class="headerlink" title="事务是否是隔离的"></a>事务是否是隔离的</h2><p>在看这里之前，建议先看<br><a href="https://whl963854.github.io/p/14751.html">https://whl963854.github.io/p/14751.html</a><br><a href="https://whl963854.github.io/p/21631.html">https://whl963854.github.io/p/21631.html</a></p><p>有这么一张表：</p><pre><code>mysql&gt; CREATE TABLE `t` (`id` int(11) NOT NULL,`k` int(11) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2);</code></pre><p><img src="https://s1.ax1x.com/2023/07/07/pCcQu1e.png" alt="事务 A、B、C 的执行流程"></p><p>这里，我们需要注意的是事务的启动时机。</p><p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p><ul><li>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的；</li><li>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</li></ul><p>事务 C 没有显式地使用 begin&#x2F;commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p><p>这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？</p><p>这里，我们不妨做如下假设：</p><ul><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ul><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。<br>为了简化分析，先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p><p><img src="https://s1.ax1x.com/2023/07/07/pCc1cy4.png" alt="pCc1cy4.png"></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ul><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ul><p>现在，我们用这个规则来判断图中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li><li>(1,1) 是在视图数组创建之前提交的，可见。</li></ul><p>去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。<br>不过，更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</p><h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>在 MySQL 里，有两个“视图”的概念：</p><ul><li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p><p>这看上去不太现实。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，平时的事务执行起来很快啊。</p><p>实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p><p>如图 2 所示，就是一个记录被多个事务连续更新后的状态。</p><p><img src="https://s1.ax1x.com/2023/07/07/pCcQvDA.png" alt="pCcQvDA.png"></p><p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p><p>图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p>明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。<br>一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p><p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）</p><p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p><p><img src="https://s1.ax1x.com/2023/07/07/pCc1AJK.png" alt="pCc1AJK.png"></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><ul><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<ul><li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ul><p>我们继续看一下图 1 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k&#x3D;1。</p><p>这里，我们不妨做如下假设：</p><ul><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ul><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p><p><img src="https://s1.ax1x.com/2023/07/07/pCc1cy4.png" alt="pCc1cy4.png"></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><ul><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ul><p>现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li><li>(1,1) 是在视图数组创建之前提交的，可见。</li></ul><p>去掉数字对比后，只用时间先后顺序来判断，所以，后面我们就都用这个规则来分析。</p><p>事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？</p><p>如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。<br>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k&#x3D;k+1 是在（1,2）的基础上进行的操作。</p><p>这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</p><p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。<br>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。<br>这里我们提到了一个概念，叫作<strong>当前读</strong>。其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p><h2 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h2><h3 id="从应用开发端来看"><a href="#从应用开发端来看" class="headerlink" title="从应用开发端来看"></a>从应用开发端来看</h3><p>确认是否使用了 set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</p><p>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin&#x2F;commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</p><p>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</p><h3 id="从数据库端来看："><a href="#从数据库端来看：" class="headerlink" title="从数据库端来看："></a>从数据库端来看：</h3><p>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 &#x2F; 或者 kill；</p><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p><p>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</p><p>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务三种提交问题</title>
      <link href="/p/33810.html"/>
      <url>/p/33810.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务三种提交问题"><a href="#事务三种提交问题" class="headerlink" title="事务三种提交问题"></a>事务三种提交问题</h1><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B又用回滚把数据恢复成原来的值，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p><table><thead><tr><th>步骤</th><th>操作</th><th>余额变化</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td>N&#x2F;A</td><td></td></tr><tr><td>2</td><td>开始事务</td><td>N&#x2F;A</td><td></td></tr><tr><td>3</td><td>查询账户余额为2000元</td><td>N&#x2F;A</td><td></td></tr><tr><td>4</td><td>取款1000元</td><td>-1000元</td><td>余额变更为1000元</td></tr><tr><td>5</td><td>查询账户余额为1000元</td><td>N&#x2F;A</td><td>脏读产生，实际余额为未提交前的1000元</td></tr><tr><td>6</td><td>事务回滚</td><td>+1000元</td><td>余额变更为2000元</td></tr><tr><td>7</td><td>转入2000元</td><td>+2000元</td><td>脏读的1000元+2000元，余额变更为3000元</td></tr><tr><td>8</td><td>提交事务</td><td>N&#x2F;A</td><td>最终余额应该为4000元</td></tr></tbody></table><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。</p><p>这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。</p><table><thead><tr><th>时间顺序</th><th>事务</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>开始事务</td></tr><tr><td>2</td><td>A</td><td>第一次查询，小明的年龄为20岁</td></tr><tr><td>3</td><td>B</td><td>开始事务</td></tr><tr><td>4</td><td>B</td><td>其他操作</td></tr><tr><td>5</td><td>B</td><td>更改小明的年龄为30岁</td></tr><tr><td>6</td><td>B</td><td>提交事务</td></tr><tr><td>7</td><td>A</td><td>第二次查询，小明的年龄为30岁</td></tr></tbody></table><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。</p><p>幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。</p><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td></td><td>其他操作</td></tr><tr><td>5</td><td></td><td>新增100条数据</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，数据总量为200条</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据总量应该一致</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务隔离级别</title>
      <link href="/p/14751.html"/>
      <url>/p/14751.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ul><li>读未提交（READ UNCOMMITTED）在该隔离级别一个事务还没提交时，它做的变更就能被别的事务看到，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务提交之后，它做的变更才会被其他事务看到。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>可重复读 （REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>串行化 （SERIALIZABLE）“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><table><thead><tr><th>事务隔离级别</th><th>实现方式</th></tr></thead><tbody><tr><td>未提交读（RU）</td><td>事务对当前被读取的数据不加锁；事务在更新某数据瞬间，必须先加行级共享锁，直到事务结束才释放。</td></tr><tr><td>提交读（RC）</td><td>事务对当前被读取的数据加行级共享锁（读到时加锁），读完该行后立即释放该行级共享锁；事务在更新某数据瞬间，必须先加行级排他锁，直到事务结束才释放。</td></tr><tr><td>可重复读（RR）</td><td>事务在读取某数据的瞬间，必须先加行级共享锁，直到事务结束才释放；事务在更新某数据瞬间，必须先加行级排他锁，直到事务结束才释放。</td></tr><tr><td>序列化读（S）</td><td>事务在读取数据时，必须先加表级共享锁，直到事务结束才释放；事务在更新数据时，必须先加表级排他锁，直到事务结束才释放。</td></tr></tbody></table><p>只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。</p><h2 id="如何设置隔离级别"><a href="#如何设置隔离级别" class="headerlink" title="如何设置隔离级别"></a>如何设置隔离级别</h2><pre><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; 其中，隔离级别格式： &gt; READ UNCOMMITTED &gt; READ COMMITTED &gt; REPEATABLE READ &gt; SERIALIZABLE</code></pre><p>或者</p><pre><code>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#39;隔离级别&#39; #其中，隔离级别格式： &gt; READ-UNCOMMITTED &gt; READ-COMMITTED &gt; REPEATABLE-READ &gt; SERIALIZABLE</code></pre><p><a href="https://imgse.com/i/pp5CeWn"><img src="https://s1.ax1x.com/2023/04/04/pp5CeWn.md.png" alt="pp5CeWn.md.png"></a></p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。</p><p>我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p><p><a href="https://imgse.com/i/pp5C1wF"><img src="https://s1.ax1x.com/2023/04/04/pp5C1wF.md.png" alt="pp5C1wF.md.png"></a><br>按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。</p><p>快照，学名叫做一致性视图，这是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p><p>对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：</p><p>当前事务内的更新，可以读到；<br>版本未提交，不能读到；<br>版本已提交，但是却在快照创建后提交的，不能读到；<br>版本已提交，且是在快照创建前提交的，可以读到；<br>利用上面的规则，再返回去套用到读提交和可重复读的那两张图上就很清晰了。还是要强调，两者主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化</title>
      <link href="/p/1692.html"/>
      <url>/p/1692.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><strong>普通插入：</strong></p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p><strong>大批量插入：</strong><br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><p>客户端连接服务端时，加上参数 –local-infile（这一行在bash&#x2F;cmd界面输入）</p><pre><code>mysql --local-infile -u root -p</code></pre><p>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p><pre><code>set global local_infile = 1;select @@local_infile;</code></pre><p>执行load指令将准备好的数据，加载到表结构中</p><pre><code>load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></pre><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，默认为0.5，可以自己设置，在创建表或创建索引时指定</p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">详细内容参照黑马程序员数据库相关讲解</a></p><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号<ul><li>UUID:随机字符串（不重复）</li></ul></li><li>业务操作时，避免对主键的修改</li></ul><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为idx_user_pro_age_stat，则句式可以是select … where profession order by age，这样也符合最左前缀法则</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><p>– 此语句耗时很长</p><pre><code>select * from tb_sku limit 9000000, 10;</code></pre><p>– 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</p><pre><code>select id from tb_sku order by id limit 9000000, 10;</code></pre><p>– 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</p><pre><code>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</code></pre><p>– 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</p><pre><code>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</code></pre><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h2 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h2><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br>update student set no &#x3D; ‘123’ where id &#x3D; 1;，这句由于id有主键索引，所以只会锁这一行；<br>update student set no &#x3D; ‘123’ where name &#x3D; ‘test’;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树和B树的区别</title>
      <link href="/p/39914.html"/>
      <url>/p/39914.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎</title>
      <link href="/p/62812.html"/>
      <url>/p/62812.html</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:<br><img src="/p/62812.htm/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>行，InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：</p><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/p/62812.htm/InnoDB%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 </p><p><img src="/p/62812.htm/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg"></p><p>接下来介绍一下这四个部分。<br><strong>Buffer Pool</strong></p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。<br>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul><p>在专用服务器上，通常将多达 80 ％的物理内存分配给缓冲池 。<br>参数设置：     </p><pre><code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></pre><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ul><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li></ul><p>所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><p>**Change Buffer **</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：<br><img src="/p/62812.htm/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p><strong>Adaptive Hash Index</strong></p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<br>自适应哈希索引，无需人工干预，是系统根据情况自动完成。<br>参数： <code>adaptive_hash_index</code></p><p><strong>Log Buffer</strong></p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数:</p><pre><code>innodb_log_buffer_size：查看缓冲区大小innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：    0: 每秒将日志写入并刷新到磁盘一次。    1: 日志在每次事务提交时写入并刷新到磁盘，默认值1s。    2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</code></pre><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：<br><img src="/p/62812.htm/image"></p><p><strong>System Tablespace</strong></p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等，8.0后主要存储更改缓冲区的数据)</p><p>参数：<code>innodb_data_file_path</code></p><p>系统表空间，默认的文件名叫 <code>ibdata1</code></p><p><strong>File-Per-Table Tablespaces</strong></p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p><p><strong>General Tablespaces</strong></p><p>通用表空间，需要通过<code>CREATE TABLESPACE</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name;</code></pre><p><strong>Undo Tablespaces</strong></p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（undo_001,undo_002,初始大小16M），用于存储undo log日志。</p><p><strong>Temporary Tablespaces</strong></p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p><strong>Doublewrite Buffer Files</strong></p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><strong>Redo Log</strong></p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：</p><pre><code>ib_logfile0ib_logfile1</code></pre><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><h4 id="线程类型-默认个数-职责"><a href="#线程类型-默认个数-职责" class="headerlink" title="线程类型 默认个数 职责"></a>线程类型 默认个数 职责</h4><p>在InnoDB的后台线程中，分为 4 类，分别是：Master Thread 、IO Thread、Purge Thread、<br>Page Cleaner Thread。</p><p><strong>Master Thread</strong></p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p><strong>IO Thread</strong></p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。<br>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p><pre><code>Read thread 负责读操作Write thread 负责写操作Log thread 负责将日志缓冲区刷新到磁盘Insert buffer thread 负责将写缓冲区内容刷新到磁盘</code></pre><p><strong>Purge Thread</strong></p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><p><strong>Page Cleaner Thread</strong></p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h3><p><strong>事务</strong></p><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>特性</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p>而对于这四大特性，实际上分为两个部分。 </p><ul><li>其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 </li><li>而持久性是通过数据库的锁，加上MVCC来保证的。</li></ul><p>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：</p><ul><li>重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo logfile）</li></ul><p>前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中<br>的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却<br>没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</p><p><img src="/p/62812.htm/redolog.jpg"></p><p>有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo  log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment<br>回滚段中，内部包含 1024 个undo log segment。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>当前读</strong></p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</p><p>?测试：</p><h4 id="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"><a href="#在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内" class="headerlink" title="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"></a>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内</h4><p>容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们<br>加排他锁的时候，也是当前读操作。</p><h4 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2). 快照读"></a>2). 快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，<br>不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h4><h4 id="隐藏字段-含义"><a href="#隐藏字段-含义" class="headerlink" title="隐藏字段 含义"></a>隐藏字段 含义</h4><h4 id="DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"><a href="#DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。" class="headerlink" title="DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"></a>DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</h4><h4 id="DB-ROLL-PTR"><a href="#DB-ROLL-PTR" class="headerlink" title="DB_ROLL_PTR"></a>DB_ROLL_PTR</h4><p>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版<br>本。<br>DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。<br>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照<br>读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同<br>的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h4 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3). MVCC"></a>3). MVCC</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，<br>使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需<br>要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从<br>而来介绍一下MVCC的原理。</p><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><pre><code>DB_TRX_IDDB_ROLL_PTRDB_ROW_ID</code></pre><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>1). 查看有主键的表 stu</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令:</p><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID<br>隐藏字段。</p><p>1 ibd2sdi stu.ibd</p><p>2). 查看没有主键的表 employee</p><p>建表语句：</p><p>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</p><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有<br>指定主键的。</p><pre><code>create table employee (id int , name varchar( 10 ));ibd2sdi employee.ibd</code></pre><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即<br>被删除。</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><h4 id="有一张表原始数据为："><a href="#有一张表原始数据为：" class="headerlink" title="有一张表原始数据为："></a>有一张表原始数据为：</h4><h4 id="DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"><a href="#DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是" class="headerlink" title="DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"></a>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是</h4><h4 id="自增的。"><a href="#自增的。" class="headerlink" title="自增的。"></a>自增的。</h4><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><h4 id="然后，有四个并发事务同时在访问这张表。"><a href="#然后，有四个并发事务同时在访问这张表。" class="headerlink" title="然后，有四个并发事务同时在访问这张表。"></a>然后，有四个并发事务同时在访问这张表。</h4><h4 id="A-第一步"><a href="#A-第一步" class="headerlink" title="A. 第一步"></a>A. 第一步</h4><p>当事务 2 执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="B-第二步"><a href="#B-第二步" class="headerlink" title="B.第二步"></a>B.第二步</h4><p>当事务 3 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="C-第三步"><a href="#C-第三步" class="headerlink" title="C. 第三步"></a>C. 第三步</h4><p>当事务 4 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条<br>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><h4 id="字段-含义"><a href="#字段-含义" class="headerlink" title="字段 含义"></a>字段 含义</h4><p>m_ids 当前活跃的事务ID集合<br>min_trx_id 最小活跃事务ID<br>max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）<br>creator_trx_id ReadView创建者的事务ID</p><h4 id="条件-是否可以访问-说明"><a href="#条件-是否可以访问-说明" class="headerlink" title="条件 是否可以访问 说明"></a>条件 是否可以访问 说明</h4><p>trx_id &#x3D;&#x3D;<br>creator_trx_id 可以访问该版本</p><h4 id="成立，说明数据是当前这个事"><a href="#成立，说明数据是当前这个事" class="headerlink" title="成立，说明数据是当前这个事"></a>成立，说明数据是当前这个事</h4><h4 id="务更改的。"><a href="#务更改的。" class="headerlink" title="务更改的。"></a>务更改的。</h4><p>trx_id &lt; min_trx_id 可以访问该版本 成立，说明数据已经提交了。<br>trx_id &gt; max_trx_id 不可以访问该版本 成立，说明该事务是在<br>ReadView生成后才开启。<br>min_trx_id &lt;&#x3D; trx_id<br>&lt;&#x3D; max_trx_id<br>如果trx_id不在m_ids中，<br>是可以访问该版本的 成立，说明数据已经提交。<br>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务<br>（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><p>不同的隔离级别，生成ReadView的时机不同：</p><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。<br>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h4><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p><h4 id="我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的"><a href="#我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的" class="headerlink" title="我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?"></a>我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?</h4><p>在事务 5 中，查询了两次id为 30 的记录，由于隔离级别为Read Committed，所以每一次进行快照读<br>都会生成一个ReadView，那么两次生成的ReadView如下。</p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，<br>到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><h4 id="A-先来看第一次快照读具体的读取过程："><a href="#A-先来看第一次快照读具体的读取过程：" class="headerlink" title="A. 先来看第一次快照读具体的读取过程："></a>A. 先来看第一次快照读具体的读取过程：</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的"><a href="#先匹配-这条记录，这条记录对应的" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也<br>不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p><h4 id="再匹配第三条-，这条记"><a href="#再匹配第三条-，这条记" class="headerlink" title="再匹配第三条 ，这条记"></a>再匹配第三条 ，这条记</h4><p>录对应的trx_id为 2 ，也就是将 2 带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照<br>读，返回的数据就是版本链中记录的这条数据。</p><h4 id="B-再来看第二次快照读具体的读取过程"><a href="#B-再来看第二次快照读具体的读取过程" class="headerlink" title="B. 再来看第二次快照读具体的读取过程:"></a>B. 再来看第二次快照读具体的读取过程:</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的-1"><a href="#先匹配-这条记录，这条记录对应的-1" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次<br>快照读，返回的数据就是版本链中记录的这条数据。</p><h4 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可<br>重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该<br>ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返<br>回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。<br>而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/p/df9a61f7.html"/>
      <url>/p/df9a61f7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql基础架构"><a href="#Mysql基础架构" class="headerlink" title="Mysql基础架构"></a>Mysql基础架构</h1><p>下面是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。<br><a href="https://s1.ax1x.com/2023/07/07/pCcieKO.png">pCcieKO.png</a></p><p>MySQL 可以分为 Server 层和存储引擎层两部分。</p><ul><li>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li><li>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</li></ul><p>不同的存储引擎共用一个Server 层</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><pre><code>mysql -h$ip -P$port -u$user -p</code></pre><p>输完命令之后，就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致密码泄露。如果是生产服务器，强烈建议不要这么做。(会丢掉工作)</p><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。<br>建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ul><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。<br>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能结果存起来还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><pre><code>mysql&gt; select SQL_CACHE * from T where ID=10；</code></pre><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><pre><code>mysql&gt; elect * from t where ID=1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID=1&#39; at line 1</code></pre><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><pre><code>mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</code></pre><ul><li>既可以先从表 t1 里面取出 c&#x3D;10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d&#x3D;20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限。</p><pre><code>mysql&gt; select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</code></pre><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ul><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>在数据库的慢查询日志中可以看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应急提高性能的方法</title>
      <link href="/p/294fcea.html"/>
      <url>/p/294fcea.html</url>
      
        <content type="html"><![CDATA[<h1 id="“饮鸩止渴”提高性能的方法"><a href="#“饮鸩止渴”提高性能的方法" class="headerlink" title="“饮鸩止渴”提高性能的方法"></a>“饮鸩止渴”提高性能的方法</h1><h2 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h2><p>正常的短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。<br>MySQL 建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。在数据库压力比较小的时候，这些额外的成本并不明显。但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。max_connections 参数，用来控制一个 MySQL 实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。</p><p>在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过 max_connections 的限制。碰到这种情况时，一个比较自然的想法，就是调高 max_connections 的值。但这样做是有风险的。因为设计 max_connections 这个参数的目的是想保护 MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到 CPU 资源去执行业务的 SQL 请求。</p><p>有两种方法，但要注意，这些方法都是有损的。</p><p><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></p><p>max_connections 的计算，不是看谁在 running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，我们可以通过 kill connection 主动踢掉。这个行为跟事先设置 wait_timeout 的效果是一样的。设置 wait_timeout 参数表示的是，一个线程空闲 wait_timeout 这么多秒之后，就会被 MySQL 直接断开连接。但是需要注意，在 show processlist 的结果里，踢掉显示为 sleep 的线程，可能是有损的。我们来看下面这个例子。</p><p><img src="https://s1.ax1x.com/2023/07/07/pCcdY4J.png" alt="pCcdY4J.png"></p><p>在上面这个例子里，如果断开 session A 的连接，因为这时候 session A 还没有提交，所以 MySQL 只能按照回滚事务来处理；而断开 session B 的连接，就没什么大影响。所以，如果按照优先级来说，你应该优先断开像 session B 这样的事务外空闲的连接。</p><p>要看事务具体状态的话，你可以查 information_schema 库的 innodb_trx 表。<br>如果是连接数过多，可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p><p>从服务端断开连接使用的是 kill connection + id 的命令， 一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL 一直没恢复”。</p><p>所以，如果你是一个支持业务的 DBA，不要假设所有的应用代码都会被正确地处理。即使只是一个断开连接的操作，也要确保通知到业务开发团队。</p><p><strong>第二种方法：减少连接过程的消耗。</strong></p><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p><p>跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables 参数启动。这样，整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p><p>但是，这种方法风险极高，是我特别不建议使用的方案。尤其你的库外网可访问的话，就更不能这么做了。</p><p>在 MySQL 8.0 版本里，如果你启用–skip-grant-tables 参数，MySQL 会默认把 –skip-networking 参数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL 官方对 skip-grant-tables 这个参数的安全问题也很重视。</p><p>除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是由 QPS（每秒查询数）突增导致的。</p><h2 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h2><p>在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：</p><ul><li>索引没有设计好；</li><li>SQL 语句没写好；</li><li>MySQL 选错了索引。</li></ul><p>接下来，我们就具体分析一下这三种可能，以及对应的解决方案。<br>导致慢查询的第一种可能是，索引没有设计好。</p><p>这种场景一般就是通过紧急创建索引来解决。MySQL 5.6 版本以后，创建索引都支持 Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行 alter table 语句。</p><p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库 A、备库 B，这个方案的大致流程是这样的：</p><p>在备库 B 上执行 set sql_log_bin&#x3D;off，也就是不写 binlog，然后执行 alter table 语句加上索引；</p><p>执行主备切换；</p><p>这时候主库是 B，备库是 A。在 A 上执行 set sql_log_bin&#x3D;off，然后执行 alter table 语句加上索引。</p><p>这是一个“古老”的 DDL 方案。平时在做变更的时候，你应该考虑类似 gh-ost 这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的</p><p>导致慢查询的第二种可能是，语句没写好。<br>比如语句没有使用上索引,我们可以通过改写 SQL 语句来处理。MySQL 5.7 提供了 query_rewrite 功能，可以把输入的一种语句改写成另外一种模式。</p><p>比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，可以通过下面的方式，增加一个语句改写规则。</p><pre><code>mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);call query_rewrite.flush_rewrite_rules();</code></pre><p>这里，call query_rewrite.flush_rewrite_rules() 这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。</p><p>导致慢查询的第三种可能，就是MySQL 选错了索引。<br>这时候，应急方案就是给这个语句加上 force index。</p><p>同样地，使用查询重写功能，给原来的语句加上 force index，也可以解决这个问题。</p><h2 id="QPS-突增问题"><a href="#QPS-突增问题" class="headerlink" title="QPS 突增问题"></a>QPS 突增问题</h2><p>有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。</p><ul><li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成”select 1”返回。<ul><li>这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</li><li>如果别的功能里面也用到了这个 SQL 语句模板，会有误伤；</li><li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以 select 1 的结果返回的话，可能会导致后面的业务逻辑一起失败。</li></ul></li></ul><p>方案 1 和 2 都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。方案 3 是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主备</title>
      <link href="/p/c04d0f5c.html"/>
      <url>/p/c04d0f5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h1><p>MySQL 是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖于 binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>下图所示就是基本的主备切换流程。</p><p><img src="https://s1.ax1x.com/2023/07/11/pCWwjyj.png" alt="pCWwjyj.png"></p><p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</p><p>当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p><p>在状态 1 中，虽然节点 B 没有被直接访问，但是依然建议你把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p><ul><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li><li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li><li>可以用 readonly 状态，来判断节点的角色。</li></ul><p>我把备库设置成只读了，还怎么跟主库保持同步更新呢？<br>这个问题不用担心。因为 readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p><p><img src="https://s1.ax1x.com/2023/07/11/pCWgImD.png" alt="pCWgImD.png"></p><p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。</p><p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p><ul><li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li><li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li><li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li><li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li></ul><p>由于多线程复制方案的引入，sql_thread 演化成为了多个线程</p><h2 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h2><p>binlog 有3种格式，一种是 statement，一种是 row。第三种格式叫作 mixed，</p><ul><li>Statement（Statement-Based Replication,SBR）：每一条会修改数据的 SQL 都会记录在binlog中。</li><li>Row（Row-Based Replication,RBR）：不记录 SQL 语句上下文信息，仅保存哪条记录被修改。</li><li>Mixed（Mixed-Based Replication,MBR）：Statement 和 Row 的混合体。</li></ul><p>log_bin &#x3D; on 时，代表 binlog 开启。</p><pre><code>show variables like &#39;log_bin&#39;</code></pre><p>为了便于描述 binlog 的这三种格式间的区别，先创建了一个表，并初始化几行数据。</p><pre><code>mysql&gt; CREATE TABLE `t` (`id` int(11) NOT NULL,`a` int(11) DEFAULT NULL,`t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (`id`),KEY `a` (`a`),KEY `t_modified`(`t_modified`)) ENGINE=InnoDB;insert into t values(1,1,&#39;2018-11-13&#39;);insert into t values(2,2,&#39;2018-11-12&#39;);insert into t values(3,3,&#39;2018-11-11&#39;);insert into t values(4,4,&#39;2018-11-10&#39;);insert into t values(5,5,&#39;2018-11-09&#39;);</code></pre><p>如果要在表中删除一行数据的话，我们来看看这个 delete 语句的 binlog 是怎么记录的。<br>下面这个语句包含注释，用 MySQL 客户端来做这个实验的话，要记得加 -c 参数，否则客户端会自动去掉注释。</p><pre><code>mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#39;2018-11-10&#39; limit 1;</code></pre><p>当 binlog_format&#x3D;statement 时，binlog 里面记录的就是 SQL 语句的原文。你可以用</p><pre><code>mysql&gt; show binlog events in &#39;master.000001&#39;;</code></pre><p>命令看 binlog 中的内容。</p><p><img src="https://s1.ax1x.com/2023/07/11/pCW2rgP.png" alt="pCW2rgP.png"></p><ul><li>第一行 SET @@SESSION.GTID_NEXT&#x3D;’ANONYMOUS’主备切换相关；</li><li>第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务；</li><li>第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。use ‘test’命令之后的 delete 语句，就是我们输入的 SQL 原文了。可以看到，binlog“忠实”地记录了 SQL 命令，甚至连注释也一并记录了。</li><li>最后一行是一个 COMMIT。里面写着 xid&#x3D;61。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些优化方面</title>
      <link href="/p/305947d.html"/>
      <url>/p/305947d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一些优化方面"><a href="#一些优化方面" class="headerlink" title="一些优化方面"></a>一些优化方面</h1><h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p>假设维护一个交易系统，其中交易记录表 tradelog 包含交易流水号（tradeid）、交易员 id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：</p><pre><code>mysql&gt; CREATE TABLE `tradelog` (`id` int(11) NOT NULL,`tradeid` varchar(32) DEFAULT NULL,`operator` int(11) DEFAULT NULL,`t_modified` datetime DEFAULT NULL,PRIMARY KEY (`id`),KEY `tradeid` (`tradeid`),KEY `t_modified` (`t_modified`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></pre><p>假设，现在已经记录了从 2016 年初到 2018 年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中 7 月份的交易记录总数。这个逻辑看上去并不复杂，你的 SQL 语句可能会这么写：</p><pre><code>select count(*) from tradelog where month(t_modified)=7;</code></pre><p>由于 t_modified 字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了特别久，才返回了结果。</p><p>如果你问 DBA 同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。</p><p>现在你已经学过了 InnoDB 的索引结构了，可以再追问一句为什么？为什么条件是 where t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成 where month(t_modified)&#x3D;7 的时候就不行了？</p><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>由于在 t_modified 字段加了 month() 函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把 SQL 语句改成基于字段本身的范围查询。按照下面这个写法，优化器就能按照我们预期的，用上 t_modified 索引的快速定位能力了。</p><pre><code>mysql&gt; select count(*) from tradelog where    -&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or    -&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or     -&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);</code></pre><p>但是如果你的系统后面又插入了之后年份的数据的话，你就需要再把其他年份补齐。</p><p>优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 select * from tradelog where id + 1 &#x3D; 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 where id &#x3D; 10000 -1 才可以。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>我们一起看一下这条 SQL 语句：</p><pre><code>mysql&gt; select * from tradelog where tradeid=110717;</code></pre><p>交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需要走全表扫描。tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p><p>那么，现在这里就有两个问题：</p><ul><li>数据类型转换的规则是什么？</li><li>为什么有数据类型转换，就需要走全索引扫描？</li></ul><p>在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。<br>这时，你再看这个全表扫描的语句：</p><pre><code>mysql&gt; select * from tradelog where tradeid=110717;</code></pre><p>就知道对于优化器来说，这个语句相当于：</p><pre><code>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</code></pre><p>对索引字段做函数操作，优化器会放弃走树搜索功能。</p><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设系统里还有另外一个表 trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，我往交易日志表 tradelog 和交易详情表 trade_detail 这两个表里插入一些数据。</p><pre><code>mysql&gt; CREATE TABLE `trade_detail` (`id` int(11) NOT NULL,`tradeid` varchar(32) DEFAULT NULL,`trade_step` int(11) DEFAULT NULL, /* 操作步骤 */`step_info` varchar(32) DEFAULT NULL, /* 步骤信息 */PRIMARY KEY (`id`),KEY `tradeid` (`tradeid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into tradelog values(1, &#39;aaaaaaaa&#39;, 1000, now());insert into tradelog values(2, &#39;aaaaaaab&#39;, 1000, now());insert into tradelog values(3, &#39;aaaaaaac&#39;, 1000, now());insert into trade_detail values(1, &#39;aaaaaaaa&#39;, 1, &#39;add&#39;);insert into trade_detail values(2, &#39;aaaaaaaa&#39;, 2, &#39;update&#39;);insert into trade_detail values(3, &#39;aaaaaaaa&#39;, 3, &#39;commit&#39;);insert into trade_detail values(4, &#39;aaaaaaab&#39;, 1, &#39;add&#39;);insert into trade_detail values(5, &#39;aaaaaaab&#39;, 2, &#39;update&#39;);insert into trade_detail values(6, &#39;aaaaaaab&#39;, 3, &#39;update again&#39;);insert into trade_detail values(7, &#39;aaaaaaab&#39;, 4, &#39;commit&#39;);insert into trade_detail values(8, &#39;aaaaaaac&#39;, 1, &#39;add&#39;);insert into trade_detail values(9, &#39;aaaaaaac&#39;, 2, &#39;update&#39;);insert into trade_detail values(10, &#39;aaaaaaac&#39;, 3, &#39;update again&#39;);insert into trade_detail values(11, &#39;aaaaaaac&#39;, 4, &#39;commit&#39;);</code></pre><p>如果要查询 id&#x3D;2 的交易的所有操作步骤信息，SQL 语句可以这么写：</p><pre><code>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /* 语句 Q1*/</code></pre><p>优化器会先在交易记录表 tradelog 上查到 id&#x3D;2 的行，这个步骤用上了主键索引，rows&#x3D;1 表示只扫描一行；<br>但是没有用上交易详情表 trade_detail 上的 tradeid 索引，进行了全表扫描。</p><p>在这个执行计划里，是从 tradelog 表中取 tradeid 字段，再去 trade_detail 表里查询匹配字段。因此，我们把 tradelog 称为驱动表，把 trade_detail 称为被驱动表，把 tradeid 称为关联字段。</p><p>这个运行结果可以分三步，</p><ul><li>第 1 步，是根据 id 在 tradelog 表里找到 L2 这一行；</li><li>第 2 步，是从 L2 中取出 tradeid 字段的值；</li><li>第 3 步，是根据 tradeid 值到 trade_detail 表中查找条件匹配的行。</li></ul><p>因为表 trade_detail 里 tradeid 字段上是有索引的，我们本来是希望通过使用 tradeid 索引能够快速定位到等值的行。但，这里并没有。因为这两个表的字符集不同，一个是 utf8，一个是 utf8mb4，所以做表连接查询的时候用不上关联字段的索引。<br>问题是出在执行步骤的第 3 步，如果单独把这一步改成 SQL 语句的话，那就是</p><pre><code>mysql&gt; select * from trade_detail where tradeid=$L2.tradeid.value; </code></pre><p>其中，$L2.tradeid.value 的字符集是 utf8mb4。</p><p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p><p>这个设定很好理解，utf8mb4 是 utf8 的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。<br>在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成 utf8mb4，再跟 L2 做比较。</p><p>也就是说，实际上这个语句等同于下面这个写法：</p><pre><code>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </code></pre><p>CONVERT() 函数，在这里的意思是把输入的字符串转成 utf8mb4 字符集。</p><p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p>如果要优化语句的执行过程，有两种做法：</p><ul><li>比较常见的优化方法是，把 trade_detail 表上的 tradeid 字段的字符集也改成 utf8mb4，这样就没有字符集转换的问题了。<ul><li>alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</li></ul></li><li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不能做这个 DDL 的话，那就只能采用修改 SQL 语句的方法了。<ul><li>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid&#x3D;CONVERT(l.tradeid USING utf8) and l.id&#x3D;2;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接编译联编</title>
      <link href="/p/43574.html"/>
      <url>/p/43574.html</url>
      
        <content type="html"><![CDATA[<h2 id="链接编译联编"><a href="#链接编译联编" class="headerlink" title="链接编译联编"></a>链接编译联编</h2><h3 id="1-动态编译与静态编译"><a href="#1-动态编译与静态编译" class="headerlink" title="1.动态编译与静态编译"></a>1.动态编译与静态编译</h3><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；</p><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库， 则⽤动态编译的可执⾏⽂件就不能运⾏。</p><h3 id="2-动态链接和静态链接区别"><a href="#2-动态链接和静态链接区别" class="headerlink" title="2.动态链接和静态链接区别"></a>2.动态链接和静态链接区别</h3><p><strong>静态连接库</strong>就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；<br><strong>动态链接</strong>就是把调⽤的函数所在⽂件模块(DLL)和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候 再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。</p><p><strong>静态连接库</strong>与<strong>动态链接库</strong>都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib中的指令都全部被直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。<br><strong>静态连接库</strong>和<strong>动态链接库</strong>的另外⼀个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。<br><strong>动态库</strong>就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对lib⽂件中同⼀个函数的调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。</p><h3 id="3-动态联编与静态联编"><a href="#3-动态联编与静态联编" class="headerlink" title="3.动态联编与静态联编"></a>3.动态联编与静态联编</h3><p>在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编和动态联编；<br><strong>静态联编</strong>是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成⼜称为早期联编。要实现静态 联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束 定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差。<br><strong>动态联编</strong>是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数 的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象 类型将做出不同的编译结果。C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类 的指针变量名-&gt;虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）</p><h4 id="实现动态联编三个条件："><a href="#实现动态联编三个条件：" class="headerlink" title="实现动态联编三个条件："></a>实现动态联编三个条件：</h4><p>1.必须把动态联编的⾏为定义为类的虚函数；<br>2.类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；<br>3.必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； </p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数表</title>
      <link href="/p/14976.html"/>
      <url>/p/14976.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的实现效果：多态实现了同样的调用语句具有不同的表现形态。<br>多态成立的三个条件：继承、虚函数重写、父类指针指向子类对象。<br>多态的C++实现方法：virtual关键字，告诉编译器要执行多态；不要根据指针类型来判断如何调用对应的函数，而是要根据指针所实际指向的对象的类型来判断如何调用。<br>多态的理论基础：动态联编（if、switch、多态）、静态联编、根据指针实际指向的对象的类型来判断重写函数的调用。<br>多态的重要意义：多态是设计模式的基础。<br>实现多态的理论基础：函数指针做函数参数。</p><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表</p><ol><li>当在类中声明虚函数时，编译器会在类中生成一个虚函数表；</li><li>虚函数表是一个存储类成员函数指针的数据结构；</li><li>虚函数表由编译器自动生成与维护；</li><li>带有virtual关键字的虚函数会被编译器放入到虚函数表中；</li><li>当类族中存在虚函数时，类族定义的每一个对象都有一个指向虚函数表的指针（VPTR指针）。</li></ol><p>利用VPTR指针，C++编译器根据父类指针实际指向的对象的类型，转到该对象的虚函数表中，去查找相应的虚函数进行执行，从而实现了多态。</p><p>编译时的多态（静态多态）是在静态联编阶段，通过函数重载和模板实现的。利用函数重载机制，在调用同名函数时，编译器会根据实参的具体情况确定要调用的是哪个函数。<br>运行时的多态（动态多态）是用动态联编阶段，通过虚函数来实现。动态多态使用的两个条件：</p><ol><li>类的定义时存在继承关系，存在虚机制，派生类重写虚函数</li><li>隐式向上强制转换使基类指针或引用可以指向基类对象或者派生类对象，这里需要动态联编，在运行时，根据不同的环境，产生不同的行为。</li></ol><p>析构函数可以写成虚的，但是构造函数不行。</p><p>虚函数是通过一种特殊的功能来实现的，它储存在类所在的内存空间中，构造函数一般用于申请内存，那连内存都没有，怎么能找到这种特殊的功能呢？所以构造函数不能是虚的。</p><h2 id="什么是虚函数表？"><a href="#什么是虚函数表？" class="headerlink" title="什么是虚函数表？"></a>什么是虚函数表？</h2><p>对于一个类来说，如果类中存在虚函数，那么该类的大小就会多4个字节，然而这4个字节就是一个指针的大小，这个指针指向虚函数表。所以，如果对象存在虚函数，那么编译器就会生成一个指向虚函数表的指针，所有的虚函数都存在于这个表中，虚函数表就可以理解为一个数组，每个单元用来存放虚函数的地址。</p><p>虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。</p><p>C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置，这样通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p><pre><code>#include &lt;iostream&gt;using namespace std;class Base &#123;public:    virtual void f() &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;    virtual void g() &#123; cout &lt;&lt; &quot;g()&quot; &lt;&lt; endl; &#125;    virtual void h() &#123; cout &lt;&lt; &quot;h()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123;    Base t;    (     ((void(*)())*((int*)(*((int*)&amp;t)) + 0))   )     ();    (     ((void(*)())*((int*)(*((int*)&amp;t)) + 1))   )     ();    (  ((void(*)())*((int*)(*((int*)&amp;t)) + 2)))     ();    return 0;&#125;</code></pre><p>输出结果：</p><pre><code>f()g()h()</code></pre><p><img src="https://s1.ax1x.com/2023/07/26/pCjxjeO.png" alt="pCjxjeO.png"></p><h3 id="单继承下的虚函数表"><a href="#单继承下的虚函数表" class="headerlink" title="单继承下的虚函数表"></a>单继承下的虚函数表</h3><h4 id="派生类未覆盖基类虚函数"><a href="#派生类未覆盖基类虚函数" class="headerlink" title="派生类未覆盖基类虚函数"></a>派生类未覆盖基类虚函数</h4><p>下面我们来看下派生类没有覆盖基类虚函数的情况。从图中可看出虚函数表中依照声明顺序先放基类的虚函数地址，再放派生类的虚函数地址。</p><pre><code>#include &lt;iostream&gt;using namespace std;class Base &#123;public:    virtual void f() &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;    virtual void g() &#123; cout &lt;&lt; &quot;g()&quot; &lt;&lt; endl; &#125;    virtual void h() &#123; cout &lt;&lt; &quot;h()&quot; &lt;&lt; endl; &#125;&#125;;class Devired :public Base&#123;public:    virtual void x() &#123; cout &lt;&lt; &quot;x()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123;    Devired t;    (((void(*)())   *((int*)(*((int*)&amp;t)))))   ();    (((void(*)())*((int*)(*((int*)&amp;t)) + 1)))     ();    (((void(*)())*((int*)(*((int*)&amp;t)) + 2)))     ();    //(((void(*)())*((int*)(*((int*)&amp;t)) + 3)))     ();    return 0;&#125;</code></pre><p>输出结果：</p><pre><code>f()g()h()</code></pre><p><img src="https://s1.ax1x.com/2023/07/26/pCjzTHS.png" alt="pCjzTHS.png"></p><ul><li>虚函数按照其声明顺序放于表中。</li><li>父类的虚函数在子类的虚函数前面。</li></ul><h4 id="派生类覆盖基类虚函数"><a href="#派生类覆盖基类虚函数" class="headerlink" title="派生类覆盖基类虚函数"></a>派生类覆盖基类虚函数</h4><pre><code>#include &lt;iostream&gt;using namespace std;class Base &#123;public:    virtual void f() &#123; cout &lt;&lt; &quot;f()&quot; &lt;&lt; endl; &#125;    virtual void g() &#123; cout &lt;&lt; &quot;g()&quot; &lt;&lt; endl; &#125;    virtual void h() &#123; cout &lt;&lt; &quot;h()&quot; &lt;&lt; endl; &#125;&#125;;class Derive :public Base&#123;public:    virtual void x() &#123; cout &lt;&lt; &quot;x()&quot; &lt;&lt; endl; &#125;    virtual void f() &#123; cout &lt;&lt; &quot;Derive::f()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123;    Derive t;    (((void(*)())   *((int*)(*((int*)&amp;t)))))   ();    (((void(*)())*((int*)(*((int*)&amp;t)) + 1)))     ();    (((void(*)())*((int*)(*((int*)&amp;t)) + 2)))     ();    //(((void(*)())*((int*)(*((int*)&amp;t)) + 3)))     ();    return 0;&#125;</code></pre><ul><li>虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置 （显然的，不然虚函数失去意义）</li><li>派生类没有覆盖的虚函数延用基类的</li></ul><h2 id="多继承下的虚函数表"><a href="#多继承下的虚函数表" class="headerlink" title="多继承下的虚函数表"></a>多继承下的虚函数表</h2><h3 id="无虚函数覆盖"><a href="#无虚函数覆盖" class="headerlink" title="无虚函数覆盖"></a>无虚函数覆盖</h3><pre><code>#include &lt;iostream&gt;class Base&#123;public:    Base(int mem1 = 1, int mem2 = 2) : m_iMem1(mem1), m_iMem2(mem2) &#123; ; &#125;    virtual void vfunc1() &#123; std::cout &lt;&lt; &quot;In vfunc1()&quot; &lt;&lt; std::endl; &#125;    virtual void vfunc2() &#123; std::cout &lt;&lt; &quot;In vfunc2()&quot; &lt;&lt; std::endl; &#125;    virtual void vfunc3() &#123; std::cout &lt;&lt; &quot;In vfunc3()&quot; &lt;&lt; std::endl; &#125;private:    int m_iMem1;    int m_iMem2;&#125;;class Base2&#123;public:    Base2(int mem = 3) : m_iBase2Mem(mem) &#123; ; &#125;    virtual void vBase2func1() &#123; std::cout &lt;&lt; &quot;In Base2 vfunc1()&quot; &lt;&lt; std::endl; &#125;    virtual void vBase2func2() &#123; std::cout &lt;&lt; &quot;In Base2 vfunc2()&quot; &lt;&lt; std::endl; &#125;private:    int m_iBase2Mem;&#125;;class Base3&#123;public:    Base3(int mem = 4) : m_iBase3Mem(mem) &#123; ; &#125;    virtual void vBase3func1() &#123; std::cout &lt;&lt; &quot;In Base3 vfunc1()&quot; &lt;&lt; std::endl; &#125;    virtual void vBase3func2() &#123; std::cout &lt;&lt; &quot;In Base3 vfunc2()&quot; &lt;&lt; std::endl; &#125;private:    int m_iBase3Mem;&#125;;class Devired : public Base, public Base2, public Base3&#123;public:    Devired(int mem = 7) : m_iMem1(mem) &#123; ; &#125;    virtual void vdfunc1() &#123; std::cout &lt;&lt; &quot;In Devired vdfunc1()&quot; &lt;&lt; std::endl; &#125;private:    int m_iMem1;&#125;;int main()&#123;    // Test_3    Devired d;    int *dAddress = (int*)&amp;d;    typedef void(*FUNC)();    /* 1. 获取对象的内存布局信息 */    // 虚表地址一    int *vtptr1 = (int*)*(dAddress + 0);    int basemem1 = (int)*(dAddress + 1);    int basemem2 = (int)*(dAddress + 2);    int *vtpttr2 = (int*)*(dAddress + 3);    int base2mem = (int)*(dAddress + 4);    int *vtptr3 = (int*)*(dAddress + 5);    int base3mem = (int)*(dAddress + 6);    /* 2. 输出对象的内存布局信息 */    int *pBaseFunc1 = (int *)*(vtptr1 + 0);    int *pBaseFunc2 = (int *)*(vtptr1 + 1);    int *pBaseFunc3 = (int *)*(vtptr1 + 2);    int *pBaseFunc4 = (int *)*(vtptr1 + 3);    (FUNC(pBaseFunc1))();    (FUNC(pBaseFunc2))();    (FUNC(pBaseFunc3))();    (FUNC(pBaseFunc4))();    // .... 后面省略若干输出内容，可自行补充    return 0;&#125;</code></pre><p>如果是多重继承的话，问题就变得稍微复杂一丢丢，主要有几点：</p><ul><li>每个基类都有自己的虚函数表</li><li>派生类的虚函数地址存依照声明顺序放在第一个基类的虚表最后（这点和单继承无虚函数覆盖相同）</li></ul><p><img src="https://s1.ax1x.com/2023/07/26/pCvpMLV.md.png" alt="pCvpMLV.md.png"></p><h3 id="派生类覆盖基类虚函数-1"><a href="#派生类覆盖基类虚函数-1" class="headerlink" title="派生类覆盖基类虚函数"></a>派生类覆盖基类虚函数</h3><p>我们再来看一下派生类覆盖了基类的虚函数的情形</p><ul><li>虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置</li><li>派生类没有覆盖的虚函数延用基类的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单继承</p><ul><li>虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置</li><li>派生类没有覆盖的虚函数就延用基类的。同时，虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面。</li></ul><p>多继承</p><ul><li>每个基类都有自己的虚函数表</li><li>派生类的虚函数地址存依照声明顺序放在第一个基类的虚表最后</li></ul><p>安全性问题<br>当我们直接通过父类指针调用子类中的未覆盖父类的成员函数，编译器会报错，但通过实验，我们可以用对象的地址访问到各个子类的成员函数，就违背了C++语义，操作会有一定的隐患，当我们使用时要注意这些危险的东西！</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谓词</title>
      <link href="/p/5958.html"/>
      <url>/p/5958.html</url>
      
        <content type="html"><![CDATA[<h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><ul><li>返回bool类型的仿函数称为谓词</li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul><li>重载函数调用操作符的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><h2 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h2><ul><li>一个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123;    bool operator()(int val) &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;    else &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h2><ul><li>两个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public:    bool operator()(int num1, int num2)    &#123;        return num1 &gt; num2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 40 );    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 50 );    sort(v.begin(), v.end());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;    //使用函数对象改变算法策略，排序从大到小    sort(v.begin(), v.end(), MyCompare());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金山训练营第一周</title>
      <link href="/p/23999.html"/>
      <url>/p/23999.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于C-编程的四大分类（结合Effective-C-的理解）"><a href="#关于C-编程的四大分类（结合Effective-C-的理解）" class="headerlink" title="关于C++编程的四大分类（结合Effective C++的理解）"></a>关于C++编程的四大分类（结合Effective C++的理解）</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>​C++仍然是以C为基础。区块，语句，预处理器，内置数据类型，数组及其指针都来源于C，在大多数的时候，对C++语言的运用往往不过是较为高级的C语言解法</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>​面向对象是C++语言最重要的特性之一，C++语言相对于C最重要的就是从面向过程的转换为面向对象的编程思维。C with Classes所诉求的部分：classes，封装，继承，多态，虚函数(virtual函数-动态绑定)</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>​泛型编程。模板是在C++中与面向对象并列的另一大分支——泛型编程。所谓泛型编程，就是不依赖某一具体类型而使代码仍然具有很强适应性的编程范式。而我们所常用的STL则是泛型编程下的一大优秀案例</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>​STL是一个template程序库，它对容器，迭代器，算法及其函数对象的规约有着极佳的紧密配合与协调</p><h2 id="C-相关基本信息"><a href="#C-相关基本信息" class="headerlink" title="C++相关基本信息"></a>C++相关基本信息</h2><h3 id="1-C-历史讲解"><a href="#1-C-历史讲解" class="headerlink" title="1.C++历史讲解"></a>1.C++历史讲解</h3><h4 id="前言：为什么要学C"><a href="#前言：为什么要学C" class="headerlink" title="前言：为什么要学C++"></a>前言：为什么要学C++</h4><ol><li>C++目前仍然是主要的流行语言之一</li><li>C++贴近OS&#x2F;硬件层，性能上限高</li><li>底层核心模块（OS，编译器，运行环境，大型软件等）通常由C++编写</li><li>应用场景十分广泛，图形引擎，音视频处理，仿真系统，高频交易</li><li>技术上线高（上至其他语言，下至逆向汇编）</li><li>WPS技术大佬基本都是C++出身，转型极快</li></ol><p><a href="https://imgse.com/i/vxifwq"><img src="https://s1.ax1x.com/2022/09/14/vxifwq.png" alt="vxifwq.png"></a></p><p><a href="https://imgse.com/i/vxi5kV"><img src="https://s1.ax1x.com/2022/09/14/vxi5kV.png" alt="vxi5kV.png"></a></p><p><a href="https://imgse.com/i/vxiIYT"><img src="https://s1.ax1x.com/2022/09/14/vxiIYT.png" alt="vxiIYT.png"></a></p><h3 id="2-VS中编译C-的方法"><a href="#2-VS中编译C-的方法" class="headerlink" title="2.VS中编译C++的方法"></a>2.VS中编译C++的方法</h3><p>编译流程：</p><p><a href="https://imgse.com/i/vxirY8"><img src="https://s1.ax1x.com/2022/09/14/vxirY8.png" alt="vxirY8.png"></a></p><h3 id="3-C与C-的区别"><a href="#3-C与C-的区别" class="headerlink" title="3.C与C++的区别"></a>3.C与C++的区别</h3><p>​C语言作为程序化开发的语言，适合处理较小规模的程序。对于大规模程序，C语言并不合适</p><p>C语言的三个缺陷：</p><ol><li>不太严谨</li><li>名字冲突</li><li>作用域</li></ol><p>而现代C++语言可以看做是三部分组成的：</p><ul><li>低级语言，大部分继承自C语言</li><li>现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统</li><li>标准库（STL），它利用高级特性来提供有用的数据结构和算法</li></ul><p>思想对比</p><ul><li>面向过程——C语言</li><li>面向对象——C++</li><li>函数式编程——Javascript</li></ul><h2 id="C-的基本架构"><a href="#C-的基本架构" class="headerlink" title="C++的基本架构"></a>C++的基本架构</h2><h3 id="1-C-的默认架构"><a href="#1-C-的默认架构" class="headerlink" title="1.C++的默认架构"></a>1.C++的默认架构</h3><p>C++的默认架构一般为：头文件，域名空间，主函数</p><p><a href="https://imgse.com/i/vxiWmn"><img src="https://s1.ax1x.com/2022/09/14/vxiWmn.png" alt="vxiWmn.png"></a></p><h3 id="2-C-的头文件"><a href="#2-C-的头文件" class="headerlink" title="2.C++的头文件"></a>2.C++的头文件</h3><p>在之前所学的C语言中的表头文件为stdio.h，C++也是类似的，老版的C++库中也是类似，调用了iostream.h</p><p>但是，目前在新版的C++库中为了方便书写，已经把.h这样的风格给去掉了</p><p>需要我们注意的是，<strong>每个使用标准库设施的程序都必须包含相关的头文件</strong>，#include指令和头文件名字必须写在同一行中</p><p>通常情况下，#include指令必须出现在所有函数之外，我们<strong>一般将一个程序的所有#include指令都放在源文件的开始位置</strong></p><p>C++语言兼容C语言，标准C++程序库中是不带.h的，若是我们打算使用C语言的函数，可以在C语言的标准库头文件，推荐写法是去掉C语言头文件中的.h文件，在前面加上c，例如</p><pre><code class="C++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;</code></pre><h3 id="3-C-中的域名空间"><a href="#3-C-中的域名空间" class="headerlink" title="3.C++中的域名空间"></a>3.C++中的域名空间</h3><p>在实际大型的项目开发中，由于很多的功能模块，是由不同的人来编写的。因此，可能会出现A编写的函数名和B编写的函数名一样的情况。这样一来，我们的程序就会发生错误，只要我们每个人都定义自己的命名空间，就可以解决这一问题，即使函数重名，只要属于不同的命名空间就不会出现问题</p><p>注：当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。<strong>多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）</strong></p><p><strong>命名空间（namespace）为了防止名字冲突提供了更加可控的机制</strong>。命名空间分割了全局命名空间，其中的每一个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（及其用户）可以避免全局名字固有的限制</p><h4 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h4><p>一个命名空间的定义包含两部分：首先是关键字namespace ，随后是命名空间的名字，在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类，变量（及其初始化操作），函数（及其定义），模板和其他命名空间</p><pre><code class="C++">// 域名控件编码规范：全部小写namespace demospace &#123;    int x=100;        void output() &#123;        cout&lt;&lt;&quot;This is a namespace example!&quot;&lt;&lt;endl;    &#125;&#125;</code></pre><p>和其他名字一样，<strong>命名空间中的名字也必须在定义它的作用域内保持唯一</strong>。命名空间即可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部</p><p><strong>注：命名空间作用域后面无须分号</strong></p><p><strong>注意事项：</strong></p><ul><li>每个命名空间都是一个作用域</li><li>命名空间可以是不连续的<ul><li>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间，此时，命名空间的组织方式类似于我们管理自定义类和函数的方式</li></ul></li></ul><p>需要我们注意的一点是，在通常情况下，我们不把#include放在命名空间内部，如果我们一旦这么做了，隐含的意思就是把头文件中所有的名字定义成该命名空间的成员</p><p>命名空间中定义的成员可以直接使用名字，而无须前缀；命名空间之外定义的成员必须使用含有前缀的名字</p><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>全局命名空间中定义的名字（即在所有类，函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间中</strong>（global namespace）。全局命名空间以隐式的方式声明，并且在所有程序中都存在</p><p>作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字，如下形式：</p><pre><code>::member_name</code></pre><p>表示全局命名空间中的一个成员</p><h5 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h5><p>嵌套命名空间是指定义在其他命名空间中的命名空间</p><h5 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h5><p>未命名的命名空间（unnamed namespace）所指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁</p><p>注：和其他的命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件</p><p>目前为止，我们所用到的库函数基本上都属于命名空间std，而程序也显式地将这一点表示出来了</p><h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><p>如果我们使用了<strong>using声明</strong>，就可以更为简单地使用命名空间中的成员，即无须使用专门的前缀（形如命名空间::）也能使用所需的名字了</p><p>using声明具有如下的形式：</p><pre><code>using namespace::name;</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><pre><code class="C++">#include&lt;iostream&gt;// using声明，当我们使用名字cin时，从命名空间std中获取它using std::cin;int main()&#123;    int i;    cin&gt;&gt;i;    std::cout&lt;&lt;i;    return 0;&#125;</code></pre><p>根据规定，每个using声明引入命名空间中的一个成员</p><h4 id="命名空间的using指示"><a href="#命名空间的using指示" class="headerlink" title="命名空间的using指示"></a>命名空间的using指示</h4><p><strong>using指示</strong>和using声明类似的地方是，我们可以使用命名空间名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的</p><p>using指示以关键字using开始，后面是关键字namespace以及命名空间的名字，例如：</p><pre><code>using namespace std;</code></pre><p>using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用</p><h4 id="using指示与作用域（总结）"><a href="#using指示与作用域（总结）" class="headerlink" title="using指示与作用域（总结）"></a>using指示与作用域（总结）</h4><p>using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。</p><p>对于using声明来说，我们只是简单地令名字在局部作用域内有效</p><p>对于using指示来说，using指示是令整个命名空间的所有内容都变得有效</p><h3 id="4-C-中的输出函数"><a href="#4-C-中的输出函数" class="headerlink" title="4.C++中的输出函数"></a>4.C++中的输出函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p><a href="https://imgse.com/i/vxib6J"><img src="https://s1.ax1x.com/2022/09/14/vxib6J.png" alt="vxib6J.png"></a></p><p>C和C++语言中没有专门的输入输出语句。C语言中输入和输出由函数来使用，而C++中的输入和输出是通过流的方式来实现的</p><ul><li>标准输入（standard input）：cin</li><li>标准输出（standard output）：cout</li><li>标准出错（standard err）：cerr</li><li>流输出运算符：&lt;&lt;</li><li>流输入运算符：&gt;&gt;</li></ul><h4 id="C-中常用格式控制符"><a href="#C-中常用格式控制符" class="headerlink" title="C++中常用格式控制符"></a>C++中常用格式控制符</h4><ul><li>noshowbase——不生成表示进制的前缀</li><li>showbase ——对整型输出表示进制的前缀</li><li>dec——整型值显示为十进制</li><li>hex——整型值显示为十六进制</li><li>oct——整型值显示为八进制</li><li>fixed——浮点数显示为定点十进制</li><li>scientific——浮点值显示为科学计数法</li><li>setprecision(整数)——设置输出有效数字的个数，不包含小数点</li><li>ends——插入空字符，然后刷新ostream缓冲区</li><li>endl——插入换行，然后刷新ostream缓冲区</li></ul><h2 id="C-中的指针"><a href="#C-中的指针" class="headerlink" title="C++中的指针"></a>C++中的指针</h2><h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><h4 id="1-地址的概念"><a href="#1-地址的概念" class="headerlink" title="1.地址的概念"></a>1.地址的概念</h4><p>​操作系统以32bit&#x2F;64bit的地址总线为基准，对内存单元以字节为单位进行编号，这个编号我们叫做内存地址</p><p><a href="https://imgse.com/i/vxigyj"><img src="https://s1.ax1x.com/2022/09/14/vxigyj.png" alt="vxigyj.png"></a></p><h4 id="2-基本内存操作"><a href="#2-基本内存操作" class="headerlink" title="2.基本内存操作"></a>2.基本内存操作</h4><ul><li>把数据写到内存中去</li><li>把内存中的数据读取出来</li></ul><h4 id="3-C-中分配内存的方法"><a href="#3-C-中分配内存的方法" class="headerlink" title="3.C++中分配内存的方法"></a>3.C++中分配内存的方法</h4><p>（1）定义变量</p><p>（2）通过malloc函数，动态分配内存</p><p><a href="https://imgse.com/i/vxihT0"><img src="https://s1.ax1x.com/2022/09/14/vxihT0.png" alt="vxihT0.png"></a></p><h4 id="4-C-中对内存读写的方法"><a href="#4-C-中对内存读写的方法" class="headerlink" title="4.C++中对内存读写的方法"></a>4.C++中对内存读写的方法</h4><p>（1）通过内存标识符（即变量名）</p><p>（2）通过内存地址，通过&amp;符号获得内存的首地址</p><p><a href="https://imgse.com/i/vxiHl4"><img src="https://s1.ax1x.com/2022/09/14/vxiHl4.png" alt="vxiHl4.png"></a></p><h4 id="5-C-中的两种变量"><a href="#5-C-中的两种变量" class="headerlink" title="5.C++中的两种变量"></a>5.C++中的两种变量</h4><p>关于变量：</p><p>​变量提供一个具体的，可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算</p><p>​对于C++程序员来说，“变量(variable)”和”对象(object)”一般可以互换使用</p><p>（1）普通变量</p><p>定义方法：数据类型变量名</p><p>（2）指针变量</p><p>定义方法：数据类型*变量名</p><p><a href="https://imgse.com/i/vxiX01"><img src="https://s1.ax1x.com/2022/09/14/vxiX01.png" alt="vxiX01.png"></a></p><h3 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h3><p>​前提引入：<strong>复合类型</strong></p><p>复合类型是指基于其他类型定义的类型，以下将将C++语言中的两种复合类型：引用和指针</p><p>一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更为通用的描述是，<strong>一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成</strong></p><h4 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h4><p>拓展：C++11新标准中新增了一种引用：所谓的“右值引用”，指针引用主要用于内置类；</p><p>严格来说，当我们使用术语“引用”时，指的其实是“左值引用”</p><p><strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名</p><p>当我们定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起</p><p>注：引用并非对象，相反的，它只是为了一个已经存在的对象所起的另外一个名字</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针是“指向”另外一种类型的复合类型。指针与引用不同之处在于，指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，且指针无须在定义时赋初值。</p><p>注：在32位的操作系统中，所有的指针变量都是4个字节</p><p><a href="https://imgse.com/i/vxiOmR"><img src="https://s1.ax1x.com/2022/09/14/vxiOmR.png" alt="vxiOmR.png"></a></p><p>指针存放着某个对象的地址，要想获取该地址，需要使用取地址符(操作符&amp;)：</p><pre><code class="c++">int val = 42;int* p = &amp;val; // p存放变量val的地址，或者说p是指向变量val的指针</code></pre><p>需要我们注意的是，引用不是对象，没有实际的地址，所以我们不能定义指向引用的指针</p><p><strong>指针的类型要与它所指向的对象严格匹配</strong>（有例外）</p><h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>​指针的值（即地址）应属下列4种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象</li><li>无效指针，也就是上述情况之外的其他值（一般这种情况下，指针被称为野指针）</li></ol><p>注意：试图拷贝或以其他方式访问无效指针的值都将引发错误</p><h4 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h4><p>​如果指针指向了一个对象(重要前提)，则允许使用<strong>解引用符</strong>(操作符*)来访问对象：</p><pre><code class="C++">int val = 42;int* p =&amp;val; // p存放着变量val的地址，或者说p是指向变量val的指针cout&lt;&lt;*p;    // 由符号*得到指针p所指的对象，输出对应的值42</code></pre><p>对指针解引用会得出所指的对象，因此<strong>如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值</strong></p><p>注：解引用操作仅适用于那些确实指向某个对象的有效指针</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>​<strong>空指针</strong>（null pointer）不指向任何对象，在试图适用一个指针之前的代码可以首先检查它是否为空</p><pre><code class="C++">int *p1 = nullptr; // 等价于int *p1 = 0;int *p2 = 0;    // 直接将p2初始化为字面常量0// 需要首先#include&lt;cstdlib&gt;int *p3 = NULL;    // 等价于int *p3 = 0;</code></pre><p>得到空指针最直接的办法就是字面值nullptr来初始化指针，这也是C++11新标准引入的一种方法。</p><p>nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型</p><p>在之前的程序中还会用到一个名为NULL的预处理变量来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0</p><p><strong>拓展</strong>：（1）NULL为预处理变量（2）预处理器是运行于编译过程之前的一段程序（3）预处理变量不属于命名空间std，它由预处理器负责</p><p>当用到一个预处理变量时，预处理器会自动地将它们替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的</p><p><strong>在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL</strong></p><p><strong>指针使用建议：初始化所有指针</strong></p><h4 id="关于CPU的两种存储模式"><a href="#关于CPU的两种存储模式" class="headerlink" title="关于CPU的两种存储模式"></a>关于CPU的两种存储模式</h4><p>大端模式：高地址存储数据的低位，低地址存储数据的高位</p><p>小端模式：低地址存储数据的低位，高地址存储数据的高位</p><p><a href="https://imgse.com/i/vxisfS"><img src="https://s1.ax1x.com/2022/09/14/vxisfS.png" alt="vxisfS.png"></a></p><h4 id="C语言中数据类型决定指针变量的寻址范围"><a href="#C语言中数据类型决定指针变量的寻址范围" class="headerlink" title="C语言中数据类型决定指针变量的寻址范围"></a>C语言中数据类型决定指针变量的寻址范围</h4><p>​通过不同的数据类型指针变量，对同一块内存进行操作的时候，一次读取数据的字节数不一样</p><pre><code class="C++">int* p1; // 一次操作4个字节short* p2; // 一次操作2个字节char* p3; // 一次操作1个字节</code></pre><p>指针变量在移动的时候，每次移动的大小为指向对象数据类型的大小</p><h3 id="一级指针和字符串"><a href="#一级指针和字符串" class="headerlink" title="一级指针和字符串"></a>一级指针和字符串</h3><p>示例：</p><pre><code class="c++">char buf[100] = &quot;WPS&quot;;char* s = &quot;WPS&quot;;buf[0] = &#39;X&#39;; // 正确s[0] = &#39;X&#39;;   // 错误</code></pre><p>结论：</p><ol><li>定义数组保存字符串的时候，字符串保存在栈区，栈区的内存有读写权限</li><li>定义指针保存字符串的时候，指针保存的是字符串的首地址。字符串存放到常量区，常量区是系统单独分配的一块内存，在这个区域字符串只能进行读操作，不能进行写操作</li></ol><p><a href="https://imgse.com/i/vxi6Sg"><img src="https://s1.ax1x.com/2022/09/14/vxi6Sg.png" alt="vxi6Sg.png"></a></p><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p>函数中使用指针的场景：</p><ol><li>当需要存储的数据内存过大（结构体或者数组），传递指针可以节省内存空间，从而减少所需的拷贝时间：</li></ol><p>例如输出数组的信息：</p><p><a href="https://imgse.com/i/vxi7pF"><img src="https://s1.ax1x.com/2022/09/14/vxi7pF.png" alt="vxi7pF.png"></a></p><p>2.需要在函数内计算某个数据，在函数内出参</p><p>例如基本的计算：</p><p><a href="https://imgse.com/i/vxiqX9"><img src="https://s1.ax1x.com/2022/09/14/vxiqX9.png" alt="vxiqX9.png"></a></p><h2 id="C-新语法"><a href="#C-新语法" class="headerlink" title="C++新语法"></a>C++新语法</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载函数（overload）——同一作用域内几个函数名字相同但形参列表不同</p><p>注：main函数不能重载</p><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同，<strong>不允许两个函数除了返回类型外其他所有要素都相同</strong></p><pre><code class="C++">int lookup(const Account&amp;);bool lookup(const Account&amp;); // 错误：与上一个函数相比只有返回类型不同</code></pre><p><strong>函数重载规则：</strong></p><ul><li>函数名称必须相同</li><li>参数列表必须不同（个数不同，或类型不同，参数排列顺序不同等）</li><li>函数返回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为函数的重载</li></ul><h4 id="判断两个形参的类型是否"><a href="#判断两个形参的类型是否" class="headerlink" title="判断两个形参的类型是否"></a>判断两个形参的类型是否</h4><p>有时候两个形参列表看起来不一样，但实际上是相同的：</p><pre><code class="C++">// 每对声明的是同一函数int lookup(const string &amp;message);int lookup(const string&amp;); // 省略了形参的名字typedef double dou;int lookup(const double&amp;);int lookup(const dou&amp;);   // 二者类型相同</code></pre><h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>​一个拥有顶层const的形参无法和另一个没有顶层const的形参区别开来：</p><pre><code class="c++">int lookup（string);int lookup(const string); // 重复声明</code></pre><p>另一方面，<strong>如果形参是某种类型的指针或引用，则通过区别其指向的是常量对象还剩非常量对象可以实现函数重载，此时的const是底层的：</strong></p><pre><code class="C++">// 对于接收引用或指针的函数来说，对象是常量还是非常量对应的形参不同// 定义了4个独立的重载函数int lookup(string&amp;); // 函数作用于string的引用int lookup(const string&amp;); // 新函数，作用于常量引用int lookup(string*); // 新函数，作用于指向string的指针int lookup(const string*); // 新函数，作用于指向常量的指针</code></pre><p>注：当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</p><h4 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h4><p>​定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配</strong>是指一个过程，在这个过程中我们把函数调用于一组重载函数中的某一关联起来，函数匹配也叫<strong>重载确定</strong>。编译器首先将调用的实参于重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数</p><p>​当调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参<strong>最佳匹配</strong>的函数并生成调用该函数的代码</li><li>找不到任何一个函数与调用实参匹配，此时编译器发出<strong>无匹配</strong>的错误信息</li><li>有多于一个函数可以匹配，但每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong></li></ul><h3 id="栈堆内存分配"><a href="#栈堆内存分配" class="headerlink" title="栈堆内存分配"></a>栈堆内存分配</h3><h4 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h4><p>​申请内存：void* malloc(unsigned size);</p><p>​释放内存：void free();</p><p><a href="https://imgse.com/i/vxi2Os"><img src="https://s1.ax1x.com/2022/09/14/vxi2Os.png" alt="vxi2Os.png"></a></p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>​new&#x2F;delete，是一个C++中堆区内存分配的运算符</p><p>​new——向堆申请空间</p><p>​delete——释放堆区的空间</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p><a href="https://imgse.com/i/vxiofU"><img src="https://s1.ax1x.com/2022/09/14/vxiofU.md.png" alt="vxiofU.md.png"></a></p><h5 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h5><ol><li>malloc&#x2F;free是C语言中提供的库函数，new&#x2F;delete是C++中的运算符</li><li>malloc可以在堆区分配空间，但是返回值是void*指针，使用要强制转换；而new&#x2F;delete使用的时候，系统的调度资源少一些。直接通过指针连接回收</li><li>new&#x2F;delete申请对象空间的时候，会调用对象的构造函数和析构函数，而malloc不会调用</li></ol><p>示例代码：</p><p><a href="https://imgse.com/i/vxiclQ"><img src="https://s1.ax1x.com/2022/09/14/vxiclQ.png" alt="vxiclQ.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>define、const、typedef、inline</title>
      <link href="/p/397.html"/>
      <url>/p/397.html</url>
      
        <content type="html"><![CDATA[<h2 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h2><h3 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h3><p>const 定义的常量在预处理阶段并不存在，而是直到运行阶段才会出现。准确地说，它实际上是运行时的“变量”，只不过不允许修改，是“只读”的<br>（read only），叫“只读变量”更合适。既然它是“变量”，那么，使用指针获取地址，再“强制”写入也是可以的。但这种做法破坏了“常量性”<br><strong>const</strong> 定义的常量是变量带类型，⽽  定义的只是个常数不带类型；<br><strong>#define</strong>只在预处理阶段起作⽤，简单的⽂本替换，⽽ <strong>const</strong> 在编译、<br>链接过程中起作⽤；<br><strong>#define</strong>   只是简单的字符串替换没有类型检查。⽽<strong>const</strong>是有数据类型的，<br>是要进⾏判断的，可以避免⼀些低级错误；<br><strong>#define</strong> 预处理后，占⽤代码段空间，<strong>const</strong> 占⽤数据段空间；<br><strong>const</strong>m 不能重定义，⽽**#define** 可以通过#undef取消某个符号的定义，进⾏重定义；<br><strong>define</strong>   独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。</p><h3 id="define-和别名-typedef-的区别"><a href="#define-和别名-typedef-的区别" class="headerlink" title="define  和别名 typedef 的区别"></a><strong>define</strong>  和别名 typedef 的区别</h3><h5 id="执⾏时间不同"><a href="#执⾏时间不同" class="headerlink" title="执⾏时间不同"></a>执⾏时间不同</h5><p><strong>typedef</strong> 在编译阶段有效，<strong>typedef</strong> 有类型检查的功能；**#define**是宏定义，发⽣在预处理阶段，不进⾏类型检查；</p><h5 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h5><p><strong>typedef</strong> ⽤来定义类型的别名，定义与平台⽆关的数据类型，<br>与   <strong>struct</strong>   的结合使⽤等。<br><strong>#define</strong>   不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p><h5 id="作⽤域不同"><a href="#作⽤域不同" class="headerlink" title="作⽤域不同"></a>作⽤域不同</h5><p><strong>#define</strong> 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。<br>⽽ typedef 有⾃⼰的作⽤域。</p><h3 id="define-与-inline-的区别"><a href="#define-与-inline-的区别" class="headerlink" title="define 与 inline 的区别"></a>define 与 inline 的区别</h3><p> #define是关键字，inline是函数；<br>宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；<br>inline 函数有类型检查，相⽐宏定义⽐较安全；</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内建函数对象</title>
      <link href="/p/45788.html"/>
      <url>/p/45788.html</url>
      
        <content type="html"><![CDATA[<h1 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h1><ul><li>STL内建了一些函数对象</li><li>头文件 functional</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><h2 id="算数仿函数"><a href="#算数仿函数" class="headerlink" title="算数仿函数"></a>算数仿函数</h2><h3 id="仿函数原型："><a href="#仿函数原型：" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3><ul><li>template<class t> T plus<T> &#x2F;&#x2F;加法仿函数</T></class></li><li>template<class t> T minus<T> &#x2F;&#x2F;减法仿函数</T></class></li><li>template<class t> T multiplies<T> &#x2F;&#x2F;乘法仿函数</T></class></li><li>template<class t> T divides<T> &#x2F;&#x2F;除法仿函数</T></class></li><li>template<class t> T modulus<T> &#x2F;&#x2F;取模仿函数</T></class></li><li>template<class t> T negate<T> &#x2F;&#x2F;取反仿函数</T></class></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;functional&gt;//negatevoid test01()&#123;    negate&lt;int&gt; n;    cout &lt;&lt; n( 50 ) &lt;&lt; endl;&#125;//plusvoid test02()&#123;    plus&lt;int&gt; p;    cout &lt;&lt; p( 10 , 20 ) &lt;&lt; endl;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h2><h3 id="仿函数原型：-1"><a href="#仿函数原型：-1" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3><ul><li>template<class t> bool equal_to<T> &#x2F;&#x2F;等于</T></class></li><li>template<class t> bool not_equal_to<T> &#x2F;&#x2F;不等于</T></class></li><li>template<class t> bool greater<T> &#x2F;&#x2F;大于</T></class></li><li>template<class t> bool greater_equal<T> &#x2F;&#x2F;大于等于</T></class></li><li>template<class t> bool less<T> &#x2F;&#x2F;小于</T></class></li><li>template<class t> bool less_equal<T> &#x2F;&#x2F;小于等于</T></class></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:    bool operator()(int v1,int v2)    &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 40 );    v.push_back( 20 );    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //sort(v.begin(), v.end(), MyCompare());    //STL内建仿函数 大于仿函数    sort(v.begin(), v.end(), greater&lt;int&gt;());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：关系仿函数中最常用的就是greater-lt-gt-大于"><a href="#总结：关系仿函数中最常用的就是greater-lt-gt-大于" class="headerlink" title="总结：关系仿函数中最常用的就是greater&lt;&gt;大于"></a>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</h5><h2 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><ul><li>template<class t> bool logical_and<T> &#x2F;&#x2F;逻辑与</T></class></li><li>template<class t> bool logical_or<T> &#x2F;&#x2F;逻辑或</T></class></li><li>template<class t> bool logical_not<T> &#x2F;&#x2F;逻辑非</T></class></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;    vector&lt;bool&gt; v;    v.push_back(true);    v.push_back(false);    v.push_back(true);    v.push_back(false);    for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //逻辑非 将v容器搬运到v2中，并执行逻辑非运算    vector&lt;bool&gt; v2;    v2.resize(v.size());    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;());    for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：逻辑仿函数实际应用较少，了解即可"><a href="#总结：逻辑仿函数实际应用较少，了解即可" class="headerlink" title="总结：逻辑仿函数实际应用较少，了解即可"></a>总结：逻辑仿函数实际应用较少，了解即可</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/p/1690d21b.html"/>
      <url>/p/1690d21b.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>作为现代 C++ 里的五种基本编程范式之一，“函数式编程”的作用和地位正在不断上升，而且在其他语言里也非常流行.<br>函数式编程期望函数的行为像数学上的函数，而非一个计算机上的子程序。这样的函数一般被称为纯函数（pure function），要点在于：</p><ul><li>会影响函数结果的只是函数的参数，没有对环境的依赖</li><li>返回的结果就是函数执行的唯一后果，不产生对环境的其他影响</li></ul><h2 id="C-函数的特殊性"><a href="#C-函数的特殊性" class="headerlink" title="C++ 函数的特殊性"></a>C++ 函数的特殊性</h2><p>C++ 里的函数概念来源于 C，是面向过程编程范式的基本部件。但严格来说，它其实应该叫“子过程”（sub-procedure）、“子例程”（sub-routine），是命令的集合、操作步骤的抽象<br>函数的目的是封装执行的细节，简化程序的复杂度，但因为它有入口参数，有返回值，形式上和数学里的函数很像，所以就被称为“函数”。<br>在语法层面上，C&#x2F;C++ 里的函数是比较特别的。虽然有函数类型，但不存在对应类型的变量，不能直接操作，只能用指针去间接操作（即函数指针），这让函数在类型体系里显得有点“格格不入”<br>函数在用法上也有一些特殊之处。在 C&#x2F;C++ 里，所有的函数都是全局的，没有生存周期的概念（static、名字空间的作用很弱，只是简单限制了应用范围，避免名字冲突）。而且函数也都是平级的，不能在函数里再定义函数，也就是不允许定义嵌套函数、函数套函数。</p><pre><code>void my_square(int x) // 定义一个函数&#123;    std::cout &lt;&lt; x * x &lt;&lt; std::endl; // 函数的具体内容&#125;auto pfunc = &amp;my_square; // 只能用指针去操作函数，指针不是函数(*pfunc)(3); // 可以用*访问函数pfunc(3); // 也可以直接调用函数指针</code></pre><p>在面向过程编程范式里，函数和变量虽然是程序里最关键的两个组成部分，但却因为没有值、没有作用域而不能一致地处理。函数只能是函数，变量只能是变量，彼此之间虽不能说是“势同水火”，但至少是“泾渭分明”。</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>C++11 引入的 lambda 表达式，下面是一个简单的例子：</p><pre><code>auto func = [](int x) // 定义一个 lambda 表达式&#123;    std::cout &lt;&lt; x * x &lt;&lt; std::endl; // lambda 表达式的具体内容&#125;;func(3); // 调用 lambda 表达式</code></pre><p>因为 lambda 表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“就地”定义函数，限制它的作用域和生命周期，实现函数的局部化。而且，因为 lambda 表达式和变量一样是“一等公民”，用起来也就更灵活自由，能对它做各种运算，生成新的函数。这就像是数学里的复合函数那样，把多个简单功能的小lambda 表达式组合，变成一个复杂的大 lambda 表达式。<br>lambda 表达式为 C++ 带来的变化可以说是革命性的。虽然它表面上只是一个很小的改进，简化了函数的声明 &#x2F; 定义，但深层次带来的编程理念的变化，却是非常巨大的。<br>C++ 里的 lambda 表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以“捕获”外部变量，在内部的代码里直接操作。</p><pre><code>int n = 10; // 一个外部变量auto func = [=](int x) // lambda 表达式，用“=”值捕获&#123;    std::cout &lt;&lt; x * n &lt;&lt; std::endl; // 直接操作外部变量&#125;;func(3); // 调用 lambda 表达式</code></pre><p>lambda 表达式就是在其他语言中大名鼎鼎的“闭包”（closure），这让它真正超越了函数和函数对象。<br>闭包可以理解为一个“活的代码块”“活的函数”。它虽然在出现时被定义，但因为保存了定义时捕获的外部变量，就可以跳离定义点，把这段代码“打包”传递到其他地方去执行，而仅凭函数的入口参数是无法做到这一点的。这就导致函数式编程与命令式编程（即面向过程）在结构上有很大不同，程序流程不再是按步骤执行的“死程序”，而是一个个的“活函数”，像做数学题那样逐步计算、推导出结果，有点像下面的这样：</p><pre><code>auto a = [](int x) // a函数执行一个功能&#123;    // ... 具体的函数体实现&#125;;auto b = [](double x) // b函数执行一个功能&#123;    // ... 具体的函数体实现&#125;;auto c = [](std::string str) // c函数执行一个功能&#123;    // ... 具体的函数体实现&#125;;auto f = [](...) // f函数执行一个功能&#123;    // ... 具体的函数体实现&#125;;return f(a, b, c); // f调用a/b/c运算得到结果</code></pre><p>在面向对象编程里，程序是由一个个实体对象组成的，对象通信完成任务。而在函数式编程里，程序是由一个个函数组成的，函数互相嵌套、组合、<br>调用完成任务。</p><h2 id="使用-lambda-的注意事项"><a href="#使用-lambda-的注意事项" class="headerlink" title="使用 lambda 的注意事项"></a>使用 lambda 的注意事项</h2><h3 id="lambda-的形式"><a href="#lambda-的形式" class="headerlink" title="lambda 的形式"></a>lambda 的形式</h3><p>C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“[]”，术语叫“lambda 引出符”（lambda<br>introducer）。在 lambda 引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体</p><pre><code>auto f1 = []()&#123;&#125;; // 相当于空函数，什么也不做</code></pre><p>这行语句定义了一个相当于空函数的 lambda 表达式<br>实际开发中不会有这么简单的 lambda 表达式，它的函数体里可能会有很多语句，所以一定要有良好的缩进格式——特别是有嵌套定义的时候，尽量让人能够一眼就看出 lambda 表达式的开始和结束，必要的时候可以用注释来强调。</p><pre><code>auto f2 = []() // 定义一个 lambda 表达式&#123;    std::cout &lt;&lt; &quot;lambda f2&quot; &lt;&lt; std::endl;    auto f3 = [](int x) // 嵌套定义 lambda 表达式    &#123;        return x * x;    &#125;; // lambda f3 // 使用注释显式说明表达式结束    std::cout &lt;&lt; f3(10) &lt;&lt; std::endl;&#125;; // lambda f2 // 使用注释显式说明表达式结束</code></pre><p>在 lambda 表达式赋值的时候，总是使用 auto 来推导类型。这是因为，在 C++ 里，每个 lambda 表达式都会有一个独特的类型，而这个类型只有编译器才知道，我们是无法直接写出来的，所以必须用 auto。<br>因为 lambda 表达式毕竟不是普通的变量，所以 C++ 也鼓励程序员尽量“匿名”使用 lambda 表达式。也就是说，它不必显式赋值给一个有名字的变量，直接声明就能用，这样不仅可以让代码更简洁，而且因为“匿名”，lambda 表达式调用完后也就不存在了，这就最小化了它的影响范围，让代码更加安全。</p><pre><code>std::vector&lt;int&gt; v = &#123;3, 1, 8, 5, 0&#125;; // 标准容器std::cout &lt;&lt; *std::find_if(std::begin(v), std::end(v), // 标准库里的查找算法    [](int x) // 匿名 lambda 表达式，不需要 auto 赋值    &#123;        return x &gt;= 5; // 用作算法的谓词判断条件    &#125; // lambda 表达式结束) &lt;&lt; std::endl; // 语句执行完，lambda 表达式就不存在了</code></pre><h3 id="lambda-的变量捕获"><a href="#lambda-的变量捕获" class="headerlink" title="lambda 的变量捕获"></a>lambda 的变量捕获</h3><p><a href="https://whl963854.github.io/p/330a6169.html">https://whl963854.github.io/p/330a6169.html</a><br><a href="https://whl963854.github.io/p/57725.html">https://whl963854.github.io/p/57725.html</a><br><a href="https://whl963854.github.io/p/46257.html">https://whl963854.github.io/p/46257.html</a></p><ul><li>“[&#x3D;]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改；</li><li>“[&amp;]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改；</li></ul><p>也可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获，C++ 在这里给予了非常大的灵活性</p><pre><code>int x = 33; // 一个外部变量auto f1 = [=]() // lambda 表达式，用“=”按值捕获&#123;    //x += 10; // x只读，不允许修改&#125;;auto f2 = [&amp;]() // lambda 表达式，用“&amp;”按引用捕获&#123;    x += 10; // x是引用，可以修改&#125;;auto f3 = [=, &amp;x]() // lambda 表达式，用“&amp;”按引用捕获 x，其他的按值捕获&#123;    x += 20; // x是引用，可以修改&#125;;</code></pre><p>使用“[&#x3D;]”按值捕获的时候，lambda 表达式使用的是变量的独立副本，非常安全。而使用“[&amp;]”的方式捕获引用就存在风险，当 lambda 表达式在离定义点“很远的地方”被调用的时候，引用的变量可能发生了变化，甚至可能会失效，导致难以预料的后果。<br>对于“就地”使用的小 lambda 表达式，可以用“[&amp;]”来减少代码量，保持整洁；而对于非本地调用、生命周期较长的 lambda 表达式应慎用“[&amp;]”捕获引用，而且，最好是在“[]”里显式写出变量列表，避免捕获不必要的变量。</p><pre><code>class DemoLambda final&#123;private:    int x = 0;public:    auto print() // 返回一个 lambda 表达式供外部使用    &#123;        return [this]() // 显式捕获 this 指针        &#123;            std::cout &lt;&lt; &quot;member = &quot; &lt;&lt; x &lt;&lt; std::endl;        &#125;;    &#125;&#125;;</code></pre><h3 id="泛型的-lambda"><a href="#泛型的-lambda" class="headerlink" title="泛型的 lambda"></a>泛型的 lambda</h3><p>在 C++14 里，lambda 表达式又多了一项新本领，可以实现“泛型化”，相当于简化了的模板函数，具体语法还是利用了auto：</p><pre><code>auto f = [](const auto&amp; x) // 参数使用 auto 声明，泛型化&#123;    return x + x;&#125;;std::cout &lt;&lt; f(3) &lt;&lt; std::endl; // 参数类型是 intstd::cout &lt;&lt; f(0.618) &lt;&lt; std::endl; // 参数类型是 doublestd::string str = &quot;matrix&quot;;std::cout &lt;&lt; f(str) &lt;&lt; std::endl; // 参数类型是 string</code></pre><p>这个新特性在写泛型函数的时候非常方便，摆脱了冗长的模板参数和函数参数列表。</p><pre><code>auto sum = [](auto x, auto y)&#123;    return x + y;&#125;</code></pre><p>上面这个 sum，就跟标准库里的 plus 模板一样，是可以传递给其他接受函数对象的函数的，而 + 本身则不行。</p><pre><code>#include &lt;array&gt; // std::array#include &lt;iostream&gt; // std::cout/endl#include &lt;numeric&gt; // std::accumulateusing namespace std;int main()&#123;    array a&#123;1, 2, 3, 4, 5&#125;;    auto s = accumulate(        a.begin(), a.end(), 0,        [](auto x, auto y) &#123;        return x + y;    &#125;);    cout &lt;&lt; s &lt;&lt; endl;&#125;</code></pre><p>虽然函数名字叫 accumulate——累加——但它的行为是通过第四个参数可修改的。我们把上面的加号 + 改成星号 *，上面的计算就从从 1 加到 5 变成了算 5 的阶乘了。</p><h2 id="bind-模板"><a href="#bind-模板" class="headerlink" title="bind 模板"></a>bind 模板</h2><p>bind1st 和 bind2nd 目前已经从 C++ 标准里移除。原因实际上有两个：</p><ul><li>它的功能可以被 lambda 表达式替代</li><li>有了一个更强大的 bind 模板</li></ul><p>比如：</p><pre><code>transform(v.begin(), v.end(),2 v.begin(),bind2nd(plus&lt;int&gt;(), 2));</code></pre><p>现在我们可以写成：</p><pre><code>using namespace std::placeholders; // for _1, _2...transform(v.begin(), v.end(),v.begin(),bind(plus&lt;&gt;(), _1, 2));</code></pre><p>原先我们只能把一个给定的参数绑定到第一个参数或第二个参数上，现在则可以非常自由地适配各种更复杂的情况！当然，bind 的参数数量，必须是第一个参数（函数对象）所需的参数数量加一。而 bind 的结果的参数数量则没有限制——你可以无聊地写出<br>bind(plus&lt;&gt;(), _1, _3)(1, 2, 3)，而结果是 4（完全忽略第二个参数）。<br>但是对 bind 只需要稍微了解一下就好——在 C++14 之后的年代里，已经没有什么地方必须要使用 bind了</p><h2 id="function-模板"><a href="#function-模板" class="headerlink" title="function 模板"></a>function 模板</h2><p>每一个 lambda 表达式都是一个单独的类型，所以只能使用 auto 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用function 模板。function 模板的参数就是函数的类型，一个函数对象放到<br>function 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。function 对象的创建还是比较耗资源的，所以请在用 auto 等方法解决不了问题的时候使用这个模板<br>下面是个简单的例子。</p><pre><code>map&lt;string, function&lt;int(int, int)&gt;&gt; op_dict&#123;    &#123;&quot;+&quot;,    [](int x, int y) &#123;        return x + y;    &#125;&#125;,    &#123;&quot;-&quot;,    [](int x, int y) &#123;        return x - y;    &#125;&#125;,    &#123;&quot;*&quot;,    [](int x, int y) &#123;        return x * y;    &#125;&#125;,    &#123;&quot;/&quot;,    [](int x, int y) &#123;        return x / y;    &#125;&#125;,&#125;;</code></pre><p>这儿，由于要把函数对象存到一个 map 里，我们必须使用 function 模板。随后，我们就可以用类似于 op_dict.at(“+”)(1, 6) 这样的方式来使用 function 对象。这种方式对表达式的解析处理可能会比较有用。</p><h2 id="不可变性和并发"><a href="#不可变性和并发" class="headerlink" title="不可变性和并发"></a>不可变性和并发</h2><p>在多核的时代里，函数式编程比以前更受青睐，一个重要的原因是函数式编程对并行并发天然友好。影响多核性能的一个重要因素是数据的竞争条件——由于共享内存数据需要加锁带来的延迟。函数式编程强调不可变性（immutability）、无副作用，天然就适合并发。更妙的是，如果使用高层抽象的话，有时可以轻轻松松“免费”得到性能提升。</p><pre><code>#include &lt;algorithm&gt;#include &lt;execution&gt;#include &lt;vector&gt;int count_file(const char* name)&#123;    ifstream ifs(name);    istream_line_reader reader(ifs);    return distance(reader.begin(),reader.end());&#125;int count_lines(const char** begin, const char** end)&#123;    std::vector&lt;int&gt; count(end - begin);    std::transform(std::execution::par, begin, end, count.begin(), count_file);    return std::reduce(std::execution::par, count.begin(), count.end());&#125;</code></pre><p>两个高阶函数的调用中都加入了 execution::par，来启动自动并行计算。</p><ul><li>std::transform 是 C++ 标准库中的一个算法函数，用于对一个序列中的每个元素应用一个操作，并将操作后的结果存储到另一个容器中，或者在原地修改原始序列。</li><li>std::reduce 是 C++17 中引入的一个算法函数，用于对序列中的元素进行累加（或其他二元操作），以生成最终的结果。它类似于 std::accumulate，但 std::reduce 具有更好的并行性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串处理</title>
      <link href="/p/b63369e3.html"/>
      <url>/p/b63369e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><p>按照标准委员会的意思，今后 C++ 也会更侧重于扩充库而不是扩充语言，将来标准库的地位还会不断上升。C++ 标准库非常庞大，里面有各式各样的精巧工具，今天就先来看看最常用，也是最容易被忽视的字符串，看看在 C++ 里该怎么处理文本数据。</p><h2 id="认识字符串"><a href="#认识字符串" class="headerlink" title="认识字符串"></a>认识字符串</h2><p>string 其实并不是一个“真正的类型”，而是模板类 basic_string 的特化形式，是一个typedef：</p><pre><code>using string = std::basic_string&lt;char&gt;; // string其实是一个类型别名</code></pre><p>所谓的字符串，就是字符的序列。字符是人类语言、文字的计算机表示，而人类语言、文字又有很多种，相应的编码方式也有很多种。所以，C++ 就为字符串设计出了模板类basic_string，再用模板来搭配不同的字符类型，就能够更有“弹性”地处理各种文字了。<br>说到字符和编码，就不能不提到 Unicode，它的目标是用一种编码方式统一处理人类语言文字，使用 32 位（4 个字节）来保证能够容纳过去或者将来所有的文字。但这就与 C++ 产生了矛盾。因为 C++ 的字符串源自 C，而 C 里的字符都是单字节的char 类型，无法支持 Unicode。<br>为了解决这个问题，C++ 就又新增了几种字符类型。C++98 定义了 wchar_t，到了C++11，为了适配 UTF-16、UTF-32，又多了 char16_t、char32_t。于是，basic_string在模板参数里换上这些字符类型之后，就可以适应不同的编码方式了。</p><pre><code>using wstring = std::basic_string&lt;wchar_t&gt;;using u16string = std::basic_string&lt;char16_t&gt;;using u32string = std::basic_string&lt;char32_t&gt;;</code></pre><p>Unicode 还有一个 UTF-8 编码方式，与单字节的 char 完全兼容，用 string 也足以适应大多数的应用场合。</p><h2 id="用好字符串"><a href="#用好字符串" class="headerlink" title="用好字符串"></a>用好字符串</h2><p>string 在 C++ 标准库里的身份也是比较特殊，虽然批评它的声音有不少，比如接口复杂、成本略高，但不像容器、算法，直到现在，仍然有且只有这么一个字符串类。string 是一个功能比较齐全的字符串类，可以提取子串、比较大小、检查长度、搜索字符……基本满足一般人对字符串的“想象”。<br>string 的接口比较复杂，除了字符串操作，还有 size()、begin()、end()、push_back() 等类似容器的操作，这很容易让人产生“联想”，把它当成是一个“字符容器”。但<strong>字符串和容器完全是两个不同的概念</strong>。</p><p>字符串是“文本”，里面的字符之间是强关系，顺序不能随便调换，否则就失去了意义，通常应该视为一个整体来处理。而容器是“集合”，里面的元素之间没有任何关系，可以随意增删改，对容器更多地是操作里面的单个元素<strong>。每个字符串都是一个不可变的实体</strong>。<br>但有的时候，我们也确实需要存储字符的容器，比如字节序列、数据缓冲区，这个时候，最好改用vector<char>，它的含义十分“纯粹”，只存储字符，没有 string 那些不必要的成本，用起来也就更灵活一些。</char></p><h3 id="字面量后缀"><a href="#字面量后缀" class="headerlink" title="字面量后缀"></a>字面量后缀</h3><p>C++11 为方便使用字符串，新增了一个字面量的后缀“s”，明确地表示它是 string 字符串类型，而不是 C 字符串，这就可以利用 auto 来自动类型推导，而且在其他用到字符串的地方，也可以省去声明临时字符串变量的麻烦，效率也会更高：</p><pre><code>using namespace std::literals::string_literals; //必须打开名字空间auto str = &quot;std string&quot;s; // 后缀s，表示是标准字符串，直接类型推导</code></pre><p>为了避免与用户自定义字面量的冲突，后缀“s”不能直接使用，必须用 using 打开名字空间才行，这是它的一个小缺点。</p><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>C++11 还为字面量增加了一个“原始字符串”（Raw string literal）的新表示形式，比原来的引号多了一个大写字母 R 和一对圆括号，就像下面这样</p><pre><code>auto str = R&quot;(nier:automata)&quot;; // 原始字符串：nier:automata</code></pre><p>C++ 的字符有“转义”的用法，在字符前面加上一个“\”，就可以写出“\n”“\t”来表示回车、跳格等不可打印字符。但这个特性也会带来麻烦，有时我们不想转义，只想要字符串的“原始”形式，在 C++ 里写起来就很难受了。特别是在用正则表达式的时候，由于它也有转义，两个转义效果“相乘”，就很容易出错<br>比如说，我要在正则里表示“$”，需要写成”\$“，而在 C++ 里需要对“\”再次转义，就是“\\\$”。<br>如果使用原始字符串的话，就没有这样的烦恼了，它不会对字符串里的内容做任何转义，完全保持了“原始风貌”，即使里面有再多的特殊字符都不怕</p><pre><code>auto str1 = R&quot;(char&quot;&quot;&#39;&#39;)&quot;; // 原样输出：char&quot;&quot;&#39;&#39;auto str2 = R&quot;(\r\n\t\&quot;)&quot;; // 原样输出：\r\n\t\&quot;auto str3 = R&quot;(\\\$)&quot;; // 原样输出：\\\$auto str4 = &quot;\\\\\\$&quot;; // 转义后输出：\\\$std::cout &lt;&lt; str1 &lt;&lt; std::endl;std::cout &lt;&lt; str2 &lt;&lt; std::endl;std::cout &lt;&lt; str3 &lt;&lt; std::endl;std::cout &lt;&lt; str4 &lt;&lt; std::endl;</code></pre><p>不过，想要在原始字符串里面写引号 + 圆括号的形式该怎么办呢？对于这个问题，C++ 也准备了应对的办法，就是在圆括号的两边加上最多 16 个字符的特别“界定符”（delimiter），这样就能够保证不与字符串内容发生冲突：</p><pre><code>auto str5 = R&quot;==(R&quot;(xxx)&quot;)==&quot;;// 原样输出：R&quot;(xxx)&quot;</code></pre><h3 id="字符串转换函数"><a href="#字符串转换函数" class="headerlink" title="字符串转换函数"></a>字符串转换函数</h3><p>在处理字符串的时候，我们还会经常遇到与数字互相转换的事情，以前只能用 C 函数atoi()、atol()，它们的参数是 C 字符串而不是 string，用起来就比较麻烦，于是，C++11就增加了几个新的转换函数：</p><ul><li>stoi()、stol()、stoll() 等把字符串转换成整数；</li><li>stof()、stod() 等把字符串转换成浮点数；</li><li>to_string() 把整数、浮点数转换成字符串。</li></ul><p>这几个小函数在处理用户数据、输入输出的时候，非常方便：</p><pre><code>#include &lt;cassert&gt;#include &lt;string&gt;int main() &#123;    assert(std::stoi(&quot;42&quot;) == 42); // 字符串转整数    assert(std::stol(&quot;253&quot;) == 253L); // 字符串转长整数    assert(std::stod(&quot;2.0&quot;) == 2.0); // 字符串转浮点数    assert(std::to_string(1984) == &quot;1984&quot;); // 整数转字符串    return 0;&#125;</code></pre><h3 id="字符串视图类"><a href="#字符串视图类" class="headerlink" title="字符串视图类"></a>字符串视图类</h3><p>再来说一下 string 的成本问题。它确实有点“重”，大字符串的拷贝、修改代价很高，所以我们通常都尽量用 const string&amp;，但有的时候还是无法避免（比如使用 C 字符串、获取子串）。如果你对此很在意，就有必要找一个“轻量级”的替代品<br>在 C++17 里，就有这么一个完美满足所有需求的东西，叫 string_view。顾名思义，它是一个字符串的视图，成本很低，内部只保存一个指针和长度，无论是拷贝，还是修改，都非常廉价<br>唯一的遗憾是，它只出现在 C++17 里，不过你也可以参考它的接口，自己在 C++11 里实现一个简化版本：</p><pre><code>class my_string_view final&#123;public:    using this_type = my_string_view; // 各种内部类型定义    using string_type = std::string;    using string_ref_type = const std::string&amp;;    using char_ptr_type = const char*;    using size_type = size_t;private:    char_ptr_type ptr = nullptr; // 字符串指针    size_type len = 0; // 字符串长度public:    my_string_view() = default;    ~my_string_view() = default;    my_string_view(string_ref_type str) noexcept        : ptr(str.data()), len(str.length())    &#123;&#125;public:    char_ptr_type data() const // 常函数，返回字符串指针    &#123;        return ptr;    &#125;    size_type size() const // 常函数，返回字符串长度    &#123;        return len;    &#125;&#125;;</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>string 只是解决了文本的表示和存储问题，要对它做大小写转换、判断前缀后缀、模式匹配查找等更复杂的处理，要如何做呢？<br>使用标准算法显然是不行的，因为算法的工作对象是容器，字符串与容器是两个完全不同的东西，大部分算法都无法直接套用到字符串上，所以文本处理也一直是C++ 的“软肋”，C++11 在标准库里加入了正则表达式库 regex，利用它的强大能力，就能够任意操作文本、字符串。</p><p>C++ 正则表达式主要有两个类。</p><ul><li>regex：表示一个正则表达式，是 basic_regex 的特化形式；</li><li>smatch：表示正则表达式的匹配结果，是 match_results 的特化形式。</li></ul><p>C++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串。</p><ul><li>regex_match()：完全匹配一个字符串；</li><li>regex_search()：在字符串里查找一个正则匹配；</li><li>regex_replace()：正则查找再做替换。</li></ul><p>所以，只要用 regex 定义好一个表达式，然后再调用匹配算法，就可以立刻得到结果</p><pre><code>#include &lt;regex&gt;#include &lt;string&gt;int main() &#123;    auto make_regex = [](const auto&amp; txt) // 生产正则表达式    &#123;        return std::regex(txt);    &#125;;    auto make_match = []() // 生产正则匹配结果    &#123;        return std::smatch();    &#125;;    std::string str = &quot;neir:automata&quot;; // 待匹配的字符串    auto reg = make_regex(R&quot;(^(\w+)\:(\w+)$)&quot;); // 原始字符串定义正则表达式    std::smatch what = make_match();    bool isMatch = std::regex_match(str, what, reg);    if (isMatch)     &#123;        std::cout &lt;&lt; &quot;Match found!&quot; &lt;&lt; std::endl;    &#125;     else     &#123;        std::cout &lt;&lt; &quot;No match found!&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>这里定义了两个简单的 lambda 表达式，生产正则对象，主要是为了方便用 auto 自动类型推导。然后就可以调用 regex_match() 检查字符串，函数会返回 bool 值表示是否完全匹配正则。如果匹配成功，结果存储在 what 里，可以像容器那样去访问，第 0 号元素是整个匹配串，其他的是子表达式匹配串：</p><pre><code>assert(regex_match(str, what, reg)); // 正则匹配for(const auto&amp; x : what) &#123; // for遍历匹配的子表达式    cout &lt;&lt; x &lt;&lt; &#39;,&#39;;&#125;</code></pre><p>regex_search()、regex_replace() 的用法也都差不多，很好理解:</p><pre><code>auto str = &quot;god of war&quot;s; // 待匹配的字符串auto reg = make_regex(R&quot;((\w+)\s(\w+))&quot;); // 原始字符串定义正则表达式auto what = make_match(); // 准备获取匹配的结果auto found = regex_search(str, what, reg);// 正则查找，和匹配类似assert(found); // 断言找到匹配assert(!what.empty()); // 断言有匹配结果assert(what[1] == &quot;god&quot;); // 看第一个子表达式assert(what[2] == &quot;of&quot;); // 看第二个子表达式auto new_str = regex_replace( // 正则替换，返回新字符串    str, // 原字符串不改动    make_regex(R&quot;(\w+$)&quot;), // 就地生成正则表达式对象    &quot;peace&quot; // 需要指定替换的文字);cout &lt;&lt; new str &lt;&lt; endl; // 输出god of peace</code></pre><p>这段代码的 regex_search() 搜索了两个连续的单词，然后在匹配结果里以数组下标的形式输出。<br>regex_replace() 不需要匹配结果，而是要提供一个替换字符串，因为算法是“只读”的，所以它会返回修改后的新字符串。利用这一点，就可以把它的输出作为另一个函数的输入，用“函数套函数”的形式实现“函数式编程”<br>在使用 regex 的时候，还要注意正则表达式的成本。因为正则串只有在运行时才会处理，检查语法、编译成正则对象的代价很高，所以尽量不要反复创建正则对象，能重用就重用。在使用循环的时候更要特别注意，一定要把正则提到循环体外.</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标准库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量变量</title>
      <link href="/p/c082d8df.html"/>
      <url>/p/c082d8df.html</url>
      
        <content type="html"><![CDATA[<h1 id="常量变量"><a href="#常量变量" class="headerlink" title="常量变量"></a>常量变量</h1><h2 id="const-与-volatile"><a href="#const-与-volatile" class="headerlink" title="const 与 volatile"></a>const 与 volatile</h2><p>先来看 const 吧，正如它的字面含义，const表示“常量”。最简单的用法就是，定义程序用到的数字、字符串常量，代替宏定义。</p><pre><code>const int MAX_LEN = 1024;const std::string NAME = &quot;metroid&quot;;</code></pre><p>但如果我们从 C++ 程序的生命周期角度来看的话，就会发现，它和宏定义还是有本质区别的：const 定义的常量在预处理阶段并不存在，而是直到运行阶段才会出现。<br>所以，准确地说，它实际上是运行时的“变量”，只不过不允许修改，是“只读”的（read only），叫“只读变量”更合适。<br>既然它是“变量”，那么，使用指针获取地址，再“强制”写入也是可以的。但这种做法破坏了“常量性”，绝对不提倡。还要用到另外一个关键字 volatile。</p><pre><code>// 需要加上volatile修饰，运行时才能看到效果const volatile int MAX_LEN = 1024;auto ptr = (int*)(&amp;MAX_LEN);*ptr = 2048;cout &lt;&lt; MAX_LEN &lt;&lt; endl; // 输出2048</code></pre><p>这里加入volatile主要是让编译器不要对const常量进行优化，不要进行常量传播，在编译期把常量都换成具体内容导致只读变量内容更改也不影响后面引用只读常量的地方。</p><p>现在就来看看 volatile 的作用。<br>它的含义是“不稳定的”“易变的”，在 C++ 里，表示变量的值可能会以“难以察觉”的方式被修改（比如操作系统信号、外界其他的代码），所以要禁止编译器做任何形式的优化，每次使用的时候都必须“老老实实”地去取值。现在，再去看刚才的那段示例代码，MAX_LEN 虽然是个“只读变量”，但加上了 volatile 修饰，就表示它不稳定，可能会悄悄地改变。编译器在生成二进制机器<br>码的时候，不会再去做那些可能有副作用的优化，而是用最“保守”的方式去使用MAX_LEN。<br>也就是说，编译器不会再把 MAX_LEN 替换为 1024，而是去内存里取值（而它已经通过指针被强制修改了）。所以，这段代码最后输出的是 2048，而不是最初的 1024。<br>const 理解成 read only（虽然是“只读”，但在运行阶段没有什么是不可以改变的，也可以强制写入），把变量标记成 const 可以让编译器做更好的优化。而 volatile 会禁止编译器做优化，所以除非必要，应当少用 volatile，</p><h2 id="基本的-const-用法"><a href="#基本的-const-用法" class="headerlink" title="基本的 const 用法"></a>基本的 const 用法</h2><p>在 C++ 里，除了最基本的值类型，还有引用类型和指针类型，它们加上 const 就成了常量引用和常量指针</p><pre><code>int x = 100;const int&amp; rx = x;const int* px = &amp;x;</code></pre><p>const &amp; 被称为万能引用，它可以引用任何类型，即不管是值、指针、左引用还是右引用，它都能“照单全收”。<br>而且，它还会给变量附加上 const 特性，这样“变量”就成了“常量”，只能读、禁止写。编译器会帮你检查出所有对它的写操作，发出警告，在编译阶段防止有意或者无意的修改。这样一来，const 常量用起来就非常安全了。因此，在设计函数的时候，尽可能地使用它作为入口参数，一来保证效率，二来保证安全。<br>const 用于指针的情况会略微复杂一点。常见的用法是，const 放在声明的最左边，表示指向常量的指针。这个其实很好理解，指针指向的是一个“只读变量”，不允许修改：</p><pre><code>string name = &quot;uncharted&quot;;const string* ps1 = &amp;name; // 指向常量*ps1 = &quot;spiderman&quot;; // 错误，不允许修改</code></pre><p>另外一种比较“恶心”的用法是，const 在“*”的右边，表示指针不能被修改，而指向的变量可以被修改：</p><pre><code>string* const ps2 = &amp;name; // 指向变量，但指针本身不能被修改*ps2 = &quot;spiderman&quot;; // 正确，允许修改</code></pre><p>再进一步，那就是“*”两边都有 const，你看看是什么意思呢：</p><pre><code>const string* const ps3 = &amp;name;</code></pre><p>这是一个指针常量，指向一个常量。</p><h2 id="与类相关的-const-用法"><a href="#与类相关的-const-用法" class="headerlink" title="与类相关的 const 用法"></a>与类相关的 const 用法</h2><p>刚才说的 const 用法都是面向过程的，在面向对象里，const 也很有用。</p><pre><code>class DemoClass final &#123;private:    const long MAX_SIZE = 256; // const成员变量    int m_value; // 成员变量public:    int get_value() const // const成员函数    &#123;        return m_value;    &#125;&#125;;</code></pre><p>这里 const 的用法有点特别。它被放在了函数的后面，表示这个函数是一个“常量”。（如果在前面，就代表返回值是 const int）<br>“const 成员函数”的意思并不是说函数不可修改。实际上，在 C++ 里，函数并不是变量（lambda 表达式除外），所以，“只读”对于函数来说没有任何意义。它的真正含义是：函数的执行过程是 const 的，不会修改对象的状态（即成员变量），也就是说，成员函数是一个“只读操作”。通过将成员函数标记为const，我们向使用该函数的调用者承诺，该函数不会对对象的状态进行修改。这样做的好处是可以增加代码的可读性和安全性。调用者可以在使用对象时更加放心，因为他们知道通过调用const成员函数，不会意外地修改对象的状态。</p><p>因为“常量引用”“常量指针”关联的对象是只读、不可修改的，那么也就意味着，对它的任何操作也应该是只读、不可修改的，否则就无法保证它的安全性。所以，编译器会检查const 对象相关的代码，如果成员函数不是 const，就不允许调用。<br>这其实也是对“常量”语义的一个自然延伸，既然对象是 const，那么它所有的相关操作也必然是 const。同样，保证了安全之后，编译器确认对象不会变，也可以去做更好的优化。</p><p><img src="https://s1.ax1x.com/2023/06/29/pCwW8aD.md.png" alt="pCwW8aD.md.png"></p><table><thead><tr><th></th><th>普通类型的成员函数</th><th>const 类型的成员函数</th></tr></thead><tbody><tr><td>普通对象</td><td>可以调用</td><td>可以调用</td></tr><tr><td>const 对象</td><td>不可以调用</td><td>可以调用</td></tr></tbody></table><ol><li>普通类型的成员函数：这是普通的成员函数，可以在普通对象和const对象上调用。</li><li>const类型的成员函数：这是带有const修饰的成员函数，可以在普通对象和const对象上调用。</li><li>普通对象：普通的对象，可以调用普通类型的成员函数和const类型的成员函数。</li><li>const对象：带有const修饰的对象，可以调用只有const修饰的成员函数，不能调用普通类型的成员函数（除非该成员函数也带有const修饰，因为const对象只能调用const成员函数）。</li></ol><h2 id="关键字-mutable"><a href="#关键字-mutable" class="headerlink" title="关键字 mutable"></a>关键字 mutable</h2><p>mutable 与 volatile 的字面含义有点像，但用法、效果却大相径庭。volatile 可以用来修饰任何变量，而 mutable 却只能修饰类里面的成员变量，表示变量即使是在 const 对象里，也是可以修改的。标记为 mutable 的成员不会改变对象的状态，也就是不影响对象的常量性，所以允许 const 成员函数改写 mutable 成员变量。<br>mutable 像是 C++ 给 const 对象打的一个“补丁”，让它部分可变。因为对象与普通的 int、double 不同，内部会有很多成员变量来表示状态，但因为“封装”特性，外界只能看到一部分状态，判断对象是否 const 应该由这些外部可观测的状态特征来决定。<br>比如说，对象内部用到了一个 mutex 来保证线程安全，或者有一个缓冲区来暂存数据，再或者有一个原子变量做引用计数……这些属于内部的私有实现细节，外面看不到，变与不变不会改变外界看到的常量性。这时，如果 const 成员函数不允许修改它们，就有点说不过去了。<br>所以，对于这些有特殊作用的成员变量，你可以给它加上 mutable 修饰，解除 const 的限制，让任何成员函数都可以操作它。</p><pre><code>class DemoClass final &#123;private:    mutable mutex_type m_mutex; // mutable成员变量public:    void save_data() const // const成员函数    &#123;        // do someting with m_mutex    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化和反序列化</title>
      <link href="/p/83d613f6.html"/>
      <url>/p/83d613f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>序列化，就是把内存里“活的对象”转换成静止的字节序列，便于存储和网络传输；而反序列化则是反向操作，从静止的字节序列重新构建出内存里可用的对象.下面介绍三种既简单又高效的数据交换格式：JSON、MessagePack 和ProtoBuffer。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON 是一种轻量级的数据交换格式，采用纯文本表示，所以是“human readable”，阅读和修改都很方便。由于 JSON 起源于“最流行的脚本语言”JavaScript，所以它也随之得到了广泛的应用，在Web 开发领域几乎已经成为了事实上的标准，而且还渗透到了其他的领域。比如很多数据库就支持直接存储 JSON 数据，还有很多应用服务使用 JSON 作为配置接口<br>SON 本身是个 KV 结构，很容易映射到类似 map 的关联数组操作方式，JSON 格式注重的是方便易用，在性能上没有太大的优势，所以如果选择JSON 来交换数据，通常都不会太在意性能。</p><p><strong>JSON for Modern C++</strong> 可能不是最小最快的 JSON 解析工具，但功能足够完善，而且使用方便，仅需要包含一个头文件“json.hpp”，没有外部依赖，也不需要额外的安装、编译、链接工作，适合快速上手开发</p><pre><code>git clone git@github.com:nlohmann/json.gitwget https://github.com/nlohmann/json/releases/download/v3.7.3/json.hpp</code></pre><p>JSON for Modern C++ 使用一个 json 类来表示 JSON 数据，为了避免说的时候弄混，给这个类起个别名 json_t：</p><p>json_t 的序列化功能很简单，标准容器 map 一样，用关联数组的“[]” 来添加任意数据。不需要特别指定数据的类型，它会自动推导出恰当的类型。比如，连续多个“[]”就是嵌套对象，array、vector 或者花括号形式的初始化列表就是 JSON 数组，map 或者是花括号形式的 pair 就是 JSON 对象，非常自然：</p><pre><code>json_t j; // JSON objectj[&quot;age&quot;] = 23; // &quot;age&quot;: 23j[&quot;name&quot;] = &quot;spiderman&quot;; // &quot;name&quot;: &quot;spiderman&quot;j[&quot;gear&quot;][&quot;suits&quot;] = &quot;2099&quot;; // &quot;gear&quot;: &#123;&quot;suits&quot;: &quot;2099&quot;&#125;j[&quot;jobs&quot;] = &#123;&quot;superhero&quot;&#125;; // &quot;jobs&quot;: [&quot;superhero&quot;]vector&lt;int&gt; v = &#123;1, 2, 3&#125;; // Vector containerj[&quot;numbers&quot;] = v; // &quot;numbers&quot;: [1, 2, 3]map&lt;string, int&gt; m = &#123;&#123;"one", 1&#125;, &#123;"two", 2&#125;&#125;; // Map container initialization listj[&quot;kv&quot;] = m; // &quot;kv&quot;: &#123;&quot;one&quot;: 1, &quot;two&quot;: 2&#125;</code></pre><p>添加完之后，用成员函数 dump() 就可以序列化，得到它的 JSON 文本形式。默认的格式是紧凑输出，没有缩进，如果想要更容易阅读的话，可以加上指示缩进的参数：</p><pre><code>cout &lt;&lt; j.dump() &lt;&lt; endl; // 序列化，无缩进cout &lt;&lt; j.dump(2) &lt;&lt; endl;</code></pre><p>json_t 的反序列化功能同样也很简单，只要调用静态成员函数 parse() 就行，直接得到JSON 对象，而且可以用 auto 自动推导类型：</p><pre><code>string str = R&quot;(&#123; // JSON文本，原始字符串    &quot;name&quot;: &quot;peter&quot;,    &quot;age&quot; : 23,    &quot;married&quot; : true&#125;)&quot;;auto j = json_t::parse(str); // 从字符串反序列化assert(j[&quot;age&quot;] == 23); // 验证序列化是否正确assert(j[&quot;name&quot;] == &quot;peter&quot;);</code></pre><p>json_t 使用异常来处理解析时可能发生的错误，如果你不能保证 JSON 数据的完整性，就要使用 try-catch 来保护代码，防止错误数据导致程序崩溃：</p><pre><code>auto txt = &quot;bad:data&quot;s; // 不是正确的JSON数据try // try保护代码&#123;    auto j = json_t::parse(txt);// 从字符串反序列化&#125;catch(std::exception&amp; e) // 捕获异常&#123;    cout &lt;&lt; e.what() &lt;&lt; endl;&#125;</code></pre><h2 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h2><p>它也是一种轻量级的数据交换格式，与 JSON 的不同之处在于它不是纯文本，而是二进制。所以 MessagePack 就比 JSON 更小巧，处理起来更快，不过也就没有 JSON 那么直观、易读、好修改了。<br>由于二进制这个特点，MessagePack 也得到了广泛的应用，著名的有 Redis、Pinterest。MessagePack 支持几乎所有的编程语言</p><pre><code>git clone git@github.com:msgpack/msgpack-c.gitg++ msgpack.cpp -std=c++14 -I../common/include -o a.out</code></pre><p>和 JSON for Modern C++ 一样，msgpack-c 也是仅头文件的库（head only），只要包含一个头文件“msgpack.hpp”就行了，不需要额外的编译链接选项（C 版本需要用“-lmsgpackc”链接）<br>但 MessagePack 的设计理念和 JSON 是完全不同的，它没有定义 JSON 那样的数据结构，而是比较底层，只能对基本类型和标准容器序列化 &#x2F; 反序列化，需要自己去组织、整理要序列化的数据。</p><p>vector 容器来举个例子，调用 pack() 函数序列化为 MessagePack 格式：</p><pre><code>vector&lt;int&gt; v = &#123;1,2,3,4,5&#125;; // vector容器msgpack::sbuffer sbuf; // 输出缓冲区msgpack::pack(sbuf, v); // 序列化</code></pre><p>它的用法不像 JSON 那么简单直观，必须同时传递序列化的输出目标和被序列化的对象。输出目标 sbuffer 是个简单的缓冲区，可以把它理解成是对字符串数组的封装，和vector<char>很像，也可以用 data() 和 size() 方法获取内部的数据和长度<br>除了 sbuffer，你还可以选择另外的 zbuffer、fbuffer。它们是压缩输出和文件输出，和sbuffer 只是格式不同，用法是相同的。</char></p><p>MessagePack 反序列化的时候略微麻烦一些，要用到函数 unpack() 和两个核心类：object_handle 和 object。<br>函数 unpack() 反序列化数据，得到的是一个 object_handle，再调用 get()，就是object：</p><pre><code>// 反序列化auto handle = msgpack::unpack(sbuf.data(), sbuf.size()); // 输入二进制数据auto obj = handle.get(); // 得到反序列化对象</code></pre><p>这个 object 是 MessagePack 对数据的封装，相当于 JSON for Modern C++ 的 JSON对象，但你不能直接使用，必须知道数据的原始类型，才能转换还原：</p><pre><code>// vector容器vector&lt;int&gt; v2; // 转换反序列化的数据obj.convert(v2); // 算法比较两个容器assert(std::equal(begin(v), end(v), begin(v2)));</code></pre><p>因为 MessagePack 不能直接打包复杂数据，所以用起来就比 JSON 麻烦一些，必须自己把数据逐个序列化，连在一起才行。<br>但是MessagePack 又提供了一个 packer 类，可以实现串联的序列化操作，简化代码：</p><pre><code>msgpack::sbuffer sbuf; // 输出缓冲区msgpack::packer&lt;decltype(sbuf)&gt; packer(sbuf); // 专门的序列化对象packer.pack(10).pack(&quot;monado&quot;s).pack(vector&lt;int&gt;&#123;1, 2, 3&#125;); // 连续序列化多个数据</code></pre><p>对于多个对象连续序列化后的数据，反序列化的时候可以用一个偏移量（offset）参数来同样连续操作：</p><pre><code>for (decltype(sbuf.size()) offset = 0; // 初始偏移量是0    offset != sbuf.size();) &#123; // 直至反序列化结束    auto handle = msgpack::unpack( // 反序列化        sbuf.data(), sbuf.size(), offset); // 输入二进制数据和偏移量    auto obj = handle.get(); // 得到反序列化对象&#125;</code></pre><p>但这样还是比较麻烦，能不能像 JSON 那样，直接对类型序列化和反序列化呢？MessagePack 为此提供了一个特别的宏：MSGPACK_DEFINE，把它放进你的类定义里，就可以像标准类型一样被 MessagePack 处理。<br>下面定义了一个简单的 Book 类：</p><pre><code>class Book final // 自定义类&#123;public:    int id;    string title;    set&lt;string&gt; tags;public:    MSGPACK_DEFINE(id, title, tags); // 实现序列化功能的宏&#125;;</code></pre><p>它可以直接用于 pack() 和 unpack()，基本上和 JSON 差不多了：</p><pre><code>Book book1 = &#123;1, &quot;1984&quot;, &#123;&quot;a&quot;, &quot;b&quot;&#125;&#125;; // 自定义类msgpack::sbuffer sbuf; // 输出缓冲区msgpack::pack(sbuf, book1); // 序列化auto obj = msgpack::unpack( // 反序列化    sbuf.data(), sbuf.size()).get(); // 得到反序列化对象Book book2;obj.convert(book2); // 转换反序列化的数据assert(book2.id == book1.id);assert(book2.tags.size() == 2);cout &lt;&lt; book2.title &lt;&lt; endl;</code></pre><p>使用 MessagePack 的时候，也要注意数据不完整的问题，必须要用 try-catch 来保护代码，捕获异常：</p><pre><code>auto txt = &quot;&quot;s; // 空数据try // try保护代码&#123;    auto handle = msgpack::unpack( // 反序列化        txt.data(), txt.size());&#125;catch(std::exception&amp; e) // 捕获异常&#123;    cout &lt;&lt; e.what() &lt;&lt; endl;&#125;</code></pre><h2 id="ProtoBuffer"><a href="#ProtoBuffer" class="headerlink" title="ProtoBuffer"></a>ProtoBuffer</h2><p>PB 也是一种二进制的数据格式，但毕竟是工业级产品，所以没有 JSON 和 MessagePack那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库</p><pre><code>apt-get install protobuf-compilerapt-get install libprotobuf-devg++ protobuf.cpp -std=c++14 -lprotobuf -o a.out</code></pre><p>PB 的另一个特点是数据有“模式”（schema），必须要先写一个 IDL（InterfaceDescription Language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。</p><p>这个特点既有好处也有坏处：一方面，接口就是清晰明确的规范文档，沟通交流简单无歧义；而另一方面，就是缺乏灵活性，改接口会导致一连串的操作，有点繁琐</p><pre><code>syntax = &quot;proto2&quot;; // 使用第2版package sample; // 定义命名空间message Vendor &#123; // 定义消息    required uint32 id = 1; // required表示必须字段    required string name = 2; // 有int32/string等基本类型    required bool valid = 3; // 需要指定字段的序号，序列化时用    optional string tel = 4; // optional字段可以没有&#125;</code></pre><p>有了接口定义文件，需要再用 protoc 工具生成对应的 C++ 源码，然后把源码文件加入自己的项目中，就可以使用了：</p><pre><code>protoc --cpp_out=. sample.proto // 生成C++代码</code></pre><p>一些重要的接口：</p><ul><li>字段名会生成对应的 has&#x2F;set 函数，检查是否存在和设置值；</li><li>IsInitialized() 检查数据是否完整（required 字段必须有值）；</li><li>DebugString() 输出数据的可读字符串描述；</li><li>ByteSize() 返回序列化数据的长度；</li><li>SerializeToString() 从对象序列化到字符串；</li><li>ParseFromString() 从字符串反序列化到对象；</li><li>SerializeToArray()&#x2F;ParseFromArray() 序列化的目标是字节数组。</li></ul><p>下面示范 PB 的部分用法：</p><pre><code>using vendor_t = sample::Vendor; // 类型别名vendor_t v; // 声明一个PB对象assert(!v.IsInitialized()); // required等字段未初始化v.set_id(1); // 设置每个字段的值v.set_name(&quot;sony&quot;);v.set_valid(true);assert(v.IsInitialized()); // required等字段都设置了，数据完整assert(v.has_id() &amp;&amp; v.id() == 1);assert(v.has_name() &amp;&amp; v.name() == &quot;sony&quot;);assert(v.has_valid() &amp;&amp; v.valid());cout &lt;&lt; v.DebugString() &lt;&lt; endl; // 输出调试字符串string enc;v.SerializeToString(&amp;enc); // 序列化到字符串vendor_t v2;assert(!v2.IsInitialized());</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理</title>
      <link href="/p/28877bf.html"/>
      <url>/p/28877bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>C++ 处理错误的标准方案是“异常”（exception）。虽然它已经在 Java、C#、Python等语言中得到了广泛的认可和应用，但在 C++ 里却存在诸多争议。异常只是 C++ 为了处理错误而提出的一种解决方案，当然也不会是唯一的一种。<br>在 C++ 之前，处理异常的基本手段是“错误码”。函数执行后，需要检查返回值或者全局的 errno，看是否正常，如果出错了，就执行另外一段代码处理错误：</p><pre><code>int n = read_data(fd, ...); // 读取数据if (n == 0) &#123;    ... // 返回值不太对，适当处理&#125;if (errno == EAGAIN) &#123;    ... // 适当处理错误&#125;</code></pre><p>这种做法很直观，但也有一个问题，那就是正常的业务逻辑代码与错误处理代码混在了一起，看起来很乱<br>错误码还有另一个更大的问题：它是可以被忽略的。完全可以不处理错误，“假装”程序运行正常，继续跑后面的代码，这就可能导致严重的安全隐患。</p><p>异常就是针对错误码的缺陷而设计的，它有三个特点。</p><ol><li>异常的处理流程是完全独立的，throw 抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch 块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。</li><li>异常是绝对不能被忽略的，必须被处理。如果你有意或者无意不写 catch 捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch 块。如果实在没有，那就会导致程序立即停止运行。</li><li>异常可以用在错误码无法使用的场合，这也算是 C++ 的“私人原因”。因为它比 C 语言多了构造 &#x2F; 析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的 errno 实在是“太不优雅”了，与 C++ 的理念不符，所以也必须使用异常来报告错误</li></ol><h2 id="异常的用法和使用方式"><a href="#异常的用法和使用方式" class="headerlink" title="异常的用法和使用方式"></a>异常的用法和使用方式</h2><p>C++ 里异常的用法：用 try 把可能发生异常的代码“包”起来，然后编写 catch 块捕获异常并处理。<br>刚才的错误码例子改用异常，就会变得非常干净清晰：</p><pre><code>try&#123;    int n = read_data(fd, ...); // 读取数据，可能抛出异常    ... // do some right thing&#125;catch(...)&#123;    ... // 集中处理各种错误情况&#125;</code></pre><p>C++ 里对异常的定义非常宽松，任何类型都可以用 throw 抛出，也就是说，你可以直接把错误码（int）、或者错误消息（char*、string）抛出，catch 也能接住，然后处理，但是C++ 已经为处理异常设计了一个配套的异常类型体系，定义在标准库的 <stdexcept> 头文件里。</stdexcept></p><p><a href="https://s1.ax1x.com/2023/07/03/pCrxVKI.png">pCrxVKI.png</a></p><p>标准异常的继承体系有点复杂，最上面是基类 exception，下面是几个基本的异常类型，比如 bad_alloc、bad_cast、runtime_error、logic_error，再往下还有更细致的错误类型，像 runtime_error 就有 range_error、overflow_error，等等</p><pre><code>class my_exception : public std::runtime_error&#123;public:    using this_type = my_exception; // 给自己起个别名    using super_type = std::runtime_error; // 给父类也起个别名public:    my_exception(const char* msg): // 构造函数        super_type(msg) // 别名也可以用于构造    &#123;&#125;    my_exception() = default; // 默认构造函数    ~my_exception() = default; // 默认析构函数private:    int code = 0; // 其他的内部私有数据&#125;;</code></pre><p>在抛出异常的时候，最好不要直接用 throw 关键字，而是要封装成一个函数，通过引入一个“中间层”来获得更多的可读性、安全性和灵活性。<br>抛异常的函数不会有返回值，所以应该用第 4 节课里的“属性”做编译阶段优化：</p><pre><code>[[noreturn]] // 属性标签void raise(const char* msg) // 函数封装throw，没有返回值&#123;    throw my_exception(msg); // 抛出异常，也可以有更多的逻辑&#125;</code></pre><p>使用 catch 捕获异常的时候也要注意，C++ 允许编写多个 catch 块，捕获不同的异常，再分别处理。但是，异常只能按照 catch 块在代码里的顺序依次匹配，而不会去找最佳匹配。<br>写 catch 块就像是写一个标准函数，所以入口参数也应当使用“const &amp;”的形式，避免对象拷贝的代价：</p><pre><code>try&#123;    raise(&quot;error occurred&quot;); // 函数封装 throw，抛出异常&#125;catch (const std::exception&amp; e) // const &amp; 捕获异常，可以用基类&#123;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl; // what() 是 exception 的虚函数&#125;</code></pre><p>关于 try-catch，还有一个很有用的形式：function-try。这个形式简单清晰，早在 C++98 的时候就已经出现。所谓 function-try，就是把整个函数体视为一个大 try 块，而 catch 块放在后面，与函数体同级并列</p><pre><code>void some_function()try // 函数名之后直接写 try 块&#123;    // Function body ...&#125;catch(...) // catch 块与函数体同级并列&#123;    // Exception handling code ...&#125;</code></pre><p>这样做的好处很明显，不仅能够捕获函数执行过程中所有可能产生的异常，而且少了一级缩,进层次，处理逻辑更清晰</p><h2 id="谨慎使用异常"><a href="#谨慎使用异常" class="headerlink" title="谨慎使用异常"></a>谨慎使用异常</h2><p>异常的抛出和处理需要特别的栈展开（stack unwind）操作，如果异常出现的位置很深，但又没有被及时处理，或者频繁地抛出异常，就会对运行性能产生很大的影响。这个时候，程序全忙着去处理异常了，正常逻辑反而被搁置。<br>对于正常的返回值，或者不太严重、可以重试 &#x2F; 恢复的错误，不建议使用异常，把它们归到正常的流程里。比如说字符串未找到（不是错误）、数据格式不对（轻微错误）、数据库正忙（可重试错误），这样的错误比较轻微，而且在业务逻辑里会经常出现，如果你用异常处理，就会“小题大做”，影响性能，几个应当使用异常的判断准则：</p><ol><li>不允许被忽略的错误；</li><li>极少数情况下才会发生的错误；</li><li>严重影响正常流程，很难恢复到正常状态的错误；</li><li>无法本地处理，必须“穿透”调用栈，传递到上层才能被处理的错误。</li></ol><p>比如说构造函数，如果内部初始化失败，无法创建，那后面的逻辑也就进行不下去了，所以这里就可以用异常来处理。<br>再比如，读写文件，通常文件系统很少会出错，总会成功，如果用错误码来处理不存在、权限错误等，就显得太啰嗦，这时也应该使用异常。<br>相反的例子就是 socket 通信。因为网络链路的不稳定因素太多，收发数据失败简直是“家常便饭”。虽然出错的后果很严重，但它出现的频率太高了，使用异常会增加很多的处理成本，为了性能考虑，还是检查错误码重试比较好<br>只要开启了异常，即使不使用异常，编译出的二进制代码通常也会膨胀。</p><h2 id="保证不抛出异常"><a href="#保证不抛出异常" class="headerlink" title="保证不抛出异常"></a>保证不抛出异常</h2><p>C++ 标准提出了一个新的编译阶段指令：noexcept，但它也有一点局限。noexcept 专门用来修饰函数，告诉编译器：这个函数不会抛出异常。编译器看到noexcept，就得到了一个“保证”，就可以对函数做优化，不去加那些栈展开的额外代码，消除异常处理的成本。<br>和 const 一样，noexcept 要放在函数后面：</p><pre><code>void func_noexcept() noexcept // 声明绝不会抛出异常&#123;    std::cout &lt;&lt; &quot;noexcept&quot; &lt;&lt; std::endl;&#125;</code></pre><p>不过，noexcept 只是做出了一个“不可靠的承诺”，不是“强保证”，编译器无法彻底检查它的行为，标记为 noexcept 的函数也有可能抛出异常：</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生命周期和编程范式</title>
      <link href="/p/d33db4ae.html"/>
      <url>/p/d33db4ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期和编程范式"><a href="#生命周期和编程范式" class="headerlink" title="生命周期和编程范式"></a>生命周期和编程范式</h1><h2 id="C-程序的生命周期"><a href="#C-程序的生命周期" class="headerlink" title="C++ 程序的生命周期"></a>C++ 程序的生命周期</h2><p>从软件工程的视角来看，一个 C++ 程序的生命周期是“瀑布”形态的;瀑布模型”把软件的生命周期分成了多个阶段，每个阶段之间分工明确，相互独立，而且有严格的先后次序，是一个经典的开发模型。虽然它已经不再适合瞬息万变的互联网产业了，但仍然有许多值得借鉴和参考的地方。 C++ 程序的生命周期也可以划分出几个明确的阶段，阶段之间顺序衔接，使用类似的方法，就可以更好地理解 C++ 程序的运行机制，帮助我们写出更好的代码.<br>因为 C++ 程序本身就已经处在“开发”阶段了，所以不会有“需求分析”“设计”这样的写文档过程。所以，一个 C++ 程序从“诞生”到“消亡”，要经历这么几个阶段：编码（Coding）、预处理（Pre-processing）、编译（Compiling）和运行（Running）</p><h3 id="C-程序的四个阶段"><a href="#C-程序的四个阶段" class="headerlink" title="C++ 程序的四个阶段"></a>C++ 程序的四个阶段</h3><p>在C++程序的生命周期中，编码阶段是非常重要的阶段，它决定了程序的质量和后续阶段的基础。在编码阶段，我们需要按照规范进行编写代码，包括遵循语言规范、设计文档、代码规范、注释规范、设计模式和编程习惯等。</p><p>接下来是预处理阶段，它是C&#x2F;C++独有的阶段。预处理阶段通过预处理器对源代码进行处理，包括文本替换和预处理编程。预处理指令如#include、#define、#if等在这个阶段发挥作用。</p><p>然后是编译阶段，它将经过预处理的源代码进行编译和链接，生成可在计算机上运行的二进制机器码。编译器会进行词法分析、语法解析、目标码生成和优化。在编译阶段，编译器还会进行静态检查，检查程序的语法和语义是否正确。在这个阶段，我们可以控制编译器的行为，实现模板元编程等高级用法。</p><p>完成编译后，进入运行阶段，C++程序被载入内存，并由CPU逐条执行，形成动态的进程。在运行阶段，我们可以进行调试、日志追踪、性能分析等操作，收集动态数据并调整设计思路，然后回到编码阶段继续开发。</p><p>C++程序生命周期的四个阶段类似于软件工程中的瀑布模型，每个阶段有着明确的职责，并且前一个阶段的输出作为后一个阶段的输入。然而，我们要注意软件工程中的蝴蝶效应和混沌理论，即尽早发现和解决Bug的重要性。因此，在编码、预处理和编译阶段应该花费更多的时间，消除Bug，优化代码，尽量避免在运行阶段才暴露问题，即“把问题扼杀在萌芽期”</p><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。编程范式和编程语言不同，有的范式只能用于少数特定的语言，有的范式却适用于大多数语<br>言；有的语言可能只支持一种范式，有的语言却可能支持多种范式。C++ 是一种多范式的编程语言。具体来说，现代<br>C++（11&#x2F;14 以后）支持“面向过程”“面向对象”“泛型”“模板元”“函数式”这五<br>种主要的编程范式。其中，“面向过程”“面向对象”是基础，支撑着后三种范式。</p><p><a href="https://imgse.com/i/pCwiPgA"><img src="https://s1.ax1x.com/2023/06/28/pCwiPgA.png" alt="pCwiPgA.png"></a></p><p>在C++中，<strong>面向过程</strong>是一种基本的编程范式，它的核心思想是通过顺序执行语句和子程序来完成任务。面向过程体现在C++中，包括变量声明、表达式、分支&#x2F;循环&#x2F;跳转语句等。</p><p><strong>面向对象</strong>是另一种基本的编程范式，它的核心思想是通过抽象和封装将任务分解为高内聚低耦合的对象，这些对象通过通信和协作来完成任务。在C++中，面向对象范式包括类、public、private、virtual、this等关键字，以及构造函数、析构函数、友元函数等概念。</p><p><strong>泛型编程</strong>是一种在C++中流行的范式，它的核心思想是一切皆为类型，通过模板来实现参数化类型和代码复用。在C++中，泛型编程的基础是template关键字，标准库中包含了各种泛型容器和算法，如vector、map、sort等。</p><p><strong>模板元编程</strong>类似于泛型编程，但更高级和复杂。它的核心思想是对编译时可见的类型进行类型运算，代码只能由编译器执行，而不能在运行时由CPU执行。在C++中，模板元编程通常以库的形式使用，如type_traits、enable_if等。</p><p><strong>函数式编程</strong>几乎和面向过程一样古老，但直到近年才在C++中得到广泛关注。函数式编程的核心思想是无副作用的数学函数，通过连续或嵌套的函数调用来处理数据。在C++中，函数式编程在C++11引入Lambda表达式后变得更加强大。</p><p>这五种编程范式基本涵盖了C++语言和标准库的各个方面，尽管它们之间有重叠，但在思想、关键字、实现机制和运行阶段等方面存在着显著差异。选择哪种编程范式取决于你的实际工作需求。通常建议掌握面向过程和面向对象，然后根据应用类型考虑深入学习泛型、函数式编程或模板元编程。</p><p>对于开发面向用户的应用程序，掌握面向过程、面向对象和泛型编程通常就足够了。对于开发面向程序员的库，深入了解泛型编程和模板元编程可以优化库的接口和性能。如果你对挑战和高级编程感兴趣，那么模板元编程将是一个有趣的选择。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板元编程</title>
      <link href="/p/a44af387.html"/>
      <url>/p/a44af387.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h1><h2 id="编译期计算"><a href="#编译期计算" class="headerlink" title="编译期计算"></a>编译期计算</h2><p>C++ 模板是图灵完全的，这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。<br>当然，这只是理论上的结论。从实际的角度，我们并不想、也不可能在编译期完成所有的计算，更不用说编译期的编程是很容易让人看不懂的。即便如此，我们也还是需要了解一下模板元编程的基本概念：它仍然有一些实用的场景，并且在实际的工程中你也可能会遇到这样的代码。</p><pre><code>template &lt;int n&gt;struct factorial &#123;    static const int value = n * factorial&lt;n - 1&gt;::value;&#125;;template &lt;&gt;struct factorial&lt;0&gt; &#123;    static const int value = 1;&#125;;</code></pre><p>上面定义了一个递归的阶乘函数。</p><pre><code>0! = 1n! = n × (n − 1)!</code></pre><p>除了顺序有特定的要求——先定义，才能特化——再加语法有点特别，代码基本上就是这<br>个数学定义的简单映射了。<br>我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（printf(“%d\n”, actorial&lt;10&gt;::value);）在 x86-64下的编译结果：</p><pre><code>.string &quot;%d\n&quot;main:    push rbp    mov rbp, rsp    mov esi, 3628800    mov edi, OFFSET FLAT:.LC0    mov eax, 0    call printf    mov eax, 0    pop rbp    ret</code></pre><p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。<br>如果我们传递一个负数给 factorial 呢？这时的结果就应该是编译期间的递归溢出。如<br>GCC 会报告：</p><pre><code>fatal error: template instantiation depth exceeds maximum of 900 (use - ftemplate-depth= to increase the maximum)</code></pre><p>如果把 int 改成 unsigned，不同的编译器和不同的标准选项会导致不同的结果。有些情况下错误信息完全不变，有些情况下则会报负数不能转换到 unsigned。通用的解决方案是使用 static_assert，确保参数永远不会是负数。</p><pre><code>template &lt;int n&gt;struct factorial &#123;    static_assert(n &gt;= 0, &quot;Arg must be non-negative&quot;);    static const int value = n * factorial&lt;n - 1&gt;::value;&#125;;</code></pre><p>要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p><h2 id="编译期类型推导"><a href="#编译期类型推导" class="headerlink" title="编译期类型推导"></a>编译期类型推导</h2><p>C++ 标准库在 <type_traits> 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）[2]。和上一节给出的例子相似，这些特点既是类型，又是常值<br>针对布尔值有两个额外的类型定义：</type_traits></p><pre><code>typedef std::integral_constant&lt;bool, true&gt; true_type;typedef std::integral_constant&lt;bool, false&gt; false_type;</code></pre><p>这两个标准类型 true_type 和 false_type 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p><pre><code>template &lt;typename T&gt;class SomeContainer &#123;public:    // ...    static void destroy(T* ptr)    &#123;        _destroy(ptr, is_trivially_destructible&lt;T&gt;());    &#125;private:    static void _destroy(T* ptr, true_type)    &#123;        // Do nothing for trivially destructible types    &#125;    static void _destroy(T* ptr, false_type)    &#123;        ptr-&gt;~T();  // Explicitly call the destructor for non-trivially destructible types    &#125;&#125;;</code></pre><p>类似上面，很多容器类里会有一个 destroy 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 true_type，要么是 false_type。如果要得到布尔值的话，当然使用 is_trivially_destructible<T>::value 就可以，但此处不需要。我们需要的是，使用 () 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</T></p><p>像 is_trivially_destructible 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：</p><pre><code>is_arrayis_enumis_functionis_pointeris_referenceis_consthas_virtual_destructor…</code></pre><p>这些特殊行为判断可以是像上面这样用于决定不同的重载，也可以是直接用在模板参数甚至代码里<br>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 remove_const 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p><pre><code>template &lt;class T&gt;struct remove_const &#123;    typedef T type;&#125;;template &lt;class T&gt;struct remove_const&lt;const T&gt; &#123;    typedef T type;&#125;;</code></pre><p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对const string&amp; 应用 remove_const，就会得到 string&amp;，即，remove_const&lt;const string&amp;&gt;::type 等价于 string&amp;。<br>这里有一个细节要注意一下，如果对 const char* 应用 remove_const 的话，结果还是 const char<em>。原因是，const char</em> 是指向 const char 的指针，而不是指向char 的 const 指针。如果我们对 char * const 应用 remove_const 的话，还是可以得到 char* 的。</p><p>如果你觉得写 is_trivially_destructible<T>::value 和remove_const<T>::type 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，<br>前者有增加 _v 的编译时常量，后者有增加 _t 的类型别名：</T></T></p><pre><code>template &lt;class T&gt;inline constexpr bool is_trivially_destructible_v = is_trivially_destructible&lt;T&gt;::value;template &lt;class T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type;</code></pre><p>需要 trait 模板的结果数值和类型时，使用带 _v 和 _t 后缀的模板可能会更方便，尤其是带 _t 后缀的类型转换模板。</p><h2 id="通用的-fmap-函数模板"><a href="#通用的-fmap-函数模板" class="headerlink" title="通用的 fmap 函数模板"></a>通用的 fmap 函数模板</h2><p>map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map [3] 和 reduce [4] 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 map 了）</p><pre><code>template &lt;    template &lt;typename, typename&gt; class OutContainer = vector,    typename F, class R&gt;auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)&#123;    typedef decay_t&lt;decltype(f(*inputs.begin()))&gt; result_type;    OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;    for (auto&amp;&amp; item : inputs) &#123;        result.push_back(f(item));    &#125;    return result;&#125;</code></pre><p>用 decltype 来获得用 f 来调用 inputs 元素的类型<br>用 decay_t 来把获得的类型变成一个普通的值类型；<br>缺省使用 vector 作为返回值的容器，但可以通过模板参数改为其他容器；<br>使用基于范围的 for 循环来遍历 inputs，对其类型不作其他要求<br>存放结果的容器需要支持 push_back 成员函数</p><p>下面的代码可以验证其功能：</p><pre><code>int add_1(int x)&#123;    return x + 1;&#125;int main()&#123;    std::vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;    auto result = fmap(add_1, v);    return 0;&#125;</code></pre><p>在 fmap 执行之后，我们会在 result 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解标签</title>
      <link href="/p/acd745d4.html"/>
      <url>/p/acd745d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="注解标签"><a href="#注解标签" class="headerlink" title="注解标签"></a>注解标签</h1><p>在C++98&#x2F;03时代，不同的编译器使用不同的注解为代码增加了一些额外的说明，比如常见的#pragma, __declspec, __attribute等。从C++11开始，新的语言标准统一制定了一些常用的注解标签，所以在这里介绍几种常用的。<br>使用注解标签得语法如下：</p><pre><code>[[attribute]] types/functions/enums/etc</code></pre><p>这些标签可以修饰任意类型、函数或者enumeration，在C++17之前不能修饰命名空间和 enumerator，在C++17后这个限制也被取消。</p><h2 id="C-98-x2F-03得enumeration和C-11的enumerator"><a href="#C-98-x2F-03得enumeration和C-11的enumerator" class="headerlink" title="C++98&#x2F;03得enumeration和C++11的enumerator"></a>C++98&#x2F;03得enumeration和C++11的enumerator</h2><p>enumeration和enumerator，前者是指从C时代就存在的不限定作用域的枚举。例如下面的枚举类型就是一个enumeration</p><pre><code>// 一个enumeration例子enum Color&#123;    black,    white,    red&#125;;// 无法编译通过bool white = true;</code></pre><p>这种枚举类型被称为不限定作用域枚举，因为一旦定义了这样的一种枚举，在其所在的作用域内就不能再定义与之同名的变量了。<br>而enumerator指的是从C++11开始引入的枚举类，例如如下形式定义的枚举变量：</p><pre><code>// 一个enumerator示例enum class Color&#123;    black,    white,    red&#125;;// 可以编译通过bool white = true;</code></pre><p>此时，由于枚举值white对外部不可见（需要使用Color::white引用），所以可以定义一个同名的white变量。<br>这种枚举变量被称为限定作用域枚举。</p><h2 id="注解标签-1"><a href="#注解标签-1" class="headerlink" title="注解标签"></a>注解标签</h2><h3 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h3><p>C++11引入的常用注解标签有 <code>[[noreturn]]</code>，这个注解的含义是告诉编译器某个函数没有返回值。 例如：</p><pre><code>[[noreturn]] void function1()</code></pre><p>这个标签一般在设计一些系统函数时使用，例如std::abort()和std::exit()。</p><h3 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h3><p>C++14引入了<code>[[deprecated]]</code>标签来表示一个函数或者类型等已经被弃用，在使用这些被弃用的函数或类型并编译时，编译器会发出相应的警告，也可以使用以下语法，给出编译时的具体警告或者出错信息。</p><pre><code>[[deprecated(&quot;use function3 instead&quot;)]] void function2() &#123;&#125;void function3() &#123;&#125;</code></pre><h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>C++17提供的注解<code>[[fallthrough]]</code>，用于 switch-case语句中，在某个case执行完毕后如果没有break语句，则编译器可能会给出警告，但这可能是开发者有意为之的，为了让编译器知道开发者的意图，可以在需要某个case分支被“贯穿”的地方显式设置<code>[[fallthrough]]</code>标记。</p><p>来看看源代码：</p><pre><code>#ifndef __fallthrough // [#if (!defined(_MSVC_LANG) || _MSVC_LANG &lt; 201703l) // [    __inner_fallthrough_dec    #define __fallthrough __inner_fallthrough#else // ][    #define __fallthrough [[fallthrough]]#endif // ]#endif // ]</code></pre><p>使用示例：</p><pre><code>int main(void)&#123;    switch (1)    &#123;    case 1:        function1();        // 缺少break，没有fallthrough标注，        // 可能是一个逻辑错误，编译器会给出警告    case 2:        function2();        __fallthrough;        // 这里缺少break，但有该标注，说明是开发者有意为之    &#125;&#125;</code></pre><h3 id="nodiscard"><a href="#nodiscard" class="headerlink" title="nodiscard"></a>nodiscard</h3><p>C++17提供的注解<code>[[nodiscard]]</code>，一般用于修饰函数，告诉函数调用者必须关注该函数的返回值（即不能丢弃该函数的返回值）。如果函数调用者未将该函数的返回值赋给一个变量，则编译器会给出一个警告。</p><p>比如网络连接函数connect()是根据返回值来说明是否建立成功，则为了防止调用者在使用时直接将该值丢弃，就是用该标记。</p><pre><code>[[nodiscard]] int connect(const char* address, short port) &#123;&#125;</code></pre><h3 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="maybe_unused"></a>maybe_unused</h3><p>C++17提供的注解<code>[[maybe_unused]]</code>在通常情况下，编译器会对程序代码中未使用的函数或变量给出警告，另一些编译器干脆不允许通过编译。在C++17之前，为了消除这些未使用的变量带来的编译警告或错误，要么修改编译器的警告选项设置，要么定义一个类似于UNREFERENCED_PARAMETER的宏来显式调用这些未使用的变量依次，以消除编译警告：</p><pre><code>#define UNREFERENCED_PARAMETER(x) xint APIENTRY wWinMain(HINSTANCE hInstance,    HINSTANCE hPrevInstance,    LPWSTRlpCmdLine,    intnCmdShow)&#123;    UNREFERENCED_PARAMETER(hPrevInstance);    UNREFERENCED_PARAMETER(lpCmdLine);&#125;</code></pre><p>上面是一个Win32程序的结构，其中的函数参数hPrevInstance 和lpCmdLine一般不会用到，为了消除警告，定义了一个宏，造成这两个参数被使用的假象。</p><p>有了<code>[[maybe_unused]]</code>后，就不再需要这些宏来欺骗编译器了。</p><p>int APIENTRY wWinMain(HINSTANCE hInstance,<br>    [[maybe_unused]] HINSTANCE hPrevInstance,<br>    [[maybe_unused]] LPWSTRlpCmdLine,<br>    intnCmdShow)<br>{<br>}</p><h2 id="GCC非标准扩展"><a href="#GCC非标准扩展" class="headerlink" title="GCC非标准扩展"></a>GCC非标准扩展</h2><p>在“属性”也支持非标准扩展，允许以类似名字空间的方式使用编译器自己的一些“非官方”属性，比如，GCC 的属性都在“gnu::”里。下面列出几个比较有用的（全部属性可参考GCC 文档）。<br>deprecated：与 C++14 相同，但可以用在 C++11 里。<br>unused：用于变量、类型、函数等，表示虽然暂时不用，但最好保留着，因为将来可能会用。<br>constructor：函数会在 main() 函数之前执行，效果有点像是全局对象的构造函数。<br>destructor：函数会在 main() 函数结束之后执行，有点像是全局对象的析构函数。<br>always_inline：要求编译器强制内联函数，作用比 inline 关键字更强。<br>hot：标记“热点”函数，要求编译器更积极地优化。<br>这几个属性的含义还是挺好理解的吧，我拿“unused”来举个例子。<br>在没有这个属性的时候，如果有暂时用不到的变量，我们只能用“(void) var;”的方式假装<br>用一下，来“骗”过编译器，属于“不得已而为之”的做法。<br>那么现在，我们就可以用“unused”属性来清楚地告诉编译器：这个变量我暂时不用，请<br>不要过度紧张，不要发出警告来烦我：</p><pre><code>[[gnu::unused]] // 声明下面的变量暂不使用，不是错误int nouse;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型推断</title>
      <link href="/p/5639.html"/>
      <url>/p/5639.html</url>
      
        <content type="html"><![CDATA[<h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><h2 id="模板型别推导"><a href="#模板型别推导" class="headerlink" title="模板型别推导"></a>模板型别推导</h2><p>模板的型别推导是现代c++最广泛应用的特性之一————————auto的基础，了解作为auto基础的模板型别推导就十分重要。<br>函数模板大致形如：</p><pre><code>template&lt;typename T&gt;void f(ParamType param);</code></pre><p>而一次调用则形如：</p><pre><code>f(expr);   //以某个表达式调用f</code></pre><p>在编译期，编译器会通过expr推导两个型别：一个是T的型别，另一个是ParamType 的型别，两个型别往往不一样，因为ParamType常会包含了一些修饰词，如const或引用符号等限定词。例如，若模板声明如下：</p><pre><code>template&lt;typename T&gt;void f(const T&amp; param);</code></pre><p>而调用语句如下：</p><pre><code>int x=0;f(x);</code></pre><p>在此例中，T会被推导为int，ParamType则被推导为const int&amp;。<br>但具体而言，T的型别推导结果不仅依赖于expr的型别，还依赖于ParamType 的形式，具体分为三种情况讨论：</p><ul><li>ParamType具有指针或者引用型别，但不是万能引用</li><li>ParamType是一个万能引用</li><li>ParamType既非指针也非引用</li></ul><h3 id="ParamType具有指针或者引用型别，但不是万能引用"><a href="#ParamType具有指针或者引用型别，但不是万能引用" class="headerlink" title="ParamType具有指针或者引用型别，但不是万能引用"></a>ParamType具有指针或者引用型别，但不是万能引用</h3><ol><li>若expr具有引用型别，先将引用部分忽略</li><li>对expr的型别和ParamType 的型别执行模式匹配，来决定T的型别。</li></ol><p>例如模式如下：</p><pre><code>template&lt;typename T&gt;void f(T&amp; param);</code></pre><p>又声明了下列变量：</p><pre><code>int x = 27;const int cx = x;const int&amp; rx = x;</code></pre><p>在各次调用中，对param和T 的型别推导结果如下：</p><pre><code>f(x);   //T的型别是int，param的型别是int&amp;f(cx);  //T的型别是const int，param的型别是const int&amp;f(rx);  //T的型别是const int，param的型别是const int&amp;</code></pre><p>rx 的引用性会在型别推导过程中被忽略</p><p>如果我们在ParamType中加入const属性：</p><pre><code>template&lt;typename T&gt;void f(const T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int，param的型别是const int&amp;f(cx);  //T的型别是int，param的型别是const int&amp;f(rx);  //T的型别是int，param的型别是const int&amp;</code></pre><p>同上，rx 的引用性会在型别推导过程中被忽略。</p><p>如果param是一个指针，而非引用，运作方式本质上并无不同：<br>    template<typename t><br>    void f(T* param);</typename></p><pre><code>int x = 27;const int *px = &amp;x;f(&amp;x);   //T的型别是int，param的型别是int*f(px);  //T的型别是const int，param的型别是const int*</code></pre><h3 id="ParamType是一个万能引用"><a href="#ParamType是一个万能引用" class="headerlink" title="ParamType是一个万能引用"></a>ParamType是一个万能引用</h3><ol><li>如果expr是个左值，T和ParamType都会被推导为左值引用。</li><li>如果expr是个右值，则应用第一条规则。</li></ol><p>例如：</p><pre><code>template&lt;typename T&gt;void f(T&amp;&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int&amp;，param的型别是int&amp;f(cx);  //T的型别是const int&amp;，param的型别是const int&amp;f(rx);  //T的型别是const int&amp;，param的型别是const int&amp;f(27);  //T的型别是int，param的型别是int&amp;&amp;</code></pre><h3 id="ParamType既非指针也非引用"><a href="#ParamType既非指针也非引用" class="headerlink" title="ParamType既非指针也非引用"></a>ParamType既非指针也非引用</h3><ol><li>若expr具有引用型别，先将引用部分忽略</li><li>若expr是个const,volatile对象，则忽略之</li></ol><p>例如：</p><pre><code>template&lt;typename T&gt;void f(T param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int，param的型别是intf(cx);  //T的型别是int，param的型别是intf(rx);  //T的型别是int，param的型别是int</code></pre><p>param是个完全独立于cx和rx的对象，是他的一个副本，即使expr不可修改，param也和他无关。<br>需要说明的是，expr是个指向const对象的const指针，且expr按值传给param：</p><pre><code>template&lt;typename T&gt;void f(T param);const char* const ptr = &quot;test&quot;;f(ptr);   //T的型别是const char*，param的型别是const char*</code></pre><h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>数组型别有别于指针型别，数组会退化成首元素的指针。</p><pre><code>const char name[] = &quot;Test&quot;;    //name的型别是const char[5]; &#39;\0&#39;const char* ptrToName = name;  //数组退化成指针 const char *</code></pre><p>当一个数组传递到持有按值形参的模板时</p><pre><code>template&lt;typename T&gt;void f(T param);f(name);void myFunc(int param[]);//这意味着myFunc等价的声明如下：void myFunc(int* param);</code></pre><p>这种数组和指针形参的等价性，是c++基础的c根源遗迹，它使得“数组和指针型别是一回事”<br>由于数组形参声明会按照他们好像是指针形参那样加以处理，按值传递给函数模板的数组型别将被推导成指针型别。<br>也就是说，在模板f的调用中，其类型形参T会被推到成const char*</p><pre><code>f(name);   //name是个数组，但是却被推导成了const char*</code></pre><p>尽管函数无法声明数组类型的形参，他们却可以声明形参为数组的引用！</p><pre><code>template&lt;typename T&gt;void f(T&amp; param);f(name);</code></pre><p>在这种情况下，T会被推导成实际的数组类型，这个型别会包含数组的尺寸 T 的推导类型为const char[5];param则被推导为const char(&amp;)[5];</p><pre><code>template&lt;typename T,std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N])noexception&#123;    return N;&#125;</code></pre><p>我们可以利用模板推导出数组含有的元素个数。</p><h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3><p>和数组一样，函数也会退化成函数指针</p><pre><code>void someFunc(int,double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc);  //param具体型别 void (*)(int,double)f2(someFunc);  //param具体型别 void (&amp;)(int,double)</code></pre><h2 id="auto-型别推导"><a href="#auto-型别推导" class="headerlink" title="auto 型别推导"></a>auto 型别推导</h2><p>auto推导规则和模板类型推导大致相同，也是分为三种类型</p><ul><li>ParamType具有指针或者引用型别，但不是万能引用</li><li>ParamType是一个万能引用</li><li>ParamType既非指针也非引用</li></ul><p>这里不进行细致研究，下面是一些例子，规则参考模板类型推导：</p><pre><code>auto x = 27;const auto cx = x;const auto&amp; rx = x;auto&amp;&amp; uref1 = x;// int&amp;auto&amp;&amp; uref1 = cx;// const int&amp;auto&amp;&amp; uref1 = 27;// int&amp;&amp;</code></pre><p>同时，关于数组指针以及函数指针相关退化规则也完全相同：</p><pre><code>const char name[] = &quot;test&quot;;auto arr1 = name;// const char*auto arr2 = name;// const char (&amp;)[5]void someFunc(int,double);auto func1 = someFunc;// void (*)(int,double)auto&amp; func2 = someFunc;// void (&amp;)(int,double)</code></pre><p>但是auto类型推导有一个例外，由于c++支持统一初始化</p><pre><code>int x3 = &#123;2&#125;;auto x4 = &#123;2&#125;;</code></pre><p>这里x3是int类型，但是x4类型并不是int，而是std::initializer_list<int><br>这也是auto和模板类型推导的主要区别，例如：</int></p><pre><code>auto x = &#123;1,2,3,4,5&#125;;// x的类型是std::initializer_list&lt;int&gt; template&lt;typename T&gt;void f(T param);f(&#123;1,2,3,4,5&#125;);//错误，无法推导T的型别</code></pre><p>但是如果你指定模板参数类型为std::initializer_list<T> 推导机制则会推导出T的类型</T></p><pre><code>template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; param);f(&#123;1,2,3,4,5&#125;);//推导T的型别为int</code></pre><h2 id="auto-作为函数返回类型"><a href="#auto-作为函数返回类型" class="headerlink" title="auto 作为函数返回类型"></a>auto 作为函数返回类型</h2><p>c++处理函数时使用类型推断的情况有两种类型</p><ul><li>创建一个模板函数并在没有显式具体化的情况下调用该函数，可以推断函数参数的类型</li><li>代替函数的返回值类型</li></ul><p>例如：</p><pre><code>auto AutoFunction(int t)&#123;    return t;&#125;</code></pre><p>c++11 这里会出现错误，后续版本解决了这个问题。<br>c++11解决该问题的方法是指定函数返回类型：</p><pre><code>auto AutoFunction(int t)-&gt;int&#123;    return t;&#125;</code></pre><p>但是如果在模板函数中，返回类型不确定，这时候需要引入一个新的关键字来进行推导：<strong>decltype</strong></p><pre><code>template&lt;typename T&gt;auto AutoFunction(T t)-&gt;decltype(t)&#123;    return t;&#125;</code></pre><p>c++14 纠正了这一情况，即使是和模板一起使用auto推导返回值类型也不需要后置返回值类型。<br>在C++14中，编译器可以直接推断出函数的返回类型了，所以可以写成下边的样子：</p><pre><code>decltype(auto) AutoFunction(int t)-&gt;int&#123;    return t;&#125;  //或者直接下面这种方式也可以 auto AutoFunction(int t)-&gt;int&#123;    return t;&#125;</code></pre><p>但是二者有所区别，auto会自动去除返回值的引用性，但是decltyoe会保留原有属性，<br>在一般情况下，decltype都是返回给定表达式或者给定的名字的类型，但是在某些情况下还是有点问题,如果仅有一个名字，那么decltype的行为保持不变，但如果是一个复杂度左值表达式，decltype会返回一个左值引用。</p><pre><code>//返回intdelctype(auto) f1()&#123;    int x = 0;    ....    return x;&#125;//返回int&amp;delctype(auto) f1()&#123;    int x = 0;    ....    return (x);&#125;</code></pre><p>auto的使用还需要注意一下代理类相关的问题。比如：</p><pre><code>std::vector&lt;bool&gt; features(const Widget&amp; w);Widget w;auto temp = features(w)[5];</code></pre><p>temp的类型并不是我们想象中的bool，这是因为vector对bool类型做过特化，每一个bool元素用一个比特位进行表示，返回值并不是bool类型，而是std::vector<bool>::reference;std::vector<bool>::reference能够向bool进行隐式类型转换</bool></bool></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程局部存储</title>
      <link href="/p/af951d26.html"/>
      <url>/p/af951d26.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><p>对于1个存在多个线程的进程来说，有时需要每个线程都自己操作自己的这份数据。这有点类似于 C++类的实例属性，每个实例对象操作的都是自己的属性。我们把这样的数据称为线程局部存储（ThreadLocal Storage，TLS），将对应的存储区域称为线程局部存储区。</p><h2 id="Windows的线程局部存储"><a href="#Windows的线程局部存储" class="headerlink" title="Windows的线程局部存储"></a>Windows的线程局部存储</h2><p>在 Windows 操作系统中，TLS（Thread Local Storage，线程局部存储）被划分为一定数量的块，每个块通过一个索引值来进行访问。这个数量由宏定义 <code>TLS_MINIMUM_AVAILABLE</code> 来表示，默认值为 64。</p><p>在 Windows 的头文件 <code>winnt.h</code> 中，可以找到以下定义：</p><pre><code class="cpp">#define TLS_MINIMUM_AVAILABLE 64</code></pre><p>这意味着系统至少提供了 64 个 TLS 块供开发者使用。开发者可以使用这些块来存储线程本地的数据，每个线程都有自己独立的一份数据副本。通过 TLS，可以在多线程环境中实现线程安全的数据访问，每个线程可以独立地操作自己的数据，而不会互相干扰。<br>需要注意的是，虽然最少提供了 64 个 TLS 块，但实际上可以使用更多的 TLS 块。开发者可以通过函数 <code>TlsAlloc</code> 来分配一个新的 TLS 索引值，用于访问额外的 TLS 块。每个线程都可以通过索引值来访问自己对应的 TLS 块。<br>总结起来，TLS 在 Windows 中提供了一种机制，用于实现线程本地数据的存储和访问。通过 TLS，可以方便地在多线程环境中管理线程私有的数据。</p><p>示意图如下：<br><img src="https://s1.ax1x.com/2023/06/13/pCmRayF.png" alt="pCmRayF.png"></p><p>在 Windows 中，可以使用 <code>TlsAlloc</code> 函数来获取一个可用的线程局部存储（TLS）块的索引。以下是使用 <code>TlsAlloc</code> 函数的示例代码：</p><pre><code class="cpp">#include &lt;Windows.h&gt;DWORD dwTlsIndex;  // 全局变量，用于存储 TLS 块的索引void InitializeTls()&#123;    // 获取一个可用的 TLS 块索引    dwTlsIndex = TlsAlloc();    if (dwTlsIndex == TLS_OUT_OF_INDEXES)    &#123;        // 获取索引失败，处理错误        // ...    &#125;&#125;void CleanupTls()&#123;    // 释放先前分配的 TLS 块索引    TlsFree(dwTlsIndex);&#125;void SetTlsData(LPVOID lpData)&#123;    // 将指定的数据存储到当前线程的 TLS 块中    TlsSetValue(dwTlsIndex, lpData);&#125;LPVOID GetTlsData()&#123;    // 从当前线程的 TLS 块中获取数据    return TlsGetValue(dwTlsIndex);&#125;</code></pre><ul><li>在上述示例中，<code>InitializeTls</code> 函数用于初始化 TLS，调用 <code>TlsAlloc</code> 函数获取一个可用的 TLS 块索引，并将其保存在全局变量 <code>dwTlsIndex</code> 中。</li><li><code>CleanupTls</code> 函数用于在程序结束或不再需要 TLS 时释放先前分配的 TLS 块索引，调用 <code>TlsFree</code> 函数进行释放。</li><li><code>SetTlsData</code> 函数用于将指定的数据存储到当前线程的 TLS 块中，调用 <code>TlsSetValue</code> 函数进行设置。</li><li><code>GetTlsData</code> 函数用于从当前线程的 TLS 块中获取数据，调用 <code>TlsGetValue</code> 函数进行获取。<br>需要注意的是，TLS 块中存储的是 <code>LPVOID</code> 类型的指针，可以根据需要将不同类型的数据进行类型转换。另外，每个线程都有独立的一份 TLS 数据，相互之间不会共享。</li></ul><p>一旦 <code>TlsAlloc</code> 函数调用成功并返回一个有效的索引，就可以使用以下两个 API 函数在该索引指向的 TLS 内存块中存储和获取数据：</p><ol><li><p><code>TlsSetValue</code> 函数：用于将数据存储到指定索引的 TLS 内存块中。</p><pre><code class="cpp">BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);</code></pre><ul><li><code>dwTlsIndex</code>：要存储数据的 TLS 索引。</li><li><code>lpTlsValue</code>：要存储的数据指针。</li></ul></li><li><p><code>TlsGetValue</code> 函数：用于从指定索引的 TLS 内存块中获取数据。</p><pre><code class="cpp">LPVOID TlsGetValue(DWORD dwTlsIndex);</code></pre><ul><li><code>dwTlsIndex</code>：要获取数据的 TLS 索引。</li></ul></li></ol><p>当不再需要使用一个 TLS 索引及其对应的内存块时，可以使用 <code>TlsFree</code> 函数来释放它们：</p><pre><code class="cpp">BOOL TlsFree(DWORD dwTlsIndex);</code></pre><ul><li><code>dwTlsIndex</code>：要释放的 TLS 索引。</li></ul><p>除了使用 Win32 API 函数来管理线程局部存储外，Microsoft VC++ 编译器也提供了一种更方便的方法来定义线程局部变量，即使用 <code>__declspec(thread)</code> 关键字。</p><p>具体用法如下所示：</p><pre><code class="cpp">__declspec(thread) &lt;variable-type&gt; &lt;variable-name&gt;;</code></pre><p>其中，<code>&lt;variable-type&gt;</code> 是要定义的线程局部变量的类型，<code>&lt;variable-name&gt;</code> 是变量的名称。</p><p>来看一个具体的例子：</p><pre><code class="cpp">#include &lt;windows.h&gt;#include &lt;iostream&gt;__declspec(thread) int g_mydata = 1;DWORD WINAPI workerThreadProc1(LPVOID lpThreadParameter)&#123;    while (true)    &#123;        ++g_mydata;        Sleep(1000);    &#125;    return 0;&#125;DWORD WINAPI workerThreadProc2(LPVOID lpThreadParameter)&#123;    while (true)    &#123;        std::cout &lt;&lt; &quot;g_mydata = &quot; &lt;&lt; g_mydata &lt;&lt; &quot;, ThreadID = &quot; &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;        Sleep(1000);    &#125;    return 0;&#125;int main()&#123;    HANDLE hWorkerThreads[2];    hWorkerThreads[0] = CreateThread(NULL, 0, workerThreadProc1, NULL, 0, NULL);    hWorkerThreads[1] = CreateThread(NULL, 0, workerThreadProc2, NULL, 0, NULL);    CloseHandle(hWorkerThreads[0]);    CloseHandle(hWorkerThreads[1]);    while (true)    &#123;        Sleep(1000);    &#125;    return 0;&#125;</code></pre><p>在以上代码中，全局变量 g_mydata是一个线程局部变量，因此在该进程中每一个线程都会拥有这样一个变量副本。由于是不同的副本，所以在WorkerThreadProc1中，这个变量不断递增，对WorkerThreadProc2的g_mydata不会造成任何影响，因此其值始终是1。</p><pre><code>mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492mydata = 1，ThreadID = 69492g_ydata = 1,ThreadID =69492</code></pre><p>需要说明的是，在 Windows 中被声明成线程局部变量的对象，在编译器生成可执行文件时，会在最终的PE文件中专门生成一个叫作tls的节，用于存放这些线程局部变量。</p><h2 id="Linux的线程局部存储"><a href="#Linux的线程局部存储" class="headerlink" title="Linux的线程局部存储"></a>Linux的线程局部存储</h2><p>在Linux上，NTPL（Native POSIX Thread Library）提供了一套函数接口来实现线程局部存储（Thread-Local Storage，TLS）功能。这些函数接口包括：</p><ol><li><p><code>int pthread_key_create(pthread_key_t* key, void (*destructor)(void*))</code></p><ul><li>参数<code>key</code>：指向线程局部存储键的指针，用于存储创建的键。</li><li>参数<code>destructor</code>：线程局部存储键关联值的清理函数指针。</li></ul><p>返回值：若成功，返回0；否则，返回错误码。</p></li><li><p><code>int pthread_key_delete(pthread_key_t key)</code></p><ul><li>参数<code>key</code>：要删除的线程局部存储键。</li></ul><p>返回值：若成功，返回0；否则，返回错误码。</p></li><li><p><code>int pthread_setspecific(pthread_key_t key, const void* value)</code></p><ul><li>参数<code>key</code>：要设置值的线程局部存储键。</li><li>参数<code>value</code>：要与键关联的值。</li></ul><p>返回值：若成功，返回0；否则，返回错误码。</p></li><li><p><code>void* pthread_getspecific(pthread_key_t key)</code></p><ul><li>参数<code>key</code>：要获取值的线程局部存储键。</li></ul><p>返回值：与键关联的值。</p></li><li><p><code>int pthread_once(pthread_once_t* once_control, void (*init_routine)(void))</code></p><ul><li>参数<code>once_control</code>：用于标记一次性初始化是否已完成的控制变量。</li><li>参数<code>init_routine</code>：一次性初始化的回调函数指针。</li></ul><p>返回值：若成功，返回0；否则，返回错误码。</p></li></ol><p>需要注意的是，函数签名中的数据类型可能会根据具体的编译环境和操作系统有所不同，上述签名是一般情况下的表示。请根据实际情况参考系统的文档和头文件定义。</p><p>通过使用这些函数接口，可以在Linux上实现线程局部存储，每个线程可以独立地存储和访问其自己的线程局部数据。这对于需要在线程之间保留独立数据的情况非常有用。<br>参数<code>destructor</code>是一个自定义函数指针，用于在线程退出时对线程局部存储的值进行清理操作。其函数签名如下：</p><pre><code class="c++">void destructor(void* value);</code></pre><p>函数指针<code>destructor</code>指向的函数接受一个<code>void*</code>类型的参数，该参数表示线程局部存储的值。在线程退出时，系统会调用注册的清理函数来处理线程局部存储的值。清理函数可以根据需要进行适当的处理，例如释放内存、关闭文件等。<br>线程终止时，如果key关联的值不是NULL，那么NTPL会自动执行定义的destructor函数；如果无须解构，则可以将destructor设置为NULL。</p><p>下面看一个例子：</p><pre><code class="cpp">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;pthread_key_t thread_log_key;void write_to_thread_log(const char* message) &#123;    if (message == NULL)        return;    FILE* logfile = (FILE*)pthread_getspecific(thread_log_key);    fprintf(logfile, &quot;%s\n&quot;, message);    fflush(logfile);&#125;void close_thread_log(void* logfile) &#123;    char logfilename[128];    sprintf(logfilename, &quot;close logfile: thread%ld.log\n&quot;, (unsigned long)pthread_self());    printf(logfilename);    fclose((FILE*)logfile);&#125;void* thread_function(void* args) &#123;    char logfilename[128];    sprintf(logfilename, &quot;thread%ld.log&quot;, (unsigned long)pthread_self());    FILE* logfile = fopen(logfilename, &quot;w&quot;);    if (logfile != NULL) &#123;        pthread_setspecific(thread_log_key, logfile);        write_to_thread_log(&quot;Thread starting...&quot;);    &#125;    return NULL;&#125;int main() &#123;    pthread_t threadIDs[5];    pthread_key_create(&amp;thread_log_key, close_thread_log);    for (int i = 0; i &lt; 5; ++i)        pthread_create(&amp;threadIDs[i], NULL, thread_function, NULL);    for (int i = 0; i &lt; 5; ++i)        pthread_join(threadIDs[i], NULL);    return 0;&#125;</code></pre><p>上述程序一共创建了5个线程，每个线程都会自己生成一个日志文件，每个线程都将自己的日志写入自己的文件中。在线程执行结束时，会关闭打开的日志文件句柄。程序运行结果如下所示：</p><pre><code>close logfile: thread139782125414144.logclose logfile: thread139702133806848.logclose logfile: thread139702150592256.logclose logfile: thread139782117021448.logclose logfile: thread139702142199552.log</code></pre><p>和Windows一样，Linux gcc编译器也提供了一个关键字__thread用于定义线程局部变量。例如：</p><pre><code>__thread int val=0</code></pre><p>再看一个例子：</p><pre><code class="c">#include &lt;stdio.h&gt;__thread int thread_data;void* thread_function(void* args) &#123;    thread_data = 42;    printf(&quot;Thread data: %d\n&quot;, thread_data);    return NULL;&#125;int main() &#123;    pthread_t thread_id;    pthread_create(&amp;thread_id, NULL, thread_function, NULL);    pthread_join(thread_id, NULL);        // 在主线程中访问线程局部变量    printf(&quot;Main thread data: %d\n&quot;, thread_data);        return 0;&#125;</code></pre><p>在上述示例中，每个线程都有自己的<code>thread_data</code>变量副本，可以独立地对其进行操作。在主线程中也可以访问线程局部变量。<br>需要注意的是，使用<code>__thread</code>定义的线程局部变量仅适用于线程函数内部和主线程中，不能在多个线程之间共享。</p><h2 id="C-11的thread-local关键字"><a href="#C-11的thread-local关键字" class="headerlink" title="C++11的thread_local关键字"></a>C++11的thread_local关键字</h2><p>C++11标准引入了关键字<code>thread_local</code>，用于定义线程局部变量。使用<code>thread_local</code>关键字可以在C++代码中声明一个变量，使其具有线程局部存储的特性。它是一个和 static、extern 同级的变量存储说明，有 thread_local 标记的变量在每个线程里都会有一个独立的副本，是“线程独占”的，所以就不会有竞争读写的问题。有了这个关键字，使用线程局部存储的代码就可以同时在Windows 和 Linux 上运行了。示例如下：</p><pre><code class="cpp">#include &lt;iostream&gt;thread_local int thread_data;void thread_function() &#123;    thread_data = 42;    std::cout &lt;&lt; &quot;Thread data: &quot; &lt;&lt; thread_data &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(thread_function);    std::thread t2(thread_function);    t1.join();    t2.join();        // 在主线程中访问线程局部变量    std::cout &lt;&lt; &quot;Main thread data: &quot; &lt;&lt; thread_data &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>在上述示例中，<code>thread_data</code>是一个线程局部变量，每个线程都有自己的变量副本。在各个线程函数中，可以独立地对<code>thread_data</code>进行操作。在主线程中也可以访问线程局部变量。</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>最后，关于线程局部存储变量，需要再强调两点。</p><ul><li>对于线程变量，每个线程都会有该变量的一个拷贝，互不影响，该局部变量一直存在，直到线程退出。</li><li>系统的线程局部存储区域的内存空间并不大，所以尽量不要用这个空间存储大的数据块，如果不得不使用大的数据块，则可以将大的数据块存储在堆内存中，再将该堆内存的地址指针存储在线程局部存储区域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/p/226.html"/>
      <url>/p/226.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池定义"><a href="#线程池定义" class="headerlink" title="线程池定义"></a>线程池定义</h2><p>C++线程池是一种多线程编程技术，用于管理和调度一组线程执行并发任务。线程池可以在应用程序启动时创建一组预先分配的线程，这些线程可以重复使用来处理多个任务，而不需要每次都创建新线程。<br>事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。<br>总之线程池通常适合下面的几个场合：</p><ul><li>单位时间内处理任务频繁而且任务处理时间短</li><li>对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。<br>线程池应用之一：日志存储<br>  在服务器保存日志至磁盘上时，性能往往压在磁盘读写上，而引入线程池利用异步解耦可以解决磁盘读写性能问题。<br>线程池的主要作用：异步解耦</li></ul><p>线程池往往不需要反复创建，所以采用了<br><img src="https://whl963854.github.io/p/46132.html" alt="单例模式"><br>线程池需要提供几个接口：</p><ul><li>static XThreadPool* Get() 获取线程池对象</li><li>void init(int threadCount);  初始化函数，需要指定线程池大小</li><li>void dispatch(XTask* task);  分发任务函数，需要将任务轮询分配给相应线程<br>线程池基于libevent做的（相关资料待整理）</li></ul><p>具体类定义如下：</p><pre><code>#ifndef XTHREAD_POOL_H#define XTHREAD_POOL_H#include &lt;vector&gt;class XThread;class XTask;class XThreadPool&#123;public:    static XThreadPool* Get()    &#123;        static XThreadPool p;        return &amp;p;    &#125;    void init(int threadCount);    void dispatch(XTask* task);    XThreadPool() &#123;&#125;;private:    ///线程数量    int m_threadCount = 0;    ///上一次分发得到线程，用于轮询    int m_lastThread = -1;    ///线程池线程队列    std::vector&lt;XThread*&gt;m_threads;&#125;;#endif //XTHREAD_POOL_H</code></pre><h3 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h3><p>初始化所有线程并启动线程</p><pre><code>void XThreadPool::init(int threadCount)&#123;    this-&gt;m_threadCount = threadCount;    this-&gt;m_lastThread = -1;    for (int i = 0; i &lt; threadCount; i++)    &#123;        XThread* t = new XThread();        t-&gt;setId(i + 1);        cout &lt;&lt; &quot;Create thread &quot; &lt;&lt; i &lt;&lt; endl;        //启动线程        t-&gt;start();        m_threads.push_back(t);        this_thread::sleep_for(10ms);    &#125;&#125;</code></pre><h3 id="分发线程"><a href="#分发线程" class="headerlink" title="分发线程"></a>分发线程</h3><p>分发策略采取轮询的方式，可以设计更好的方式，相对轮询是最简单的<br>主线程分发不会产生问题，不需要加锁，暂时不考虑多线程分发，如有需要再进行更改</p><pre><code>void XThreadPool::dispatch(XTask* task)&#123;    //轮询    if (task==nullptr)return;    int tid = (m_lastThread + 1) % m_threadCount;    m_lastThread = tid;    XThread* t = m_threads[tid];    t-&gt;addTask(task);    //激活线程    t-&gt;activate();&#125;</code></pre><h3 id="对应实现完整代码"><a href="#对应实现完整代码" class="headerlink" title="对应实现完整代码"></a>对应实现完整代码</h3><pre><code>#ifndef XTHREAD_POOL_CPP#define XTHREAD_POOL_CPP#include &quot;xthreadpool.h&quot;#include &quot;xthread.h&quot;#include &lt;thread&gt;#include &lt;iostream&gt;#include &quot;xtask.h&quot;using namespace std;//分发线程void XThreadPool::dispatch(XTask* task)&#123;    //轮询    if (task==nullptr)return;    int tid = (m_lastThread + 1) % m_threadCount;    m_lastThread = tid;    XThread* t = m_threads[tid];    t-&gt;addTask(task);    //激活线程    t-&gt;activate();&#125;//初始化所有线程并启动线程void XThreadPool::init(int threadCount)&#123;    this-&gt;m_threadCount = threadCount;    this-&gt;m_lastThread = -1;    for (int i = 0; i &lt; threadCount; i++)    &#123;        XThread* t = new XThread();        t-&gt;setId(i + 1);        cout &lt;&lt; &quot;Create thread &quot; &lt;&lt; i &lt;&lt; endl;        //启动线程        t-&gt;start();        m_threads.push_back(t);        this_thread::sleep_for(10ms);    &#125;&#125;#endif //XTHREAD_POOL_CPP</code></pre><h2 id="线程函数定义"><a href="#线程函数定义" class="headerlink" title="线程函数定义"></a>线程函数定义</h2><ul><li>线程需要提供以下接口： <ul><li>void start();  启动线程函数</li><li>void entry();  线程入口函数</li><li>bool setUp();  线程安装函数</li><li>void activate();        线程激活函数</li><li>void addTask(XTask *t); 添加任务函数</li><li>void notify(int fd, short which);   收到主线程发出的激活消息处理函数</li></ul></li></ul><p>具体线程类定义如下：</p><pre><code>#ifndef XTHREAD_H#define XTHREAD_H#include &lt;list&gt;#include &lt;mutex&gt;class XTask;class XThread&#123;public:    int getId();    void setId(int id);    //启动线程    void start();    //线程入口函数    void entry();    //安装线程，初始化event_base和管道监听事件用于激活    bool setUp();    //收到主线程发出的激活消息（线程池的分发）    void notify(int fd, short which);    //线程激活    void activate();    //添加处理的任务，一个线程同时可以处理多个任务，共用一个event_base    void addTask(XTask *t);    XThread();    ~XThread();private:    //线程编号    int m_id = 0;    int m_notifyFd = 0;    struct event_base *m_base = 0;    //任务列表    std::list&lt;XTask*&gt; m_tasks;    //线程安全 互斥    std::mutex m_tasksMux;&#125;;#endif</code></pre><h3 id="启动线程函数"><a href="#启动线程函数" class="headerlink" title="启动线程函数"></a>启动线程函数</h3><p>启动线程，线程启动需要初始化安装，同时需要与主线程断开联系，否则线程运行后会被释放</p><pre><code>void XThread::start()&#123;    setUp();    //启动线程    thread th(&amp;XThread::entry,this);    //断开与主线程联系    th.detach();&#125;</code></pre><h3 id="线程入口函数"><a href="#线程入口函数" class="headerlink" title="线程入口函数"></a>线程入口函数</h3><p>线程入口函数需要开启event_base_dispatch()事件循环，event_base_dispatch()内部调用的event_base_loop，event_base_loop内部是一个while循环，所以调用event_base_dispatch()的线程是阻塞的，除非调用了event_base_loopbreak() 或者 event_base_loopexit()才会退出<br>理论上除非主程序退出，不然线程池不需要释放线程</p><pre><code>void XThread::entry()&#123;    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() begin&quot; &lt;&lt; endl;    if (!m_base)    &#123;        cerr &lt;&lt; &quot;XThread::Main faield! m_base is null &quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;In windows set WSAStartup(MAKEWORD(2, 2), &amp;wsa)&quot; &lt;&lt; endl;        return;    &#125;    //  This loop will run the event base until either there are no more pending or    //active, or until something calls event_base_loopbreak() or    //event_base_loopexit().    event_base_dispatch(m_base);    event_base_free(m_base);    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() end&quot; &lt;&lt; endl;&#125;</code></pre><h3 id="线程安装函数"><a href="#线程安装函数" class="headerlink" title="线程安装函数"></a>线程安装函数</h3><p>安装线程，初始化event_base</p><pre><code>bool XThread::setUp()&#123;    //windows用配对socket     //创建一个socketpair 可以互相通信 fds[0] 读 fds[1]写 类似于管道    evutil_socket_t fds[2];    if (evutil_socketpair(AF_INET, SOCK_STREAM, 0, fds) &lt; 0)    &#123;        cout &lt;&lt; &quot;evutil_socketpair failed!&quot; &lt;&lt; endl;        return false;    &#125;    //设置成非阻塞    evutil_make_socket_nonblocking(fds[0]);    evutil_make_socket_nonblocking(fds[1]);    //读取绑定到event事件中，写入要保存    m_notifyFd = fds[1];    //创建libevent上下文（无锁）    event_config *ev_conf = event_config_new();    event_config_set_flag(ev_conf, EVENT_BASE_FLAG_NOLOCK);    this-&gt;m_base = event_base_new_with_config(ev_conf);    event_config_free(ev_conf);    if (!m_base)    &#123;        cerr &lt;&lt; &quot;event_base_new_with_config failed in thread!&quot; &lt;&lt; endl;        return false;    &#125;    //添加管道监听事件，用于激活线程执行任务    //EV_READ  只要网络缓冲中还有数据，回调函数就会被触发；    //EV_PERSIST  不指定这个属性，回调函数被触发后事件会被删除；    event *ev = event_new(m_base, fds[0], EV_READ | EV_PERSIST, notifyCB, this);    //函数参数ev是指向要注册的事件，tv是超时时间，    event_add(ev, 0);    return true;&#125;</code></pre><h3 id="线程激活函数"><a href="#线程激活函数" class="headerlink" title="线程激活函数"></a>线程激活函数</h3><p>线程激活，发送信号，由消息处理函数进行处理激活后的内容</p><pre><code>void XThread::activate()&#123;    int re = send(this-&gt;m_notifyFd, &quot;c&quot;, 1, 0);    if (re &lt;= 0)    &#123;        cerr &lt;&lt; &quot;XThread::Activate() failed!&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="添加任务函数"><a href="#添加任务函数" class="headerlink" title="添加任务函数"></a>添加任务函数</h3><p>目前只有一个线程池，并且只有线程池才会分发任务，暂时不会涉及到多线程</p><pre><code>void XThread::addTask(XTask *t)&#123;    if (t==nullptr)return;    t-&gt;setBase(this-&gt;m_base);    //m_tasksMux.lock();    m_tasks.push_back(t);    //m_tasksMux.unlock();&#125;</code></pre><h3 id="收到主线程发出的激活消息处理函数"><a href="#收到主线程发出的激活消息处理函数" class="headerlink" title="收到主线程发出的激活消息处理函数"></a>收到主线程发出的激活消息处理函数</h3><p>回调函数必须是static，因为成员函数默认有一个this指针参数，导致回调函数参数不匹配，而静态函数没有this指针，没有这个问题。如果采用普通函数则会破坏函数封装性，破坏面向对象设计方式。<br>线程分发后回调函数多线程并行执行，有可能会导致问题，所以需要加上锁保护函数<br>这里任务类需要统一实现init函数</p><pre><code>static void notifyCB(int fd, short which, void *arg)&#123;    XThread *t = (XThread *)arg;    t-&gt;notify(fd, which);&#125;void XThread::notify(int fd, short which)&#123;    //水平触发 只要没有接受完成，会再次进来    char buf[2] = &#123; 0 &#125;;    int re = recv(fd, buf, 1, 0);    if (re &lt;= 0)        return;    cout &lt;&lt; m_id &lt;&lt; &quot; thread &quot; &lt;&lt; buf &lt;&lt; endl;    XTask *task = nullptr;    //获取任务，并初始化任务    m_tasksMux.lock();    if (m_tasks.empty())    &#123;        m_tasksMux.unlock();        return;    &#125;    task = m_tasks.front(); //先进先出    m_tasks.pop_front();    m_tasksMux.unlock();    task-&gt;init();&#125;</code></pre><h3 id="线程完整函数定义"><a href="#线程完整函数定义" class="headerlink" title="线程完整函数定义"></a>线程完整函数定义</h3><pre><code>#ifndef XTHREAD_CPP#define XTHREAD_CPP#include &quot;xthread.h&quot;#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;event2/event.h&gt;#include &quot;xtask.h&quot;using namespace std;//激活线程任务的回调函数static void notifyCB(int fd, short which, void *arg)&#123;    XThread *t = (XThread *)arg;    t-&gt;notify(fd, which);&#125;void XThread::notify(int fd, short which)&#123;    //水平触发 只要没有接受完成，会再次进来    char buf[2] = &#123; 0 &#125;;    int re = recv(fd, buf, 1, 0);    if (re &lt;= 0)        return;    cout &lt;&lt; m_id &lt;&lt; &quot; thread &quot; &lt;&lt; buf &lt;&lt; endl;    XTask *task = nullptr;    //获取任务，并初始化任务    m_tasksMux.lock();    if (m_tasks.empty())    &#123;        m_tasksMux.unlock();        return;    &#125;    task = m_tasks.front(); //先进先出    m_tasks.pop_front();    m_tasksMux.unlock();    task-&gt;init();&#125;void XThread::addTask(XTask *t)&#123;    if (t==nullptr)return;    t-&gt;setBase(this-&gt;m_base);    m_tasksMux.lock();    m_tasks.push_back(t);    m_tasksMux.unlock();&#125;//线程激活void XThread::activate()&#123;    int re = send(this-&gt;m_notifyFd, &quot;c&quot;, 1, 0);    if (re &lt;= 0)    &#123;        cerr &lt;&lt; &quot;XThread::Activate() failed!&quot; &lt;&lt; endl;    &#125;&#125;//启动线程void XThread::start()&#123;    setUp();    //启动线程    thread th(&amp;XThread::entry,this);    //断开与主线程联系    th.detach();&#125;//安装线程，初始化event_basebool XThread::setUp()&#123;    //windows用配对socket     //创建一个socketpair 可以互相通信 fds[0] 读 fds[1]写     evutil_socket_t fds[2];    if (evutil_socketpair(AF_INET, SOCK_STREAM, 0, fds) &lt; 0)    &#123;        cout &lt;&lt; &quot;evutil_socketpair failed!&quot; &lt;&lt; endl;        return false;    &#125;    //设置成非阻塞    evutil_make_socket_nonblocking(fds[0]);    evutil_make_socket_nonblocking(fds[1]);    //读取绑定到event事件中，写入要保存    m_notifyFd = fds[1];    //创建libevent上下文（无锁）    event_config *ev_conf = event_config_new();    event_config_set_flag(ev_conf, EVENT_BASE_FLAG_NOLOCK);    this-&gt;m_base = event_base_new_with_config(ev_conf);    event_config_free(ev_conf);    if (!m_base)    &#123;        cerr &lt;&lt; &quot;event_base_new_with_config failed in thread!&quot; &lt;&lt; endl;        return false;    &#125;    //添加管道监听事件，用于激活线程执行任务    //EV_READ  只要网络缓冲中还有数据，回调函数就会被触发；    //EV_PERSIST  不指定这个属性，回调函数被触发后事件会被删除；    event *ev = event_new(m_base, fds[0], EV_READ | EV_PERSIST, notifyCB, this);    event_add(ev, 0);    return true;&#125;//线程入口函数void XThread::entry()&#123;    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() begin&quot; &lt;&lt; endl;    if (!m_base)    &#123;        cerr &lt;&lt; &quot;XThread::Main faield! m_base is null &quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;In windows set WSAStartup(MAKEWORD(2, 2), &amp;wsa)&quot; &lt;&lt; endl;        return;    &#125;    //  This loop will run the event base until either there are no more pending or    //active, or until something calls event_base_loopbreak() or    //event_base_loopexit().    event_base_dispatch(m_base);    event_base_free(m_base);    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() end&quot; &lt;&lt; endl;&#125;XThread::XThread()&#123;&#125;XThread::~XThread()&#123;&#125;int XThread::getId()&#123;    return m_id;&#125;void XThread::setId(int id)&#123;    m_id = id;&#125;#endif //XTHREAD_CPP</code></pre><h2 id="任务接口定义"><a href="#任务接口定义" class="headerlink" title="任务接口定义"></a>任务接口定义</h2><p>为线程提供一个所需执行任务的接口类，任何需要使用线程池的函数都需要继承这个接口，实现接口函数。<br>这里可以不需要相关sock等成员，只需要提供一个init 函数即可 ，但是如果需要执行网络交互则必须有相应成员变量</p><pre><code>#ifndef XTASK_H#define XTASK_Hclass XTask&#123;public:    //初始化任务    virtual bool init() = 0;    int getThreadId() &#123; return m_threadId; &#125;    void setThreadId(int getThreadId) &#123; m_threadId = getThreadId; &#125;    int getSock() &#123; return m_sock; &#125;    void setSock(int getSock) &#123; this-&gt;m_sock = getSock; &#125;    struct event_base* getBase() &#123; return m_base; &#125;    void setBase(struct event_base* getBase) &#123; this-&gt;m_base = getBase; &#125;private:    struct event_base* m_base = 0;    int m_sock = 0;    int m_threadId = 0;&#125;;#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的基本操作</title>
      <link href="/p/b2513043.html"/>
      <url>/p/b2513043.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="Linux线程的创建"><a href="#Linux线程的创建" class="headerlink" title="Linux线程的创建"></a>Linux线程的创建</h3><p>在Linux平台上使用pthread_create这个API来创建线程，其函数签名如下：</p><pre><code>int pthread_create(pthread_t *thread,pthread_attr_t *attr,void *(*start_routine)(void*),  void *arg)</code></pre><ul><li>第一个参数为指向线程标识符的指针。<ul><li>thread是一个输出参数，如果线程创建成功，则通过这个参数可以得到创建成功的线程 ID</li><li>参数 attr 指定了该线程的属性，一般被设置为NULL，表示使用默认的属性</li></ul></li><li>第二个参数用来设置线程属性attr</li><li>第三个参数是线程运行函数的起始地址。<ul><li>第三个参数是线程的入口地址，线程是一个执行路线是进程中的单独控制序列，控制序列的入口地址由第三个参数指定。</li><li>第三个参数是一个函数指针，函数指针所指向的函数特征如下，接收一个无类型的参数，返回的也是无类型指针。</li><li>这个函数的调用方式必须是__cdecl，这是C Declaration的缩写，__cdecl是在C&#x2F;C++中定义全局函数时默认的调用方式。</li></ul></li><li>第四个参数是运行函数的参数。</li><li>第四个参数为传递给线程函数的参数，也就是第三个参数所指向函数的参数。尽管arg是 <strong>void</strong>* 类型的变量，但它同样可以作为任意类型的参数传给start_routine()函数；同时，<strong>start_routine()</strong> 可以返回一个void *类型的返回值，而这个返回值也可以是其他类型，并由 <strong>pthread_join()</strong> 获取。</li><li>如果需要向<strong>start_routine</strong>函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为<strong>arg</strong>的参数传入。</li><li>对于代码的返回值，如果成功创建线程，则返回 0；如果创建失败，则返回响应的错误码，常见的错误码有 EAGAIN、EINVAL、EPERM。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>不向线程函数传递参数：</p><pre><code>#include &quot;apue.h&quot;#include &lt;pthread.h&gt;#include &quot;apueerror.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;pthread_t ntid;void printids(const char *s)&#123;    pid_tpid;    pthread_ttid;    pid = getpid();    tid = pthread_self();    printf(&quot;%s pid %lu tid %lu (0x%lx)\n&quot;, s, (unsigned long)pid,    (unsigned long)tid, (unsigned long)tid);&#125;void *thr_fn(void *arg)&#123;    cout &lt;&lt; &quot;----enter sub thread--------&quot; &lt;&lt; endl;    printids(&quot;new thread: &quot;);    cout &lt;&lt; &quot;Change to C++ code!!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;----exit from sub thread----&quot; &lt;&lt; endl;    return((void *)0);&#125;int main(void)&#123;    interr;    //第四个参数为NULL，说明没有向线程函数传参数。    err = pthread_create(&amp;ntid, NULL, thr_fn, NULL);    if (err != 0)        err_exit(err, &quot;can&#39;t create thread&quot;);    printids(&quot;main thread:&quot;);    sleep(1);    exit(0);&#125;</code></pre><p>传递一个参数</p><pre><code>#include &quot;apue.h&quot;#include &lt;pthread.h&gt;#include &quot;apueerror.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;pthread_t ntid;void printids(const char *s)&#123;    pid_tpid;    pthread_ttid;    pid = getpid();    tid = pthread_self();    printf(&quot;%s pid %lu tid %lu (0x%lx)\n&quot;, s, (unsigned long)pid,    (unsigned long)tid, (unsigned long)tid);&#125;struct Param &#123;    int a;    int b;    int c;&#125;;void *thr_fn( void *arg ) &#123;    cout &lt;&lt; &quot;----enter sub thread--------&quot; &lt;&lt; endl;    int tmp = *(int *)arg;    cout &lt;&lt; &quot;tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;    printids(&quot;new thread: &quot;);    cout &lt;&lt; &quot;Change to C++ code!!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;----exit from sub thread----&quot; &lt;&lt; endl;    return((void *)0);&#125;int main(void)&#123;    interr;    int num = 123;    //向线程函数传入一个参数。    err = pthread_create(&amp;ntid, NULL, thr_fn, &amp;num);    if (err != 0)        err_exit(err, &quot;can&#39;t create thread&quot;);    printids(&quot;main thread:&quot;);    sleep(1);    exit(0);&#125;</code></pre><p>向线程函数传递两个或以上的参数：</p><pre><code>#include &quot;apue.h&quot;#include &lt;pthread.h&gt;#include &quot;apueerror.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;pthread_t ntid;void printids(const char *s)&#123;    pid_tpid;    pthread_ttid;    pid = getpid();    tid = pthread_self();    printf(&quot;%s pid %lu tid %lu (0x%lx)\n&quot;, s, (unsigned long)pid,    (unsigned long)tid, (unsigned long)tid);&#125;struct Param &#123;    int a;    int b;    int c;&#125;;void *thr_fn(void *arg) &#123;    cout &lt;&lt; &quot;----enter sub thread--------&quot; &lt;&lt; endl;    Param tmp = *(Param *)arg;    cout &lt;&lt; &quot;tmp.a=&quot; &lt;&lt; tmp.a &lt;&lt; endl;    cout &lt;&lt; &quot;tmp.b=&quot; &lt;&lt; tmp.b &lt;&lt; endl;    cout &lt;&lt; &quot;tmp.c=&quot; &lt;&lt; tmp.c &lt;&lt; endl;    printids(&quot;new thread: &quot;);    cout &lt;&lt; &quot;Change to C++ code!!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;----exit from sub thread----&quot; &lt;&lt; endl;    return((void *)0);&#125;int main(void)&#123;    interr;    int num = 123;    Param param1;    param1.a = 11;    param1.b = 22;    param1.c = 33;    //通过结构体向线程函数传入多个参数    err = pthread_create(&amp;ntid, NULL, thr_fn, &amp;param1);    if (err != 0)        err_exit(err, &quot;can&#39;t create thread&quot;);    printids(&quot;main thread:&quot;);    sleep(1);    exit(0);&#125;</code></pre><h3 id="在windows下进程创建"><a href="#在windows下进程创建" class="headerlink" title="在windows下进程创建"></a>在windows下进程创建</h3><p>在Windows上创建线程要用到CreateThread</p><pre><code>HANDLE CreateThread(    [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,    [in]            SIZE_T                  dwStackSize,    [in]            LPTHREAD_START_ROUTINE  lpStartAddress,    [in, optional]  __drv_aliasesMem LPVOID lpParameter,    [in]            DWORD                   dwCreationFlags,    [out, optional] LPDWORD                 lpThreadId);</code></pre><p>以下是在Windows上使用CreateThread函数创建线程的相关参数说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>[in, optional] lpThreadAttributes</td><td>指向SECURITY_ATTRIBUTES结构的指针，确定返回的句柄是否可以由子进程继承。如果lpThreadAttributes为NULL，则无法继承句柄。</td></tr><tr><td>[in] dwStackSize</td><td>堆栈的初始大小（以字节为单位）。系统将此值舍入到最近的页面。如果此参数为零，新线程将使用可执行文件的默认大小。</td></tr><tr><td>[in] lpStartAddress</td><td>指向由线程执行的应用程序定义函数的指针。此指针表示线程的起始地址。</td></tr><tr><td>[in, optional] lpParameter</td><td>指向要传递给线程的变量的指针。</td></tr><tr><td>[in] dwCreationFlags</td><td>控制线程创建的标志。</td></tr><tr><td>0</td><td>创建后，线程会立即运行。</td></tr><tr><td>CREATE_SUSPENDED</td><td>线程以挂起状态创建，在调用ResumeThread函数之前不会运行。</td></tr><tr><td>STACK_SIZE_PARAM_IS_A_RESERVATION</td><td>dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，dwStackSize将指定提交大小。</td></tr><tr><td>[out, optional] lpThreadId</td><td>指向接收线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。</td></tr></tbody></table><h3 id="C-11提供的std：：thread类"><a href="#C-11提供的std：：thread类" class="headerlink" title="C++11提供的std：：thread类"></a>C++11提供的std：：thread类</h3><p>无论是在Linux上还是在Windows上创建线程的API，都有一个非常不方便的地方，就是线程函数签名必须使用规定的格式（对参数的个数和类型、返回值类型都有要求）。C++11新标准引入了一个新的类std：：thread（需要包含头文件<thread>），使用这个类可以将任意签名形式的函数作为线程函数。</thread></p><p>参照<a href="https://whl963854.github.io/p/24227.html">多线程</a></p><h2 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h2><p>在1个线程创建成功以后，我们可以拿到一个线程ID。线程ID在整个操作系统范围内是唯一的。我们可以使用线程ID来标识和区分线程，例如在日志文件中输出日志的同时将输出日志的线程ID一起输出，这样可以方便我们判断和排查问题。创建线程时可以通过pthread_create函数的第1个参数hread （Linux平台）和CreateThread函数的最后一个参数 lpThreadId（Windows 平台）得到线程的ID。大多数时候，我们需要在当前调用线程中获取当前线程的ID，在Linux平台上可以调用pthread_self函数获取，在Windows平台上可以调用GetCurrentThreadID函数获取.</p><p>在Linux平台上，可以使用<code>pthread_self</code>函数来获取当前线程的ID。它的函数签名如下：</p><pre><code class="c">pthread_t pthread_self(void);</code></pre><p><code>pthread_self</code>函数返回的是一个<code>pthread_t</code>类型的值，表示当前线程的ID。</p><p>在Windows平台上，可以使用<code>GetCurrentThreadId</code>函数来获取当前线程的ID。它的函数签名如下：</p><pre><code class="c">DWORD GetCurrentThreadId(void);</code></pre><p><code>GetCurrentThreadId</code>函数返回的是一个<code>DWORD</code>类型的值，表示当前线程的ID。</p><p>以下是使用这两个函数获取当前线程ID的示例代码：</p><p>在Linux平台上：</p><pre><code class="c">#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;void* threadFunction(void* arg) &#123;    pthread_t threadID = pthread_self();    printf(&quot;Thread ID: %lu\n&quot;, threadID);    // 线程的其他操作    return NULL;&#125;int main() &#123;    pthread_t thread;    pthread_create(&amp;thread, NULL, threadFunction, NULL);        // 等待线程执行完毕    pthread_join(thread, NULL);        return 0;&#125;</code></pre><p>在Windows平台上：</p><pre><code class="c">#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI threadFunction(LPVOID lpParam) &#123;    DWORD threadID = GetCurrentThreadId();    printf(&quot;Thread ID: %lu\n&quot;, threadID);    // 线程的其他操作    return 0;&#125;int main() &#123;    HANDLE thread = CreateThread(NULL, 0, threadFunction, NULL, 0, NULL);        // 等待线程执行完毕    WaitForSingleObject(thread, INFINITE);        CloseHandle(thread);        return 0;&#125;</code></pre><p>上述代码中，<code>threadFunction</code>函数是线程的入口函数，在函数内部通过相应的函数获取线程ID，并进行其他操作。主函数中创建线程，并等待线程执行完毕。</p><h3 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h3><p><code>pstack</code>是一个用于显示指定进程的每个线程的调用堆栈信息的命令。它可以帮助我们了解每个线程的执行情况，从而用于分析和调试程序。<br>使用<code>pstack</code>命令查看进程的线程数量和每个线程的调用堆栈，可以按照以下步骤进行操作：</p><ol><li><p>首先，使用<code>ps</code>命令查看目标进程的进程ID（PID）。例如，使用<code>ps aux | grep nginx</code>命令查找Nginx进程的PID。</p></li><li><p>然后，使用<code>pstack</code>命令加上目标进程的PID来查看该进程的线程调用堆栈。例如，执行<code>pstack &lt;PID&gt;</code>，其中<code>&lt;PID&gt;</code>是目标进程的PID。</p><pre><code class="bash">pstack &lt;PID&gt;</code></pre></li></ol><p>如果目标进程有多个线程，<code>pstack</code>命令会显示每个线程的调用堆栈信息。</p><p>请注意，使用<code>pstack</code>命令查看程序的调用堆栈需要满足以下条件：</p><ul><li>目标程序必须具有调试符号（debug symbol）。这意味着程序必须以调试模式编译，或者在编译时生成了调试符号信息。</li><li>对于非特权用户，必须具有查看目标进程的权限。</li></ul><p>对于排查进程CPU使用率过高的问题，可以结合使用<code>top</code>和<code>pstack</code>命令。首先使用<code>top</code>命令查看进程的CPU使用率，然后使用<code>top -H</code>命令查看各个线程的运行状态。从<code>top -H</code>命令的输出中获取高CPU使用率的线程ID，然后使用<code>pstack</code>命令查看该线程的调用堆栈信息。通过分析线程的调用堆栈，可以定位问题所在，优化相关逻辑以解决CPU使用率过高的问题。</p><p>需要注意的是，<code>pstack</code>命令提供的是当前线程的调用堆栈信息，并不能直接提供线程的执行状态等其他信息。因此，在排查问题时，还需要综合考虑其他监控工具和调试手段，以全面分析和定位问题。</p><h3 id="Linux系统线程ID的本质"><a href="#Linux系统线程ID的本质" class="headerlink" title="Linux系统线程ID的本质"></a>Linux系统线程ID的本质</h3><p>当在Linux系统中获取线程ID时，有三种常见的方法。</p><h4 id="方法一：pthread-create函数"><a href="#方法一：pthread-create函数" class="headerlink" title="方法一：pthread_create函数"></a>方法一：pthread_create函数</h4><p>调用pthread_create函数创建线程时，成功创建后可以通过第一个参数获取线程ID。这种方式获取的线程ID是pthread_t类型，实际上是一个指向线程控制块（Thread Control Block）的指针。因为不同的进程可能有相同地址的内存块，所以通过该方法获取的线程ID可能不是全系统唯一的，一般是一个较大的数字（内存地址）。</p><h4 id="方法二：pthread-self函数"><a href="#方法二：pthread-self函数" class="headerlink" title="方法二：pthread_self函数"></a>方法二：pthread_self函数</h4><p>在需要获取线程ID的线程内部，可以调用pthread_self函数获取当前线程的ID。这种方式也返回pthread_t类型的线程ID，与方法一相同。同样地，该ID可能不是全系统唯一的，而是线程内部的唯一标识。</p><h4 id="方法三：系统调用"><a href="#方法三：系统调用" class="headerlink" title="方法三：系统调用"></a>方法三：系统调用</h4><p>通过系统调用可以获取系统范围内全局唯一的线程ID。在Linux中，这个线程ID是轻量级进程（LWP）的ID。轻量级进程是早期Linux系统中通过进程实现的线程，因此这种线程ID被称为LWP ID。与方法一和方法二不同，该ID是一个较小的整数值，通常在系统范围内唯一标识一个线程。</p><p>需要注意的是，现代Linux系统已经发展为更加完善的多线程模型（如NPTL），线程不再是通过进程实现的，而是直接使用内核线程。尽管底层实现有所不同，但在概念上仍然可以将线程ID视为轻量级进程的ID。</p><pre><code>#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;void* thread_proc(void* arg)&#123;    pthread_t* tid1 = (pthread_t*)arg;    int tid2 = syscall(SYS_gettid);    pthread_t tid3 = pthread_self();        while(true)    &#123;        printf(&quot;tid1: %ld, tid2: %ld, tid3: %ld\n&quot;, *tid1, tid2, tid3);        sleep(1);    &#125;    &#125;int main()&#123;    pthread_t tid;    pthread_create(&amp;tid, NULL, thread_proc, &amp;tid);        pthread_join(tid, NULL);        return 0;&#125;</code></pre><p>以上代码在新开的线程中使用上面介绍的三种方式获取线程ID并打印<br>tid2即LWP的ID，而tid1和tid3是一个内存地址。</p><h3 id="C-11获取当前线程ID的方法"><a href="#C-11获取当前线程ID的方法" class="headerlink" title="C++11获取当前线程ID的方法"></a>C++11获取当前线程ID的方法</h3><p>C++11的线程库可以使用std：：this_thread类的get_id获取当前线程ID，这是一个类静态方法。<br>当然，也可以使用std：：thread的get_id获取指定线程的ID，这是一个类实例方法。<br>在C++11的线程库中，可以使用<code>std::this_thread</code>类的<code>get_id</code>静态方法来获取当前线程的ID。这个方法返回的是<code>std::thread::id</code>类型的对象，它是一个包装类型，不能直接强制转换为整型。</p><p>为了输出线程ID或将其转换为整型，可以使用以下方法：</p><ol><li>使用输出流（如<code>std::cout</code>）来打印线程ID：</li></ol><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;int main() &#123;    std::thread::id threadId = std::this_thread::get_id();    std::cout &lt;&lt; &quot;Thread ID: &quot; &lt;&lt; threadId &lt;&lt; std::endl;    return 0;&#125;</code></pre><ol start="2"><li>将线程ID转换为字符串类型，然后再将字符串转换为整型：</li></ol><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;sstream&gt;int main() &#123;    std::thread::id threadId = std::this_thread::get_id();    std::ostringstream oss;    oss &lt;&lt; threadId;    std::string threadIdStr = oss.str();        // 转换为整型    int threadIdInt = std::stoi(threadIdStr);        std::cout &lt;&lt; &quot;Thread ID: &quot; &lt;&lt; threadIdInt &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>需要注意的是，在C++11的线程库中，<code>std::thread::id</code>类型没有提供直接转换为整型的接口，因此需要通过字符串转换来实现这一目的。这确实可能会导致一些不便，但可以通过上述方法来获取并处理线程ID。</p><h2 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h2><h3 id="Linux下等待线程结束"><a href="#Linux下等待线程结束" class="headerlink" title="Linux下等待线程结束"></a>Linux下等待线程结束</h3><p>在Linux下等待线程结束可以使用<code>pthread_join</code>函数。该函数用于等待指定线程的退出，并接收它的返回值（退出码）。</p><p><code>pthread_join</code>函数的签名如下：</p><pre><code class="cpp">#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void** retval);</code></pre><p>其中，<code>thread</code>参数是需要等待的线程ID，<code>retval</code>是一个输出参数，用于接收等待线程的退出码。退出码可以通过在线程函数中使用<code>pthread_exit</code>函数指定，或者通过线程函数中的<code>return</code>语句返回。如果不需要获取退出码，可以将<code>retval</code>设置为<code>NULL</code>。</p><p>使用<code>pthread_join</code>函数时，当前线程（调用<code>pthread_join</code>的线程）会被挂起，进入等待状态，不会消耗CPU时间片。只有当目标线程退出后，调用<code>pthread_join</code>的线程才会被唤醒，继续执行后续逻辑。</p><p>下面是一个示例，演示了如何使用<code>pthread_join</code>函数等待工作线程退出，并从文件中读取时间并显示在屏幕上：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;pthread.h&gt;// 线程函数，将当前系统时间写入文件后退出void* workerThread(void* arg) &#123;    std::ofstream file(&quot;time.txt&quot;);    if (file.is_open()) &#123;        time_t currentTime = time(nullptr);        file &lt;&lt; ctime(&amp;currentTime);        file.close();    &#125;    pthread_exit(nullptr);&#125;int main() &#123;    pthread_t thread;    int result = pthread_create(&amp;thread, nullptr, workerThread, nullptr);    if (result != 0) &#123;        std::cerr &lt;&lt; &quot;Failed to create thread.&quot; &lt;&lt; std::endl;        return 1;    &#125;        // 等待工作线程退出    result = pthread_join(thread, nullptr);    if (result != 0) &#123;        std::cerr &lt;&lt; &quot;Failed to join thread.&quot; &lt;&lt; std::endl;        return 1;    &#125;        // 从文件中读取时间并显示在屏幕上    std::ifstream file(&quot;time.txt&quot;);    if (file.is_open()) &#123;        std::string timeStr;        std::getline(file, timeStr);        std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; timeStr &lt;&lt; std::endl;        file.close();    &#125;        return 0;&#125;</code></pre><p>在上述示例中，程序启动时创建了一个工作线程，工作线程将当前系统时间写入文件后退出。主线程使用<code>pthread_join</code>函数等待工作线程退出。一旦工作线程退出，主线程从文件中读取时间并显示在屏幕上。</p><h3 id="Windows下等待线程结束"><a href="#Windows下等待线程结束" class="headerlink" title="Windows下等待线程结束"></a>Windows下等待线程结束</h3><p>在Windows下，可以使用<code>WaitForSingleObject</code>函数或<code>WaitForMultipleObjects</code>函数等待线程结束。</p><ol><li>使用<code>WaitForSingleObject</code>函数等待一个线程结束：</li></ol><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;DWORD WINAPI workerThread(LPVOID lpParam) &#123;    // 线程逻辑    return 0;&#125;int main() &#123;    HANDLE threadHandle;    DWORD threadId;        // 创建线程    threadHandle = CreateThread(nullptr, 0, workerThread, nullptr, 0, &amp;threadId);    if (threadHandle == nullptr) &#123;        std::cerr &lt;&lt; &quot;Failed to create thread.&quot; &lt;&lt; std::endl;        return 1;    &#125;        // 等待线程结束    DWORD result = WaitForSingleObject(threadHandle, INFINITE);    if (result == WAIT_OBJECT_0) &#123;        std::cout &lt;&lt; &quot;Thread finished.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cerr &lt;&lt; &quot;Failed to wait for thread.&quot; &lt;&lt; std::endl;    &#125;        // 关闭线程句柄    CloseHandle(threadHandle);        return 0;&#125;</code></pre><p>在上述示例中，使用<code>CreateThread</code>函数创建了一个线程，并获取了线程句柄和线程ID。然后，使用<code>WaitForSingleObject</code>函数等待线程结束。<code>WaitForSingleObject</code>函数的第一个参数是线程句柄，第二个参数是等待时间，这里使用<code>INFINITE</code>表示无限等待。函数返回后，可以根据返回值判断等待是否成功。</p><ol start="2"><li>使用<code>WaitForMultipleObjects</code>函数等待多个线程结束：</li></ol><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;DWORD WINAPI workerThread1(LPVOID lpParam) &#123;    // 线程1逻辑    return 0;&#125;DWORD WINAPI workerThread2(LPVOID lpParam) &#123;    // 线程2逻辑    return 0;&#125;int main() &#123;    HANDLE threadHandles[2];    DWORD threadIds[2];        // 创建线程1    threadHandles[0] = CreateThread(nullptr, 0, workerThread1, nullptr, 0, &amp;threadIds[0]);    if (threadHandles[0] == nullptr) &#123;        std::cerr &lt;&lt; &quot;Failed to create thread 1.&quot; &lt;&lt; std::endl;        return 1;    &#125;        // 创建线程2    threadHandles[1] = CreateThread(nullptr, 0, workerThread2, nullptr, 0, &amp;threadIds[1]);    if (threadHandles[1] == nullptr) &#123;        std::cerr &lt;&lt; &quot;Failed to create thread 2.&quot; &lt;&lt; std::endl;        return 1;    &#125;        // 等待两个线程结束    DWORD result = WaitForMultipleObjects(2, threadHandles, TRUE, INFINITE);    if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + 2) &#123;        std::cout &lt;&lt; &quot;All threads finished.&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cerr &lt;&lt; &quot;Failed to wait for threads.&quot; &lt;&lt; std::endl;    &#125;        // 关闭线程句柄    CloseHandle(threadHandles[0]);    CloseHandle(threadHandles[1]);        return 0;&#125;</code></pre><p>在上述示例中，使用<code>CreateThread</code>函数创建了两个线程，并获取了线程</p><p>句柄和线程ID。然后，使用<code>WaitForMultipleObjects</code>函数等待这两个线程结束。<code>WaitForMultipleObjects</code>函数的第一个参数是等待的对象数量，第二个参数是对象句柄数组，第三个参数表示是否等待所有对象都结束，第四个参数是等待时间。函数返回后，可以根据返回值判断等待是否成功。</p><p>请注意，上述示例中的线程函数使用的是Windows的线程函数签名，返回类型是<code>DWORD</code>。</p><h3 id="C-11提供的等待线程结果的函数"><a href="#C-11提供的等待线程结果的函数" class="headerlink" title="C++11提供的等待线程结果的函数"></a>C++11提供的等待线程结果的函数</h3><p>在C++11中，可以使用<code>std::thread</code>和<code>std::mutex</code>来等待线程结束。下面是将上述Windows版本的代码改写成C++11版本的示例：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;thread&gt;void workerThread() &#123;    // 线程逻辑&#125;int main() &#123;    std::thread threadObj(workerThread);        // 等待线程结束    threadObj.join();        std::cout &lt;&lt; &quot;Thread finished.&quot; &lt;&lt; std::endl;        return 0;&#125;</code></pre><p>在上述示例中，使用<code>std::thread</code>创建了一个线程对象，并传入线程函数<code>workerThread</code>。然后，使用<code>join</code>函数等待线程结束。<code>join</code>函数会阻塞当前线程，直到被等待的线程执行完毕。</p><p>如果有多个线程需要等待，可以使用<code>std::vector&lt;std::thread&gt;</code>来管理多个线程对象，并逐个调用<code>join</code>函数等待它们的结束。</p><p>需要注意的是，C++11的线程库在<code>&lt;thread&gt;</code>头文件中，而不是Windows的API函数。另外，C++11的线程库已经封装了线程的创建和管理，无需显式操作线程句柄。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译时常量的使用</title>
      <link href="/p/28630.html"/>
      <url>/p/28630.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译时常量的使用"><a href="#编译时常量的使用" class="headerlink" title="编译时常量的使用"></a>编译时常量的使用</h1><p>constexpr 关键字可以用于创建变量和函数，保证编译时对他们进行计算,一个 constexpr 变量是一个编译时完全确定的常数。一个 constexpr 函数至少对于某一组实参可以在编译期间产生一个编译期常数.一个 constexpr 函数不保证在所有情况下都会产生一个编译期常数,编译器也没法通用地检查这点。编译器唯一强制的是：constexpr 变量必须立即初始化,初始化只能使用字面量或常量表达式，后者不允许调用任何非 constexpr 函数.</p><p>例1：</p><pre><code>int main()&#123;    constexpr uint32_t ARRAY_SIZE&#123;5&#125;;    std::array&lt;uint32_t,ARRAY_SIZE&gt;myArray&#123;1,2,3,4,5&#125;;    for(auto&amp;&amp; num:myArray)    &#123;        std::cout&lt;&lt;num&lt;&lt;std::endl;    &#125;    return 0;&#125;</code></pre><p>constexpr 保证了在编译时可以计算值的大小，因为Array的大小必须在编译时确定。<br>此外，函数也可以使用constexpr</p><p>例2：</p><pre><code>constexpr uint32_t A(int a)&#123;    return a;&#125;</code></pre><p>constexpr还可以构建一个类<br>例3:</p><pre><code>class Test&#123;private:    uint32_t m_member;public:    constexpr Test(uint32_t a)        : m_member(a)    &#123;    &#125;    constexpr uint32_t getValue()&#123;        return m_member;    &#125;&#125;</code></pre><p>在c++11当中，constexpr不可以做c++代码的许多事情，比如创建变量和使用if语句循环语句<br>下面代码展示了c++14的constexpr用法<br>例4:</p><pre><code>constexpr uint32_t ArraySizeFunc(uint32_t para)&#123;    uint32_t value&#123;para&#125;;    if(value&gt;10)    &#123;        value=10;    &#125;    return value;&#125;</code></pre><p>实际上,constexpr返回的并不是常量<br>例5：</p><pre><code>constexpr int count()&#123;    return 99;&#125;int main()&#123;    int temp=count();    temp=2;    return 0;&#125;</code></pre><h2 id="constexpr-和-const"><a href="#constexpr-和-const" class="headerlink" title="constexpr 和 const"></a>constexpr 和 const</h2><p>一个很可能有的困惑是，它跟 const 用法上的区别到底是什么。产生这种困惑是正常的，毕竟 const 是个重载了很多不同含义的关键字。<br>const 的原本和基础的含义，自然是表示它修饰的内容不会变化</p><pre><code>const int n = 1:n = 2; // 出错！</code></pre><p>本质上，const 用来表示一个运行时常量<br>在 C++ 里，const 后面渐渐带上了现在的 constexpr 用法，也代表编译期常数。现在——在有了 constexpr 之后——我们应该使用 constexpr 在这些用法中替换 const了。<br>从编译器的角度，为了向后兼容性，const 和 constexpr 在很多情况下还是等价的。但有时候，它们也有些细微的区别，其中之一为是否内联的问题。</p><h3 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h3><p>C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，const 缺省是不内联的，而 constexpr 缺省就是内联的。这种区别在你用 &amp; 去取一个 const int 值的地址、或将其传到一个形参类型为 const int&amp; 的函数去的时候（这在 C++ 文档里的行话叫 ODR-use），就会体现出来。</p><pre><code>#include &lt;iostream&gt;struct magic &#123;    static const int number = 42;&#125;;int main() &#123;    std::cout &lt;&lt; magic::number &lt;&lt; std::endl;&#125;</code></pre><p>我们稍微改一点：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;struct magic &#123;    static const int number = 42;&#125;;int main() &#123;    std::vector&lt;int&gt; v;    v.push_back(magic::number);    std::cout &lt;&lt; v[0] &lt;&lt; std::endl;&#125;</code></pre><p>程序在链接时就会报错了，说找不到 magic::number。这是因为 ODR-use 的类静态常量也需要有一个定义，在没有内联变量之前需要在某一个源代码文件（非头文件）中这样写：</p><pre><code>const int magic::number = 42;</code></pre><p>必须正正好好一个，多了少了都不行，所以叫 one definition rule。内联函数，现在又有了内联变量，以及模板，则不受这条规则限制<br>修正这个问题的简单方法是把 magic 里的 static const 改成 static constexpr 或static inline const。前者可行的原因是，类的静态 constexpr 成员变量默认就是内联的。const 常量和类外面的 constexpr 变量不默认内联，需要手工加 inline 关键字才会变成内联</p><h3 id="constexpr-变量模板"><a href="#constexpr-变量模板" class="headerlink" title="constexpr 变量模板"></a>constexpr 变量模板</h3><p>变量模板是 C++14 引入的新概念。之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。constexpr 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。</p><pre><code>template &lt;class T&gt;inline constexpr bool is_trivially_destructible_v = is_trivially_destructible&lt;T&gt;::value;</code></pre><p>了解了变量也可以是模板之后，上面这个代码就很容易看懂了吧？这只是一个小小的语法糖，允许我们把 is_trivially_destructible<T>::value 写成is_trivially_destructible_v<T>。</T></T></p><h3 id="constexpr-变量仍是-const"><a href="#constexpr-变量仍是-const" class="headerlink" title="constexpr 变量仍是 const"></a>constexpr 变量仍是 const</h3><p>一个 constexpr 变量仍然是 const 常类型。需要注意的是，就像 const char* 类型是指向常量的指针、自身不是 const 常量一样，下面这个表达式里的 const 也是不能缺少的：</p><pre><code>constexpr int a = 42;constexpr const int&amp; b = a;</code></pre><p>第二行里，constexpr 表示 b 是一个编译期常量，const 表示这个引用是常量引用。去掉这个 const 的话，编译器就会认为你是试图将一个普通引用绑定到一个常数上，报一个类似下面的错误信息</p><pre><code>error: binding reference of type ‘int&amp;’ to ‘const int’ discards qualifiers  </code></pre><p>如果按照 const 位置的规则，constexpr const int&amp; b 实际该写成 const int&amp;constexpr b。不过，constexpr 不需要像 const 一样有复杂的组合，因此永远是写在类型前面的</p><h2 id="constexpr-构造函数和字面类型"><a href="#constexpr-构造函数和字面类型" class="headerlink" title="constexpr 构造函数和字面类型"></a>constexpr 构造函数和字面类型</h2>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake基础</title>
      <link href="/p/8a6d8fe.html"/>
      <url>/p/8a6d8fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="cmake基础"><a href="#cmake基础" class="headerlink" title="cmake基础"></a>cmake基础</h1><h2 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h2><p>编写如下文件</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123;    printf(&quot;hello world\n&quot;);    return 0;&#125;</code></pre><p>然后编写如下CMakeLists.txt</p><pre><code># CMake 指定运行此配置文件所需的 CMake 的最低版本cmake_minimum_required (VERSION 2.8)# 该命令表示项目的名称是singleFileproject (singleFile)# 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件add_executable(singleFile main.cpp)</code></pre><p>使用cmake命令进行配置编译并编译</p><pre><code>mkdir debugcd    debugcmake ../make</code></pre><h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><p>同级目录<br>在同一文件夹下创建如下文件</p><pre><code>./sameDirMultSrc    |    +---------tool.h    |    +---------tool.cpp    |    +---------main.cpp</code></pre><p>我们在同级目录下编写如下CMakeLists.txt</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (sameDirMultSrc)# 指定生成目标add_executable(sameDirMultSrc main.cpp tool.cpp)</code></pre><ul><li><p>与上面的CMakeLists.txt比较，我们只是在add_executable命令中多添加了一个源文件</p></li><li><p>当源文件很多是这样写不利于管理，cmake中有如下命令来简化这种写法</p><p>  aux_source_directory</p></li></ul><p>该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><pre><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code></pre><p>最终形式的CMakeLists.txt为：</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (sameDirMultSrc)# 查找当前目录下的所有源文件# 并将名称保存到 SRC 变量aux_source_directory(. SRC)# 指定生成目标#add_executable(sameDirMultSrc main.cpp tool.cpp)add_executable(sameDirMultSrc $&#123;SRC&#125;)</code></pre><h2 id="多级目录"><a href="#多级目录" class="headerlink" title="多级目录"></a>多级目录</h2><p>创建如下目录结构，并在各目录下创建对应文件</p><pre><code>./sameDir    |    +-----main.cpp    |    +-----./tool        |        +-----tool.h        |        +-----tool.cpp    </code></pre><p>为了方便，我们将tool目录里的文件编译为动态库，并在main中调用</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (sameDir)#导入头文件所在路径#PROJECT_SOURCE_DIR为cmake宏include_directories(&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tool&quot;)# 查找当前目录下的所有源文件# 并将名称保存到 SRC 变量aux_source_directory(. SRC)# 指定生成目标add_executable(sameDir $&#123;SRC&#125;)# 添加 math 子目录add_subdirectory(tool)# 添加链接库 #该命令要在add_executable命令下方，否则报错target_link_libraries(sameDir Tool)</code></pre><ul><li>add_subdirectory 指明本项目包含一个子目录 tool，这样 tool 目录下的 CMakeLists.txt 文件和源代码也会被处理</li><li>使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 Tool 的链接库</li></ul><p>子目录中的CMakeLists.txt文件为</p><pre><code># 查找当前目录下的所有源文件# 并将名称保存到 LIB_SRC 变量aux_source_directory(. LIB_SRC)#生成链接库add_library(Tool $&#123;LIB_SRC&#125;)</code></pre><p>• add_library将源文件编译为静态库 详情参照<a href="https://cmake.org/cmake/help/latest/command/add_library.html#id2">https://cmake.org/cmake/help/latest/command/add_library.html#id2</a></p><h2 id="自定义编译选项"><a href="#自定义编译选项" class="headerlink" title="自定义编译选项"></a>自定义编译选项</h2><p>当我们需要在代码中做预编译处理时，我们如何通过cmake来指定相关的预处理宏呢？<br>现在我们将tool库设为一个可选库，如果该选项是ON，我们就使用其中的Message函数，否则我们使用系统printf函数。</p><p>为了实现这个功能我们需要在CMakeLists.txt文件中这样写</p><pre><code># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (compileOption)#通过cmake处理预定义头文件configure_file (    &quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;    &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;    )# 是否使用自己的 Tool 库option (USE_TOOL &quot;Use tool&quot; on)if(USE_TOOL)    #导入头文件所在路径    #PROJECT_SOURCE_DIR为cmake宏    include_directories(        $&#123;PROJECT_SOURCE_DIR&#125;/tool        $&#123;PROJECT_BINARY_DIR&#125;    )    # 添加 math 子目录    add_subdirectory(tool)    set (EXTRA_LIBS Tool)endif(USE_TOOL)# 查找当前目录下的所有源文件# 并将名称保存到 SRC 变量aux_source_directory(. SRC)# 指定生成目标add_executable(compileOption $&#123;SRC&#125;)# 添加链接库 #该命令要在add_executable命令下方，否则报错target_link_libraries(compileOption $&#123;EXTRA_LIBS&#125;)</code></pre><ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成</li><li>option 命令添加了一个 USE_TOOL 选项，并且默认值为 ON,该选项可以在cmake时指定为OFF</li><li>if（USE_TOOL）可以根据变量的值来确定是否使用TOOL库</li><li>PROJECT_SOURCE_DIR为cmake预先定义好的变量，可以参考cmake文档</li><li>EXTRA_LIBS 为自定义变量，用于保存静态库名称方便可执行文件链接链接</li><li>set的用法请查看该链接</li></ul><p>我们编写一个config.h.in文件放在工程目录下</p><pre><code>//config.h.in#cmakedefine USE_MYMATH3. 我们的源文件这样写//main.cpp#include &quot;config.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#ifdef USE_TOOL#include &quot;tool.h&quot;#endif //USE_TOOLint main(int argc, char *argv[])&#123;#ifdef USE_TOOL    Message(string(&quot;hello world!&quot;));#else    printf(&quot;%s %d %s&quot;,__FILE__, __LINE__, &quot;hello world!\n&quot;);#endif //USE_TOOL    return 0;&#125;</code></pre><p>运行cmake</p><pre><code>mkdir buildcd buildcmake .. （等价与cmake .. -DUSE_TOOL=1） 或者 cmake .. -DUSE_TOOL=0make./compileOption</code></pre><h2 id="编译不同版本"><a href="#编译不同版本" class="headerlink" title="编译不同版本"></a>编译不同版本</h2><pre><code>#编译Debugset(CMAKE_BUILD_TYPE &quot;Debug&quot;)#编译Releaseset(CMAKE_BUILD_TYPE &quot;Release&quot;)#支持gdbset(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</code></pre><p>以上宏定义均可在cmake时定义,具体方法为</p><pre><code>cmake . -DCMAKE_BUILD_TYPE=Debug</code></pre><h2 id="添加版本号"><a href="#添加版本号" class="headerlink" title="添加版本号"></a>添加版本号</h2><p>我们为项目添加版本号，并在源码中使用它<br>在CMakeLists.txt文件中project命令后添加如下命令</p><pre><code># CMake 指定运行此配置文件所需的 CMake 的最低版本cmake_minimum_required (VERSION 2.8)# 该命令表示项目的名称是singleFileproject (version)set(VERSION_MAJOR 1)set(VERSION_MINOR 0)configure_file (    &quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;    &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;)include_directories(    $&#123;PROJECT_BINARY_DIR&#125;)# 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件add_executable(version main.cpp)</code></pre><p>在config.h.in文件中写如下语句</p><pre><code>#define VERSION_MAJOR @VERSION_MAJOR@#define VERSION_MINOR @VERSION_MINOR@</code></pre><p>我们在代码中这样使用它</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;config.h&quot;int main(int argc, char *argv[])&#123;        printf(&quot;%s Version %d.%d\n&quot;, argv[0], VERSION_MAJOR, VERSION_MINOR);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp代码到exe</title>
      <link href="/p/43341.html"/>
      <url>/p/43341.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-从代码到可执行二进制文件"><a href="#C-从代码到可执行二进制文件" class="headerlink" title="C++从代码到可执行二进制文件"></a>C++从代码到可执行二进制文件</h1><p>test.cpp–&gt;test.i–&gt;test.s–&gt;test.o<br>gcc&#x2F;g++是GNU编译器套件中用于编译C和C++程序的工具。下面是一些常用的选项和其功能以及生成的目标文件类型：</p><ul><li><code>-E</code>：预处理源代码文件，不进行编译，生成预处理后的文件。目标文件类型为 <code>.i</code>。</li><li><code>-S</code>：将源代码编译成汇编程序，不进行汇编，生成汇编文件。目标文件类型为 <code>.s</code>。</li><li><code>-c</code>：编译源代码并将其汇编生成目标文件，但不进行连接操作。目标文件类型为 <code>.o</code>。</li><li><code>-o</code>：指定生成的目标文件的文件名。可以使用该选项后跟文件名来指定生成的目标文件的名称。</li><li><code>-m32</code>：按照32位架构进行编译，生成32位的目标文件。适用于32位系统。</li><li><code>-m64</code>：按照64位架构进行编译，生成64位的目标文件。适用于64位系统。</li></ul><p>这些选项可根据需要进行组合使用，以实现所需的编译、预处理和生成目标文件的操作。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预处理阶段编程的操作目标是“源码”，用各种指令控制预处理器，把源码改造成另一种形式。预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。预处理指令都以符号“#”开头，这个你应该很熟悉了。但同时你也应该意识到，虽然都在一个源文件里，但它不属于 C+ 语言，它走的是预处理器，不受 C++ 语法规则的<br>约束。gcc的预处理是预处理器cpp来完成的，你可以通过如下命令对test.c进行预处理：</p><pre><code>gcc -E -I./inc main.cpp -o main.i</code></pre><p>或者直接调用cpp命令</p><pre><code>$ cpp main.cpp -I./inc -o main.i</code></pre><p>上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-I指定头文件目录，这里指定的是我们自定义的头文件目录；-o指定输出文件名。<br>经过预处理之后代码体积会大很多,预处理之后的程序还是文本，可以用文本编辑器打开<br>预处理编程不太遵守 C++ 代码的风格。一般来说，预处理指令不应该受C++ 代码缩进层次的影响，不管是在函数、类里，还是在 if、for 等语句里，永远是<strong>顶格写</strong></p><p>单独的一个“#”也是一个预处理指令，叫“空指令”，可以当作特别的预处理空行。而“#”与后面的指令之间也可以有空格，从而实现缩进，方便排版。</p><pre><code># // 预处理空行#if __linux__ // 预处理检查宏是否存在# define HAS_LINUX 1 // 宏定义，有缩进#endif // 预处理条件语句结束# // 预处理空行</code></pre><p>预处理程序也有它的特殊性，暂时没有办法调试，不过可以让 GCC 使用“-E”选项，略过后面的编译链接，只输出预处理后的源码<br>例如：</p><pre><code>g++ test03.cpp -E -o a.cxx #输出预处理后的源码</code></pre><h3 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h3><p>预处理指令<code>#include</code>在C++中用于包含文件。它的作用是将指定的文件内容插入到源文件中。需要注意的是，<code>#include</code>并不只是用于包含头文件，它可以包含任意类型的文件，包括源码、普通文本、图片、音频和视频等。</p><p>使用<code>#include</code>指令时，编译器会将指定文件的内容直接复制粘贴到源文件中，没有进行太多的检查和处理。这也意味着，如果包含的文件有错误或无法处理，会导致编译错误。</p><p>为了防止头文件被重复包含，通常会在头文件中添加”Include Guard”（包含保护）。这是通过使用<code>#ifndef</code>、<code>#define</code>和<code>#endif</code>预处理指令来实现的，示例如下：</p><pre><code class="cpp">#ifndef _XXX_H_INCLUDED_#define _XXX_H_INCLUDED_// 头文件内容#endif // _XXX_H_INCLUDED_</code></pre><p>“Include Guard”会检查一个标识符是否已定义，如果未定义，则定义该标识符并包含头文件内容，防止头文件被多次包含。</p><p>这种方法虽然有些原始，但在当前（C++11&#x2F;14）仍然是有效且向下兼容的。因此，建议在所有的头文件中都使用”Include Guard”来保护头文件。</p><p>除了常用的包含头文件外，你还可以利用<code>#include</code>的特性进行一些巧妙的操作。例如，你可以编写一些代码片段并将其存储在<code>.inc</code>文件中，然后有选择地加载这些代码片段，通过这种方式可以实现源码级别的抽象。</p><p>需要注意的是，对于包含非头文件的其他文件（如图片、音频、视频等），编译器不会对其进行处理，而只是将其内容插入到源文件中。因此，确保这些文件在源文件中的使用是合理且正确的。</p><p>通过将大数组存储在一个独立的文件（例如”calc_values.inc”）中，然后使用<code>#include</code>将其插入到源文件中，可以节省大量空间并使代码更加整洁。</p><p>以下是示例代码：</p><pre><code class="cpp">static uint32_t calc_table[] = &#123;# include &quot;calc_values.inc&quot; // 非常大的一个数组，细节被隐藏&#125;;</code></pre><p>在”calc_values.inc”文件中，你可以将数值计算的大数组以相同的格式存储，例如：</p><pre><code class="cpp">0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,...</code></pre><p>通过这种方式，你可以将大数组的细节隐藏起来，减小源文件的体积，并提高代码的可读性和维护性。同时，如果需要修改大数组的数值，只需在”calc_values.inc”文件中进行修改，而无需修改源文件。</p><p>需要注意的是，使用这种方法时，确保”calc_values.inc”文件的路径正确，并且文件内容符合C++的语法规则，以确保成功地包含大数组的数值。</p><h3 id="宏定义（-define-x2F-undef）"><a href="#宏定义（-define-x2F-undef）" class="headerlink" title="宏定义（#define&#x2F;#undef）"></a>宏定义（#define&#x2F;#undef）</h3><p>宏定义(#define)在C++中是非常强大和灵活的工具，可以实现各种代码替换和功能扩展。通过宏定义，可以定义常量、变量、函数、类型别名等，并且可以在预处理阶段将宏调用处替换为相应的文本。</p><p>然而，宏定义的灵活性也可能导致代码可读性和维护性的下降。如果滥用宏定义，过度使用复杂的宏，或者在不恰当的地方使用宏，可能会导致代码难以理解、难以调试和难以维护。如果过于随意地去使用宏来写程序，就有可能把正常的 C++代码搞得“千疮百孔”，替换来替换去，都不知道真正有效的代码是什么样子了。</p><p>因为宏的展开、替换发生在预处理阶段，不涉及函数调用、参数传递、指针寻址，没有任何运行期的效率损失，所以对于一些调用频繁的小代码片段来说，用宏来封装的效果比 <code>inline</code> 关键字要更好，因为它真的是源码级别的无条件内联。下面有几个摘自 Nginx的示例：</p><pre><code class="c">#define ngx_tolower(c) ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? (c | 0x20) : c)#define ngx_toupper(c) ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ? (c &amp; ~0x20) : c)#define ngx_memzero(buf, n) (void) memset(buf, 0, n)</code></pre><p>其次，宏是没有作用域概念的，永远是全局生效。所以，对于一些用来简化代码、起临时作用的宏，最好是用完后尽快用 <code>#undef</code> 取消定义，避免冲突的风险。像下面这样：</p><pre><code class="c">#define CUBE(a) (a) * (a) * (a) // 定义一个简单的求立方的宏cout &lt;&lt; CUBE(10) &lt;&lt; endl; // 使用宏简化代码cout &lt;&lt; CUBE(15) &lt;&lt; endl; // 使用宏简化代码#undef CUBE // 使用完毕后立即取消定义</code></pre><p>另一种做法是宏定义前先检查，如果之前有定义就先 <code>undef</code>，然后再重新定义：</p><pre><code class="c">#ifdef AUTH_PWD // 检查是否已经有宏定义# undef AUTH_PWD // 取消宏定义#endif // 宏定义检查结束#define AUTH_PWD &quot;xxx&quot; // 重新宏定义</code></pre><p>有一个比较实际的例子，用宏来代替直接定义名字空间（namespace）：</p><pre><code class="c">#define BEGIN_NAMESPACE(x) namespace x &#123;#define END_NAMESPACE(x) &#125;BEGIN_NAMESPACE(my_own)... // functions and classesEND_NAMESPACE(my_own)</code></pre><p>这里定义了两个宏：BEGIN_NAMESPACE 和 END_NAMESPACE，虽然只是简单的文本替换，但它全大写的形式非常醒目，可以很容易地识别出名字空间开始和结束的位置。</p><h3 id="条件编译（-if-x2F-else-x2F-endif）"><a href="#条件编译（-if-x2F-else-x2F-endif）" class="headerlink" title="条件编译（#if&#x2F;#else&#x2F;#endif）"></a>条件编译（#if&#x2F;#else&#x2F;#endif）</h3><p>利用“#define”定义出的各种宏，我们还可以在预处理阶段实现分支处理，通过判断宏的数值来产生不同的源码，改变源文件的形态，这就是“条件编译”。条件编译是预处理阶段的重要功能之一，通过使用条件指令 <code>#if</code> 和预定义宏来实现分支处理，根据宏的值产生不同的源码，从而改变源文件的形态。</p><p>在编译环境中，通常会预定义一些宏，用于表示CPU支持的特殊指令集、操作系统&#x2F;编译器&#x2F;程序库的版本、语言特性等。通过使用这些宏，可以在预处理阶段进行各种优化，生成适合当前系统的源码。</p><p>一个必须了解的宏是 <code>__cplusplus</code>，它用于标记C++语言的版本号。通过使用它，可以判断当前是C还是C++，以及是C++98还是C++11等。下面是一个示例：</p><pre><code class="c">#ifdef __cplusplus // 定义了这个宏就是在用C++编译    extern &quot;C&quot; &#123; // 函数按照C的方式去处理#endif        void a_c_function(int a);#ifdef __cplusplus // 检查是否是C++编译    &#125; // extern &quot;C&quot; 结束#endif#if __cplusplus &gt;= 201402 // 检查C++标准的版本号    cout &lt;&lt; &quot;c++14 or later&quot; &lt;&lt; endl; // 201402就是C++14#elif __cplusplus &gt;= 201103 // 检查C++标准的版本号    cout &lt;&lt; &quot;c++11 or before&quot; &lt;&lt; endl; // 201103是C++11#else // __cplusplus &lt; 201103 // 199711是C++98# error &quot;c++ is too old&quot; // 太低则预处理报错#endif // __cplusplus &gt;= 201402 // 预处理语句结束</code></pre><p>除了 <code>__cplusplus</code>，C++中还有许多其他预定义的宏，例如表示源文件信息的 <code>__FILE__</code>、<code>__LINE__</code>、<code>__DATE__</code>，以及一些用于测试语言特性的宏，如 <code>__cpp_decltype</code>、<code>__cpp_decltype_auto</code>、<code>__cpp_lib_make_unique</code>等。这些宏可以用于根据特定的语言支持情况执行不同的代码。</p><p>不过，与优化更密切相关的底层系统信息在 C++ 语言标准里没有定义，但编译器通常都会提供，比如 GCC 可以使用一条简单的命令查看：</p><pre><code>g++ -E -dM - &lt; /dev/null#define __GNUC__ 5#define __unix__ 1#define __x86_64__ 1#define __UINT64_MAX__ 0xffffffffffffffffUL</code></pre><p>基于它们，可以更精细地根据具体的语言、编译器、系统特性来改变源码，有，就用新特性；没有，就采用变通实现：比如c++网络通信，就会用到这些。</p><p>除了这些内置宏，也可以用其他手段自己定义更多的宏来实现条件编译。比如，Nginx就使用 Shell 脚本检测外部环境，生成一个包含若干宏的源码配置文件，再条件编译包含不同的头文件，实现操作系统定制化：</p><pre><code>#if (NGX_FREEBSD)#include &lt;ngx_freebsd.h&gt;#elif (NGX_LINUX)#include &lt;ngx_linux.h&gt;#elif (NGX_SOLARIS)#include &lt;ngx_solaris.h&gt;#elif (NGX_DARWIN)#include &lt;ngx_darwin.h&gt;#endif</code></pre><p>条件编译还有一个特殊的用法，那就是，使用“#if 1”“#if 0”来显式启用或者禁用大段代码，要比“&#x2F;* … *&#x2F;”的注释方式安全得多</p><pre><code>#if 0 // 0即禁用下面的代码，1则是启用... // 任意的代码#endif // 预处理结束#if 1 // 1启用代码，用来强调下面代码的必要性... // 任意的代码#endif // 预处理结束</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译是预处理之后的阶段，它的输入是（经过预处理的）C++ 源码，输出是二进制可执行文件（也可能是汇编文件、动态库或者静态库）。这个处理动作就是由编译器来执行的。和预处理阶段一样，在这里你也可以“面向编译器编程”，用一些指令或者关键字让编译器按照你的想法去做一些事情。只不过，这时你要面对的是庞大的 C++ 语法，而不是简单的文本替换，难度可以说是高了好几个数量级。编译只是把我们写的代码转为汇编代码，它的工作是检查词法和语法规则，所以，如果程序没有词法或则语法错误，那么不管逻辑是怎样错误的，都不会报错。<br>编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。</p><pre><code>$ gcc -S -I./inc main.cpp -o main.s</code></pre><p>上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件<br>编译过程可以使用注解标签或者静态断言，<a href="https://whl963854.github.io/p/acd745d4.html">注解标签</a>我们已经介绍过，可以左侧导航栏搜索参考。下面主要介绍静态断言。</p><h3 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h3><p>“属性”像是给编译器的一个”提示”或”告知”，无法进行计算，还算不上是编程。而静态断言（static_assert），则更接近编程的范畴。</p><p>你可能使用过 assert，它用来断言一个表达式必定为真。比如说，数字必须是正数，指针必须非空、函数必须返回 true：</p><pre><code class="cpp">assert(i &gt; 0 &amp;&amp; &quot;i must be greater than zero&quot;);assert(p != nullptr);assert(!str.empty());</code></pre><p>当程序（也就是 CPU）运行到 assert 语句时，会计算表达式的值，如果为 false，就会输出错误消息并调用 abort() 终止程序的执行。</p><p>注意，assert 虽然是一个宏，但在预处理阶段不生效，而是在运行阶段才起作用，因此称为”动态断言”。</p><p>静态断言（static_assert）与 assert 类似，但它只在编译时生效，不可见于运行阶段，因此被称为”静态”断言。</p><p>静态断言是编译阶段中检测各种条件的”断言”，编译器会计算 static_assert 的表达式的值，如果为 false，就会报错，导致编译失败。</p><p>例如，在斐波那契数列计算函数中，可以使用静态断言确保模板参数必须大于等于零：</p><pre><code class="cpp">template&lt;int N&gt;struct fib&#123;    static_assert(N &gt;= 0, &quot;N &gt;= 0&quot;);    static const int value = fib&lt;N - 1&gt;::value + fib&lt;N - 2&gt;::value;&#125;;</code></pre><p>另一个例子是，如果想保证程序只在 64 位系统上运行，可以使用静态断言在编译阶段检查 long 的大小，必须是 8 个字节：</p><pre><code class="cpp">static_assert(sizeof(long) &gt;= 8, &quot;must run on x64&quot;);</code></pre><p>需要注意的是，静态断言运行在编译阶段，只能看到编译时的常数和类型，无法看到运行时的变量、指针、内存数据等，因此是”静态”的。所以不要简单地将 assert 的习惯搬过来使用。</p><p>举个例子，下面的代码试图检查空指针，但由于变量只能在运行阶段出现，在编译阶段无法处理，所以静态断言无法应用于此类场景。</p><pre><code class="cpp">char* p = nullptr;static_assert(p == nullptr, &quot;some error.&quot;); // 错误用法</code></pre><p>静态断言的表达式看起来可能很奇怪，既有模板符号<code>&lt;&gt;</code>，又有作用</p><p>域符号<code>::</code>，与运行阶段的普通表达式有很大的不同。初次见到这样的代码可能会感到困惑。这也是由于 C++ 本身并不是为编译阶段编程而设计的。受到语言的限制，编译阶段编程只能对传统的语法要素进行一些”魔改”：将类当作函数、将模板参数当作函数参数、将<code>::</code>用作返回值。这类似于函数式编程，只是静态断言运行在编译阶段。</p><p>为了更好地发挥静态断言的威力，还需要结合标准库中的”type_traits”，它提供了各种编译期”函数”来对应这些概念。</p><pre><code class="cpp">static_assert(is_integral&lt;T&gt;::value, &quot;int&quot;);static_assert(is_pointer&lt;T&gt;::value, &quot;ptr&quot;);static_assert(is_default_constructible&lt;T&gt;::value, &quot;constructible&quot;);</code></pre><p>静态断言的使用需要时刻将自己代入编译器的角色，像编译器那样思考。需要思考的是，在编译阶段能否计算出断言表达式的结果。在泛型编程中，这些检查条件表面上看起来是”不言自明”的，但要精确地用 C++ 语言描述出来并不简单。因此，要更好地发挥静态断言的作用，还需要使用标准库中的”type_traits”来辅助实现。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程将上一步的汇编代码(main.s)转换成机器码(machine code)，这一步产生的文件叫做目标文件(main.o)，是二进制格式。<br>gcc&#x2F;g++的汇编过程通过 as 命令完成，所以我们可以通过g++ -c或as命令完成汇编：</p><pre><code>g++ -c -I include/ main.cpp -o main.o</code></pre><p>或者直接调用 as 命令</p><pre><code>as main.s -o main.o</code></pre><p>上述指令中： - g++ -c让编译器在汇编之后退出，等价于 as - -I include&#x2F;仍是用于指定头文件目录 - main.cpp是要汇编的源文件 - -o main.o用于指定生成的文件名<br>汇编这一步需要为每一个源文件（本文示例代码中为main.cpp、func.cpp）产生一个目标文件。因此func.cpp也需要执行一次这个汇编过程产生一个func.o文件:</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>C&#x2F;C++代码经过汇编之后生成的目标文件(*.o)并不是最终的可执行二进制文件，而仍是一种中间文件(或称临时文件)，目标文件仍然需要经过链接(Link)才能变成可执行文件。</p><p>既然目标文件和可执行文件的格式是一样的（都是二进制格式），为什么还要再链接一次呢？<br>因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。<br>链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件(.o)和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。<br>此外需要注意的是：C++程序编译的时候其实只识别.cpp文件，每个cpp文件都会分别编译一次，生成一个.o文件。这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个.o或者.obj文件组合起来，生成最终的可执行文件(Executable file)。<br>以本文中的代码为例，将func.o和main.o链接成可执行文件main.out，指令如下:</p><pre><code>g++ src/func.o main.o -o main.out</code></pre><p>-o main.out用于指定生成的可执行二进制文件名<br>由于g++自动链接了系统组件，所以我们只需要把自定义函数的目标文件与main.o链接即可。<br>运行main.out，结果如下：</p><pre><code>./main.outa + b = 3</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编码规范</title>
      <link href="/p/64590.html"/>
      <url>/p/64590.html</url>
      
        <content type="html"><![CDATA[<h1 id="c-编码规则"><a href="#c-编码规则" class="headerlink" title="c++编码规则"></a>c++编码规则</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>文件名全部使用小写字母<br>示例：</p><pre><code>kctlinechartview.h</code></pre><h4 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h4><p>类的命名使用前缀+驼峰命名法。当一个类需要暴露给其它工程使用时，应加上工程约定的前缀，前缀全部使用大写字母。类命名尽量使用完整英文单词，除非是常见的缩写。<br>示例：</p><pre><code>KCTLineChartView</code></pre><p>Com 接口命名在普通前缀前加 I 作为标志。</p><p>示例：IKCTChartView</p><h4 id="其他类型命名"><a href="#其他类型命名" class="headerlink" title="其他类型命名"></a>其他类型命名</h4><p>struct、typedef 与 enum 的命名原则与类相同。enum 成员采用大写字母开头的驼峰写法，且应在命名中体现 enum 名称，具体位置不做强制要求，但同一个 enum 内的命名规则要保持一致。<br>示例：</p><pre><code>enum ActionType&#123;    InsertActionType, DeleteActionType, MoveActionType&#125;;</code></pre><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>变量命名使用小写字母开头的驼峰写法，不加类型信息前缀，命名应使用能表达变量涵义的完整英文单 词。<br>示例:</p><pre><code>int index = 0；KCTLineChartView  *lineChartView = NULL;</code></pre><p>仅允许在 for 单层循环中的 i 和表示坐标的 x、y、z 上使用单字母变量，其他情况下不允许使用。</p><p>非 static 的类成员变量前加上小写字母 m_前缀，static 的类成员变量前加上小写字母 s_前缀，这两种情况下变量名的第一个单词首字母小写，后面单词首字母大写。<br>示例：</p><pre><code>class GoodClass&#123;private:    int m_dataMember;    static int s_staticDataMember;&#125;;</code></pre><h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><p>除构造函数和析构函数外，类成员函数使用小写字母开头的驼峰写法。非类成员函数使用大写字母开头 的驼峰写法。<br>示例：</p><pre><code>lineChartView-&gt;lineCount();GetObjectCountInDocument();</code></pre><p>名词属性的类成员函数命名分两种情况：若欲获取的信息当成返回值返回，则命名方式为 名词 或 名词+修饰语 的样式。若欲获取的信息通过某个参数返回，则命名方式为 get+名词（+修饰语）的样式。<br>示例：</p><pre><code>lineChartView-&gt;title();lineChartView-&gt;subViewAtIndex(index);lineChartView-&gt;getSubViews(&amp;outPointer);</code></pre><p>动词属性的类成员函数命名方式为 动词+宾语，若宾语是 this, 应省略。<br>示例：  </p><pre><code>lineChartView-&gt;removeAllSubViews(); lineChartView-&gt;setTitle(L”Hello World”); lineChartView-&gt;initialize();</code></pre><p>形容词属性的类成员函数命名方式为 is&#x2F;has 等修饰语+形容词&#x2F;名词。<br>示例：</p><pre><code>lineChartView-&gt;isVisible(); lineChartView-&gt;hasTitle();</code></pre><p>返回对象指针的函数若内部分配了内存，应使用 copy, create 等关键字把该信息反映在函数名上。</p><p>示例：</p><pre><code>lineChartView-&gt;subViews(); //未重新分配内存 lineChartView-&gt;copySubViews();//重新分配了内存</code></pre><h4 id="函数命名-1"><a href="#函数命名-1" class="headerlink" title="函数命名"></a>函数命名</h4><p>宏命名</p><p>原则上宏的命名全部大写，如有必要单词间用下划线分隔。如无必要，不把一段代码定义成宏。</p><p>示例：</p><pre><code>#define SOMETHING_USED</code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>关于使用全局变量的注意事项见后文。全局变量前加小写字母 g_ 前缀，static 全局变量前加小写字母 gs_前缀。<br>示例：</p><pre><code>bool g_inFileOpening = false;static bool gs_staticInFileOpening = true;</code></pre><h4 id="名称空间命名"><a href="#名称空间命名" class="headerlink" title="名称空间命名"></a>名称空间命名</h4><p>名称空间使用剪短的全小写英文单词命名。<br>示例：</p><pre><code>namespace chart&#123;    ....&#125;</code></pre><h4 id="不允许使用-My-或自己的姓名作为以上命名的前缀"><a href="#不允许使用-My-或自己的姓名作为以上命名的前缀" class="headerlink" title="不允许使用 My 或自己的姓名作为以上命名的前缀"></a>不允许使用 My 或自己的姓名作为以上命名的前缀</h4><p>例如：</p><p>&#x2F;&#x2F;禁止下列写法。</p><pre><code>Class MyStringProject&#123; public:    ...&#125;</code></pre><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h4 id="头文件包含保护"><a href="#头文件包含保护" class="headerlink" title="头文件包含保护"></a>头文件包含保护</h4><p>在所有头文件中均使用#ifndef + #define + #endif 来避免该文件被重复包含，宏的命名方式为</p><pre><code>PROJECTNAME_FILENAME_H</code></pre><p>示例：</p><p>MyProject 项目有头文件名为 MyHeader.h，则文件头部加上 </p><pre><code>#ifndef      MYPROJECT_MYHEADER_H #define      MYPROJECT_MYHEADER_H </code></pre><p>文件末尾加上</p><pre><code>#endif  //     MYPROJECT_MYHEADER_H </code></pre><h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>当使用一两个前置声明就能编译通过时，不要在头文件里包含另一个头文件。</p><h4 id="头文件包含顺序"><a href="#头文件包含顺序" class="headerlink" title="头文件包含顺序"></a>头文件包含顺序</h4><p>在代码文件里包含多个头文件时，应按照如下顺序将头文件分组，每组之间使用空行隔开：</p><ol><li><p>   预编译头文件，通常是 stdafx.h</p></li><li><p>   与代码文件同名的头文件</p></li><li><p>   系统头文件</p></li><li><p>   WPS 内部其他工程头文件</p></li><li><p>   本工程其他头文件</p></li></ol><p>示例：</p><p>MyProject 工程中的 MyClass.cpp 实现了声明在 MyClass.h 内的类，此外还用到了 C++ 标准库中的 Vector 容器、ExternalProject 工程中的 ExternalClass.h 和 ExternalUtils.h、MyProject 工程中的 MyFriendClass.h、MyFileIOHelper.h 与 MyStringUtils.h，<br>其包含顺序如下: </p><pre><code>#include &quot;stdafx.h&quot;#include &quot;MyClass.h&quot;#include &lt;vector&gt;#include &quot;ExternalClass.h&quot; #include &quot;ExternalUtils.h&quot;#include &quot;MyFirendClass.h&quot; #include &quot;MyFileIOHelper.h&quot; #include &quot;MyStringUtils.h&quot;</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的所有成员变量必须初始化，只有成员变量没有函数的类，必须定义默认构造函数。</p><p>除非有特殊需求，在类的构造函数中仅进行不涉及具体功能的初始化操作，例如为成员变量赋零。较复杂的初始化操作，应放在一个单独的 init()方法中，由类实例的创建者负责调用。<br>解释：构造函数内难以报告错误，且构造函数中对虚函数的调用不会派发给子类，所以较复杂的初始化操作应在构造完成之后进行。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>若没有明确的将单参构造函数用于隐式类型转换的需求，应使用 explicit 关键字。</p><h4 id="拷贝构造函数、赋值运算符"><a href="#拷贝构造函数、赋值运算符" class="headerlink" title="拷贝构造函数、赋值运算符"></a>拷贝构造函数、赋值运算符</h4><p>若没有明确的对类进行拷贝的需求，应在 private 段中声明拷贝构造函数和赋值运算符。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>只使用 public 继承。</p><p>在语义明确的时候从父类继承具体实现，其他时候从抽象接口继承。若类有虚函数，则析构函数也定义为虚函数。<br>父类中声明为 virtual 的函数，子类声明中要明确标明为 virtual 以及 override。</p><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>尽量避免运算符重载，除非是为了在容器类中使用而必须实现的。</p><h4 id="访问权限声明"><a href="#访问权限声明" class="headerlink" title="访问权限声明"></a>访问权限声明</h4><p>类声明中按 public, protected, private 的顺序声明函数和变量，每个关键字仅占用一段，每一段中的声明顺序为： typedef, enum, Q_OBJECT 及类似声明，嵌套类，常量，构造函数，虚构函数，成员函数，数据成员。</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的定义和友类的定义应放在同一个文件中。</p><h2 id="函数与实现"><a href="#函数与实现" class="headerlink" title="函数与实现"></a>函数与实现</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数排列顺序为输入参数在前，输出参数在后。引用作为输入参数时应配合 const 使用。不使用缺省参数。<br>不允许一个参数即作为传入参数，又作为传出参数。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数不超过 10 行，推荐仅对 1 行的函数进行 inline。不使用循环或 switch…case，不进行递归。在类定义体内实现的函数，不要加 inline 关键字。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>避免使用异常（try…catch）。使用 ATL 和 STL 时，关闭异常或限制异常作用域。</p><h4 id="类型编程"><a href="#类型编程" class="headerlink" title="类型编程"></a>类型编程</h4><p>不使用运行时类型信息。明确使用 static_cast，const_cast 进行类型转换，避免使用 dynamic_cast,小心使用 reinterpret_cast。</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>尽量使用 const、enum、inline 替代 #define。</p><h4 id="类数据成员的引用"><a href="#类数据成员的引用" class="headerlink" title="类数据成员的引用"></a>类数据成员的引用</h4><p>避免成员函数返回指向类成员的指针或引用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>文件头注释应包括 文件名，创建者，创建时间，功能描述 和版权信息。</p><p>示例：</p><pre><code>    // KCTCodingGuideline.h    // 创建者： Tom Cat    // 创建时间： 2013/5/24    // 功能描述： The coding guideline for Chart project in WPS        // Copyright 2013 Kingsoft</code></pre><h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><p>注释使用 &#x2F;&#x2F; 风格，应简洁清晰，不写没必要的注释。代码中不是很简单直观的地方需要增加注释，</p><p>例如：</p><ul><li><p>   故意违背编码规范之处。</p></li><li><p>   分成多步完成的任务。</p></li><li><p>   较复杂的逻辑。</p></li><li><p>   和常理不符的代码。</p></li><li><p>   比较重要，需要引起注意的地方。</p></li></ul><h4 id="注释语言"><a href="#注释语言" class="headerlink" title="注释语言"></a>注释语言</h4><p>默认注释语言为中文。</p><h4 id="注释中的工程师姓名"><a href="#注释中的工程师姓名" class="headerlink" title="注释中的工程师姓名"></a>注释中的工程师姓名</h4><p>在且仅在两种情形下把姓名加入注释中：</p><ol><li><p>   文件头中的创建者信息。</p></li><li><p>   做 TODO 注释时。</p></li></ol><p>示例： </p><pre><code> //TODO(Tommy Zhang): 删掉这里的全局变量!</code></pre><h4 id="预处理宏注释"><a href="#预处理宏注释" class="headerlink" title="预处理宏注释"></a>预处理宏注释</h4><p>中间代码段较长的#else 与 #endif 之后用注释标明宏的名字。</p><p>示例：</p><pre><code>    #if TARGET_PLATFORM_WINDOWS    ................        #else //TARGET_PLATFORM_WINDOWS    ................    #endif //TARGET_PLATFORM_WINDOWS</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h4 id="对齐与缩进"><a href="#对齐与缩进" class="headerlink" title="对齐与缩进"></a>对齐与缩进</h4><p>使用 Tab 进行对齐。</p><p>花括号上下对齐，不允许将左花括号放在 if 等语句的末尾：<br>例如：</p><pre><code>    void MyFunction(InputType type)    &#123;        static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;         static const ScopeType scopeType[] =        &#123;            wpsFindScope_MainText, wpsFindScope_Selection, wpsFindScope_HeaderFooters, wpsFindScope_Footnotes, wpsFindScope_Endnotes,            ...            wpsFindScope_Comments        &#125;;                switch (type)        &#123;        case TypeA:            break;        case TypeB:            break;         default:            break;        &#125;        if (...)        &#123;        &#125;        else        &#123;        &#125;        do        &#123;        &#125;        while (...);                for (int i = 0; i &lt; 10; ++ i)        &#123;        &#125;    &#125;</code></pre><p>构造函数初始化列表和多个基类的中每一行逗号放前面，和冒号对齐。</p><p>示例：</p><pre><code>KGroupGrid::KGroupGrid(QWidget *parent)    : QWidget(parent)    , m_scrollBar(Qt::Vertical, this)    , m_headerHeight()    , m_itemSize(80, 64)    , m_showTooltip(false)    , m_flatFrame(true)    , m_showSeperatorLine(true)    , m_scrollBarPolicy(Qt::ScrollBarAsNeeded) #if X_OS_WINDOWS    , m_firstRow(0) #endif&#123;&#125;class KxWppViewPages    : public QStackedWidget        , public KFakeUnknown&lt;IShellPagesGetter&gt;    , public KFakeUnknown&lt;IROShellPages&gt;    , public KxWppViewPagesCoreNotify&#123;&#125;;</code></pre><p>只有一行代码的 if 语句不加花括号。</p><p>示例：</p><pre><code>if (inputType == badType)     DoSomethingBad();if (inputType == badType)     DoSomethingBad();else    DoSomethingElse();</code></pre><p>当 if 语句中某一个分支有一行的以上代码时，if 的所有子句都要加括号。</p><p>示例：</p><pre><code>if (inputType == badType)&#123;    DoSomethingBad();&#125;else&#123;    DoSomethingElse1();     DoSomethingElse2();&#125;</code></pre><p>推荐一行代码不超过 120 个字符。函数参数列表过长时，应换行：返回值类型、左括号应保持与函数名同一行，具体换行的方案有两种：<br>示例：</p><pre><code>HRESULT MyClass::method(ParameterOne param1,                        ParameterTwo param2,                         ParameterThree param3)HRESULT MyClass::method(ParameterOne param1,     ParameterTwo param2, ParameterThree param3)</code></pre><p>函数类型为 const 时，const 关键字与最后一个参数同行<br>示例：</p><pre><code>HRESULT MyClass::constMethod(ParameterOne param1,                            ParameterTwo param2,                            ParameterThree param3) const</code></pre><p>所有预编译宏顶格对齐。</p><p>示例：</p><pre><code>void MyClass::methodWithMacros()&#123;    static int integer1 = 0;    integer1 ++;     if(integer1 &gt;= 10)    &#123;#if PLATFORM_1        integer1 = 1;#else        integer1 = 2;#endif    &#125;&#125;</code></pre><p>分为多行的布尔表达式中 &amp;&amp; 与 || 置于行首。换行应在运算符优先级最低的地方进行，尽可能避免把配对的括号分成两行。<br>当条件比较复杂时，应将高优先级的运算用括号明确标识出来。</p><p>示例：</p><pre><code>if ((valueGood &gt;= somethingGood || otherContion)     &amp;&amp; (valueBad + 1) &lt;= somethingRealyBad)</code></pre><p>命名空间（namespace)内容不缩进</p><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>函数调用的括号前后之间不加空格，参数之间逗号之后加一个空格。</p><p>示例：</p><pre><code>void MyFunction(ParameterOne param1, ParameterTwo param2)</code></pre><p>if、while、for 等关键字与括号之间加一个空格，括号后不加空格。<br>示例：</p><pre><code>if (NULL == thePointer)for (int index = 0; index &lt; maxIntValue; index++)</code></pre><p>使用 Tab 键无法刚好对齐时，使用空格补齐。</p><p>没有参数的函数括号内不加空格。</p><p>二元运算符前后各加一个空格；</p><p>自增减运算符与分号间不加空格，与变量之间也不加空格。</p><p>示例：</p><pre><code>if (inputType1 == goodType &amp;&amp; inputType2 == badType) for (int index == 0; index &lt; MAX_INT; index++)</code></pre><p>引用符号（. -&gt;）前后不加空格。</p><p>示例：</p><pre><code>theSmartPointer-&gt;value();</code></pre><p>地址、引用运算符（*, &amp;）后不加空格；</p><p>示例：</p><pre><code>*integerPointer = 1;</code></pre><p>声明指针类型的*号前加一空格，后边不加空格</p><p>示例：</p><pre><code>MyClass *goodClass;</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>不需要暴露嵌套类作为接口的时候，将嵌套类声明为 private。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量应在将要使用时进行声明，声明的同时初始化。</p><p>示例：</p><pre><code>void SomeMagicalFunction()&#123;    const int magicNumber = 1;    int integer1 = magicNumber;    integer1 ++;    if (integer1 &lt;= 0)         DoSomethingWeird();    float floatingNumer1 = 1.0;    float *floatingPointer = &amp;floatNumber1;    if (floatingPointer == NULL)        HowCouldThisHappen();&#125;</code></pre><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>除非特殊情况，不使用 Class 类型的全局变量，不使用 Class 类型的 static 类数据成员。可以用单例模式替代 Class 类型的全局变量。</p><p>全局的字符串变量使用 C 风格的 char，不使用各种字符串类。</p><h4 id="名称空间（namespace）"><a href="#名称空间（namespace）" class="headerlink" title="名称空间（namespace）"></a>名称空间（namespace）</h4><p>允许在 cpp 文件中使用匿名名称空间进行保护，不允许在头文件中使用匿名名称空间。避免使用 using namespace 将一个名称空间中的所有名称全部导入。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>使用 typename 关键字声明模板，不使用 class 关键字。</p><h4 id="模板适用范围"><a href="#模板适用范围" class="headerlink" title="模板适用范围"></a>模板适用范围</h4><p>一般情况下仅使用模板来实现容器类或通用算法，如果需要用作其他用途，请增加注释说明必要性。</p><h4 id="模板中的嵌套类"><a href="#模板中的嵌套类" class="headerlink" title="模板中的嵌套类"></a>模板中的嵌套类</h4><p>模板中使用嵌套类时，加上 typename 关键字声明。</p><p>示例：</p><pre><code>template&lt;typename T&gt;void someFunction(const T&amp; container)&#123;    typename T::Iterator iter(container.begin());    iter.next();&#125;</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>在模板派生类中调用模板基类函数时，明确在函数调用前声明该函数属于基类。</p><p>示例：</p><pre><code>template&lt;typename T&gt;class DerivedClass::public BaseClass&lt;T&gt;&#123;public:    void doAction()    &#123;        BaseClass&lt;T&gt;::doBaseAction();    &#125;&#125;</code></pre><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="优先使用静态内存"><a href="#优先使用静态内存" class="headerlink" title="优先使用静态内存"></a>优先使用静态内存</h4><p>编译期能够确定的常量数组，应声明为 static。</p><p>示例：</p><pre><code>void func(int type)&#123;    static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;    ......&#125;</code></pre><h4 id="其次为栈内存"><a href="#其次为栈内存" class="headerlink" title="其次为栈内存"></a>其次为栈内存</h4><p>编译期能够确定长度的非常量数组，应使用栈内存。</p><p>示例：</p><pre><code>void func(int type)&#123;    const int length = 1024;    unsigned char buffer[length + 1];     DWORD dwReadSize = length;    while (::ReadFile(hFile, buffer, length, &amp;dwReadSize, NULL))    &#123;        ......        dwReadSize = length;    &#125;&#125;</code></pre><h4 id="使用智能指针和容器管理堆内存"><a href="#使用智能指针和容器管理堆内存" class="headerlink" title="使用智能指针和容器管理堆内存"></a>使用智能指针和容器管理堆内存</h4><p>单个堆对象的生命周期用 std::unique_ptr 来管理。</p><p>连续的内存空间用 std::vector 或 QVector 来分配和管理。</p><p>示例：</p><pre><code>void func(int type)&#123;    std::unque_ptr&lt;CSomeObject&gt; spObject = new CSomeObject();    int bufferLength = getBufferLength(); std::vector&lt;SomeType&gt; vecBuffer(bufferLength);     readBuffer(&amp;vecBuffer[0], bufferLength);&#125;</code></pre><p>字符串用 std::basic_string<T>或 QString 来管理。</T></p><p>示例：</p><pre><code>void func(int type)&#123;    int stringLength = getStringLength();    std::string str; str.resize(stringLength);    readStringInCStyleFunction(&amp;str[0], stringLength);&#125;</code></pre><p>不允许在代码中出现 new[] 和 delete[]的显示调用。</p><p>delete 不应该出现在析构函数或用于清理内存的函数之外的地方出现。</p><p>不允许使用 malloc&#x2F;free 来分配和释放内存。</p><p>十. 跨平台<br>####Windows 内建类型</p><p>调用 Windows API 时，使用 DWORD、LPCTSTR 等 Windows 类型，其它情况下避免使用，但可以使用 HRESULT。</p><h4 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h4><p>避免使用 Windows 系统 API，只能在限定模块内使用，比如一个封装操作系统 API 的中间层。</p><h4 id="C-扩展库"><a href="#C-扩展库" class="headerlink" title="C++扩展库"></a>C++扩展库</h4><p>不允许使用 Boost 库，除非是已经进入 C++11 标准的部分。</p><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h4><p>可以使用 C++11 新语法中 Visual C++支持的部分，但须遵守如下原则：</p><ol><li><p>   不使用 lambda 表达式。</p></li><li><p>   仅使用 auto 来简化模板变量的声明，不将基本类型或者表达式返回值赋给 auto 对象。</p></li><li><p>   不使用尾部返回类型声明，例如 auto Function() -&gt; int；</p></li><li><p>   不使用 Raw String。</p></li><li><p>   禁用模版元编程。</p></li><li><p>   不允许使用逗号表达式。</p></li></ol><p>不能使用 Visual C++专有语法，例如：</p><ol><li><p>   finally、     super、     forceinline 等关键字。</p></li><li><p>   省略类静态成员的外部定义。</p></li><li><p>   将函数指针 cast 成整型指针。</p></li><li><p>   重复包含有 extern 全局变量定义(非声明)的头文件。</p></li><li><p>   goto 关键字跨越变量定义。</p></li><li><p>   如果有可能，在 Visual Studio 中设置&#x2F;Za 标志关闭 Microsoft Extension to C++。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/p/2.html"/>
      <url>/p/2.html</url>
      
        <content type="html"><![CDATA[<p>stoi()，atoi() ，to_string 这三个函数都是对字符串处理的函数，前两者是将字符串转化为十进制 int 类型，最后一个是将十进制类型 int、double 等转化为string，头文件都是：#include<cstring><br>stoi 的参数是 const string* 类型<br>atoi 的参数是 const char* 类型</cstring></p><p>stoi() 会对转化后的数进行检查，判断是否会超出 int 范围，如果超出范围就会报错；<br>atoi() 不会对转化后的数进行检查，超出上界，输出上界，超出下界，输出下界；</p><p>反转数字自动去除前导零</p><pre><code>int countDistinctIntegers(vector&lt;int&gt;&amp; nums) &#123;    map&lt;int,int&gt; m;    for(int x:nums)&#123;      m[x]++;      string s=to_string(x);      reverse(s.begin(),s.end());      m[stoi(s)]++;    &#125;    return m.size();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SFINAE</title>
      <link href="/p/9fa70a35.html"/>
      <url>/p/9fa70a35.html</url>
      
        <content type="html"><![CDATA[<h1 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h1><p>模板里的一个特殊概念——替换失败非错（substituion failure is not an error），英文简称为SFINAE。</p><h2 id="函数模板的重载决议"><a href="#函数模板的重载决议" class="headerlink" title="函数模板的重载决议"></a>函数模板的重载决议</h2><p>当一个函数名称和某个函数模板名称匹配时，重载决议过程大致如下：</p><ul><li>根据名称找出所有适用的函数和函数模板</li><li>对于适用的函数模板，要根据实际情况对模板形参进行替换；替换过程中如果发生错误，这个模板会被丢弃</li><li>在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用</li><li>如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，则编译器需要报错</li></ul><p>我们还是来看一个具体的例子</p><pre><code>#include &lt;stdio.h&gt;struct Test &#123;    typedef int foo;&#125;;template &lt;typename T&gt;void f(typename T::foo)&#123;    puts(&quot;1&quot;);&#125;template &lt;typename T&gt;void f(T)&#123;    puts(&quot;2&quot;);&#125;int main()&#123;    f&lt;Test&gt;(10);    f&lt;int&gt;(10);&#125;</code></pre><p>输出为：</p><pre><code>12</code></pre><p>首先看 f<Test>(10); 的情况：有两个模板符合名字 f,替换结果为 f(Test::foo) 和 f(Test)使用参数 10 去匹配，只有前者参数可以匹配，因而第一个模板被选择<br>再看一下 f<int>(10) 的情况：还是两个模板符合名字 f替换结果为 f(int::foo) 和 f(int)；显然前者不是个合法的类型，被抛弃使用参数 10 去匹配 f(int)，没有问题，那就使用这个模板实例了</int></Test></p><p>在这儿，体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。<br>这儿的失败仅指函数模板的原型声明，即参数和返回值。函数体内的失败不考虑在内。如果重载决议选择了某个函数模板，而函数体在实例化的过程中出错，那我们仍然会得到一个编译错误</p><h2 id="编译期成员检测"><a href="#编译期成员检测" class="headerlink" title="编译期成员检测"></a>编译期成员检测</h2><p>SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。下面这个模板，就可以检测一个类是否有一个名叫 reserve、参数类型为 size_t 的成员函数：</p><pre><code>template &lt;typename T&gt;struct has_reserve &#123;    struct good &#123; char dummy; &#125;;    struct bad &#123; char dummy[2]; &#125;;    template &lt;class U, void (U::*)(size_t)&gt;struct SFINAE &#123;&#125;;    template &lt;class U&gt;static good reserve(SFINAE&lt;U, &amp;U::reserve&gt;*);    template &lt;class U&gt;static bad reserve(...);    static const bool value = sizeof(reserve&lt;T&gt;(nullptr)) == sizeof(good);&#125;;</code></pre><p>首先定义了两个结构 good 和 bad；它们的内容不重要，我们只关心它们的大小必须不一样。<br>定义了一个 SFINAE 模板，内容也同样不重要，但模板的第二个参数需要是第一个参数的成员函数指针，并且参数类型是 size_t，返回值是 void。<br>定义了一个要求 SFINAE* 类型的 reserve 成员函数模板，返回值是good；<br>再定义了一个对参数类型无要求的 reserve 成员函数模板，返回值是 bad。<br>最后，我们定义常整型布尔值 value，结果是 true 还是 false，取决于 nullptr 能不能和 SFINAE* 匹配成功，而这又取决于模板参数 T 有没有返回类型是 void、接受一个参数并且类型为 size_t 的成员函数 reserve。</p><p>那这样的模板有什么用处呢？我们继续往下看。</p><h2 id="SFINAE-模板技巧"><a href="#SFINAE-模板技巧" class="headerlink" title="SFINAE 模板技巧"></a>SFINAE 模板技巧</h2><h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><p>C++11 开始，标准库里有了一个叫 enable_if 的模板（定义在 <type_traits> 里），可以用它来选择性地启用某个函数的重载。</type_traits></p><p>假设我们有一个函数，用来往一个容器尾部追加元素。我们希望原型是这个样子的：</p><pre><code>template &lt;typename C, typename T&gt;void append(C&amp; container, T* ptr,size_t size);</code></pre><p>显然，container 有没有 reserve 成员函数，是对性能有影响的——如果有的话，我们通常应该预留好内存空间，以免产生不必要的对象移动甚至拷贝操作。利用 enable_if 和上面的 has_reserve 模板，我们就可以这么写：</p><pre><code>template &lt;typename C, typename T&gt;enable_if_t&lt;has_reserve&lt;C&gt;::value, void&gt;append(C&amp; container, T* ptr, size_t size)&#123;    container.reserve(container.size() + size);    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;template &lt;typename C, typename T&gt;enable_if_t&lt;!has_reserve&lt;C&gt;::value, void&gt;append(C&amp; container, T* ptr, size_t size)&#123;    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;</code></pre><p>对于某个 type trait，添加 _t 的后缀等价于其 type 成员类型。</p><p>第一个函数模板（前半部分）：它有两个模板参数，C 和 T，分别表示容器类型和元素类型。使用 enable_if_t&lt;has_reserve<C>::value, void&gt; 来实现模板参数的限定，只有当容器类型 C 拥有 reserve 成员函数时才会被实例化。has_reserve<C>::value 是一个用于检查容器类型是否有 reserve 成员函数的类型特性（traits）。如果有 reserve 成员函数，has_reserve<C>::value 为 true，否则为 false。在函数中，首先通过 reserve 函数预留足够的容量以容纳待添加的元素，然后使用循环将指针 ptr 指向的元素逐个添加到容器中。</C></C></C></p><p>第二个函数模板：与第一个函数模板类似，它也有两个模板参数 C 和 T。使用 enable_if_t&lt;!has_reserve<C>::value, void&gt; 来实现模板参数的限定，只有当容器类型 C 没有 eserve 成员函数时才会被实例化。在函数中，直接通过循环将指针 ptr 指向的元素逐个添加到容器中，因为没有 reserve 函数，所以容器会自动调整大小以容纳新的元素。</C></p><h3 id="decltype-返回值"><a href="#decltype-返回值" class="headerlink" title="decltype 返回值"></a>decltype 返回值</h3><p>如果只需要在某个操作有效的情况下启用某个函数，而不需要考虑相反的情况的话，有另外一个技巧可以用。对于上面的 append 的情况，如果我们想限制只有具有 reserve 成员函数的类可以使用这个重载，我们可以把代码简化成</p><pre><code>template &lt;typename C, typename T&gt;auto append(C&amp; container, T* ptr, size_t size)-&gt; decltype(declval&lt;C&amp;&gt;().reserve(1U), void())&#123;    container.reserve(container.size() + size);    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;</code></pre><p>使用 decltype 关键字来定义返回类型。declval&lt;C&amp;&gt;().reserve(1U) 用来测试 C&amp; 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数。此外，我们需要记得，C++ 里的逗号表达式的意思是按顺序逐个估值，并返回最后一项。所以，上面这个函数的返回值类型是 void。</p><p>在函数中，首先通过 reserve 函数预留足够的容量以容纳待添加的元素，然后使用循环将指针 ptr 指向的元素逐个添加到容器中。<br>这样，当调用 append 函数时，编译器会根据容器 C 是否有 reserve 成员函数来选择合适的返回类型，确保只有在容器支持 reserve 成员函数时，才会调用该函数。这是一种在编译时根据类型特性选择函数实现的技术，避免了在运行时出现不支持的操作。</p><h3 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h3><p>void_t 是 C++17 新引入的一个模板。它的定义十分的简单</p><pre><code>template &lt;typename...&gt;using void_t = void;</code></pre><p>这个类型模板会把任意类型映射到 void。它的特殊性在于，在这个看似无聊的过程中，编译器会检查那个“任意类型”的有效性。利用 decltype、declval 和模板特化，我们可以把 has_reserve 的定义大大简化：</p><pre><code>template &lt;typename T, typename = void_t&lt;&gt; &gt;struct has_reserve : false_type &#123;&#125;;template &lt;typename T&gt;struct has_reserve&lt;T, void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt; : true_type &#123;&#125;;</code></pre><p>这里第二个 has_reserve 模板的定义实际上是一个偏特化。偏特化是类模板的特有功能，跟函数重载有些相似。编译器会找出所有的可用模板，然后选择其中最“特别”的一个。像上面的例子，所有类型都能满足第一个模板，但不是所有的类型都能满足第二个模板，所以第二个更特别。当第二个模板能被满足时，编译器就会选择第二个特化的模板；而只有第二个模板不能被满足时，才会回到第一个模板的通用情况。有了这个 has_reserve 模板，我们就可以继续使用其他的技巧，如 enable_if 和下面的标签分发，来对重载进行限制</p><h3 id="标签分发"><a href="#标签分发" class="headerlink" title="标签分发"></a>标签分发</h3><p>上面我们提到了用 true_type 和 false_type 来选择合适的重载。这种技巧有个专门的名字，叫标签分发（tag dispatch）。我们的 append 也可以用标签分发来实现：</p><pre><code>template &lt;typename C, typename T&gt;void _append(C&amp; container, T* ptr, size_t size, true_type)&#123;    container.reserve(container.size() + size);    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;template &lt;typename C, typename T&gt;void _append(C&amp; container, T* ptr, size_t size, false_type)&#123;    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;template &lt;typename C, typename T&gt;void append(C&amp; container, T* ptr, size_t size)&#123;    _append(container, ptr, size, integral_constant&lt;bool, has_reserve&lt;C&gt;::value&gt;&#123;&#125;);&#125;</code></pre><p>如果我们用 void_t 那个版本的 has_reserve 模板的话，由于模板的实例会继承false_type 或 true_type 之一，代码可以进一步简化为：</p><pre><code>template &lt;typename C, typename T&gt;void append(C&amp; container, T* ptr, size_t size)&#123;    _append(container, ptr, size, has_reserve&lt;C&gt;&#123;&#125;);&#125;</code></pre><h2 id="静态多态的限制"><a href="#静态多态的限制" class="headerlink" title="静态多态的限制"></a>静态多态的限制</h2><p>为什么我们不能按照下面的代码运行呢？</p><pre><code>template &lt;typename C, typename T&gt;void append(C&amp; container, T* ptr, size_t size)&#123;    if (has_reserve&lt;C&gt;::value) &#123;        container.reserve(container.size() + size);    &#125;    for (size_t i = 0; i &lt; size; ++i) &#123;        container.push_back(ptr[i]);    &#125;&#125;</code></pre><p>试验一下，就会发现，在 C 类型没有 reserve 成员函数的情况下，编译是不能通过的，会报错。这是因为 C++ 是静态类型的语言，所有的函数、名字必须在编译时被成功解析、确定。在动态类型的语言里，只要语法没问题，缺成员函数要执行到那一行上才会被发现。这赋予了动态类型语言相当大的灵活性；只不过，不能在编译时检查错误，同样也是很多人对动态类型语言的抱怨所在……</p><p>在 C++17 里，我们只要在 if 后面加上 constexpr，代码就能工作了</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda的使用</title>
      <link href="/p/57725.html"/>
      <url>/p/57725.html</url>
      
        <content type="html"><![CDATA[<h1 id="lambda的使用"><a href="#lambda的使用" class="headerlink" title="lambda的使用"></a>lambda的使用</h1><p>c++ 引入了lambda，可以用来创建闭包并且在代码中传递</p><p>例如：</p><pre><code>int main()&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    std::for_each(myArray.begin(),myArray.end(),[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;);    return 0;&#125;</code></pre><p>lambda还可以通过变量来引用:</p><pre><code>int main()&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    auto func=[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;;    std::for_each(myArray.begin(),myArray.end(),func);    return 0;&#125;</code></pre><p>func存储了闭包类型，c++提供了一种方法来传递不同类型的对象，这些对象可以像函数一样调用</p><pre><code>void print(const std::function&lt;void(std::array&lt;uint32_t,5&gt;::value_type)&gt;&amp;func)&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    std::for_each(myArray.begin(),myArray.end(),func);&#125;int main()&#123;    auto func=[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;;    print(func);    return 0;&#125;</code></pre><p>同时，lambda表达式还可以通过引用捕获来共享变量来进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与时间有关的程序</title>
      <link href="/p/6239.html"/>
      <url>/p/6239.html</url>
      
        <content type="html"><![CDATA[<h1 id="与时间有关的程序"><a href="#与时间有关的程序" class="headerlink" title="与时间有关的程序"></a>与时间有关的程序</h1><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><pre><code>#include&lt;ctime&gt;#include&lt;chrono&gt;#include&lt;iostream&gt;using namespace chrono;int main()&#123;    auto currentTimePoint=system_clock::now();    auto currentTime = system_clock::to_time_t(currentTimePoint);    auto timeText=ctime(&amp;currentTime);    std::cout&lt;&lt;timeTixt&lt;&lt;std::endl;    return 0;&#125;</code></pre><p>system_clock::now()返回的对象是一个time_point类型，他表示从某一个时间点（epoch）开始的偏移，epoch是一个参考时间，系统用它来偏移其他时间。但是如果系统使用不同的epoch来计算时间，那么一台计算机上的时间可能不能够一直到另一条计算机上。<br>time_point结构不能直接输出，也无法转换成字符串，但是该类型能够转换成time_t，time_t可以通过ctime函数转换成字符串类型。</p><h2 id="比较时间"><a href="#比较时间" class="headerlink" title="比较时间"></a>比较时间</h2><pre><code>#include&lt;ctime&gt;#include&lt;chrono&gt;#include&lt;iostream&gt;#include&lt;thread&gt;using namespace literals;using namespace chrono;int main()&#123;    auto startTimePoint=system_clock::now();    this_thread::sleep(5s);    auto endTimePoint=system_clock::now();    auto timeTaken = duration_cast&lt;milliseconds&gt;(endTimeoint-startTimePoint);    std::cout&lt;&lt;&quot;time taken: &quot;timeTaken.count()&lt;&lt;std::endl;    return 0;&#125;</code></pre><p>duration_cast将减法的结果转换成一个具有特定时间类型的具体时间。<br>此外，sleep函数内采用了字面量，h，min，s，ms，us，ns这些字面量只能在c++14使用，c++11和c++98不支持。</p><h2 id="三种使用时钟类型"><a href="#三种使用时钟类型" class="headerlink" title="三种使用时钟类型"></a>三种使用时钟类型</h2><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;ctime&gt;//local_time#include&lt;chrono&gt;//time_futures#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;iomanip&gt;//put_timeusing namespace std;int main()&#123;    chrono::system_clock::time_point pc_clock = chrono::system_clock::now();    time_t pc_clock_time = chrono::system_clock::to_time_t(pc_clock);    cout &lt;&lt; &quot;The time according to the computer clock is:&quot; &lt;&lt; put_time(localtime(&amp;pc_clock_time), &quot;%T %p&quot;) &lt;&lt; endl;    chrono::steady_clock::time_point start = chrono::steady_clock::now();    //when we start    chrono::high_resolution_clock::time_point start2 = chrono::high_resolution_clock::now();//high res clock    chrono::system_clock::time_point now = chrono::system_clock::now();    //current time    time_t now_c = chrono::system_clock::to_time_t(now);    cout &lt;&lt; &quot;\n\nThe time now is: &quot; &lt;&lt; put_time(localtime(&amp;now_c), &quot;%F %T %b %I %p&quot;) &lt;&lt; endl;    time_t now_p = chrono::system_clock::to_time_t(now - chrono::hours(2));    cout &lt;&lt; &quot;The time 2 hours ago was: &quot; &lt;&lt; put_time(localtime(&amp;now_p), &quot;%F %T %B %A&quot;) &lt;&lt; &quot;\n\n&quot;;    chrono::steady_clock::time_point end = chrono::steady_clock::now();//it is over    chrono::high_resolution_clock::time_point end2 = chrono::high_resolution_clock::now();    cout &lt;&lt; &quot;computing lasted &quot; &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() &lt;&lt; &quot;ms&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;computing with high_resolution_clock yielded &quot; &lt;&lt; chrono::duration_cast&lt;chrono::nanoseconds&gt;(end2 - start2).count()        &lt;&lt; &quot;nanoseconds!&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>结果如下</p><pre><code>The time according to the computer clock is:23:19:00 PMThe time now is: 2023-03-11 23:19:00 Mar 11 PMThe time 2 hours ago was: 2023-03-11 21:19:00 March Saturdaycomputing lasted 2311mscomputing with high_resolution_clock yielded 2311700nanoseconds!</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存</title>
      <link href="/p/10970.html"/>
      <url>/p/10970.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="静态内存"><a href="#静态内存" class="headerlink" title="静态内存"></a>静态内存</h2><p>静态内存可以被看作全局变量，这些变量和他们的值可以在任何时候被任何程序的任何部分访问。</p><p>例如</p><pre><code>#include&lt;iostream&gt;using namespace std;unsigned int counter=0;void increaseCount()&#123;    counter+=10;    cout&lt;&lt;&quot;counter is&quot;&lt;&lt;counter&lt;&lt;endl;&#125;int main()&#123;    counter+=5;    cout&lt;&lt;&quot;counter is&quot;&lt;&lt;counter&lt;&lt;endl;    increaseCount();    return 0;&#125;</code></pre><p>结果：</p><pre><code>counter is 5counter is 15</code></pre><p>全局变量在某些确定的情况下有用，但是在很多情况下会导致问题。<br>静态成员变量也是全局变量的一种，他的一个普遍问题是创建顺序，c++标准不保证按照某种顺序初始化，这会导致许多相关全局变量的程序由于意外的初始化顺序而出现问题导致崩溃。全局变量在多线程也会产生问题。<br>通常建议将全局变量的使用限度降到最低，同时相同名称的局部变量会获取更高的优先权。</p><p>例如</p><pre><code>#include&lt;iostream&gt;using namespace std;unsigned int counter=0;void increaseCount()&#123;    counter+=10;    cout&lt;&lt;&quot;counter is &quot;&lt;&lt;counter&lt;&lt;endl;&#125;int main()&#123;    unsigned int counter=0;    counter+=5;    cout&lt;&lt;&quot;counter is &quot;&lt;&lt;counter&lt;&lt;endl;    increaseCount();    return 0;&#125;</code></pre><p>结果：</p><pre><code>counter is 5counter is 10</code></pre><h2 id="栈内存的使用"><a href="#栈内存的使用" class="headerlink" title="栈内存的使用"></a>栈内存的使用</h2><p>在函数工作时，需要内存来存储临时变量<br>c++通过栈来为局部变量分配空间，主要通过ebp，esp来完成。</p><h2 id="堆内存的使用"><a href="#堆内存的使用" class="headerlink" title="堆内存的使用"></a>堆内存的使用</h2><h2 id="自动共享内存的使用"><a href="#自动共享内存的使用" class="headerlink" title="自动共享内存的使用"></a>自动共享内存的使用</h2>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化变量</title>
      <link href="/p/54280.html"/>
      <url>/p/54280.html</url>
      
        <content type="html"><![CDATA[<h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>统一初始化是c++11的一个重要特性<br>例如：</p><pre><code>class MyClass&#123;&#125;int main()&#123;    MyClass a;    MyClass b(MyClass());    return 0;&#125;</code></pre><p>c++编译器不会把<code>MyClass b(MyClass());</code>看作是定义了一个类型为MyClass且名称为b的变量，它调用了一个构造函数并且接收MyClass产生的对象，实际上，编译器会认为这是一个函数声明，声明一个b的函数，返回MyClass，有一个未命名的函数指针指向返回MyClass对象的函数。</p><pre><code>class MyClass&#123;&#125;int main()&#123;    MyClass a;    MyClass b&#123; MyClass&#123;&#125; &#125;;    return 0;&#125;</code></pre><p>统一初始化几乎可以初始化所有变量，他的另一个好处就是可以防止变量缩窄</p><pre><code>char a=&#123;512&#125;;</code></pre><p>除非强制类型转换告诉编译器我要允许缩窄，否则编译器不会编译此代码。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与资源同步</title>
      <link href="/p/e1bf1f97.html"/>
      <url>/p/e1bf1f97.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程与资源同步"><a href="#多线程与资源同步" class="headerlink" title="多线程与资源同步"></a>多线程与资源同步</h1><h2 id="线程常见问题"><a href="#线程常见问题" class="headerlink" title="线程常见问题"></a>线程常见问题</h2><h3 id="主线程退出子线程会退出吗？"><a href="#主线程退出子线程会退出吗？" class="headerlink" title="主线程退出子线程会退出吗？"></a>主线程退出子线程会退出吗？</h3><p>对于WINDOWS系统，主线程退出，其他未执行完毕的子线程也会退出，因为主线程退出调用exit()，相当于终止整个进程，其他线程自然而然会终止；<br>对于linux系统，主线程退出，其他未执行完毕的子线程不会退出，会继续执行，但是这个进程会编程僵尸进程，通过ps -ef查看进程列表，如果有defunct字样的进程，就是僵尸进程。僵尸进程应该被避免。所以，我们应该在主线程退出之前等待其他子线程执行完毕，具体做法有：<br>可以在主线程return之前调用phread_exit()，会使主线程退出，子线程继续执行，当所有线程执行完毕，进程才会退出。</p><h3 id="线程崩溃是否会造成进程崩溃？"><a href="#线程崩溃是否会造成进程崩溃？" class="headerlink" title="线程崩溃是否会造成进程崩溃？"></a>线程崩溃是否会造成进程崩溃？</h3><p>会崩溃。线程没有自己单独的内存地址空间。在一个线程中把另外一个线程的栈空间写坏是再正常不过的事情了。这与进程有没有自己的栈空间无关，因为无论他们有没有自己的栈空间，都可以通过内存地址访问到其他线程的栈空间，所以指针数据的错误可以导致任何同地址空间内其他线程的崩溃，当然也可以导致进程崩溃。一般而言，没有绝对必要的共享内存空间的需求就不要使用线程，用进程会安全很多。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程使用锁经验总结</title>
      <link href="/p/f7f57f41.html"/>
      <url>/p/f7f57f41.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程使用锁经验总结"><a href="#多线程使用锁经验总结" class="headerlink" title="多线程使用锁经验总结"></a>多线程使用锁经验总结</h1><p>我们已经介绍了 Windows 和 Linux 操作系统提供的各种常用锁对象的使用原理和方法。多线程编程少不了与这些锁打交道，在使用锁时稍不注意就可能会造成死锁或者程序性能出现问题。这里总结了一些经验</p><h2 id="减少锁的使用次数"><a href="#减少锁的使用次数" class="headerlink" title="减少锁的使用次数"></a>减少锁的使用次数</h2><p>在实际开发中能不使用锁则尽量不使用锁，当然，这不是绝对的：如果使用锁也能满足性能要求，则使用锁也无妨。使用了锁的代码一般会存在如下性能损失：</p><ul><li>加锁和解锁操作，本身有一定的开销；</li><li>临界区的代码不能并发执行；</li><li>进入临界区的次数过于频繁，线程之间对临界区的争夺太过激烈，若线程竞争互斥体失败，就会陷入阻塞并让出 CPU，所以执行上下文切换的次数要远远多于不使用互斥体的次数。</li></ul><p>替代锁的方式有很多，例如无锁队列，无锁队列是一种并发数据结构，它允许多个线程同时进行插入和删除操作，而无需使用锁来保护临界区。它使用一些原子操作（如原子比较交换）来实现并发访问的同步。无锁队列的实现可以利用硬件原子操作提供的原子性保证，而不需要使用互斥锁来保护临界区。这样可以避免锁带来的开销和串行执行的限制，从而提高并发性能。但是，无锁队列的实现可能会更复杂，并且在高并发环境下可能会出现一些问题，如ABA问题和内存重排序等，需要仔细处理和考虑。</p><h2 id="明确锁的范围"><a href="#明确锁的范围" class="headerlink" title="明确锁的范围"></a>明确锁的范围</h2><p>先来看一个例子：</p><pre><code class="cpp">if (my_hashtable.is_empty()) &#123;    pthread_mutex_lock(&amp;my_mutex);    htable_insert(my_hashtable, &amp;my_elem);    pthread_mutex_unlock(&amp;my_mutex);&#125;</code></pre><p>上述代码，在判断 <code>my_hashtable</code> 是否为空之前，没有使用互斥体进行加锁。这可能导致多个线程同时访问并修改 <code>my_hashtable</code> 的状态，从而引发竞态条件（race condition）。<br>为了正确保护共享资源，应该对条件判断和插入操作都使用同一个互斥体进行加锁和解锁。正确的写法如下：</p><pre><code class="cpp">pthread_mutex_lock(&amp;my_mutex);if (my_hashtable.is_empty()) &#123;    htable_insert(my_hashtable, &amp;my_elem);&#125;pthread_mutex_unlock(&amp;my_mutex);</code></pre><p>这样做可以确保在判断为空和插入操作之间的原子性，避免了多个线程之间的竞争问题。</p><h2 id="减少锁的使用粒度"><a href="#减少锁的使用粒度" class="headerlink" title="减少锁的使用粒度"></a>减少锁的使用粒度</h2><p>减小锁的使用粒度，指的是尽量减小锁作用的临界区代码范围，临界区的代码范围越小，多个线程排队进入临界区的时间就会越短。<br>来看两个具体的示例<br>例1</p><pre><code>void TaskPool::addTask(Task* task) &#123;    std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);    std::shared_ptr&lt;Task&gt; spTask;    spTask.reset(task);    m_taskList.push_back(spTask);    m_cv.notify_one();&#125;</code></pre><p>在以上代码中，guard 锁保护 m_taskList。仔细分析这段代码会发现，代码中有一些其实没必要作为临界区内的代码，建议将其挪到临界区外面，修改如下：</p><pre><code>void TaskPool::addTask(Task* task) &#123;    std::shared_ptr&lt;Task&gt; spTask;    spTask.reset(task);    &#123;        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);        m_taskList.push_back(spTask);    &#125;    m_cv.notify_one();&#125;</code></pre><p>修改之后，guard锁仅对m_taskList.push_back（）操作做保护，这样锁的粒度就变小了。</p><p>例2</p><pre><code>void EventLoop::doPendingFunctors() &#123;    std::unique_lock&lt;std::mutex&gt; lock(m_mutex);    for (size_t i = 0; i &lt; m_pendingFunctors.size(); ++i) &#123;        m_pendingFunctors[i]();    &#125;&#125;</code></pre><p>在以上代码中，m_pendingFunctors是被锁保护的对象，它的类型是std：：vector，这样的代码运行效率较低，必须等当前线程逐个处理完m_pendingFunctors中的元素后，其他线程才能操作m_pendingFunctors。修改代码如下：</p><pre><code>void EventLoop::doPendingFunctors() &#123;    std::vector&lt;std::function&lt;void()&gt;&gt; pendingFunctors;    &#123;        std::unique_lock&lt;std::mutex&gt; lock(m_mutex);        pendingFunctors.swap(m_pendingFunctors);    &#125;    for (const auto&amp; functor : pendingFunctors) &#123;        functor();    &#125;&#125;</code></pre><p>修改之后的代码使用了一个局部变量 pendingFunctors，然后把m_pendingFunctors 中的内容倒换到 pendingFunctors 中，这样就可以释放锁并允许其他线程操作 m_pendingFunctors了。现在只要继续操作本地对象localFunctors就可以了，提高了效率。</p><h2 id="避免死锁的一些建议"><a href="#避免死锁的一些建议" class="headerlink" title="避免死锁的一些建议"></a>避免死锁的一些建议</h2><ol><li><p>在一个函数中如果有一个加锁操作，那么一定要记得在函数退出时解锁，且在每个退出路径上都不要忘记解锁。例如</p><pre><code class="cpp">void someFunction() &#123;    std::mutex mtx;    // 加锁    mtx.lock();    // 执行一些操作    // 在每个退出路径上都解锁    if (condition1) &#123;        mtx.unlock();        return;    &#125;    if (condition2) &#123;        mtx.unlock();        throw SomeException();    &#125;    // 其他操作    // 解锁并返回    mtx.unlock();&#125;</code></pre><p> 在上述示例中，我们确保在每个退出路径上都有对互斥量的解锁操作。无论是通过 <code>return</code> 语句直接返回、抛出异常或执行其他操作，都要记得解锁互斥量。这样可以确保在函数结束时释放资源并保持锁的一致性。另外，为了避免忘记解锁，还可以使用 RAII（Resource Acquisition Is Initialization）技术，通过  std::lock_guard 或 std::unique_lock 等智能锁类来管理互斥量的锁定和解锁操作。这样可以确保在作用域结束时自动释放锁，不需要手动调用解锁操作。上述已经介绍过，就不赘述了。</p></li><li><p>在线程退出时一定要及时释放其持有的锁。在实际开发中会因为一些特殊需求创建了一些临时线程，这些线程在执行完相应的任务后会退出。对于这类线程，如果其持有了锁，则在线程退出时，一定要记得释放其持有的锁。</p></li><li><p>多线程请求锁的方向要一致，避免死锁。假设现在有两个锁A 和 B，线程1在请求了锁A后再请求锁 B，线程 2 在请求了锁 B 后再请求锁 A，这种线程请求锁的方向就不一致了：线程 1的方向是从A到 B，线程2的方向是从 B到 A，多个线程请求锁的方向不一致容易造成死锁。所以建议线程1和线程2请求锁的方向保持一致，要么都从A到B，要么都从B到A。</p></li><li><p>当需要同一个线程重复请求一个锁时，就需要明白使用锁的行为是递增锁引用计数，还是阻塞或者直接获得锁。</p></li></ol><h2 id="避免活锁的一些建议"><a href="#避免活锁的一些建议" class="headerlink" title="避免活锁的一些建议"></a>避免活锁的一些建议</h2><p>“活锁”指多个线程使用trylock系列的函数时，由于相互谦让，导致即使在某段时间内锁资源可用，也可能导致需要锁的线程拿不到锁。举个生活中的例子，马路上两个人迎面走来，两个人可能会同时向一个方向避让，其本意是给对方让路，但还是发生了碰撞。我们在实际编码时，应该尽量避免让过多的线程使用trylock请求锁，以免出现活锁，这是对资源的一种浪费。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左值引用和右值引用</title>
      <link href="/p/64657.html"/>
      <url>/p/64657.html</url>
      
        <content type="html"><![CDATA[<h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>移动语义是现代c++重要特性，移动语义不适用于通过const引用将传递参数替换为方法。移动操作可能比拷贝操作快，但最坏情况下，他可能比拷贝慢，并且总是比通过const引用传递慢。</p><pre><code>#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);    &#125;    ~MyClass()    &#123;        --(*m_Member);        m_Member = nullptr;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;int main()&#123;    auto object1 = MyClass();    cout &lt;&lt; object1.GetValue()&lt;&lt;endl;    &#123;        auto object2 = MyClass();        cout &lt;&lt; object2.GetValue() &lt;&lt; endl;    &#125;    auto object3 = MyClass();    cout &lt;&lt; object3.GetValue() &lt;&lt; endl;    return 0;&#125;</code></pre><p>利用static成员统计内存中类的活动实例数<br>当MyClass包含拷贝构造函数后</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Constructing: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    ~MyClass()    &#123;        --(*m_Member);        m_Member = nullptr;        cout &lt;&lt; &quot;Destructing: &quot; &lt;&lt; s_Counter &lt;&lt; endl;    &#125;    MyClass(const MyClass&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Copying: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;MyClass CopyMyClass(MyClass parameter)&#123;    cout &lt;&lt; &quot;!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl;    return parameter;&#125;int main()&#123;    auto object1 = MyClass();    &#123;        auto object2 = MyClass();    &#125;    auto object3 = MyClass();    auto object4 = CopyMyClass(object3);    return 0;&#125;</code></pre><p>输出结果为：</p><pre><code>Constructing: 1Constructing: 2Destructing: 1Constructing: 2Copying: 3!!!!!!!!!!!!Copying: 4Destructing: 3Destructing: 2Destructing: 1Destructing: 0</code></pre><p>这里object3拷贝到参数中，然后返回值拷贝到object4中，之后调用析构函数析构这两个临时参数。<br>移动构造函数可以用来降低拷贝构造函数的复杂性，运行时将有同样多的对象，右值引用是编译器包中变量引用的对象是临时对象，所以可以随意拆解对象，可以进行更快的拷贝操作。</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Constructing: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    ~MyClass()    &#123;        if (m_Member)        &#123;            --(*m_Member);            m_Member = nullptr;            cout &lt;&lt; &quot;Destructing: &quot; &lt;&lt; s_Counter &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;Destroying a moved-from instance&quot; &lt;&lt; endl;        &#125;            &#125;    MyClass(const MyClass&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Copying: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    MyClass(MyClass&amp;&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        cout &lt;&lt; hex &lt;&lt; showbase;        cout &lt;&lt; &quot;Moving: &quot; &lt;&lt; &amp;rhs &lt;&lt; &quot; to &quot; &lt;&lt; this &lt;&lt; endl;        cout &lt;&lt; noshowbase &lt;&lt;dec;        rhs.m_Member = nullptr;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;MyClass CopyMyClass(MyClass parameter)&#123;    cout &lt;&lt; &quot;!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl;    return parameter;&#125;int main()&#123;    auto object1 = MyClass();    &#123;        auto object2 = MyClass();    &#125;    auto object3 = MyClass();    auto object4 = CopyMyClass(object3);    return 0;&#125;</code></pre><p>运行结果为：</p><pre><code>Constructing: 1Constructing: 2Destructing: 1Constructing: 2Copying: 3!!!!!!!!!!!!!!!!!Moving: 001CF894 to 001CF988Destroying a moved-from instanceDestructing: 2Destructing: 1Destructing: 0</code></pre><p>返回语句结束后，编译器不需要维护参数的状态，可以调用移动构造来创建object4</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/p/52505.html"/>
      <url>/p/52505.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="几个高性能并发指标"><a href="#几个高性能并发指标" class="headerlink" title="几个高性能并发指标"></a>几个高性能并发指标</h2><h3 id="QPS，每秒查询"><a href="#QPS，每秒查询" class="headerlink" title="QPS，每秒查询"></a>QPS，每秒查询</h3><p>QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p><h3 id="TPS，每秒事务"><a href="#TPS，每秒事务" class="headerlink" title="TPS，每秒事务"></a>TPS，每秒事务</h3><p>TPS：是TransactionsPerSecond的缩写，也就是事务数&#x2F;秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p><h3 id="RT，响应时间"><a href="#RT，响应时间" class="headerlink" title="RT，响应时间"></a>RT，响应时间</h3><p>响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。</p><p>响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整型变量的原子操作</title>
      <link href="/p/aebf582b.html"/>
      <url>/p/aebf582b.html</url>
      
        <content type="html"><![CDATA[<h1 id="整型变量的原子操作"><a href="#整型变量的原子操作" class="headerlink" title="整型变量的原子操作"></a>整型变量的原子操作</h1><p>线程同步技术，指的是多个线程同时操作某个资源（从程序的术语来说，这里的资源可能是一个简单的整型变量，也可能是一个复杂的C++对象）。多线程同时操作资源指的是多线程同时对资源进行读写。我们需要采取一些特殊的措施去保护这些资源，以免引起一些资源访问冲突（如死锁）或者得到意料外的结果。<br>当然，最简单的资源类型应该是整型变量。</p><h2 id="为什么给整型变量赋值不是原子操作"><a href="#为什么给整型变量赋值不是原子操作" class="headerlink" title="为什么给整型变量赋值不是原子操作"></a>为什么给整型变量赋值不是原子操作</h2><p>常见的整型变量操作有如下三种。</p><h3 id="给整型变量赋一个确定的值"><a href="#给整型变量赋一个确定的值" class="headerlink" title="给整型变量赋一个确定的值"></a>给整型变量赋一个确定的值</h3><p>例如 </p><pre><code>int a=1;</code></pre><p>这条指令操作一般是原子的，因为对应一条计算机指令，所以CPU将立即数 1搬运到变量a的内存地址中即可，汇编指令如下：</p><pre><code>mov dword ptr[a], 1</code></pre><p>这确实是最不常见的情形。由于现代编译器一般存在优化策略，所以如果变量a的值在编译期间就可以计算出来（例如在这里的例子中a 的值就是 1），那么 a 这个变量本身在正式版本的软件中（release版）就很有可能被编译器优化，凡是使用a的地方，直接使用常量1来代替。所以在实际的执行指令中，这样的指令存在的可能性较低</p><h3 id="变量自身增加或者减去一个值"><a href="#变量自身增加或者减去一个值" class="headerlink" title="变量自身增加或者减去一个值"></a>变量自身增加或者减去一个值</h3><p>例如：</p><pre><code>a++;</code></pre><p>从C&#x2F;C++语法的级别来看，这是一条语句，应该是原子的；但从编译得到的汇编指令来看，其实不是原子的，其一般对应三条指令，首先将变量a对应的内存值搬运到某个寄存器（如 eax）中，然后将该寄存器中的值自增 1，再将该寄存器中的值搬运回 a代表的内存中<br>现在假设 a的值是0，有两个线程，每个线程对变量 a的值都递增1，预想一下，其结果应该是2，可实际运行结果可能是1！</p><p><img src="https://s1.ax1x.com/2023/06/10/pCVns2R.png" alt="pCVns2R.png"></p><p>我们预想的结果是线程1和线程2的三条指令各自执行，最终a的值变为2，但是由于操作系统线程调度的不确定性，线程1执行完指令①和②后，eax寄存器中的值变为1，此时操作系统切换到线程2执行，执行指令③④⑤，此时eax的值变为1；接着操作系统切回线程1继续执行，执行指令⑥，得到a的最终结果1。</p><p>把一个变量的值赋给另一个变量，或者把一个表达式的值赋给另一个变量，如：</p><pre><code>int a=b;</code></pre><p>从C&#x2F;C++语法的级别来看，这条语句应该是原子的；但是从编译得到的汇编指令来看，由于现代计算机 CPU架构体系的限制，数据不能直接从内存某处搬运到内存另外一处，必须借助寄存器中转，因此这条语句一般对应两条计算机指令，即将变量b的值搬运到某个寄存器（如eax）中，再从该寄存器搬运到变量a的内存地址中.既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第1条指令执行完毕后被剥夺 CPU时间片，切换到另一个线程而出现不确定的情况。这和上一种情况类似.</p><h2 id="Windows平台上对整型变量的原子操作"><a href="#Windows平台上对整型变量的原子操作" class="headerlink" title="Windows平台上对整型变量的原子操作"></a>Windows平台上对整型变量的原子操作</h2><p>在Windows平台上，Interlocked系列函数提供了对整型变量的原子操作。这些函数可以直接对整型变量进行操作，而不需要使用额外的锁对象。下面是一些常用的Interlocked函数：</p><ol><li><p>InterlockedIncrement: 对一个整型变量执行原子的递增操作，并返回递增后的值。</p><pre><code class="cpp">LONG InterlockedIncrement(LONG volatile* Addend);</code></pre></li><li><p>InterlockedDecrement: 对一个整型变量执行原子的递减操作，并返回递减后的值。</p><pre><code class="cpp">LONG InterlockedDecrement(LONG volatile* Addend);</code></pre></li><li><p>InterlockedExchange: 对一个整型变量执行原子的交换操作，将新值存储到变量中，并返回原先的值。</p><pre><code class="cpp">LONG InterlockedExchange(LONG volatile* Target, LONG Value);</code></pre></li><li><p>InterlockedCompareExchange: 对一个整型变量执行原子的比较和交换操作，如果当前值等于预期值，则将新值存储到变量中，并返回原先的值；否则，不进行交换操作。</p><pre><code class="cpp">LONG InterlockedCompareExchange(LONG volatile* Destination, LONG Exchange, LONG Comparand);</code></pre></li><li><p>InterlockedAdd: 对一个整型变量执行原子的加法操作，并返回加法后的值。</p><pre><code class="cpp">LONG InterlockedAdd(LONG volatile* Addend, LONG Value);</code></pre></li></ol><p>这些函数都是以原子方式执行的，确保在多线程环境下对变量的操作是线程安全的。它们是Windows平台下常用的原子操作函数，可以用于实现线程同步和共享数据的访问保护。</p><h2 id="C-11对整型变量原子操作的支持"><a href="#C-11对整型变量原子操作的支持" class="headerlink" title="C++11对整型变量原子操作的支持"></a>C++11对整型变量原子操作的支持</h2><p>在C++98&#x2F;03标准中，如果想对整型变量进行原子操作，则要么利用操作系统提供的相关原子操作API，要么利用对应操作系统提供的锁对象对变量进行保护。在C++11标准中，引入了std::atomic模板类型，它提供了对整型变量的原子操作。std::atomic可以用于跨平台的编程，不再依赖特定的操作系统API或锁对象。<br>在C++11标准中，std::atomic提供了对多种整型变量的原子操作支持。除了常用的整型类型（如int、long等），std::atomic还支持其他整型类型和一些特定的操作。</p><p>完整的std::atomic支持的整型类型列表可以在cppreference官方网站找到。以下是一些常见的整型类型：</p><ul><li>bool</li><li>char, signed char, unsigned char</li><li>short, unsigned short</li><li>int, unsigned int</li><li>long, unsigned long</li><li>long long, unsigned long long</li><li>wchar_t</li><li>char16_t, char32_t</li><li>intptr_t, uintptr_t</li><li>size_t, ssize_t</li><li>ptrdiff_t</li></ul><p>对于每个支持的整型类型，std::atomic提供了相应的操作函数和操作符。</p><p>std::atomic提供了一系列成员函数和操作符，用于对整型变量进行原子操作。除了模拟整数运算，原子变量还有一些特殊的原子操作，比如 store、load、fetch_add、fetch_sub、exchange、compare_exchange_weak&#x2F;compare_exchange_strong，最后一组就是著名的 CAS（Compare And Swap）操作。而另一个同样著名的 TAS（Test And Set）操作，则需要用到一个特殊的原子类型atomic_flag。它不是简单的 bool 特化（atomic），没有 store、load 的操作，只用来实现 TAS，保证绝对无锁<br>下面是一些常用的std::atomic成员函数和操作符：</p><ol><li><p>load：原子地加载整型变量的值。</p><pre><code class="cpp">T load(std::memory_order order = std::memory_order_seq_cst) const noexcept;</code></pre></li><li><p>store：原子地存储给定的值到整型变量。</p><pre><code class="cpp">void store(T value, std::memory_order order = std::memory_order_seq_cst) noexcept;</code></pre></li><li><p>exchange：原子地交换整型变量的值，并返回原先的值。</p><pre><code class="cpp">T exchange(T desired, std::memory_order order = std::memory_order_seq_cst) noexcept;</code></pre></li><li><p>compare_exchange_weak&#x2F;strong：原子地比较整型变量的值和期望值，如果相等则将新值存储到变量中，否则不进行交换。</p><pre><code class="cpp">bool compare_exchange_weak(T&amp; expected, T desired, std::memory_order success, std::memory_order failure) noexcept;bool compare_exchange_strong(T&amp; expected, T desired, std::memory_order success, std::memory_order failure) noexcept;</code></pre></li></ol><p>除了上述成员函数，std::atomic还重载了一些操作符，如+&#x3D;、-&#x3D;、++、–等，用于实现原子的加法、减法、递增和递减操作。<br>原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“&#x3D;”的赋值形式，只能用圆括号或者花括号：</p><p>std::atomic提供了对整型变量的原子操作，保证在多线程环境下的线程安全性。它是C++11标准中用于原子操作的重要特性，使得跨平台的编程更加便捷和可靠。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda、资源管理与杂项</title>
      <link href="/p/46257.html"/>
      <url>/p/46257.html</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h4 id="1-Lambda捕获列表"><a href="#1-Lambda捕获列表" class="headerlink" title="1.Lambda捕获列表"></a>1.Lambda捕获列表</h4><pre><code class="cpp">   class MyClass &#123;          public:    void Foo()    &#123;        // 虽然看起来是按值捕获，但对        // data的修改会改变成员变量的值        auto Lambda = [=]()) &#123; data++; &#125;;        Lambda();     private:        int data = 0;    &#125;&#125;;</code></pre><p>正确做法：</p><pre><code class="cpp">    class MyClass &#123;    public:        void Foo()        &#123;            auto Lambda =[data = this-&gt; data]0 mutable &#123;                data+ +;            &#125;;            //...            Lambda0;            //....        &#125;    private:        int data = 0;&#125;;</code></pre><p>避免使用默认捕获模式。如果捕获this,需要明确写出。</p><h4 id="2-Lambda捕获局部变量"><a href="#2-Lambda捕获局部变量" class="headerlink" title="2.Lambda捕获局部变量"></a>2.Lambda捕获局部变量</h4><pre><code class="cpp">    例：        auto GetFunc()        &#123;            int thresh = 10;            // GetFunc返回后，局部变量被释放            return [&amp;thresh](int x)&#123; returnx &lt; thresh; &#125;;        &#125;        int main()        &#123;            vector&lt;int&gt; v&#123;0, 1, 3, 5&#125;;            // find if内部访问已被释放的变量导致未定义行为            auto it = find ifv.begin0. v.end0, GetFuncQ);            return 0;        &#125;</code></pre><p>当lambda对象会传递到函数外部的时候，避免按引用捕获局部变</p><h4 id="3-new的失败场景"><a href="#3-new的失败场景" class="headerlink" title="3.new的失败场景"></a>3.new的失败场景</h4><pre><code class="cpp">    auto p = new int[1024*1024];    if (p == nullptr) &#123;        //内存不足的处理    &#125;</code></pre><p>实际上，new操作符不会返回空指针，这是个错误的写法<br>正确写法1：</p><pre><code class="cpp">    try &#123;        auto p = new int[1024 * 1024];    &#125;     catch (std::bad alloc) &#123;        // .内存不足的处理    &#125;</code></pre><p>正确写法2：</p><pre><code class="cpp">    auto p = new(nothrow) int[1024 * 1024];    if (p == nullptr) &#123;        // .内存不足的处理    &#125;</code></pre><p>当需要处理new失败场景时，捕获std:bad _alloc异常或者使用new(nothrow)并判断空指针。</p><h4 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4.智能指针"></a>4.智能指针</h4><pre><code class="cpp">        void Func(shared. _ptr &lt;MyClass&gt; X,shared. ptr&lt;MyClass&gt; y)    &#123;        // ..    &#125;    int main()    &#123;        // 类型被重复写两次        unique_ ptr &lt;MyClass&gt; a(new MyClass);        // 在被智能指针接管前可能发生泄漏        Func(shared ptr&lt;MyClass&gt; (new MyClass),shared ptr&lt;MyClas&gt; (new MyClass));        return 0;    &#125;        </code></pre><p>正确做法：</p><pre><code class="cpp">    void Func(shared ptr &lt;MyClass&gt; x,shared_ ptr &lt;MyClass&gt; y)    &#123;        //....    &#125;    int main()    &#123;         auto a = make_ unique &lt;MyClass&gt;();        //....        Func(make_ shared &lt;MyClass&gt;(), make_ shared&lt;MyClass&gt;());        return 0;    &#125;</code></pre><p>使用std::make_ unique而不是new创建unique_ ptr<br>使用std::make shared而不是new创建shared_ptr</p><h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        for (auto it = numbers.begin(); it != numbers.end();++it) &#123;            if(*it == num) &#123;                // 删除该元素后，迭代器不再指向原有元素                // ++后迭代器指向的不是下一个元素                numbers.erase(it);            &#125;        &#125;    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>正确做法：</p><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        numbers.erase(std:remove(numbers. begin(), numbers.end(), num),numbers.end);    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>使用有效的迭代器，尤其注意在遍历的同时给容器增删元素时</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码风格规定</title>
      <link href="/p/41521.html"/>
      <url>/p/41521.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码风格规定"><a href="#代码风格规定" class="headerlink" title="代码风格规定"></a>代码风格规定</h2><hr><h4 id="单个标识符的命名风格有以下几种"><a href="#单个标识符的命名风格有以下几种" class="headerlink" title="单个标识符的命名风格有以下几种:"></a>单个标识符的命名风格有以下几种:</h4><p><strong>驼峰</strong>:每个单词第一个字母大写，其余小写: VariableName.<br>又可进一步细分为<strong>大驼峰</strong>(VariableName) 和<strong>小驼峰</strong>(variableName)</p><p><strong>内核</strong>:所有字母都小写，用下划线连接: variable name<br>C++的标准库源码都使用该命名方式</p><p><strong>匈牙利</strong>:以大驼峰为基础，给每个变量加上特定前缀表示其类型: iVariableName<br>匈牙利命名法存在可读性、可维护性方面的问题，已被现代编程实践所抛弃。</p><p><strong>全大写加下划线</strong>:所有字母都大写，用下划线连接: VARIABLE NAME<br>一般只用于常量和宏的命名.</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><hr><p>当今业界主流的排版风格:</p><ul><li>函数、类型、复合语句内部缩进一层</li><li>缩进使用空格而不是制表符</li><li>if&#x2F;for&#x2F;while&#x2F;switch和括号之间留一个空格</li><li>双目运算符两边留空格,逗号、分号后面留空格</li><li>圆括号内侧不空格</li><li>函数定义之间空行</li><li>注释符号(&#x2F;&#x2F;) 和内容之间留一个空格</li></ul><h2 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h2><hr><ul><li>程序必须为阅读它的人而编写，只是顺便用于机器执行。</li><li>短小的函数总是更简洁、容易阅读的。</li><li>功能单一的函数更容易被复用，简洁明了的代码更容易维护。</li><li>函数行数(建议不超过40行)</li><li>文件行数(建议不超过500行)</li><li>函数圈复杂度(建议不超过10)</li><li>函数内缩进嵌套层次(建议不超过4层)</li><li>架构度量(上帝类、模块耦合程度… .</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与函数</title>
      <link href="/p/29637.html"/>
      <url>/p/29637.html</url>
      
        <content type="html"><![CDATA[<h2 id="类与函数"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold, int&amp; count)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return SUCCESS;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>函数的输出没有意义，恒为SUCCESS<br>可以将返回值更改为return count;</p><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return count;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>这样输入输出更简洁，设计函数时， 优先使用返回值而不是输出参数。</p><h4 id="2-避免使用宏"><a href="#2-避免使用宏" class="headerlink" title="2.避免使用宏"></a>2.避免使用宏</h4><pre><code class="cpp">    例：        #define SQUARE(a)a*a        #define MAX(a, b) ((a) &lt; (b))? (b) : (a)        int main()        &#123;            intx = SQUARE(1 + 2);// 宏扩展为1+2*1+2,结果为4            unsigned int a = 1;            int y = SQUARE(a++); //a自增多次            a=1;            int b=-1;            cout &lt;&lt; MAX(a, b); //不同参数类型无法检查会导致错误结果            return 0;        &#125;</code></pre><p>可以使用函数替代宏函数</p><pre><code class="cpp">    inline int Square(int a) &#123; returna* a; &#125;    inline int Max(int a, int b)    &#123;        returna&lt;b?b:a;    &#125;    int main()    &#123;        int x = Square(1 + 2);        unsigned int a= 1;        int y = Square(a++);        int b= -1;        cout &lt;&lt; Max(a, b);        return 0;    &#125;</code></pre><p>宏有类型检查、非预期副作用、运算优先级等方面的缺点,应当尽可能用函数、inline函数、 模板函数代替宏。<br>如果不得不使用宏， 则必须在定义宏时使用完备的括号。</p><h4 id="3-类和成员初始化"><a href="#3-类和成员初始化" class="headerlink" title="3.类和成员初始化"></a>3.类和成员初始化</h4><pre><code class="cpp">    class Message &#123;    public:                Message()&#123;&#125;//所有成员都没有初始化        Message(int id, int len) : msglD(id), msgLength(len) &#123;&#125;//msgBuffer指针没有初始化     private:        unsigned int msglD;        unsigned int msgLength;        unsigned char* msgBuffer;    &#125;    int main()    &#123;        Message a;//随机值        Message b(1, 2);//可能访问野指针        return 0;     &#125;</code></pre><p>禁止使用未经初始化的变量作为右值<br>类的所有构造函数都要保证所有成贸被正确初始化<br>优先使用初始化列表或者类内初始化来初始化成员</p><h4 id="4-虚函数重写规则"><a href="#4-虚函数重写规则" class="headerlink" title="4.虚函数重写规则"></a>4.虚函数重写规则</h4><pre><code class="cpp">    例：        class Base &#123;        public:            virtual void mf1() const;            virtual void mf2(int x);            virtual void mf3() &amp;;             void mf4() const;        &#125;;        class Derived : public Base &#123;        public:            virtual void mf1();//没有const            virtual void mf2(unsigned int x);//参数不匹配，重载            virtual void mf3() &amp;&amp;;//this是右值引用，基类是左值引用            void mf4() const;//mf4并没有用virtual修饰        &#125;;    以上函数都没有成功的重载，并且编译器不会发生告警</code></pre><p>C++ 11新增的override可以有效的避免这种编码错误<br>override必须是继承而来的虚函数，否则编译不过<br>在重写虚函数时使用override或者final关键字<br>final不允许子类继续重写虚函数</p><h4 id="5-禁止在构造函数析构函数中调用虚函数"><a href="#5-禁止在构造函数析构函数中调用虚函数" class="headerlink" title="5.禁止在构造函数析构函数中调用虚函数"></a>5.禁止在构造函数析构函数中调用虚函数</h4><pre><code class="cpp">    class Base &#123;    public:        //构造函数中调用虚函数，此时虚表还没有初始化完成        //不会调用到子类的虚函数        Base()&#123; Log(); &#125;;        //调用纯虚函数会产生未定义行为        virtual void Log() = 0;    &#125;;    class Sub : public Base &#123;    public:        virtualvoid Log()&#123;... &#125;;    &#125;</code></pre><p>禁止在构造函数和析构函数中调用虚函数,产生未定义行为或者达不到多态的目的</p><h4 id="6-内存操作函数"><a href="#6-内存操作函数" class="headerlink" title="6.内存操作函数"></a>6.内存操作函数</h4><pre><code class="cpp">    class Point &#123;    public:        virtual ~Point(); //Point对象包含虚表指针    private:        int X;        int y;    &#125;    int main()&#123;        Point a;        memset(&amp;a, 0, sizeof(a));//memset操作会破坏对象的虚表指针        return 0;    &#125;;</code></pre><p>禁止使用memcpy. memset等内存操作函数初始化非POD对象</p><h6 id="POD对象："><a href="#POD对象：" class="headerlink" title="POD对象："></a>POD对象：</h6><p>在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。<br>一般来说，POD对象应该满足如下特性。</p><p>对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，<br>如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，<br>再将其复制回对象，那么该对象的值与原始值一样。</p><p>对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，<br>如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。</p><p>简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，<br>只要其二进制内容在，就能还原出正确无误的POD对象。<br>对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。</p><h4 id="7-析构函数"><a href="#7-析构函数" class="headerlink" title="7.析构函数"></a>7.析构函数</h4><pre><code class="cpp">    class Base &#123;    public:        virtual const char* Name() const        &#123;            return &quot;Base&quot;;         &#125;    &#125;;    class Sub : public Base &#123;    public:        Sub() : numbers(new int[1000]) &#123;&#125;         ~Sub() &#123; delete[] numbers; &#125;        virtual const char* Name() const        &#123;        return &quot;Sub&quot;;        &#125;    private:        int* numbers;    &#125;;    int main(int argc, char* argsQ)    &#123;        Base* b = new Sub();        delete b;        return 0;     &#125;</code></pre><p>基类没有定义虚析构函数，所以main函数中并没有析构子类数据成员，造成内存泄露<br>基类的析构函数应当声明为虚函数</p><h4 id="8-虚函数的缺省参数"><a href="#8-虚函数的缺省参数" class="headerlink" title="8.虚函数的缺省参数"></a>8.虚函数的缺省参数</h4><pre><code class="cpp">    class Base&#123;    public:         virtual void Display(const std:string&amp; text = &quot;Base!&quot;)&#123;            std:.cout &lt;&lt; text &lt;&lt; std::endl;        &#125;        virtual ~ Base()&#123;&#125;    &#125;;    class Sub : public Base &#123;    public:        virtual void Display(const stl:string&amp; text = &quot;Sub!&quot;)        &#123;            std:cout &lt;&lt; text &lt;&lt; std:.endl;        &#125;        virtual ~Sub()&#123;&#125;     &#125;;    int main(        Base* base = new Sub();        Sub* sub = new Sub();        // ..        base-&gt; Display();         sub-&gt; Display();        delete base;         delete sub;        return 0;    &#125;;</code></pre><p>调用的函数是运行时决定的，但缺省参数是编译时决定的，导致使用”Base!” 参数调用Sub<br>类的Display<br>禁止子类的虚函数定义与基类不同的缺省参数</p><h4 id="9-void"><a href="#9-void" class="headerlink" title="9.void*"></a>9.void*</h4><pre><code class="cpp">    class BaseA &#123;    public:        virtual void FunA();         virtual ~BaseA();    &#125;;    class BaseB &#123;    public:        virtual void FunB();        virtual ~ BaseB();    &#125;;    class Sub : public BaseA, public BaseB &#123;    public:        virtual void FunA();         virtual void FunB();        virtual ~Sub();    &#125;;    int main()    &#123;        BaseA* pa = new Sub();        void* pv = pa;        BaseB* pb = (BaseB*)pv;        // ..        delete pb;        return 0;    &#125;;        //  正确做法    //  int main()    //  &#123;    //      BaseA* pa = new Sub();    //      BaseB* pb = dynamic cast&lt;BaseB*&gt; (pa);    //      return 0;    //  &#125;</code></pre><p>BaseA和BaseB的指针虽然指向同一个对象，但它们应该有不同的地址值。<br>如果使用void<em>转换，则使BaseA</em>和BaseB<em>为相同地址，产生未定义行为<br>void</em>丢失了对象的类型信息，失去了编译时的类型检查能力，应避免使用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
            <tag> 编码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全编码与未定义行为</title>
      <link href="/p/22884.html"/>
      <url>/p/22884.html</url>
      
        <content type="html"><![CDATA[<h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><h4 id="1-不要使用越界的指针或者数组下标"><a href="#1-不要使用越界的指针或者数组下标" class="headerlink" title="1.不要使用越界的指针或者数组下标"></a>1.不要使用越界的指针或者数组下标</h4><pre><code class="cpp">    例：        int a[4];        for(int i=0;i&lt;=4;i++)&#123;            a[i]=i;        &#125;    缓冲区溢出在CWE漏洞库中排名第二  </code></pre><h4 id="2-避免任何可能产生未定义行为的代码"><a href="#2-避免任何可能产生未定义行为的代码" class="headerlink" title="2.避免任何可能产生未定义行为的代码"></a>2.避免任何可能产生未定义行为的代码</h4><pre><code class="cpp">    例：        char *Getstring(bool choice)&#123;            char str[6];            if(choice)&#123;                strcpy(str,&quot;true&quot;);            &#125;            else&#123;                strcpy(str,&quot;false&quot;);            &#125;            return str;        &#125;    因为局部变量保存在栈中，随着函数返回，栈内内容可能会被释放或者被覆盖。</code></pre><h4 id="3-确保整数运算不溢出"><a href="#3-确保整数运算不溢出" class="headerlink" title="3.确保整数运算不溢出"></a>3.确保整数运算不溢出</h4><pre><code class="cpp">    例：        int32_t Average(int32_t x,int32_t y)&#123;            return (x+y)/2;        &#125;    可能发生int溢出，超出int表示范围，导致结果异常        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int64_t&gt; (x+y)/2;        &#125;    这是一个错误的更正,已经发生溢出才进行类型转换。        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int32_t&gt;((static_cast&lt;int64_t&gt;(x)+y)/2);        &#125;    运算时编译器会自动将y进行类型转换为int64_t</code></pre><h4 id="4-char用来表示数值时明确有符号还是无符号"><a href="#4-char用来表示数值时明确有符号还是无符号" class="headerlink" title="4.char用来表示数值时明确有符号还是无符号"></a>4.char用来表示数值时明确有符号还是无符号</h4><pre><code class="cpp">    例：        char a=-100;        unsigned int b=a;        标准并没有规定char类型是否是有符号数，可能导致不同编译器产生不同结果</code></pre><h4 id="5-避免混用有符号和无符号数"><a href="#5-避免混用有符号和无符号数" class="headerlink" title="5.避免混用有符号和无符号数"></a>5.避免混用有符号和无符号数</h4><pre><code class="cpp">    例：        int  a=-1;        unsigned b=1;        cout&lt;&lt;(b&gt;a);    结果是false，因为编译器将有符号转换为了无符号数，所以-1是无符号int最大的正数</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式与变量</title>
      <link href="/p/39885.html"/>
      <url>/p/39885.html</url>
      
        <content type="html"><![CDATA[<h2 id="表达式与变量"><a href="#表达式与变量" class="headerlink" title="表达式与变量"></a>表达式与变量</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><h6 id="a-cpp"><a href="#a-cpp" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int g_GlobalX=1;</code></pre><h6 id="b-cpp"><a href="#b-cpp" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int g_GlobalX;    int g_GlobalY=1+g_GlobalX;    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>这里由于全局变量初始化顺序不确定导致结果不唯一。<br>如果先初始化g_GlobalX那么g_GlobalY为2，否则为1。<br>那么该如何解决这个问题呢，下面有一种解决办法：</p><h6 id="a-cpp-1"><a href="#a-cpp-1" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int GetX()&#123;        static int g_GlobalX=1;        return g_GlobalX;    &#125;</code></pre><h6 id="b-cpp-1"><a href="#b-cpp-1" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int GetX();    int g_GlobalY=1+GetX();    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>函数中静态变量一定会在第一次调用函数时初始化<br>这也就解决了全局变量初始化顺序的问题</p><h4 id="2-函数名是函数的地址"><a href="#2-函数名是函数的地址" class="headerlink" title="2.函数名是函数的地址"></a>2.函数名是函数的地址</h4><pre><code class="cpp">    例：        bool isFriday()&#123;            return true;        &#125;        int main()&#123;            if(isFriday)&#123;                cout&lt;&lt;&quot;yes&quot;;            &#125;            else&#123;                cout&lt;&lt;&quot;no&quot;;            &#125;            return 0;        &#125;</code></pre><p>这个的结果恒为真，因为调用函数没有加上（），函数名是地址恒不为0;</p><h4 id="3-switch每个case都要有break"><a href="#3-switch每个case都要有break" class="headerlink" title="3.switch每个case都要有break"></a>3.switch每个case都要有break</h4><pre><code class="cpp">    通常情况下case之后都要有break    但是如果需要滑入下一个分支，必须明确注释或者使用c++17的[[fallthrough]]</code></pre><h4 id="4-和–"><a href="#4-和–" class="headerlink" title="4.++和–"></a>4.++和–</h4><pre><code class="cpp">    例：        int i=0;        int x=0;        int b[10];        x=b[i]+i++;        func(i++,i);    </code></pre><p>同一个表达式中的i，使用的是自增之前的值还是之后的无法确定，存在隐患<br>含有变量自增或者自减的表达式中禁止再次使用该变量.</p><h4 id="5-避免过大的栈上变量"><a href="#5-避免过大的栈上变量" class="headerlink" title="5.避免过大的栈上变量"></a>5.避免过大的栈上变量</h4><pre><code class="cpp">    class Vector&#123;        public :        int value[10000];    &#125;    Vector Decrement(Vector input)&#123;        Vector output;        for(int i=0;i&lt;10000;i++)&#123;            output.value[i]=input.value[i]+100;        &#125;        return output;    &#125;</code></pre><p>当局部变量大小超过1k时就需要审视其合理性<br>较大的函数类型作为函数参数时，应使用引用或者const引用</p><h4 id="6-使用引用代替指针"><a href="#6-使用引用代替指针" class="headerlink" title="6.使用引用代替指针"></a>6.使用引用代替指针</h4><pre><code class="cpp">    void Caculate(int input, char* op, int* output)    &#123;        if (op == nullptr) &#123;            *output = input;        &#125;         else if (strcmp(op, &quot;add&quot;) == 0) &#123;            *output = input + 10;        &#125;         else if (strcmp(op, &quot;subtract&quot;) == 0) &#123;            *output = input - 10;        &#125;    &#125;</code></pre><p>单个对象不允许为空，建议用引用int&amp;<br>但如果传入的是一串对象(数组)，则应当用指针或者封装的类型<br>引用不为空，而且指向的对象不会变化。应当优先使用引用取代指针。</p><h4 id="7-不修改变量、函数采用const修饰"><a href="#7-不修改变量、函数采用const修饰" class="headerlink" title="7.不修改变量、函数采用const修饰"></a>7.不修改变量、函数采用const修饰</h4><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>这里两个成员函数都不修改形参或者是this，所以应采用const修饰</p><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>定义接口时，将不修改的类型声明为const,可以让使用者知晓哪些对象不会被修改。<br> 编码时如不惧将对象修改了，，能够在编译时就发现问题而不是等到运行时debug.</p><h4 id="8-数组作为参数"><a href="#8-数组作为参数" class="headerlink" title="8.数组作为参数"></a>8.数组作为参数</h4><pre><code class="cpp">    int CountLength(char str[])//int CountLength(char str[10])    &#123;        for (inti = 0;i &lt; sizeof(str) / sizeof(char); ++i) &#123;            if(str[] == &#39;\0&#39;) &#123;            return i;            &#125;        &#125;        return sizeof(str);    &#125;</code></pre><p>这里str是一个指针，sizeof(str)返回的是指针的大小，而不是数组的大小<br>不要将指针作为sizeof的参数来获取指向内容的长度。<br>不要对函数的数组参数使用sizeof</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11/14/17线程同步对象</title>
      <link href="/p/4071de72.html"/>
      <url>/p/4071de72.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-11-x2F-14-x2F-17线程同步对象"><a href="#C-11-x2F-14-x2F-17线程同步对象" class="headerlink" title="C++11&#x2F;14&#x2F;17线程同步对象"></a>C++11&#x2F;14&#x2F;17线程同步对象</h1><p>在C&#x2F;C++中直接使用操作系统提供的多线程资源同步API 虽然限制最少，但使用起来毕竟不方便，同样的代码不能同时兼容Windows和Linux两个平台。C++11标准新增了很多现代编程语言的标配，线程资源同步对象就是其中很重要的部分。本节将讨论C++11标准中新增的用于线程同步的std：：mutex和std：：condition_variable对象的用法，有了它们，我们就可以写出跨平台的多线程程序了。</p><h2 id="std：：mutex系列"><a href="#std：：mutex系列" class="headerlink" title="std：：mutex系列"></a>std：：mutex系列</h2><p>在 C++11&#x2F;14&#x2F;17 中，提供了如下 mutex 系列类型：</p><ol><li><p><code>std::mutex</code>: 最基本的互斥量类型，提供了独占访问的能力，可以使用 <code>lock()</code> 和 <code>unlock()</code> 方法进行加锁和解锁操作。</p></li><li><p><code>std::timed_mutex</code>: 在 <code>std::mutex</code> 的基础上增加了超时功能，可以使用 <code>try_lock_for()</code> 和 <code>try_lock_until()</code> 方法进行带超时的加锁操作。</p></li><li><p><code>std::recursive_mutex</code>: 递归互斥量，允许同一个线程多次对互斥量进行加锁，避免死锁。同一个线程多次加锁时需要对应释放相同次数的锁。</p></li><li><p><code>std::recursive_timed_mutex</code>: 在 <code>std::recursive_mutex</code> 的基础上增加了超时功能。</p></li><li><p><code>std::shared_mutex</code>: 共享互斥量，提供了共享访问的能力，允许多个线程同时对互斥量进行读操作，但只能有一个线程进行写操作。可以使用 <code>lock()</code> 和 <code>unlock()</code> 方法进行加锁和解锁，也可以使用 <code>lock_shared()</code> 和 <code>unlock_shared()</code> 方法进行共享加锁和解锁。</p></li><li><p><code>std::shared_timed_mutex</code>: 在 <code>std::shared_mutex</code> 的基础上增加了超时功能。</p></li></ol><p>这些 mutex 类型都定义在 <code>&lt;mutex&gt;</code> 头文件中，并位于 <code>std</code> 命名空间中。它们提供了一系列方法和操作来实现线程间的同步和互斥访问。使用这些 mutex 类型可以确保在多线程环境下对共享资源的安全访问。不同的 mutex 类型可以根据具体需求选择合适的类型。<br>这个系列类型的对象均提供了加锁（lock）、尝试加锁（trylock）和解锁（unlock）的方法，这里以std：：mutex类为例，说明std：：mutex系列锁的用法，示例代码如下：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;mutex&gt;// g_num使用g_num_mutex进行保护int g_num = 0;std::mutex g_num_mutex;void slow_increment(int id)&#123;    for (int i = 0; i &lt; 3; ++i)    &#123;        g_num_mutex.lock();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; &quot; =&gt; &quot; &lt;&lt; g_num &lt;&lt; std::endl;        g_num_mutex.unlock();        // 睡眠1秒        std::this_thread::sleep_for(std::chrono::seconds(1));    &#125;&#125;int main()&#123;    std::thread t1(slow_increment, 0);    std::thread t2(slow_increment, 1);    t1.join();    t2.join();    return 0;&#125;</code></pre><p>在代码示例中，我们在 <code>slow_increment()</code> 函数中使用了互斥量 <code>g_num_mutex</code> 来保护 <code>g_num</code> 的访问。在访问 <code>g_num</code> 前调用 <code>lock()</code> 方法进行加锁操作，确保只有一个线程可以访问 <code>g_num</code>，在访问完成后调用 <code>unlock()</code> 方法进行解锁操作。<br>在 <code>main()</code> 函数中，我们创建了两个线程 <code>t1</code> 和 <code>t2</code> 分别调用 <code>slow_increment()</code> 函数。通过互斥量的加锁和解锁操作，我们确保了对 <code>g_num</code> 的安全访问，避免了竞态条件的发生。<br>在每次访问 <code>g_num</code> 之后使用 <code>std::this_thread::sleep_for()</code> 方法使线程休眠1秒，以便观察到不同线程交替执行的效果。<br>请注意，由于互斥量的使用，每个线程在访问 <code>g_num</code> 时都会等待另一个线程释放锁。这样可以确保对 <code>g_num</code> 的递增操作是互斥的，避免了并发访问导致的问题。</p><p>注意：如果在 Linux下编译和运行程序，则在编译时需要链接pthread库，否则虽然能够正常编译，但在运行时程序会崩溃<br>为了避免死锁，std：：mutex.lock方法和std：：mutex：：unlock方法需要成对使用，但是如上面所介绍的，如果在一个函数中有很多出口，而互斥体对象又是需要在整个函数作用域被保护的资源，那么我们在编码时会因为忘记在某个出口处调用std：：mutex.unlock而造成死锁。所以我们推荐通过RAII技术封装这两个接口。其实C++新标准也为我们提供了如下封装:</p><ol><li><p><code>std::lock_guard</code>（C++11）：基于作用域的互斥量管理。<code>std::lock_guard</code> 是一个模板类，用于管理互斥量的加锁和解锁操作。在 <code>std::lock_guard</code> 对象的作用域结束时，会自动解锁互斥量。它适用于简单的互斥量保护，可以确保互斥量在作用域结束时被正确解锁。</p></li><li><p><code>std::unique_lock</code>（C++11）：更加灵活的互斥量管理。<code>std::unique_lock</code> 也是一个模板类，提供了比 <code>std::lock_guard</code> 更多的灵活性和功能。除了自动加锁和解锁外，<code>std::unique_lock</code> 还支持延迟加锁、条件变量等功能。它适用于需要更精细控制互斥量的场景。</p></li><li><p><code>std::shared_lock</code>（C++14）：共享互斥量的管理。<code>std::shared_lock</code> 也是一个模板类，用于管理共享互斥量的加锁和解锁操作。与 <code>std::unique_lock</code> 不同，<code>std::shared_lock</code> 允许多个线程同时持有共享锁，以提高并发性能。它适用于读多写少的场景。</p></li><li><p><code>std::scoped_lock</code>（C++17）：多互斥量避免死锁的管理。<code>std::scoped_lock</code> 是一个模板类，用于管理多个互斥量的加锁和解锁操作。它提供了避免死锁的机制，能够同时对多个互斥量进行加锁，并确保在异常情况下的正确解锁。它适用于多个互斥量之间存在交叉依赖的场景，能够简化死锁管理。</p></li></ol><p>这些互斥量管理类提供了更高级和安全的方式来管理互斥量，使得多线程编程更加简单和可靠。根据具体的需求，选择合适的互斥量管理类可以提高代码的可读性和性能，并避免常见的线程安全问题。</p><h2 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h2><p>C++11标准让很多开发者诟病的原因之一是，它借鉴了 Boost库的boost：：mutex、boost：：shared_mutex 来引入std：：mutex 和std：：shared_mutex，但是在 C++11 中只引入了std：：mutex，直到C++17才有std：：shared_mutex，导致使用仅支持C++11标准的编译器（例如Visual Studio 2013、gcc&#x2F;g++4.8）进行开发非常不便。在商业项目中一般不会轻易升级编译器，因为商业项目一般牵涉的代码范围较大，升级编译器后可能导致大量旧的文件需要修改。例如对于被广泛使用的CentOS 7.0，其自带的 gcc编译器是 4.8，在升级 gcc的同时会导致系统自带的glibc库发生变化，使系统中大量的其他程序无法运行。因此在实际的商业项目中，升级旧的开发环境必须非常谨慎。<br>std：：shared_mutex的底层实现是操作系统提供的读写锁，也就是说，在有多个线程对共享资源读且少许线程对共享资源写的情况下，std：：shared_mutex比std：：mutex效率更高。std：：shared_mutex提供了lock 方法和unlock 方法分别用于获取写锁和解除写锁，提供了lock_shared方法和unlock_shared方法分别用于获取读锁和解除读锁。我们一般将写锁模式称为排他锁（Exclusive Locking），将读锁模式称为共享锁（Shared<br>Locking）<br>另外，在C++新标准中引入了与std：：shared_mutex配合使用的两个对象——std：：unique_lock和std：：shared_lock，这两个对象在构造时自动对std：：shared_mutex加锁，在析构时自动对std：：shared_mutex 解锁，前者用于加解 std：：shared_mutex 的写锁，后者用于加解std：：shared_mutex的读锁。std：：unique_lock在C++11中引入，std：：shared_lock在C++14中引入。</p><h2 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h2><p>C++11提供了std：：condition_variable类来代表条件变量，与Linux系统原生的条件变量一样，还提供了等待条件变量满足的wait系列方法（wait、wait_for、wait_until方法），发送条件信号时使用notify 方法（notify_one 和 notify_all 方法）。当然，使用std：：condition_variable对象时需要绑定1个std：：unique_lock或std：：lock_guard对象。<br>与 Linux 或 Windows 自带的条件变量相比，对 C++11 的std：：condition_variable不再需要显式地初始化和销毁。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex mtx;  // 互斥锁std::condition_variable cv;  // 条件变量bool isReady = false;  // 条件变量的状态void waitingThread()&#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);        // 等待条件变量满足    cv.wait(lock, []()&#123; return isReady; &#125;);        // 条件满足后继续执行    std::cout &lt;&lt; &quot;Condition is ready. Proceeding...&quot; &lt;&lt; std::endl;&#125;void notifyingThread()&#123;    std::this_thread::sleep_for(std::chrono::seconds(3));  // 模拟一段时间后发送条件信号        &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        isReady = true;    &#125;        // 发送条件信号    cv.notify_one();&#125;int main()&#123;    // 创建等待线程    std::thread waiting(waitingThread);        // 创建发送信号线程    std::thread notifying(notifyingThread);        // 等待线程完成    waiting.join();    notifying.join();        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初始化方式</title>
      <link href="/p/814162d0.html"/>
      <url>/p/814162d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><p>c++初始化方式有很多种，例如</p><pre><code>int x(0);int y = 0;int z&#123;0&#125;;int u = &#123;0&#125;;//=&#123;&#125;通常按照上述&#123;&#125;方式处理</code></pre><p>对于非静态成员，可以用{}和&#x3D; 指定默认初始化值，但是不可以用()</p><pre><code>class Widget&#123;    ...private:     int x&#123;0&#125;;    int y = 0;    int z(0);//不可行！！！&#125;</code></pre><p>但是对于不可复制的对象（比如std::atomic类型的对象)可以采用大括号小括号，却不能用‘&#x3D;’<br>    std::atomic<int> ai1{0};<br>    std::atomic<int> ai2 &#x3D;0;&#x2F;&#x2F;不可行！！！<br>    std::atomic<int> ai3(0);</int></int></int></p><p>由此可见{}应用更为普适。但是{}禁止内建型别隐式窄化型别转换</p><pre><code>double x,y,z;...int sum = &#123;x+y+z&#125;;//不可行</code></pre><p>但是小括号和&#x3D;则可以窄化转换<br>    int sum(x+y+z);<br>    int sum &#x3D; x + y + z;</p><p>但是{}有个很大的问题，如果构造函数声明了任何一个具备std::initializer_list类型的形参，那么{}初始化语法的句子会优先匹配std::initializer_list对应的重载版本。</p><pre><code>class Widget&#123;public:    Widget(int i,bool j);    Widget(int i,double j);    Widget(std::initializer_list&lt;long double&gt;il);&#125;Widget w1(10,true);//调用第一个构造函数Widget w1&#123;10,true&#125;;//调用第三个构造函数Widget w3(10,3.0);//调用第二个构造函数Widget w4&#123;10,3.0&#125;;//调用第三个构造函数</code></pre><p>同理，复制或者移动构造函数都会被std::initializer_list型别的构造函数劫持。</p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;long double&gt; il);operator float() const;   // 支持隐式转换为float类型...&#125;;Widget w5(w4);    // 使用圆括号，调用拷贝构造函数Widget w6&#123;w4&#125;;   // 使用大括号，调用第三个构造函数                // 原因是先把w4转换为float，再把float转换为long dobuleWidget w7(std::move(m4));  // 使用圆括号，调用移动构造函数Widget w8&#123;std::move(m4)&#125;;  // 使用大括号，调用第三个构造函数，理由同w6</code></pre><p>编译器用带有std::initializer_list构造函数匹配大括号初始值的决心是<br>如此的坚定，就算带有std::initializer_list的构造函数是无法调用的：</p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;bool&gt; il);  // long double 改为 bool...&#125;;Widget w&#123;10, 5.0&#125;;  // 报错，因为发生范围窄化转换</code></pre><p>就算是这样，编译器也会忽略另外两个构造函数(第二个还是参数精确匹配的)，并且尝试调用带有std::initializer_list<bool>的构造函数。而调用第三个构造函数会让一个int(10)值和一个double(5.0)值转换为bool类型。这两个转换都是范围窄化转换(bool的大小不能准确描述它们的值)，然而窄化转换在大括号初始化语法中是被禁止的，所以这个函数调用无效，代码无法编译通过。</bool></p><p>只有当大括号内的值无法转换为std::initializer_list元素的类型时，编译器才会使用正常的重载选择方法，例如把上面的std::initializer_list<bool>改为std::initializer_list<a href="std::string">std::string</a>，那么那些非std::initializer_list构造函数会重新成为候选函数，因为没有办法从数值转换为std::string：</bool></p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;std::string&gt; il);  // bool 改为 std::string...&#125;;Widget w1(10, true);  // 使用圆括号，调用第一个构造函数Widget w2&#123;10, true&#125;;  // 使用大括号，不过调用第一个构造函数Widget w3(10, 5.0);   // 使用圆括号，调用第二个构造函数Widget w4&#123;10, 5.0&#125;;  // 使用大括号， 不过调用第二个构造函数</code></pre><p>这就会让编译器检查大括号内的初始值然后选择重载函数，不过这里有一个有趣的边缘情况。一个大括号内无参的构造函数，不仅可以表示默认构造，还可以表示带std::initializer_list的构造函数。你的空括号是表示哪一种情况呢？如果它表示不带参数，那么就是默认构造，如果它表示一个空的std::initializer_list，那么就是从一个不带元素的std::initializer_list进行构造。</p><p>正确答案是你将使用默认构造，一个空的大括号表示的是没有参数，而不是一个空的std::initializer_list：</p><pre><code>class Widget &#123;public:    Widget();    Widget(std::initializer_list&lt;int&gt; il);    ...&#125;;Widget w1;   // 调用默认构造函数Widget w2&#123;&#125;;   // 调用默认构造函数Widget w3();   // 出现most vexing parse，声明了一个函数</code></pre><p>如果你想要用一个空的std::initializer_list参数来调用带std::initializer_list构造函数，那么你需要把大括号作为参数，即把空的大括号放在圆括号内或者大括号内：</p><pre><code>Widget w4(&#123;&#125;);   // 用了一个空的list来调用带std::initializer_list构造函数Widget w5&#123;&#123;&#125;&#125;;   // 同上</code></pre><p>std::vector中有一个可以指定容器的大小和容器内元素的初始值的不带std::initializer_list构造函数，但它也有一个可以指定容器中元素值的带std::initializer_list函数。如果你想要创建一个数值类型的std::vector(例如std::vector)，然后你要传递两个值作为构造函数的参数，那么使用大括号与圆括号的行为是不同的：</p><pre><code>std::vector&lt;int&gt; v1(10, 20);   // 使用不带std::initializer_list的构造函数                        // 创建10个元素的vector，每个元素的值为20std::vector&lt;int&gt; v2&#123;10, 20&#125;;   // 使用带std::initializer_list的构造函数                        // 创建2个元素的vector，元素值为10和20</code></pre><p>我们先忽视std::vector和圆括号，大括号，构造函数重载规则。这次讨论不涉及两个要素。首先，作为一个类的作者，你需要知道如果你的构造函数集中包含一个带std::initializer构造函数，客户代码中使用了大括号初始化的话看起来好像只有带std::initializer构造函数。因此，你最好把构造函数设计得重载调用不受大括号和圆括号影响。换句话说，把上面std::vector出现的情况中当作错误，自己写代码时应该避免这样。</p><p>如果你的类一开始不含有带std::initializer_list构造函数，后来你加了一个，那么用户会发现，原理使用大括号初始化时选择的是不带std::initializer_list构造函数，而现在全部都选择带std::initializer_list构造函数。当然，这种事情在你为重载函数再添加一个实现时也有可能发生：本来是调用旧的重载函数可能会选择新加入的函数。不过std::initializer_list构造函数的不同之处是，带std::initializer_list构造函数不用与其它构造函数竞争，它直接遮蔽了其它的构造函数。所以加入带std::initializer_list需要深思熟虑。</p><p>你想通过随意的数值参数来创建一个数值类型对象。一个可变参数模板在概念上可以很直接的实现：</p><pre><code>template &lt;typename T, typename... Ts&gt;void doSomeWork(Ts&amp;&amp;... params)&#123;create local T object from params...  //伪代码...&#125;</code></pre><p>在伪代码中有两种选择：</p><pre><code>T localObject(std::forward&lt;Ts&gt;(params)...);    // 使用圆括号T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;;    // 使用大括号</code></pre><p>然后考虑以下代码：</p><pre><code>std::vector&lt;int&gt; v;...doSomeWork&lt;std::vector&lt;int&gt;&gt;(10,20);</code></pre><p>如果doSomeWork使用的是圆括号的方式创建对象，那么局部对象std::vector有10个元素。如果doSomeWork使用的是大括号的方式创建对象，那么局部对象std::vector只有2个元素。</p><blockquote><p>容器怎么实现的大列表初始化呢</p></blockquote><p>容器需要实现A(std::initializer_list<T> vecs)，void append(std::initializer_list<T> vecs)等接口；</T></T></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jthread</title>
      <link href="/p/324821f5.html"/>
      <url>/p/324821f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="jthread"><a href="#jthread" class="headerlink" title="jthread"></a>jthread</h1><p>C ++ 20中新引入的的新线程（jthread）功能修复了std::thread不是RAII类型的设计缺陷，并且增加了能够主动取消或停止线程执行的新特性。它基本上是一个包装器，它为线程带来了两个新功能：默认情况下，它们可以协同中断并加入。std::jthread对象包含std::thread一个成员，提供完全相同的公共函数，这些函数只是向下传递调用。<br>它拥有同 std::thread 的行为外，主要增加了以下两个功能：</p><ul><li>std::jthread 对象被 destruct 时，会自动调用 join，等待其所表示的执行流结束</li><li>支持外部请求中止（通过 get_stop_source、get_stop_token 和 request_stop ）</li></ul><h2 id="jthread声明"><a href="#jthread声明" class="headerlink" title="jthread声明"></a>jthread声明</h2><h3 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h3><table><thead><tr><th>成员类型</th><th>定义</th></tr></thead><tbody><tr><td>id</td><td>std::thread::id 类型</td></tr><tr><td>native_handle_type (可选)</td><td>std::thread::native_handle_type 类型（可选）</td></tr></tbody></table><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p><strong>构造函数</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>jthread()</td><td>创建一个空的 jthread 对象</td></tr><tr><td>jthread(Function)</td><td>创建一个 jthread 对象并启动线程</td></tr><tr><td>jthread(Function, Args…)</td><td>创建一个 jthread 对象并启动线程，传递参数</td></tr></tbody></table><p><strong>析构函数</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>~jthread()</td><td>如果 joinable() 为 true ，则调用 request_stop() 然后 join()；无论如何都会销毁 jthread 对象</td></tr></tbody></table><p><strong>operator&#x3D;</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>operator&#x3D;(jthread&amp;&amp;)</td><td>移动 jthread 对象</td></tr></tbody></table><p><strong>观察器</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>joinable()</td><td>检查线程是否可合并，即潜在地运行于平行环境中</td></tr><tr><td>get_id()</td><td>返回线程的 id</td></tr><tr><td>native_handle()</td><td>返回底层实现定义的线程句柄</td></tr><tr><td>hardware_concurrency() (静态)</td><td>返回实现支持的并发线程数</td></tr></tbody></table><p><strong>操作</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>join()</td><td>等待线程完成其执行</td></tr><tr><td>detach()</td><td>允许线程从线程句柄独立开来执行</td></tr><tr><td>swap()</td><td>交换两个 jthread 对象</td></tr></tbody></table><p><strong>停止记号处理</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>get_stop_source()</td><td>返回与线程的停止状态关联的 stop_source 对象</td></tr><tr><td>get_stop_token()</td><td>返回与线程的共享停止状态关联的 stop_token</td></tr><tr><td>request_stop()</td><td>请求执行经由线程的共享停止状态停止</td></tr></tbody></table><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p>| swap(std::jthread)(C++20)| 特化 std::swap 算法(函数)| </p><h2 id="std-thread的缺陷"><a href="#std-thread的缺陷" class="headerlink" title="std::thread的缺陷"></a>std::thread的缺陷</h2><p>当使用 std::thread 时，需要在线程对象的生命周期结束时调用 join() 或 detach() 函数。如果这两个函数都没有被调用，析构函数将立即导致程序异常终止并产生 core dump（程序异常终止或崩溃时，操作系统将程序的内存状态保存到一个特殊文件中，该文件称为核心转储文件）。下面是示例代码：</p><pre><code>void FuncWithoutJoinOrDetach() &#123;    std::thread t&#123;task, task_args&#125;;    // 没有调用 t.join() 或 t.detach()&#125;    // t 的生命周期结束时将调用 std::terminate()，异常终止程序</code></pre><p>即使我们调用了 join() 来等待正在运行的线程结束，仍然可能出现异常安全的问题：</p><pre><code>void FuncWithExceptionSafety() &#123;    // 启动线程执行 task    std::thread t&#123;task, task_args&#125;;    ... // 中间可能会发生异常，在异常时调用 std::terminate()    // 等待 task 执行结束    t.join();&#125;</code></pre><p>因此，需要使用 try-catch 来进行异常处理，确保异常发生后 join() 函数也能被正常调用：</p><pre><code>void FuncWithoutExceptionSafety() &#123;// 启动线程执行 taskstd::thread t&#123;task, task_args&#125;;    try &#123;        ...    &#125;     catch (...) &#123;        // 阻塞等待 t 运行结束        t.join();        // 重新抛出异常        throw;    &#125;    t.join();&#125;</code></pre><h2 id="std-jthread修复了std-thread不是RAII类型的设计缺陷"><a href="#std-jthread修复了std-thread不是RAII类型的设计缺陷" class="headerlink" title="std::jthread修复了std::thread不是RAII类型的设计缺陷"></a>std::jthread修复了std::thread不是RAII类型的设计缺陷</h2><p>jthread包装了std::thread，在析构函数中调用join()函数(jthread的j是joining的缩写)，修复了std::thread不是RAII类型的缺陷：</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;​int main(int argc, char* argv[])&#123;    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;​    std::thread thr&#123;        [] &#123; cout &lt;&lt; &quot;joinable std::thread&lt;&lt;&quot; &lt;&lt; std::endl; &#125;    &#125;;​    std::cout &lt;&lt; thr.joinable() &lt;&lt; std::endl;&#125;</code></pre><p>上述程序会报错，因为上述程序在main函数退出资源就要被释放，但是线程对象的析构函数被调用时，线程并没有被 join() 或 detach()。由于没有调用 join() 或 detach()，程序会抛出 std::terminate() 异常并终止。<br>在c++11中，为了解决这个问题，可以在主函数结束之前，调用 join() 或 detach() 来管理线程的生命周期。添加 thr.join() 或 thr.detach()，将线程加入主线程或分离线程，确保线程的正确结束。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int main(int argc, char* argv[])&#123;    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;    std::thread thr&#123;        [] &#123; cout &lt;&lt; &quot;joinable std::thread&lt;&lt;&quot; &lt;&lt; std::endl; &#125;    &#125;;    std::cout &lt;&lt; thr.joinable() &lt;&lt; std::endl;    thr.join(); // 或者使用 thr.detach()    return 0;&#125;</code></pre><p>上述程序可以正常运行，但是和new delete一样，每次都需要手动析构很可能造成资源泄露或者其他异常问题，c++20提供的jthread利用RAII特性，可以实现线程的自动分离。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;​int main(int argc, char* argv[])&#123;    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::endl;​    std::jthread thr&#123;        [] &#123; cout &lt;&lt; &quot;joinable std::thread&quot; &lt;&lt; std::endl; &#125;    &#125;;​    std::cout &lt;&lt; thr.joinable() &lt;&lt; std::endl;    return 0;&#125;</code></pre><h2 id="std-jthread增加了能够主动取消或停止线程执行的新特性"><a href="#std-jthread增加了能够主动取消或停止线程执行的新特性" class="headerlink" title="std::jthread增加了能够主动取消或停止线程执行的新特性"></a>std::jthread增加了能够主动取消或停止线程执行的新特性</h2><p>调用线程的join()函数后可能需要等待很长时间，甚至是永远等待。由于线程不像进程允许我们主动发送kill信号终止它，已经启动的线程只能自己结束运行或结束整个程序来结束该线程。因此，std::jthread除了提供std::stop_token能够主动取消或停止正在执行的线程，还增加了std::stop_callback允许在停止线程操作时调用一组回调函数。<br>例如如下代码将允许当前线程调用request_stop()之后，主动终止线程</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;using namespace std;int main(int argc, char *argv[]) &#123;    auto f = [](const stop_token &amp;st) &#123; // jthread负责传入stop_token        while (!st.stop_requested()) &#123; // jthread并不会强制停止线程，需要我们依据stop_token的状态来进行取消/停止操作            cout &lt;&lt; &quot;other: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;            this_thread::sleep_for(1s);        &#125;        cout &lt;&lt; &quot;other thread stopped!\n&quot;;    &#125;;    jthread jth(f);    cout &lt;&lt; &quot;main: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;    this_thread::sleep_for(5s);    jth.request_stop(); // 请求停止线程，对应的stop_token的stop_requested()函数返回true（注意，除了手动调用外，jthread销毁时也会自动调用该函数）    // 我们无需在jthread上调用join()，它在销毁时自动join&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/p/9423.html"/>
      <url>/p/9423.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>六大部件</strong></p><ul><li>分配器</li><li>容器</li><li>迭代器</li><li>算法</li><li>仿函数</li><li>适配器</li></ul><p><img src="/p/9423.htm/Components.png"></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>分为</p><ul><li>Sequence Containers<ul><li>Array</li><li>Vector</li><li>Deque</li><li>List</li><li>Forward-List</li></ul></li><li>Associative Containers<ul><li>Set&#x2F;Multiset</li><li>Map&#x2F;Multimap</li><li>Unordered Set&#x2F;Multiset</li><li>Unordered Map&#x2F;Multimap</li></ul></li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td></tr><tr><td><code>deque</code></td><td>双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</td></tr></tbody></table><ul><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forwa‘rd_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/p/58909.html"/>
      <url>/p/58909.html</url>
      
        <content type="html"><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string 一般并不被认为是一个 C++ 的容器。但其和容器有很多共同点。string 是模板 basic_string 对于 char 类型的特化，可以认为是一个只存放字符 char 类型数据的容器。“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。</p><h2 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>srting的本质是一个类，类内部封装了char* 管理这个字符串，是一个char*类型的容器</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>string()</li><li>string(const char*s)</li><li>string(const string&amp;str)</li><li>string(int n,char c)<ul><li>例如string s1(5,’a’);s1初始化为”aaaaa”</li></ul></li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul><li>string&amp; operator&#x3D;(const char*s)</li><li>string&amp; operator&#x3D;(const string &amp;s)</li><li>string&amp; operator&#x3D;(char c)</li><li>string&amp; assign(const char *s)</li><li>string&amp; assign(const char *s,int n)<ul><li>把字符串s前n个字符赋给当前字符串</li></ul></li><li>string&amp; assign(const string &amp;s)</li><li>string&amp; assign(int n,char c)</li></ul><h2 id="字符换拼接"><a href="#字符换拼接" class="headerlink" title="字符换拼接"></a>字符换拼接</h2><ul><li>string&amp; operator+&#x3D;(const char*str)</li><li>string&amp; operator+&#x3D;(const char c)</li><li>string&amp; operator+&#x3D;(const string &amp;str)</li><li>string&amp; append(const char *s)</li><li>string&amp; append(const char *s,int n)<ul><li>把字符串s前n个字符拼接到当前字符串</li></ul></li><li>string&amp; append(const string &amp;s)</li><li>string&amp; append(const string &amp;s,int pos,int n)<ul><li>字符串s从pos开始的n个字符拼接到当前字符串后面</li></ul></li></ul><h2 id="字符串查找和替换"><a href="#字符串查找和替换" class="headerlink" title="字符串查找和替换"></a>字符串查找和替换</h2><ul><li>int find(const string&amp; str, int pos &#x3D; 0) const;<ul><li>查找str第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos &#x3D; 0) const;<ul><li>查找s第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos, int n) const;<ul><li>从pos位置查找s的前n个字符第一次位置</li></ul></li><li>int find(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c第一次出现位置</li></ul></li><li>int rfind(const string&amp; str, int pos &#x3D; npos) const; <ul><li>查找str最后一次位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos &#x3D; npos) const; <ul><li>查找s最后一次出现位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos, int n) const; <ul><li>从pos查找s的前n个字符最后一次位置</li></ul></li><li>int rfind(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c最后一次出现位置</li></ul></li><li>string&amp; replace(int pos, int n, const string&amp; str);<ul><li>替换从pos开始n个字符替换为字符串str</li></ul></li><li>string&amp; replace(int pos, int n,const char* s);<ul><li>替换从pos开始的n个字符替换为字符串s</li></ul></li></ul><p><strong>查找失败返回-1</strong></p><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>按照ASCLL 码比较</p><ul><li>‘&#x3D;’ 返回0</li><li>‘&gt;’ 返回1</li><li>‘&lt; ‘返回-1</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul><li><p>int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较</p></li><li><p>int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较</p></li></ul><h2 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h2><h3 id="string中单个字符存取方式有两种"><a href="#string中单个字符存取方式有两种" class="headerlink" title="string中单个字符存取方式有两种"></a>string中单个字符存取方式有两种</h3><ul><li>char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符</li><li>char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符</li></ul><p>可以利用size()函数获取string大小进行遍历</p><h3 id="string中字串存取方式"><a href="#string中字串存取方式" class="headerlink" title="string中字串存取方式"></a>string中字串存取方式</h3><ul><li>string substr(int pos &#x3D; 0, int n &#x3D; npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li></ul><p>中文两字节代表一个汉字,所以截取第一个汉字substr(0,2);</p><h2 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h2><ul><li><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c</p></li><li><p>string&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/p/54708.html"/>
      <url>/p/54708.html</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 ArrayList 和 Python 的 list。现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，vector 的连续内存使用是它的一大优势所在。vector 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector与普通数组区别：</strong><br>1.不同之处在于数组是静态空间，而vector可以动态扩展。</p><pre><code>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</code></pre><p>2.vector容器的迭代器是支持随机访问的迭代器</p><h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><ul><li>vector<T> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</T></li><li>vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li><li>vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。</li></ul><p>总结：vector的多种构造方式没有可比性，灵活使用即可</p><h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><ul><li>vector&amp; operator&#x3D;(const vector &amp;vec);&#x2F;&#x2F;重载等号操作</li><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;    vector&lt;int&gt; v1; //无参构造    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    v2 = v1;    printVector(v2);    vector&lt;int&gt;v3;    v3.assign(v1.begin(), v1.end());    printVector(v3);    vector&lt;int&gt;v4;    v4.assign( 10 , 100 );    printVector(v4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p><h2 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h2><ul><li><p>empty(); &#x2F;&#x2F;判断容器是否为空</p></li><li><p>capacity(); &#x2F;&#x2F;容器的容量</p></li><li><p>size(); &#x2F;&#x2F;返回容器中元素的个数</p></li><li><p>resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li><p>resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    if (v1.empty())    &#123;        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;    &#125;    //resize 重新指定大小 ，若指定的更大，默认用 0 填充新位置，可以利用重载版本替换默认填充    v1.resize( 15 , 10 );    printVector(v1);    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除    v1.resize( 5 );    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><ul><li>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</li><li>pop_back(); &#x2F;&#x2F;删除最后一个元素</li><li>insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li>insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li>erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素</li><li>erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li>clear(); &#x2F;&#x2F;删除容器中所有元素</li></ul><p><strong>示例</strong>：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    vector&lt;int&gt; v1;    //尾插    v1.push_back( 10 );    v1.push_back( 20 );    v1.push_back( 30 );    v1.push_back( 40 );    v1.push_back( 50 );    printVector(v1);    //尾删    v1.pop_back();    printVector(v1);    //插入    v1.insert(v1.begin(), 100 );    printVector(v1);    v1.insert(v1.begin(), 2 , 1000 );    printVector(v1);    //删除    v1.erase(v1.begin());    printVector(v1);    //清空    v1.erase(v1.begin(), v1.end());    v1.clear();    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h2><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><ul><li>swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    for (int i = 10 ; i &gt; 0 ; i--)    &#123;        v2.push_back(i);    &#125;    printVector(v2);    //互换容器    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;    v1.swap(v2);    printVector(v1);    printVector(v2);&#125;void test02()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;    v.resize( 3 );    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;//大小变为3    //收缩内存    vector&lt;int&gt;(v).swap(v); //匿名对象下一行自动回收    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><ul><li>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    //预留空间    v.reserve( 100000 );    int num = 0 ;    int* p = NULL;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);        if (p != &amp;v[ 0 ]) &#123;            p = &amp;v[ 0 ];            num++;    &#125;&#125;cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set/multiset</title>
      <link href="/p/22700.html"/>
      <url>/p/22700.html</url>
      
        <content type="html"><![CDATA[<h1 id="set-x2F-multiset-容器"><a href="#set-x2F-multiset-容器" class="headerlink" title="set&#x2F; multiset 容器"></a>set&#x2F; multiset 容器</h1><h2 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>所有元素都会在插入时自动被排序</p><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><p>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</p><h3 id="set和multiset区别："><a href="#set和multiset区别：" class="headerlink" title="set和multiset区别："></a>set和multiset区别：</h3><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h2 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>set<T> st; &#x2F;&#x2F;默认构造函数：</T></p></li><li><p>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;        cout &lt;&lt; endl;    &#125;&#125;//构造和赋值void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //拷贝构造    set&lt;int&gt;s2(s1);    printSet(s2);    //赋值    set&lt;int&gt;s3;    s3 = s2;    printSet(s3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h2 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    if (s1.empty())    &#123;        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;    &#125;&#125;//交换void test02()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    set&lt;int&gt; s2;    s2.insert( 100 );    s2.insert( 300 );    s2.insert( 200 );    s2.insert( 400 );    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printSet(s1);    printSet(s2);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    s1.swap(s2);    printSet(s1);    printSet(s2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //删除    s1.erase(s1.begin());    printSet(s1);    s1.erase( 30 );    printSet(s1);    //清空    //s1.erase(s1.begin(), s1.end());    s1.clear();    printSet(s1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h2><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    //查找    set&lt;int&gt;::iterator pos = s1.find( 30 );    if (pos != s1.end())    &#123;        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = s1.count( 30 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;//set和multiset区别void test01()&#123;    set&lt;int&gt; s;    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        pair&lt;type, type&gt; p ( value1, value2 );        pair&lt;type, type&gt; p = make_pair( value1, value2 );        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;    &#125;    ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;    &#125;    //multiset    multiset&lt;int&gt; ms;    ms.insert( 10 );    ms.insert( 10 );    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h2 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h2><h5 id="两种创建方式："><a href="#两种创建方式：" class="headerlink" title="两种创建方式："></a>两种创建方式：</h5><pre><code>#include &lt;string&gt;//对组创建void test01()&#123;    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h2><h3 id="示例一-set存放内置数据类型"><a href="#示例一-set存放内置数据类型" class="headerlink" title="示例一 set存放内置数据类型"></a>示例一 set存放内置数据类型</h3><pre><code>#include &lt;set&gt;class MyCompare&#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 40 );    s1.insert( 20 );    s1.insert( 30 );    s1.insert( 50 );    //默认从小到大    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //指定排序规则    set&lt;int,MyCompare&gt; s2;    s2.insert( 10 );    s2.insert( 40 );    s2.insert( 20 );    s2.insert( 30 );    s2.insert( 50 );    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用仿函数可以指定set容器的排序规则"><a href="#总结：利用仿函数可以指定set容器的排序规则" class="headerlink" title="总结：利用仿函数可以指定set容器的排序规则"></a>总结：利用仿函数可以指定set容器的排序规则</h5><h3 id="示例二-set存放自定义数据类型"><a href="#示例二-set存放自定义数据类型" class="headerlink" title="示例二 set存放自定义数据类型"></a>示例二 set存放自定义数据类型</h3><pre><code>#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class comparePerson&#123;public:    bool operator()(const Person&amp; p1, const Person &amp;p2)    &#123;        //按照年龄进行排序 降序        return p1.m_Age &gt; p2.m_Age;    &#125;&#125;;void test01()&#123;    set&lt;Person, comparePerson&gt; s;    Person p1(&quot;刘备&quot;, 23 );    Person p2(&quot;关羽&quot;, 27 );    Person p3(&quot;张飞&quot;, 25 );    Person p4(&quot;赵云&quot;, 21 );    s.insert(p1);    s.insert(p2);    s.insert(p3);    s.insert(p4);    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>对于自定义数据类型，set必须指定排序规则才可以插入数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack</title>
      <link href="/p/64038.html"/>
      <url>/p/64038.html</url>
      
        <content type="html"><![CDATA[<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h2 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h2><p>概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口.栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><ul><li><p>栈中进入数据称为 — 入栈 push</p></li><li><p>栈中弹出数据称为 — 出栈 pop</p></li></ul><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>stack<T> stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</T></p></li><li><p>stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;向栈顶添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从栈顶移除第一个元素</p></li><li><p>top(); &#x2F;&#x2F;返回栈顶元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;stack&gt;void test01()&#123;    stack&lt;int&gt; s;    //向栈中添加元素，叫做 压栈 入栈    s.push( 10 );    s.push( 20 );    s.push( 30 );    while (!s.empty()) &#123;        //输出栈顶元素        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;        //弹出栈顶元素        s.pop();    &#125;    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue</title>
      <link href="/p/41872.html"/>
      <url>/p/41872.html</url>
      
        <content type="html"><![CDATA[<h1 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h1><h2 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h2><p>概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口<br>创建栈容器 栈容器必须符合先进后出<br>队列容器允许从一端新增元素，从另一端移除元素<br>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><ul><li><p>队列中进数据称为 — 入队 push</p></li><li><p>队列中出数据称为 — 出队 pop</p></li></ul><h2 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>queue<T> que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</T></p></li><li><p>queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;往队尾添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从队头移除第一个元素</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素</p></li><li><p>front(); &#x2F;&#x2F;返回第一个元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;void test01() &#123;    //创建队列    queue&lt;Person&gt; q;    //准备数据    Person p1(&quot;唐僧&quot;, 30 );    Person p2(&quot;孙悟空&quot;, 1000 );    Person p3(&quot;猪八戒&quot;, 900 );    Person p4(&quot;沙僧&quot;, 800 );    q.push(p1);    q.push(p2);    q.push(p3);    q.push(p4);    //队列不提供迭代器，更不支持随机访问    while (!q.empty()) &#123;        //输出队头元素        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name        &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name        &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        cout &lt;&lt; endl;        //弹出队头元素        q.pop();    &#125;    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map/multimap</title>
      <link href="/p/37043.html"/>
      <url>/p/37043.html</url>
      
        <content type="html"><![CDATA[<h1 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h1><h2 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h2><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><ul><li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>可以根据key值快速找到value值</li></ul><h4 id="map和multimap区别："><a href="#map和multimap区别：" class="headerlink" title="map和multimap区别："></a>map和multimap区别：</h4><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h2 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数:</p></li><li><p>map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int,int&gt;m; //默认构造    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    printMap(m);    map&lt;int, int&gt;m2(m); //拷贝构造    printMap(m2);    map&lt;int, int&gt;m3;    m3 = m2; //赋值    printMap(m3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h2 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    if (m.empty())    &#123;        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;    &#125;&#125;void test02()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    map&lt;int, int&gt;m2;    m2.insert(pair&lt;int, int&gt;( 4 , 100 ));    m2.insert(pair&lt;int, int&gt;( 5 , 200 ));    m2.insert(pair&lt;int, int&gt;( 6 , 300 ));    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printMap(m);    printMap(m2);    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    m.swap(m2);    printMap(m);    printMap(m2);&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h2><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    //插入    map&lt;int, int&gt; m;    //第一种插入方式    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    //第二种插入方式    m.insert(make_pair( 2 , 20 ));    //第三种插入方式    m.insert(map&lt;int, int&gt;::value_type( 3 , 30 ));    //第四种插入方式    m[ 4 ] = 40 ;    printMap(m);    //删除    m.erase(m.begin());    printMap(m);    m.erase( 3 );    printMap(m);    //清空    m.erase(m.begin(),m.end());    m.clear();    printMap(m);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    //查找    map&lt;int, int&gt;::iterator pos = m.find( 3 );    if (pos != m.end())    &#123;        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = m.count( 3 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h2><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;class MyCompare &#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    //默认从小到大排序    //利用仿函数实现从大到小排序    map&lt;int, int, MyCompare&gt; m;    m.insert(make_pair( 1 , 10 ));    m.insert(make_pair( 2 , 20 ));    m.insert(make_pair( 3 , 30 ));    m.insert(make_pair( 4 , 40 ));    m.insert(make_pair( 5 , 50 ));    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例-员工分组"></a>案例-员工分组</h3><h4 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h4><p>公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作<br>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发<br>随机给 10 名员工分配部门和工资<br>通过multimap进行信息的插入 key(部门编号) value(员工)<br>分部门显示员工信息</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>创建 10 名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><h5 id="案例代码："><a href="#案例代码：" class="headerlink" title="案例代码："></a>案例代码：</h5><pre><code>#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给 10 名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA 0#define MEISHU 1#define YANFA 2class Worker&#123;public:    string m_Name;    int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;    string nameSeed = &quot;ABCDEFGHIJ&quot;;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        Worker worker;        worker.m_Name = &quot;员工&quot;;        worker.m_Name += nameSeed[i];        worker.m_Salary = rand() % 10000 + 10000 ; // 10000 ~ 19999        //将员工放入到容器中        v.push_back(worker);    &#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        //产生随机部门编号        int deptId = rand() % 3 ; // 0 1 2        //将员工插入到分组中        //key部门编号，value具体员工        m.insert(make_pair(deptId, *it));    &#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);    int count = m.count(CEHUA); // 统计具体人数    int index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;    pos = m.find(MEISHU);    count = m.count(MEISHU); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;    pos = m.find(YANFA);    count = m.count(YANFA); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;&#125;int main() &#123;    srand((unsigned int)time(NULL));    //1、创建员工    vector&lt;Worker&gt;vWorker;    createWorker(vWorker);    //2、员工分组    multimap&lt;int, Worker&gt;mWorker;    setGroup(vWorker, mWorker);    showWorkerByGourp(mWorker);    ////测试    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)    //&#123;    // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/p/39907.html"/>
      <url>/p/39907.html</url>
      
        <content type="html"><![CDATA[<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><p>list 在 C++ 里代表双向链表。和 vector 相比，它优化了在容器中间的插入和删除</p><h2 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h2><p><img src="https://s1.ax1x.com/2023/07/15/pC5oIAI.png" alt="pC5oIAI.png"><br>功能：将数据进行链式存储<br>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列结点组成<br>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p><strong>list的优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点：</strong></p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</T></li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    list&lt;int&gt;L2(L1.begin(),L1.end());    printList(L2);    list&lt;int&gt;L3(L2);    printList(L3);    list&lt;int&gt;L4( 10 , 1000 );    printList(L4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h2><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    //赋值    list&lt;int&gt;L2;    L2 = L1;    printList(L2);    list&lt;int&gt;L3;    L3.assign(L2.begin(), L2.end());    printList(L3);    list&lt;int&gt;L4;    L4.assign( 10 , 100 );    printList(L4);&#125;//交换void test02()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    list&lt;int&gt;L2;    L2.assign( 10 , 100 );    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);    cout &lt;&lt; endl;    L1.swap(L2);    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    if (L1.empty())    &#123;        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;    &#125;    //重新指定大小    L1.resize( 10 );    printList(L1);    L1.resize( 2 );    printList(L1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h2><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;//插入和删除void test01()&#123;    list&lt;int&gt; L;    //尾插    L.push_back( 10 );    L.push_back( 20 );    L.push_back( 30 );    //头插    L.push_front( 100 );    L.push_front( 200 );    L.push_front( 300 );    printList(L);    //尾删    L.pop_back();    printList(L);    //头删    L.pop_front();    printList(L);    //插入    list&lt;int&gt;::iterator it = L.begin();    L.insert(++it, 1000 );    printList(L);    //删除    it = L.begin();    L.erase(++it);    printList(L);    L.push_back( 10000 );    L.push_back( 10000 );    L.push_back( 10000 );    printList(L);    L.remove( 10000 );    printList(L);    //清空    L.clear();    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h2><ul><li><p>front(); &#x2F;&#x2F;返回第一个元素。</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素。</p></li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;//数据存取void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;    //list容器的迭代器是双向迭代器，不支持随机访问    list&lt;int&gt;::iterator it = L1.begin();    //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：list容器中不可以通过[]或者at方式访问数据</p><ul><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h2 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h2><ul><li><p>reverse(); &#x2F;&#x2F;反转链表</p></li><li><p>sort(); &#x2F;&#x2F;链表排序</p></li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;    return val1 &gt; val2;&#125;//反转和排序void test01()&#123;    list&lt;int&gt; L;    L.push_back( 90 );    L.push_back( 30 );    L.push_back( 20 );    L.push_back( 70 );    printList(L);    //反转容器的元素    L.reverse();    printList(L);    //排序    L.sort(); //默认的排序规则 从小到大    printList(L);    L.sort(myCompare); //指定规则，从大到小    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h3><h4 id="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"><a href="#案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高" class="headerlink" title="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"></a>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</h4><h4 id="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"><a href="#排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序" class="headerlink" title="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"></a>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</h4><h5 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:    Person(string name, int age , int height) &#123;        m_Name = name;        m_Age = age;        m_Height = height;    &#125;public:    string m_Name; //姓名    int m_Age; //年龄    int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    else    &#123;        return p1.m_Age &lt; p2.m_Age;    &#125;&#125;void test01() &#123;    list&lt;Person&gt; L;    Person p1(&quot;刘备&quot;, 35 , 175 );    Person p2(&quot;曹操&quot;, 45 , 180 );    Person p3(&quot;孙权&quot;, 40 , 170 );    Person p4(&quot;赵云&quot;, 25 , 190 );    Person p5(&quot;张飞&quot;, 35 , 160 );    Person p6(&quot;关羽&quot;, 35 , 200 );    L.push_back(p1);    L.push_back(p2);    L.push_back(p3);    L.push_back(p4);    L.push_back(p5);    L.push_back(p6);    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;    L.sort(ComparePerson); //排序    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="/p/31381.html"/>
      <url>/p/31381.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h1><p>算法主要是由头文件algorithm functional numeric组成。</p><ul><li>algorithm是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历、操作、复制、修改等等</li><li>numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li>functional定义了一些模板类,用以声明函数对象。</li></ul><h2 id="遍历算法for-each"><a href="#遍历算法for-each" class="headerlink" title="遍历算法for_each"></a>遍历算法for_each</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>for_each(iterator beg, iterator end, _func);</code></pre><ul><li>遍历算法 遍历容器元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;//for_each算法基本用法void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //遍历算法    for_each(v.begin(), v.end(), print01);    cout &lt;&lt; endl;    for_each(v.begin(), v.end(), print02());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握"><a href="#总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握" class="headerlink" title="总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握"></a>总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握</h3><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul><li>搬运容器到另一个容器中</li></ul><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></pre><ul><li>beg1 源容器开始迭代器</li><li>end1 源容器结束迭代器</li><li>beg2 目标容器开始迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public:    int operator()(int val)    &#123;        return val;    &#125;&#125;class MyPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;vTarget; //目标容器    vTarget.resize(v.size()); // 目标容器需要提前开辟空间    transform(v.begin(), v.end(), vTarget.begin(), TransForm());    for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运"><a href="#总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运" class="headerlink" title="总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运"></a>总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</h3><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find(iterator beg, iterator end, value);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    //查找容器中是否有 5 这个元素    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5 );    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;class Person &#123;public:    Person(string name, int age)    this-&gt;m_Name = name;    this-&gt;m_Age = age;&#125;//重载==，否则自定义数据类型无法运行findbool operator==(const Person&amp; p)&#123;    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)    &#123;        return true;    &#125;    return false;&#125;public:    string m_Name;    int m_Age;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：-利用find可以在容器中找指定的元素，返回值是迭代器"><a href="#总结：-利用find可以在容器中找指定的元素，返回值是迭代器" class="headerlink" title="总结： 利用find可以在容器中找指定的元素，返回值是迭代器"></a>总结： 利用find可以在容器中找指定的元素，返回值是迭代器</h3><h2 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 函数或者谓词（返回bool类型的仿函数）</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public:    bool operator()(int val)    &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到大于 5 的数字:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;//自定义数据类型class Person &#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;public:    string m_Name;    int m_Age;&#125;;class Greater20&#123;public:    bool operator()(Person &amp;p)    &#123;        return p.m_Age &gt; 20 ;    &#125;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"><a href="#总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略" class="headerlink" title="总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"></a>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</h3><h2 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h2><h3 id="查找相邻重复元素"><a href="#查找相邻重复元素" class="headerlink" title="查找相邻重复元素"></a>查找相邻重复元素</h3><h3 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>adjacent_find(iterator beg, iterator end);</code></pre><ul><li>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 5 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 4 );    v.push_back( 3 );    //查找相邻重复元素    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法"><a href="#总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法" class="headerlink" title="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法"></a>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</h3><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h2><p>查找指定元素是否存在，返回值是bool类型</p><h3 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>bool binary_search(iterator beg, iterator end, value);</code></pre><ul><li>查找指定的元素，查到 返回true 否则false</li><li>注意: 在无序序列中不可用</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //二分查找    bool ret = binary_search(v.begin(), v.end(), 2 );    if (ret)    &#123;        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;    &#125;    else        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"><a href="#总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列" class="headerlink" title="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"></a>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</h3><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><h3 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h3><h3 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count(iterator beg, iterator end, value);</code></pre><ul><li>统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 统计的元素</li></ul><h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );       v.push_back( 4 );    v.push_back( 4 );    int num = count(v.begin(), v.end(), 4 );    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    bool operator==(const Person &amp; p)    &#123;        if (this-&gt;m_Age == p.m_Age)        &#123;            return true;        &#125;        else        &#123;            return false;        &#125;    &#125;    string m_Name;    int m_Age;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    Person p(&quot;诸葛亮&quot;, 35 );    int num = count(v.begin(), v.end(), p);    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D"><a href="#总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D" class="headerlink" title="总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;"></a>总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;</h5><h2 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h2><h3 id="函数原型：-7"><a href="#函数原型：-7" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按条件统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 4 ;    &#125;&#125;;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );    v.push_back( 4 );    v.push_back( 4 );    int num = count_if(v.begin(), v.end(), Greater4());    cout &lt;&lt; &quot;大于 4 的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class AgeLess35&#123;public:    bool operator()(const Person &amp;p)    &#123;        return p.m_Age &lt; 35 ;    &#125;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    int num = count_if(v.begin(), v.end(), AgeLess35());    cout &lt;&lt; &quot;小于 35 岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：按值统计用count，按条件统计用count-if"><a href="#总结：按值统计用count，按条件统计用count-if" class="headerlink" title="总结：按值统计用count，按条件统计用count_if"></a>总结：按值统计用count，按条件统计用count_if</h3>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合算法</title>
      <link href="/p/35802.html"/>
      <url>/p/35802.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h1><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>set_intersection &#x2F;&#x2F; 求两个容器的交集</li><li>set_union &#x2F;&#x2F; 求两个容器的并集</li><li>set_difference &#x2F;&#x2F; 求两个容器的差集</li></ul><h2 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h2><ul><li>求两个容器的交集</li></ul><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的交集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器</li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较小的值给目标容器开辟空间    vTarget.resize(min(v1.size(), v2.size()));    vector&lt;int&gt;::iterator itEnd =    set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器中取小值</li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h2 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h2><h5 id="求两个集合的并集"><a href="#求两个集合的并集" class="headerlink" title="求两个集合的并集"></a>求两个集合的并集</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的并集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li><li>返回目标容器的最后一个元素的迭代器地址</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个容器的和给目标容器开辟空间    vTarget.resize(v1.size() + v2.size());    //返回目标容器的最后一个元素的迭代器地址    vector&lt;int&gt;::iterator itEnd =    set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要两个容器相加</li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h2 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h2><h5 id="求两个集合的差集"><a href="#求两个集合的差集" class="headerlink" title="求两个集合的差集"></a>求两个集合的差集</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的差集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 &#x2F;&#x2F; </li><li>end1 容器 1 结束迭代器 &#x2F;&#x2F; </li><li>beg2 容器 2 开始迭代器 &#x2F;&#x2F; </li><li>end2 容器 2 结束迭代器 &#x2F;&#x2F;</li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较大的值给目标容器开辟空间    vTarget.resize( max(v1.size() , v2.size()));    //返回目标容器的最后一个元素的迭代器地址    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;    vector&lt;int&gt;::iterator itEnd =    set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器取较大值</li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算术生成算法</title>
      <link href="/p/41195.html"/>
      <url>/p/41195.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h1><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric></numeric></li></ul><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>accumulate &#x2F;&#x2F; 计算容器元素累计总和</li><li>fill &#x2F;&#x2F; 向容器中添加元素</li></ul><h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><h5 id="计算区间内-容器元素累计总和"><a href="#计算区间内-容器元素累计总和" class="headerlink" title="计算区间内 容器元素累计总和"></a>计算区间内 容器元素累计总和</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>accumulate(iterator beg, iterator end, value);</code></pre><ul><li>计算容器元素累计总和</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 起始值</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt;= 100 ; i++) &#123;        v.push_back(i);    &#125;    int total = accumulate(v.begin(), v.end(), 0 );    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：accumulate使用时头文件注意是-numeric，这个算法很实用"><a href="#总结：accumulate使用时头文件注意是-numeric，这个算法很实用" class="headerlink" title="总结：accumulate使用时头文件注意是 numeric，这个算法很实用"></a>总结：accumulate使用时头文件注意是 numeric，这个算法很实用</h5><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><ul><li>向容器中填充指定的元素</li></ul><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>fill(iterator beg, iterator end, value);</code></pre><ul><li>向容器中填充元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 填充的值</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.resize( 10 );    //填充    fill(v.begin(), v.end(), 100 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用fill可以将容器区间内元素填充为-指定的值"><a href="#总结：利用fill可以将容器区间内元素填充为-指定的值" class="headerlink" title="总结：利用fill可以将容器区间内元素填充为 指定的值"></a>总结：利用fill可以将容器区间内元素填充为 指定的值</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/p/29759.html"/>
      <url>/p/29759.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><h2 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h2><pre><code>+ sort //对容器内元素进行排序+ random_shuffle //洗牌 指定范围内的元素随机调整次序+ merge // 容器元素合并，并存储到另一容器中+ reverse // 反转指定范围的元素</code></pre><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h2><p>顾名思义，binary_search就是在已经排好序的区间里执行二分查找。但它只返回一个 bool 值，告知元素是否存在，而更多的时候，我们是想定位到那个元素，所以 binary_search 几乎没什么用。</p><pre><code>vector&lt;int&gt; v = &#123;3, 5, 1, 7, 10, 99, 42&#125;; // Vector containerstd::sort(begin(v), end(v)); // Quick sortauto found = binary_search( // Binary search, can only determine if the element is present or not    cbegin(v), cend(v), 7);</code></pre><p>想要在已序容器上执行二分查找，要用到一个名字比较怪的算法：lower_bound，它返回第一个“大于或等于”值的位置：</p><pre><code>decltype(cend(v)) pos; // Declare an iterator using decltypepos = std::lower_bound( // Find the first position &gt;= 7    cbegin(v), cend(v), 7);bool found = (pos != cend(v)) &amp;&amp; (*pos == 7); // It may not be found, so it must be checkedassert(found); // 7 is in the containerpos = std::lower_bound( // Find the first position &gt;= 9    cbegin(v), cend(v), 9);found = (pos != cend(v)) &amp;&amp; (*pos == 9); // It may not be found, so it must be checkedassert(!found); // 9 is not in the container</code></pre><p>lower_bound 的返回值是一个迭代器，所以就要做一点判断工作，才能知道是否真的找到了。判断的条件有两个，一个是迭代器是否有效，另一个是迭代器的值是不是要找的值。<br>注意 lower_bound 的查找条件是“大于等于”，而不是“等于”，所以它的真正含义是“大于等于值的第一个位置”。相应的也就有“大于等于值的最后一个位置”，算法叫upper_bound，返回的是第一个“大于”值的元素<br>它俩的返回值构成一个区间，这个区间往前就是所有比被查找值小的元素，往后就是所有比被查找值大的元素，可以写成一个简单的不等式：</p><pre><code>begin &lt; x &lt;= lower_bound &lt; upper_bound &lt; end</code></pre><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>sort(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;vector&lt;int&gt; v;v.push_back( 10 );v.push_back( 30 );v.push_back( 50 );v.push_back( 20 );v.push_back( 40 );//sort默认从小到大排序sort(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint);cout &lt;&lt; endl;//从大到小排序sort(v.begin(), v.end(), greater&lt;int&gt;());for_each(v.begin(), v.end(), myPrint);    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>random_shuffle(iterator beg, iterator end);</code></pre><ul><li>指定范围内的元素随机调整次序</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    srand((unsigned int)time(NULL));    vector&lt;int&gt; v;    for(int i = 0 ; i &lt; 10 ;i++)    &#123;        v.push_back(i);    &#125;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //打乱顺序    random_shuffle(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>容器元素合并，并存储到另一容器中</li><li>注意: 两个容器必须是有序的</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i + 1 );    &#125;    vector&lt;int&gt; vtarget;    //目标容器需要提前开辟空间    vtarget.resize(v1.size() + v2.size());    //合并 需要两个有序序列    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());    for_each(vtarget.begin(), vtarget.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：merge合并的两个容器必须的有序序列</p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="将容器内元素进行反转"><a href="#将容器内元素进行反转" class="headerlink" title="将容器内元素进行反转"></a>将容器内元素进行反转</h3><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>reverse(iterator beg, iterator end);</code></pre><ul><li>反转指定范围的元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 20 );    v.push_back( 40 );    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;    reverse(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：reverse反转区间内元素，面试题可能涉及到</p><h2 id="其他常用算法"><a href="#其他常用算法" class="headerlink" title="其他常用算法"></a>其他常用算法</h2><ul><li>要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的；</li><li>选出前几名（TopN），应该用 partial_sort；</li><li>选出前几名，但不要求再排出名次（BestN），应该用 nth_element；</li><li>中位数（Median）、百分位数（Percentile），还是用 nth_element；</li><li>按照某种规则把元素划分成两组，用 partition；</li><li>第一名和最后一名，用 minmax_element。</li></ul><ol><li><p>在前三名中进行部分排序：</p><pre><code class="cpp">std::partial_sort(begin(v), next(begin(v), 3), end(v));</code></pre><p>这行代码将向量 <code>v</code> 的前三个元素按升序排列，其余元素的顺序不变。</p></li><li><p>找出最好的三个元素：</p><pre><code class="cpp">std::nth_element(begin(v), next(begin(v), 3), end(v));</code></pre><p>这行代码通过重新排列向量 <code>v</code> 的元素，将第三个位置放置在排序后的位置，这样前三个元素将是最好的三个元素，但它们的顺序不一定是按升序排列的。</p></li><li><p>计算中位数：</p><pre><code class="cpp">auto mid_iter = next(begin(v), v.size()/2);std::nth_element(begin(v), mid_iter, end(v));cout &lt;&lt; &quot;median is &quot; &lt;&lt; *mid_iter &lt;&lt; endl;</code></pre><p>这段代码首先找到中位数的位置，然后通过重新排列向量 <code>v</code> 的元素，将中位数放置在正确的位置上。最后，中位数将被打印出来。</p></li><li><p>对大于 9 的数进行分组：</p><pre><code class="cpp">auto pos = std::partition(begin(v), end(v), [](const auto&amp; x) &#123;    return x &gt; 9;&#125;);for_each(begin(v), pos, print);</code></pre><p>这段代码使用 <code>std::partition</code> 函数将向量 <code>v</code> 中大于 9 的元素移动到前面，小于等于 9 的元素移动到后面。然后，将大于 9 的元素打印出来。</p></li><li><p>找出最小值和最大值：</p><pre><code class="cpp">auto value = std::minmax_element(cbegin(v), cend(v));</code></pre><p>这行代码使用 <code>std::minmax_element</code> 函数找出向量 <code>v</code> 中的最小值和最大值，并将其作为一个范围返回。</p></li></ol><p>请注意，上述代码中可能存在一些错误，例如未定义 <code>print</code> 函数和使用 <code>cbegin</code> 和 <code>cend</code> 来获取常量迭代器。这些问题需要在上下文中进行修复。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用拷贝和替换算法</title>
      <link href="/p/20982.html"/>
      <url>/p/20982.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h1><ul><li>copy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li>replace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li>replace_if &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li><li>swap &#x2F;&#x2F; 互换两个容器的元素</li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><h5 id="容器内指定范围的元素拷贝到另一容器中"><a href="#容器内指定范围的元素拷贝到另一容器中" class="headerlink" title="容器内指定范围的元素拷贝到另一容器中"></a>容器内指定范围的元素拷贝到另一容器中</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>copy(iterator beg, iterator end, iterator dest);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>dest 目标起始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i + 1 );    &#125;    vector&lt;int&gt; v2;    //分配大小    v2.resize(v1.size());    copy(v1.begin(), v1.end(), v2.begin());    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"><a href="#总结：利用copy算法在拷贝时，目标容器记得提前开辟空间" class="headerlink" title="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"></a>总结：利用copy算法在拷贝时，目标容器记得提前开辟空间</h5><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><h5 id="将容器内指定范围的旧元素修改为新元素"><a href="#将容器内指定范围的旧元素修改为新元素" class="headerlink" title="将容器内指定范围的旧元素修改为新元素"></a>将容器内指定范围的旧元素修改为新元素</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></pre><ul><li>将区间内旧元素 替换成 新元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>oldvalue 旧元素</li><li>newvalue 新元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //将容器中的 20 替换成 2000    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace(v.begin(), v.end(), 20 , 2000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace会替换区间内满足条件的元素"><a href="#总结：replace会替换区间内满足条件的元素" class="headerlink" title="总结：replace会替换区间内满足条件的元素"></a>总结：replace会替换区间内满足条件的元素</h5><h2 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h2><h5 id="将区间内满足条件的元素，替换成指定元素"><a href="#将区间内满足条件的元素，替换成指定元素" class="headerlink" title="将区间内满足条件的元素，替换成指定元素"></a>将区间内满足条件的元素，替换成指定元素</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></pre><ul><li>按条件替换元素，满足条件的替换成指定元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_pred 谓词</li><li>newvalue 替换的新元素</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;class ReplaceGreater30&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 30 ;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件"><a href="#总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件" class="headerlink" title="总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件"></a>总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</h5><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><h5 id="互换两个容器的元素"><a href="#互换两个容器的元素" class="headerlink" title="互换两个容器的元素"></a>互换两个容器的元素</h5><h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>swap(container c1, container c2);</code></pre><ul><li>互换两个容器的元素</li><li>c1容器 1</li><li>c2容器 2</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 100 );    &#125;    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    swap(v1, v2);    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：swap交换容器时，注意交换的容器要同种类型"><a href="#总结：swap交换容器时，注意交换的容器要同种类型" class="headerlink" title="总结：swap交换容器时，注意交换的容器要同种类型"></a>总结：swap交换容器时，注意交换的容器要同种类型</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque</title>
      <link href="/p/42201.html"/>
      <url>/p/42201.html</url>
      
        <content type="html"><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h2><blockquote><p>双端数组，可以对头端进行插入删除操作</p></blockquote><p>deque 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</p><h3 id="deque与vector区别："><a href="#deque与vector区别：" class="headerlink" title="deque与vector区别："></a>deque与vector区别：</h3><p>1.vector对于头部的插入删除效率低，数据量越大，效率越低deque相对而言，对头部的插入删除速度回比vector快</p><p>2.vector访问元素时的速度会比deque快,这和两者内部实现有关</p><h3 id="deque内部工作原理"><a href="#deque内部工作原理" class="headerlink" title="deque内部工作原理:"></a>deque内部工作原理:</h3><p><img src="https://s1.ax1x.com/2023/07/15/pC5oc9K.png" alt="pC5oc9K.png"><br>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间<br>deque容器的迭代器也是支持随机访问的<br>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。由于每一段存储大小相等，deque 支持使用下标访问容器元素，大致相当于 index[i&#x2F; chunk_size][i % chunk_size]，也保持高效。</p><h2 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h2><ul><li>deque<T> deqT; &#x2F;&#x2F;默认构造形式</T></li><li>deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//deque构造void test01() &#123;    deque&lt;int&gt; d1; //无参构造函数    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt; d2(d1.begin(),d1.end());    printDeque(d2);    deque&lt;int&gt;d3(10, 100);    printDeque(d3);    deque&lt;int&gt;d4 = d3;    printDeque(d4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><ul><li><p>deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</p></li><li><p>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;        deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt;d2;    d2 = d1;    printDeque(d2);    deque&lt;int&gt;d3;    d3.assign(d1.begin(), d1.end());    printDeque(d3);    deque&lt;int&gt;d4;    d4.assign( 10 , 100 );    printDeque(d4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><ul><li>deque.empty(); &#x2F;&#x2F;判断容器是否为空</li><li>deque.size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    //判断容器是否为空    if (d1.empty()) &#123;        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;        //统计大小        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;    &#125;    //重新指定大小    d1.resize( 15 , 1 );    printDeque(d1);    d1.resize( 5 );    printDeque(d1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><ul><li><p>两端插入操作：</p><ul><li>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据</li><li>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据</li><li>pop_back(); &#x2F;&#x2F;删除容器最后一个数据</li><li>pop_front(); &#x2F;&#x2F;删除容器第一个数据</li><li>指定位置操作：</li></ul></li><li><p>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p><ul><li>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear(); &#x2F;&#x2F;清空容器的所有数据</li><li>erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul></li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;`    &#125;    cout &lt;&lt; endl;&#125;//两端操作void test01()&#123;    deque&lt;int&gt; d;    //尾插    d.push_back( 10 );    d.push_back( 20 );    //头插    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    //尾删    d.pop_back();    //头删    d.pop_front();    printDeque(d);&#125;//插入void test02()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.insert(d.begin(), 1000 );    printDeque(d);    d.insert(d.begin(), 2 , 10000 );    printDeque(d);    deque&lt;int&gt;d2;    d2.push_back( 1 );    d2.push_back( 2 );    d2.push_back( 3 );    d.insert(d.begin(), d2.begin(), d2.end());    printDeque(d);&#125;//删除void test03()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.erase(d.begin());    printDeque(d);    d.erase(d.begin(), d.end());    d.clear();    printDeque(d);&#125;int main() &#123;    test01();    test02();    test03();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//数据存取void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7 deque 排序"></a>3.3.7 deque 排序</h4><h5 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h5><ul><li>sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序</li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    sort(d.begin(), d.end());    printDeque(d);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashtable</title>
      <link href="/p/51768.html"/>
      <url>/p/51768.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>hashtable 的目的是为了提供任何操作都是常数级别</p><h2 id="hashtable基本概念"><a href="#hashtable基本概念" class="headerlink" title="hashtable基本概念"></a>hashtable基本概念</h2><p>功能：将数据进行链式存储<br>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列结点组成<br>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p><strong>list的优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点：</strong></p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</T></li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    list&lt;int&gt;L2(L1.begin(),L1.end());    printList(L2);    list&lt;int&gt;L3(L2);    printList(L3);    list&lt;int&gt;L4( 10 , 1000 );    printList(L4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h2><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    //赋值    list&lt;int&gt;L2;    L2 = L1;    printList(L2);    list&lt;int&gt;L3;    L3.assign(L2.begin(), L2.end());    printList(L3);    list&lt;int&gt;L4;    L4.assign( 10 , 100 );    printList(L4);&#125;//交换void test02()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    list&lt;int&gt;L2;    L2.assign( 10 , 100 );    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);    cout &lt;&lt; endl;    L1.swap(L2);    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    if (L1.empty())    &#123;        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;    &#125;    //重新指定大小    L1.resize( 10 );    printList(L1);    L1.resize( 2 );    printList(L1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h2><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;//插入和删除void test01()&#123;    list&lt;int&gt; L;    //尾插    L.push_back( 10 );    L.push_back( 20 );    L.push_back( 30 );    //头插    L.push_front( 100 );    L.push_front( 200 );    L.push_front( 300 );    printList(L);    //尾删    L.pop_back();    printList(L);    //头删    L.pop_front();    printList(L);    //插入    list&lt;int&gt;::iterator it = L.begin();    L.insert(++it, 1000 );    printList(L);    //删除    it = L.begin();    L.erase(++it);    printList(L);    L.push_back( 10000 );    L.push_back( 10000 );    L.push_back( 10000 );    printList(L);    L.remove( 10000 );    printList(L);    //清空    L.clear();    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h2><ul><li><p>front(); &#x2F;&#x2F;返回第一个元素。</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素。</p></li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;//数据存取void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;    //list容器的迭代器是双向迭代器，不支持随机访问    list&lt;int&gt;::iterator it = L1.begin();    //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：list容器中不可以通过[]或者at方式访问数据</p><ul><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h2 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h2><ul><li><p>reverse(); &#x2F;&#x2F;反转链表</p></li><li><p>sort(); &#x2F;&#x2F;链表排序</p></li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;    return val1 &gt; val2;&#125;//反转和排序void test01()&#123;    list&lt;int&gt; L;    L.push_back( 90 );    L.push_back( 30 );    L.push_back( 20 );    L.push_back( 70 );    printList(L);    //反转容器的元素    L.reverse();    printList(L);    //排序    L.sort(); //默认的排序规则 从小到大    printList(L);    L.sort(myCompare); //指定规则，从大到小    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h3><h4 id="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"><a href="#案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高" class="headerlink" title="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"></a>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</h4><h4 id="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"><a href="#排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序" class="headerlink" title="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"></a>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</h4><h5 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:    Person(string name, int age , int height) &#123;        m_Name = name;        m_Age = age;        m_Height = height;    &#125;public:    string m_Name; //姓名    int m_Age; //年龄    int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    else    &#123;        return p1.m_Age &lt; p2.m_Age;    &#125;&#125;void test01() &#123;    list&lt;Person&gt; L;    Person p1(&quot;刘备&quot;, 35 , 175 );    Person p2(&quot;曹操&quot;, 45 , 180 );    Person p3(&quot;孙权&quot;, 40 , 170 );    Person p4(&quot;赵云&quot;, 25 , 190 );    Person p5(&quot;张飞&quot;, 35 , 160 );    Person p6(&quot;关羽&quot;, 35 , 200 );    L.push_back(p1);    L.push_back(p2);    L.push_back(p3);    L.push_back(p4);    L.push_back(p5);    L.push_back(p6);    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;    L.sort(ComparePerson); //排序    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RvalueReference</title>
      <link href="/p/57245.html"/>
      <url>/p/57245.html</url>
      
        <content type="html"><![CDATA[<h1 id="RvalueReference"><a href="#RvalueReference" class="headerlink" title="RvalueReference"></a>RvalueReference</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>解决非必要的拷贝<br>Rvalue references are a new reference type introduced in C++Oxthat help solve the problem of unnecessary copying and enableperfect forwarding. When the right-hand side of an assignment isan rvalue, then the left-hand side object can steal resources fromthe right-hand side object rather than performing a separate allocation, thus enabling move semantics.</p><p>Rvalue 引用是 C++Ox 中引入的一种新的引用类型，有助于解决不必要的复制问题并启用完美转发。当赋值的右侧是右值时，左侧对象可以从右侧对象窃取资源，而不是执行单独的分配，从而实现移动语义。</p><ul><li>Lvalue: 可以出现在左边</li><li>Rvalue: 只能出现在右边</li></ul><p><strong>a+b&#x3D;42编译无法通过</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC.png"><br><strong>标红可以通过编译</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC2.png"><br><strong>标红可以通过编译</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC3.png"></p><h2 id="perfect-forwarding"><a href="#perfect-forwarding" class="headerlink" title="perfect forwarding"></a>perfect forwarding</h2><p><img src="/p/57245.htm/perfectForwarding.png"><br><img src="/p/57245.htm/standardForward.png"></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alias Template</title>
      <link href="/p/45839.html"/>
      <url>/p/45839.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h1><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>传统方法使用关键字 typedef。<br>C++新标准规定了一种新方法，使用关键字 using 进行 别名申明（alias declaration）来定义类型的别名。<br>从使用语法来看 using 比 typedef 更加简洁明了，推荐使用 using 关键字进行别名定义。</p><ul><li>typedef void (*func)(int, int);</li><li>using func&#x3D; void(*) (int,int);</li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><ul><li>using vec &#x3D; std::vector&lt; T,MyAlloc<T> &gt;;</T></li><li>使用#define无法达到同样的效果</li><li>使用typedef也无法达到同样的效果，因为typedef不接受参数，只能提供特化的内容在</li><li>标准 C++，typedef 可定义模板类型一个新的类型名称，但是不能够使用 typedef 来定义模板的别名。举例来说：</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>别名声明可以模板化，但是typedef不可以；</p><pre><code>template&lt;typename T&gt;using MyAllocList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;;MyAllocList&lt;Widget&gt; lw;</code></pre><p>如果使用typedef的话，则很复杂：</p><pre><code>template&lt;typename T&gt;struct MyAllocList &#123;    typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;&#125;;MyAllocList&lt;Widget&gt;::type lw;</code></pre><p>别名的作用难道就是少打几个字嘛？<br><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%951.png" alt="错误案例1"></p><p><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%95.png" alt="错误案例2"></p><p>正确用法<br><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%953.png" alt="错误案例2"></p><p>但是我们并没有成功的传入模板参数T，还是有些遗憾，那么该如何解决呢？<br>后续内容请参考<a href="./TemplateTemplateParameter.md">模板模板参数</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template Template Parameter</title>
      <link href="/p/6511.html"/>
      <url>/p/6511.html</url>
      
        <content type="html"><![CDATA[<h1 id="Template-Template-Parameter"><a href="#Template-Template-Parameter" class="headerlink" title="Template Template Parameter"></a>Template Template Parameter</h1><p>接Alias Template<br>我们还是想解决这个问题<br><img src="/p/6511.htm/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B01.png"><br>通过模板模板参数，我们可以采用下面这个方法<br><img src="/p/6511.htm/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png"><br>这个程序编译是可以通过的，但是调用的过程中会产生下面的错误<br><img src="/p/6511.htm/%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png"><br>仔细分析报错信息我们会发现<br><img src="/p/6511.htm/vector.png"><br>事实上，容器第二个参数在模板中需要传参<br><img src="/p/6511.htm/%E5%88%AB%E5%90%8D%E8%B0%83%E7%94%A8.png"><br>通过别名调用才是正确的结果，这说明别名的存在有很大作用，需要细细体会</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Otherthings</title>
      <link href="/p/4097.html"/>
      <url>/p/4097.html</url>
      
        <content type="html"><![CDATA[<h1 id="Otherthings"><a href="#Otherthings" class="headerlink" title="Otherthings"></a>Otherthings</h1><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><ul><li>noexcept是C++11为了替代 throw()而提出的一个新的关键字</li><li>C++中使用函数异常声明列表来查看函数可能抛出的异常。</li><li>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</li></ul><p>下例就是一个函数异常声明列表，该声明指出 func 可能抛出int和 double 类型的异常。</p><pre><code>void func() throw (int,double);</code></pre><p>但是在实际编程中很少使用这种写法，所以这一特性在 C++11 中被抛弃。另外，如果异常声明列表写成如下形式：</p><pre><code>void func() throw();</code></pre><p>这种写法表示函数 func 不抛出任何异常，而这种写法在 c++11 中被新的关键字 noexcept 异常声明所取代。语法上 noexcept 修饰符有两种形式，一种就是简单地在函数声明后加上 noexcept 关键字。比如：</p><pre><code>void func() noecept;</code></pre><p>另外一种形式则是接受一个常量表达式作为参数，如下所示：</p><pre><code>void func() noexcept(常量表达式);</code></pre><p>常量表达式的结果会被转换成一个 bool 类型的值，该值为 true，表示函数不会抛出异常，反之则可能抛出异常。而不带常量表达式的 noexcept相当于声明了 noexcept(true)，即不会抛出异常。</p><p><strong>以下情形鼓励使用noexcept：</strong></p><ul><li>移动构造函数（move constructor）</li><li>移动分配函数（move assignment）</li><li>析构函数（destructor）</li></ul><p><img src="/p/4097.htm/noexcept.png"></p><p><strong>不是以上情况或者没把握的情况下，不要轻易使用noexception。</strong></p><h2 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h2><p>override关键字作用：<br>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。<br>如果派生类里面想要重载虚函数 就加上关键字override 这样编译器可以辅助检查是不是正确重载，如果没加这个关键字 也没什么严重的error 只是少了编译器检查的安全性。</p><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>C++11的关键字final有两个用途。</p><ul><li>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</li><li>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面。</li></ul><p>具体例子如下所示：</p><pre><code>struct Base&#123;    virtual void foo();&#125;;struct A : Base&#123;    void foo() final; // Base::foo 被覆盖而 A::foo 是最终覆盖函数    void bar() final; // 错误：非虚函数不能被覆盖或是 final&#125;;struct B final : A // struct B 为 final&#123;    void foo() override; // 错误：foo 不能被覆盖，因为它在 A 中是 final&#125;;struct C : B // 错误：B 为 final&#123;&#125;;</code></pre><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>auto，用于通过一个表达式在编译时确定待定义的变量类型，auto 所修饰 的变量必须被初始化，编译器需要通过初始化来确定auto 所代表的类型，即必须要定义变 量。<br>若仅希望得到类型，而不需要（或不能）定义变量的时候应该怎么办呢？ C++11 新增了decltype 关键字，用来在编译时推导出一个表达式的类型。它的语法格式 如下：</p><pre><code>decltype(exp)</code></pre><p>其中，exp 表示一个表达式（expression）</p><p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。</p><pre><code>#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;class Base &#123;public:    void func(T&amp; container) &#123;        m_it = container.begin();    &#125;private:    typename T::iterator m_it;  //注意这里&#125;;int main()&#123;    const vector&lt;int&gt; v;    Base&lt;const vector&lt;int&gt;&gt; obj;    obj.func(v);    return 0;&#125;</code></pre><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变参模板</title>
      <link href="/p/64016.html"/>
      <url>/p/64016.html</url>
      
        <content type="html"><![CDATA[<h1 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h1><h2 id="数量不定的模板参数："><a href="#数量不定的模板参数：" class="headerlink" title="数量不定的模板参数："></a>数量不定的模板参数：</h2><p>Variadic Template是C++11的一个很重要的特性；</p><p>变体现在两个方面：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归调用；</li><li>参数类型：参数个数逐一递减导致参数类型也逐一递减；</li></ul><p>两个注意点</p><ul><li>递归调用</li><li>递归终止：使用重载的办法终止递归调用；</li></ul><p><img src="https://i.imgur.com/PheGO3f.png"></p><h2 id="递归函数方式展开参数包"><a href="#递归函数方式展开参数包" class="headerlink" title="递归函数方式展开参数包"></a>递归函数方式展开参数包</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>以print函数为例，该模板参数将可以把参数不断地递归分解参数，不断递归调用print本身将参数打印出来了，但是最后一个打印完后没有参数了，所以还需要写一个参数为零的print()。 </p><pre><code>void print() &#123;&#125;template&lt;typename T,typename...Types&gt;void print(const T&amp; firstArg, const Types&amp;...args) &#123;    cout &lt;&lt; firstArg &lt;&lt; endl;    printX(args...);&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code>int maximun(int n)&#123;    return n;&#125;template&lt;typename...Args&gt;int maximun(int n,Args...args)&#123;    return std::max(n,maximun(args...));&#125;</code></pre><h2 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h2><pre><code>template &lt;class T&gt;void printarg(T t)&#123;cout &lt;&lt; t &lt;&lt; endl;&#125;template &lt;class ...Args&gt;void expand(Args... args)&#123;int arr[] = &#123;(printarg(args), 0)...&#125;;&#125;expand(1,2,3,4);</code></pre><p>这个例子将分别打印出1,2,3,4四个数字。这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p><pre><code>d = (a = b, c); </code></pre><p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p><p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。我们可以把上面的例子再进一步改进一下，将函数作为参数，就可以支持lambda表达式了，从而可以少写一个递归终止函数了，具体代码如下：</p><pre><code>template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args) &#123;    initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;&#125;expand([](int i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2,3);</code></pre><p>上面的例子将打印出每个参数，这里如果再使用C++14的新特性泛型lambda表达式的话，可以写更泛化的lambda表达式了：</p><pre><code>expand([](auto i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2.0,”test”);</code></pre><p>主要内容摘自<a href="https://www.cnblogs.com/qicosmos/p/4325949.html">https://www.cnblogs.com/qicosmos/p/4325949.html</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构化绑定</title>
      <link href="/p/53866983.html"/>
      <url>/p/53866983.html</url>
      
        <content type="html"><![CDATA[<h1 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h1><p>首先我们先来看元组解包的std::tie<br>std::tie会将变量的引用整合成一个tuple，从而实现批量赋值。</p><pre><code>int i; double d; string s;tie(i, d, s) = t3;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; s &lt;&lt; endl;</code></pre><p>这样相对于 get&lt;0&gt;(t3)这种方式容易多了。<br>结构化绑定：通过对象的元素或成员初始化多个实体。<br>一个结构体如下：</p><pre><code>struct MyStruct &#123;    int i = 0;    std::string s;&#125;;</code></pre><p>我们可以将一个MyStruct对象绑定到两个变量上。</p><pre><code>MyStruct ms;auto [u, v] = ms;</code></pre><p>在这里，u和v就是结构化绑定。将结构体的成员分解初始化了u、v变量。</p><p>另一个比较有意思的使用地方在于可以增加代码可读性，例如输出map中所有的键值对。map如下：</p><pre><code>std::map&lt;int, std::string&gt; mymap = &#123;&#123;1, "el"&#125;, &#123;3, "tom"&#125;, &#123;4, "nic"&#125;&#125;;</code></pre><p>结构化绑定之前我们遍历给定的是无意义的elem。</p><pre><code>for (const auto&amp; elem : mymap) &#123;    std::cout &lt;&lt; elem.first &lt;&lt; &quot;: &quot;  &lt;&lt; elem.second &lt;&lt; std::endl;&#125;</code></pre><p>有了结构体绑定之后，我们只需要[key, val]。</p><pre><code>for (const auto&amp; [key, val] : mymap) &#123;    std::cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; val &lt;&lt; std::endl;&#125;</code></pre><p>在这里我们可以清晰的看出结构化绑定的语义。</p><p>不过，结构化绑定不能使用constexpr修饰或者声明成为static</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/p/2cf69f40.html"/>
      <url>/p/2cf69f40.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（[1]）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达。数字“2”获取众筹列表<br>我在用 output_container.h 输出容器内容的时候，实际上就对容器的 begin 和 end 成员函数返回的对象类型提出了要求。假设前者返回的类型是 I，后者返回的类型是 S，这些要求是</p><ul><li>I 对象支持 * 操作，解引用取得容器内的某个对象。</li><li>I 对象支持 ++，指向下一个对象。</li><li>I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）</li></ul><p>注意在 C++17 之前，begin 和 end 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。</p><p>上面的类型 I，多多少少就是一个满足输入迭代器（input iterator）的类型了。不过，output_container.h 只使用了前置 ++，但输入迭代器要求前置和后置 ++ 都得到支持。</p><p>输入迭代器不要求对同一迭代器可以多次使用 * 运算符，也不要求可以保存迭代器来重新遍历对象，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p><p>一个前向迭代器的类型，如果同时支持 –（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。一个双向迭代器，如果额外支持在整数类型上的 +、-、+&#x3D;、-&#x3D;，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p><p>一个随机访问迭代器 i 和一个整数 n，在 *i 可解引用且 i + n 是合法迭代器的前提下，如果额外还满足 *(addressdof(*i) + n) 等价于 *(i + n)，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguousiterator）。</p><p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 *i 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p><p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p><ul><li>对象可以被拷贝构造、拷贝赋值和析构。</li><li>对象支持 * 运算符。</li><li>对象支持前置 ++ 运算符。</li></ul><p><img src="https://s1.ax1x.com/2023/07/15/pC579Zd.md.png" alt="pC579Zd.md.png"></p><p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。</p><h2 id="常用迭代器"><a href="#常用迭代器" class="headerlink" title="常用迭代器"></a>常用迭代器</h2><p>最常用的迭代器就是容器的 iterator 类型了。以我们学过的顺序容器为例，它们都定义了嵌套的 iterator 类型和 const_iterator 类型。一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p><ul><li>vector::iterator 和 array::iterator 可以满足到连续迭代器。</li><li>deque::iterator 可以满足到随机访问迭代器（记得它的内存只有部分连续）。</li><li>list::iterator 可以满足到双向迭代器（链表不能快速跳转）。</li><li>forward_list::iterator 可以满足到前向迭代器（单向链表不能反向遍历）。</li></ul><p>很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是ostream_iterator，方便我们把容器内容“拷贝”到一个输出流。</p><p>vector<int> v1{1, 2, 3, 4, 5};<br>2 vector<int> v2;<br>3 copy(v1.begin(), v1.end(),<br>4 back_inserter(v2));</int></int></p><h2 id="支持for-each"><a href="#支持for-each" class="headerlink" title="支持for_each"></a>支持for_each</h2><p>需要提供</p><pre><code>Iterator  begin();Iterator end(),</code></pre><p>以及必须支持</p><pre><code>operator++operator--operator *</code></pre><h2 id="迭代器和指针区别"><a href="#迭代器和指针区别" class="headerlink" title="迭代器和指针区别"></a>迭代器和指针区别</h2><p>迭代器和指针的相似之处在于我们可以取消引用它们以获取值。但是，主要区别如下：</p><table><thead><tr><th>特性</th><th>指针</th><th>迭代器</th></tr></thead><tbody><tr><td>存储内容</td><td>保存内存地址。</td><td>可能持有指向复杂数据结构、文件系统数据或分布式数据的引用。</td></tr><tr><td>算术运算</td><td>可以进行简单的算术运算，如递增、递减和整数加减。</td><td>并非所有迭代器都支持算术运算，受限于迭代器类型的不同。</td></tr><tr><td>支持类型</td><td>T* 类型的指针可以指向任何类型 T 对象。</td><td>迭代器类型受容器限制，例如 vector::iterator 只能引用双精度数。</td></tr><tr><td>删除操作</td><td>可以使用 delete 删除指针。</td><td>迭代器没有删除操作的概念，容器负责内存管理。</td></tr><tr><td>用途</td><td>主要用于直接访问内存地址。</td><td>主要用于容器或数据结构中的元素遍历。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值右值</title>
      <link href="/p/3763.html"/>
      <url>/p/3763.html</url>
      
        <content type="html"><![CDATA[<h1 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h1><p>在 C++11 中，一共有 5 种 value：</p><p>lvalue (Left-hand-side value)<br>rvalue (Right-hand-side value)<br>xvalue (eXpiring value)<br>prvalue (Pure rvalue)<br>glvalue (Generalized lvalue)</p><p>一个 lvalue 是通常可以放在等号左边的表达式，左值<br>一个 rvalue 是通常只能放在等号右边的表达式，右值<br>一个 glvalue 是 generalized lvalue，广义左值<br>一个 xvalue 是 expiring lvalue，将亡值<br>一个 prvalue 是 pure rvalue，纯右值</p><p>他们的关系大致如下图所示：<br><img src="https://s1.ax1x.com/2023/04/02/ppfUKTe.png" alt="valueTyoe.png"><br><img src="https://s1.ax1x.com/2023/07/15/pC55W8O.png" alt="pC55W8O.png"></p><p>lvalue 和 xvalue 合称为 glvalue。<br>prvalue 和 xvalue 合称为 rvalue。</p><p>有”身份”[has identity]：能够确定某个表达式是否和另一个表达式指涉[refers to]同一个实体，例如，通过比较它们标识[identify]出来的函数或者对象的地址(直接或间接得到的)。<br>能被移动[can be moved from]：能够被移动构造函数、移动赋值操作符或者其它实现[implement]移动语义[move semantics]的重载函数绑定[bind to]。<br>根据上面两个属性，我们可以对表达式进行分类：</p><p>有”身份”但是不能”被移动”的表达式被称为左值表达式[lvalue expression];<br>有”身份”同时能”被移动”的表达式被称为 xvalue 表达式[xvalue expression];<br>没有”身份”但是能”被移动”的表达式被称为纯右值表达式[prvalue expression];<br>C++没有既没有”身份”也不能”被移动”的表达式；<br><a href="https://imgse.com/i/ppfUvhd"><img src="https://s1.ax1x.com/2023/04/02/ppfUvhd.png" alt="ppfUvhd.png"></a></p><p><strong>“值类别”</strong>（value category）和<strong>“值类型”</strong>（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。</p><h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h2><p>如果你可以对一个表达式取地址，那这个表达式就是个lvalue。<br>如果一个表达式的类型是一个lvalue reference (例如, T&amp; 或 const T&amp;, 等.)，那这个表达式就是一个lvalue。<br>一个 lvalue 是通常可以放在等号左边的表达式<br>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：<br>变量、函数或数据成员<br>返回左值引用的表达式如：</p><pre><code>++x、x = 1、cout &lt;&lt; &#39; &#39;int x = 0;cout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;cout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;cout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;//cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl; // errorcout &lt;&lt; &quot;(cout &lt;&lt; &#39; &#39;).addr=&quot; &lt;&lt; &amp;(cout &lt;&lt; &#39; &#39;) &lt;&lt; endl;</code></pre><p>字符串字面量是左值，而且是不可被更改的左值。字符串字面量并不具名，但是可以用&amp;取地址所以也是左值。如：</p><pre><code>&quot;hello&quot;,在c++中是 char const [6] 类型，而在c中是 char [6] 类型cout &lt;&lt; &quot;(\&quot;hello\&quot;).addr=&quot; &lt;&lt; &amp;(&quot;hello&quot;) &lt;&lt; endl;</code></pre><p>如果一个表达式的类型是一个lvalue reference (例如, T&amp; 或 const T&amp;, 等.)，那这个表达式就是一个lvalue。</p><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><h3 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h3><p>通常指代一个生存周期即将结束的值（因此其资源可以被转移）。是某些涉及到右值引用的表达式的值，根据C++11标准，以下四种情况属于xvalue：</p><ul><li>调用函数（无论是隐式还是显式）的结果，该函数的返回类型是对对象类型的右值引用，</li><li>对对象类型的右值引用的强制转换，</li><li>类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue，或</li><li>指向成员表达式的*指针，其中第一个操作数是xvalue，第二个操作数是指向数据成员的指针。</li></ul><h3 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h3><p>prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p><p>返回非引用类型的表达式 如 x++、x + 1<br>除字符串字面量之外的字面量 如 42、true<br>隐式或显式调用函数的结果，该函数的返回类型是对所返回对象类型的右值引用</p><pre><code>int&amp;&amp; f()&#123;    return 3;&#125;int main()&#123;    f(); // The expression f() belongs to the xvalue category, because f() return type is an rvalue reference to object type.    return 0;&#125;</code></pre><p>类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue</p><pre><code>struct As&#123;    int i;&#125;;As&amp;&amp; f()&#123;    return As();&#125;int main()&#123;    f().i; // The expression f().i belongs to the xvalue category, because As::i is a non-static data member of non-reference type, and the subexpression f() belongs to the xvlaue category.    return 0;&#125;</code></pre><p>对对象类型右值引用的转换</p><pre><code>int main()&#123;    static_cast&lt;int&amp;&amp;&gt;(7); // The expression static_cast&lt;int&amp;&amp;&gt;(7) belongs to the xvalue category, because it is a cast to an rvalue reference to object type.    std::move(7); // std::move(7) is equivalent to static_cast&lt;int&amp;&amp;&gt;(7).    return 0;&#125;</code></pre><p>从语法上来看，声明右值引用看起来和声明”普通”的引用很像，只不过要用&amp;&amp;而不是&amp;。下面这个函数需要一个类型为rvalue-reference-to-Widget:的参数:</p><pre><code>void f(Widget&amp;&amp; param);</code></pre><p>假设右值引用是使用&amp;&amp;声明的，那么假设类型声明中出现&amp;&amp; 表示右值引用似乎是合理的。事实并非如此:</p><pre><code>Widget&amp;&amp; var1 = someWidget;      // here, “&amp;&amp;” means rvalue referenceauto&amp;&amp; var2 = var1;              // here, “&amp;&amp;” does not mean rvalue referencetemplate&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param);  // here, “&amp;&amp;” means rvalue referencetemplate&lt;typename T&gt;void f(T&amp;&amp; param);               // here, “&amp;&amp;”does not mean rvalue reference</code></pre><p>因此正确的区分这两种含义非常重要，如果你看到“&amp;&amp;”就以为是右值引用的话，会误读很多c++11代码。</p><p>2.引入万能引用<br>这个问题的本质实际上是，类型声明当中的“&amp;&amp;”有的时候意味着rvalue reference，但有的时候意味着rvalue reference 或者 lvalue reference。因此，源代码当中出现的 “&amp;&amp;” 有可能是 “&amp;” 的意思，即是说，语法上看着像rvalue reference (“&amp;&amp;”)，但实际上却代表着一个lvalue reference (“&amp;”)。在这种情况下，此种引用比lvalue references 或者 rvalue references都要来的更灵活。<br>Rvalue references只能绑定到右值上，lvalue references除了可以绑定到左值上，在某些条件下还可以绑定到右值上。</p><p>例如：</p><pre><code>string &amp;s = &quot;asd&quot;;  // errorconst string &amp;s = &quot;asd&quot;;  // ok</code></pre><p>规则简化如下：</p><pre><code>左值引用   &#123;左值&#125;  右值引用   &#123;右值&#125;常左值引用  &#123;右值&#125;</code></pre><p>相比之下，声明中带 “&amp;&amp;” 的，可能是lvalue references 或者 rvalue references 的引用可以绑定到任何东西上。这种引用称它们为 universal references(万能引用或转发引用、通用引用)。</p><pre><code>string f() &#123; return &quot;abc&quot;; &#125;​void g() &#123;    const string &amp;s = f();       // still legal?    cout &lt;&lt; s &lt;&lt; endl;&#125;</code></pre><p>上面g函数中合法？</p><p>答案是合法的，原因是s是个左值，类型是常左值引用，而f()是个右值，前面提到常左值引用可以绑定到右值！所以合法，当然把const去掉，便是不合法！</p><h2 id="生命周期和表达式类型"><a href="#生命周期和表达式类型" class="headerlink" title="生命周期和表达式类型"></a>生命周期和表达式类型</h2><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。我们先看一个没有生命周期延长的基本情况</p><pre><code>process_shape(circle(), triangle());</code></pre><p>我们生成了临时对象，一个圆和一个三角形，它们会在 process_shape 执行完<br>成并生成结果对象后被销毁。</p><pre><code>#include &lt;stdio.h&gt;class shape &#123;public:    virtual ~shape() &#123;&#125;&#125;;class circle : public shape &#123;public:    circle() &#123; puts(&quot;circle()&quot;); &#125;    ~circle() &#123; puts(&quot;~circle()&quot;); &#125;&#125;;class triangle : public shape &#123;public:    triangle() &#123; puts(&quot;triangle()&quot;); &#125;    ~triangle() &#123; puts(&quot;~triangle()&quot;); &#125;&#125;;class result &#123;public:    result() &#123; puts(&quot;result()&quot;); &#125;    ~result() &#123; puts(&quot;~result()&quot;); &#125;&#125;;result process_shape(const shape&amp; shape1, const shape&amp; shape2)&#123;    puts(&quot;process_shape()&quot;);    return result();&#125;int main()&#123;    puts(&quot;main()&quot;);    process_shape(circle(), triangle());    puts(&quot;something else&quot;);&#125;</code></pre><p>输出结果可能会是（circle 和 triangle 的顺序在标准中没有规定）：</p><pre><code>main()circle()triangle()process_shape()result()~result()~triangle()~circle()something else</code></pre><p>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：</p><pre><code>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样    长。</code></pre><p>我们对上面的代码只要改一行就能演示这个效果。把 process_shape 那行改成：</p><pre><code>result&amp;&amp; r = process_shape(circle(), triangle());</code></pre><p>我们就能看到不同的结果了：</p><pre><code>main()circle()triangle()process_shape()result()~triangle()~circle()something else~result()</code></pre><p>现在 result 的生成还在原来的位置，但析构被延到了 main 的最后<br>这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长。不注意这点的话，代码就可能会产生隐秘的 bug。比如，我们如果这样改一下代码，结果就不对了：</p><pre><code>#include &lt;utility&gt; // std::move…result&amp;&amp; r = std::move(process_shape(circle(), triangle()));</code></pre><p>这时的代码输出就回到了前一种情况。虽然执行到 something else 那儿我们仍然有一个有效的变量 r，但它指向的对象已经不存在了，对 r 的解引用是一个未定义行为。由于 r 指向的是栈空间，通常不会立即导致程序崩溃，而会在某些复杂的组合条件下才会引致问题……</p><p>可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。</p><h2 id="移动的意义"><a href="#移动的意义" class="headerlink" title="移动的意义"></a>移动的意义</h2><p>我们可以尝试分析一下下面这个假想的语句（假设name 是 string 类型）：</p><pre><code>string result =string(&quot;Hello, &quot;) + name + &quot;.&quot;;</code></pre><p>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，执行流程大致如下：</p><ol><li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次</li><li>调用 operator+(const string&amp;, const string&amp;)，生成临时对象 2；”Hello,” 复制 2 次，name 复制 1 次。</li><li>调用 operator+(const string&amp;, const char*)，生成对象 3；”Hello, “ 复<br>制 3 次，name 复制 2 次，”.” 复制 1 次。</li><li>假设返回值优化能够生效（最佳情况），对象 3 可以直接在 result 里构造完成。</li><li>临时对象 2 析构，释放指向 string(“Hello, “) + name 的内存。</li><li>临时对象 1 析构，释放指向 string(“Hello, “) 的内存。</li></ol><p>我们可以这么学来进行优化</p><pre><code>string result = &quot;Hello, &quot;;result += name;result += &quot;.&quot;;</code></pre><p>这样的话，只会调用构造函数一次和 string::operator+&#x3D; 两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。但显然代码就啰嗦多了——尤其如果拼接的步骤比较多的话。从 C++11 开始，这不再是必须的。同样上面那个单行的语句，执行流程大致如下：</p><ol><li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次。</li><li>调用 operator+(string&amp;&amp;, const string&amp;)，直接在临时对象 1 上面执行追加<br>操作，并把结果移动到临时对象 2；name 复制 1 次。</li><li>调用 operator+(string&amp;&amp;, const char*)，直接在临时对象 2 上面执行追加操<br>作，并把结果移动到 result；”.” 复制 1 次。</li><li>临时对象 2 析构，内容已经为空，不需要释放任何内存。</li><li>临时对象 1 析构，内容已经为空，不需要释放任何内存</li></ol><p>性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。程序员只需要牺牲一点点性能，就可以大大增加代码的可读性。而且，所谓的性能牺牲，也只是相对于优化得很好的 C 或 C++ 代码而言——这样的 C++ 代码的性能仍然完全可以超越 Python 类的语言的相应代码。此外很关键的一点是，C++ 里的对象缺省都是值语义。在下面这样的代码里：</p><pre><code>class A &#123;    B b_;    C c_;&#125;;</code></pre><p>从实际内存布局的角度，很多语言——如 Java 和 Python——会在 A 对象里放 B 和 C 的指针（虽然这些语言里本身没有指针的概念）。而 C++ 则会直接把 B 和 C 对象放在 A 的内存空间里。这种行为既是优点也是缺点。说它是优点，是因为它保证了内存访问的局域性，而局域性在现代处理器架构上是绝对具有性能优势的。说它是缺点，是因为复制对象的开销大大增加：在 Java 类语言里复制的是指针，在 C++ 里是完整的对象。这就是为什么C++ 需要移动语义这一优化，而 Java 类语言里则根本不需要这个概念。<br>移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</p><h3 id="如何实现移动？"><a href="#如何实现移动？" class="headerlink" title="如何实现移动？"></a>如何实现移动？</h3><p>对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 unique_ptr）。<br>对象应该有 swap 成员函数，支持和另外一个对象快速交换成员。<br>在对象的名空间下，应当有一个全局的 swap 函数，调用成员函数 swap 来实现交换。支持这种用法会方便在其他对象里包含你的对象，并快速实现它们的 swap 函数。<br>实现通用的 operator&#x3D;。<br>上面各个函数如果不抛异常的话，应当标为 noexcept。这对移动构造函数尤为重要。</p><h3 id="不要返回本地变量的引用"><a href="#不要返回本地变量的引用" class="headerlink" title="不要返回本地变量的引用"></a>不要返回本地变量的引用</h3><p>有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出任何奇怪的行为都是正常的。<br>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。</p><pre><code>#include &lt;iostream&gt; // std::cout/endl#include &lt;utility&gt; // std::moveusing namespace std;class Obj &#123;public:    Obj()    &#123;        cout &lt;&lt; &quot;Obj()&quot; &lt;&lt; endl;    &#125;    Obj(const Obj&amp;)    &#123;        cout &lt;&lt; &quot;Obj(const Obj&amp;)&quot; &lt;&lt; endl;    &#125;    Obj(Obj&amp;&amp;)    &#123;        cout &lt;&lt; &quot;Obj(Obj&amp;&amp;)&quot; &lt;&lt; endl;    &#125;&#125;;Obj simple()&#123;    Obj obj;    // 简单返回对象；一般有 NRVO    return obj;&#125;Obj simple_with_move()&#123;    Obj obj;    // move 会禁止 NRVO    return std::move(obj);&#125;Obj complicated(int n)&#123;    Obj obj1;    Obj obj2;    // 有分支，一般无 NRVO    if (n % 2 == 0) &#123;        return obj1;    &#125;     else &#123;        return obj2;    &#125;&#125;int main()&#123;    cout &lt;&lt; &quot;*** 1 ***&quot; &lt;&lt; endl;    auto obj1 = simple();    cout &lt;&lt; &quot;*** 2 ***&quot; &lt;&lt; endl;    auto obj2 = simple_with_move();    cout &lt;&lt; &quot;*** 3 ***&quot; &lt;&lt; endl;    auto obj3 = complicated(42);&#125;</code></pre><p>输出通常为：</p><pre><code>*** 1 ***Obj()*** 2 ***Obj()Obj(Obj&amp;&amp;)*** 3 ***Obj()Obj()Obj(Obj&amp;&amp;)</code></pre><p>也就是，用了 std::move 反而妨碍了返回值优化。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/p/47718.html"/>
      <url>/p/47718.html</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况发⽣。使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域时，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。</p><p><strong>注意！！！智能指针没有从根本上解决了c++内存安全的问题</strong></p><h2 id="常⽤接⼝"><a href="#常⽤接⼝" class="headerlink" title="常⽤接⼝"></a>常⽤接⼝</h2><pre><code>T* get();T&amp; operator*(); T* operator-&gt;();T&amp; operator=(const T&amp; val);T* release();void reset (T* ptr = nullptr);</code></pre><ul><li>T 是模板参数, 也就是传⼊的类型；</li><li>get() ⽤来获取 <strong>auto_ptr</strong> 封装在内部的指针, 也就是获取原⽣指针；</li><li>operator() 重载 , operator-&gt;() 重载了-&gt;, operator&#x3D;()重载了&#x3D;；</li><li>realease() 将 <strong>auto_ptr</strong> 封装在内部的指针置为 nullptr, 但并不会破坏指针所指向的内容, 函数返回的是内部指针置空之前的值；</li><li>直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值,  则将内部指针初始化为该值 (否则将其设置为nullptr；</li></ul><h2 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h2><p><strong>1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</strong></p><pre><code>auto_ptr&lt;std::string&gt; p1 (new string (&quot;hello&quot;));auto_ptr&lt;std::string&gt; p2;p2 = p1; //auto_ptr 不会报错.</code></pre><p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 <strong>auto_ptr</strong> 的缺点是：存在潜在的内存崩溃问题！</p><p><strong>2、unique_ptr（替换 <strong>auto_ptr</strong> ）</strong><br><strong>unique_ptr</strong> 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。<br>采⽤所有权模式，还是上⾯那个例⼦</p><pre><code>unique_ptr&lt;string&gt; p3 (new string (auto));unique_ptr&lt;string&gt; p4;p4 = p3;//此时会报错</code></pre><p>编译器认为 p4&#x3D;p3 ⾮法，避免了 p3 不再指向有效数据的问题。因此，<strong>unique_ptr</strong> ⽐ <strong>auto_ptr</strong> 更安全。</p><p><strong>3、shared_ptr（共享型，强引⽤）</strong><br><strong>shared_ptr</strong>实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。<br>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊<strong>auto_ptr</strong>, <strong>unique_ptr</strong>,<strong>weak_ptr</strong> 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。<br><strong>shared_ptr</strong> 是为了解决 <strong>auto_ptr</strong> 在对象所有权上的局限性 (<strong>auto_ptr</strong> 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。</p><p><strong>4、weak_ptr（弱引⽤）</strong><br><strong>weak_ptr</strong> 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 <strong>shared_ptr</strong> 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 <strong>shared_ptr</strong>。<br><strong>weak_ptr</strong> 只是提供了对管理对象的⼀个访问⼿段。<strong>weak_ptr</strong> 设计的⽬的是为配合 <strong>shared_ptr</strong> ⽽引⼊的⼀种智能指针来协助 <strong>shared_ptr</strong> ⼯作，它只可以从⼀个 <strong>shared_ptr</strong> 或另⼀个 <strong>weak_ptr</strong> 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。<br><strong>weak_ptr</strong> 是⽤来解决 <strong>shared_ptr</strong> 相互引⽤时的死锁问题，如果说两个 <strong>shared_ptr</strong> 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数， 和 <strong>shared_ptr</strong> 之间可以相互转化，<strong>shared_ptr</strong> 可以直接赋值给它，它可以通过调⽤ lock 函数来获得 <strong>shared_ptr</strong>。<br>当两个智能指针都是 <strong>shared_ptr</strong> 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为<strong>weak_ptr</strong>就可以。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>具体请查看<a href="https://whl963854.github.io/p/39842.html">unique_ptr</a>;</p><h3 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h3><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><h2 id="实现C-的智能指针"><a href="#实现C-的智能指针" class="headerlink" title="实现C++的智能指针"></a>实现C++的智能指针</h2><p>智能指针要能够包装任意类型的指针，我们需要使用类模板。</p><pre><code>template &lt;typename T&gt;class smart_ptr &#123;public:    explicit smart_ptr(T* ptr = nullptr)        : ptr_(ptr) &#123;&#125;    ~smart_ptr() &#123;        delete ptr_;    &#125;    T* get() const &#123;        return ptr_;    &#125;private:    T* ptr_;&#125;;</code></pre><p>目前这个 smart_ptr 的行为还是和指针有点差异的：</p><ul><li>它不能用 * 运算符解引用</li><li>它不能用 -&gt; 运算符指向对象成员</li><li>它不能像指针一样用在布尔表达式里</li></ul><p>不过，这些问题也相当容易解决，加几个成员函数就可以</p><pre><code>template &lt;typename T&gt;class smart_ptr &#123;public:    …    T&amp; operator*() const &#123; return *ptr_; &#125;    T* operator-&gt;() const &#123; return ptr_; &#125;    operator bool() const &#123; return ptr_; &#125;&#125;</code></pre><h3 id="拷贝构造和赋值"><a href="#拷贝构造和赋值" class="headerlink" title="拷贝构造和赋值"></a>拷贝构造和赋值</h3><p>拷贝构造和赋值，这是个比较复杂的问题了。关键还不是实现问题，而是我们该如何定义其行为。假设有下面的代码：</p><pre><code>smart_ptr&lt;shape&gt; ptr1&#123;create_shape(shape_type::circle)&#125;;smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</code></pre><p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查一下各种可能性。<br>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p><pre><code>template &lt;typename T&gt;class smart_ptr &#123;    // ...    smart_ptr(const smart_ptr&amp;) = delete;    smart_ptr&amp; operator=(const smart_ptr&amp;) = delete;    // ...&#125;;</code></pre><p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，smart_ptr<shape>ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃</shape></p><p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。在 C++ 里没有像 Java 的clone 方法这样的约定；一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。<br>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p><pre><code>template &lt;typename T&gt;class smart_ptr &#123;    …    smart_ptr(smart_ptr&amp; other)    &#123;        ptr_ = other.release();    &#125;    smart_ptr&amp; operator=(smart_ptr&amp; rhs)    &#123;        smart_ptr(rhs).swap(*this);        return *this;    &#125;    …    T* release()    &#123;        T* ptr = ptr_;        ptr_ = nullptr;        return ptr;    &#125;    void swap(smart_ptr&amp; rhs)    &#123;        using std::swap;        swap(ptr_, rhs.ptr_);    &#125;    …&#125;;</code></pre><p>在拷贝构造函数中，通过调用 other 的 release 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权。实现上是不复杂的。</p><p>如果赋值函数类似于 if (this !&#x3D; &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。<br>赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景<br>上面给出的语义本质上就是 C++98 的 auto_ptr 的定义。<br>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……</p><p>smart_ptr 通过“移动”来改善其行为，我们需要对代码做两处小修改：</p><pre><code>template &lt;typename T&gt;class smart_ptr &#123;    …    smart_ptr(smart_ptr&amp;&amp; other)    &#123;        ptr_ = other.release();    &#125;    smart_ptr&amp; operator=(smart_ptr rhs)    &#123;        rhs.swap(*this);        return *this;    &#125;    …&#125;;</code></pre><p>把拷贝构造函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr&amp;&amp;；现在它成了移动构造函数。把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。<br>根据 C++ 的规则，如果提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用，于是，我们自然地得到了以下结果</p><pre><code>smart_ptr&lt;shape&gt; ptr1&#123;create_shape(shape_type::circle)&#125;;smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // 编译出错smart_ptr&lt;shape&gt; ptr3;ptr3 = ptr1; // 编译出错ptr3 = std::move(ptr1); // OK，可以smart_ptr&lt;shape&gt; ptr4&#123;std::move(ptr3)&#125;; // OK，可以</code></pre><p>这也是 C++11 的 unique_ptr 的基本行为。</p><h3 id="子类指针向基类指针的转换"><a href="#子类指针向基类指针的转换" class="headerlink" title="子类指针向基类指针的转换"></a>子类指针向基类指针的转换</h3><p>一个 circle* 是可以隐式转换成 shape*的，但上面的 smart_ptr<circle></circle> 却无法自动转换成 smart_ptr<shape>。这个行为显然还是不够“自然<br>在我们目前给出的实现里，只需要修改我们的移动构造函数一处即可——这也算是我们让赋值函数使用拷贝 &#x2F; 移动构造函数的好处了</shape></p><pre><code>template &lt;typename U&gt;smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)&#123;    ptr_ = other.release();&#125;</code></pre><p>这样，我们自然而然利用了指针的转换特性：现在 smart_ptr<circle></circle> 可以移动给smart_ptr<shape>，但不能移动给 smart_ptr<triangle>。不正确的转换会在代码编译时直接报错</triangle></shape></p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 shared_ptr 了。</p><p>多个不同的 shared_ptr 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 shared_ptr 析构时，它需要删除对象和共享计数。我们下面就来实现一下。<br>我们先来写出共享计数的接口：</p><pre><code>class shared_count &#123;public:    shared_count();    void add_count();    long reduce_count();    long get_count() const;&#125;;</code></pre><p>这个 shared_count 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 shared_ptr 了。</p><pre><code>class shared_count &#123;public:    shared_count() : count_(1) &#123;&#125;    void add_count()    &#123;        ++count_;    &#125;    long reduce_count()    &#123;        return --count_;    &#125;    long get_count() const    &#123;        return count_;    &#125;private:    long count_;&#125;;</code></pre><p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：<br>构造函数跟之前的主要不同点是会构造一个 shared_count 出来。析构函数在看到 ptr_非空时（此时根据代码逻辑，shared_count 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。原理就是这样，不复杂。当然，我们还有些细节要处理。为了方便实现赋值（及其他一些惯用法），我们需要一个新<br>的 swap 成员函数</p><pre><code>void swap(smart_ptr&amp; rhs)&#123;    using std::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_, rhs.shared_count_);&#125;</code></pre><p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p><pre><code>template &lt;typename U&gt;smart_ptr(const smart_ptr&lt;U&gt;&amp; other)&#123;    ptr_ = other.ptr_;    if (ptr_) &#123;        other.shared_count_-&gt;add_count();        shared_count_ = other.shared_count_;    &#125;&#125;template &lt;typename U&gt;smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)&#123;    ptr_ = other.ptr_;    if (ptr_) &#123;        shared_count_ = other.shared_count_;        other.ptr_ = nullptr;    &#125;&#125;</code></pre><p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 other.ptr_ 置为空，认为 other 不再指向该共享对象即可<br>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p><pre><code>fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’</code></pre><p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和shared_count_。我们需要在 smart_ptr 的定义中显式声明：</p><pre><code>template &lt;typename U&gt;friend class smart_ptr;</code></pre><p>此外，我们之前的实现（类似于单一所有权的 unique_ptr ）中用 release 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p><pre><code>long use_count() const&#123;    if (ptr_) &#123;        return shared_count_-&gt;get_count();    &#125;     else &#123;        return 0;    &#125;&#125;</code></pre><p>这就差不多是一个比较完整的引用计数智能指针的实现:</p><pre><code>class shape &#123;public:    virtual ~shape() &#123;&#125;&#125;;class circle : public shape &#123;    public:    ~circle() &#123; puts(&quot;~circle()&quot;); &#125;&#125;;int main()&#123;    smart_ptr&lt;circle&gt; ptr1(new circle());    printf(&quot;use count of ptr1 is %ld\n&quot;, ptr1.use_count());        smart_ptr&lt;shape&gt; ptr2;    printf(&quot;use count of ptr2 was %ld\n&quot;, ptr2.use_count());        ptr2 = ptr1;    printf(&quot;use count of ptr2 is now %ld\n&quot;, ptr2.use_count());        if (ptr1) &#123;        puts(&quot;ptr1 is not empty&quot;);    &#125;&#125;</code></pre><p>这段代码的运行结果是：</p><pre><code>use count of ptr1 is 1use count of ptr2 was 0use count of ptr2 is now 2ptr1 is not empty~circle()</code></pre><p>上面我们可以看到引用计数的变化，以及最后对象被成功删除</p><h3 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h3><p>对应于 C++ 里的不同的类型强制转换：</p><ul><li><p>static_cast</p></li><li><p>reinterpret_cast</p></li><li><p>const_cast</p></li><li><p>dynamic_cast<br>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p><p>  template <typename u><br>  smart_ptr(const smart_ptr<U>&amp; other, T* ptr)<br>  {<br>  ptr_ &#x3D; ptr;<br>  if (ptr_) {<br>      other.shared_count_-&gt;add_count();<br>      shared_count_ &#x3D; other.shared_count_;<br>  }<br>  }</U></typename></p></li></ul><p>这样我们就可以实现转换所需的函数模板了。下面实现一个 dynamic_pointer_cast</p><pre><code>template &lt;typename T, typename U&gt;smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other)&#123;    T* ptr = dynamic_cast&lt;T*&gt;(other.get());    return smart_ptr&lt;T&gt;(other, ptr);&#125;</code></pre><p>在前面的验证代码后面我们可以加上：</p><pre><code>smart_ptr&lt;circle&gt; ptr3 =2 dynamic_pointer_cast&lt;circle&gt;(ptr2);printf(&quot;use count of ptr3 is %ld\n&quot;,ptr3.use_count());</code></pre><p>编译会正常通过，同时能在输出里看到下面的结果：</p><pre><code>use count of ptr3 is 3</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>#include &lt;utility&gt; // std::swapclass shared_count &#123;public:shared_count() noexcept    : count_(1) &#123;&#125;void add_count() noexcept&#123;    ++count_;&#125;long reduce_count() noexcept&#123;    return --count_;&#125;long get_count() const noexcept&#123;    return count_;&#125;private:long count_;&#125;;template &lt;typename T&gt;class smart_ptr &#123;public:template &lt;typename U&gt;friend class smart_ptr;explicit smart_ptr(T* ptr = nullptr)    : ptr_(ptr)&#123;    if (ptr) &#123;    shared_count_ = new shared_count();    &#125;&#125;~smart_ptr()&#123;    printf(&quot;~smart_ptr(): %p\n&quot;, this);    if (ptr_ &amp;&amp; !shared_count_-&gt;reduce_count()) &#123;    delete ptr_;    delete shared_count_;    &#125;&#125;template &lt;typename U&gt;smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept&#123;    ptr_ = other.ptr_;    if (ptr_) &#123;    other.shared_count_-&gt;add_count();    shared_count_ = other.shared_count_;    &#125;&#125;template &lt;typename U&gt;smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept&#123;    ptr_ = other.ptr_;    if (ptr_) &#123;    shared_count_ = other.shared_count_;    other.ptr_ = nullptr;    &#125;&#125;template &lt;typename U&gt;smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) noexcept&#123;    ptr_ = ptr;    if (ptr_) &#123;    other.shared_count_-&gt;add_count();    shared_count_ = other.shared_count_;    &#125;&#125;smart_ptr&amp; operator=(smart_ptr rhs) noexcept&#123;    rhs.swap(*this);    return *this;&#125;T* get() const noexcept&#123;    return ptr_;&#125;long use_count() const noexcept&#123;    if (ptr_) &#123;    return shared_count_-&gt;get_count();    &#125; else &#123;    return 0;    &#125;&#125;void swap(smart_ptr&amp; rhs) noexcept&#123;    using std::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_, rhs.shared_count_);&#125;T&amp; operator*() const noexcept&#123;    return *ptr_;&#125;T* operator-&gt;() const noexcept&#123;    return ptr_;&#125;operator bool() const noexcept&#123;    return ptr_;&#125;private:T* ptr_;shared_count* shared_count_;&#125;;template &lt;typename T&gt;void swap(smart_ptr&lt;T&gt;&amp; lhs, smart_ptr&lt;T&gt;&amp; rhs) noexcept&#123;lhs.swap(rhs);&#125;template &lt;typename T, typename U&gt;smart_ptr&lt;T&gt; static_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept&#123;T* ptr = static_cast&lt;T*&gt;(other.get());return smart_ptr&lt;T&gt;(other, ptr);&#125;template &lt;typename T, typename U&gt;smart_ptr&lt;T&gt; reinterpret_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept&#123;T* ptr = reinterpret_cast&lt;T*&gt;(other.get());return smart_ptr&lt;T&gt;(other, ptr);&#125;template &lt;typename T, typename U&gt;smart_ptr&lt;T&gt; const_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept&#123;T* ptr = const_cast&lt;T*&gt;(other.get());return smart_ptr&lt;T&gt;(other, ptr);&#125;template &lt;typename T, typename U&gt;smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept&#123;T* ptr = dynamic_cast&lt;T*&gt;(other.get());return smart_ptr&lt;T&gt;(other, ptr);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美转发</title>
      <link href="/p/50074.html"/>
      <url>/p/50074.html</url>
      
        <content type="html"><![CDATA[<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>在说明完美转发之前先来介绍一下引用折叠</p><pre><code>A&amp; &amp; 变成 A&amp;A&amp; &amp;&amp; 变成 A&amp;A&amp;&amp; &amp; 变成 A&amp;A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;</code></pre><h2 id="完美转发-1"><a href="#完美转发-1" class="headerlink" title="完美转发"></a>完美转发</h2><p><strong>转发</strong>：函数将一个或多个实参传递给其他函数的过程<br><strong>完美转发（perfect forwarding）</strong>：转发过程中，保持被转发实参的所有原始性质，包括实参类型是否为const，左值 or 右值等</p><p>我们先来看一个例子</p><pre><code>void f(int v1, int v2);template&lt;typename F, typename T1, typename T2&gt;void test1(F f, T1 t1, T2 t2) &#123;     f(t2, t1);&#125;</code></pre><p>理论上我们完成了转发，但是这有很多问题，比如当我们希望它调用一个接受引用参数的函数时，会出现问题：</p><pre><code>void f(int v1, int&amp; v2) &#123; // v2是一个引用类型    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;&#125;</code></pre><p>代码中，f改变了绑定到v2的实参值，但并不会影响test1的实参。因为实参传递给test1的形参，只是一个普通的int，而非引用（int&amp;），所以改变test1的形参并不会影响实参。<br>此外，采用拷贝而不是移动语义回导致效率造成损失。</p><p>为了让test函数传递一个引用，可以重写test函数，使其参数能保持给定实参的“左值性”，以及const属性（常量性）。</p><pre><code>template&lt;typename F, typename T1, typename T2&gt;void test2(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(t2, t1);&#125;</code></pre><p>如果t1或t2对应实参是左值（int&amp;），通过引用折叠，转换成int&amp;，继续保持左值属性；<br>如果实参是右值（int&amp;&amp;），同样地，转换成int&amp;&amp;，继续保持右值属性。</p><p>这个版本的翻转函数test2只解决了一半问题，对于接受一个左值引用的函数工作正常，但是对于接受右值引用的函数，却无法正常工作。</p><pre><code>// 接受一个右值引用和一个左值引用的函数void f(int&amp;&amp; i, int&amp;&amp; j) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;&#125;</code></pre><p>test2(f, i, 42); &#x2F;&#x2F; 错误：不能从一个左值实例化int&amp;&amp;<br>虽然test2的实参42是右值，但在test2内部调用f，传给f的实参将是test2的参数t2（值为42），而函数参数t2与其他任何变量一样，都是左值表达式。将左值实参直接传递给右值形参，将导致编译错误。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>C++11中，可以使用std::forward传递test2的参数，使它能保持原始实参的类型的所有细节。<br>当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个左值。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推导，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。<br>这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。</p><p>与move调用不同的是，forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用，i.e. forward返回类型为T&amp;&amp;。</p><p>使用forward重写test函数：</p><pre><code>// OKtemplate&lt;typename F, typename T1, typename T2&gt;void test3(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125;// 像这样调用不再有问题int i = 10, j = 20;test3(f, i, 20); // OK</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>c++中很多小巧的函数都通过完美转发实现了，比如make_pair,make_unique</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/p/8398734e.html"/>
      <url>/p/8398734e.html</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>传统C++的enum只要有作用域包含这个枚举类型，那么在这个作用域内这个枚举的变量名就生效了。即枚举量的名字泄露到了包含这个枚举类型的作用域内。在这个作用域内就不能有其他实体取相同的名字。所以在C++98中这个称之为不限范围的枚举型别</p><pre><code>enum Color&#123;black,white,red&#125;;//black、white、red作用域和color作用域相同auto white = false;//错误，white已经被声明过了</code></pre><h2 id="enum-class-的优点"><a href="#enum-class-的优点" class="headerlink" title="enum class 的优点"></a>enum class 的优点</h2><h3 id="防止命名空间污染"><a href="#防止命名空间污染" class="headerlink" title="防止命名空间污染"></a>防止命名空间污染</h3><p>enum class 将 { } 内的变量，加上 class 限制其在 { } 作用域内可见，是”域内枚举” (scoped enums)，可以防止命名空间污染</p><pre><code>// yellow, green, blue are scoped to Colorenum class Color &#123; yellow, green, blue&#125;;// fine, no other &quot;yellow&quot; in scopeauto yellow = false;// also fine　　auto c = Color::yellow;  </code></pre><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>传统的不限范围的枚举类是可以发生隐式转换的：</p><pre><code>enum Color&#123;black,white,red&#125;;std::vector&lt;std::size_t&gt; primeFactors(std::size_t x);//函数返回x的质因数Color c = red;if(c &lt; 14.5)//将color型别和double型别比较，发生隐式转换&#123;    auto factors = primeFactors(c);  //计算一个color型别的质因数，发生隐式转换&#125;</code></pre><p>限定作用域的枚举型别不允许发生任何隐式转换。如果非要转换，按就只能使用static_cast进行强制转换。</p><pre><code>enum class Color&#123;black,white,red&#125;;Color c = Color::red;if(c &lt; 14.5)//错误，不能将枚举类和double进行比较&#123;    auto factors = primeFactors(c); //错误，Color不能转化为size_t型别&#125;</code></pre><h3 id="可以前置声明"><a href="#可以前置声明" class="headerlink" title="可以前置声明"></a>可以前置声明</h3><p>在不指定类型的情况下允许前置声明：</p><pre><code>enum Color;//错误enum class Color;//正确</code></pre><p>如果你想enum前置声明，则需要指定底层型别</p><pre><code>enum Color:std:uint8_t;//提前指定底层型别，可以进行前置声明enum class Status:std::uint32_t&#123;//在定义中设置底层型别    good = 0,    failed = 1,    incomplate = 100&#125;;</code></pre><h2 id="enum优点"><a href="#enum优点" class="headerlink" title="enum优点"></a>enum优点</h2><p>传统的enum并非被完全取代了，在一种情况下它还是具有优势，即需要引用C++11中的std::tuple型别的各个域时。</p><pre><code>//********文件A********//using UserInfo = std::tuple&lt;std::string, //名字            std::string //邮件            std::size_t&gt;; //声望值//********文件B*******//UserInfo uInfo;auto val = std::get&lt;1&gt;(uInfo);  //取用域1的值</code></pre><p>在上述代码中，在文件B中我们要取tuple中第二个值，但是如果第一次接触这段代码，很难知道这第2个值到底是什么意思。使用不限范围的枚举型别和域序数关联就可以消除这种问题：</p><pre><code>eunm UserInfoFields&#123;uiName,uiEmail,uiReputation&#125;;UserInfo uInfo;auto val = std::get&lt;uiEmail&gt;(uInfo);  //一目了然，要去邮件这个值</code></pre><p>以上代码能够运行的原理就是不限范围的枚举类型可以隐式转换。而使用enum class来定义的话，由于限定作用域的枚举类型不接受隐式转换，就要使用static_cast进行强转，整个代码会变得很啰嗦。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特种成员函数的生成机制</title>
      <link href="/p/7296bf5f.html"/>
      <url>/p/7296bf5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="特种成员函数的生成机制"><a href="#特种成员函数的生成机制" class="headerlink" title="特种成员函数的生成机制"></a>特种成员函数的生成机制</h1><p>特种成员函数包括默认拷贝函数、析构函数、复制构造函数、复制赋值运算符、移动构造函数以及移动赋值运算符。<br>这些特种成员函数在特定场合，编译器都可以自动为其生成，且访问权限都是public的，inline类型的。</p><h2 id="特种成员函数的生成规则"><a href="#特种成员函数的生成规则" class="headerlink" title="特种成员函数的生成规则"></a>特种成员函数的生成规则</h2><p>一个类没有声明任何构造函数时，编译器才会自动生成默认构造函数。<br>两种复制（复制构造函数与复制赋值运算符）操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。<br>两种移动（移动构造函数与移动赋值运算符）操作是彼此不独立的：声明了其中一个，会阻止编译器生成另外一个。<br>如果你声明了复制构造函数，复制赋值运算符，或者析构函数中的任何一个，你就得同时声明所有的这个三个；<br>移动操作(移动拷贝构造函数和移动赋值运算符)仅当类中未包含用户显示声明的复制操作、移动操作和析构函数时编译器才会自动生成。<br>显式声明的析构函数会删除复制操作，<br>显式声明的移动操作也会删除复制操作</p><p>基类特种成员函数对派生类特种成员函数生成的影响</p><p>基类未定义(删除)的复制构造函数会阻止派生类默认复制构造函数的生成<br>基类未定义(删除)的复制赋值运算符会阻止派生类复制赋值运算符的生成<br>当基类的析构函数是虚函数时，编译器为子类生成的默认析构函数也才会是虚函数，且析构函数默认为noexcept的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++11对于特殊成员函数处理的规则如下：</p><p>默认构造函数：仅当类不存在用户声明的构造函数时才自动生成。<br>析构函数：基本上和C++98相同；稍微不同的是现在析构函数默认noexcept，和C++98一样，仅当基类析构为虚函数，派生类的析构函数才是虚的。<br>拷贝构造函数：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造时才生成。如果该类声明了移动操作，则复制构造函数将被删除。当用户声明了拷贝赋值运算符或析构函数时，拷贝构造函数不再自动生成。<br>拷贝赋值运算符：和C++98运行时行为一样：逐成员拷贝赋值非static数据。仅当类没有用户定义的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符就是delete。当用户声明了拷贝构造或者析构函数，拷贝赋值运算符不再自动生成。<br>移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动。仅当类中不包含用户声明的拷贝操作，移动操作和析构函数时才生成。<br>请注意，没有成员函数模板阻止编译器生成特殊成员函数的规则。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动语义</title>
      <link href="/p/27999.html"/>
      <url>/p/27999.html</url>
      
        <content type="html"><![CDATA[<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>对于移动语义，相关一个话题就是异常，对于移动构造函数来说，抛出异常有时候是个危险的事情，因为可能移动语义还没有完成一个异常就会抛出造成悬挂指针。因此移动构造函数应该为其添加一个noexception关键字，保证异常抛出以后直接调用terminate程序终止执行。</p><p>在标准库中，我们可以使用std::move_if_noexception来代替move函数，该函数在移动构造函数没有noexception关键字修饰的时候返回一个左值引用从而使变量使用拷贝语义。在移动构造函数有noexception关键字修饰的时候返回一个右值引用从而使变量使用移动语义。</p><p>与移动语义相关但是关联不多的一个话题是：RVO&#x2F;NRVO优化</p><pre><code>A returnRvalue()&#123;A a();return a;&#125;A b=returnRvalue();</code></pre><p>编译器优化后，从returnRvalue函数中a的变量拷贝  临时变量拷贝通通没有了，b变量实际上霸占了a变量。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/p/330a6169.html"/>
      <url>/p/330a6169.html</url>
      
        <content type="html"><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>变量捕获的开头是可选的默认捕获符 &#x3D; 或 &amp;，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：</p><ul><li>本地变量名标明对其按值捕获（不能在默认捕获符 &#x3D; 后出现；因其已自动按值捕获所有本地变量）</li><li>&amp; 加本地变量名标明对其按引用捕获（不能在默认捕获符 &amp; 后出现；因其已自动按引用捕获所有本地变量）</li><li>this 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 &#x3D; 和 &amp; 号可以自动捕获 this（并且在 C++20 之前，在 &#x3D;后写 this 会导致出错）</li><li>*this 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）<br>变量名 &#x3D; 表达式 标明按值捕获表达式的结果（可理解为 auto 变量名 &#x3D; 表达式）<br>&amp;变量名 &#x3D; 表达式 标明按引用捕获表达式的结果（可理解为 auto&amp; 变量名 &#x3D; 表达<br>式）</li></ul><h2 id="避免默认的捕获模式"><a href="#避免默认的捕获模式" class="headerlink" title="避免默认的捕获模式"></a>避免默认的捕获模式</h2><p>在c++11中，有两种默认的捕获模式：值捕获和引用捕获。一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长，默认的引用捕获可能会造成悬挂引用现象。<br>按引用捕获会导致闭包包含涉及到局部变量的引用，或者涉及到定义lambda式子的作用域内形参的引用。</p><pre><code>using FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters;void addDivisorFilter() &#123;    auto calc1 = computeSomeValue1();    auto calc2 = computeSomeValue2();        auto divisor = computeDivisor(calc1, calc2);        filters.emplace_back(// 危险，对divisor的指涉可能空悬！        [&amp;](int value)&#123; return value % divisor == 0;&#125;    );&#125;</code></pre><p>上述代码随时会出错，lambda式指涉到局部变量diviisor的引用，但该变量在addDivisorFilter返回时即不存在。<br>就算不这样做，换作以显示方式按引用捕获divisor，问题依旧。</p><pre><code>filters.emplace_back(// 危险，对divisor的指涉可能空悬！    [&amp;divisor](int value)&#123; return value % divisor == 0;&#125;</code></pre><p>解决这个问题的一个办法就是使用按值捕获的方式：</p><pre><code>filters.emplace_back(    [=](int value)&#123; return value % divisor == 0;&#125;</code></pre><p>*this 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>move</title>
      <link href="/p/64202.html"/>
      <url>/p/64202.html</url>
      
        <content type="html"><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><p>为什么要引入move，我们来看一个例子</p><pre><code>class A &#123;    public:        A()&#123;            std::cout &lt;&lt; &quot;A construct...&quot; &lt;&lt; std::endl;            ptr_ = new int(100);        &#125;        A(const A &amp; a)&#123;            std::cout &lt;&lt; &quot;A copy construct ...&quot; &lt;&lt; std::endl;            ptr_ = new int();            memcpy(ptr_, a.ptr_, sizeof(int));        &#125;        ~A()&#123;            std::cout &lt;&lt; &quot;A deconstruct ...&quot; &lt;&lt; std::endl;            if(ptr_)&#123;                delete ptr_;            &#125;        &#125;        A&amp; operator=(const A &amp; a) &#123;            std::cout &lt;&lt; &quot; A operator= ....&quot; &lt;&lt; std::endl;            return *this;        &#125;        int * getVal()&#123;            return ptr_;        &#125;    private:        int *ptr_;&#125;;int main(int argc, char *argv[])&#123;    std::vector&lt;A&gt; vec;    vec.push_back(A());&#125;</code></pre><p>输出结果</p><pre><code>A construct...          //main中创建的A对象A copy construct ...    //vector内部创建的A对象A deconstruct ...       //vector内部创建的A对象被析构A deconstruct ...       //main中创建的A对象析构</code></pre><p>但是如果使用move：</p><pre><code>class A &#123;    public:        ...        A(A &amp;&amp; a)&#123;            std::cout &lt;&lt; &quot;A move construct ...&quot; &lt;&lt; std::endl;            ptr_ = a.ptr_;            a.ptr_ = nullptr;        &#125;        ...&#125;;int main()&#123;    std::vector&lt;A&gt; vec;    vec.push_back(std::move(A())); &#125;</code></pre><p>输出结果</p><pre><code>A construct...          //main中创建的A对象A move construct ...    //vector内部创建的A对象A deconstruct ...       //vector内部创建的A对象被析构A deconstruct ...       //main中创建的A对象析构</code></pre><p>可以看到td::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p><p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。</p><p>std::move是为性能而生。std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。</p><p>例如：</p><pre><code>#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;string&gt;int main()&#123;    std::string str = &quot;Hello&quot;;    std::vector&lt;std::string&gt; v;    //调用常规的拷贝构造函数，新建字符数组，拷贝数据    v.push_back(str);    std::cout &lt;&lt; &quot;After copy, str is \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    //调用移动构造函数，掏空str，掏空后，最好不要使用str    v.push_back(std::move(str));    std::cout &lt;&lt; &quot;After move, str is \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    std::cout &lt;&lt; &quot;The contents of the vector are \&quot;&quot; &lt;&lt; v[0]                                        &lt;&lt; &quot;\&quot;, \&quot;&quot; &lt;&lt; v[1] &lt;&lt; &quot;\&quot;\n&quot;;&#125;</code></pre><p>输出：</p><pre><code>After copy, str is &quot;Hello&quot;After move, str is &quot;&quot;The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;</code></pre><h2 id="move实现"><a href="#move实现" class="headerlink" title="move实现"></a>move实现</h2><p>在分析std::move()与std::forward()之前，先看看remove_reference，下面是remove_reference的实现：</p><pre><code>template&lt;typename _Tp&gt;struct remove_reference&#123; typedef _Tp   type; &#125;;// 特化版本template&lt;typename _Tp&gt;struct remove_reference&lt;_Tp&amp;&gt;&#123; typedef _Tp   type; &#125;;template&lt;typename _Tp&gt;struct remove_reference&lt;_Tp&amp;&amp;&gt;&#123; typedef _Tp   type; &#125;;</code></pre><p>remove_reference的作用是去除T中的引用部分，只获取其中的类型部分。无论T是左值还是右值，最后只获取它的类型部分。</p><h3 id="std-forward源码剖析"><a href="#std-forward源码剖析" class="headerlink" title="std::forward源码剖析"></a>std::forward源码剖析</h3><p>转发左值</p><pre><code>template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept&#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125;</code></pre><p>先通过获得类型type，定义_t为左值引用的左值变量，通过static_cast进行强制转换。_Tp&amp;&amp;会发生引用折叠，当_Tp推导为左值引用，则折叠为_Tp&amp; &amp;&amp;，即_Tp&amp;，当推导为右值引用，则为本身_Tp&amp;&amp;，即forward返回值与static_cast处都为_Tp&amp;&amp;。</p><p>转发右值</p><pre><code>template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept&#123;    static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot;            &quot; substituting _Tp is an lvalue reference type&quot;);    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125;</code></pre><p>不同于转发左值，_t为右值引用的左值变量，除此之外中间加了一个断言，表示当不是左值的时候，也就是右值，才进行static_cast转换。</p><h3 id="std-move-源码剖析"><a href="#std-move-源码剖析" class="headerlink" title="std::move()源码剖析"></a>std::move()源码剖析</h3><pre><code>// FUNCTION TEMPLATE movetemplate &lt;class _Ty&gt;_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept &#123; // forward _Arg as movable    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);&#125;</code></pre><p>std::move的功能是：</p><ul><li>传递的是左值，推导为左值引用，仍旧static_cast转换为右值引用。</li><li>传递的是右值，推导为右值引用，仍旧static_cast转换为右值引用。</li><li>在返回处，直接范围右值引用类型即可。还是通过renive_reference获得_Tp类型，然后直接type&amp;&amp;即可。<br>所以std::remove_reference&lt;_Tp&gt;::type&amp;&amp;，就是一个右值引用，我们就知道了std::move干的事情了。</li></ul><h2 id="std-move使用场景"><a href="#std-move使用场景" class="headerlink" title="std::move使用场景"></a>std::move使用场景</h2><p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，避免拷贝，从而提升程序性能。 在没有右值引用之前，一个简单的数组类通常实现如下，有构造函数、拷贝构造函数、赋值运算符重载、析构函数等。</p><pre><code>class Array &#123;public:    Array(int size) : size_(size) &#123;        data = new int[size_];    &#125;        // 深拷贝构造    Array(const Array&amp; temp_array) &#123;        size_ = temp_array.size_;        data_ = new int[size_];        for (int i = 0; i &lt; size_; i ++) &#123;            data_[i] = temp_array.data_[i];        &#125;    &#125;        // 深拷贝赋值    Array&amp; operator=(const Array&amp; temp_array) &#123;        delete[] data_;        size_ = temp_array.size_;        data_ = new int[size_];        for (int i = 0; i &lt; size_; i ++) &#123;            data_[i] = temp_array.data_[i];        &#125;    &#125;    ~Array() &#123;        delete[] data_;    &#125;public:    int *data_;    int size_;&#125;;</code></pre><p>该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个移动构造函数，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::move和std::forword</title>
      <link href="/p/39842.html"/>
      <url>/p/39842.html</url>
      
        <content type="html"><![CDATA[<h1 id="std-move和std-forword"><a href="#std-move和std-forword" class="headerlink" title="std::move和std::forword"></a>std::move和std::forword</h1><h2 id="两者异同点"><a href="#两者异同点" class="headerlink" title="两者异同点"></a>两者异同点</h2><p>相同点：std::move并不进行任何移动操作，std::forward也并不进行任何转发操作，都只是仅仅执行强制类型转换的模版函数。<br>不同点：std::move无条件地将实参强制转换成右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。</p><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>来看一个简单的std::move的示例实现，他不符合标准的所有细节，但十分接近了。</p><pre><code>template&lt;typename T&gt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;move(T&amp;&amp; param) &#123; // 万能引用    // 确保返回的一定是右值引用    using ReturnType = typename std::remove_reference&lt;T&gt;::type&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param); // 类型转换&#125;</code></pre><p>此外，std::move在C++14中可以被更简单地实现。利用函数返回值类型推导和标准库的模板别名std::remove_reference_t，std::move可以这样写：</p><pre><code>template&lt;typename T&gt;decltype(auto) move(T&amp;&amp; param)          //C++14，仍然在std命名空间&#123;    using ReturnType = remove_referece_t&lt;T&gt;&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param);&#125;</code></pre><h3 id="保留常量属性"><a href="#保留常量属性" class="headerlink" title="保留常量属性"></a>保留常量属性</h3><p>move移动过程实际上就是一个类型转换的过程，但是这并不改变T的常量性；<br>举例如下：</p><pre><code>class Annotation &#123;public:    explicit Annotation(const std::string test) : value_(std::move(test)) &#123;&#125;private:    std::string value_;&#125;;class string &#123; // std::string实际是std::basic_string&lt;char&gt;的typedefpublic:    string(const std::string&amp;); // 拷贝构造函数（形参为const）    string(std::string&amp;&amp;);      // 移动构造函数（形参非const）&#125;;</code></pre><p>实际上在这儿调用的是拷贝构造函数进行了复制操作，并非是被移动的。具体原因：<br>std::move仅仅做引用类型的转换，const常量属性依旧会被保留下来。也就是test经过std::move后返回类型为const std::string的右值引用。<br>移动构造函数、移动赋值运算符因为会更改被移动对象的成员变量值，因此其形参不是const类型，也就是实参不能是常量右值引用。<br>复制构造函数、赋值运算符的形参类型为常量的左值引用，其可以绑定到常量右值引用的实参，因此可以调用复制构造函数、赋值运算符。<br>这种行为是为了保证原对象的常量属性。只要对象是const类型，即是经过std::move也不能更改其常量属性，也就不能传递给可能更改对象值的函数（移动构造函数、移动赋值运算符）。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>std::forward通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。<br>示例实现</p><pre><code>template&lt;class T&gt;constexpr T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; arg) noexcept&#123;    // forward an lvalue as either an lvalue or an rvalue    return (static_cast&lt;T&amp;&amp;&gt;(arg));&#125;template&lt;class T&gt;constexpr T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp;&amp; arg) noexcept&#123;    // forward an rvalue as an rvalue    return (static_cast&lt;T&amp;&amp;&gt;(arg));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nullptr</title>
      <link href="/p/1199.html"/>
      <url>/p/1199.html</url>
      
        <content type="html"><![CDATA[<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。在某种意义上来说，传统 C++ 会把 NULL、 0 视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。<br>C++ 不允许直接将 void * 隐式转 换到其他类型，但如果NULL 被定义为 ((void*)0)，那么当编译 char *ch &#x3D; NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导致了 C++ 中重载特性 会发⽣混乱，考虑：<br>    void func(int);<br>    void func(char *);<br>对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL) 这个语句将 会去调⽤ func(int)，从⽽导致代码违反直观。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr 出现的⽬的是为了替代 NULL。<br>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。C++11 引⼊了 nullptr 关键字，专⻔⽤来区分空指针、0.值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：<br>int * a1 &#x3D; nullptr;<br>char * a2 &#x3D; nullptr;<br>double * a3 &#x3D; nullptr;<br>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。<br>当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shared_ptr</title>
      <link href="/p/78b58054.html"/>
      <url>/p/78b58054.html</url>
      
        <content type="html"><![CDATA[<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>基本原理:记录对象被引用的次数，当引用次数为 0 的时候，也就是最后一个指向该对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。<br>特点:它所指向的资源具有共享性，即多个shared_ptr可以指向同一份资源，并在内部使用引用计数机制来实现这一点。</p><p>共享指针内存：每个 shared_ptr 对象在内部指向两个内存位置：</p><ul><li>指向对象的指针；</li><li>用于控制引用计数数据的指针。<br>shared_ptr像普通指针一样使用，可以将*和-&gt;与 shared_ptr 对象一起使用，也可以像其他 shared_ptr 对象一样进行比较;</li></ul><h2 id="shared-ptr的创建"><a href="#shared-ptr的创建" class="headerlink" title="shared_ptr的创建"></a>shared_ptr的创建</h2><p>当使用<code>shared_ptr</code>时，以下是一些常见的用法和操作：</p><ol><li><p>创建一个空的<code>shared_ptr</code>：</p><pre><code class="cpp">shared_ptr&lt;T&gt; ptr; // ptr 类似于一个空指针，即指向 NULL</code></pre></li><li><p>通过<code>new</code>操作符创建一个新的对象并初始化<code>shared_ptr</code>：</p><pre><code class="cpp">shared_ptr&lt;T&gt; ptr(new T());</code></pre></li><li><p>使用拷贝构造函数创建一个新的<code>shared_ptr</code>，引用计数会增加：</p><pre><code class="cpp">shared_ptr&lt;T&gt; ptr2(ptr1);// 可以将 shared_ptr 作为函数参数传递，或者作为函数的返回值返回，这实际上也是使用拷贝构造函数。</code></pre></li><li><p>如果类型 B 是类型 A 的子类，可以使用<code>dynamic_pointer_cast</code>函数进行类型转换，并创建一个新的<code>shared_ptr</code>：</p><pre><code class="cpp">shared_ptr&lt;B&gt; ptrb(new B());shared_ptr&lt;A&gt; ptra(dynamic_pointer_cast&lt;A&gt;(ptrb));</code></pre></li><li><p><code>shared_ptr</code>的赋值操作：</p><pre><code class="cpp">shared_ptr&lt;T&gt; a(new T());shared_ptr&lt;T&gt; b(new T());a = b; // 此后 a 原先所指的对象会被销毁，b 所指的对象的引用计数加 1// shared_ptr 也可以直接赋值，但必须是赋给相同类型的 shared_ptr 对象，不能是普通的 C 指针或 new 运算符的返回值。// 当共享指针 a 被赋值为 b 时，如果 a 原先为 NULL，直接将 a 设置为 b 并增加所指对象的引用计数；// 如果 a 原先指向其他对象，a 被赋值为 b 时，原先所指对象的引用计数减 1，新指向的对象的引用计数加 1。</code></pre></li><li><p>重置已定义的<code>shared_ptr</code>以指向一个新的对象：</p><pre><code class="cpp">shared_ptr&lt;T&gt; ptr(new T());ptr.reset(new T()); // 原先所指的对象会被销毁</code></pre></li><li><p>make_shared辅助函数创建</p><pre><code class="cpp">std::shared_ptr&lt;int&gt; foo = std::make_shared&lt;int&gt; (10);</code></pre></li></ol><p>推荐使用std::make_shared<T>来创建 </T></p><h2 id="自定义释放规则"><a href="#自定义释放规则" class="headerlink" title="自定义释放规则"></a>自定义释放规则</h2><p>自定义所指堆内存的释放规则<br>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。<br>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。<br>对于申请的动态数组，释放规则可以<br>使用 C++11 标准中提供的 default_delete 模板类<br>可以自定义释放规则</p><pre><code>//指定 default_delete 作为释放规则std::shared_ptr&lt;int&gt; p6(new int[10]std::default_delete&lt;int[]&gt;());//自定义释放规则void deleteInt(int*p) &#123;    delete []p;&#125;//初始化智能指针，并自定义释放规则std::shared_ptr&lt;int&gt; p7(new int[10], deleteInt);</code></pre><p>实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：</p><pre><code>std::shared_ptr&lt;int&gt; p7(new int[10], [](int* p) &#123;delete[]p; &#125;);</code></pre><h2 id="shared-ptr常用函数"><a href="#shared-ptr常用函数" class="headerlink" title="shared_ptr常用函数"></a>shared_ptr常用函数</h2><table><thead><tr><th>成员方法名</th><th>功能</th></tr></thead><tbody><tr><td>operator&#x3D;</td><td>重载赋值号，使得同一类型的shared_ptr智能指针可以相互赋值。</td></tr><tr><td>operator*</td><td>重载 * 号，获取当前shared_ptr智能指针对象指向的数据。</td></tr><tr><td>operator-&gt;</td><td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr><tr><td>swap</td><td>交换两个相同类型shared_ptr智能指针的内容。</td></tr><tr><td>reset</td><td>当函数没有实参时，该函数会使当前shared_ptr所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的shared_ptr对象会获得该存储空间的所有权，并且引用计数的初始值为 1</td></tr><tr><td>get</td><td>获得shared_ptr对象内部包含的普通指针</td></tr><tr><td>use_count</td><td>返回与当前shared_ptr对象（包括它）指向相同的所有shared_ptr对象的数量。</td></tr><tr><td>unique</td><td>判断当前shared_ptr对象指向的堆内存，是否不再有其它shared_ptr对象再指向它。</td></tr><tr><td>operator bool</td><td>判断当前shared_ptr对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td></tr></tbody></table><h2 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>template&lt;typename T&gt;class SharedPtr&#123;public:    explicit SharedPtr();    explicit SharedPtr(T *_ptr);    SharedPtr(const SharedPtr&amp; p);  // 拷贝构造函数    ~SharedPtr();    // 拷贝赋值运算符(左边的值减少，右边的值增加)    SharedPtr&amp; operator=(const SharedPtr&amp; p);    // 解引用运算符    T&amp; operator*();    // 箭头运算符    T* operator-&gt;();    // 重载布尔值操作    operator bool();    T* get() const;    size_t use_count();    bool unique();    void swap(SharedPtr&amp; p);private:    size_t *count;    T *ptr;&#125;;template&lt;typename T&gt;SharedPtr&lt;T&gt;::SharedPtr() : count(new size_t(0)), ptr(nullptr)&#123;&#125;template&lt;typename T&gt;SharedPtr&lt;T&gt;::SharedPtr(T *_ptr) : count(new size_t(1)), ptr(_ptr)&#123;&#125;template&lt;typename T&gt;SharedPtr&lt;T&gt;::~SharedPtr()&#123;    --(*count);    if(*count &lt;= 0) &#123;        delete ptr;        delete count;        ptr = nullptr;        count = nullptr;    &#125;    std::cout &lt;&lt; &quot;shared ptr destory.&quot; &lt;&lt; std::endl;&#125;template&lt;typename T&gt;SharedPtr&lt;T&gt;::SharedPtr(const SharedPtr &amp;p)&#123;    count = p.count;    ptr = p.ptr;    ++(*count);&#125;template&lt;typename T&gt;SharedPtr&lt;T&gt;&amp; SharedPtr&lt;T&gt;::operator=(const SharedPtr &amp;p)&#123;    // 如果是原指针，直接返回    if(ptr == p.ptr) &#123;        return *this;    &#125;    if(ptr) &#123;        --(*count);        if((*count) == 0) &#123;            delete ptr;            delete count;        &#125;    &#125;    ptr = p.ptr;    count = p.count;    ++(*count);    return *this;&#125;template&lt;typename T&gt;T&amp; SharedPtr&lt;T&gt;::operator*()&#123;    return *ptr;&#125;template&lt;typename T&gt;T* SharedPtr&lt;T&gt;::operator-&gt;()&#123;    return ptr;&#125;template&lt;typename T&gt;SharedPtr&lt;T&gt;::operator bool()&#123;    return ptr != nullptr;&#125;template&lt;typename T&gt;T* SharedPtr&lt;T&gt;::get() const&#123;    return ptr;&#125;template&lt;typename T&gt;size_t SharedPtr&lt;T&gt;::use_count()&#123;    return *count;&#125;template&lt;typename T&gt;bool SharedPtr&lt;T&gt;::unique()&#123;    return *count == 1;&#125;template&lt;typename T&gt;void SharedPtr&lt;T&gt;::swap(SharedPtr&amp; p)&#123;    std::swap(*this, p);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unique_ptr</title>
      <link href="/p/39842.html"/>
      <url>/p/39842.html</url>
      
        <content type="html"><![CDATA[<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。通常我们可以认为std::unique_ptr和原始指针有一样的尺寸，并且对于多数操作（包括解引用），它和原始指针有几乎相同的CPU指令。这意味着你可以在内存和CPU紧张的地方使用它，如果普通的原始指针对你够快够用的话，那么std::unique_ptr几乎也是够用的。因此，要想使用unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</memory></T></p><pre><code>#include &lt;memory&gt;using namespace std;</code></pre><p>unique_ptr是一个只移型别。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>通过以下  2 种方式，可以创建出空的 unique_ptr 指针：</p><pre><code>std::unique_ptr&lt;int&gt; p1();std::unique_ptr&lt;int&gt; p2(nullptr);</code></pre><p>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</p><pre><code>std::unique_ptr&lt;int&gt; p3(new int);</code></pre><p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数（后续c++14有了）。未初始化的 unique_ptr 表示空指针，这样就相当于直接操作了空指针，运行时就会产生致命的错误（比如 core dump）。为了避免这种低级错误，可以调用工厂函数 make_unique()，强制创建智能指针的时候必须初始化。</T></p><p>如果使用的c++11也可以简单实现该函数，并不是很复杂：</p><pre><code class="cpp">template&lt;class T, class... Args&gt;std::unique_ptr&lt;T&gt; my_make_unique(Args&amp;&amp;... args)&#123;    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));&#125;</code></pre><p>上述代码是一个简化版的<code>make_unique()</code>函数的实现，适用于C++11标准。它使用了可变参数模板和完美转发来构造一个<code>std::unique_ptr</code>对象并返回。</p><p>使用该函数可以替代C++14中引入的<code>make_unique()</code>函数，用于创建动态分配的对象的智能指针。</p><p>示例用法：</p><pre><code class="cpp">auto ptr = my_make_unique&lt;MyClass&gt;(arg1, arg2, arg3);</code></pre><p>C++14及更高版本已经提供了标准的<code>make_unique()</code>函数，无需手动实现。上述代码只适用于C++11标准下不支持<code>make_unique()</code>的情况下使用。</p><p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 std::move 来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><p>unique_ptr 独占智能指针类也有一个 reset 方法，函数原型如下：</p><pre><code>void reset( pointer ptr = pointer() ) noexcept;</code></pre><p>使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p><pre><code>int main()&#123;    unique_ptr&lt;int&gt; ptr1(new int(10));    unique_ptr&lt;int&gt; ptr2 = move(ptr1);    ptr1.reset();    ptr2.reset(new int(250));    return 0;&#125;</code></pre><p>ptr1.reset(); 解除对原始内存的管理<br>ptr2.reset(new int(250)); 重新指定智能指针管理的原始内存</p><p>如果想要获取独占智能指针管理的原始地址，可以调用 get () 方法，<br>函数原型如下：</p><pre><code>pointer get() const noexcept;</code></pre><p>函数用法示例</p><pre><code>int main()&#123;    unique_ptr&lt;int&gt; ptr1(new int(10));    unique_ptr&lt;int&gt; ptr2 = move(ptr1);    ptr2.reset(new int(250));    cout &lt;&lt; *ptr2.get() &lt;&lt; endl;// 得到内存地址中存储的实际数值 250    return 0;&#125;</code></pre><h2 id="unique-ptr的实现"><a href="#unique-ptr的实现" class="headerlink" title="unique_ptr的实现"></a>unique_ptr的实现</h2><pre><code>template &lt;typename T&gt; struct PointerDeleter&#123;    void operator()(const T *ptr) &#123;        if(ptr) &#123;            delete ptr;            ptr = nullptr;        &#125;    &#125;&#125;;template &lt;typename T, typename Deleter = PointerDeleter&lt;T&gt; &gt;class UniquePtr&#123;public:    UniquePtr();    UniquePtr(T *_ptr);    UniquePtr(UniquePtr &amp;&amp;p); // 移动构造函数    ~UniquePtr();// non-copyableprivate:    UniquePtr(const UniquePtr &amp;p);    UniquePtr &amp;operator=(const UniquePtr &amp;p);public:    T&amp; operator* ();    T* operator-&gt; ();    UniquePtr &amp;operator=(UniquePtr &amp;&amp;p); // 移动赋值，右值    operator bool() const;    // 返回原始指针    T* get() const;    // 返回指针，释放所有权    T* release();    // 替换被管理的对象    void reset(T *_ptr);    // 交换被管理的对象    void swap(UniquePtr &amp;p);private:    T *ptr;&#125;;template &lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;::UniquePtr() : ptr(nullptr)&#123;&#125;template &lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;::UniquePtr(T *_ptr) : ptr(_ptr)&#123;&#125;// 移交所有权template &lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;::UniquePtr(UniquePtr &amp;&amp;p) : ptr(p.ptr)&#123;    p.ptr = nullptr;&#125;// 析构函数template&lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;::~UniquePtr() &#123;    Deleter()(ptr);    std::cout &lt;&lt; &quot;unique ptr destory.&quot; &lt;&lt; std::endl;&#125;// template&lt;typename T, typename Deleter&gt;T&amp; UniquePtr&lt;T, Deleter&gt;::operator*()&#123;    return *ptr;&#125;// template&lt;typename T, typename Deleter&gt;T* UniquePtr&lt;T, Deleter&gt;::operator-&gt;()&#123;    return ptr;&#125;// template&lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;&amp; UniquePtr&lt;T, Deleter&gt;::operator=(UniquePtr &amp;&amp;p) &#123;    std::swap(ptr, p.ptr);    return *this;&#125;template&lt;typename T, typename Deleter&gt;UniquePtr&lt;T, Deleter&gt;::operator bool() const &#123;    return ptr != nullptr;&#125;template&lt;typename T, typename Deleter&gt;T* UniquePtr&lt;T, Deleter&gt;::get() const &#123;    return ptr;&#125;template&lt;typename T, typename Deleter&gt;T* UniquePtr&lt;T, Deleter&gt;::release()&#123;    T *pointer = ptr;    ptr = nullptr;    return pointer;&#125;template&lt;typename T, typename Deleter&gt;void UniquePtr&lt;T, Deleter&gt;::reset(T *_ptr) &#123;    UniquePtr&lt;T, Deleter&gt;().swap(*this);    ptr = _ptr;&#125;template&lt;typename T, typename Deleter&gt;void UniquePtr&lt;T, Deleter&gt;::swap(UniquePtr &amp;p) &#123;    std::swap(ptr, p.ptr);&#125;</code></pre><p>从中可以看到，unique_ptr禁用了拷贝构造和拷贝赋值构造，仅仅实现了移动构造和移动赋值构造，这也就使得它是独占式的。</p><h2 id="unique-ptr的基本使用"><a href="#unique-ptr的基本使用" class="headerlink" title="unique_ptr的基本使用"></a>unique_ptr的基本使用</h2><p>下面是一个unique_ptr的例子,此处的res是在栈上的局部变量，在main()结束时会被销毁，它管理的资源也会被释放掉。</p><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptrstruct Resource&#123;    Resource() &#123; std::cout &lt;&lt; &quot;Resource acquired\n&quot;; &#125;    ~Resource() &#123; std::cout &lt;&lt; &quot;Resource destroyed\n&quot;; &#125;&#125;;int main()&#123;    // allocate a Resource object and have it owned by std::unique_ptr    std::unique_ptr&lt;Resource&gt; res&#123; new Resource() &#125;;    return 0;&#125; // the allocated Resource is destroyed here</code></pre><p>std::unique_ptr实现的是专属所有权语义，其只支持移动，不支持复制，也不能将一个裸指针直接赋值给std::unique_ptr对象，编译器禁止这种隐式转换。默认的std::unique_ptr的析构函数将调用delete完成指针删除操作，当然，如果默认的析构函数不满足要求，我们也可以自定义析构函数，代码实现及运行结果如下：</p><pre><code>class MyTest &#123;public:    //自定义类构造函数    MyTest() &#123;        cout &lt;&lt; &quot;MyTest&quot; &lt;&lt; endl;    &#125;;    //自定义类析构函数    ~MyTest() &#123;        cout &lt;&lt; &quot;~MyTest&quot; &lt;&lt; endl;    &#125;;&#125;;int main()&#123;    &#123;        //std::unique_ptr的自定义析构函数，t可以为MyTest类型及其子类        auto MyDelete = [](MyTest* t) &#123;            cout &lt;&lt; &quot;MyDelete&quot; &lt;&lt; endl;            delete t;        &#125;;        //智能指针初始化        std::unique_ptr&lt;MyTest,decltype(MyDelete)&gt; p(new MyTest, MyDelete);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weak_ptr</title>
      <link href="/p/5b46547.html"/>
      <url>/p/5b46547.html</url>
      
        <content type="html"><![CDATA[<h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>std: :weak_ptr 一般者是通过 std: : shared _ptr 来创建的。当使用 std: :shared_ptr 完成初始化 std::weak_ptr 的时刻，两者就指涉到了相同位置</p><p>弱智能指针weak_ptr区别于shared_ptr之处在于：</p><ul><li>weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在</li><li>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li><li>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源</li></ul><h2 id="weak-ptr内几个重要成员函数："><a href="#weak-ptr内几个重要成员函数：" class="headerlink" title="weak_ptr内几个重要成员函数："></a>weak_ptr内几个重要成员函数：</h2><ul><li>成员函数use_count() 观测资源引用计数</li><li>成员函数expired() 功能相当于 use_count()&#x3D;&#x3D;0 表示被观测的资源(也就是shared_ptr的管理的资源)是否被销毁</li><li>成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 进而操作资源。但当expired()&#x3D;&#x3D;true的时候，lock()函数将返回一个存储空指针的shared_ptr</li></ul><h2 id="使用weak-ptr"><a href="#使用weak-ptr" class="headerlink" title="使用weak_ptr"></a>使用weak_ptr</h2><h3 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h3><p>定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。<br>class B; &#x2F;&#x2F; 前置声明类B<br>class A<br>{<br>public:<br>    A() { cout &lt;&lt; “A()” &lt;&lt; endl; }<br>    <del>A() { cout &lt;&lt; “</del>A()” &lt;&lt; endl; }<br>    weak_ptr<B> _ptrb; &#x2F;&#x2F; 指向B对象的弱智能指针。引用对象时，用弱智能指针<br>};<br>class B<br>{<br>public:<br>    B() { cout &lt;&lt; “B()” &lt;&lt; endl; }<br>    <del>B() { cout &lt;&lt; “</del>B()” &lt;&lt; endl; }<br>    weak_ptr<A> _ptra; &#x2F;&#x2F; 指向A对象的弱智能指针。引用对象时，用弱智能指针<br>};<br>int main()<br>{<br>    &#x2F;&#x2F; 定义对象时，用强智能指针<br>    shared_ptr<A> ptra(new A());&#x2F;&#x2F; ptra指向A对象，A的引用计数为1<br>    shared_ptr<B> ptrb(new B());&#x2F;&#x2F; ptrb指向B对象，B的引用计数为1</B></A></A></B></p><pre><code>// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变ptra-&gt;_ptrb = ptrb;// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变ptrb-&gt;_ptra = ptra;cout &lt;&lt; ptra.use_count() &lt;&lt; endl; // 打印结果:1cout &lt;&lt; ptrb.use_count() &lt;&lt; endl; // 打印结果:1/*出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”*/return 0;</code></pre><p>}</p><h3 id="线程安全的对象回调与析构"><a href="#线程安全的对象回调与析构" class="headerlink" title="线程安全的对象回调与析构"></a>线程安全的对象回调与析构</h3><p>有时候我们需要“如果对象还活着，就调用它的成员函数，否则忽略之”的语意，就像Observable::notifyObservers()。这也是可以实现的，利用weak_ptr，我们可以把weak_ptr绑到boost::function里，这样对象的生命期就不会被延长。然后在回调的时候先尝试提升为shared_ptr，如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就不必劳神了。</p><p>线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。</p><pre><code>class Test&#123;public:    // 构造Test对象，_ptr指向一块int堆内存，初始值是20    Test() :_ptr(new int(20))     &#123;        cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl;    &#125;    // 析构Test对象，释放_ptr指向的堆内存    ~Test()    &#123;        delete _ptr;        _ptr = nullptr;        cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;    &#125;    // 该show会在另外一个线程中被执行    void show()    &#123;        cout &lt;&lt; *_ptr &lt;&lt; endl;    &#125;private:    int *volatile _ptr;&#125;;void threadProc(weak_ptr&lt;Test&gt; pw) // 通过弱智能指针观察强智能指针&#123;    // 睡眠两秒    std::this_thread::sleep_for(std::chrono::seconds(2));    /*     如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升    为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存    的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象    已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。    */    shared_ptr&lt;Test&gt; ps = pw.lock();    if (ps != nullptr)    &#123;        ps-&gt;show();    &#125;&#125;int main()&#123;    // 在堆上定义共享对象    shared_ptr&lt;Test&gt; p(new Test);    // 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针    std::thread t1(threadProc, weak_ptr&lt;Test&gt;(p));    // 在main线程中析构Test共享对象    // 等待子线程运行结束    t1.join();    return 0;&#125;</code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>template&lt;typename T&gt;class WeakPtr&#123;public:    WeakPtr() &#123;&#125;;    WeakPtr(const SharedPtr&lt;T&gt; &amp;p) : ptr(p.get())    &#123;&#125;    ~WeakPtr()    &#123;&#125;    WeakPtr&lt;T&gt;&amp; operator=(const WeakPtr &amp;p)    &#123;        ptr = p.ptr;        return *this;    &#125;    T&amp; operator*()    &#123;        return *ptr;    &#125;    T* operator-&gt;()    &#123;        return ptr;    &#125;    operator bool()    &#123;        return ptr != nullptr;    &#125;private:    // weak point 只引用，不计数    T *ptr;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/p/24227.html"/>
      <url>/p/24227.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul><li>并行是指两个或多个独立的操作同时进行。</li><li>并发是指一个时间段内执行多个操作。</li></ul><p><strong>线程：</strong> 线程是操作系统能够进行CPU调度的最小单位，它被包含在进程之中，一个进程可包含单个或者多个线程。可以用多个线程去完成一个任务，也可以用多个进程去完成一个任务，它们的本质都相当于多个人去合伙完成一件事。</p><p><strong>多线程并发：</strong> 多线程是实现并发的一种手段，多线程并发即多个线程同时执行,一般而言，多线程并发就是把一个任务拆分为多个子任务，然后交由不同线程处理不同子任务,使得这多个子任务同时执行。</p><p><strong>C++多线程并发：</strong>  （简单情况下）实现C++多线程并发程序的思路如下：将任务的不同功能交由多个函数分别实现，创建多个线程，每个线程执行一个函数，一个任务就这样同时分由不同线程执行了。</p><p><a href="https://imgse.com/i/ppISCnO"><img src="https://s1.ax1x.com/2023/04/05/ppISCnO.png" alt="c++多线程.png"></a></p><h2 id="C-11-多线程相关的头文件："><a href="#C-11-多线程相关的头文件：" class="headerlink" title="C++11 多线程相关的头文件："></a>C++11 多线程相关的头文件：</h2><ul><li><p>atomic：该头文件主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</p></li><li><p>thread：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。</p></li><li><p>mutex：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock，std::try_lock std::lock_guard, std::unique_lock, 以及其他的类型和函数。</p></li><li><p>condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。</p></li><li><p>future：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。</p></li></ul><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>首先要引入头文件#include<thread>，管理线程的函数和类在该头文件中声明，其中包括std::thread类。<br>语句”std::thread th1(proc1);”创建了一个名为th1的线程，并且线程th1开始执行。</thread></p><pre><code>#include&lt;iostream&gt;#include&lt;thread&gt;using namespace std;void proc1(int &amp;a)&#123;    cout &lt;&lt; &quot;我是子线程,传入参数为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;子线程中显示子线程id为&quot; &lt;&lt; this_thread::get_id()&lt;&lt; endl;&#125;int main()&#123;    cout &lt;&lt; &quot;我是主线程&quot; &lt;&lt; endl;    int a = 9;    //第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。    thread th1(proc1,ref(a));    cout &lt;&lt; &quot;主线程中显示子线程id为&quot; &lt;&lt; th1.get_id() &lt;&lt; endl;    //此处省略多行，不要在创建完线程后马上join,应该在程序结束前join    th1.join()；//此时主线程被阻塞直至子线程执行结束。    return 0;&#125;</code></pre><p>如果仅仅是调用无参数的构造函数，不会启动一个新的线程，直到指定了线程函数。</p><pre><code>std::vector&lt;std::thread&gt; threads(10); // 此时没有启动线程​for(int i=0;i&lt;10;++i)&#123;    threads[i]=std::thread(do_some_work);    // 此时才启动线程&#125;</code></pre><h3 id="C-11-std-thread源码"><a href="#C-11-std-thread源码" class="headerlink" title="C++11 std::thread源码"></a>C++11 std::thread源码</h3><pre><code>class thread&#123;    //.....    thread() noexcept : _Thr&#123;&#125; &#123;&#125;    explicit thread(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;        //.....        _Thr._Hnd =reinterpret_cast&lt;void*&gt;(_CSTD _beginthreadex(nullptr, 0,                                           _Invoker_proc,_Decay_copied.get(), 0, &amp;_Thr._Id));    &#125;    ~thread() noexcept &#123;        if (joinable()) &#123;            _STD terminate();        &#125;    &#125;&#125;;</code></pre><h3 id="如何传递参数"><a href="#如何传递参数" class="headerlink" title="如何传递参数"></a>如何传递参数</h3><p>新拉起的线程肯定是开辟新的参数副本，这样就能避免临界区竞争、访问已经被析构的变量等问题。<br><code>std::thread</code>拉起一个新线程，会进行两次copy：</p><ul><li>第一次在调用std::thread构造函数时，会在新线程保存一份变量。可以是赋值构造、也可以是移动构造；</li><li>第二次在把保存的变量传递给线程函数时，这里统一是用std::move，即移动构造；</li></ul><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>下面是一个示例</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Para&#123;public:    Para() &#123; cout &lt;&lt; &quot;Create Para&quot; &lt;&lt; endl; &#125;    Para(const Para&amp; p) &#123; cout &lt;&lt; &quot;Copy Para&quot; &lt;&lt; endl; &#125;    ~Para() &#123; cout &lt;&lt; &quot;Drop Para&quot; &lt;&lt; endl; &#125;    string name;&#125;;void ThreadMain(int p1, float p2, string str, Para p4)&#123;    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;ThreadMain &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt;&quot; &quot;&lt;&lt;p4.name&lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    thread th;    &#123;        float f1 = 12.1f;        Para p;        p.name = &quot;test Para class&quot;;        //所有的参数做复制        th =  thread(ThreadMain, 101, f1, &quot;test string para&quot;,p);    &#125;    th.join();    return 0;&#125;</code></pre><p>输出结果</p><pre><code>Create ParaCopy ParaDrop ParaCopy ParaThreadMain 101 12.1 test string paraDrop ParaDrop Para</code></pre><p>示例2：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;//Linux -lpthreadusing namespace std;class Para&#123;public:    Para() &#123; cout &lt;&lt; &quot;Create Para&quot; &lt;&lt; endl; &#125;    Para(const Para&amp; p) &#123; cout &lt;&lt; &quot;Copy Para&quot; &lt;&lt; endl; &#125;    Para(Para&amp;&amp; p) &#123; cout &lt;&lt; &quot;move Para&quot; &lt;&lt; endl; &#125;    ~Para() &#123; cout &lt;&lt; &quot;Drop Para&quot; &lt;&lt; endl; &#125;    string name;&#125;;void ThreadMain(int p1, float p2, string str, Para p4)&#123;    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;ThreadMain &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt;&quot; &quot;&lt;&lt;p4.name&lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    thread th;    &#123;    float f1 = 12.1f;    Para p;    p.name = &quot;test Para class&quot;;    //所有的参数做复制    th =  thread(ThreadMain, 101, f1, &quot;test string para&quot;,p);    &#125;    th.join();    return 0;&#125;</code></pre><p>输出结果</p><pre><code>Create ParaCopy ParaDrop Paramove ParaThreadMain 101 12.1 test string paraDrop ParaDrop Para</code></pre><p>可以看到有移动拷贝则使用移动拷贝，否则使用赋值拷贝</p><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>因为新的线程是开辟了新的参数副本，但这样做也有缺点，不能用引用传递参数了，也就不能修改原值。<br>这时我们需要用c++11提供的std::ref这个模板函数，它会返回一个类，本质上是维护了一个指针，所有操作都会改变指针指向的变量，相当于起到引用的功能。</p><p>举个例子：</p><pre><code>void update_data_for_widget(widget_id w,widget_data&amp; data); // 引用传参void oops_again(widget_id w)&#123;    widget_data data;    std::thread t(update_data_for_widget,w,data); // error 右值不可以匹配到左值引用    display_status();    t.join();&#125;</code></pre><p>因为在第二次传参时，发生了std::move强转为右值，不能匹配widget_data&amp;左值引用，自然报错。如果非要用引用传参，需要用std::ref。</p><p>把那一行代码改为std::thread t(update_data_for_widget,w,std::ref(data));就可以了。</p><p>我们会发现std::thread和std::bind的参数传递过程很像，先在本地copy一份副本，当真正执行时，再把参数传入到执行函数。本质上是因为thread和bind都不知道用户何时执行，为了避免发生悬挂指针等错误，保存一份副本是值得的行为。</p><h4 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h4><p>在向线程函数传递参数时，我们需要注意以下场景：</p><p>浅拷贝了一个指针<br>    void f(int i,std::string const&amp; s);<br>    void oops(int some_param)<br>    {<br>        char buffer[1024];<br>        sprintf(buffer, “%i”,some_param);<br>        std::thread t(f,3,buffer);<br>        t.detach();<br>    }<br>buffer是数组指针，在构造时采用浅拷贝，只拷贝了buffer指针，所以新的线程还是访问了主线程的buffer[1024]。让事情雪上加霜的是，采用非阻塞式detach，这意味着很有可能新线程在访问数组时，数组已经被析构了！</p><p>解决方法是采用深拷贝，在传入前转换为std::string：</p><pre><code>void f(int i,std::string const&amp; s);void oops(int some_param)&#123;    char buffer[1024];     sprintf(buffer, &quot;%i&quot;,some_param);    std::thread t(f,3,std::string(buffer)); // 避免悬挂指针    t.detach(); &#125;</code></pre><h4 id="使用成员函数作为参数"><a href="#使用成员函数作为参数" class="headerlink" title="使用成员函数作为参数"></a>使用成员函数作为参数</h4><pre><code>class MyThread&#123;public:    //入口线程函数    void Main()    &#123;        cout &lt;&lt; &quot;MyThread Main &quot; &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; age;    &#125;    string name;    int age = 100;&#125;;int main()&#123;    MyThread myth;    myth.name = &quot;Test name 001&quot;;    myth.age = 20;    //需要传入对象地址    thread th(&amp;MyThread::Main, &amp;myth);    th.join();    return 0;&#125;</code></pre><h4 id="使用lambda表达式作为参数"><a href="#使用lambda表达式作为参数" class="headerlink" title="使用lambda表达式作为参数"></a>使用lambda表达式作为参数</h4><pre><code>class TestLambda&#123;public:    void Start()    &#123;        thread th([this]() &#123;cout &lt;&lt; &quot;name = &quot; &lt;&lt; name &lt;&lt; endl; &#125;);        th.join();    &#125;    string name = &quot;test lambda&quot;;&#125;;int main()&#123;    thread th(        [](int i) &#123;cout &lt;&lt; &quot;test lmbda &quot; &lt;&lt; i &lt;&lt; endl; &#125;,        123    );    th.join();    TestLambda test;    test.Start();    return 0;&#125;</code></pre><h2 id="线程等待和分离"><a href="#线程等待和分离" class="headerlink" title="线程等待和分离"></a>线程等待和分离</h2><p>detach其实就是一个守护线程。</p><p>守护进程的概念：发起就遗忘，即使当前进程运行到结束，但守护进程依旧继续执行，直到整个程序被关闭了。总而言之，守护进程不需要.join()等待了，拉起来就让它一直伴随左右。<br>由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。<br>但是守护进程却能够突破这种限制，它从被执行开始运转，直到接收到某种信号或者整个系统关闭时才会退出。如果想让某个进程不因为用户、终端或者其他的变化而受到影响，那么就必须把这个进程变成一个守护进程。</p><p>此外，std::thread还有一个joinable()方法用于检测线程是否有效。<br>joinable：代表该线程是可执行线程（即刚初始化完成，拥有线程所有权，且没结束运行）<br>not-joinable：通常一下几种情况会导致线程成为not-joinable：</p><ul><li>由thread的缺省构造函数构造而成(thread()没有参数)；</li><li>该thread被move过（包括move构造和move赋值）；</li><li>该线程调用过join或者detach（调用过后就置为non-joinable）；</li></ul><p>线程不安全行为<br>下面介绍detach和join这两种情况下的不安全行为：<br>detach。由于detach不阻塞，很有可能访问到已经析构的对象。如：</p><pre><code>struct func&#123;    int&amp; i;    func(int&amp; i_) : i(i_) &#123;&#125;    void operator() ()    &#123;        for (unsigned j=0 ; j&lt;1000000 ; ++j)        &#123;            do_something(i); // 潜在访问隐患： 悬空引用        &#125;    &#125;&#125;;​void oops()&#123;    int some_local_state=0;    func my_func(some_local_state);    std::thread my_thread(my_func);    my_thread.detach();     // detach不等待线程结束，所以很有可能变量i已经析构了&#125;</code></pre><p>join。当发生异常时，容易忘记执行join。</p><pre><code>struct func; void f()&#123;    int some_local_state=0;    func my_func(some_local_state);    std::thread t(my_func);    try&#123;        do_something_in_current_thread();    &#125;    catch(...)&#123;        t.join();         throw;    &#125;    t.join(); &#125;</code></pre><p>当发生异常这类特殊情况时，join很容易遗漏，发生不安全的行为。</p><pre><code>class thread_guard&#123;private:    std::thread&amp; t;public:    explicit thread_guard(std::thread&amp; t_):t(t_)&#123;&#125;        ~thread_guard()&#123;        if(t.joinable())&#123; // 是否是可执行的线程            t.join();         &#125;    &#125;&#125;;</code></pre><h2 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h2><p>std:call_once的作用，确保函数或代码片段在多线程环境下，只需要执行一次，常用的场景如Init()操作或一些系统参数的获取等。<br>相对来说，std::call_once用法比较简单，配合std::once_flag即可实现，先声明一个 once_flag 类型的变量，最好是静态、全局的（线程可见），作为初始化的标志，然后调用专门的 call_once() 函数，以函数式编程的方式，传递这个标志和初始化函数。代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::once_flag flag;void Initialize()&#123;    std::cout &lt;&lt; &quot;Run into Initialize..&quot; &lt;&lt; std::endl;&#125;void Init()&#123;    std::call_once(flag, Initialize);&#125;int main()&#123;    std::thread t1(Init);    std::thread t2(Init);    std::thread t3(Init);    std::thread t4(Init);    t1.join();    t2.join();    t3.join();    t4.join();&#125;</code></pre><p>最终Initialize()只调用了一次，call_once() 完全消除了初始化时的并发冲突，在它的调用位置根本看不到并发和线程。</p><h2 id="多线程状态"><a href="#多线程状态" class="headerlink" title="多线程状态"></a>多线程状态</h2><p><a href="https://imgse.com/i/ppIPYoF"><img src="https://s1.ax1x.com/2023/04/05/ppIPYoF.png" alt="ppIPYoF.png"></a></p><ul><li><p>初始化状态：在执行new Thread(s)，线程对象一旦创建就进入初始化状态</p></li><li><p>就绪状态：在线程对象创建完成后调用start方法，但是线程不会立刻调度执行，而是进入就绪状态，因为在运行前还有一些准备工作要做</p></li><li><p>运行状态：准备工作完成后进入运行状态，一个运行状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间（Java的规范说明没有将它作为一个单独状态，准确的说这个状态应该是可运行状态，因为任何时刻，这个状态的某个线程可能正在运行也可能没有运行）</p></li><li><p>阻塞状态： 当一个线程被插队、礼让别的线程或者休眠时就会进入到阻塞状态，阻塞状态解除后回到就绪状态，等待CPU调度执行</p></li><li><p>退出状态 当一个运行状态的线程自然执行完毕后或者中断后线程进入退出状态，退出后无法再次启动</p></li></ul><h3 id="竞争状态和临界状态"><a href="#竞争状态和临界状态" class="headerlink" title="竞争状态和临界状态"></a>竞争状态和临界状态</h3><ul><li><p>竞争条件</p><ul><li>竞争条件是指多个任务以非互斥的方式同时进入临界区， 大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。</li></ul></li><li><p>临界区</p><ul><li>程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。怕有同学看得不仔细，强调一下，临界区是指程序中那些访问公共资源的指令代码，即临界区是指令，并不是受访的静态公共资源。</li></ul></li><li><p>互斥</p><ul><li>互斥也可称为排他， 是指某一时刻公共资源只能被 1 个任务独享， 即不允许多个任务同时出现在自己的临界区中。公共资源在任意时刻只能被一个任务访问，即只能有一个任务在自己的临界区中执行，其他任务想访问公共资源时，必须等待当前公共资源的访问者完全执行完他自己的临界区代码后（使用完资源后）再开始访问。</li></ul></li></ul><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。<br>mutex常用操作：</p><ul><li>lock()：资源上锁</li><li>unlock()：解锁资源</li><li>trylock()：查看是否上锁，它有下列3种类情况：<ul><li>未上锁返回false，并锁住；</li><li>其他线程已经上锁，返回true；</li><li>同一个线程已经对它上锁，将会产生死锁。</li></ul></li></ul><p>通过锁可以防止临界区的冲突</p><pre><code>#include &lt;iostream&gt;  // std::cout#include &lt;thread&gt;  // std::thread#include &lt;mutex&gt;  // std::mutexstd::mutex mtx;  // mutex for critical sectionvoid print_block (int n, char c) &#123;    mtx.lock();    for (int i=0; i&lt;n; ++i)     &#123;        std::cout &lt;&lt; c;     &#125;    std::cout &lt;&lt; &#39;\n&#39;;    mtx.unlock();&#125;int main ()&#123;    std::thread th1 (print_block,50,&#39;&#39;);//线程1：打印*    std::thread th2 (print_block,50,&#39;$&#39;);//线程2：打印$    th1.join();    th2.join();    return 0;&#125;</code></pre><h4 id="互斥锁需要注意的地方"><a href="#互斥锁需要注意的地方" class="headerlink" title="互斥锁需要注意的地方"></a>互斥锁需要注意的地方</h4><p>多线程锁有一个问题就是在解锁之后立刻请求锁，这样会导致可能一个线程一直占用着锁导致其他线程无法获得锁。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;using namespace std;static mutex mux;void ThreadMainMux(int i)&#123;    for (;;)    &#123;        mux.lock();        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        mux.unlock();    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadMainMux, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><p>解决的一个办法是解锁后等待一个时间段以后再重新请求锁</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;//Linux -lpthreadusing namespace std;static mutex mux;void ThreadMainMux(int i)&#123;    for (;;)    &#123;        mux.lock();        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        mux.unlock();        //this_thread::sleep_for(1ms);    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadMainMux, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h3 id="超时锁"><a href="#超时锁" class="headerlink" title="超时锁"></a>超时锁</h3><p>功能：避免长时间死锁，可以记录锁获取情况，多次超时，可以记录日志，获取错误情况<br>由于try_lock(）不会阻塞该线程，那么将会一直占着CPU资源，因此加入sleep_for(100ms)延时给其他线程一点机会，然而延时是调用的this_thread下的函数：</p><pre><code>if (!mux.try_lock())&#123;    cout &lt;&lt; &quot;.&quot; &lt;&lt; flush;    this_thread::sleep_for(100ms);    continue;&#125;</code></pre><p>c++还提供了另外一个解决方法，就是使用超时锁</p><pre><code>timed_mutex tmux;void ThreadMainTime(int i)&#123;    for (;;)    &#123;        if (!tmux.try_lock_for(chrono::milliseconds(500)))        &#123;             //如果未在规定时间内拿到锁，那么这段代码可能会出现问题，这里可以进行日志的写入，便于调试            cout &lt;&lt; i &lt;&lt; &quot;[try_lock_for timeout]&quot; &lt;&lt; endl;            continue;        &#125;        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(2000ms);        tmux.unlock();        this_thread::sleep_for(1ms);    &#125;&#125;</code></pre><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>递归锁允许同一个线程多次获取该互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;struct Complex&#123;    std::mutex mutex;    int i;    Complex() : i(0)&#123;&#125;    void mul(int x)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        i *= x;    &#125;    void div(int x)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        i /= x;    &#125;    void both(int x, int y)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        mul(x);        div(y);    &#125;&#125;;int main(void)&#123;    Complex complex;    complex.both(32, 23);    return 0;&#125;</code></pre><p>运行后出现死锁的情况。在调用both时获取了互斥量，在调用mul时又要获取互斥量，但both的并没有 释放，从而产生死锁。</p><p>使用递归锁解决同一个线程的死锁问题：</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;struct Complex&#123;    std::recursive_mutex mutex;    int i;    Complex() : i(0)&#123;&#125;    void mul(int x)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        i *= x;    &#125;    void div(int x)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        i /= x;    &#125;    void both(int x, int y)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        mul(x);        div(y);    &#125;&#125;;int main(void)&#123;    Complex complex;    complex.both(32, 23); //因为同一线程可以多次获取同一互斥量，不会发生死锁    std::cout &lt;&lt; &quot;main finish\n&quot;;    return 0;&#125;</code></pre><h3 id="共享锁-shared-mutex"><a href="#共享锁-shared-mutex" class="headerlink" title="共享锁 shared_mutex"></a>共享锁 shared_mutex</h3><p>C++17起，shared_mutex 类是一个同步原语，可用于保护共享数据不被多个线程同时访问。与便于独占访问的其他互斥类型不同，shared_mutex 拥有二个访问级别：</p><ul><li>共享 - 多个线程能共享同一互斥的所有权；</li><li>独占性 - 仅一个线程能占有互斥。<br>1）若一个线程已经通过lock或try_lock获取独占锁（写锁），则无其他线程能获取该锁（包括共享的）。尝试获得读锁的线程也会被阻塞。<br>2）仅当任何线程均未获取独占性锁时，共享锁（读锁）才能被多个线程获取（通过 lock_shared 、try_lock_shared ）。<br>3）在一个线程内，同一时刻只能获取一个锁（共享或独占性）。</li></ul><p>按照如下代码，读取只能有一个线程进入，在很多业务场景中，没有充分利用 cpu 资源</p><pre><code>//读取 同时只能有一个线程读取mux.lock();cout&lt;&lt;share&lt;&lt;endl;mux.unlock();//写入mux.lock() share++; mux.unlock()</code></pre><p>可以看到这个无论读还是写都无法并行处理，显然读操作即上面打印操作是可以并行的</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;using namespace std;//c++17  共享锁//shared_mutex smux;//c++14 shared_timed_mutex stmux;void ThreadRead(int i)&#123;    for (;;)    &#123;        stmux.lock_shared();        cout &lt;&lt; i &lt;&lt; &quot; Read&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        stmux.unlock_shared();        this_thread::sleep_for(1ms);    &#125;&#125;void ThreadWrite(int i)&#123;    for (;;)    &#123;        stmux.lock_shared();        //读取数据        stmux.unlock_shared();        stmux.lock(); //互斥锁 写入        cout &lt;&lt; i &lt;&lt; &quot; Write&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        stmux.unlock();        this_thread::sleep_for(1ms);    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadWrite, i + 1);        th.detach();    &#125;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadRead, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="RAII风格锁"><a href="#RAII风格锁" class="headerlink" title="RAII风格锁"></a>RAII风格锁</h2><p><strong>什么是RAII：</strong><br>资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期绑定与一个对象的生存期相绑定。<br><strong>RAII 可总结如下:</strong><br>将每个资源封装入一个类，其中构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，析构函数释放资源并决不抛出异常；始终经由 RAII 类的实例使用满足要求的资源，该资源自身拥有自动存储期或临时生存期，或具有与自动或临时对象的生存期绑定的生存期。移动语义使得在对象间，跨作用域，以及在线程内外安全地移动所有权，而同时维护资源安全成为可能。</p><p>手动实现一个最简单的RAII锁：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;using namespace std;class XMutex&#123;public:    XMutex(mutex&amp; mux):mux_(mux)    &#123;        mux.lock();    &#125;    ~XMutex()    &#123;        mux_.unlock();    &#125;private:    mutex&amp; mux_;&#125;;static mutex mux;void TestMutex(int status)&#123;    XMutex test(mux);    if (status == 1)    &#123;        cout &lt;&lt; &quot;=1&quot; &lt;&lt; endl;        return;    &#125;    else    &#123;        cout &lt;&lt; &quot;!=1&quot; &lt;&lt; endl;        return;    &#125;&#125;int main(int argc, char* argv[])&#123;    TestMutex(1);    TestMutex(2);    getchar();    return 0;&#125;</code></pre><p>上面是一个最简单的体现RAII思维的锁，还需要实现模板，移动语义以及如果构造参数传入的锁锁住以后防止死锁等。</p><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p>这是构造互斥锁的写法，会在lock_guard构造函数里加锁，在析构函数里解锁，这个写法，C++委员会的解释是防止使用mutex加锁解锁的时候，忘记解锁unlock了。</p><pre><code>template &lt;class _Mutex&gt;class lock_guard &#123; public:    using mutex_type = _Mutex;    explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123;         _MyMutex.lock();    &#125;    lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123;&#125;    ~lock_guard() noexcept &#123;        MyMutex.unlock();    &#125;    lock_guard(const lock_guard&amp;) = delete;     lock_guard&amp; operator=(const lock_guard&amp;) = delete;&#125;；</code></pre><p>可以看到锁的所有权是不会改变的，拷贝构造移动构造都被禁止使用了<br>下面这个例子利用了lock_guard自动对锁进行释放<br>    #include <iostream><br>    #include <thread><br>    #include <string><br>    #include <mutex><br>    using namespace std;</mutex></string></thread></iostream></p><pre><code>mutex mt;void thread_task()&#123;    for (int i = 0; i &lt; 1000; i++)    &#123;        lock_guard&lt;mutex&gt; guard(mt);        cout &lt;&lt; &quot;print thread: &quot; &lt;&lt; i &lt;&lt; endl;    &#125;&#125;int main()&#123;    thread t(thread_task);    for (int i = 0; i &gt; -1000; i--)    &#123;        lock_guard&lt;mutex&gt; guard(mt);        cout &lt;&lt; &quot;print main: &quot; &lt;&lt; i &lt;&lt; endl;    &#125;    t.join();    return 0;&#125;</code></pre><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p>虽然lock_guard挺好用，但他有个很大的缺陷，在定义lock_guard的地方会调用构造函数加锁，在离开定义域的话lock_guard就会被销毁，调用析构函数解锁。这就产生了一个问题，如果这个定义域范围很大的话，那么锁的粒度就很大，很大程序上会影响效率。为了解决lock_guard锁的粒度过大的原因，unique_lock就出现了。<br>unique_lock C++11 实现可移动的互斥体所有权包装器</p><ul><li>支持临时释放锁 unlock</li><li>支持 adopt_lock（已经拥有锁，不加锁，出栈区会释放） </li><li>支持 defer_lock （延后拥有，不加锁，出栈区不释放）</li><li>支持 try_to_lock 尝试获得互斥的所有权而不阻塞 ，获取失败退出栈区不会释放，通过owns_lock()函数判断</li><li>支持超时参数，超时不拥有锁</li></ul><h4 id="unique-lock的第二个参数"><a href="#unique-lock的第二个参数" class="headerlink" title="unique_lock的第二个参数"></a>unique_lock的第二个参数</h4><p>unique_lock 可以带第二个参数：<br>std::unique_lock<a href="std::mutex">std::mutex</a> sbguard1(my_mutex1, std::adopt_lock);&#x2F;&#x2F; std::adopt_lock标记作用；</p><h5 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h5><p>表示这个互斥量已经被lock了（你必须要把互斥量提前lock了 ，否者会报异常）；std::adopt_lock标记的效果就是假设调用一方已经拥有了互斥量的所有权（已经lock成功了）；通知lock_guard不需要再构造函数中lock这个互斥量了。<br>unique_lock也可以带std::adopt_lock标记，含义相同，就是不希望再unique_lock()的构造函数中lock这个mutex。<br>用std::adopt_lock的前提是，自己需要先把mutex lock上；用法与lock_guard相同。</p><h5 id="std-try-to-lock"><a href="#std-try-to-lock" class="headerlink" title="std::try_to_lock"></a>std::try_to_lock</h5><p>try_to_lock的意思是尝试加锁，它的好处就是——当线程A拿不到锁的时候，线程A不会等在那里，它会去做一些别的事情，用这个try_to_lock的前提是你自己不能先lock。</p><h5 id="std-defer-lock"><a href="#std-defer-lock" class="headerlink" title="std::defer_lock"></a>std::defer_lock</h5><p>用std::defer_lock的前提是，你不能自己先lock,否则会报异常，std::defer_lock的意思就是并没有给mutex加锁：初始化了一个没有加锁的mutex。我们借着defer_lock的话题，来介绍一些unique_lock的重要成员函数。</p><h3 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h3><p>shared_lock  c++14开始引入<br>类 shared_lock 是通用共享互斥所有权包装器（unique_lock则是独占互斥所有权包装器），允许延迟锁定、定时锁定和锁所有权的转移。锁定 shared_lock，会以共享模式锁定关联的共享互斥</p><pre><code>//共享锁static shared_timed_mutex  tmux;//读取锁 共享锁&#123;    //调用共享锁     shared_lock&lt;shared_timed_mutex&gt; lock(tmux);    cout &lt;&lt; &quot;read data&quot; &lt;&lt; endl;    //退出栈区 释放共享锁&#125;//写入锁 互斥锁&#123;    unique_lock&lt;shared_timed_mutex&gt; lock(tmux);    cout &lt;&lt; &quot;write data&quot; &lt;&lt; endl;&#125;</code></pre><p>shared_lock是read lock。被锁后仍允许其他线程执行同样被shared_lock的代码。这是一般做读操作时的需要。<br>unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。在写操作时，一般用这个，可以同时限制unique_lock的写和share_lock的读。</p><h3 id="scoped-lock区域锁"><a href="#scoped-lock区域锁" class="headerlink" title="scoped_lock区域锁"></a>scoped_lock区域锁</h3><p>scoped_lock C++17<br>将多个锁（std::mutex等）包装成一种锁类型，用于线程一次性申请多个锁，避免死锁。<br>scoped_lock使用std::lock函数，其会调用一个特殊的算法对所提供的互斥量调用try_lock函数，这是为了避免死锁。因此，在加锁与解锁的顺序相同的情况下，使用scoped_lock或对同一组锁调用std::lock都是非常安全的。可以同时对一堆锁同时加锁，要么同时成功，要么加锁同时失败，不会出现死锁情况。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;void TestScope1()&#123;    //模拟死锁 停100ms等另一个线程锁mux2    this_thread::sleep_for(100ms);     cout &lt;&lt;this_thread::get_id()&lt;&lt; &quot; begin mux1 lock&quot; &lt;&lt; endl;    //mux1.lock();    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux2 lock&quot; &lt;&lt; endl;    //mux2.lock(); //死锁    //c++11    // lock(mux1, mux2);    //c++17     scoped_lock lock(mux1, mux2); // 解决死锁        cout &lt;&lt; &quot;TestScope1&quot; &lt;&lt; endl;    this_thread::sleep_for(1000ms);        //mux1.unlock();    //mux2.unlock();&#125;void TestScope2()&#123;    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux2 lock&quot; &lt;&lt; endl;    mux2.lock();    this_thread::sleep_for(500ms);    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux1 lock&quot; &lt;&lt; endl;    mux1.lock();//死锁    cout &lt;&lt; &quot;TestScope2&quot; &lt;&lt; endl;    this_thread::sleep_for(1500ms);    mux1.unlock();    mux2.unlock();&#125;int main(int argc, char* argv[])&#123;    //演示死锁情况    &#123;        thread th(TestScope1);        th.detach();    &#125;    &#123;        thread th(TestScope2);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待<br>条件变量的条件成立而挂起;另一个线程使条件成立（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥量结合在一起。</p><h3 id="改变共享变量的线程步骤"><a href="#改变共享变量的线程步骤" class="headerlink" title="改变共享变量的线程步骤"></a>改变共享变量的线程步骤</h3><p><strong>准备好信号量</strong></p><pre><code>std::condition_variable cv;</code></pre><p><strong>1获得 std::mutex （常通过 std::unique_lock ）</strong></p><pre><code>unique_lock lock(mux);</code></pre><p><strong>2在获取锁时进行修改</strong></p><pre><code>msgs_.push_back(data);</code></pre><p><strong>3释放锁并通知读取线程</strong></p><pre><code>lock.unlock();cv.notify_one(); //通知一个等待信号线程cv.notify_all(); //通知所有等待信号线程</code></pre><h3 id="等待信号读取共享变量的线程步骤"><a href="#等待信号读取共享变量的线程步骤" class="headerlink" title="等待信号读取共享变量的线程步骤"></a>等待信号读取共享变量的线程步骤</h3><p>wait函数有三个，分别为wait、wait_for、wait_until，这里着重介绍一下wait方法：<br>wait函数有以下两个版本：</p><pre><code>void wait (unique_lock&lt;mutex&gt;&amp; lck);template&lt;class Predicate&gt;void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred);</code></pre><p>参数lck</p><ul><li>一个加了锁的unique_lock对象，所有调用了当前条件变量wait方法的对象都应该在下层使用同一个mutex对象。</li></ul><p>参数pred</p><ul><li>一个可以调用的对象或者函数，函数或者对象没有参数并且需要返回一个bool类型的值，线程将会不停的调用wait函数直到该返回值为true;</li></ul><p><strong>获得与改变共享变量线程共同的mutex</strong></p><pre><code>unique_lock lock(mux);</code></pre><p><strong>wait() 等待信号通知</strong><br>无lambada 表达式</p><pre><code>//解锁lock,并阻塞等待 notify_one notify_all 通知cv.wait(lock);</code></pre><p>lambada 表达式</p><pre><code>cv.wait(lock, [] &#123;return !msgs_.empty();&#125;); </code></pre><p>对于以上两个版本的函数，其使用效果如下所示，且以下示例等价：<br>    std::mutex mtx;<br>    std::condition_variable cv;<br>    bool isReady;<br>    &#x2F;&#x2F;写法一<br>    while(true) {<br>        sleep(1);<br>        std::unique_lock<a href="std::mutext">std::mutext</a> lk(mtx);<br>        while (!isReady) {<br>            cv.wait(lk);<br>        }<br>    }<br>    &#x2F;&#x2F;写法二<br>    while (true) {<br>        sleep(1);<br>        std::unique_lock<a href="std::mutext">std::mutext</a> lk(mtx);<br>        cv.wait(lk, []{return isReady;});<br>    }</p><p>只在 std::unique_lock<a href="std::mutex">std::mutex</a> 上工作的 std::condition_variable</p><pre><code>void wait(unique_lock&lt;mutex&gt;&amp; _Lck) &#123;     // wait for signal    // Nothing to do to comply with LWG‐2135 because std::mutex lock/unlock are nothrow    _Check_C_return(_Cnd_wait(_Mycnd(), _Lck.mutex()‐&gt;_Mymtx()));&#125;template &lt;class _Predicate&gt;void wait(unique_lock&lt;mutex&gt;&amp; _Lck, _Predicate _Pred) &#123;     // wait for signal and test predicate    while (!_Pred())    &#123;         wait(_Lck);    &#125;&#125;</code></pre><p>代码示例：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;list&lt;string&gt; msgs_;mutex mux;condition_variable cv;void ThreadWrite()&#123;    for (int i = 0;;i++)    &#123;        stringstream ss;        cout &lt;&lt; &quot;write msg &quot; &lt;&lt; i &lt;&lt; endl;        ss &lt;&lt; &quot;msg &quot; &lt;&lt; i;        unique_lock&lt;mutex&gt; lock(mux);        msgs_.push_back(ss.str());        lock.unlock();        cv.notify_one(); //发送信号        this_thread::sleep_for(3000ms);    &#125;&#125;void ThreadRead(int i)&#123;    while(1)    &#123;        unique_lock&lt;mutex&gt; lock(mux);        //cv.wait(lock);//解锁、阻塞等待信号        cv.wait(lock, [i]         &#123;            return !msgs_.empty();         &#125;);        //获取信号后锁定        while (!msgs_.empty())        &#123;            cout &lt;&lt; &quot;ThreadRead &quot; &lt;&lt; i &lt;&lt; &quot; read &quot; &lt;&lt; msgs_.front() &lt;&lt; endl;            msgs_.pop_front();        &#125;    &#125;&#125;int main(int argc, char* argv[])&#123;    thread th(ThreadWrite);    th.detach();    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadRead, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="线程异步和通信"><a href="#线程异步和通信" class="headerlink" title="线程异步和通信"></a>线程异步和通信</h2><h3 id="promise-和-future"><a href="#promise-和-future" class="headerlink" title="promise 和 future"></a>promise 和 future</h3><p>future和promise的作用是在不同线程之间传递数据。使用指针也可以完成数据的传递，但是指针非常危险，因为互斥量不能阻止指针的访问；而且指针的方式传递的数据是固定的，如果更改数据类型，那么还需要更改有关的接口，比较麻烦；promise支持泛型的操作，更加方便编程处理。</p><ul><li>promise 用于异步传输变量<ul><li>std::promise 提供存储异步通信的值，再通过其对象创建的std::future异步获得结果。</li><li>std::promise 只能使用一次。 void set_value(_Ty&amp;&amp; _Val) 设置传递值，只能掉用一次</li></ul></li><li>std::future 提供访问异步操作结果的机制<ul><li>get() 阻塞等待promise set_value 的值</li></ul></li></ul><p>下面是一个例子，可以看到如果没有set  get会一直堵塞住</p><pre><code>#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;future&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;cstdlib&gt;void thread_set_promise(std::promise&lt;int&gt;&amp; p) &#123;    std::this_thread::sleep_for(std::chrono::milliseconds(3000));    p.set_value(35);&#125;int main() &#123;    std::promise&lt;int&gt; p;    std::future&lt;int&gt; f = p.get_future();    std::thread t(&amp;thread_set_promise, std::ref(p));    std::cout &lt;&lt; f.get() &lt;&lt; std::endl;    t.join();    getchar();    return 0;&#125;</code></pre><p>三秒后屏幕输出35 ，get一直堵塞，直到set函数调用以后截止</p><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::packaged_task的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个函数操作，并将其返回值传递给对应的future，而这个future在另外一个线程中也可以安全的访问到这个值。与bind的区别，可异步调用，函数访问和获取返回值分开调用</p><pre><code>#include &lt;iostream&gt;     // std::cout#include &lt;future&gt;       // std::packaged_task, std::future#include &lt;chrono&gt;       // std::chrono::seconds#include &lt;thread&gt;       // std::thread, std::this_thread::sleep_forusing namespace std;int countdown(int from, int to) &#123;    for (int i = from; i != to; --i) &#123;        std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;        std::this_thread::sleep_for(1s);    &#125;    std::cout &lt;&lt; &quot;Lift off!\n&quot;;    return from - to;&#125;int main()&#123;    std::packaged_task&lt;int(int, int)&gt; tsk(countdown);   // set up packaged_task    std::future&lt;int&gt; ret = tsk.get_future();            // get future    std::thread th(std::move(tsk), 10, 0);   // spawn thread to count down from 10 to 0    int value = ret.get();                  // wait for the task to finish and get result    std::cout &lt;&lt; &quot;The countdown lasted for &quot; &lt;&lt; value &lt;&lt; &quot; seconds.\n&quot;;    th.join();    return 0;&#125;</code></pre><h3 id="async-创建异步线程"><a href="#async-创建异步线程" class="headerlink" title="async 创建异步线程"></a>async 创建异步线程</h3><p>std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用 线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取。它解耦了线程的创建和执行，使得我们可以在需要的时候获取异步 操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），使得我们可以以多种方式去创建线程。另外，这里还有一个很隐蔽的“坑”，如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数），于是“async”就变成了“sync”。所以，即使我们不关心返回值，也总要用 auto 来配合 async()，避免同步阻塞，</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;string&gt;using namespace std;string TestAsync(int index)&#123;    this_thread::sleep_for(2s);    return &quot;test&quot;;&#125;int main(int argc, char* argv[])&#123;    //不创建线程启动异步任务    auto future = async(launch::deferred, TestAsync,100);    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;future.get() = &quot; &lt;&lt; future.get() &lt;&lt; endl&lt;&lt;endl;    //创建异步线程    auto future2 = async(TestAsync, 101);    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;future2.get() = &quot; &lt;&lt; future2.get() &lt;&lt; endl;    getchar();    return 0;&#125;</code></pre><p>std::async 可以延迟调用，在get的时候调用函数。但是下面是启动了一个线程，该线程会直接启动执行。std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选</p><pre><code>//#include &lt;execution&gt; c++17 std::for_each(std::execution::par, //并行计算 多核in_data.begin(), in_data.end(),[&amp;]()&#123;&#125;); //多线程进入此函数</code></pre><h2 id="c-20-线程特性"><a href="#c-20-线程特性" class="headerlink" title="c++20 线程特性"></a>c++20 线程特性</h2><h3 id="std-barrier-屏障"><a href="#std-barrier-屏障" class="headerlink" title="std::barrier 屏障"></a>std::barrier 屏障</h3><ul><li>arrive<ul><li>到达屏障并减少期待计数</li></ul></li><li>wait<ul><li>在阶段同步点阻塞，直至运行其阶段完成步骤</li></ul></li><li>arrive_and_wait <ul><li>到达屏障并把期待计数减少一，然后阻塞直至当前阶段完成</li></ul></li><li>arrive_and_drop<ul><li>将后继阶段的初始期待计数和当前阶段的期待计数均减少一</li></ul></li></ul><p>下面是一个示例，目前使用的vs2019不支持，并没有下载最新版vs进行测试。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;barrier&gt;using namespace std;void TestBar(int i, barrier&lt;&gt;* bar)&#123;    this_thread::sleep_for(chrono::seconds(i));    cout &lt;&lt; i &lt;&lt; &quot; begin wait&quot; &lt;&lt; endl;    bar-&gt;wait(bar-&gt;arrive()); //期待数 -1 阻塞等待，期待为0是返回    cout &lt;&lt; i &lt;&lt; &quot; end wait&quot; &lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    int count = 3;    barrier bar(count);//初始数量    for (int i = 0; i &lt; count; i++)    &#123;        thread th(TestBar, i, &amp;bar);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><p>输出：</p><pre><code>begin waitbegin waitbegin waitend waitend waitend wait</code></pre><h2 id="待补坑"><a href="#待补坑" class="headerlink" title="待补坑"></a>待补坑</h2><p>C++20 正式加入了协程（关键字co_wait&#x2F;co_yield&#x2F;co_return）。它是用户态的线程，没有系统级线程那么多的麻烦事</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/p/63561.html"/>
      <url>/p/63561.html</url>
      
        <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><ul><li>没有从形式上体现转换功能和风险的不同。</li><li>将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</li><li>难以在程序中寻找到底什么地方进行了强制类型转换。</li></ul><p>C++ 的四种强制转换包括： static_cast, dynamic_cast, const_cast, reinterpret_cast</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><blockquote><p>static_cast<type>(expression)</type></p></blockquote><p>static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。如果对象所属的类重载了强制类型转换运算符 T（如 T是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。</p><pre><code>uint x = 1;int y = static_cast&lt;int&gt;(x); // 转换正确int x = 1;double y = static_cast&lt;double&gt;(x); // 转换正确</code></pre><p>需要注意的是：static_cast 没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全。<br>static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。空类型指针转换为任意基本类型的指针,空指针转换这里面很容易出错，因为有可能出现未知的转换结果，要保证转换的正确性就必须保证转换后所得的类型就是指针原先的类型。</p><pre><code>int x = -1;uint y = static_cast&lt;uint&gt;(x) // 转换错误double x = 1.23;int y = static_cast&lt;int&gt;(x) // 转换丢失精度</code></pre><p>static_cast 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类，所以主要执⾏⾮多态的转换作；</p><pre><code>// 上行转换，派生类→基类Derive* d = new Derive();Base* b = static_cast&lt;Base*&gt;(d);// 下行转换，基类→派生类Base* b = new Base();Derive* d = static_cast&lt;Derive*&gt;(b);</code></pre><p>这是因为派生类包含基类信息，所以上行转换（只能调用基类的方法和成员变量），一般是安全的；<br>而基类没有派生类的任何信息，而下行转换后会用到派生类的方法和成员变量，这些基类都没有，很容易”指鹿为马”，或指向不存在的空间。</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><blockquote><p>dynamic_cast<type>(expression)   type 必须是类指针，类引⽤或void*，<br>dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，对于下⾏转换是安全的，当类型不⼀致时（即我们的父类指针指向的实际内存不是目标对象type-id *），转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的是错误意义的指针，可能造成⾮法访问等问题。只能用于含有虚函数的类转换，用于类向上和向下转换<br>dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</type></p></blockquote><p>dynamic_cast使用的场景:</p><p>如果你必须做一个非多态的工作在继承类B和C上,但只能接收基类A,则需要如下的操作:<br>比如下面这段代码：</p><pre><code>class A &#123; public: virtual ~A()&#123;&#125; &#125;;class B: public A&#123; public: void work4B()&#123;&#125; &#125;;class C: public A&#123; public: void work4C()&#123;&#125; &#125;; void non_polymorphic_work(A* ap)&#123;    //因为不知道传入来的是那个对象，但是又想统一的调用一个函数，但我们又不能用多态来实现这个效果    if (B* bp =dynamic_cast&lt;B*&gt;(ap))        bp-&gt;work4B();     if (C* cp =dynamic_cast&lt;C*&gt;(ap))        cp-&gt;work4C(); &#125;</code></pre><p>在C++面向对象的思想中，虚函数是实现多态的关键机制。当一个类中有虚函数时，那么编译器就会构建出一个虚函数表来指示这些函数的地址。当用基类的指针指向派生类的对象，调用方法时就会根据虚函数表找到对应派生类的方法。<br>注意：A 要有虚函数，否则会编译出错；static_cast则没有这个限制。</p><p>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><blockquote><p>const_cast<type>(expression)<br>该运算符用来修改 expression 的 const 或 volatile 属性。这里需要注意：expression 和 type 的类型一样的。</type></p></blockquote><p>比如下面的代码，指针 px 由于有 const 修饰，无法直接通过其修改 x 的值，但又期望能修改 x 的值时，怎么办呢？这时就需要用到 const_cast。</p><pre><code>int main()&#123;    int x = 1;    cout &lt;&lt; &quot;before: &quot; &lt;&lt; x &lt;&lt; endl;    const int* px = &amp;x;    // *px = 2; // 编译错误    int* py = const_cast&lt;int*&gt;(px);    *py = 2;    cout &lt;&lt; &quot;px: &quot; &lt;&lt; px &lt;&lt; endl;    cout &lt;&lt; &quot;py: &quot; &lt;&lt; py &lt;&lt; endl;    cout &lt;&lt; &quot;after : &quot; &lt;&lt; x &lt;&lt; endl;    return 0;&#125;</code></pre><p>px 和 py 指向同一个地址，但通过 py 就可以修改 x 的值了。</p><p>这是因为通过const_cast，就把 const 类型的指针 px 转换成非 const 类型的指针 py 了。</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><blockquote><p>reinterpret_cast<type>(expression)</type></p></blockquote><p>reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</p><p>这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作</p><pre><code>#include &lt;iostream&gt;using namespace std;class A&#123;public:    int i;    int j;    A(int n):i(n),j(n) &#123; &#125;&#125;;int main()&#123;    A a(100);    int &amp;r = reinterpret_cast&lt;int&amp;&gt;(a); //强行让 r 引用 a    r = 200;  //把 a.i 变成了 200    cout &lt;&lt; a.i &lt;&lt; &quot;,&quot; &lt;&lt; a.j &lt;&lt; endl;  // 输出 200,100    int n = 300;    A *pa = reinterpret_cast&lt;A*&gt; ( &amp; n); //强行让 pa 指向 n    pa-&gt;i = 400;  // n 变成 400    pa-&gt;j = 500;  //此条语句不安全，很可能导致程序崩溃    cout &lt;&lt; n &lt;&lt; endl;  // 输出 400    long long la = 0x12345678abcdLL;    pa = reinterpret_cast&lt;A*&gt;(la); //la太长，只取低32位0x5678abcd拷贝给pa    unsigned int u = reinterpret_cast&lt;unsigned int&gt;(pa);//pa逐个比特拷贝到u    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  //输出 5678abcd    typedef void (* PF1) (int);    typedef int (* PF2) (int,char *);    PF1 pf1;  PF2 pf2;    pf2 = reinterpret_cast&lt;PF2&gt;(pf1); //两个不同类型的函数指针之间可以互相转换&#125;</code></pre><p>程序的输出结果是：</p><pre><code>200, 1004005678abed</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，在使用强制类型转换时，需要首先考虑清楚使用目的，总结如下：</p><p>static_cast：基本类型转换，低风险；<br>dynamic_cast：类层次间的上行转换或下行转换，低风险；<br>const_cast：去 const 属性，低风险；<br>reinterpret_cast：转换不相关的类型，高风险。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委派构造函数</title>
      <link href="/p/19966.html"/>
      <url>/p/19966.html</url>
      
        <content type="html"><![CDATA[<h1 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h1><p>委派构造函数又叫委托构造函数，是在C++11标准新引入的一项改进，主要目的是为了减少程序员在构造函数方面花费的工作。通过委派构造函数使之对于构造函数的编写更加简单。</p><h2 id="委派构造函数引入"><a href="#委派构造函数引入" class="headerlink" title="委派构造函数引入"></a>委派构造函数引入</h2><p>在下面这段代码中，定义了一个Class Info。这个类中有俩个成员变量，三个构造函数，但是三个构造函数都共同调用了InitRest方法。所以我们看到各个构造函数都有或多或少的相似之处。为此C++11引入了委派构造函数。</p><pre><code>class Info&#123;public:    Info() :type(1), name(&#39;a&#39;)    &#123;        InitRest();    &#125;    Info(int i) :type(i), name(&#39;a&#39;)    &#123;        InitRest();    &#125;    Info(char ch) :type(1), name(ch)    &#123;        InitRest();    &#125;private:    void InitRest()&#123; /* 其他初始化 */ &#125;    int type;    char name;&#125;;</code></pre><p>可以看到，我们声明了一个Info的自定义类型。该类型拥有2个成员变量以及3个构造函数。这里的3个构造函数都声明了初始化列表来初始化成员type和name，并且都调用了相同的函数InitRest。可以看到，除了初始化列表有的不同，而其他的部分，3个构造函数基本上是相似的，因此其代码存在着很多重复。这里其实我们可以通过成员初始化方式，可以使得初始化列表变得简洁化。</p><pre><code>class Info&#123;public:    Info()    &#123;        InitRest();    &#125;    Info(int i) :type(i)    &#123;        InitRest();    &#125;    Info(char ch) :name(ch)    &#123;        InitRest();    &#125;private:    void InitRest() &#123; /* 其他初始化 */&#125;    int type &#123;1&#125;;    char name &#123;&#39;a&#39;&#125;;&#125;;</code></pre><p>可以看到，我们的代码相对简洁了很多，但是每个构造函数还是需要调用InitRest函数进行初始化。而现实编程中，构造函数中的代码还会更长，比如可能还需要调用一些基类的构造函数等。那能不能让代码进一步优化呢？这里就用到了委派构造函数方式进行优化。</p><pre><code>// 通过委派构造函数进行优化class Info&#123;public:    Info()    &#123;        InitRest();    &#125;    Info(int i) : Info()    &#123;        type = i;    &#125;    Info(char ch) : Info() // 委派构造函数不能使用初始化列表 初始化成员变量    &#123;        name = ch;    &#125;private:    void InitRest() &#123; /* 其他初始化 */&#125;    int type&#123; 1 &#125;;    char name&#123; &#39;a&#39; &#125;;&#125;;</code></pre><p>委派构造函数说白了就是将构造的任务分派给一个目标构造函数来完成。</p><ul><li>委派构造函数：初始化列表中调用“基准版本”的构造函数就是委派构造函数。</li><li>目标构造函数：被调用“基准版本”构造函数就是目标构造函数。</li></ul><p>构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unique_ptr</title>
      <link href="/p/39842.html"/>
      <url>/p/39842.html</url>
      
        <content type="html"><![CDATA[<h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I&#x2F;O 多路复用技术， epoll、 poll、 dev&#x2F;poll、 select 和 kqueue 等；支持 I&#x2F;O，定时器和信号等事件；注册事件优先级。<br>Libevent 已经被广泛的应用，作为底层的网络库；比如 memcached、 Vomit、 Nylon、 Netchat等等。</p><h2 id="libevent的特点和优势"><a href="#libevent的特点和优势" class="headerlink" title="libevent的特点和优势"></a>libevent的特点和优势</h2><ul><li>事件驱动，高性能；</li><li>轻量级，专注于网络；</li><li>跨平台，支持 Windows、Linux、Mac Os等；</li><li>支持多种 I&#x2F;O多路复用技术， epoll、poll、dev&#x2F;poll、select 和kqueue 等；</li><li>支持 I&#x2F;O，定时器和信号等事件；</li></ul><p>libevent的组成：</p><ul><li>事件管理包括各种IO（socket）、定时器、信号等事件，也是libevent应用最广的模块；</li><li>缓存管理是指evbuffer功能；</li><li>DNS是libevent提供的一个异步DNS查询功能；</li><li>HTTP是libevent的一个轻量级http实现，包括服务器和客户端</li></ul><h2 id="第一个libevent应用"><a href="#第一个libevent应用" class="headerlink" title="第一个libevent应用"></a>第一个libevent应用</h2><pre><code>#include &lt;event2/event.h&gt;#include &lt;event2/listener.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;#define SPORT 5001void listen_cb(struct evconnlistener * e, evutil_socket_t s, struct sockaddr *a, int socklen, void *arg)&#123;    cout &lt;&lt; &quot;listen_cb&quot; &lt;&lt; endl;&#125;int main()&#123;    //初始化socket库    WSADATA wsa;    WSAStartup(MAKEWORD(2,2),&amp;wsa);    std::cout &lt;&lt; &quot;test server!\n&quot;;     //创建libevent的上下文    event_base * base = event_base_new();    if (base)    &#123;        cout &lt;&lt; &quot;event_base_new success!&quot; &lt;&lt; endl;    &#125;    //监听端口    //socket ，bind，listen 绑定事件    sockaddr_in sin;    memset(&amp;sin, 0, sizeof(sin));    sin.sin_family = AF_INET;    sin.sin_port = htons(SPORT);    evconnlistener *ev = evconnlistener_new_bind(        base,                    // libevent的上下文        listen_cb,//接收到连接的回调函数        base,//回调函数获取的参数 arg        LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE,    //地址重用，evconnlistener关闭同时关闭socket        10,//连接队列大小，对应listen函数        (sockaddr*)&amp;sin,//绑定的地址和端口        sizeof(sin)    );    //事件分发处理    if(base)        event_base_dispatch(base);    //资源清理    if(ev)        evconnlistener_free(ev);    if(base)        event_base_free(base);#ifdef _WIN32    WSACleanup();#endif    return 0;&#125;</code></pre><p>TODO…</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某些小项目</title>
      <link href="/p/55324.html"/>
      <url>/p/55324.html</url>
      
        <content type="html"><![CDATA[<h2 id="象棋方块"><a href="#象棋方块" class="headerlink" title="象棋方块"></a>象棋方块</h2><p><a href="http://wang-ziminghhh.gitee.io/last-chess-blocks/">http://wang-ziminghhh.gitee.io/last-chess-blocks/</a></p>]]></content>
      
      
      <categories>
          
          <category> 软工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/p/16107.html"/>
      <url>/p/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
