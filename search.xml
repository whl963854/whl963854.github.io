<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>防疫大数据</title>
      <link href="/2022/10/20/%E9%A2%98%E8%A7%A3/csp/2022_09_3/"/>
      <url>/2022/10/20/%E9%A2%98%E8%A7%A3/csp/2022_09_3/</url>
      
        <content type="html"><![CDATA[<h1 id="防疫大数据"><a href="#防疫大数据" class="headerlink" title="防疫大数据"></a>防疫大数据</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。具体而言，在每天夜里，西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地区的信息，以及当天疫情风险地区的信息。数据中心需要根据这些信息，生成一份存在风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://imgse.com/i/x6kjot"><img src="https://s1.ax1x.com/2022/10/20/x6kjot.png" alt="x6kjot.png"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出到标准输出。<br>输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格分隔的若干整数。其中第一个整数表示当天的日期，接下来的各个整数为按从小到大排序的存在风险的用户列表。</p><p><strong>样例 1 输入</strong></p><pre><code>91 4 10 1 1-1 1 1-1 2 10 2 20 30 3 11 2 21 3 20 00 00 00 00 00 15 4 11 0 1</code></pre><p><strong>样例 1 输出</strong></p><pre><code>0 11 1 32 1 33 1 34 1 35 1 36 1 378</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>无脑做，不知道哪里有问题，只有20分，哭死（）</p><p> <strong>代码实现</strong></p><pre><code>？？？忘保存了！！！</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p><strong>代码实现</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;set&lt;LL&gt; sd[1050], su;struct node&#123;    LL d, u, r;&#125;a;vector&lt;node&gt; v[1050];LL n, ri, mi, d, u, r, pi;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) // i:生成名单这一天    &#123;        cin &gt;&gt; ri &gt;&gt; mi;                for (int j = 0; j &lt; ri; j ++ ) // ri个风险地区        &#123;            cin &gt;&gt; pi;            for (int k = i; k &lt; i + 7; k ++ ) sd[k].insert(pi); // pi地区i ~ i+6天都是风险地区        &#125;                for (int j = 0; j &lt; mi; j ++ ) //         &#123;            cin &gt;&gt; d &gt;&gt; u &gt;&gt; r;            if (d &lt; 0) continue;            if (!sd[d].count(r)) continue; // 到访的地区在到访的那一日不处于风险状态,肯定无风险            v[i].push_back(&#123;d, u, r&#125;); // 存储第i天的漫游数据        &#125;                // 对漫游信息进行判断,从第i-6天开始.因为7天前的用户漫游数据有可能到现在还是风险的        for (int j = max(0, i - 6); j &lt;= i; j ++ )        &#123;            for (int k = 0; k &lt; v[j].size(); k ++ )            &#123;                d = v[j][k].d;                u = v[j][k].u;                r = v[j][k].r;                                // 1.该用户的d要在7日内                // 2.该用户在近7日内到访的地区在到访的那一日处于风险状态                // 3.上述存在风险的地区自到访日(d)至生成名单当日(i)持续处于风险状态                bool flag = 1;                if (d &lt;= i - 7) continue; // 要求1                for (int l = d; l &lt;= i; l ++ ) // 要一直持续到当前i这一天 要求2&amp;3                    flag = flag &amp; sd[l].count(r);                if (flag) su.insert(u);            &#125;        &#125;                cout &lt;&lt; i &lt;&lt; &quot; &quot;;        for (auto it : su) cout &lt;&lt; it &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        su.clear();    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/20/%E9%A2%98%E8%A7%A3/longestFibonacci/"/>
      <url>/2022/10/20/%E9%A2%98%E8%A7%A3/longestFibonacci/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RvalueReference</title>
      <link href="/2022/10/18/cpp/hj/RvalueReferences/"/>
      <url>/2022/10/18/cpp/hj/RvalueReferences/</url>
      
        <content type="html"><![CDATA[<h1 id="RvalueReference"><a href="#RvalueReference" class="headerlink" title="RvalueReference"></a>RvalueReference</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>解决非必要的拷贝<br>Rvalue references are a new reference type introduced in C++Oxthat help solve the problem of unnecessary copying and enableperfect forwarding. When the right-hand side of an assignment isan rvalue, then the left-hand side object can steal resources fromthe right-hand side object rather than performing a separate allocation, thus enabling move semantics.</p><p>Rvalue 引用是 C++Ox 中引入的一种新的引用类型，有助于解决不必要的复制问题并启用完美转发。当赋值的右侧是右值时，左侧对象可以从右侧对象窃取资源，而不是执行单独的分配，从而实现移动语义。</p><ul><li>Lvalue: 可以出现在左边</li><li>Rvalue: 只能出现在右边</li></ul><p><strong>a+b&#x3D;42编译无法通过</strong><br><img src="/2022/10/18/cpp/hj/RvalueReferences/%E5%B7%A6%E5%80%BC.png"><br><strong>标红可以通过编译</strong><br><img src="/2022/10/18/cpp/hj/RvalueReferences/%E5%B7%A6%E5%80%BC2.png"><br><strong>标红可以通过编译</strong><br><img src="/2022/10/18/cpp/hj/RvalueReferences/%E5%B7%A6%E5%80%BC3.png"></p><h2 id="perfect-forwarding"><a href="#perfect-forwarding" class="headerlink" title="perfect forwarding"></a>perfect forwarding</h2><p><img src="/2022/10/18/cpp/hj/RvalueReferences/perfectForwarding.png"><br><img src="/2022/10/18/cpp/hj/RvalueReferences/standardForward.png"></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/16/cpp/csp/"/>
      <url>/2022/10/16/cpp/csp/</url>
      
        <content type="html"><![CDATA[<p>stoi()，atoi() ，to_string 这三个函数都是对字符串处理的函数，前两者是将字符串转化为十进制 int 类型，最后一个是将十进制类型 int、double 等转化为string，头文件都是：#include<cstring><br>stoi 的参数是 const string* 类型<br>atoi 的参数是 const char* 类型</cstring></p><p>stoi() 会对转化后的数进行检查，判断是否会超出 int 范围，如果超出范围就会报错；<br>atoi() 不会对转化后的数进行检查，超出上界，输出上界，超出下界，输出下界；</p><p>反转数字自动去除前导零</p><pre><code>int countDistinctIntegers(vector&lt;int&gt;&amp; nums) &#123;    map&lt;int,int&gt; m;    for(int x:nums)&#123;      m[x]++;      string s=to_string(x);      reverse(s.begin(),s.end());      m[stoi(s)]++;    &#125;    return m.size();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2022/10/16/%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/10/16/%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串求他的最长回文子串</p><h2 id="方法1-暴力法"><a href="#方法1-暴力法" class="headerlink" title="方法1 暴力法"></a>方法1 暴力法</h2><p>略；</p><h2 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2 动态规划"></a>方法2 动态规划</h2><p>给定一个字符串s，设[p,q]是他的一个从p到q的回文字串，那么当p+1&lt;&#x3D;q-1的时候，[p+1，q-1]必定也是s的一个子串；<br>由此我们可以找到动态规划的递推表达式：</p><p>设：</p><pre><code>dp[i][i]=1; //单个字符是回文串dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串</code></pre><p>思考状态转移方程：</p><pre><code>根据头尾字符是否相等，需要分类讨论：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></pre><p>最终代码如下：</p><pre><code>string longestPalindrome(string s) &#123;    int slen=s.size();    vector&lt;vector&lt;bool&gt;&gt; dp(slen, vector&lt;bool&gt;(slen, 0));    int maxlenth = 0;    int left = 0;    int right = 0;    for (int i = slen - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; slen; j++) &#123;            if (s[i] == s[j]) &#123;                if (j - i &lt;= 1) &#123;                    dp[i][j] = true;                &#125;                 else if (dp[i + 1][j - 1]) &#123;                     dp[i][j] = true;                &#125;            &#125;            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxlenth) &#123;                maxlenth = j - i + 1;                left = i;                right = j;            &#125;        &#125;    &#125;    return s.substr(left, maxlenth);&#125;</code></pre><h2 id="方法三-中心拓展法"><a href="#方法三-中心拓展法" class="headerlink" title="方法三 中心拓展法"></a>方法三 中心拓展法</h2><p>我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1)P(i+1,j−1) 扩展到 P(i,j)P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。<br>官方用的stl，本弱鸡不会呜呜呜，只能硬着头皮写喽；</p><pre><code>class Solution &#123;public:    string longestPalindrome(string s) &#123;        int lans=0;        int length=s.size();        int left=0;        string ans=&quot;&quot;;        for(int i=0;i&lt;length;i++)&#123;            int j=1;            int tans=0;            while(i-j&gt;=0&amp;&amp;i+j&lt;length&amp;&amp;s[i-j]==s[i+j])&#123;                tans++;                j++;            &#125;            if(lans&lt;tans*2+1)&#123;                lans=tans*2+1;                left=i-tans;            &#125;            j=0;            tans=0;            while(i-j&gt;=0&amp;&amp;i+j+1&lt;length&amp;&amp;s[i-j]==s[i+j+1])&#123;                    tans++;                    j++;            &#125;            if(lans&lt;tans&lt;&lt;1)&#123;                lans=tans&lt;&lt;1;                left=i-tans+1;            &#125;            if(lans&gt;(length-i)*2)break;        &#125;        ans=s.substr(left,lans);        return ans;    &#125;&#125;;</code></pre><h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><p>class Solution {<br>public:<br>    int expand(const string&amp; s, int left, int right) {<br>        while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] &#x3D;&#x3D; s[right]) {<br>            –left;<br>            ++right;<br>        }<br>        return (right - left - 2) &#x2F; 2;<br>    }</p><pre><code>string longestPalindrome(string s) &#123;    int start = 0, end = -1;    string t = &quot;#&quot;;    for (char c: s) &#123;        t += c;        t += &#39;#&#39;;    &#125;    t += &#39;#&#39;;    s = t;    vector&lt;int&gt; arm_len;    int right = -1, j = -1;    for (int i = 0; i &lt; s.size(); ++i) &#123;        int cur_arm_len;        if (right &gt;= i) &#123;            int i_sym = j * 2 - i;            int min_arm_len = min(arm_len[i_sym], right - i);            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);        &#125; else &#123;            cur_arm_len = expand(s, i, i);        &#125;        arm_len.push_back(cur_arm_len);        if (i + cur_arm_len &gt; right) &#123;            j = i;            right = i + cur_arm_len;        &#125;        if (cur_arm_len * 2 + 1 &gt; end - start) &#123;            start = i - cur_arm_len;            end = i + cur_arm_len;        &#125;    &#125;    string ans;    for (int i = start; i &lt;= end; ++i) &#123;        if (s[i] != &#39;#&#39;) &#123;            ans += s[i];        &#125;    &#125;    return ans;&#125;</code></pre><p>};</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2022/10/15/DesignMode/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/15/DesignMode/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>日常生活中，我们经常到饭店去吃饭，当然我们要吃什么会给服务员说，服务员再转告给厨师，点菜可以看做一个请求，看它如何用命令模式实现</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//命令的处理者：厨师class Chef&#123;public:    void cook(string name)    &#123;        cout &lt;&lt; &quot;厨师做一道&quot; &lt;&lt; name &lt;&lt; endl;    &#125;&#125;;//命令抽象类：点菜class Command&#123;protected:    Chef* chef_;public:    Command(Chef* chef) :chef_(chef) &#123;&#125;    virtual void excute() = 0;&#125;;命令具体类:牛肉class BeefCmd :public Command&#123;public:    BeefCmd(Chef *chef) :Command(chef) &#123;&#125;    virtual void excute() override    &#123;        chef_-&gt;cook(&quot;青椒炒牛肉&quot;);    &#125;&#125;;//命令具体类:土豆class PotatoCmd :public Command&#123;public:    PotatoCmd(Chef *_chef) :Command(_chef) &#123;&#125;    virtual void excute()    &#123;        chef_-&gt;cook(&quot;青椒炒土豆丝&quot;);    &#125;&#125;;//命令接受者：服务员class Waiter&#123;private:    Command* cmd_;public:    void ReciveCmd(Command* cmd)    &#123;        cmd_ = cmd;    &#125;    void DealCmd()    &#123;        cmd_-&gt;excute();    &#125;&#125;;//饭店场景int main()&#123;    //服务员    Waiter *waiter = new Waiter;    //厨师    Chef *chef = new Chef;    //客人开始点菜    Command *beef = new BeefCmd(chef);    Command *potato = new PotatoCmd(chef);    //下单    waiter-&gt;ReciveCmd(beef);    waiter-&gt;DealCmd();    waiter-&gt;ReciveCmd(potato);    waiter-&gt;DealCmd();    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点</strong></p><ul><li>将调用操作的对象和实现操作的对象进行了解耦。</li><li>具体命令扩展方便。</li></ul><p><strong>缺点</strong></p><ul><li>有几个具体命令就有多少具体类，可能需要大量具体命令类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编码规范</title>
      <link href="/2022/10/15/cpp/cpp%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2022/10/15/cpp/cpp%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="c-编码规则"><a href="#c-编码规则" class="headerlink" title="c++编码规则"></a>c++编码规则</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>文件名全部使用小写字母<br>示例：</p><pre><code>kctlinechartview.h</code></pre><h4 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h4><p>类的命名使用前缀+驼峰命名法。当一个类需要暴露给其它工程使用时，应加上工程约定的前缀，前缀全部使用大写字母。类命名尽量使用完整英文单词，除非是常见的缩写。<br>示例：</p><pre><code>KCTLineChartView</code></pre><p>Com 接口命名在普通前缀前加 I 作为标志。</p><p>示例：IKCTChartView</p><h4 id="其他类型命名"><a href="#其他类型命名" class="headerlink" title="其他类型命名"></a>其他类型命名</h4><p>struct、typedef 与 enum 的命名原则与类相同。enum 成员采用大写字母开头的驼峰写法，且应在命名中体现 enum 名称，具体位置不做强制要求，但同一个 enum 内的命名规则要保持一致。<br>示例：</p><pre><code>enum ActionType&#123;    InsertActionType, DeleteActionType, MoveActionType&#125;;</code></pre><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>变量命名使用小写字母开头的驼峰写法，不加类型信息前缀，命名应使用能表达变量涵义的完整英文单 词。<br>示例:</p><pre><code>int index = 0；KCTLineChartView  *lineChartView = NULL;</code></pre><p>仅允许在 for 单层循环中的 i 和表示坐标的 x、y、z 上使用单字母变量，其他情况下不允许使用。</p><p>非 static 的类成员变量前加上小写字母 m_前缀，static 的类成员变量前加上小写字母 s_前缀，这两种情况下变量名的第一个单词首字母小写，后面单词首字母大写。<br>示例：</p><pre><code>class GoodClass&#123;private:    int m_dataMember;    static int s_staticDataMember;&#125;;</code></pre><h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><p>除构造函数和析构函数外，类成员函数使用小写字母开头的驼峰写法。非类成员函数使用大写字母开头 的驼峰写法。<br>示例：    </p><pre><code>lineChartView-&gt;lineCount();GetObjectCountInDocument();</code></pre><p>名词属性的类成员函数命名分两种情况：若欲获取的信息当成返回值返回，则命名方式为 名词 或 名词+修饰语 的样式。若欲获取的信息通过某个参数返回，则命名方式为 get+名词（+修饰语）的样式。<br>示例：    </p><pre><code>lineChartView-&gt;title();lineChartView-&gt;subViewAtIndex(index);lineChartView-&gt;getSubViews(&amp;outPointer);</code></pre><p>动词属性的类成员函数命名方式为 动词+宾语，若宾语是 this, 应省略。<br>示例：  </p><pre><code>lineChartView-&gt;removeAllSubViews(); lineChartView-&gt;setTitle(L”Hello World”); lineChartView-&gt;initialize();</code></pre><p>形容词属性的类成员函数命名方式为 is&#x2F;has 等修饰语+形容词&#x2F;名词。<br>示例：</p><pre><code>lineChartView-&gt;isVisible(); lineChartView-&gt;hasTitle();</code></pre><p>返回对象指针的函数若内部分配了内存，应使用 copy, create 等关键字把该信息反映在函数名上。</p><p>示例：</p><pre><code>lineChartView-&gt;subViews();     //未重新分配内存 lineChartView-&gt;copySubViews();    //重新分配了内存</code></pre><h4 id="函数命名-1"><a href="#函数命名-1" class="headerlink" title="函数命名"></a>函数命名</h4><p>宏命名</p><p>原则上宏的命名全部大写，如有必要单词间用下划线分隔。如无必要，不把一段代码定义成宏。</p><p>示例：</p><pre><code>#define SOMETHING_USED</code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>关于使用全局变量的注意事项见后文。全局变量前加小写字母 g_ 前缀，static 全局变量前加小写字母 gs_前缀。<br>示例：</p><pre><code>bool g_inFileOpening = false;static bool gs_staticInFileOpening = true;</code></pre><h4 id="名称空间命名"><a href="#名称空间命名" class="headerlink" title="名称空间命名"></a>名称空间命名</h4><p>名称空间使用剪短的全小写英文单词命名。<br>示例：</p><pre><code>namespace chart&#123;    ....&#125;</code></pre><h4 id="不允许使用-My-或自己的姓名作为以上命名的前缀"><a href="#不允许使用-My-或自己的姓名作为以上命名的前缀" class="headerlink" title="不允许使用 My 或自己的姓名作为以上命名的前缀"></a>不允许使用 My 或自己的姓名作为以上命名的前缀</h4><p>例如：</p><p>&#x2F;&#x2F;禁止下列写法。</p><pre><code>Class MyStringProject&#123; public:    ...&#125;</code></pre><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h4 id="头文件包含保护"><a href="#头文件包含保护" class="headerlink" title="头文件包含保护"></a>头文件包含保护</h4><p>在所有头文件中均使用#ifndef + #define + #endif 来避免该文件被重复包含，宏的命名方式为</p><pre><code>PROJECTNAME_FILENAME_H</code></pre><p>示例：</p><p>MyProject 项目有头文件名为 MyHeader.h，则文件头部加上 </p><pre><code>#ifndef      MYPROJECT_MYHEADER_H     #define      MYPROJECT_MYHEADER_H     </code></pre><p>文件末尾加上</p><pre><code>#endif  //     MYPROJECT_MYHEADER_H     </code></pre><h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>当使用一两个前置声明就能编译通过时，不要在头文件里包含另一个头文件。</p><h4 id="头文件包含顺序"><a href="#头文件包含顺序" class="headerlink" title="头文件包含顺序"></a>头文件包含顺序</h4><p>在代码文件里包含多个头文件时，应按照如下顺序将头文件分组，每组之间使用空行隔开：</p><ol><li><p>预编译头文件，通常是 stdafx.h</p></li><li><p>与代码文件同名的头文件</p></li><li><p>系统头文件</p></li><li><p>WPS 内部其他工程头文件</p></li><li><p>本工程其他头文件</p></li></ol><p>示例：</p><p>MyProject 工程中的 MyClass.cpp 实现了声明在 MyClass.h 内的类，此外还用到了 C++ 标准库中的 Vector 容器、ExternalProject 工程中的 ExternalClass.h 和 ExternalUtils.h、MyProject 工程中的 MyFriendClass.h、MyFileIOHelper.h 与 MyStringUtils.h，<br>其包含顺序如下: </p><pre><code>#include &quot;stdafx.h&quot;#include &quot;MyClass.h&quot;#include &lt;vector&gt;#include &quot;ExternalClass.h&quot; #include &quot;ExternalUtils.h&quot;#include &quot;MyFirendClass.h&quot; #include &quot;MyFileIOHelper.h&quot; #include &quot;MyStringUtils.h&quot;</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的所有成员变量必须初始化，只有成员变量没有函数的类，必须定义默认构造函数。</p><p>除非有特殊需求，在类的构造函数中仅进行不涉及具体功能的初始化操作，例如为成员变量赋零。较复杂的初始化操作，应放在一个单独的 init()方法中，由类实例的创建者负责调用。<br>解释：构造函数内难以报告错误，且构造函数中对虚函数的调用不会派发给子类，所以较复杂的初始化操作应在构造完成之后进行。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>若没有明确的将单参构造函数用于隐式类型转换的需求，应使用 explicit 关键字。</p><h4 id="拷贝构造函数、赋值运算符"><a href="#拷贝构造函数、赋值运算符" class="headerlink" title="拷贝构造函数、赋值运算符"></a>拷贝构造函数、赋值运算符</h4><p>若没有明确的对类进行拷贝的需求，应在 private 段中声明拷贝构造函数和赋值运算符。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>只使用 public 继承。</p><p>在语义明确的时候从父类继承具体实现，其他时候从抽象接口继承。若类有虚函数，则析构函数也定义为虚函数。<br>父类中声明为 virtual 的函数，子类声明中要明确标明为 virtual 以及 override。</p><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>尽量避免运算符重载，除非是为了在容器类中使用而必须实现的。</p><h4 id="访问权限声明"><a href="#访问权限声明" class="headerlink" title="访问权限声明"></a>访问权限声明</h4><p>类声明中按 public, protected, private 的顺序声明函数和变量，每个关键字仅占用一段，每一段中的声明顺序为： typedef, enum, Q_OBJECT 及类似声明，嵌套类，常量，构造函数，虚构函数，成员函数，数据成员。</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的定义和友类的定义应放在同一个文件中。</p><h2 id="函数与实现"><a href="#函数与实现" class="headerlink" title="函数与实现"></a>函数与实现</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数排列顺序为输入参数在前，输出参数在后。引用作为输入参数时应配合 const 使用。不使用缺省参数。<br>不允许一个参数即作为传入参数，又作为传出参数。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数不超过 10 行，推荐仅对 1 行的函数进行 inline。不使用循环或 switch…case，不进行递归。在类定义体内实现的函数，不要加 inline 关键字。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>避免使用异常（try…catch）。使用 ATL 和 STL 时，关闭异常或限制异常作用域。</p><h4 id="类型编程"><a href="#类型编程" class="headerlink" title="类型编程"></a>类型编程</h4><p>不使用运行时类型信息。明确使用 static_cast，const_cast 进行类型转换，避免使用 dynamic_cast,小心使用 reinterpret_cast。</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>尽量使用 const、enum、inline 替代 #define。</p><h4 id="类数据成员的引用"><a href="#类数据成员的引用" class="headerlink" title="类数据成员的引用"></a>类数据成员的引用</h4><p>避免成员函数返回指向类成员的指针或引用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>文件头注释应包括 文件名，创建者，创建时间，功能描述 和版权信息。</p><p>示例：</p><pre><code>    // KCTCodingGuideline.h    // 创建者： Tom Cat    // 创建时间： 2013/5/24    // 功能描述： The coding guideline for Chart project in WPS        // Copyright 2013 Kingsoft</code></pre><h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><p>注释使用 &#x2F;&#x2F; 风格，应简洁清晰，不写没必要的注释。代码中不是很简单直观的地方需要增加注释，</p><p>例如：</p><ul><li><p>故意违背编码规范之处。</p></li><li><p>分成多步完成的任务。</p></li><li><p>较复杂的逻辑。</p></li><li><p>和常理不符的代码。</p></li><li><p>比较重要，需要引起注意的地方。</p></li></ul><h4 id="注释语言"><a href="#注释语言" class="headerlink" title="注释语言"></a>注释语言</h4><p>默认注释语言为中文。</p><h4 id="注释中的工程师姓名"><a href="#注释中的工程师姓名" class="headerlink" title="注释中的工程师姓名"></a>注释中的工程师姓名</h4><p>在且仅在两种情形下把姓名加入注释中：</p><ol><li><p>文件头中的创建者信息。</p></li><li><p>做 TODO 注释时。</p></li></ol><p>示例： </p><pre><code> //TODO(Tommy Zhang): 删掉这里的全局变量!</code></pre><h4 id="预处理宏注释"><a href="#预处理宏注释" class="headerlink" title="预处理宏注释"></a>预处理宏注释</h4><p>中间代码段较长的#else 与 #endif 之后用注释标明宏的名字。</p><p>示例：</p><pre><code>    #if TARGET_PLATFORM_WINDOWS    ................        #else //TARGET_PLATFORM_WINDOWS    ................    #endif //TARGET_PLATFORM_WINDOWS</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h4 id="对齐与缩进"><a href="#对齐与缩进" class="headerlink" title="对齐与缩进"></a>对齐与缩进</h4><p>使用 Tab 进行对齐。</p><p>花括号上下对齐，不允许将左花括号放在 if 等语句的末尾：<br>例如：</p><pre><code>    void MyFunction(InputType type)    &#123;        static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;         static const ScopeType scopeType[] =        &#123;            wpsFindScope_MainText, wpsFindScope_Selection, wpsFindScope_HeaderFooters, wpsFindScope_Footnotes, wpsFindScope_Endnotes,            ...            wpsFindScope_Comments        &#125;;                switch (type)        &#123;        case TypeA:            break;        case TypeB:            break;         default:            break;        &#125;        if (...)        &#123;        &#125;        else        &#123;        &#125;        do        &#123;        &#125;        while (...);                for (int i = 0; i &lt; 10; ++ i)        &#123;        &#125;    &#125;</code></pre><p>构造函数初始化列表和多个基类的中每一行逗号放前面，和冒号对齐。</p><p>示例：</p><pre><code>KGroupGrid::KGroupGrid(QWidget *parent)    : QWidget(parent)    , m_scrollBar(Qt::Vertical, this)    , m_headerHeight()    , m_itemSize(80, 64)    , m_showTooltip(false)    , m_flatFrame(true)    , m_showSeperatorLine(true)    , m_scrollBarPolicy(Qt::ScrollBarAsNeeded) #if X_OS_WINDOWS    , m_firstRow(0) #endif&#123;&#125;class KxWppViewPages    : public QStackedWidget        , public KFakeUnknown&lt;IShellPagesGetter&gt;    , public KFakeUnknown&lt;IROShellPages&gt;    , public KxWppViewPagesCoreNotify&#123;&#125;;</code></pre><p>只有一行代码的 if 语句不加花括号。</p><p>示例：</p><pre><code>if (inputType == badType)     DoSomethingBad();if (inputType == badType)     DoSomethingBad();else    DoSomethingElse();</code></pre><p>当 if 语句中某一个分支有一行的以上代码时，if 的所有子句都要加括号。</p><p>示例：</p><pre><code>if (inputType == badType)&#123;    DoSomethingBad();&#125;else&#123;    DoSomethingElse1();     DoSomethingElse2();&#125;</code></pre><p>推荐一行代码不超过 120 个字符。函数参数列表过长时，应换行：返回值类型、左括号应保持与函数名同一行，具体换行的方案有两种：<br>示例：</p><pre><code>HRESULT MyClass::method(ParameterOne param1,                        ParameterTwo param2,                         ParameterThree param3)HRESULT MyClass::method(ParameterOne param1,     ParameterTwo param2, ParameterThree param3)</code></pre><p>函数类型为 const 时，const 关键字与最后一个参数同行<br>示例：</p><pre><code>HRESULT MyClass::constMethod(ParameterOne param1,                            ParameterTwo param2,                            ParameterThree param3) const</code></pre><p>所有预编译宏顶格对齐。</p><p>示例：</p><pre><code>void MyClass::methodWithMacros()&#123;    static int integer1 = 0;    integer1 ++;     if(integer1 &gt;= 10)    &#123;#if PLATFORM_1        integer1 = 1;#else        integer1 = 2;#endif    &#125;&#125;</code></pre><p>分为多行的布尔表达式中 &amp;&amp; 与 || 置于行首。换行应在运算符优先级最低的地方进行，尽可能避免把配对的括号分成两行。<br>当条件比较复杂时，应将高优先级的运算用括号明确标识出来。</p><p>示例：</p><pre><code>if ((valueGood &gt;= somethingGood || otherContion)     &amp;&amp; (valueBad + 1) &lt;= somethingRealyBad)</code></pre><p>命名空间（namespace)内容不缩进</p><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>函数调用的括号前后之间不加空格，参数之间逗号之后加一个空格。</p><p>示例：</p><pre><code>void MyFunction(ParameterOne param1, ParameterTwo param2)</code></pre><p>if、while、for 等关键字与括号之间加一个空格，括号后不加空格。<br>示例：</p><pre><code>if (NULL == thePointer)for (int index = 0; index &lt; maxIntValue; index++)</code></pre><p>使用 Tab 键无法刚好对齐时，使用空格补齐。</p><p>没有参数的函数括号内不加空格。</p><p>二元运算符前后各加一个空格；</p><p>自增减运算符与分号间不加空格，与变量之间也不加空格。</p><p>示例：</p><pre><code>if (inputType1 == goodType &amp;&amp; inputType2 == badType) for (int index == 0; index &lt; MAX_INT; index++)</code></pre><p>引用符号（. -&gt;）前后不加空格。</p><p>示例：</p><pre><code>theSmartPointer-&gt;value();</code></pre><p>地址、引用运算符（*, &amp;）后不加空格；</p><p>示例：</p><pre><code>*integerPointer = 1;</code></pre><p>声明指针类型的*号前加一空格，后边不加空格</p><p>示例：</p><pre><code>MyClass *goodClass;</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>不需要暴露嵌套类作为接口的时候，将嵌套类声明为 private。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量应在将要使用时进行声明，声明的同时初始化。</p><p>示例：</p><pre><code>void SomeMagicalFunction()&#123;    const int magicNumber = 1;    int integer1 = magicNumber;    integer1 ++;    if (integer1 &lt;= 0)         DoSomethingWeird();    float floatingNumer1 = 1.0;    float *floatingPointer = &amp;floatNumber1;    if (floatingPointer == NULL)        HowCouldThisHappen();&#125;</code></pre><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>除非特殊情况，不使用 Class 类型的全局变量，不使用 Class 类型的 static 类数据成员。可以用单例模式替代 Class 类型的全局变量。</p><p>全局的字符串变量使用 C 风格的 char，不使用各种字符串类。</p><h4 id="名称空间（namespace）"><a href="#名称空间（namespace）" class="headerlink" title="名称空间（namespace）"></a>名称空间（namespace）</h4><p>允许在 cpp 文件中使用匿名名称空间进行保护，不允许在头文件中使用匿名名称空间。避免使用 using namespace 将一个名称空间中的所有名称全部导入。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>使用 typename 关键字声明模板，不使用 class 关键字。</p><h4 id="模板适用范围"><a href="#模板适用范围" class="headerlink" title="模板适用范围"></a>模板适用范围</h4><p>一般情况下仅使用模板来实现容器类或通用算法，如果需要用作其他用途，请增加注释说明必要性。</p><h4 id="模板中的嵌套类"><a href="#模板中的嵌套类" class="headerlink" title="模板中的嵌套类"></a>模板中的嵌套类</h4><p>模板中使用嵌套类时，加上 typename 关键字声明。</p><p>示例：</p><pre><code>template&lt;typename T&gt;void someFunction(const T&amp; container)&#123;    typename T::Iterator iter(container.begin());    iter.next();&#125;</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>在模板派生类中调用模板基类函数时，明确在函数调用前声明该函数属于基类。</p><p>示例：</p><pre><code>template&lt;typename T&gt;class DerivedClass::public BaseClass&lt;T&gt;&#123;public:    void doAction()    &#123;        BaseClass&lt;T&gt;::doBaseAction();    &#125;&#125;</code></pre><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="优先使用静态内存"><a href="#优先使用静态内存" class="headerlink" title="优先使用静态内存"></a>优先使用静态内存</h4><p>编译期能够确定的常量数组，应声明为 static。</p><p>示例：</p><pre><code>void func(int type)&#123;    static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;    ......&#125;</code></pre><h4 id="其次为栈内存"><a href="#其次为栈内存" class="headerlink" title="其次为栈内存"></a>其次为栈内存</h4><p>编译期能够确定长度的非常量数组，应使用栈内存。</p><p>示例：</p><pre><code>void func(int type)&#123;    const int length = 1024;    unsigned char buffer[length + 1];     DWORD dwReadSize = length;    while (::ReadFile(hFile, buffer, length, &amp;dwReadSize, NULL))    &#123;        ......        dwReadSize = length;    &#125;&#125;</code></pre><h4 id="使用智能指针和容器管理堆内存"><a href="#使用智能指针和容器管理堆内存" class="headerlink" title="使用智能指针和容器管理堆内存"></a>使用智能指针和容器管理堆内存</h4><p>单个堆对象的生命周期用 std::unique_ptr 来管理。</p><p>连续的内存空间用 std::vector 或 QVector 来分配和管理。</p><p>示例：</p><pre><code>void func(int type)&#123;    std::unque_ptr&lt;CSomeObject&gt; spObject = new CSomeObject();    int bufferLength = getBufferLength(); std::vector&lt;SomeType&gt; vecBuffer(bufferLength);     readBuffer(&amp;vecBuffer[0], bufferLength);&#125;</code></pre><p>字符串用 std::basic_string<T>或 QString 来管理。</T></p><p>示例：</p><pre><code>void func(int type)&#123;    int stringLength = getStringLength();    std::string str; str.resize(stringLength);    readStringInCStyleFunction(&amp;str[0], stringLength);&#125;</code></pre><p>不允许在代码中出现 new[] 和 delete[]的显示调用。</p><p>delete 不应该出现在析构函数或用于清理内存的函数之外的地方出现。</p><p>不允许使用 malloc&#x2F;free 来分配和释放内存。</p><p>十. 跨平台</p><h4 id="Windows-内建类型"><a href="#Windows-内建类型" class="headerlink" title="Windows 内建类型"></a>Windows 内建类型</h4><p>调用 Windows API 时，使用 DWORD、LPCTSTR 等 Windows 类型，其它情况下避免使用，但可以使用 HRESULT。</p><h4 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h4><p>避免使用 Windows 系统 API，只能在限定模块内使用，比如一个封装操作系统 API 的中间层。</p><h4 id="C-扩展库"><a href="#C-扩展库" class="headerlink" title="C++扩展库"></a>C++扩展库</h4><p>不允许使用 Boost 库，除非是已经进入 C++11 标准的部分。</p><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h4><p>可以使用 C++11 新语法中 Visual C++支持的部分，但须遵守如下原则：</p><ol><li><p>不使用 lambda 表达式。</p></li><li><p>仅使用 auto 来简化模板变量的声明，不将基本类型或者表达式返回值赋给 auto 对象。</p></li><li><p>不使用尾部返回类型声明，例如 auto Function() -&gt; int；</p></li><li><p>不使用 Raw String。</p></li><li><p>禁用模版元编程。</p></li><li><p>不允许使用逗号表达式。</p></li></ol><p>不能使用 Visual C++专有语法，例如：</p><ol><li><p>finally、     super、     forceinline 等关键字。</p></li><li><p>省略类静态成员的外部定义。</p></li><li><p>将函数指针 cast 成整型指针。</p></li><li><p>重复包含有 extern 全局变量定义(非声明)的头文件。</p></li><li><p>goto 关键字跨越变量定义。</p></li><li><p>如果有可能，在 Visual Studio 中设置&#x2F;Za 标志关闭 Microsoft Extension to C++。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长字符串链</title>
      <link href="/2022/10/13/%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/"/>
      <url>/2022/10/13/%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="最长字符串链"><a href="#最长字符串链" class="headerlink" title="最长字符串链"></a>最长字符串链</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给出一个单词数组 words ，其中每个单词都由小写英文字母组成。</p><p>如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。</p><p>例如，”abc” 是 “abac” 的 前身 ，而 “cba” 不是 “bcad” 的 前身<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k &#x3D;&#x3D; 1 的 单词链 。</p><p>从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。 </p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>示例 1：</p><pre><code>输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]输出：4解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]</code></pre><p>示例 2:</p><pre><code>输入：words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]输出：5解释：所有的单词都可以放入单词链 [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;].</code></pre><p>示例 3:</p><pre><code>输入：words = [&quot;abcd&quot;,&quot;dbqca&quot;]输出：1解释：字链[&quot;abcd&quot;]是最长的字链之一。[&quot;abcd&quot;，&quot;dbqca&quot;]不是一个有效的单词链，因为字母的顺序被改变了。</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><pre><code>1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 16words[i] 仅由小写英文字母组成。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们将问题分解成几个子问题，我们先来看单词链的判断，单词链相邻单词必然满足长度相差一且长度较长的单词&#x3D;长度短的单词+任意位置插入一个字母，也就是说如果没有插入字母两个字符串是完全相同的，插入一个字母以后，除了那一个位置以外的所有字母都是一一对应的。那么我们可以根据这个对短单词进行遍历，一一与长单词进行对应，如果不相同则跳过这个字母，比对后面的字母，如果跳过次数不等于1，则两个单词不能组成单词链。<br>接下来我们分析题目，需要求最长单词链，我们仔细观察可以发现最长单词链是满足最优子结构性的，例如长度为最大为m的单词组成的最长链必须由单词+最长的单词长度最大为m-1的单词链组成。<br>定义</p><pre><code>dp[i]表示以单词i为结尾的最长的单词链长度</code></pre><p>初始化</p><pre><code>至少一个单词，初始化为1</code></pre><p>计算</p><pre><code>预处理先按照字符串长度升序排列从短到长来计算, 对于当前单词去找序号比它小的 j 情况： 如果相等，则 max(d[i], d[j]+1)</code></pre><p>代码 </p><pre><code>class Solution &#123;    // a是否是b的前身    bool isFor(string&amp; a, string&amp; b) &#123;        int asize=a.size();        int bsize=b.size();        if(bsize - asize== 1) &#123;            int i = 0, j = 0;            while(i &lt; asize &amp;&amp; j &lt; bsize) &#123;                if(a[i] == b[j]) i++;                j++;            &#125;            if(i == asize) return true;        &#125;        return false;    &#125;public:    int longestStrChain(vector&lt;string&gt;&amp; words) &#123;        if(words.size() &lt; 2)            return words.size();                vector&lt;int&gt; dp(words.size(), 1);        int res = 1;                // 按字符串长度递增排序        sort(words.begin(), words.end(),             [](string a, string b) &#123;return a.size() &lt; b.size();&#125;);                for(int i = 0; i &lt; words.size(); i++) &#123;            for(int j = i - 1; j &gt;= 0; j--) &#123;                if(isFor(words[j], words[i])) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-string-chain">https://leetcode.cn/problems/longest-string-chain</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Otherthings</title>
      <link href="/2022/10/11/cpp/hj/otherthings/"/>
      <url>/2022/10/11/cpp/hj/otherthings/</url>
      
        <content type="html"><![CDATA[<h1 id="Otherthings"><a href="#Otherthings" class="headerlink" title="Otherthings"></a>Otherthings</h1><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><ul><li>noexcept是C++11为了替代 throw()而提出的一个新的关键字</li><li>C++中使用函数异常声明列表来查看函数可能抛出的异常。</li><li>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</li></ul><p>下例就是一个函数异常声明列表，该声明指出 func 可能抛出int和 double 类型的异常。</p><pre><code>void func() throw (int,double);</code></pre><p>但是在实际编程中很少使用这种写法，所以这一特性在 C++11 中被抛弃。另外，如果异常声明列表写成如下形式：</p><pre><code>void func() throw();</code></pre><p>这种写法表示函数 func 不抛出任何异常，而这种写法在 c++11 中被新的关键字 noexcept 异常声明所取代。语法上 noexcept 修饰符有两种形式，一种就是简单地在函数声明后加上 noexcept 关键字。比如：</p><pre><code>void func() noecept;</code></pre><p>另外一种形式则是接受一个常量表达式作为参数，如下所示：</p><pre><code>void func() noexcept(常量表达式);</code></pre><p>常量表达式的结果会被转换成一个 bool 类型的值，该值为 true，表示函数不会抛出异常，反之则可能抛出异常。而不带常量表达式的 noexcept相当于声明了 noexcept(true)，即不会抛出异常。</p><p><strong>以下情形鼓励使用noexcept：</strong></p><ul><li>移动构造函数（move constructor）</li><li>移动分配函数（move assignment）</li><li>析构函数（destructor）</li></ul><p><img src="/2022/10/11/cpp/hj/otherthings/noexcept.png"></p><p><strong>不是以上情况或者没把握的情况下，不要轻易使用noexception。</strong></p><h2 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h2><p>override关键字作用：<br>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。<br>如果派生类里面想要重载虚函数 就加上关键字override 这样编译器可以辅助检查是不是正确重载，如果没加这个关键字 也没什么严重的error 只是少了编译器检查的安全性。</p><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>C++11的关键字final有两个用途。</p><ul><li>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</li><li>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面。</li></ul><p>具体例子如下所示：</p><pre><code>struct Base&#123;    virtual void foo();&#125;;struct A : Base&#123;    void foo() final; // Base::foo 被覆盖而 A::foo 是最终覆盖函数    void bar() final; // 错误：非虚函数不能被覆盖或是 final&#125;;struct B final : A // struct B 为 final&#123;    void foo() override; // 错误：foo 不能被覆盖，因为它在 A 中是 final&#125;;struct C : B // 错误：B 为 final&#123;&#125;;</code></pre><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>auto，用于通过一个表达式在编译时确定待定义的变量类型，auto 所修饰 的变量必须被初始化，编译器需要通过初始化来确定auto 所代表的类型，即必须要定义变 量。<br>若仅希望得到类型，而不需要（或不能）定义变量的时候应该怎么办呢？ C++11 新增了decltype 关键字，用来在编译时推导出一个表达式的类型。它的语法格式 如下：</p><pre><code>decltype(exp)</code></pre><p>其中，exp 表示一个表达式（expression）</p><p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。</p><pre><code>#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;class Base &#123;public:    void func(T&amp; container) &#123;        m_it = container.begin();    &#125;private:    typename T::iterator m_it;  //注意这里&#125;;int main()&#123;    const vector&lt;int&gt; v;    Base&lt;const vector&lt;int&gt;&gt; obj;    obj.func(v);    return 0;&#125;</code></pre><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template Template Parameter</title>
      <link href="/2022/10/11/cpp/hj/TemplateTemplateParameter/"/>
      <url>/2022/10/11/cpp/hj/TemplateTemplateParameter/</url>
      
        <content type="html"><![CDATA[<h1 id="Template-Template-Parameter"><a href="#Template-Template-Parameter" class="headerlink" title="Template Template Parameter"></a>Template Template Parameter</h1><p>接Alias Template<br>我们还是想解决这个问题<br><img src="/2022/10/11/cpp/hj/TemplateTemplateParameter/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B01.png"><br>通过模板模板参数，我们可以采用下面这个方法<br><img src="/2022/10/11/cpp/hj/TemplateTemplateParameter/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png"><br>这个程序编译是可以通过的，但是调用的过程中会产生下面的错误<br><img src="/2022/10/11/cpp/hj/TemplateTemplateParameter/%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png"><br>仔细分析报错信息我们会发现<br><img src="/2022/10/11/cpp/hj/TemplateTemplateParameter/vector.png"><br>事实上，容器第二个参数在模板中需要传参<br><img src="/2022/10/11/cpp/hj/TemplateTemplateParameter/%E5%88%AB%E5%90%8D%E8%B0%83%E7%94%A8.png"><br>通过别名调用才是正确的结果，这说明别名的存在有很大作用，需要细细体会</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alias Template</title>
      <link href="/2022/10/11/cpp/hj/Alias%20Template/"/>
      <url>/2022/10/11/cpp/hj/Alias%20Template/</url>
      
        <content type="html"><![CDATA[<h1 id="Alias"><a href="#Alias" class="headerlink" title="Alias"></a>Alias</h1><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>传统方法使用关键字 typedef。<br>C++新标准规定了一种新方法，使用关键字 using 进行 别名申明（alias declaration）来定义类型的别名。<br>从使用语法来看 using 比 typedef 更加简洁明了，推荐使用 using 关键字进行别名定义。</p><ul><li>typedef void (*func)(int, int);</li><li>using func&#x3D; void(*) (int,int);</li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><ul><li>using vec &#x3D; std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</li><li>使用#define无法达到同样的效果</li><li>使用typedef也无法达到同样的效果，因为typedef不接受参数，只能提供特化的内容在</li><li>标准 C++，typedef 可定义模板类型一个新的类型名称，但是不能够使用 typedef 来定义模板的别名。举例来说：</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>别名的作用难道就是少打几个字嘛？<br><img src="/2022/10/11/cpp/hj/Alias%20Template/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%951.png" alt="错误案例1"></p><p><img src="/2022/10/11/cpp/hj/Alias%20Template/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%95.png" alt="错误案例2"></p><p>正确用法<br><img src="/2022/10/11/cpp/hj/Alias%20Template/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%953.png" alt="错误案例2"></p><p>但是我们并没有成功的传入模板参数T，还是有些遗憾，那么该如何解决呢？<br>后续内容请参考<a href="./TemplateTemplateParameter.md">模板模板参数</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Initialization</title>
      <link href="/2022/10/10/cpp/Initialization/"/>
      <url>/2022/10/10/cpp/Initialization/</url>
      
        <content type="html"><![CDATA[<h1 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h1><pre><code>int    values[ ] &#123;1, 2, 3&#125;;vector&lt;int&gt; v&#123; 2, 3, 5, 7, 11, 13, 17  &#125;;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Variadic Templates</title>
      <link href="/2022/10/10/cpp/hj/Variadic_Templates/"/>
      <url>/2022/10/10/cpp/hj/Variadic_Templates/</url>
      
        <content type="html"><![CDATA[<h1 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h1><h2 id="数量不定的模板参数："><a href="#数量不定的模板参数：" class="headerlink" title="数量不定的模板参数："></a>数量不定的模板参数：</h2><p>Variadic Template是C++11的一个很重要的特性；</p><p>变体现在两个方面：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归调用；</li><li>参数类型：参数个数逐一递减导致参数类型也逐一递减；</li></ul><p>两个注意点</p><ul><li>递归调用</li><li>递归终止：使用重载的办法终止递归调用；</li></ul><p><img src="https://i.imgur.com/PheGO3f.png"></p><h2 id="递归函数方式展开参数包"><a href="#递归函数方式展开参数包" class="headerlink" title="递归函数方式展开参数包"></a>递归函数方式展开参数包</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>以print函数为例，该模板参数将可以把参数不断地递归分解参数，不断递归调用print本身将参数打印出来了，但是最后一个打印完后没有参数了，所以还需要写一个参数为零的print()。 </p><pre><code>void print() &#123;&#125;template&lt;typename T,typename...Types&gt;void print(const T&amp; firstArg, const Types&amp;...args) &#123;    cout &lt;&lt; firstArg &lt;&lt; endl;    printX(args...);&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code>int maximun(int n)&#123;    return n;&#125;template&lt;typename...Args&gt;int maximun(int n,Args...args)&#123;    return std::max(n,maximun(args...));&#125;</code></pre><h2 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h2><pre><code>template &lt;class T&gt;void printarg(T t)&#123;cout &lt;&lt; t &lt;&lt; endl;&#125;template &lt;class ...Args&gt;void expand(Args... args)&#123;int arr[] = &#123;(printarg(args), 0)...&#125;;&#125;expand(1,2,3,4);</code></pre><p>这个例子将分别打印出1,2,3,4四个数字。这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p><pre><code>d = (a = b, c); </code></pre><p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p><p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。我们可以把上面的例子再进一步改进一下，将函数作为参数，就可以支持lambda表达式了，从而可以少写一个递归终止函数了，具体代码如下：</p><pre><code>template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args) &#123;    initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;&#125;expand([](int i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2,3);</code></pre><p>上面的例子将打印出每个参数，这里如果再使用C++14的新特性泛型lambda表达式的话，可以写更泛化的lambda表达式了：</p><pre><code>expand([](auto i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2.0,”test”);</code></pre><p>主要内容摘自<a href="https://www.cnblogs.com/qicosmos/p/4325949.html">https://www.cnblogs.com/qicosmos/p/4325949.html</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2022/10/07/zSTL/STL/"/>
      <url>/2022/10/07/zSTL/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>六大部件</strong></p><ul><li>分配器</li><li>容器</li><li>迭代器</li><li>算法</li><li>仿函数</li><li>适配器</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>分为</p><ul><li>Sequence Containers<ul><li>Array</li><li>Vector</li><li>Deque</li><li>List</li><li>Forward-List</li></ul></li><li>Associative Containers<ul><li>Set&#x2F;Multiset</li><li>Map&#x2F;Multimap</li><li>Unordered Set&#x2F;Multiset</li><li>Unordered Map&#x2F;Multimap</li></ul></li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td></tr><tr><td><code>deque</code></td><td>双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</td></tr></tbody></table><ul><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2022/10/02/cpp/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr/"/>
      <url>/2022/10/02/cpp/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/unique_ptr/</url>
      
        <content type="html"><![CDATA[<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。因此，要想使用unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</memory></T></p><pre><code>#include &lt;memory&gt;using namespace std;</code></pre><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>通过以下  2 种方式，可以创建出空的 unique_ptr 指针：</p><pre><code>std::unique_ptr&lt;int&gt; p1();std::unique_ptr&lt;int&gt; p2(nullptr);</code></pre><p>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</p><pre><code>std::unique_ptr&lt;int&gt; p3(new int);</code></pre><p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</T></p><h2 id="unique-ptr的实现"><a href="#unique-ptr的实现" class="headerlink" title="unique_ptr的实现"></a>unique_ptr的实现</h2><pre><code>template&lt;typename T&gt;struct AutoPtr4&#123;    AutoPtr4(T* ptr = nullptr)        : ptr(ptr)    &#123;    &#125;    ~AutoPtr4()    &#123;        if(this-&gt;ptr != nullptr)        &#123;            delete this-&gt;ptr;            this-&gt;ptr = nullptr;        &#125;    &#125;    AutoPtr4(const AutoPtr4&amp; ptr4) = delete; // disable copying    AutoPtr4(AutoPtr4&amp;&amp; ptr4) noexcept // move constructor        : ptr(ptr4)    &#123;        ptr4.ptr = nullptr;    &#125;    AutoPtr4&amp; operator=(const AutoPtr4&amp; ptr4) = delete; // disable copy assignment    AutoPtr4&amp; operator=(AutoPtr4&amp;&amp; ptr4) noexcept // move assignment    &#123;        if(this == &amp;ptr4)        &#123;            return *this;        &#125;        delete this-&gt;ptr;        this-&gt;ptr = ptr4.ptr;        ptr4.ptr = nullptr;        return *this;    &#125;    T&amp; operator*() const    &#123;        return *this-&gt;ptr;    &#125;    T* operator-&gt;() const    &#123;        return this-&gt;ptr;    &#125;    bool isNull() const    &#123;        return this-&gt;ptr == nullptr;    &#125;private:    T* ptr;&#125;;从中可以看到，unique_ptr禁用了拷贝构造和拷贝赋值构造，仅仅实现了移动构造和移动赋值构造，这也就使得它是独占式的。</code></pre><p>从中可以看到，unique_ptr禁用了拷贝构造和拷贝赋值构造，仅仅实现了移动构造和移动赋值构造，这也就使得它是独占式的。</p><h2 id="unique-ptr的基本使用"><a href="#unique-ptr的基本使用" class="headerlink" title="unique_ptr的基本使用"></a>unique_ptr的基本使用</h2><p>下面是一个unique_ptr的例子,此处的res是在栈上的局部变量，在main()结束时会被销毁，它管理的资源也会被释放掉。</p><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptrstruct Resource&#123;    Resource() &#123; std::cout &lt;&lt; &quot;Resource acquired\n&quot;; &#125;    ~Resource() &#123; std::cout &lt;&lt; &quot;Resource destroyed\n&quot;; &#125;&#125;;int main()&#123;    // allocate a Resource object and have it owned by std::unique_ptr    std::unique_ptr&lt;Resource&gt; res&#123; new Resource() &#125;;    return 0;&#125; // the allocated Resource is destroyed here</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建器模式</title>
      <link href="/2022/10/02/DesignMode/%E6%9E%84%E5%BB%BA%E5%99%A8/"/>
      <url>/2022/10/02/DesignMode/%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="构建器模式"><a href="#构建器模式" class="headerlink" title="构建器模式"></a>构建器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造者(构建器)–Builder模式, 是将一个复杂对象的构建与表示相分离,是的同样的构建过程可以有不同的创建表示.<br>将一个复杂的对象分解了多个简单的对象, 然后一步步的构建成.达到了将变与不变相分离, 即组成部分是不变的, 但是是每一部分又可以达到灵活选择.<br>Builder模式隐藏了复杂对象的创建过程, 将复杂对象在创建过程加以抽象, 通过子类基础或重载的方式,动态创建具有符合属性的对象.</p><h2 id="Builder优缺点"><a href="#Builder优缺点" class="headerlink" title="Builder优缺点"></a>Builder优缺点</h2><p><strong>优点</strong></p><ul><li>各个具体的构建器都是相互独立的, 利于系统的扩展</li><li>客户端不必知道具体产品内部的实现</li></ul><p><strong>缺点</strong></p><ul><li>产品组成部分必须要相同, 限制了使用范围</li><li>假如产品内部变化复杂, 会增加更多的建造者类</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>隔离复杂对象的创建和使用，同样的方法不同的执行顺序，从而产生不同事件的结果</li><li>初始化对象时，参数很多或者很多参数都具有默认值</li><li>不适合创建差异化很大的产品类，如果产品内部变化负责时，会导致定义很多建造者来实现变化，增加类的数量，增加了运行成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎</title>
      <link href="/2022/10/02/DataBase/MySQL/InnoDB/"/>
      <url>/2022/10/02/DataBase/MySQL/InnoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:<br><img src="/2022/10/02/DataBase/MySQL/InnoDB/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>行，InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：</p><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/2022/10/02/DataBase/MySQL/InnoDB/InnoDB%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 </p><p><img src="/2022/10/02/DataBase/MySQL/InnoDB/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg"></p><p>接下来介绍一下这四个部分。<br><strong>Buffer Pool</strong></p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。<br>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul><p>在专用服务器上，通常将多达 80 ％的物理内存分配给缓冲池 。<br>参数设置：     </p><pre><code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></pre><p>**Change Buffer **</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：<br><img src="/2022/10/02/DataBase/MySQL/InnoDB/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p><strong>Adaptive Hash Index</strong></p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<br>自适应哈希索引，无需人工干预，是系统根据情况自动完成。<br>参数： <code>adaptive_hash_index</code></p><p><strong>Log Buffer</strong></p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数:</p><pre><code>innodb_log_buffer_size：查看缓冲区大小innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：    0: 每秒将日志写入并刷新到磁盘一次。    1: 日志在每次事务提交时写入并刷新到磁盘，默认值1s。    2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</code></pre><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：<br><img src="/2022/10/02/DataBase/MySQL/InnoDB/image"></p><p><strong>System Tablespace</strong></p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等，8.0后主要存储更改缓冲区的数据)</p><p>参数：<code>innodb_data_file_path</code></p><p>系统表空间，默认的文件名叫 <code>ibdata1</code></p><p><strong>File-Per-Table Tablespaces</strong></p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p><p><strong>General Tablespaces</strong></p><p>通用表空间，需要通过<code>CREATE TABLESPACE</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name;</code></pre><p><strong>Undo Tablespaces</strong></p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（undo_001,undo_002,初始大小16M），用于存储undo log日志。</p><p><strong>Temporary Tablespaces</strong></p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p><strong>Doublewrite Buffer Files</strong></p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><strong>Redo Log</strong></p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：</p><pre><code>ib_logfile0ib_logfile1</code></pre><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><h4 id="线程类型-默认个数-职责"><a href="#线程类型-默认个数-职责" class="headerlink" title="线程类型 默认个数 职责"></a>线程类型 默认个数 职责</h4><p>在InnoDB的后台线程中，分为 4 类，分别是：Master Thread 、IO Thread、Purge Thread、<br>Page Cleaner Thread。</p><p><strong>Master Thread</strong></p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p><strong>IO Thread</strong></p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。<br>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p><pre><code>Read thread 负责读操作Write thread 负责写操作Log thread 负责将日志缓冲区刷新到磁盘Insert buffer thread 负责将写缓冲区内容刷新到磁盘</code></pre><p><strong>Purge Thread</strong></p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><p><strong>Page Cleaner Thread</strong></p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h3><p><strong>事务</strong></p><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>特性</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p>而对于这四大特性，实际上分为两个部分。 </p><ul><li>其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 </li><li>而持久性是通过数据库的锁，加上MVCC来保证的。</li></ul><p>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：</p><ul><li>重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo logfile）</li></ul><p>前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中<br>的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却<br>没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</p><p><img src="/2022/10/02/DataBase/MySQL/InnoDB/redolog.jpg"></p><p>有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo  log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment<br>回滚段中，内部包含 1024 个undo log segment。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>当前读</strong></p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</p><p>?测试：</p><h4 id="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"><a href="#在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内" class="headerlink" title="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"></a>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内</h4><p>容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们<br>加排他锁的时候，也是当前读操作。</p><h4 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2). 快照读"></a>2). 快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，<br>不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h4><h4 id="隐藏字段-含义"><a href="#隐藏字段-含义" class="headerlink" title="隐藏字段 含义"></a>隐藏字段 含义</h4><h4 id="DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"><a href="#DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。" class="headerlink" title="DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"></a>DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</h4><h4 id="DB-ROLL-PTR"><a href="#DB-ROLL-PTR" class="headerlink" title="DB_ROLL_PTR"></a>DB_ROLL_PTR</h4><p>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版<br>本。<br>DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。<br>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照<br>读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同<br>的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h4 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3). MVCC"></a>3). MVCC</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，<br>使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需<br>要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从<br>而来介绍一下MVCC的原理。</p><h3 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h3><h4 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h4><h4 id="当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。-实际上除了"><a href="#当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。-实际上除了" class="headerlink" title="当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了"></a>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了</h4><p>这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><h4 id="而上述的前两个字段是肯定会添加的，-是否添加最后一个字段DB-ROW-ID，得看当前表有没有主键，"><a href="#而上述的前两个字段是肯定会添加的，-是否添加最后一个字段DB-ROW-ID，得看当前表有没有主键，" class="headerlink" title="而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，"></a>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，</h4><h4 id="如果有主键，则不会添加该隐藏字段。"><a href="#如果有主键，则不会添加该隐藏字段。" class="headerlink" title="如果有主键，则不会添加该隐藏字段。"></a>如果有主键，则不会添加该隐藏字段。</h4><h4 id="6-4-2-2-测试"><a href="#6-4-2-2-测试" class="headerlink" title="6.4.2.2 测试"></a>6.4.2.2 测试</h4><p>1). 查看有主键的表 stu</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令:</p><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID<br>隐藏字段。</p><p>1 ibd2sdi stu.ibd</p><p>2). 查看没有主键的表 employee</p><p>建表语句：</p><h4 id="此时，我们再通过以下指令来查看表结构及其其中的字段信息："><a href="#此时，我们再通过以下指令来查看表结构及其其中的字段信息：" class="headerlink" title="此时，我们再通过以下指令来查看表结构及其其中的字段信息："></a>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</h4><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有<br>指定主键的。</p><p>1 create table employee (id int , name varchar( 10 ));<br>1 ibd2sdi employee.ibd</p><h3 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h3><h4 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即<br>被删除。</p><h4 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h4><h4 id="有一张表原始数据为："><a href="#有一张表原始数据为：" class="headerlink" title="有一张表原始数据为："></a>有一张表原始数据为：</h4><h4 id="DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"><a href="#DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是" class="headerlink" title="DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"></a>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是</h4><h4 id="自增的。"><a href="#自增的。" class="headerlink" title="自增的。"></a>自增的。</h4><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><h4 id="然后，有四个并发事务同时在访问这张表。"><a href="#然后，有四个并发事务同时在访问这张表。" class="headerlink" title="然后，有四个并发事务同时在访问这张表。"></a>然后，有四个并发事务同时在访问这张表。</h4><h4 id="A-第一步"><a href="#A-第一步" class="headerlink" title="A. 第一步"></a>A. 第一步</h4><p>当事务 2 执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="B-第二步"><a href="#B-第二步" class="headerlink" title="B.第二步"></a>B.第二步</h4><p>当事务 3 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="C-第三步"><a href="#C-第三步" class="headerlink" title="C. 第三步"></a>C. 第三步</h4><p>当事务 4 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条<br>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h3 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h3><h4 id="字段-含义"><a href="#字段-含义" class="headerlink" title="字段 含义"></a>字段 含义</h4><p>m_ids 当前活跃的事务ID集合<br>min_trx_id 最小活跃事务ID<br>max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）<br>creator_trx_id ReadView创建者的事务ID</p><h4 id="条件-是否可以访问-说明"><a href="#条件-是否可以访问-说明" class="headerlink" title="条件 是否可以访问 说明"></a>条件 是否可以访问 说明</h4><p>trx_id &#x3D;&#x3D;<br>creator_trx_id 可以访问该版本</p><h4 id="成立，说明数据是当前这个事"><a href="#成立，说明数据是当前这个事" class="headerlink" title="成立，说明数据是当前这个事"></a>成立，说明数据是当前这个事</h4><h4 id="务更改的。"><a href="#务更改的。" class="headerlink" title="务更改的。"></a>务更改的。</h4><p>trx_id &lt; min_trx_id 可以访问该版本 成立，说明数据已经提交了。<br>trx_id &gt; max_trx_id 不可以访问该版本 成立，说明该事务是在<br>ReadView生成后才开启。<br>min_trx_id &lt;&#x3D; trx_id<br>&lt;&#x3D; max_trx_id<br>如果trx_id不在m_ids中，<br>是可以访问该版本的 成立，说明数据已经提交。<br>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务<br>（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><p>不同的隔离级别，生成ReadView的时机不同：</p><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。<br>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p><h3 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h3><h4 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h4><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p><h4 id="我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的"><a href="#我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的" class="headerlink" title="我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?"></a>我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?</h4><p>在事务 5 中，查询了两次id为 30 的记录，由于隔离级别为Read Committed，所以每一次进行快照读<br>都会生成一个ReadView，那么两次生成的ReadView如下。</p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，<br>到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><h4 id="A-先来看第一次快照读具体的读取过程："><a href="#A-先来看第一次快照读具体的读取过程：" class="headerlink" title="A. 先来看第一次快照读具体的读取过程："></a>A. 先来看第一次快照读具体的读取过程：</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的"><a href="#先匹配-这条记录，这条记录对应的" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也<br>不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p><h4 id="再匹配第三条-，这条记"><a href="#再匹配第三条-，这条记" class="headerlink" title="再匹配第三条 ，这条记"></a>再匹配第三条 ，这条记</h4><p>录对应的trx_id为 2 ，也就是将 2 带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照<br>读，返回的数据就是版本链中记录的这条数据。</p><h4 id="B-再来看第二次快照读具体的读取过程"><a href="#B-再来看第二次快照读具体的读取过程" class="headerlink" title="B. 再来看第二次快照读具体的读取过程:"></a>B. 再来看第二次快照读具体的读取过程:</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的-1"><a href="#先匹配-这条记录，这条记录对应的-1" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次<br>快照读，返回的数据就是版本链中记录的这条数据。</p><h4 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可<br>重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该<br>ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返<br>回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。<br>而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2022/09/29/DataBase/MySQL/%E9%94%81/"/>
      <url>/2022/09/29/DataBase/MySQL/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</code></pre><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br>为什么全库逻辑备份，就需要加全就锁呢？</p><p><strong>A.  我们一起先来分析一下不加全局锁，可能存在的问题。</strong></p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。业务中执行插入订单日志操作。</li><li>最后，又备份了tb_orderlog表。</li><li>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</li></ul><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p><strong>B.  再来分析一下加了全局锁后的情况</strong></p><p> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>数据备份</p><pre><code>mysqldump -uroot –p1234 itcast &gt; itcast.sql</code></pre><p>释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</code></pre><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li>加锁：lock tables 表名... read&#x2F;write。</li><li>释放锁：unlock tables &#x2F; 客户端断开连接 。<br>特点:</li></ul><p>A.  读锁</p><p><img src="/2022/09/29/DataBase/MySQL/%E9%94%81/%E8%AF%BB%E9%94%81.png"></p><p>B.  写锁<br><img src="/2022/09/29/DataBase/MySQL/%E9%94%81/%E5%86%99%E9%94%81.png"></p><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。<br>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong><br>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。<br>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)。<br>常见的SQL操作时，所添加的元数据锁：</p><p><img src="/2022/09/29/DataBase/MySQL/%E9%94%81/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81.png"></p><p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ &#x2F; SHARED_WRITE），之间是兼容的。</p><p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><pre><code>select object_type,object_schema,object_name,lock_type,lock_duration fromperformance_schema.metadata_locks ;</code></pre><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。<br>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><ul><li>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</li><li>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</li></ul><p>有了意向锁之后 :</p><ul><li>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</li><li>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p><strong>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</strong><br>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><p>A.  意向共享锁与表读锁是兼容的<br>B.  意向排他锁与表读锁、写锁都是互斥的</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在</p><p>InnoDB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3></li></ul><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>两种行锁的兼容情况如下:<br><img src="/2022/09/29/DataBase/MySQL/%E9%94%81/%E8%A1%8C%E9%94%81%E5%85%BC%E5%AE%B9%E6%83%85%E5%86%B5.png"></p><h4 id="常见的SQL语句，在执行时，所加的行锁如下："><a href="#常见的SQL语句，在执行时，所加的行锁如下：" class="headerlink" title="常见的SQL语句，在执行时，所加的行锁如下："></a>常见的SQL语句，在执行时，所加的行锁如下：</h4><p><img src="/2022/09/29/DataBase/MySQL/%E9%94%81/%E6%B7%BB%E5%8A%A0%E8%A1%8C%E9%94%81%E7%B1%BB%E5%9E%8B.png"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><p>A. 普通的select语句，执行时，不会加锁。<br>B. select…lock in share mode，加共享锁</p><ul><li>共享锁与共享锁之间兼容。</li><li>共享锁与排他锁之间互斥。</li><li>排它锁与排他锁之间互斥。</li><li>无索引行锁升级为表锁。</li></ul><p>stu表中数据如下:</p><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><strong>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</strong></p><p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。<br>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p><p>分析一下：</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为 18 的数据，并加上共享锁，我们是只锁定 18 这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个 18 的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值。此时会对 18 加临键锁，并对间隙加锁。</p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p><p>[19]</p><p>(19,25]</p><p>(25,+∞]</p><p>所以数据库数据在加锁是，就是将 19 加了行锁， 25 的临键锁（包含 25 及 25 之前的间隙），正无穷的临<br>键锁(正无穷及之前的间隙)。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2022/09/29/DesignMode/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/29/DesignMode/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="装饰者模式原则"><a href="#装饰者模式原则" class="headerlink" title="装饰者模式原则"></a>装饰者模式原则</h2><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实质编程</li><li>为交互对象的松耦合设计而努力</li><li>对扩展开放，对修改关闭</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>桥模式</title>
      <link href="/2022/09/29/DesignMode/%E6%A1%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/29/DesignMode/%E6%A1%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>桥接模式是─种非常实用的对象结构型设计模式<br>当系统中某个类存在两个独立变化的维护.则可以通过桥接模式将这个维度分离出来,使两者可以独立扩展<br>桥接模式是一种巧妙的方式处理多层继承存在的问题用抽象关联取代了传统的多层继承将类之间的静态继承关系转换为动态的对象组合关系使得系统更加灵活并且易于扩展，同时有效控制了系统中类的个数，将抽象部分和它的实现部分分离，使它们都可以独立的变化。简单粗暴的说，就是抽象对外提供调用的接口；对外隐瞒实现部分，在抽象中引用实现部分，从而实现抽象对实现部分的调用，而抽象中引用的实现部分可以在今后的开发过程中，切换成别的实现部分。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>未使用桥模式：</p><pre><code>/*** 未使用桥模式* 缺点：类的数量暴增*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~Messager()&#123;&#125;&#125;;// 平台实现class PCMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class PCMessagerPerfect : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerLite : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerPerfect : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;void onProcess&#123;    Messager* meg = new MobileMessaferPerfect();    //编译时装配&#125;</code></pre><p>上述实例代码针对Messager基类有两个维度的变化，PC和Message，精简和完整版。此时需要将它们分离开来，充分利用组合的方式。将继承变成组合进行解耦重构。</p><pre><code>/*** 使用桥模式*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;        virtual ~Messager()&#123;&#125;&#125;;class MessagerImp&#123;public:    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~MessagerImp()&#123;&#125;&#125;;// 平台实现class PCMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public Messager&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerLite : public Messager&#123;    MessagerImp *messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerPerfect&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;void onProgress()&#123;    //运行时装配    MessagerImp* mImp = new MessagerImp();    Messager *m = new Messager();&#125;</code></pre><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>1). Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。<br>2). Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。<br>3). Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于的变化维度，这时可以使用Bridge的扩展模式。</p><p><strong>优缺点</strong></p><ul><li>优点<ul><li>分离抽象接口及其实现部分</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了”单一职责原则(SRP)”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了类的个数</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合”开闭原则(OCP)”.</li></ul></li><li>缺点<ul><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就就要针对抽象层进行设计与编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累</li></ul></li></ul><p><strong>使用场景</strong><br>    如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超过一半的数字</title>
      <link href="/2022/09/28/%E9%A2%98%E8%A7%A3/%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2022/09/28/%E9%A2%98%E8%A7%A3/%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中数字出现的个数</title>
      <link href="/2022/09/27/%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2022/09/27/%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中数字出现的个数"><a href="#数组中数字出现的个数" class="headerlink" title="数组中数字出现的个数"></a>数组中数字出现的个数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>输入：</p><pre><code>1 2 3 4 4 2</code></pre><p>输出：</p><pre><code>1 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code>这里只想到了如何快速获得一个只出现一次的数字，没有想到分组异或相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ret = 0;        for (int n : nums)            ret ^= n;        int div = 1;        while ((div &amp; ret) == 0)            div &lt;&lt;= 1;        int a = 0, b = 0;        for (int n : nums)            if (div &amp; n)                a ^= n;            else                b ^= n;        return vector&lt;int&gt;&#123;a, b&#125;;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触发器</title>
      <link href="/2022/09/27/DataBase/MySQL/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2022/09/27/DataBase/MySQL/%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触 发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。<br>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><h4 id="触发器类型-NEW-和-OLD"><a href="#触发器类型-NEW-和-OLD" class="headerlink" title="触发器类型 NEW 和 OLD"></a>触发器类型 NEW 和 OLD</h4><ul><li>INSERT 型触发器   NEW   表示将要或者已经新增的数据</li><li>UPDATE 型触发器   OLD   表示修改之前的数据 , NEW 表示将要或已经修改后的数据</li><li>DELETE 型触发器   OLD   表示将要或者已经删除的数据</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建 </p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGIN    trigger_stmt ;END;</code></pre><p>查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>删除</p><pre><code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ;<br>创建表结构：</p><pre><code>create table user_logs(    id int( 11 ) not null auto_increment,    operation varchar( 20 ) not null comment &#39;操作类型, insert/update/delete&#39;,    operate_time datetime not null comment &#39;操作时间&#39;,    operate_id int( 11 ) not null comment &#39;操作的ID&#39;,    operate_params varchar( 500 ) comment &#39;操作参数&#39;,    primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>定义插入触发器：</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES    (null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:    id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,    profession=&#39;, NEW.profession));end;</code></pre><p>定义更新触发器：</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES    (null, &#39;update&#39;, now(), new.id,    concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession));end; </code></pre><p>定义删除触发器：</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES    (null, &#39;delete&#39;, now(), old.id,    concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储过程</title>
      <link href="/2022/09/23/DataBase/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/23/DataBase/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li><p>封装，复用                  ————-&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p></li><li><p>可以接收参数，也可以返回数据  ————-&gt; 在存储过程中，可以传递参数，也可以接收返回</p></li><li><p>减少网络交互，效率提升       ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol><li><p>创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN    -- SQL语句END ;</code></pre></li><li><p>调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre></li><li><p>查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre></li><li><p>删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre></li></ol><p>命令行中分号会导致错误，需要用delimiter设置结束语句</p><pre><code>delimiter $$</code></pre><p>现在结束语句以$$结束</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p></blockquote><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><blockquote><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p></blockquote><ol><li><p>查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre></li></ol><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION，会话变量。<br>全局变量(GLOBAL): 全局变量针对于所有的会话。<br>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><ol start="2"><li><p>设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre></li></ol><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p><h4 id="演示示例"><a href="#演示示例" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1 ;insert into course(id, name) VALUES ( 6 , &#39;ES&#39;);set global autocommit = 0 ;select @@global.autocommit;</code></pre><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><blockquote><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 &quot;@变量名&quot; 使用就可以。其作用域为当前连接。会话一建立的连接会话二无法使用。</p></blockquote><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ol><li><p>方式一:</p><pre><code> 赋值时，可以使用 = ，也可以使用 := 推荐：= SELECT @var_name := expr [, @var_name := expr] ... ; SELECT 字段名 INTO @var_name FROM 表名;</code></pre></li><li><p>方式二:</p><pre><code> SET @var_name = expr [, @var_name = expr] ... ; SET @var_name := expr [, @var_name := expr] ... ;</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>SELECT @var_name ;</code></pre><h4 id="演示示例-1"><a href="#演示示例-1" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 赋值set @myname = &#39;itcast&#39;;set @myage := 10 ;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><p><strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。</p></blockquote><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><pre><code>select @abc;DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><h4 id="演示示例-2"><a href="#演示示例-2" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>create procedure p2()begin    declare stu_count int default 0 ;    select count(*) into stu_count from student;    select stu_count;end;call p2();</code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>if 用于做条件判断，具体的语法结构为：</p><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p3()begin    declare score int default 58 ;    declare result varchar( 10 );    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;    select result;end;call p3();</code></pre><blockquote><p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。<br>那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？ 答案是肯定的，我们可以通过接下来所讲解的 参数 来解决上述的问题。</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><ul><li>IN 该类参数作为输入，也就是需要调用时传入值</li><li>OUT 该类参数作为输出，也就是该参数可以作为返回值</li><li>INOUT 既可以作为输入参数，也可以作为输出参数</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>根据传入参数score，判定当前分数对应的分数等级，并返回。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p4(in score int, out result varchar( 10 ))begin    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;end;</code></pre><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回 。</p><pre><code>create procedure p5(inout score double)begin    set score := score * 0.5;end;</code></pre><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式： </p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>语法1</strong>：</p><pre><code>CASE case_value    WHEN when_value1 THEN statement_list1    [ WHEN when_value2 THEN statement_list2] ...    [ ELSE statement_list ]END CASE;</code></pre><p>– 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，<br>执行statement_list2， 否则就执行 statement_list</p><p><strong>语法2</strong>：</p><pre><code>CASE    WHEN search_condition1 THEN statement_list1    [WHEN search_condition2 THEN statement_list2] ...    [ELSE statement_list]END CASE;</code></pre><p>– 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</p><blockquote><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p></blockquote><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p><ul><li>1-3月份，为第一季度</li><li>4-6月份，为第二季度</li><li>7-9月份，为第三季度</li><li>10-12月份，为第四季度</li></ul><p>代码如下：</p><pre><code>create procedure p6(in month int)begin    declare result varchar( 10 );    case        when month &gt;= 1 and month &lt;= 3 then            set result := &#39;第一季度&#39;;        when month &gt;= 4 and month &lt;= 6 then            set result := &#39;第二季度&#39;;        when month &gt;= 7 and month &lt;= 9 then            set result := &#39;第三季度&#39;;        when month &gt;= 10 and month &lt;= 12 then            set result := &#39;第四季度&#39;;        else            set result := &#39;非法参数&#39;;    end case ;    select concat(&#39;您输入的月份为: &#39;,month, &#39;, 所属的季度为: &#39;,result);end;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DO    SQL逻辑...END WHILE;</code></pre><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p>计算从1累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p7(in n int)begin    declare total int default 0 ;    while n&gt; 0 do         set total := total + n;        set n := n - 1 ;    end while;    select total;end;</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEAT    SQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2). 案例"></a>2). 案例</h4><p>计算从 1 累加到n的值，n为传入的参数值。(使用repeat实现)</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p8(in n int)begin    declare total int default 0 ;    repeat        set total := total + n;        set n := n - 1 ;        until n &lt;= 0    end repeat;    select total;end;</code></pre><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p><pre><code>[begin_label:] LOOP    SQL逻辑...END LOOP [end_label];</code></pre><ul><li>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</li><li>LEAVE ：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>计算从 1 累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx</p><pre><code>create procedure p9(in n int)begin    declare total int default 0 ;    sum:loop    if n&lt;= 0 then        leave sum;    end if;        set total := total + n;        set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h5 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h5><p>计算从 1 到n之间的偶数累加的值，n为传入的参数值。<br>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx<br>– C. 如果当次累加的数据是奇数, 则直接进入下一次循环. ——–&gt; iterate xx</p><pre><code>create procedure p10(in n int)begin    declare total int default 0 ;    sum:loop        if n&lt;= 0 then            leave sum;        end if;        if n% 2 = 1 then            set n := n - 1 ;            iterate sum;        end if;            set total := total + n;            set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A.  声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B.  打开游标</p><pre><code>OPEN 游标名称 ;</code></pre><p>C.  获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D.  关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>– 逻辑:<br>– A. 声明游标, 存储查询结果集<br>– B. 准备: 创建表结构<br>– C. 开启游标<br>– D. 获取游标中的记录<br>– E. 插入数据到新表中<br>– F. 关闭游标</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。<br>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。</p><h2 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><pre><code>ECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action    CONTINUE: 继续执行当前程序    EXIT: 终止执行当前程序condition_value    SQLSTATE sqlstate_value: 状态码，如 02000    SQLWARNING: 所有以 01 开头的SQLSTATE代码的简写    NOT FOUND: 所有以 02 开头的SQLSTATE代码的简写    SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。<br>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>A.  通过SQLSTATE指定具体的状态码</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02000 时，将关闭游标u_cursor，并退出    declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>B.  通过SQLSTATE的代码简写方式 NOT FOUND 02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02 开头时，将关闭游标u_cursor，并退出    declare exit handler for not found close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        DETERMINISTIC：相同的输入参数总是产生相同的结果        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>具体的错误状态码，可以参考官方文档：**<a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a> <a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a>**</p><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN    -- SQL语句    RETURN ...;END ;</code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h3 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h3><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegin    declare total int default 0 ;    while n&gt; 0 do        set total := total + n;        set n := n - 1 ;    end while;    return total;end;</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错：</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图</title>
      <link href="/2022/09/23/DataBase/MySQL/%E8%A7%86%E5%9B%BE/"/>
      <url>/2022/09/23/DataBase/MySQL/%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><blockquote><p>特点:</p><p>封装，复用 -----------------------&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p><p>可以接收参数，也可以返回数据 --------&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p><p>减少网络交互，效率提升 -------------&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></blockquote><h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol><li>简单</li></ol><blockquote><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p></blockquote><ol start="2"><li>安全</li></ol><blockquote><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p></blockquote><ol start="3"><li>数据独立</li></ol><blockquote><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>创建</li><li>查询</li><li>修改</li><li>删除</li></ul><p>– 创建视图</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>– 查看创建视图语句：</p><pre><code>SHOW CREATE VIEW 视图名称;</code></pre><p>– 查看视图数据：</p><pre><code>SELECT * FROM 视图名称 ...... ;方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>– 删除视图</p><pre><code> DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</code></pre><p>– 创建视图</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 查询视图</p><pre><code>show create view stu_v_1;select * from stu_v_1;select * from stu_v_1 where id &lt; 3 ;</code></pre><p>– 修改视图</p><pre><code>create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10 ;alter view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 删除视图</p><pre><code>drop view if exists stu_v_1;</code></pre><p>执行下面的SQL，我们会发现，id为 6 和 17 的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id为 17 的记录。</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values( 6 ,&#39;Tom&#39;);insert into stu_v_1 values( 17 ,&#39;Tom22&#39;);</code></pre><p>因为我们在创建视图的时候，指定的条件为 id&lt;&#x3D;10, id为 17 的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。<br>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p><h3 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h3><h4 id="级联。"><a href="#级联。" class="headerlink" title="级联。"></a>级联。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><h3 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h3><h4 id="本地。"><a href="#本地。" class="headerlink" title="本地。"></a>本地。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><blockquote><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p></blockquote><p>A.  聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p><p>B.  DISTINCT</p><p>C.  GROUP BY</p><p>D.  HAVING</p><p>E.  UNION 或者 UNION ALL</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/2022/09/22/DesignMode/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_20220922195857226500.png" alt="模板方法模式"><br>个人理解大概就是覆盖和隐藏的应用</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用模板方法前</p><pre><code>//程序库开发人员class Library &#123;public:    void Step1() &#123;        //...    &#125;    void Step3() &#123;        //...    &#125;    void Step5() &#123;        //...    &#125;&#125;;//应用程序开发人员class Application &#123;public:    bool Step2() &#123;        //...    &#125;    void Step4() &#123;        //...    &#125;&#125;;int main()&#123;    Library lib;    Application app;    lib.Step1();    if (app.Step2()) &#123;        lib.Step3();    &#125;    for (int i = 0; i &lt; 4; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre><p>使用模板方法后</p><pre><code>//程序库开发人员class Library &#123;public:    //稳定 template method    void Run() &#123;        Step1();        if (Step2()) &#123; //支持变化 ==&gt; 虚函数的多态调用            Step3();        &#125;        for (int i = 0; i &lt; 4; i++) &#123;            Step4(); //支持变化 ==&gt; 虚函数的多态调用        &#125;        Step5();    &#125;    virtual ~Library() &#123; &#125;protected:    void Step1() &#123; //稳定        //.....    &#125;    void Step3() &#123;//稳定        //.....    &#125;    void Step5() &#123; //稳定        //.....    &#125;    virtual bool Step2() = 0;//变化    virtual void Step4() = 0; //变化&#125;;//应用程序开发人员class Application : public Library &#123;protected:    virtual bool Step2() &#123;        //... 子类重写实现    &#125;    virtual void Step4() &#123;        //... 子类重写实现    &#125;&#125;;int main()&#123;    Library* pLib = new Application();    pLib-&gt;Run();    delete pLib;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2022/09/22/DesignMode/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本两个不兼容的接口之间的桥梁，可以使接口不兼容导致不能一起工作的那些类可以一起工作。它包括类适配器和对象适配器.<br>在GoF的设计模式中，对适配器模式讲了两种类型，</p><ul><li>类适配器模式</li><li>对象适配器模式</li></ul><p>类适配器采用多继承方式，对象适配器采用对适配者Adaptee接口方式。两种方式都能完成Target接口与Adaptee接口对接。</p><p>类适配器模式通过多重继承对一个接口与另一个接口进行匹配，C#、VB.NET、JAVA等语言都不支持多重继承(C++支持)，也就是一个类只有一个父类</p><p>适配器模式主要应用在以下场景：</p><ul><li>新旧接口兼容软件版本升级，部分旧接口还在被使用。需要保留旧的接口，增加新接口，使两者兼容。</li><li>第三方接口的适配在系统功能稳定的情况下，有第三方新的接口需求需要对接。</li><li>统一多个类相同功能的接口例如统一不同类型数据库的访问接口。</li></ul><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="/2022/09/22/DesignMode/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Usb device connect phone */class CAdapter : public CUsbDisk&#123;public:    CAdapter()    &#123;        mpAdaptee = new CTypeCInterface();    &#125;    ~CAdapter()    &#123;        if (NULL != mpAdaptee) &#123;            delete mpAdaptee;        &#125;    &#125;    void ConnectDevice()    &#123;        if (NULL != mpAdaptee) &#123;            mpAdaptee-&gt;ConnectDevice();        &#125; else &#123;            cout &lt;&lt; &quot;Adapter abnormal. Connect fail!&quot; &lt;&lt; endl;        &#125;    &#125;private:    CTypeCInterface *mpAdaptee;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p> 比如电源适配的，一般家用电都是220V，但是手机充电只需要5V，此时手机充电器就相当于是一个适配器，将220V转成手机充电需要的5V。</p><p>220V电源：</p><pre><code>public class AC220V &#123;    public int output()&#123;        int output = 220;        System.out.println(&quot;输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>需要的5V电源：</p><pre><code>public interface DC5V &#123;    int output();&#125;</code></pre><p>变压器（也就是充电器）：</p><pre><code>public class Transformer implements DC5V&#123;    //包含了220V的属性    private AC220V ac220V ;    public Transformer(AC220V ac220V) &#123;        this.ac220V = ac220V;    &#125;    @Override    public int output() &#123;        int input = ac220V.output();        //经过相应的逻辑转换成需要的5V        int output = input / 44;        System.out.println(&quot;输入&quot;+input+&quot;v,输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>测试类：</p><pre><code>DC5V dc5V = new Transformer(new AC220V());dc5V.output();</code></pre><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p><img src="/2022/09/22/DesignMode/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Not only connect Usb port, but also connect Type-C port */class CAdapter : public CUsbDisk, public CTypeCInterface&#123;public:    void ConnectDevice()    &#123;        CTypeCInterface::ConnectDevice();    &#125;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对比</strong></p><ul><li>在类适配器中，由于适配器是适配者的子类，所以可以在适配器类中重写一些适配者的方法.使得适配器的灵活性更强</li><li>一个对象适配器可以把多个不同的适配者适配到同一个目标即同一个适配器可以把适配者类和它的子类都适配到目标接口</li></ul><p><strong>使用场景</strong></p><ul><li>系统需要使用现有的类，而此类的接口不符合系统的需要</li><li>需要创建一个可复用的类,该类可以与其他不相关的类或不可预见的类系统工作</li></ul><p><strong>优缺点</strong></p><ul><li>优点——可以让任何两个没有关联的类一起运行，提高了类的复用</li><li>缺点——过度使用适配器，会让系统杂乱无章，不利整体进行把握</li></ul><p>适配器模式主要原理: 在于实现客户接口时，关联上已存在的功能接口。一种使用过多继承方式，一种通过类之间依赖的方式，都能实现。<br>为统一多个功能相同的类接口时，类适配器模式是更适合的。比较典型的例子如，MySql和SQLServer等多种类型数据库的访问接口的统一。<br>《Effective C++》曾告诫程序猿们: C++编程不要轻易使用多继承，除非忍不住！<br>另外，文中也有说过。在软件开发初，无第三方需求接口的情况下，不要考虑此模式的使用。往往适配器模式的使用，会让代码看起来像一个补丁，修修补补。<br>「适配器模式」看起来与「外观模式」相似，都是与外部对接。其实有很大不同: 「外观模式」是定义一套新的接口，而「适配器模式」则是运用已有的接口。「外观模式」是在已有复杂的接口上，再封一层简单的接口，方便客户端使用。「适配器模式」则是结合已有的功能，实现或重载已经存在的客户端接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2022/09/22/DesignMode/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>用建造者模式描述简单的电脑组装，电脑组装是个复杂的过程，它包括显示器、鼠标、键盘、主机（主机又包括cpu、显卡、主板等）、耳机等等，我们不可能自己去组装电脑，我们是将自己的配置需求告诉老板，老板安排技术人员组装电脑，然后将电脑交给我们。通过组装电脑可以看出建造者模式的特点：都是由各个简单的对象（电脑各个部件）组成，各个部件（各种各样的显卡、各种各样的cpu等）都可以灵活选择，但是创建产品的步骤大同小异（技术人员组装电脑的过程）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>具体电脑类：</p><pre><code>class Computer&#123;public:    Computer() = default;    ~Computer() &#123;&#125;;    void show()    &#123;        cout &lt;&lt; &quot;电脑创建出来了&quot;&lt;&lt;endl;        cout &lt;&lt; &quot;组成部分：&quot; &lt;&lt; endl;        for (auto t = vec.cbegin(); t != vec.cend(); t++)        &#123;            cout &lt;&lt; * t &lt;&lt; endl;        &#125;    &#125;    void setDisplayer(string displayer) &#123;         vec.push_back(displayer);     &#125;    void setMouse(string mouse) &#123; vec.push_back(mouse); &#125;    void setKeyBoard(string keyboard) &#123; vec.push_back( keyboard); &#125;    void setHost(string host) &#123; vec.push_back(host); &#125;private:    vector&lt;string &gt; vec;&#125;;</code></pre><p>抽象建造者类：</p><pre><code>class Builder&#123;public:    Builder() = default;    ~Builder() &#123; delete pCo; &#125;    virtual void buildDisplayer(string display) &#123;&#125;;    virtual void buildMouse(string mouse) &#123;&#125;;    virtual void buildKeyBoard(string keyboard) &#123;&#125;;    virtual void buildHost(string host) &#123;&#125;;    Computer * getResult()    &#123;        return pCo;    &#125;protected:    Computer *pCo = new Computer();&#125;;</code></pre><p>具体建造者类（组装电脑的技术人员）：</p><pre><code>class ConcreteBuilder :public Builder&#123;public:    ConcreteBuilder() = default;    ~ConcreteBuilder() &#123;&#125;;    void buildDisplayer(string display)    &#123;        pCo-&gt;setDisplayer(display);    &#125;    void buildMouse(string mouse)    &#123;        pCo-&gt;setMouse(mouse);    &#125;    void buildKeyBoard(string keyboard)    &#123;        pCo-&gt;setKeyBoard(keyboard);    &#125;    void buildHost(string host)    &#123;        pCo-&gt;setHost(host);    &#125;&#125;;</code></pre><p>指挥者（卖电脑的老板）:</p><pre><code>class Director&#123;public:    Director(Builder *pBu) &#123; pBuilder = pBu; &#125;     ~Director() &#123; delete pBuilder; &#125;;    Computer *Construct(string display,string mouse,string keyboard,string host)    &#123;        pBuilder-&gt;buildDisplayer(display);        pBuilder-&gt;buildMouse(mouse);        pBuilder-&gt;buildKeyBoard(keyboard);        pBuilder-&gt;buildHost(host);        return pBuilder-&gt;getResult();    &#125;private:    Builder *pBuilder;&#125;;</code></pre><p>比如说我们找老板买的电脑配置是三星显示器、牧马人鼠标、机械键盘、联想主机：</p><pre><code>int main()&#123;    Builder *pBu = new ConcreteBuilder();    Director *pDi = new Director(pBu);    Computer *pCo = pDi-&gt;Construct(&quot;三星显示器&quot;,&quot;牧马人鼠标&quot;,&quot;机械键盘&quot;,&quot;联想主机&quot;);    pCo-&gt;show();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="创建者模式和工厂模式的对比"><a href="#创建者模式和工厂模式的对比" class="headerlink" title="创建者模式和工厂模式的对比"></a>创建者模式和工厂模式的对比</h2><p>Factory模式中：</p><ul><li>有一个抽象的工厂</li><li>实现一个具体的工厂 - 汽车工厂</li><li>工厂生产的汽车A，得到汽车产品A</li><li>工厂生产汽车B，得到汽车产品B</li><li>实现了购买者和生产线的隔离，强调的是结果</li></ul><p>Builder模式</p><ul><li>引擎工厂生产引擎产品，得到汽车的部件A</li><li>轮胎工厂生产轮子产品，得到汽车部件B</li><li>底盘工厂生产车身产品，得到汽车部件C</li><li>将这些部件放到一起，形成刚好能够组装成一辆汽车的整体</li><li>这样做，目的是为了实现复杂对象生产线和其部件的解耦。强调的是过程</li></ul><p>两者的区别在于以下几种情况：</p><ul><li><p>工厂模式不考虑对象的组装过程，而直接生成一个我想要的对象。</p></li><li><p>Builder模式先一个个的创建对象的每一个部件，再统一组装成一个对象</p></li><li><p>工厂模式所解决的问题是，工厂生产产品</p></li><li><p>而Builder模式解决的是工厂控制产品 生成器组装各个部件的过程，然后从产品生成器中得到产品。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2022/09/22/DesignMode/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式也称为委托模式。<br>作用： 找一个对象来替我们访问某个对象。<br>意图:  为其他对象提供一种代理以控制对这个对象的访问。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F_20220922190144062739.png" alt="代理模式"></p><h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><p>代理模式的共同优点如下：</p><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li></ol><p>此外，不同类型的代理模式也具有独特的优点，例如：</p><ol><li><p>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</p></li><li><p>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</p></li><li><p>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</p></li><li><p>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>租房子模型</p><p> #include <iostream><br> #include <string><br> using namespace std;</string></iostream></p><p> class Person<br> {<br> public:<br> virtual void rentHouse() &#x3D; 0;<br> };</p><p> class Mike :public Person<br> {<br> public:<br> void rentHouse()<br> {<br>     cout &lt;&lt; “mike需要租一间房子！” &lt;&lt; endl;<br> }<br> };</p><p> &#x2F;&#x2F;代理<br> class Intermediary :public Person<br> {<br> public:<br> Intermediary(Person* person) :m_Person(person) {}<br> public:<br> void rentHouse()<br> {<br>     m_Person-&gt;rentHouse();<br>     cout &lt;&lt; “我是中介，我帮你找房子，但是要抽取10%佣金！” &lt;&lt; endl;<br> }<br> private:<br> Person* m_Person;<br> };</p><p> &#x2F;&#x2F;场景<br> int main()<br> {<br> Person* pMike &#x3D; new Mike;<br><br> &#x2F;&#x2F;找一个中介帮忙租房子<br> Person* intermediary &#x3D; new Intermediary(pMike);<br><br> intermediary-&gt;rentHouse();<br> return 0;<br> }</p></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是代理模式的具体应用<br>智能指针使用引用计数实现时，就是最好的使用代理模式的例子。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2022/09/22/DesignMode/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F_20220922185016499798.png" alt="原型模式"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在有一个简历 Resume 类，如果要批量复制简历对象，有哪些方法呢？</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string sex;    std::string age;public:    Resume() &#123;&#125;;    void SetPersonalInfo(const std::string&amp; name, const std::sting&amp; age)    &#123;        this.name = name;        this.age = age;    &#125;&#125;;int main()&#123;    Resume p1;    p1.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);    Resume p2;    p2.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);&#125;</code></pre><p>上述实现方式非常简单又容易理解，你需要几份简历，就定义几个简历对象。但是，这里有一个很严重的问题：一旦简历内容需要修改，那么所有的简历对象都需要改动。原型模式正是为了解决它而出现的。</p><p>原型模式</p><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string age;    std::string education;public:    Resume()     &#123;        std::cout &lt;&lt; &quot;Construct !&quot; &lt;&lt; std::endl;    &#125;;    Resume(const Resume&amp; resume)    &#123;        this-&gt;name = resume.name;           this-&gt;age = resume.age;        this-&gt;education = resume.education;        std::cout &lt;&lt; &quot;Copy Construct !&quot; &lt;&lt; std::endl;    &#125;    void SetPersonalInfo(const std::string&amp; name, const std::string&amp; age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void SetEducation(const std::string&amp; educatoin)    &#123;        this-&gt;education = educatoin;    &#125;    void PrintResume()    &#123;        std::cout &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age  &lt;&lt; &quot;, &quot; &lt;&lt; education &lt;&lt; std::endl;    &#125;    Resume* Clone()    &#123;        return new Resume(*this);    &#125;&#125;;int main()&#123;    Resume* p1 = new Resume();    p1-&gt;SetPersonalInfo(&quot;Tom&quot;, &quot;25&quot;);    p1-&gt;SetEducation(&quot;master&quot;);    p1-&gt;PrintResume();    Resume* p2 = p1-&gt;Clone();    p2-&gt;SetPersonalInfo(&quot;Jack&quot;, &quot;28&quot;);    p2-&gt;PrintResume();&#125;</code></pre><p>当我们定义了第一个简历对象 p1 时，如果再需要创建一个对象，直接调用 p1 中的克隆 Clone 方法，然后返回一个新的对象 p2. 如果想要定制化简历 p2 时，只需要在 p2 中修改与 p1 差异的地方就可以了。而 Clone 一定要借助于拷贝构造函数才能实现<br>所以，一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，对性能又是大大的提升。</p><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;iostream&gt;using namespace std;//接口class Prototype&#123;public :    Prototype()&#123;&#125;    virtual ~Prototype()&#123;&#125;    virtual Prototype * Clone() = 0;&#125;;//实现class ConcretePrototype : public Prototype&#123;public :    ConcretePrototype():m_counter(0)&#123;&#125;    virtual ~ConcretePrototype()&#123;&#125;    //拷贝构造函数    ConcretePrototype( const ConcretePrototype &amp; rhs)    &#123;        m_counter = rhs .m_counter;    &#125;    //复制自身    virtual ConcretePrototype * Clone()    &#123;        //调用拷贝构造函数        return new ConcretePrototype (*this );    &#125;private :    int m_counter;&#125;;int main(int argc , char **argv)&#123;    //生成对像    ConcretePrototype * conProA = new ConcretePrototype ();    //复制自身    ConcretePrototype * conProB = conProA-&gt;Clone();    delete conProA;    conProA= NULL ;    delete conProB;    conProB= NULL ;    return 0;&#125;</code></pre><p>浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。但我们可能更需要这样的一种需求，把要复制的对象所引用的对象都复制一遍。我们希望是a、b、c三个引用的对象都是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为‘深复制’，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。clone的时候要注意引用拷贝会发生浅拷贝的现象导致多个指针指向同一个内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2022/09/22/DesignMode/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/22/DesignMode/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>当一个对象的状态发生改变的时候，如何让依赖他的所有对象得到通知并进行相应的处理。</p><ul><li>稳定点 一对多的依赖关系（一变化 多跟着变化）</li><li>变化点 <ul><li>‘多’增加</li><li>‘多’减少</li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>丈夫下班的时候会告诉孩子和老婆，老公开车要往回走了</p><ul><li>孩子妈收到消息后开始做饭</li><li>孩子收到消息后，就赶紧收起手机，怕挨揍</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>观察者模式的核心思想是 1对多</p><p>传统写法：</p><pre><code>#include &lt;iostream&gt;class Son&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;爸爸回来了，赶紧去写作业&quot;&lt;&lt;std::endl;    &#125;&#125;;class Wife&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;老公回来了，去做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();    &#125;private:    Wife wife;    Son son;&#125;;int main()&#123;    Husband husband;    husband.Gohome();    return 0;&#125;</code></pre><p>这样写的不足如下：</p><p>如果关心丈夫的人变多了，比如老妈、老爸 ，这时候我们不得不去修改Husband的类</p><pre><code>class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();        mom.DoSomething();        ba.DoSomething();    &#125;private:    Wife wife;    Son son;    Mother mom;    Father ba;&#125;;</code></pre><p>人数少的时候，还可以应付，假如关心我的人有1000人，那这时候我们该怎么办</p><p><strong>开始重构，简单观察者模式，面向抽象编程</strong><br>观察者接口</p><pre><code>class ObserverInterface&#123;public:    virtual void dosomething()=0;    virtual ~ObserverInterface()&#123;&#125;&#125;;</code></pre><p>被观察者接口</p><pre><code>class SubjectInterface&#123;public:    virtual void Add(ObserverInterface* obr)=0;    virtual void Remove(ObserverInterface* obr)=0;    virtual void Notify()=0;    virtual ~SubjectInterface()&#123;&#125;&#125;;</code></pre><p>丈夫</p><pre><code>class Husband:public SubjectInterface&#123;public:    void Add(ObserverInterface* obr) override&#123;        observers.push_back(obr);    &#125;    void Remove(ObserverInterface* obr) override&#123;        auto pos=std::find(observers.begin(),observers.end(),obr);        if(pos!=observers.end())&#123;            observers.erase(pos);        &#125;    &#125;    void Notify() override&#123;        for(const auto&amp; obs:observers)&#123;            obs-&gt;dosomething();        &#125;    &#125;private:    std::vector&lt;ObserverInterface*&gt; observers;&#125;;</code></pre><p>孩子妈</p><pre><code>class Wife:public ObserverInterface&#123;public:    void dosomething() override&#123;        std::cout&lt;&lt;&quot;老公快回来了，开始做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>孩子</p><pre><code>class Son:public  ObserverInterface&#123;public:    void dosomething() override &#123;        std::cout&lt;&lt;&quot;爸爸快回来了，不能玩游戏了&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    Husband husband;    ObserverInterface* wife=new Wife;    ObserverInterface* son=new Son;    husband.Add(wife);    husband.Add(son);    //下班了 发消息    husband.Notify();    delete wife;    delete son;&#125;</code></pre><p>这样的好处是：再增加新的观察者，我们就不用修改Husband的类了，只需要添加到vector中就可以<br>不足是：需要自己做内存管理 delete</p><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>使用面向对象的抽象，Observer模式使得我们可以独立的改变目标与观察者，从而使二者之间的依赖关系松耦合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优化</title>
      <link href="/2022/09/21/DataBase/MySQL/%E4%BC%98%E5%8C%96/"/>
      <url>/2022/09/21/DataBase/MySQL/%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><strong>普通插入：</strong></p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p><strong>大批量插入：</strong><br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><p>客户端连接服务端时，加上参数 –local-infile（这一行在bash&#x2F;cmd界面输入）</p><pre><code>mysql --local-infile -u root -p</code></pre><p>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p><pre><code>set global local_infile = 1;select @@local_infile;</code></pre><p>执行load指令将准备好的数据，加载到表结构中</p><pre><code>load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></pre><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，默认为0.5，可以自己设置，在创建表或创建索引时指定</p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">详细内容参照黑马程序员数据库相关讲解</a></p><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号<ul><li>UUID:随机字符串（不重复）</li></ul></li><li>业务操作时，避免对主键的修改</li></ul><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为idx_user_pro_age_stat，则句式可以是select … where profession order by age，这样也符合最左前缀法则</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><p>– 此语句耗时很长</p><pre><code>select * from tb_sku limit 9000000, 10;</code></pre><p>– 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</p><pre><code>select id from tb_sku order by id limit 9000000, 10;</code></pre><p>– 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</p><pre><code>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</code></pre><p>– 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</p><pre><code>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</code></pre><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h2 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h2><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br>update student set no &#x3D; ‘123’ where id &#x3D; 1;，这句由于id有主键索引，所以只会锁这一行；<br>update student set no &#x3D; ‘123’ where name &#x3D; ‘test’;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2022/09/20/DataBase/MySQL/%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/09/20/DataBase/MySQL/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p><strong>优缺点：</strong></p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><p>select * from user where id &#x3D; 10;<br>select * from user where name &#x3D; ‘Arm’;<br>– 备注：id为主键，name字段创建的有索引</p><pre><code>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</code></pre><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><pre><code>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建索引：</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code></pre><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：</p><pre><code>SHOW INDEX FROM table_name;</code></pre><p>删除索引：</p><pre><code>DROP INDEX index_name ON table_name;</code></pre><p>案例：</p><p>– name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</p><pre><code>create index idx_user_name on tb_user(name);</code></pre><p>– phone手机号字段的值非空，且唯一，为该字段创建唯一索引</p><pre><code>create unique index idx_user_phone on tb_user (phone);</code></pre><p>– 为profession, age, status创建联合索引</p><pre><code>create index idx_user_pro_age_stat on tb_user(profession, age, status);</code></pre><p>– 为email建立合适的索引来提升查询效率</p><pre><code>create index idx_user_email on tb_user(email);</code></pre><p>– 删除索引</p><pre><code>drop index idx_user_email on tb_user;</code></pre><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p><pre><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code></pre><p>例：</p><pre><code>show global status like &#39;Com_______&#39;</code></pre><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>开启慢查询日志开关</p><pre><code>slow_query_log=1</code></pre><p>设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</p><pre><code>long_query_time=2</code></pre><p>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：</p><pre><code>show variables like &#39;slow_query_log&#39;;</code></pre><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p><pre><code>SELECT @@have_profiling;</code></pre><p>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：</p><pre><code>SET profiling = 1;</code></pre><p>查看所有语句的耗时：</p><pre><code>show profiles;</code></pre><p>查看指定query_id的SQL语句各个阶段的耗时：</p><pre><code>show profile for query query_id;</code></pre><p>查看指定query_id的SQL语句CPU的使用情况</p><pre><code>show profile cpu for query query_id;</code></pre><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><pre><code>直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</code></pre><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><ol><li>在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) &#x3D; ‘15’;这里对phone进行操作了</li><li>字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone &#x3D; 17799990015;，此处phone的值没有加引号进行了隐式类型转换。</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like ‘%工程’;，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>不使用哪个索引：</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>必须使用哪个索引：</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h3 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *当中的* 的使用。</p><p>explain 中 extra 字段含义：</p><ul><li>using index condition：查找使用了索引，但是需要回表查询数据</li><li>using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</li></ul><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name&#x3D;’xxx’;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name&#x3D;’xxx’;</p><p>所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p><strong>面试题</strong><br>一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br>select id, username, password from tb_user where username&#x3D;’itcast’;</p><pre><code>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</code></pre><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：create index idx_xxxx on table_name(columnn(n));<br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><pre><code>select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</code></pre><p>show index 里面的sub_part可以看到接取的长度</p><h3 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h3><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><pre><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code></pre><p>这句只会用到phone索引字段</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储引擎</title>
      <link href="/2022/09/20/DataBase/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2022/09/20/DataBase/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>MySQL体系结构：</strong></p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><ul><li>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。</li><li>存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。</li><li>默认存储引擎是InnoDB。</li></ul><p>相关操作：</p><p>– 查询建表语句</p><pre><code>show create table account;</code></pre><p>– 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(    ...) ENGINE=INNODB;</code></pre><p>– 查看当前数据库支持的存储引擎</p><pre><code>show engines;</code></pre><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：</p><pre><code>show variables like &#39;innodb_file_per_table&#39;;</code></pre><p>从idb文件提取表结构数据：（在cmd运行）</p><pre><code>ibd2sdi xxx.ibd</code></pre><p>InnoDB 逻辑存储结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Screenshot_20220920_193246_tv.danmaku.bili_20220920193701368683.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2022/09/20/DataBase/MySQL/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/09/20/DataBase/MySQL/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><p>– 1. 查询张三账户余额</p><pre><code>select * from account where name = &#39;张三&#39;;</code></pre><p>– 2. 将张三账户余额-1000</p><pre><code>update account set money = money - 1000 where name = &#39;张三&#39;;</code></pre><p>– 此语句出错后张三钱减少但是李四钱没有增加<br>    模拟sql语句错误</p><p>– 3. 将李四账户余额+1000</p><pre><code>update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p>– 查看事务提交方式</p><pre><code>SELECT @@AUTOCOMMIT;</code></pre><p>– 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</p><pre><code>SET @@AUTOCOMMIT = 0;</code></pre><p>– 提交事务</p><pre><code>COMMIT;</code></pre><p>– 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>– 设置手动提交后上面代码改为：</p><pre><code>select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><p>操作方式二：</p><p>开启事务：</p><pre><code>START TRANSACTION 或 BEGIN TRANSACTION;</code></pre><p>提交事务：</p><pre><code>COMMIT;</code></pre><p>回滚事务：</p><pre><code>ROLLBACK;</code></pre><p>操作实例：</p><pre><code>start transaction;select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><h2 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h2><ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h2 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>设置事务隔离级别：</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code></pre><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2022/09/20/DataBase/MySQL/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/09/20/DataBase/MySQL/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><p>– 查询员工姓名，及关联的部门的名称<br>1.隐式</p><pre><code>select e.name, d.name from employee as e, dept as d where e.dept = d.id;</code></pre><p>2.显式</p><pre><code>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><ul><li><p>左外连接：</p><p>  查询左表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>  相当于查询表1的所有数据，包含表1和表2交集部分数据</p></li><li><p>右外连接：</p><p>  查询右表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p></li></ul><p>例子：</p><p>左</p><pre><code>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</code></pre><p>右</p><pre><code>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</code></pre><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h2 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h2><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><p>– 查询员工及其所属领导的名字</p><pre><code>select a.name, b.name from employee a, employee b where a.manager = b.id;</code></pre><p>– 没有领导的也查询出来</p><pre><code>select a.name, b.name from employee a left join employee b on a.manager = b.id;</code></pre><h2 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h2><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 则对重复结果进行去重处理</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code></p><p><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><p>– 查询销售部所有员工</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>– 根据销售部部门ID，查询员工信息</p><pre><code>select * from employee where dept = 4;</code></pre><p>– 合并（子查询）</p><pre><code>select * from employee where dept = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>– 查询xxx入职之后的员工信息</p><pre><code>select * from employee where entrydate &gt; (select entrydate from employee where name = &#39;xxx&#39;);</code></pre><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><p>– 查询销售部和市场部的所有员工信息</p><pre><code>select * from employee where dept in (select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;);</code></pre><p>– 查询比财务部所有人工资都高的员工信息</p><pre><code>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#39;财务部&#39;));</code></pre><p>– 查询比研发部任意一人工资高的员工信息</p><pre><code>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#39;研发部&#39;));</code></pre><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><p>– 查询与xxx的薪资及直属领导相同的员工信息</p><pre><code>select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#39;xxx&#39;);</code></pre><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><p>– 查询与xxx1，xxx2的职位和薪资相同的员工</p><pre><code>select * from employee where (job, salary) in (select job, salary from employee where name = &#39;xxx1&#39; or name = &#39;xxx2&#39;);</code></pre><p>– 查询入职日期是2006-01-01之后的员工，及其部门信息</p><pre><code>select e.*, d.* from (select * from employee where entrydate &gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept = d.id;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="/2022/09/20/DataBase/MySQL/%E7%BA%A6%E6%9D%9F/"/>
      <url>/2022/09/20/DataBase/MySQL/%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><pre><code class="mysql">create table user(    id int primary key auto_increment,    name varchar(10) not null unique,    age int check(age &gt; 0 and age &lt; 120),    status char(1) default &#39;1&#39;,    gender char(1));</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><pre><code class="mysql">CREATE TABLE 表名(    字段名 字段类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</code></pre><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-x2F-更新行为"><a href="#删除-x2F-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2022/09/20/DataBase/MySQL/%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/20/DataBase/MySQL/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><p>– 拼接<br><code>SELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);</code><br>– 小写<br><code>SELECT LOWER(&#39;Hello&#39;);</code><br>– 大写<br><code>SELECT UPPER(&#39;Hello&#39;);</code><br>– 左填充<br><code>SELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 右填充<br><code>SELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 去除空格<br><code>SELECT TRIM(&#39; Hello World &#39;);</code><br>– 切片（起始索引为1）<br><code>SELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);</code></p><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><p>– DATE_ADD</p><pre><code>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</code></pre><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><pre><code>select    name,    (case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)from employee;select    name,    (case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;from employee;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2022/09/20/DataBase/MySQL/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/20/DataBase/MySQL/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><p>数据库语句后面记得加分号！</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>查询所有数据库：</p><pre><code>SHOW DATABASES;</code></pre><p>查询当前数据库：</p><pre><code>SELECT DATABASE();</code></pre><p>创建数据库：</p><pre><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code></pre><p>使用数据库：</p><pre><code>USE 数据库名;</code></pre><p><strong>注意事项</strong>：UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</p><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查询当前数据库所有表：</p><pre><code>SHOW TABLES;</code></pre><p>查询表结构：</p><pre><code>DESC 表名;</code></pre><p>查询指定表的建表语句：</p><pre><code>SHOW CREATE TABLE 表名;</code></pre><p>创建表：</p><pre><code>CREATE TABLE 表名(    字段1 字段1类型 [COMMENT 字段1注释],    字段2 字段2类型 [COMMENT 字段2注释],    字段3 字段3类型 [COMMENT 字段3注释],    ...    字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];最后一个字段后面没有逗号</code></pre><p>添加字段：</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>修改数据类型：</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></pre><p>修改字段名和字段类型：</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>删除字段：</p><pre><code>ALTER TABLE 表名 DROP 字段名;</code></pre><p>修改表名：</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名</code></pre><p>删除表：</p><pre><code>DROP TABLE [IF EXISTS] 表名;</code></pre><p>删除表，并重新创建该表：</p><pre><code>TRUNCATE TABLE 表名;</code></pre><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>添加数据<br>指定字段：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>全部字段：</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>批量添加数据：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></pre><p><strong>注意事项</strong></p><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li><li>更新和删除数据</li></ul><p>修改数据：</p><pre><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code></pre><p>例：</p><pre><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></pre><p>删除数据：</p><pre><code>DELETE FROM 表名 [ WHERE 条件 ];</code></pre><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p><strong>编写顺序</strong></p><ol><li>SELECT<br> 字段列表</li><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><p><strong>执行顺序</strong></p><ol><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li><ul><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li></ul></li><li>SELECT<br> 字段列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>查询多个字段：</p><p>SELECT 字段1, 字段2, 字段3, … FROM 表名;</p><p>SELECT * FROM 表名;</p><p>设置别名<br>：<br>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], … FROM 表名;</p><p>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], … FROM 表名;</p><p>去除重复记录：</p><p>SELECT DISTINCT 字段列表 FROM 表名;</p><p>转义：</p><p>SELECT * FROM 表名 WHERE name LIKE ‘&#x2F;_张三’ ESCAPE ‘&#x2F;‘<br>&#x2F; 之后的_不作为通配符</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><p>SELECT 字段列表 FROM 表名 WHERE 条件列表;</p><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr><tr><td>例子：</td><td></td></tr></tbody></table><p>– 年龄等于30</p><pre><code>select * from employee where age = 30;</code></pre><p>– 年龄小于30</p><pre><code>select * from employee where age &lt; 30;</code></pre><p>– 小于等于</p><pre><code>select * from employee where age &lt;= 30;</code></pre><p>– 没有身份证</p><pre><code>select * from employee where idcard is null or idcard = &#39;&#39;;</code></pre><p>– 有身份证</p><pre><code>select * from employee where idcard;select * from employee where idcard is not null;</code></pre><p>– 不等于</p><pre><code>select * from employee where age != 30;</code></pre><p>– 年龄在20到30之间</p><pre><code>select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;</code></pre><p>– 下面语句不报错，但查不到任何信息</p><pre><code>select * from employee where age between 30 and 20;</code></pre><p>– 性别为女且年龄小于30</p><pre><code>elect * from employee where age &lt; 30 and gender = &#39;女&#39;;</code></pre><p>– 年龄等于25或30或35</p><pre><code>select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);</code></pre><p>– 姓名为两个字</p><pre><code>select * from employee where name like &#39;__&#39;;</code></pre><p>– 身份证最后为X</p><pre><code>select * from employee where idcard like &#39;%X&#39;;</code></pre><h3 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h3><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：</p><pre><code>SELECT 聚合函数(字段列表) FROM 表名;</code></pre><p>例：</p><pre><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></pre><p>分组查询<br>语法：</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></pre><p><strong>where 和 having 的区别：</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。<br>例子：</li></ul><p>– 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</p><pre><code>select count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性数量</p><pre><code>select gender, count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性的平均年龄</p><pre><code>select gender, avg(age) from employee group by gender;</code></pre><p>– 年龄小于45，并根据工作地址分组</p><pre><code>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</code></pre><p>– 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</code></pre><p><strong>注意事项</strong></p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></pre><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><p>– 根据年龄升序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;</code></pre><p>– 两字段排序，根据年龄升序排序，入职时间降序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</code></pre><p><strong>注意事项:</strong> 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></pre><p>例子：</p><p>– 查询第一页数据，展示10条</p><pre><code>SELECT * FROM employee LIMIT 0, 10;</code></pre><p>– 查询第二页</p><pre><code>SELECT * FROM employee LIMIT 10, 10;</code></pre><p>注意事项</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><p><strong>DQL执行顺序</strong><br>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>查询用户：</p><pre><code>USE mysql;SELECT * FROM user;</code></pre><p>创建用户:</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>修改用户密码：</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></pre><p>删除用户：</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>例子：</p><p>– 创建用户test，只能在当前主机localhost访问</p><pre><code>create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><p>– 创建用户test，能在任意主机访问</p><pre><code>create user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;test&#39; identified by &#39;123456&#39;;</code></pre><p>– 修改密码</p><pre><code>alter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;</code></pre><p>– 删除用户</p><pre><code>drop user &#39;test&#39;@&#39;localhost&#39;;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><p>查询权限：</p><pre><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>授予权限：</p><pre><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;`</code></pre><p>撤销权限：</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合算法</title>
      <link href="/2022/09/16/zSTL/CommonSetAlgorithms/"/>
      <url>/2022/09/16/zSTL/CommonSetAlgorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h1><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>set_intersection &#x2F;&#x2F; 求两个容器的交集</li><li>set_union &#x2F;&#x2F; 求两个容器的并集</li><li>set_difference &#x2F;&#x2F; 求两个容器的差集</li></ul><h2 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h2><ul><li>求两个容器的交集</li></ul><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的交集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器</li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较小的值给目标容器开辟空间    vTarget.resize(min(v1.size(), v2.size()));    vector&lt;int&gt;::iterator itEnd =    set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器中取小值</li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h2 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h2><h5 id="求两个集合的并集"><a href="#求两个集合的并集" class="headerlink" title="求两个集合的并集"></a>求两个集合的并集</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的并集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li><li>返回目标容器的最后一个元素的迭代器地址</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个容器的和给目标容器开辟空间    vTarget.resize(v1.size() + v2.size());    //返回目标容器的最后一个元素的迭代器地址    vector&lt;int&gt;::iterator itEnd =    set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要两个容器相加</li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h2 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h2><h5 id="求两个集合的差集"><a href="#求两个集合的差集" class="headerlink" title="求两个集合的差集"></a>求两个集合的差集</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的差集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 &#x2F;&#x2F; </li><li>end1 容器 1 结束迭代器 &#x2F;&#x2F; </li><li>beg2 容器 2 开始迭代器 &#x2F;&#x2F; </li><li>end2 容器 2 结束迭代器 &#x2F;&#x2F;</li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较大的值给目标容器开辟空间    vTarget.resize( max(v1.size() , v2.size()));    //返回目标容器的最后一个元素的迭代器地址    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;    vector&lt;int&gt;::iterator itEnd =    set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器取较大值</li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算术生成算法</title>
      <link href="/2022/09/16/zSTL/CommonFunctionGenerationAlgorithms/"/>
      <url>/2022/09/16/zSTL/CommonFunctionGenerationAlgorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h1><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric></numeric></li></ul><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>accumulate &#x2F;&#x2F; 计算容器元素累计总和</li><li>fill &#x2F;&#x2F; 向容器中添加元素</li></ul><h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><h5 id="计算区间内-容器元素累计总和"><a href="#计算区间内-容器元素累计总和" class="headerlink" title="计算区间内 容器元素累计总和"></a>计算区间内 容器元素累计总和</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>accumulate(iterator beg, iterator end, value);</code></pre><ul><li>计算容器元素累计总和</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 起始值</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt;= 100 ; i++) &#123;        v.push_back(i);    &#125;    int total = accumulate(v.begin(), v.end(), 0 );    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：accumulate使用时头文件注意是-numeric，这个算法很实用"><a href="#总结：accumulate使用时头文件注意是-numeric，这个算法很实用" class="headerlink" title="总结：accumulate使用时头文件注意是 numeric，这个算法很实用"></a>总结：accumulate使用时头文件注意是 numeric，这个算法很实用</h5><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><ul><li>向容器中填充指定的元素<h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5>  fill(iterator beg, iterator end, value);</li><li>向容器中填充元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 填充的值</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.resize( 10 );    //填充    fill(v.begin(), v.end(), 100 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用fill可以将容器区间内元素填充为-指定的值"><a href="#总结：利用fill可以将容器区间内元素填充为-指定的值" class="headerlink" title="总结：利用fill可以将容器区间内元素填充为 指定的值"></a>总结：利用fill可以将容器区间内元素填充为 指定的值</h5>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用拷贝和替换算法</title>
      <link href="/2022/09/16/zSTL/CopyAndReplace/"/>
      <url>/2022/09/16/zSTL/CopyAndReplace/</url>
      
        <content type="html"><![CDATA[<h1 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h1><ul><li>copy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li>replace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li>replace_if &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li><li>swap &#x2F;&#x2F; 互换两个容器的元素</li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><h5 id="容器内指定范围的元素拷贝到另一容器中"><a href="#容器内指定范围的元素拷贝到另一容器中" class="headerlink" title="容器内指定范围的元素拷贝到另一容器中"></a>容器内指定范围的元素拷贝到另一容器中</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>copy(iterator beg, iterator end, iterator dest);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>dest 目标起始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i + 1 );    &#125;    vector&lt;int&gt; v2;    //分配大小    v2.resize(v1.size());    copy(v1.begin(), v1.end(), v2.begin());    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"><a href="#总结：利用copy算法在拷贝时，目标容器记得提前开辟空间" class="headerlink" title="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"></a>总结：利用copy算法在拷贝时，目标容器记得提前开辟空间</h5><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><h5 id="将容器内指定范围的旧元素修改为新元素"><a href="#将容器内指定范围的旧元素修改为新元素" class="headerlink" title="将容器内指定范围的旧元素修改为新元素"></a>将容器内指定范围的旧元素修改为新元素</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></pre><ul><li>将区间内旧元素 替换成 新元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>oldvalue 旧元素</li><li>newvalue 新元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //将容器中的 20 替换成 2000    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace(v.begin(), v.end(), 20 , 2000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace会替换区间内满足条件的元素"><a href="#总结：replace会替换区间内满足条件的元素" class="headerlink" title="总结：replace会替换区间内满足条件的元素"></a>总结：replace会替换区间内满足条件的元素</h5><h2 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h2><h5 id="将区间内满足条件的元素，替换成指定元素"><a href="#将区间内满足条件的元素，替换成指定元素" class="headerlink" title="将区间内满足条件的元素，替换成指定元素"></a>将区间内满足条件的元素，替换成指定元素</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></pre><ul><li>按条件替换元素，满足条件的替换成指定元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_pred 谓词</li><li>newvalue 替换的新元素</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;class ReplaceGreater30&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 30 ;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件"><a href="#总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件" class="headerlink" title="总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件"></a>总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</h5><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><h5 id="互换两个容器的元素"><a href="#互换两个容器的元素" class="headerlink" title="互换两个容器的元素"></a>互换两个容器的元素</h5><h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>swap(container c1, container c2);</code></pre><ul><li>互换两个容器的元素</li><li>c1容器 1</li><li>c2容器 2</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 100 );    &#125;    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    swap(v1, v2);    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：swap交换容器时，注意交换的容器要同种类型"><a href="#总结：swap交换容器时，注意交换的容器要同种类型" class="headerlink" title="总结：swap交换容器时，注意交换的容器要同种类型"></a>总结：swap交换容器时，注意交换的容器要同种类型</h5>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/2022/09/16/zSTL/CommonSortAlgorithm/"/>
      <url>/2022/09/16/zSTL/CommonSortAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><h3 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h3><pre><code>+ sort //对容器内元素进行排序+ random_shuffle //洗牌 指定范围内的元素随机调整次序+ merge // 容器元素合并，并存储到另一容器中+ reverse // 反转指定范围的元素</code></pre><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>sort(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;vector&lt;int&gt; v;v.push_back( 10 );v.push_back( 30 );v.push_back( 50 );v.push_back( 20 );v.push_back( 40 );//sort默认从小到大排序sort(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint);cout &lt;&lt; endl;//从大到小排序sort(v.begin(), v.end(), greater&lt;int&gt;());for_each(v.begin(), v.end(), myPrint);    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>random_shuffle(iterator beg, iterator end);</code></pre><ul><li>指定范围内的元素随机调整次序</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    srand((unsigned int)time(NULL));    vector&lt;int&gt; v;    for(int i = 0 ; i &lt; 10 ;i++)    &#123;        v.push_back(i);    &#125;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //打乱顺序    random_shuffle(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：random-shuffle洗牌算法比较实用，使用时记得加随机数种子"><a href="#总结：random-shuffle洗牌算法比较实用，使用时记得加随机数种子" class="headerlink" title="总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子"></a>总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</h5><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>容器元素合并，并存储到另一容器中</li><li>注意: 两个容器必须是有序的</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器</li></ul><h5 id="dest-目标容器开始迭代器"><a href="#dest-目标容器开始迭代器" class="headerlink" title="dest 目标容器开始迭代器"></a>dest 目标容器开始迭代器</h5><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i + 1 );    &#125;    vector&lt;int&gt; vtarget;    //目标容器需要提前开辟空间    vtarget.resize(v1.size() + v2.size());    //合并 需要两个有序序列    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());    for_each(vtarget.begin(), vtarget.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：merge合并的两个容器必须的有序序列"><a href="#总结：merge合并的两个容器必须的有序序列" class="headerlink" title="总结：merge合并的两个容器必须的有序序列"></a>总结：merge合并的两个容器必须的有序序列</h5><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h5 id="将容器内元素进行反转"><a href="#将容器内元素进行反转" class="headerlink" title="将容器内元素进行反转"></a>将容器内元素进行反转</h5><h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>reverse(iterator beg, iterator end);</code></pre><ul><li>反转指定范围的元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 20 );    v.push_back( 40 );    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;    reverse(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：reverse反转区间内元素，面试题可能涉及到"><a href="#总结：reverse反转区间内元素，面试题可能涉及到" class="headerlink" title="总结：reverse反转区间内元素，面试题可能涉及到"></a>总结：reverse反转区间内元素，面试题可能涉及到</h5>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="/2022/09/16/zSTL/CommomAlgorithm/"/>
      <url>/2022/09/16/zSTL/CommomAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h1><p>算法主要是由头文件algorithm functional numeric组成。</p><ul><li>algorithm是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历、操作、复制、修改等等</li><li>numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li>functional定义了一些模板类,用以声明函数对象。</li></ul><h2 id="遍历算法for-each"><a href="#遍历算法for-each" class="headerlink" title="遍历算法for_each"></a>遍历算法for_each</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>for_each(iterator beg, iterator end, _func);</code></pre><ul><li>遍历算法 遍历容器元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;//for_each算法基本用法void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //遍历算法    for_each(v.begin(), v.end(), print01);    cout &lt;&lt; endl;    for_each(v.begin(), v.end(), print02());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握"><a href="#总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握" class="headerlink" title="总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握"></a>总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握</h3><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul><li>搬运容器到另一个容器中</li></ul><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></pre><ul><li>beg1 源容器开始迭代器</li><li>end1 源容器结束迭代器</li><li>beg2 目标容器开始迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public:    int operator()(int val)    &#123;        return val;    &#125;&#125;class MyPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;vTarget; //目标容器    vTarget.resize(v.size()); // 目标容器需要提前开辟空间    transform(v.begin(), v.end(), vTarget.begin(), TransForm());    for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运"><a href="#总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运" class="headerlink" title="总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运"></a>总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</h3><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find(iterator beg, iterator end, value);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    //查找容器中是否有 5 这个元素    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5 );    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;class Person &#123;public:    Person(string name, int age)    this-&gt;m_Name = name;    this-&gt;m_Age = age;&#125;//重载==，否则自定义数据类型无法运行findbool operator==(const Person&amp; p)&#123;    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)    &#123;        return true;    &#125;    return false;&#125;public:    string m_Name;    int m_Age;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：-利用find可以在容器中找指定的元素，返回值是迭代器"><a href="#总结：-利用find可以在容器中找指定的元素，返回值是迭代器" class="headerlink" title="总结： 利用find可以在容器中找指定的元素，返回值是迭代器"></a>总结： 利用find可以在容器中找指定的元素，返回值是迭代器</h3><h2 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 函数或者谓词（返回bool类型的仿函数）</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public:    bool operator()(int val)    &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到大于 5 的数字:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;//自定义数据类型class Person &#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;public:    string m_Name;    int m_Age;&#125;;class Greater20&#123;public:    bool operator()(Person &amp;p)    &#123;        return p.m_Age &gt; 20 ;    &#125;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"><a href="#总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略" class="headerlink" title="总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"></a>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</h3><h2 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h2><h3 id="查找相邻重复元素"><a href="#查找相邻重复元素" class="headerlink" title="查找相邻重复元素"></a>查找相邻重复元素</h3><h3 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>adjacent_find(iterator beg, iterator end);</code></pre><ul><li>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 5 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 4 );    v.push_back( 3 );    //查找相邻重复元素    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法"><a href="#总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法" class="headerlink" title="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法"></a>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</h3><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h2><p>查找指定元素是否存在，返回值是bool类型</p><h3 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>bool binary_search(iterator beg, iterator end, value);</code></pre><ul><li>查找指定的元素，查到 返回true 否则false</li><li>注意: 在无序序列中不可用</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //二分查找    bool ret = binary_search(v.begin(), v.end(), 2 );    if (ret)    &#123;        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;    &#125;    else        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"><a href="#总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列" class="headerlink" title="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"></a>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</h3><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><h3 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h3><h3 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count(iterator beg, iterator end, value);</code></pre><ul><li>统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 统计的元素</li></ul><h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );       v.push_back( 4 );    v.push_back( 4 );    int num = count(v.begin(), v.end(), 4 );    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    bool operator==(const Person &amp; p)    &#123;        if (this-&gt;m_Age == p.m_Age)        &#123;            return true;        &#125;        else        &#123;            return false;        &#125;    &#125;    string m_Name;    int m_Age;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    Person p(&quot;诸葛亮&quot;, 35 );    int num = count(v.begin(), v.end(), p);    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D"><a href="#总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D" class="headerlink" title="总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;"></a>总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;</h5><h2 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h2><h3 id="函数原型：-7"><a href="#函数原型：-7" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按条件统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 4 ;    &#125;&#125;;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );    v.push_back( 4 );    v.push_back( 4 );    int num = count_if(v.begin(), v.end(), Greater4());    cout &lt;&lt; &quot;大于 4 的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class AgeLess35&#123;public:    bool operator()(const Person &amp;p)    &#123;        return p.m_Age &lt; 35 ;    &#125;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    int num = count_if(v.begin(), v.end(), AgeLess35());    cout &lt;&lt; &quot;小于 35 岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：按值统计用count，按条件统计用count-if"><a href="#总结：按值统计用count，按条件统计用count-if" class="headerlink" title="总结：按值统计用count，按条件统计用count_if"></a>总结：按值统计用count，按条件统计用count_if</h3>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内建函数对象</title>
      <link href="/2022/09/16/cpp/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/09/16/cpp/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h1><ul><li>STL内建了一些函数对象</li><li>头文件 functional<h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3></li><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数<h2 id="算数仿函数"><a href="#算数仿函数" class="headerlink" title="算数仿函数"></a>算数仿函数</h2><h3 id="仿函数原型："><a href="#仿函数原型：" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3></li><li>template<class t> T plus<T> &#x2F;&#x2F;加法仿函数</T></class></li><li>template<class t> T minus<T> &#x2F;&#x2F;减法仿函数</T></class></li><li>template<class t> T multiplies<T> &#x2F;&#x2F;乘法仿函数</T></class></li><li>template<class t> T divides<T> &#x2F;&#x2F;除法仿函数</T></class></li><li>template<class t> T modulus<T> &#x2F;&#x2F;取模仿函数</T></class></li><li>template<class t> T negate<T> &#x2F;&#x2F;取反仿函数<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5>  #include <functional><br>  &#x2F;&#x2F;negate<br>  void test01()<br>  {<br>  negate<int> n;<br>  cout &lt;&lt; n( 50 ) &lt;&lt; endl;<br>  }<br>  &#x2F;&#x2F;plus<br>  void test02()<br>  {<br>  plus<int> p;<br>  cout &lt;&lt; p( 10 , 20 ) &lt;&lt; endl;<br>  }<br>  int main() {<br>  test01();<br>  test02();<br>  system(“pause”);<br>  return 0 ;<br>  }</int></int></functional></T></class></li></ul><h2 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h2><h3 id="仿函数原型：-1"><a href="#仿函数原型：-1" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3><ul><li>template<class t> bool equal_to<T> &#x2F;&#x2F;等于</T></class></li><li>template<class t> bool not_equal_to<T> &#x2F;&#x2F;不等于</T></class></li><li>template<class t> bool greater<T> &#x2F;&#x2F;大于</T></class></li><li>template<class t> bool greater_equal<T> &#x2F;&#x2F;大于等于</T></class></li><li>template<class t> bool less<T> &#x2F;&#x2F;小于</T></class></li><li>template<class t> bool less_equal<T> &#x2F;&#x2F;小于等于</T></class></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:    bool operator()(int v1,int v2)    &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 40 );    v.push_back( 20 );    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //sort(v.begin(), v.end(), MyCompare());    //STL内建仿函数 大于仿函数    sort(v.begin(), v.end(), greater&lt;int&gt;());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：关系仿函数中最常用的就是greater-lt-gt-大于"><a href="#总结：关系仿函数中最常用的就是greater-lt-gt-大于" class="headerlink" title="总结：关系仿函数中最常用的就是greater&lt;&gt;大于"></a>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</h5><h2 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><ul><li>template<class t> bool logical_and<T> &#x2F;&#x2F;逻辑与</T></class></li><li>template<class t> bool logical_or<T> &#x2F;&#x2F;逻辑或</T></class></li><li>template<class t> bool logical_not<T> &#x2F;&#x2F;逻辑非</T></class></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;    vector&lt;bool&gt; v;    v.push_back(true);    v.push_back(false);    v.push_back(true);    v.push_back(false);    for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //逻辑非 将v容器搬运到v2中，并执行逻辑非运算    vector&lt;bool&gt; v2;    v2.resize(v.size());    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;());    for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：逻辑仿函数实际应用较少，了解即可"><a href="#总结：逻辑仿函数实际应用较少，了解即可" class="headerlink" title="总结：逻辑仿函数实际应用较少，了解即可"></a>总结：逻辑仿函数实际应用较少，了解即可</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map/multimap</title>
      <link href="/2022/09/15/zSTL/map/"/>
      <url>/2022/09/15/zSTL/map/</url>
      
        <content type="html"><![CDATA[<h1 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h1><h2 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h2><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><ul><li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>可以根据key值快速找到value值</li></ul><h4 id="map和multimap区别："><a href="#map和multimap区别：" class="headerlink" title="map和multimap区别："></a>map和multimap区别：</h4><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h2 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数:</p></li><li><p>map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int,int&gt;m; //默认构造    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    printMap(m);    map&lt;int, int&gt;m2(m); //拷贝构造    printMap(m2);    map&lt;int, int&gt;m3;    m3 = m2; //赋值    printMap(m3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h2 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    if (m.empty())    &#123;        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;    &#125;&#125;void test02()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    map&lt;int, int&gt;m2;    m2.insert(pair&lt;int, int&gt;( 4 , 100 ));    m2.insert(pair&lt;int, int&gt;( 5 , 200 ));    m2.insert(pair&lt;int, int&gt;( 6 , 300 ));    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printMap(m);    printMap(m2);    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    m.swap(m2);    printMap(m);    printMap(m2);&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h2><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    //插入    map&lt;int, int&gt; m;    //第一种插入方式    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    //第二种插入方式    m.insert(make_pair( 2 , 20 ));    //第三种插入方式    m.insert(map&lt;int, int&gt;::value_type( 3 , 30 ));    //第四种插入方式    m[ 4 ] = 40 ;    printMap(m);    //删除    m.erase(m.begin());    printMap(m);    m.erase( 3 );    printMap(m);    //清空    m.erase(m.begin(),m.end());    m.clear();    printMap(m);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    //查找    map&lt;int, int&gt;::iterator pos = m.find( 3 );    if (pos != m.end())    &#123;        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = m.count( 3 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h2><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;class MyCompare &#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    //默认从小到大排序    //利用仿函数实现从大到小排序    map&lt;int, int, MyCompare&gt; m;    m.insert(make_pair( 1 , 10 ));    m.insert(make_pair( 2 , 20 ));    m.insert(make_pair( 3 , 30 ));    m.insert(make_pair( 4 , 40 ));    m.insert(make_pair( 5 , 50 ));    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例-员工分组"></a>案例-员工分组</h3><h4 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h4><p>公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作<br>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发<br>随机给 10 名员工分配部门和工资<br>通过multimap进行信息的插入 key(部门编号) value(员工)<br>分部门显示员工信息</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>创建 10 名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><h5 id="案例代码："><a href="#案例代码：" class="headerlink" title="案例代码："></a>案例代码：</h5><pre><code>#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给 10 名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA 0#define MEISHU 1#define YANFA 2class Worker&#123;public:    string m_Name;    int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;    string nameSeed = &quot;ABCDEFGHIJ&quot;;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        Worker worker;        worker.m_Name = &quot;员工&quot;;        worker.m_Name += nameSeed[i];        worker.m_Salary = rand() % 10000 + 10000 ; // 10000 ~ 19999        //将员工放入到容器中        v.push_back(worker);    &#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        //产生随机部门编号        int deptId = rand() % 3 ; // 0 1 2        //将员工插入到分组中        //key部门编号，value具体员工        m.insert(make_pair(deptId, *it));    &#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);    int count = m.count(CEHUA); // 统计具体人数    int index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;    pos = m.find(MEISHU);    count = m.count(MEISHU); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;    pos = m.find(YANFA);    count = m.count(YANFA); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;&#125;int main() &#123;    srand((unsigned int)time(NULL));    //1、创建员工    vector&lt;Worker&gt;vWorker;    createWorker(vWorker);    //2、员工分组    multimap&lt;int, Worker&gt;mWorker;    setGroup(vWorker, mWorker);    showWorkerByGourp(mWorker);    ////测试    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)    //&#123;    // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set/multiset</title>
      <link href="/2022/09/15/zSTL/set/"/>
      <url>/2022/09/15/zSTL/set/</url>
      
        <content type="html"><![CDATA[<h1 id="set-x2F-multiset-容器"><a href="#set-x2F-multiset-容器" class="headerlink" title="set&#x2F; multiset 容器"></a>set&#x2F; multiset 容器</h1><h2 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>所有元素都会在插入时自动被排序</p><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><p>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</p><h3 id="set和multiset区别："><a href="#set和multiset区别：" class="headerlink" title="set和multiset区别："></a>set和multiset区别：</h3><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h2 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>set<T> st; &#x2F;&#x2F;默认构造函数：</T></p></li><li><p>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;        cout &lt;&lt; endl;    &#125;&#125;//构造和赋值void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //拷贝构造    set&lt;int&gt;s2(s1);    printSet(s2);    //赋值    set&lt;int&gt;s3;    s3 = s2;    printSet(s3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h2 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    if (s1.empty())    &#123;        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;    &#125;&#125;//交换void test02()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    set&lt;int&gt; s2;    s2.insert( 100 );    s2.insert( 300 );    s2.insert( 200 );    s2.insert( 400 );    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printSet(s1);    printSet(s2);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    s1.swap(s2);    printSet(s1);    printSet(s2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //删除    s1.erase(s1.begin());    printSet(s1);    s1.erase( 30 );    printSet(s1);    //清空    //s1.erase(s1.begin(), s1.end());    s1.clear();    printSet(s1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h2><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    //查找    set&lt;int&gt;::iterator pos = s1.find( 30 );    if (pos != s1.end())    &#123;        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = s1.count( 30 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;//set和multiset区别void test01()&#123;    set&lt;int&gt; s;    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        pair&lt;type, type&gt; p ( value1, value2 );        pair&lt;type, type&gt; p = make_pair( value1, value2 );        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;    &#125;    ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;    &#125;    //multiset    multiset&lt;int&gt; ms;    ms.insert( 10 );    ms.insert( 10 );    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h2 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h2><h5 id="两种创建方式："><a href="#两种创建方式：" class="headerlink" title="两种创建方式："></a>两种创建方式：</h5><pre><code>#include &lt;string&gt;//对组创建void test01()&#123;    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h2><h3 id="示例一-set存放内置数据类型"><a href="#示例一-set存放内置数据类型" class="headerlink" title="示例一 set存放内置数据类型"></a>示例一 set存放内置数据类型</h3><pre><code>#include &lt;set&gt;class MyCompare&#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 40 );    s1.insert( 20 );    s1.insert( 30 );    s1.insert( 50 );    //默认从小到大    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //指定排序规则    set&lt;int,MyCompare&gt; s2;    s2.insert( 10 );    s2.insert( 40 );    s2.insert( 20 );    s2.insert( 30 );    s2.insert( 50 );    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用仿函数可以指定set容器的排序规则"><a href="#总结：利用仿函数可以指定set容器的排序规则" class="headerlink" title="总结：利用仿函数可以指定set容器的排序规则"></a>总结：利用仿函数可以指定set容器的排序规则</h5><h3 id="示例二-set存放自定义数据类型"><a href="#示例二-set存放自定义数据类型" class="headerlink" title="示例二 set存放自定义数据类型"></a>示例二 set存放自定义数据类型</h3><pre><code>#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class comparePerson&#123;public:    bool operator()(const Person&amp; p1, const Person &amp;p2)    &#123;        //按照年龄进行排序 降序        return p1.m_Age &gt; p2.m_Age;    &#125;&#125;;void test01()&#123;    set&lt;Person, comparePerson&gt; s;    Person p1(&quot;刘备&quot;, 23 );    Person p2(&quot;关羽&quot;, 27 );    Person p3(&quot;张飞&quot;, 25 );    Person p4(&quot;赵云&quot;, 21 );    s.insert(p1);    s.insert(p2);    s.insert(p3);    s.insert(p4);    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>对于自定义数据类型，set必须指定排序规则才可以插入数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/2022/09/15/zSTL/list/"/>
      <url>/2022/09/15/zSTL/list/</url>
      
        <content type="html"><![CDATA[<h1 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h1><h2 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h2><p>功能：将数据进行链式存储<br>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列结点组成<br>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p><strong>list的优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点：</strong></p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</T></li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    list&lt;int&gt;L2(L1.begin(),L1.end());    printList(L2);    list&lt;int&gt;L3(L2);    printList(L3);    list&lt;int&gt;L4( 10 , 1000 );    printList(L4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h2><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    //赋值    list&lt;int&gt;L2;    L2 = L1;    printList(L2);    list&lt;int&gt;L3;    L3.assign(L2.begin(), L2.end());    printList(L3);    list&lt;int&gt;L4;    L4.assign( 10 , 100 );    printList(L4);&#125;//交换void test02()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    list&lt;int&gt;L2;    L2.assign( 10 , 100 );    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);    cout &lt;&lt; endl;    L1.swap(L2);    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    if (L1.empty())    &#123;        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;    &#125;    //重新指定大小    L1.resize( 10 );    printList(L1);    L1.resize( 2 );    printList(L1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h2><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;//插入和删除void test01()&#123;    list&lt;int&gt; L;    //尾插    L.push_back( 10 );    L.push_back( 20 );    L.push_back( 30 );    //头插    L.push_front( 100 );    L.push_front( 200 );    L.push_front( 300 );    printList(L);    //尾删    L.pop_back();    printList(L);    //头删    L.pop_front();    printList(L);    //插入    list&lt;int&gt;::iterator it = L.begin();    L.insert(++it, 1000 );    printList(L);    //删除    it = L.begin();    L.erase(++it);    printList(L);    L.push_back( 10000 );    L.push_back( 10000 );    L.push_back( 10000 );    printList(L);    L.remove( 10000 );    printList(L);    //清空    L.clear();    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h2><ul><li><p>front(); &#x2F;&#x2F;返回第一个元素。</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素。</p></li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;//数据存取void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;    //list容器的迭代器是双向迭代器，不支持随机访问    list&lt;int&gt;::iterator it = L1.begin();    //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：list容器中不可以通过[]或者at方式访问数据</p><ul><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h2 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h2><ul><li><p>reverse(); &#x2F;&#x2F;反转链表</p></li><li><p>sort(); &#x2F;&#x2F;链表排序</p></li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;    return val1 &gt; val2;&#125;//反转和排序void test01()&#123;    list&lt;int&gt; L;    L.push_back( 90 );    L.push_back( 30 );    L.push_back( 20 );    L.push_back( 70 );    printList(L);    //反转容器的元素    L.reverse();    printList(L);    //排序    L.sort(); //默认的排序规则 从小到大    printList(L);    L.sort(myCompare); //指定规则，从大到小    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h3><h4 id="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"><a href="#案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高" class="headerlink" title="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"></a>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</h4><h4 id="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"><a href="#排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序" class="headerlink" title="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"></a>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</h4><h5 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:    Person(string name, int age , int height) &#123;        m_Name = name;        m_Age = age;        m_Height = height;    &#125;public:    string m_Name; //姓名    int m_Age; //年龄    int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    else    &#123;        return p1.m_Age &lt; p2.m_Age;    &#125;&#125;void test01() &#123;    list&lt;Person&gt; L;    Person p1(&quot;刘备&quot;, 35 , 175 );    Person p2(&quot;曹操&quot;, 45 , 180 );    Person p3(&quot;孙权&quot;, 40 , 170 );    Person p4(&quot;赵云&quot;, 25 , 190 );    Person p5(&quot;张飞&quot;, 35 , 160 );    Person p6(&quot;关羽&quot;, 35 , 200 );    L.push_back(p1);    L.push_back(p2);    L.push_back(p3);    L.push_back(p4);    L.push_back(p5);    L.push_back(p6);    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;    L.sort(ComparePerson); //排序    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue</title>
      <link href="/2022/09/15/zSTL/queue/"/>
      <url>/2022/09/15/zSTL/queue/</url>
      
        <content type="html"><![CDATA[<h1 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h1><h2 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h2><p>概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口<br>创建栈容器 栈容器必须符合先进后出<br>队列容器允许从一端新增元素，从另一端移除元素<br>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><ul><li><p>队列中进数据称为 — 入队 push</p></li><li><p>队列中出数据称为 — 出队 pop</p><h2 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h2></li></ul><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>queue<T> que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</T></p></li><li><p>queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;往队尾添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从队头移除第一个元素</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素</p></li><li><p>front(); &#x2F;&#x2F;返回第一个元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;void test01() &#123;    //创建队列    queue&lt;Person&gt; q;    //准备数据    Person p1(&quot;唐僧&quot;, 30 );    Person p2(&quot;孙悟空&quot;, 1000 );    Person p3(&quot;猪八戒&quot;, 900 );    Person p4(&quot;沙僧&quot;, 800 );    q.push(p1);    q.push(p2);    q.push(p3);    q.push(p4);    //队列不提供迭代器，更不支持随机访问    while (!q.empty()) &#123;        //输出队头元素        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name        &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name        &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        cout &lt;&lt; endl;        //弹出队头元素        q.pop();    &#125;    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack</title>
      <link href="/2022/09/15/zSTL/stack/"/>
      <url>/2022/09/15/zSTL/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h2 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h2><p>概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口.栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><ul><li><p>栈中进入数据称为 — 入栈 push</p></li><li><p>栈中弹出数据称为 — 出栈 pop</p></li></ul><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>stack<T> stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</T></p></li><li><p>stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;向栈顶添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从栈顶移除第一个元素</p></li><li><p>top(); &#x2F;&#x2F;返回栈顶元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;stack&gt;void test01()&#123;    stack&lt;int&gt; s;    //向栈中添加元素，叫做 压栈 入栈    s.push( 10 );    s.push( 20 );    s.push( 30 );    while (!s.empty()) &#123;        //输出栈顶元素        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;        //弹出栈顶元素        s.pop();    &#125;    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque</title>
      <link href="/2022/09/15/zSTL/deque/"/>
      <url>/2022/09/15/zSTL/deque/</url>
      
        <content type="html"><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h2><blockquote><p>双端数组，可以对头端进行插入删除操作</p></blockquote><h3 id="deque与vector区别："><a href="#deque与vector区别：" class="headerlink" title="deque与vector区别："></a>deque与vector区别：</h3><p>1.vector对于头部的插入删除效率低，数据量越大，效率越低deque相对而言，对头部的插入删除速度回比vector快</p><p>2.vector访问元素时的速度会比deque快,这和两者内部实现有关</p><h3 id="deque内部工作原理"><a href="#deque内部工作原理" class="headerlink" title="deque内部工作原理:"></a>deque内部工作原理:</h3><p>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间<br>deque容器的迭代器也是支持随机访问的</p><h2 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h2><ul><li>deque<T> deqT; &#x2F;&#x2F;默认构造形式</T></li><li>deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5>  #include <deque><br>  void printDeque(const deque<int>&amp; d)<br>  {<br>  for (deque<int>::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) {<br>  cout &lt;&lt; *it &lt;&lt; “ “;<br>  }<br>  cout &lt;&lt; endl;<br>  }<br>  &#x2F;&#x2F;deque构造<br>  void test01() {<br>  deque<int> d1; &#x2F;&#x2F;无参构造函数<br>  for (int i &#x3D; 0 ; i &lt; 10 ; i++)<br>  {<br>      d1.push_back(i);<br>  }<br>  printDeque(d1);<br>  deque<int> d2(d1.begin(),d1.end());<br>  printDeque(d2);<br>  deque<int>d3(10, 100);<br>  printDeque(d3);<br>  deque<int>d4 &#x3D; d3;<br>  printDeque(d4);<br>  }<br>  int main() {<br>  test01();<br>  system(“pause”);<br>  return 0;<br>  }</int></int></int></int></int></int></deque></li></ul><p>总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><ul><li><p>deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</p></li><li><p>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;        deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt;d2;    d2 = d1;    printDeque(d2);    deque&lt;int&gt;d3;    d3.assign(d1.begin(), d1.end());    printDeque(d3);    deque&lt;int&gt;d4;    d4.assign( 10 , 100 );    printDeque(d4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><ul><li>deque.empty(); &#x2F;&#x2F;判断容器是否为空</li><li>deque.size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    //判断容器是否为空    if (d1.empty()) &#123;        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;        //统计大小        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;    &#125;    //重新指定大小    d1.resize( 15 , 1 );    printDeque(d1);    d1.resize( 5 );    printDeque(d1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><ul><li><p>两端插入操作：</p><ul><li>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据</li><li>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据</li><li>pop_back(); &#x2F;&#x2F;删除容器最后一个数据</li><li>pop_front(); &#x2F;&#x2F;删除容器第一个数据</li><li>指定位置操作：</li></ul></li><li><p>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p><ul><li>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear(); &#x2F;&#x2F;清空容器的所有数据</li><li>erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul></li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;`    &#125;    cout &lt;&lt; endl;&#125;//两端操作void test01()&#123;    deque&lt;int&gt; d;    //尾插    d.push_back( 10 );    d.push_back( 20 );    //头插    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    //尾删    d.pop_back();    //头删    d.pop_front();    printDeque(d);&#125;//插入void test02()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.insert(d.begin(), 1000 );    printDeque(d);    d.insert(d.begin(), 2 , 10000 );    printDeque(d);    deque&lt;int&gt;d2;    d2.push_back( 1 );    d2.push_back( 2 );    d2.push_back( 3 );    d.insert(d.begin(), d2.begin(), d2.end());    printDeque(d);&#125;//删除void test03()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.erase(d.begin());    printDeque(d);    d.erase(d.begin(), d.end());    d.clear();    printDeque(d);&#125;int main() &#123;    test01();    test02();    test03();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//数据存取void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7 deque 排序"></a>3.3.7 deque 排序</h4><h5 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h5><ul><li>sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序</li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    sort(d.begin(), d.end());    printDeque(d);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/2022/09/15/zSTL/vector/"/>
      <url>/2022/09/15/zSTL/vector/</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector与普通数组区别：</strong><br>1.不同之处在于数组是静态空间，而vector可以动态扩展。</p><pre><code>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</code></pre><p>2.vector容器的迭代器是支持随机访问的迭代器</p><h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><ul><li>vector<T> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</T></li><li>vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li><li>vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。</li></ul><p>总结：vector的多种构造方式没有可比性，灵活使用即可</p><h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><ul><li>vector&amp; operator&#x3D;(const vector &amp;vec);&#x2F;&#x2F;重载等号操作</li><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;    vector&lt;int&gt; v1; //无参构造    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    v2 = v1;    printVector(v2);    vector&lt;int&gt;v3;    v3.assign(v1.begin(), v1.end());    printVector(v3);    vector&lt;int&gt;v4;    v4.assign( 10 , 100 );    printVector(v4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p><h2 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h2><ul><li><p>empty(); &#x2F;&#x2F;判断容器是否为空</p></li><li><p>capacity(); &#x2F;&#x2F;容器的容量</p></li><li><p>size(); &#x2F;&#x2F;返回容器中元素的个数</p></li><li><p>resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li><p>resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    if (v1.empty())    &#123;        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;    &#125;    //resize 重新指定大小 ，若指定的更大，默认用 0 填充新位置，可以利用重载版本替换默认填充    v1.resize( 15 , 10 );    printVector(v1);    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除    v1.resize( 5 );    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><ul><li>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</li><li>pop_back(); &#x2F;&#x2F;删除最后一个元素</li><li>insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li>insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li>erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素</li><li>erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li>clear(); &#x2F;&#x2F;删除容器中所有元素</li></ul><p><strong>示例</strong>：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    vector&lt;int&gt; v1;    //尾插    v1.push_back( 10 );    v1.push_back( 20 );    v1.push_back( 30 );    v1.push_back( 40 );    v1.push_back( 50 );    printVector(v1);    //尾删    v1.pop_back();    printVector(v1);    //插入    v1.insert(v1.begin(), 100 );    printVector(v1);    v1.insert(v1.begin(), 2 , 1000 );    printVector(v1);    //删除    v1.erase(v1.begin());    printVector(v1);    //清空    v1.erase(v1.begin(), v1.end());    v1.clear();    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h2><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><ul><li>swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    for (int i = 10 ; i &gt; 0 ; i--)    &#123;        v2.push_back(i);    &#125;    printVector(v2);    //互换容器    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;    v1.swap(v2);    printVector(v1);    printVector(v2);&#125;void test02()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;    v.resize( 3 );    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;//大小变为3    //收缩内存    vector&lt;int&gt;(v).swap(v); //匿名对象下一行自动回收    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><ul><li>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    //预留空间    v.reserve( 100000 );    int num = 0 ;    int* p = NULL;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);        if (p != &amp;v[ 0 ]) &#123;            p = &amp;v[ 0 ];            num++;    &#125;&#125;cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/2022/09/15/zSTL/string/"/>
      <url>/2022/09/15/zSTL/string/</url>
      
        <content type="html"><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>srting的本质是一个类，类内部封装了char* 管理这个字符串，是一个char*类型的容器</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>string()</li><li>string(const char*s)</li><li>string(const string&amp;str)</li><li>string(int n,char c)<ul><li>例如string s1(5,’a’);s1初始化为”aaaaa”</li></ul></li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul><li>string&amp; operator&#x3D;(const char*s)</li><li>string&amp; operator&#x3D;(const string &amp;s)</li><li>string&amp; operator&#x3D;(char c)</li><li>string&amp; assign(const char *s)</li><li>string&amp; assign(const char *s,int n)<ul><li>把字符串s前n个字符赋给当前字符串</li></ul></li><li>string&amp; assign(const string &amp;s)</li><li>string&amp; assign(int n,char c)<h2 id="字符换拼接"><a href="#字符换拼接" class="headerlink" title="字符换拼接"></a>字符换拼接</h2></li><li>string&amp; operator+&#x3D;(const char*str)</li><li>string&amp; operator+&#x3D;(const char c)</li><li>string&amp; operator+&#x3D;(const string &amp;str)</li><li>string&amp; append(const char *s)</li><li>string&amp; append(const char *s,int n)<ul><li>把字符串s前n个字符拼接到当前字符串</li></ul></li><li>string&amp; append(const string &amp;s)</li><li>string&amp; append(const string &amp;s,int pos,int n)<ul><li>字符串s从pos开始的n个字符拼接到当前字符串后面</li></ul></li></ul><h2 id="字符串查找和替换"><a href="#字符串查找和替换" class="headerlink" title="字符串查找和替换"></a>字符串查找和替换</h2><ul><li>int find(const string&amp; str, int pos &#x3D; 0) const;<ul><li>查找str第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos &#x3D; 0) const;<ul><li>查找s第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos, int n) const;<ul><li>从pos位置查找s的前n个字符第一次位置</li></ul></li><li>int find(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c第一次出现位置</li></ul></li><li>int rfind(const string&amp; str, int pos &#x3D; npos) const; <ul><li>查找str最后一次位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos &#x3D; npos) const; <ul><li>查找s最后一次出现位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos, int n) const; <ul><li>从pos查找s的前n个字符最后一次位置</li></ul></li><li>int rfind(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c最后一次出现位置</li></ul></li><li>string&amp; replace(int pos, int n, const string&amp; str);<ul><li>替换从pos开始n个字符替换为字符串str</li></ul></li><li>string&amp; replace(int pos, int n,const char* s);<ul><li>替换从pos开始的n个字符替换为字符串s</li></ul></li></ul><p><strong>查找失败返回-1</strong></p><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>按照ASCLL 码比较</p><ul><li>‘&#x3D;’ 返回0</li><li>‘&gt;’ 返回1</li><li>‘&lt; ‘返回-1</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul><li><p>int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较</p></li><li><p>int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较</p></li></ul><h2 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h2><h3 id="string中单个字符存取方式有两种"><a href="#string中单个字符存取方式有两种" class="headerlink" title="string中单个字符存取方式有两种"></a>string中单个字符存取方式有两种</h3><ul><li>char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符</li><li>char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符</li></ul><p>可以利用size()函数获取string大小进行遍历</p><h3 id="string中字串存取方式"><a href="#string中字串存取方式" class="headerlink" title="string中字串存取方式"></a>string中字串存取方式</h3><ul><li>string substr(int pos &#x3D; 0, int n &#x3D; npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li></ul><p>中文两字节代表一个汉字,所以截取第一个汉字substr(0,2);</p><h2 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h2><ul><li><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c</p></li><li><p>string&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谓词</title>
      <link href="/2022/09/15/cpp/%E8%B0%93%E8%AF%8D/"/>
      <url>/2022/09/15/cpp/%E8%B0%93%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><ul><li>返回bool类型的仿函数称为谓词</li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2></li><li>重载函数调用操作符的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><h2 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h2><ul><li>一个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123;    bool operator()(int val) &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;    else &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h2><ul><li>两个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public:    bool operator()(int num1, int num2)    &#123;        return num1 &gt; num2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 40 );    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 50 );    sort(v.begin(), v.end());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;    //使用函数对象改变算法策略，排序从大到小    sort(v.begin(), v.end(), MyCompare());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/09/15/DesignMode/Singleton/"/>
      <url>/2022/09/15/DesignMode/Singleton/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众多设计模式中，单例模式比较常见的一种，该模式需要满足以下两个条件。</p><ul><li>保证一个类只创建一个实例。</li><li>提供对该实例的全局访问点。</li></ul><p>如果系统有类似的实体（有且只有一个，且需要全局访问），那么就可以将其实现为一个单例。</p><p>实际工作中常见的应用举例</p><ul><li>日志类，一个应用往往只对应一个日志实例。</li><li>配置类，应用的配置集中管理，并提供全局访问。</li><li>管理器，比如windows系统的任务管理器就是一个例子，总是只有一个管理器的实例。</li><li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。</li><li>多线程的线程池，数据库</li></ul><h2 id="Lazy-Singleton"><a href="#Lazy-Singleton" class="headerlink" title="Lazy Singleton"></a>Lazy Singleton</h2><p>头文件中</p><pre><code>class Singleton  &#123;public:    static Singleton&amp; Instance()    &#123;        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;        return *instance_;    &#125;private:    Singleton();    ~Singleton();    Singleton(const Singleton&amp;);    Singleton&amp; operator=(const Singleton&amp;);private:    static Singleton* instance_;&#125;;</code></pre><p>实现文件中</p><pre><code>Singleton* Singleton::instance_ = 0;  </code></pre><p>实现中构造函数被声明为私有方法，这样从根本上杜绝外部使用构造函数生成新的实例，同时禁用拷贝函数与赋值操作符（声明为私有但是不提供实现）避免通过拷贝函数或赋值操作生成新实例。<br>提供静态方法Instance()作为实例全局访问点，该方法中先判断有没有现成的实例，如果有直接返回，如果没有则生成新实例并把实例的指针保存到私有的静态属性中。<br>注意，这里Instance()返回的实例的引用而不是指针，如果返回的是指针可能会有被外部调用者delete掉的隐患，所以这里返回引用会更加保险一些。并且直到Instance()被访问，才会生成实例，这种特性被称为延迟初始化（Lazy initialization），这在一些初始化时消耗较大的情况有很大优势。</p><p>Lazy Singleton不是线程安全的，比如现在有线程A和线程B，都通过instance_ &#x3D;&#x3D; NULL的判断，那么线程A和B都会创建新实例。单例模式保证生成唯一实例的规则被打破了。</p><pre><code>instance_ = new Singleton;</code></pre><p>这条语句实际上做了三件事，</p><ul><li>第一件事申请一块内存</li><li>第二件事调用构造函数</li><li>第三件是将该内存地址赋给instance_</li></ul><p>但是不同的编译器表现是不一样的。可能先将该内存地址赋给instance_，然后再调用构造函数。这时线程A恰好申请完成内存，并且将内存地址赋给instance_，但是还没调用构造函数的时候。线程B执行到判断语句，判断instance_此时不为空，则返回该变量，然后调用该对象的函数，但是该对象还没有进行构造，会发生未定义异常。</p><h2 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h2><p>使用local static对象（函数内的static对象）。当第一次访问Instance()方法时才创建实例。</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            static Singleton instance；            return instance；        &#125;    private:        Singleton()；        ~Singleton()；        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);&#125;;</code></pre><p>这里需要注意的是，C++11以后，要求编译器保证内部静态变量的线程安全性，可以不加锁。但C++ 11以前，仍需要加锁。</p><h2 id="双检测锁模式（Double-Checked-Locking-Pattern）"><a href="#双检测锁模式（Double-Checked-Locking-Pattern）" class="headerlink" title="双检测锁模式（Double-Checked Locking Pattern）"></a>双检测锁模式（Double-Checked Locking Pattern）</h2><p>Lazy Singleton的一种线程安全改造是在Instance()中每次判断是否为NULL前加锁，但是加锁是很慢的。<br>而实际上只有第一次实例创建的时候才需要加锁。双检测锁模式被提出来，改造之后大致是这样</p><pre><code>static Singleton&amp; Instance()  &#123;    if (instance_ == NULL)     &#123;        Lock lock; //基于作用域的加锁，超出作用域，自动调用析构函数解锁        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;    &#125;    return *instance_;&#125;</code></pre><p>既然只需要在第一次初始化的时候加锁，那么在这之前判断一下实例有没有被创建就可以了，所以多在加锁之前多加一层判断，需要判断两次所有叫Double-Checked。理论上问题解决了，但是存在内存读写reorder不安全，编译器优化可能先分配内存，把指针分配给instance_，最后new构造，可能存在线程在分配指针后没有构造的时候就返回*instance_。</p><p>在C++11中有全新的内存模型和原子库，可以很方便的用来实现DCLP。</p><h2 id="c-11-以后版本实现"><a href="#c-11-以后版本实现" class="headerlink" title="c++11 以后版本实现"></a>c++11 以后版本实现</h2><p><img src="/2022/09/15/DesignMode/Singleton/c++11%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png"></p><h2 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h2><p>在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，pthread_once是很适合用来实现线程安全单例。</p><pre><code>template&lt;typename T&gt;  class Singleton : boost::noncopyable  &#123;    public:        static T&amp; instance()        &#123;            pthread_once(&amp;ponce_, &amp;Singleton::init);            return *value_;        &#125;        static void init()        &#123;            value_ = new T();        &#125;    private:        static pthread_once_t ponce_;    static T* value_;&#125;;template&lt;typename T&gt;  pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template&lt;typename T&gt;  T* Singleton&lt;T&gt;::value_ = NULL;  </code></pre><p>这里的boost::noncopyable的作用是把构造函数, 赋值函数, 析构函数, 复制构造函数声明为私有或者保护。</p><h2 id="Eager-Singleton"><a href="#Eager-Singleton" class="headerlink" title="Eager Singleton"></a>Eager Singleton</h2><p>这种实现在程序开始(静态属性instance初始化)的时就完成了实例的创建。这正好和上述的Lazy Singleton相反。</p><p>头文件中</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            return instance;        &#125;    private:        Singleton();        ~Singleton();        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);    private:        static Singleton instance;&#125;</code></pre><p>实现文件中</p><pre><code>Singleton Singleton::instance;  </code></pre><p>由于在main函数之前初始化，所以没有线程安全的问题，但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 Instance()方法会返回一个未定义的实例。</p><h2 id="内存释放问题"><a href="#内存释放问题" class="headerlink" title="内存释放问题"></a>内存释放问题</h2><h3 id="单独的函数"><a href="#单独的函数" class="headerlink" title="单独的函数"></a>单独的函数</h3><p>不能在析构函数中使用delete instance__，这会导致一直析构和delete操作循环嵌套下去，应该单独生成一个释放内存的函数</p><pre><code>static void delInstance()&#123; // 为了多线程安全，释放操作也要做 double-check    if(m_pInstance != nullptr)     &#123;        std::lock_guard&lt;std::mutex&gt; lck(m_mutex);        if(m_pInstance != nullptr)         &#123;            delete m_pInstance;            m_pInstance = nullptr;        &#125;    &#125;        &#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>我们知道，进程结束时，静态对象的生命周期随之结束，其析构函数会被调用来释放对象。因此，我们可以利用这一特性，在单例类中声明一个内嵌类，该类的析构函数专门用来释放new出来的单例对象，并声明一个该类类型的static对象。<br><img src="/2022/09/15/DesignMode/Singleton/%E6%87%92%E6%B1%89%E5%BC%8F%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98.png"></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>用智能指针来释放new出的内存是一种很省心的，内存释放方式，如OSG中的osg::ref_ptr<class t>(本人接触的第一种智能指针)，UE4中的TSharePtr<class t>。当然，这种方式同样也使用于对单例指针的释放.。不过使用智能指针往往会导致的一个问题就是我们无法去主动控制内存的释放，也不知道它什么时候就被释放掉了。偶尔指针越界也挺让人郁闷的，不过对于初学者来说确实是一种不错的选择。</class></class></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多其他大佬讲解的内容目前还不太明白，只能暂时摘录不懂的地方嵌入blog，未来会对本篇文章进行补充和完善。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>factory模式</title>
      <link href="/2022/09/15/DesignMode/Factory/"/>
      <url>/2022/09/15/DesignMode/Factory/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为简单工厂模式，工厂方法模式和抽象工厂模式。</p><ul><li>简单工厂       Simple Factory</li><li>工厂方法       Factory Method</li><li>抽象工厂       Abstract Factory</li></ul><p><img src="/2022/09/15/DesignMode/Factory/EasyFactoryUML.png"></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>示例：</p><p>步骤 1<br>创建一个接口。</p><pre><code>class Shape&#123;public:    virtual ~Shape()&#123;&#125;    virtual void draw() = 0;&#125;;</code></pre><p>步骤 2<br>创建实现接口的实体类</p><pre><code>class Circle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a circle&quot; &lt;&lt; std::endl;    &#125;&#125;;class Square:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a square&quot; &lt;&lt; std::endl;    &#125;&#125;;class Rectangle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a rectangle&quot; &lt;&lt; std::endl;    &#125;&#125;;</code></pre><p> 步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><pre><code>class ShapeFactory&#123;public:    std::shared_ptr&lt;Shape&gt; getShape(const std::string &amp; shapType)&#123;        if(shapType == &quot;Square&quot;)&#123;            return std::make_shared&lt;Square&gt;();        &#125;        else if(shapType == &quot;Circle&quot;)&#123;            return std::make_shared&lt;Circle&gt;();        &#125;         else if(shapType == &quot;Rectangle&quot;)&#123;            return std::make_shared&lt;Rectangle&gt;();        &#125;        return nullptr;    &#125;&#125;;</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><pre><code>ShapeFactory factory;auto shape1 = factory.getShape(&quot;Circle&quot;);shape1-&gt;draw();auto shape2 = factory.getShape(&quot;Square&quot;);shape2-&gt;draw();auto shape3 = factory.getShape(&quot;Rectangle&quot;);shape3-&gt;draw();</code></pre><p>步骤 5<br>验证输出。</p><pre><code>draw a circledraw a squaredraw a rectangle</code></pre><p>特点：用户不需要具体关心实例是怎么创建的，只需要输入标识符就可以得到实例，但这种设计不符合开-闭原则，对修改和扩展都是开放的，增加对象类型和删除对象类型都需要重写这个接口。<br>就是把所有对象的创建都封装在了一个ShapeFactory类的getShape函数中，根据传入的参数，选择产生不同的对象，很明显，getShape这个函数做不到“开-闭”原则，即对原有代码修改关闭，对功能扩展开放，这个函数随着新对象的添加，或者原有对象的删除，都会导致该函数的代码修改，而且有可能影响原来的功能，所以这样的设计不能算完美。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Factory Method工厂方法是标准的OOP设计模式之一，主要解决了上面使用简单工厂遇到的问题。工厂方法为每一种产品提供相应的实例工厂进行对象创建，更符合实际的面向对象设计，比如说不同图形，肯定都有自己的绘图工具，每个图形都有自己的工厂在生产。</p><p>产品类型</p><pre><code>class Product&#123;public:    Product(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductA : public Product&#123;public:    ProductA(string name) :Product(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用老外高通芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductB : public Product&#123;public:    ProductB(string name) :Product(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用自研麒麟芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>工厂基类</p><pre><code>class Factory&#123;public:    virtual Product* createProduct() = 0;&#125;;</code></pre><p>生产小米手机的工厂</p><pre><code>class XiaomiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 小米工厂肯定生产小米手机        return new ProductA(&quot;小米手机&quot;);    &#125;&#125;;</code></pre><p>生产华为手机的工厂</p><pre><code>class HuaweiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 华为工厂肯定生产华为手机        return new ProductB(&quot;华为手机&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;Factory&gt; f1(new XiaomiFactory);    unique_ptr&lt;Factory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建产品    unique_ptr&lt;Product&gt; p1(f1-&gt;createProduct());    unique_ptr&lt;Product&gt; p2(f2-&gt;createProduct());    p1-&gt;show();    p2-&gt;show();    return 0;&#125;</code></pre><p>特点：仔细理解上面的工厂方法模式，会发现一个问题，就是每一个实例工厂负责生产一个实例产品，也就是一个产品对应一个工厂，一个工厂对应一个产品，那么小米不仅仅生产手机，还生产耳机，智能手环，智能插座等等相关的小米产品簇，不可能给这每一个产品都创建一个工厂类，那样的话代码中的类就太多了，不好维护，而且也不符合实际情况。<br>所以对于包含产品簇这么一类实体关系的设计，就需要使用Abstract Factory抽象工厂了，你也可以把上面的工厂方法看作只生产一种产品的抽象工厂，本质是相同的。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>经过上面内容的描述，抽象工厂其实就是解决产品簇的产品类设计的。</p><p>产品簇手机类型</p><pre><code>class ProductA&#123;public:    ProductA(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiPhone : public ProductA&#123;public:    XiaomiPhone(string name) :ProductA(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米手机:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiPhone : public ProductA&#123;public:    HuaweiPhone(string name) :ProductA(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个华为手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品簇智能手环类型</p><pre><code>class ProductB&#123;public:    ProductB(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiCircle : public ProductB&#123;public:    XiaomiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiCircle : public ProductB&#123;public:    HuaweiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;        cout &lt;&lt; &quot;获取了一个华为智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>抽象工厂，创建通过一个产品簇的设备产品</p><pre><code>class AbstractFactory&#123;public:    // 工厂里面创建手机的纯虚函数接口    virtual ProductA* createPhone() = 0;    // 工厂里面创建智能手环的纯虚函数接口    virtual ProductB* createSmartCircle() = 0;&#125;;</code></pre><p>生产小米产品簇的工厂</p><pre><code>class XiaomiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 小米工厂肯定生产小米手机        return new XiaomiPhone(&quot;小米x9&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 小米工厂肯定生产小米智能手环        return new XiaomiCircle(&quot;小米智能手环2代时尚版&quot;);    &#125;&#125;;</code></pre><p>生产华为产品簇的工厂</p><pre><code>class HuaweiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 华为工厂肯定生产华为手机        return new HuaweiPhone(&quot;华为荣耀7x&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 华为工厂肯定生产华为智能手环        return new HuaweiCircle(&quot;华为智能手环B3青春版&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;AbstractFactory&gt; f1(new XiaomiFactory);    unique_ptr&lt;AbstractFactory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建手机产品    unique_ptr&lt;ProductA&gt; p1(f1-&gt;createPhone());    unique_ptr&lt;ProductA&gt; p2(f2-&gt;createPhone());    p1-&gt;show();    p2-&gt;show();    // 通过工厂方法创建智能手环产品    unique_ptr&lt;ProductB&gt; p3(f1-&gt;createSmartCircle());    unique_ptr&lt;ProductB&gt; p4(f2-&gt;createSmartCircle());    p3-&gt;show();    p4-&gt;show();    return 0;&#125;</code></pre><p>可以看到，抽象工厂模式把一个产品簇的产品放在一个工厂类中去创建，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。<br>其实仔细想想，抽象工厂也存在一些问题，比如有的工厂生产某一种产品，但有的工厂它不生产该种产品（可能生产其它的产品），但由于都是从一个抽象工厂继承下来的，所以就会多继承一些无用的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/13/Linux/vim/"/>
      <url>/2022/09/13/Linux/vim/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/13/wZ8oCa7er4Qtqcp.png" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>括号生成</title>
      <link href="/2022/09/13/%E9%A2%98%E8%A7%A3/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2022/09/13/%E9%A2%98%E8%A7%A3/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1：</p><pre><code>输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p>示例 2：</p><pre><code>输入：n = 1输出：[&quot;()&quot;]</code></pre><p> </p><p>提示：</p><pre><code>1 &lt;= n &lt;= 8</code></pre><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p><strong>本弱鸡的解题思路</strong><br>暴力枚举加剪枝，如果右括号数量比左括号数量多，则进行剪枝，否则依次枚举添加左括号和添加右括号，如果左右括号数量相等，则只能添加左括号。当左括号数目为n，停止添加左括号，只添加右括号。当左右括号数量都为n，将其填入结果vector当中。</p><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt;ans;    vector&lt;string&gt; generateParenthesis(int n) &#123;        dfs(&quot;&quot;,n,n);        return ans;    &#125;    void dfs(string temp,int left,int right)&#123;        if(left==0&amp;&amp;right==0)&#123;            ans.push_back(temp);        &#125;        else&#123;            if(left!=0)&#123;                dfs(temp+&#39;(&#39;,left-1,right);            &#125;            if(left&lt;right)&#123;                dfs(temp+&#39;)&#39;,left,right-1);            &#125;        &#125;    &#125;&#125;;</code></pre><p>不论是时间还是空间花费都比较多<br><strong>执行用时：4 ms, 在所有 C++ 提交中击败了65.31%的用户<br>内存消耗：13.5 MB, 在所有 C++ 提交中击败了35.99%的用户</strong></p><h3 id="dfs（大佬做法）"><a href="#dfs（大佬做法）" class="headerlink" title="dfs（大佬做法）"></a>dfs（大佬做法）</h3><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; res;        func(res, &quot;&quot;, 0, 0, n);        return res;    &#125;        void func(vector&lt;string&gt; &amp;res, string str, int l, int r, int n)&#123;        if(l &gt; n || r &gt; n || r &gt; l) return ;        if(l == n &amp;&amp; r == n) &#123;res.push_back(str); return;&#125;        func(res, str + &#39;(&#39;, l+1, r, n);        func(res, str + &#39;)&#39;, l, r+1, n);        return;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：14.6 MB, 在所有 C++ 提交中击败了22.09%的用户</strong></p><p>不清楚为什么时间效率会差这么多，感觉都要遍历同样多的节点数。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>解题思路</strong><br>可以把一个（）看作最小单位元进行处理，每次在最后一个（后面开始加入（），一直加到末尾，例如：<br>【（）】<br>【（（））】 【（）（）】<br>【（（（））） 】【（（）（））】 【（（））（）】 【（）（）（）】 【（）（（））】<br><strong>……</strong></p><p>10<br>1100 1010<br>111000 110100 110010 101100 101010<br>……</p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if(n == 1) return &#123;&quot;()&quot;&#125;;        vector&lt;string&gt; tmp = generateParenthesis(n - 1);        vector&lt;string&gt; res;        for(int i = 0; i &lt; tmp.size(); i ++)&#123;            int last = tmp[i].size() - 1;            while(tmp[i][last - 1] != &#39;(&#39;) last --;            for(int j = last; j &lt;= tmp[i].size(); j++)&#123;                res.push_back(&quot;&quot; + tmp[i]);                res.back().insert(j, &quot;()&quot;);            &#125;        &#125;                return res;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：7 MB, 在所有 C++ 提交中击败了98.07%的用户</strong></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>作者<a href="https://leetcode.cn/u/yuyu-13/">：yuyu-13</a><br>题解链接：<a href="https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a><br><strong>解题思路</strong></p><p>当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i&#x3D;n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。</p><p>那么，剩下 n-1 组括号有可能在哪呢？</p><p><strong>【这里是重点，请着重理解】</strong></p><p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p><p>既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：</p><p>“(“ + 【i&#x3D;p时所有括号的排列组合】 + “)” + 【i&#x3D;q时所有括号的排列组合】</p><p>其中 p + q &#x3D; n-1，且 p q 均为非负整数。</p><p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p><p><em>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</em></p><p><strong>代码：</strong><br><strong>具体代码如下：</strong>（<strong>时间击败百分之 95，内存击败百分之 99.65）</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if (n == 0) return &#123;&#125;;        if (n == 1) return &#123; &quot;()&quot; &#125;;        vector&lt;vector&lt;string&gt;&gt; dp(n+1);        dp[0] = &#123; &quot;&quot; &#125;;        dp[1] = &#123; &quot;()&quot; &#125;;        for (int i = 2; i &lt;= n; i++) &#123;            for (int j = 0; j &lt;i; j++) &#123;                for (string p : dp[j])                    for (string q : dp[i - j - 1]) &#123;                        string str = &quot;(&quot; + p + &quot;)&quot; + q;                        dp[i].push_back(str);                    &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/generate-parentheses">https://leetcode.cn/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻宝大作战</title>
      <link href="/2022/09/11/%E9%A2%98%E8%A7%A3/csp/2022_06_2/"/>
      <url>/2022/09/11/%E9%A2%98%E8%A7%A3/csp/2022_06_2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p><p>某天，小 P 获得了一张神秘的藏宝图。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br>简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br>地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br>其中 A[i][j]&#x3D;1 表示坐标 (i,j) 处种有一棵树，A[i][j]&#x3D;0 则表示坐标 (i,j) 处没有树。<br>换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p><p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br>并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br>具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br>理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br>对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]&#x3D;B[i][j]。<br>当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p><p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br>请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p><p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]&#x3D;B[0][0]&#x3D;1，表示了宝藏埋藏的位置。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p><p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p><p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p><p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br>需要注意，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p><p><strong>样例 1 输入</strong></p><pre><code>5 100 20 01 12 23 34 40 0 10 1 01 0 0</code></pre><p><strong>样例 1 输出</strong></p><pre><code>3</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>对stl掌握的不好，只能用数组碰运气来做。浪费很多时间，最后只拿了200分，第三题本来可以骗几个用例分数的，，，，，我采用的是记录稀疏矩阵，然后根据横坐标纵坐标排序，最后采用O(n)枚举的暴力做法。代码又臭又长，如下所示（不看也罢）：</p><p> <strong>代码实现</strong></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */struct Zb&#123;    int x;    int y;&#125;zb[1050],cbt[60];int ss[60][60];int cmp(struct Zb a,struct Zb b)&#123;    if(a.x==b.x)&#123;        return a.y&lt;b.y;    &#125;    else return a.x&lt;b.x;    &#125;int main(int argc, char** argv) &#123;    int n,L,s ;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;L,&amp;s);    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;zb[i].x,&amp;zb[i].y);        &#125;        sort(zb,zb+n,cmp);        int t,count=0;        for(int i=s;i&gt;=0;i--)&#123;            for(int j=0;j&lt;=s;j++)&#123;                scanf(&quot;%d&quot;,&amp;ss[i][j]);                if(ss[i][j]==1)&#123;                    cbt[count].y=j;                    cbt[count].x=i;                    count++;                &#125;            &#125;        &#125;        sort(cbt,cbt+count,cmp);        int vcount =0;        for(int i=0;i&lt;n;i++)&#123;            int flag=0;            int k=i+1;            int countzb=0;            if(zb[i].x&gt;L-s||zb[i].y&gt;L-s)flag=1;            while(zb[k].x-zb[i].x&lt;=s&amp;&amp;k&lt;n)&#123;                if(abs(zb[k].x-zb[i].x)&lt;=s&amp;&amp;zb[k].y-zb[i].y&lt;=s&amp;&amp;zb[k].y-zb[i].y&gt;=0)&#123;                    if(ss[abs(zb[k].x-zb[i].x)][abs(zb[k].y-zb[i].y)]!=1)&#123;                        flag=1;                        break;                    &#125;                     countzb++;                &#125;                k++;            &#125;            if(countzb+1!=count)flag=1;            if(flag==0)&#123;                    vcount++;            &#125;        &#125;        printf(&quot;%d&quot;,vcount);     return 0;&#125;</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p>对于较大数据10^9，如果用二维数组vector的话无法开辟那么大空间，换成二维map来存储可以解决较大数据问题。解决好两个图的存储问题之后，接下来就是找到符合要求的可能埋有宝藏地点个数，无非就是两个条件：一是满足藏宝图可以在绿化图某块区域完美对上，二是满足藏宝图在绿化图中不出界。可以利用这两个条件去判断每一个符合条件的绿树点。如果两个条件都满足即有可能此处为藏宝点。<br><strong>代码实现</strong></p><pre><code>#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;cmath&gt;using namespace std;//pair&lt;int ,int&gt;和int对应map&lt;int,map&lt;int,int&gt; &gt;mp;struct node&#123;    int x,y;&#125;point[1001];int g[51][51];//地图int main()&#123;    int n,L,S;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;point[i].x&gt;&gt;point[i].y;        mp[point[i].x][point[i].y]=1;    &#125;    //输入也是一个坑    for(int i=S;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=S;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        int flag=1;        int x=point[i].x,y=point[i].y;        for(int j=0;j&lt;=S;j++)&#123;            for(int k=0;k&lt;=S;k++)&#123;                if(x+S&gt;L||y+S&gt;L||mp[x+j][y+k]!=g[j][k])&#123;                    flag=0;                    break;                &#125;            &#125;            if(!flag) break;        &#125;        if(flag) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;</code></pre><p><a href="https://blog.csdn.net/victory066/article/details/125819918">作者原文</a><br><a href="https://blog.csdn.net/victory066/article/details/125819918">https://blog.csdn.net/victory066/article/details/125819918</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h1><ul><li><p>Pre-Order Traversal ： 到达一个节点后，即刻输出该节点的值，并继续遍历其左右子树。                                VLR</p></li><li><p>In-Order Traversal  ：   到达一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。LVR</p></li><li><p>Post-Order Traversal:   到达一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。                          LRV</p></li></ul><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p><strong>递归实现</strong></p><pre><code>void preOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void preOrderTraverse2(node *root) &#123;    LinkedList&lt;node*&gt; stack = new LinkedList&lt;&gt;();    node *pNode = root;    while (pNode != null || !stack.isEmpty()) &#123;        if (pNode != null) &#123;            System.out.print(pNode.val+&quot;  &quot;);            stack.push(pNode);            pNode = pNode.left;        &#125;         else &#123; //pNode == null &amp;&amp; !stack.isEmpty()            nodeNode node = stack.pop();            pNode = node.right;        &#125;    &#125;&#125;</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if (root == NULL)        return;    node *p = root;    stack&lt;node*&gt;s;    while (p != NULL || !s.empty())    &#123;        while (p!=NULL)        &#123;            s.push(p);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;            p = s.top();            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        //第二次遇见的时候输出            s.pop();            p = p-&gt;rchild;        &#125;    &#125;&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>递归实现</strong></p><pre><code>void postOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);    printf(&quot;%d\n&quot;,root-&gt;data);&#125;</code></pre><p><strong>非递归实现</strong><br>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问。其右孩子还未被访问,所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是 否是第一次出现在栈顶。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == NULL)        return;    stack&lt;node*&gt;s;    Binode p = root;    node tmp;    while (p!=NULL || !s.empty())    &#123;        while (p != NULL)            //沿左子树一直往下搜索，直至出现没有左子树的结点        &#123;            node btn = (node)malloc(sizeof(Node));            btn-&gt;btnode = p;            btn-&gt;isfirst = true;            s.push(btn);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;            tmp = s.top();            s.pop();            if (tmp-&gt;isfirst == true)    //第一次出现在栈顶            &#123;                tmp-&gt;isfirst = false;                s.push(tmp);                p = tmp-&gt;btnode-&gt;rchild;            &#125;            else                //第二次出现在栈顶            &#123;                cout &lt;&lt; tmp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;;                p = NULL;            &#125;        &#125;    &#125;&#125;</code></pre><p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == NULL)        return;    stack&lt;node*&gt;s;    node* cur = root, *pre = NULL;    s.push(root);    while (!s.empty())    &#123;        cur = s.top();        if ((cur-&gt;lchild == NULL&amp;&amp;cur-&gt;rchild == NULL) ||            ((pre == cur-&gt;lchild || pre == cur-&gt;rchild) &amp;&amp; pre != NULL))        &#123;            cout &lt;&lt; cur-&gt;data &lt;&lt; &quot; &quot;;            s.pop();            pre = cur;        &#125;        else        &#123;            if (cur-&gt;rchild != NULL)                s.push(cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                s.push(cur-&gt;lchild);        &#125;    &#125;&#125;</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><strong>非递归遍历</strong></p><pre><code>void layerOrderTraverse(node* root)&#123;    queue&lt;node*&gt; q;    q.push(root);    while(!q.empty())&#123;        node*now=q.front();        q.pop();        cout&lt;&lt; now-&gt;data&lt;&lt;endl;        if(now-&gt;lchild!=nullptr)q.push(now-&gt;lchild);        if(now-&gt;rchild!=nullptr)q.push(now-&gt;rchild);    &#125;&#125;</code></pre><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><pre><code>void DFS(node* root)&#123;    Stack&lt;node*&gt; nodeStack;    nodeStack.push(root);    while(!nodeStack.empty())    &#123;        root=nodeStack.top();        printf(format, root-&gt;data);        nodeStack.pop();        if(root-&gt;rChild)        &#123;            nodeStack.push(root-&gt;rChild);        &#125;        if(root-&gt;lChild)        &#123;            nodeStack.push(root-&gt;lChild);        &#125;            &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金山训练营第一周</title>
      <link href="/2022/09/09/cpp/WPSlesson1/"/>
      <url>/2022/09/09/cpp/WPSlesson1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于C-编程的四大分类（结合Effective-C-的理解）"><a href="#关于C-编程的四大分类（结合Effective-C-的理解）" class="headerlink" title="关于C++编程的四大分类（结合Effective C++的理解）"></a>关于C++编程的四大分类（结合Effective C++的理解）</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>​    C++仍然是以C为基础。区块，语句，预处理器，内置数据类型，数组及其指针都来源于C，在大多数的时候，对C++语言的运用往往不过是较为高级的C语言解法</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>​    面向对象是C++语言最重要的特性之一，C++语言相对于C最重要的就是从面向过程的转换为面向对象的编程思维。C with Classes所诉求的部分：classes，封装，继承，多态，虚函数(virtual函数-动态绑定)</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>​    泛型编程。模板是在C++中与面向对象并列的另一大分支——泛型编程。所谓泛型编程，就是不依赖某一具体类型而使代码仍然具有很强适应性的编程范式。而我们所常用的STL则是泛型编程下的一大优秀案例</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>​    STL是一个template程序库，它对容器，迭代器，算法及其函数对象的规约有着极佳的紧密配合与协调</p><h2 id="C-相关基本信息"><a href="#C-相关基本信息" class="headerlink" title="C++相关基本信息"></a>C++相关基本信息</h2><h3 id="1-C-历史讲解"><a href="#1-C-历史讲解" class="headerlink" title="1.C++历史讲解"></a>1.C++历史讲解</h3><h4 id="前言：为什么要学C"><a href="#前言：为什么要学C" class="headerlink" title="前言：为什么要学C++"></a>前言：为什么要学C++</h4><ol><li>C++目前仍然是主要的流行语言之一</li><li>C++贴近OS&#x2F;硬件层，性能上限高</li><li>底层核心模块（OS，编译器，运行环境，大型软件等）通常由C++编写</li><li>应用场景十分广泛，图形引擎，音视频处理，仿真系统，高频交易</li><li>技术上线高（上至其他语言，下至逆向汇编）</li><li>WPS技术大佬基本都是C++出身，转型极快</li></ol><p><a href="https://imgse.com/i/vxifwq"><img src="https://s1.ax1x.com/2022/09/14/vxifwq.png" alt="vxifwq.png"></a></p><p><a href="https://imgse.com/i/vxi5kV"><img src="https://s1.ax1x.com/2022/09/14/vxi5kV.png" alt="vxi5kV.png"></a></p><p><a href="https://imgse.com/i/vxiIYT"><img src="https://s1.ax1x.com/2022/09/14/vxiIYT.png" alt="vxiIYT.png"></a></p><h3 id="2-VS中编译C-的方法"><a href="#2-VS中编译C-的方法" class="headerlink" title="2.VS中编译C++的方法"></a>2.VS中编译C++的方法</h3><p>编译流程：</p><p><a href="https://imgse.com/i/vxirY8"><img src="https://s1.ax1x.com/2022/09/14/vxirY8.png" alt="vxirY8.png"></a></p><h3 id="3-C与C-的区别"><a href="#3-C与C-的区别" class="headerlink" title="3.C与C++的区别"></a>3.C与C++的区别</h3><p>​    C语言作为程序化开发的语言，适合处理较小规模的程序。对于大规模程序，C语言并不合适</p><p>C语言的三个缺陷：</p><ol><li>不太严谨</li><li>名字冲突</li><li>作用域</li></ol><p>而现代C++语言可以看做是三部分组成的：</p><ul><li>低级语言，大部分继承自C语言</li><li>现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统</li><li>标准库（STL），它利用高级特性来提供有用的数据结构和算法</li></ul><p>思想对比</p><ul><li>面向过程——C语言</li><li>面向对象——C++</li><li>函数式编程——Javascript</li></ul><h2 id="C-的基本架构"><a href="#C-的基本架构" class="headerlink" title="C++的基本架构"></a>C++的基本架构</h2><h3 id="1-C-的默认架构"><a href="#1-C-的默认架构" class="headerlink" title="1.C++的默认架构"></a>1.C++的默认架构</h3><p>C++的默认架构一般为：头文件，域名空间，主函数</p><p><a href="https://imgse.com/i/vxiWmn"><img src="https://s1.ax1x.com/2022/09/14/vxiWmn.png" alt="vxiWmn.png"></a></p><h3 id="2-C-的头文件"><a href="#2-C-的头文件" class="headerlink" title="2.C++的头文件"></a>2.C++的头文件</h3><p>在之前所学的C语言中的表头文件为stdio.h，C++也是类似的，老版的C++库中也是类似，调用了iostream.h</p><p>但是，目前在新版的C++库中为了方便书写，已经把.h这样的风格给去掉了</p><p>需要我们注意的是，<strong>每个使用标准库设施的程序都必须包含相关的头文件</strong>，#include指令和头文件名字必须写在同一行中</p><p>通常情况下，#include指令必须出现在所有函数之外，我们<strong>一般将一个程序的所有#include指令都放在源文件的开始位置</strong></p><p>C++语言兼容C语言，标准C++程序库中是不带.h的，若是我们打算使用C语言的函数，可以在C语言的标准库头文件，推荐写法是去掉C语言头文件中的.h文件，在前面加上c，例如</p><pre><code class="C++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;</code></pre><h3 id="3-C-中的域名空间"><a href="#3-C-中的域名空间" class="headerlink" title="3.C++中的域名空间"></a>3.C++中的域名空间</h3><p>在实际大型的项目开发中，由于很多的功能模块，是由不同的人来编写的。因此，可能会出现A编写的函数名和B编写的函数名一样的情况。这样一来，我们的程序就会发生错误，只要我们每个人都定义自己的命名空间，就可以解决这一问题，即使函数重名，只要属于不同的命名空间就不会出现问题</p><p>注：当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。<strong>多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）</strong></p><p><strong>命名空间（namespace）为了防止名字冲突提供了更加可控的机制</strong>。命名空间分割了全局命名空间，其中的每一个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（及其用户）可以避免全局名字固有的限制</p><h4 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h4><p>一个命名空间的定义包含两部分：首先是关键字namespace ，随后是命名空间的名字，在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类，变量（及其初始化操作），函数（及其定义），模板和其他命名空间</p><pre><code class="C++">// 域名控件编码规范：全部小写namespace demospace &#123;    int x=100;        void output() &#123;        cout&lt;&lt;&quot;This is a namespace example!&quot;&lt;&lt;endl;    &#125;&#125;</code></pre><p>和其他名字一样，<strong>命名空间中的名字也必须在定义它的作用域内保持唯一</strong>。命名空间即可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部</p><p><strong>注：命名空间作用域后面无须分号</strong></p><p><strong>注意事项：</strong></p><ul><li>每个命名空间都是一个作用域</li><li>命名空间可以是不连续的<ul><li>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间，此时，命名空间的组织方式类似于我们管理自定义类和函数的方式</li></ul></li></ul><p>需要我们注意的一点是，在通常情况下，我们不把#include放在命名空间内部，如果我们一旦这么做了，隐含的意思就是把头文件中所有的名字定义成该命名空间的成员</p><p>命名空间中定义的成员可以直接使用名字，而无须前缀；命名空间之外定义的成员必须使用含有前缀的名字</p><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>全局命名空间中定义的名字（即在所有类，函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间中</strong>（global namespace）。全局命名空间以隐式的方式声明，并且在所有程序中都存在</p><p>作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字，如下形式：</p><pre><code>::member_name</code></pre><p>表示全局命名空间中的一个成员</p><h5 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h5><p>嵌套命名空间是指定义在其他命名空间中的命名空间</p><h5 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h5><p>未命名的命名空间（unnamed namespace）所指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁</p><p>注：和其他的命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件</p><p>目前为止，我们所用到的库函数基本上都属于命名空间std，而程序也显式地将这一点表示出来了</p><h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><p>如果我们使用了<strong>using声明</strong>，就可以更为简单地使用命名空间中的成员，即无须使用专门的前缀（形如命名空间::）也能使用所需的名字了</p><p>using声明具有如下的形式：</p><pre><code>using namespace::name;</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><pre><code class="C++">#include&lt;iostream&gt;// using声明，当我们使用名字cin时，从命名空间std中获取它using std::cin;int main()&#123;    int i;    cin&gt;&gt;i;    std::cout&lt;&lt;i;    return 0;&#125;</code></pre><p>根据规定，每个using声明引入命名空间中的一个成员</p><h4 id="命名空间的using指示"><a href="#命名空间的using指示" class="headerlink" title="命名空间的using指示"></a>命名空间的using指示</h4><p><strong>using指示</strong>和using声明类似的地方是，我们可以使用命名空间名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的</p><p>using指示以关键字using开始，后面是关键字namespace以及命名空间的名字，例如：</p><pre><code>using namespace std;</code></pre><p>using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用</p><h4 id="using指示与作用域（总结）"><a href="#using指示与作用域（总结）" class="headerlink" title="using指示与作用域（总结）"></a>using指示与作用域（总结）</h4><p>using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。</p><p>对于using声明来说，我们只是简单地令名字在局部作用域内有效</p><p>对于using指示来说，using指示是令整个命名空间的所有内容都变得有效</p><h3 id="4-C-中的输出函数"><a href="#4-C-中的输出函数" class="headerlink" title="4.C++中的输出函数"></a>4.C++中的输出函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p><a href="https://imgse.com/i/vxib6J"><img src="https://s1.ax1x.com/2022/09/14/vxib6J.png" alt="vxib6J.png"></a></p><p>C和C++语言中没有专门的输入输出语句。C语言中输入和输出由函数来使用，而C++中的输入和输出是通过流的方式来实现的</p><ul><li>标准输入（standard input）：cin</li><li>标准输出（standard output）：cout</li><li>标准出错（standard err）：cerr</li><li>流输出运算符：&lt;&lt;</li><li>流输入运算符：&gt;&gt;</li></ul><h4 id="C-中常用格式控制符"><a href="#C-中常用格式控制符" class="headerlink" title="C++中常用格式控制符"></a>C++中常用格式控制符</h4><ul><li>noshowbase——不生成表示进制的前缀</li><li>showbase ——对整型输出表示进制的前缀</li><li>dec——整型值显示为十进制</li><li>hex——整型值显示为十六进制</li><li>oct——整型值显示为八进制</li><li>fixed——浮点数显示为定点十进制</li><li>scientific——浮点值显示为科学计数法</li><li>setprecision(整数)——设置输出有效数字的个数，不包含小数点</li><li>ends——插入空字符，然后刷新ostream缓冲区</li><li>endl——插入换行，然后刷新ostream缓冲区</li></ul><h2 id="C-中的指针"><a href="#C-中的指针" class="headerlink" title="C++中的指针"></a>C++中的指针</h2><h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><h4 id="1-地址的概念"><a href="#1-地址的概念" class="headerlink" title="1.地址的概念"></a>1.地址的概念</h4><p>​    操作系统以32bit&#x2F;64bit的地址总线为基准，对内存单元以字节为单位进行编号，这个编号我们叫做内存地址</p><p><a href="https://imgse.com/i/vxigyj"><img src="https://s1.ax1x.com/2022/09/14/vxigyj.png" alt="vxigyj.png"></a></p><h4 id="2-基本内存操作"><a href="#2-基本内存操作" class="headerlink" title="2.基本内存操作"></a>2.基本内存操作</h4><ul><li>把数据写到内存中去</li><li>把内存中的数据读取出来</li></ul><h4 id="3-C-中分配内存的方法"><a href="#3-C-中分配内存的方法" class="headerlink" title="3.C++中分配内存的方法"></a>3.C++中分配内存的方法</h4><p>（1）定义变量</p><p>（2）通过malloc函数，动态分配内存</p><p><a href="https://imgse.com/i/vxihT0"><img src="https://s1.ax1x.com/2022/09/14/vxihT0.png" alt="vxihT0.png"></a></p><h4 id="4-C-中对内存读写的方法"><a href="#4-C-中对内存读写的方法" class="headerlink" title="4.C++中对内存读写的方法"></a>4.C++中对内存读写的方法</h4><p>（1）通过内存标识符（即变量名）</p><p>（2）通过内存地址，通过&amp;符号获得内存的首地址</p><p><a href="https://imgse.com/i/vxiHl4"><img src="https://s1.ax1x.com/2022/09/14/vxiHl4.png" alt="vxiHl4.png"></a></p><h4 id="5-C-中的两种变量"><a href="#5-C-中的两种变量" class="headerlink" title="5.C++中的两种变量"></a>5.C++中的两种变量</h4><p>关于变量：</p><p>​    变量提供一个具体的，可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算</p><p>​    对于C++程序员来说，“变量(variable)”和”对象(object)”一般可以互换使用</p><p>（1）普通变量</p><p>定义方法：数据类型    变量名</p><p>（2）指针变量</p><p>定义方法：数据类型*    变量名</p><p><a href="https://imgse.com/i/vxiX01"><img src="https://s1.ax1x.com/2022/09/14/vxiX01.png" alt="vxiX01.png"></a></p><h3 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h3><p>​    前提引入：<strong>复合类型</strong></p><p>复合类型是指基于其他类型定义的类型，以下将将C++语言中的两种复合类型：引用和指针</p><p>一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更为通用的描述是，<strong>一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成</strong></p><h4 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h4><p>拓展：C++11新标准中新增了一种引用：所谓的“右值引用”，指针引用主要用于内置类；</p><p>严格来说，当我们使用术语“引用”时，指的其实是“左值引用”</p><p><strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名</p><p>当我们定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起</p><p>注：引用并非对象，相反的，它只是为了一个已经存在的对象所起的另外一个名字</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针是“指向”另外一种类型的复合类型。指针与引用不同之处在于，指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，且指针无须在定义时赋初值。</p><p>注：在32位的操作系统中，所有的指针变量都是4个字节</p><p><a href="https://imgse.com/i/vxiOmR"><img src="https://s1.ax1x.com/2022/09/14/vxiOmR.png" alt="vxiOmR.png"></a></p><p>指针存放着某个对象的地址，要想获取该地址，需要使用取地址符(操作符&amp;)：</p><pre><code class="c++">int val = 42;int* p = &amp;val; // p存放变量val的地址，或者说p是指向变量val的指针</code></pre><p>需要我们注意的是，引用不是对象，没有实际的地址，所以我们不能定义指向引用的指针</p><p><strong>指针的类型要与它所指向的对象严格匹配</strong>（有例外）</p><h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>​    指针的值（即地址）应属下列4种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象</li><li>无效指针，也就是上述情况之外的其他值（一般这种情况下，指针被称为野指针）</li></ol><p>注意：试图拷贝或以其他方式访问无效指针的值都将引发错误</p><h4 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h4><p>​    如果指针指向了一个对象(重要前提)，则允许使用<strong>解引用符</strong>(操作符*)来访问对象：</p><pre><code class="C++">int val = 42;int* p =&amp;val; // p存放着变量val的地址，或者说p是指向变量val的指针cout&lt;&lt;*p;    // 由符号*得到指针p所指的对象，输出对应的值42</code></pre><p>对指针解引用会得出所指的对象，因此<strong>如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值</strong></p><p>注：解引用操作仅适用于那些确实指向某个对象的有效指针</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>​    <strong>空指针</strong>（null pointer）不指向任何对象，在试图适用一个指针之前的代码可以首先检查它是否为空</p><pre><code class="C++">int *p1 = nullptr; // 等价于int *p1 = 0;int *p2 = 0;        // 直接将p2初始化为字面常量0// 需要首先#include&lt;cstdlib&gt;int *p3 = NULL;    // 等价于int *p3 = 0;</code></pre><p>得到空指针最直接的办法就是字面值nullptr来初始化指针，这也是C++11新标准引入的一种方法。</p><p>nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型</p><p>在之前的程序中还会用到一个名为NULL的预处理变量来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0</p><p><strong>拓展</strong>：（1）NULL为预处理变量（2）预处理器是运行于编译过程之前的一段程序（3）预处理变量不属于命名空间std，它由预处理器负责</p><p>当用到一个预处理变量时，预处理器会自动地将它们替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的</p><p><strong>在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL</strong></p><p><strong>指针使用建议：初始化所有指针</strong></p><h4 id="关于CPU的两种存储模式"><a href="#关于CPU的两种存储模式" class="headerlink" title="关于CPU的两种存储模式"></a>关于CPU的两种存储模式</h4><p>大端模式：高地址存储数据的低位，低地址存储数据的高位</p><p>小端模式：低地址存储数据的低位，高地址存储数据的高位</p><p><a href="https://imgse.com/i/vxisfS"><img src="https://s1.ax1x.com/2022/09/14/vxisfS.png" alt="vxisfS.png"></a></p><h4 id="C语言中数据类型决定指针变量的寻址范围"><a href="#C语言中数据类型决定指针变量的寻址范围" class="headerlink" title="C语言中数据类型决定指针变量的寻址范围"></a>C语言中数据类型决定指针变量的寻址范围</h4><p>​    通过不同的数据类型指针变量，对同一块内存进行操作的时候，一次读取数据的字节数不一样</p><pre><code class="C++">int* p1; // 一次操作4个字节short* p2; // 一次操作2个字节char* p3; // 一次操作1个字节</code></pre><p>指针变量在移动的时候，每次移动的大小为指向对象数据类型的大小</p><h3 id="一级指针和字符串"><a href="#一级指针和字符串" class="headerlink" title="一级指针和字符串"></a>一级指针和字符串</h3><p>示例：</p><pre><code class="c++">char buf[100] = &quot;WPS&quot;;char* s = &quot;WPS&quot;;buf[0] = &#39;X&#39;; // 正确s[0] = &#39;X&#39;;   // 错误</code></pre><p>结论：</p><ol><li>定义数组保存字符串的时候，字符串保存在栈区，栈区的内存有读写权限</li><li>定义指针保存字符串的时候，指针保存的是字符串的首地址。字符串存放到常量区，常量区是系统单独分配的一块内存，在这个区域字符串只能进行读操作，不能进行写操作</li></ol><p><a href="https://imgse.com/i/vxi6Sg"><img src="https://s1.ax1x.com/2022/09/14/vxi6Sg.png" alt="vxi6Sg.png"></a></p><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p>函数中使用指针的场景：</p><ol><li>当需要存储的数据内存过大（结构体或者数组），传递指针可以节省内存空间，从而减少所需的拷贝时间：</li></ol><p>例如输出数组的信息：</p><p><a href="https://imgse.com/i/vxi7pF"><img src="https://s1.ax1x.com/2022/09/14/vxi7pF.png" alt="vxi7pF.png"></a></p><p>2.需要在函数内计算某个数据，在函数内出参</p><p>例如基本的计算：</p><p><a href="https://imgse.com/i/vxiqX9"><img src="https://s1.ax1x.com/2022/09/14/vxiqX9.png" alt="vxiqX9.png"></a></p><h2 id="C-新语法"><a href="#C-新语法" class="headerlink" title="C++新语法"></a>C++新语法</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载函数（overload）——同一作用域内几个函数名字相同但形参列表不同</p><p>注：main函数不能重载</p><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同，<strong>不允许两个函数除了返回类型外其他所有要素都相同</strong></p><pre><code class="C++">int lookup(const Account&amp;);bool lookup(const Account&amp;); // 错误：与上一个函数相比只有返回类型不同</code></pre><p><strong>函数重载规则：</strong></p><ul><li>函数名称必须相同</li><li>参数列表必须不同（个数不同，或类型不同，参数排列顺序不同等）</li><li>函数返回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为函数的重载</li></ul><h4 id="判断两个形参的类型是否"><a href="#判断两个形参的类型是否" class="headerlink" title="判断两个形参的类型是否"></a>判断两个形参的类型是否</h4><p>有时候两个形参列表看起来不一样，但实际上是相同的：</p><pre><code class="C++">// 每对声明的是同一函数int lookup(const string &amp;message);int lookup(const string&amp;); // 省略了形参的名字typedef double dou;int lookup(const double&amp;);int lookup(const dou&amp;);       // 二者类型相同</code></pre><h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>​    一个拥有顶层const的形参无法和另一个没有顶层const的形参区别开来：</p><pre><code class="c++">int lookup（string);int lookup(const string); // 重复声明</code></pre><p>另一方面，<strong>如果形参是某种类型的指针或引用，则通过区别其指向的是常量对象还剩非常量对象可以实现函数重载，此时的const是底层的：</strong></p><pre><code class="C++">// 对于接收引用或指针的函数来说，对象是常量还是非常量对应的形参不同// 定义了4个独立的重载函数int lookup(string&amp;); // 函数作用于string的引用int lookup(const string&amp;); // 新函数，作用于常量引用int lookup(string*); // 新函数，作用于指向string的指针int lookup(const string*); // 新函数，作用于指向常量的指针</code></pre><p>注：当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</p><h4 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h4><p>​    定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配</strong>是指一个过程，在这个过程中我们把函数调用于一组重载函数中的某一关联起来，函数匹配也叫<strong>重载确定</strong>。编译器首先将调用的实参于重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数</p><p>​    当调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参<strong>最佳匹配</strong>的函数并生成调用该函数的代码</li><li>找不到任何一个函数与调用实参匹配，此时编译器发出<strong>无匹配</strong>的错误信息</li><li>有多于一个函数可以匹配，但每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong></li></ul><h3 id="栈堆内存分配"><a href="#栈堆内存分配" class="headerlink" title="栈堆内存分配"></a>栈堆内存分配</h3><h4 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h4><p>​    申请内存：void* malloc(unsigned size);</p><p>​    释放内存：void free();</p><p><a href="https://imgse.com/i/vxi2Os"><img src="https://s1.ax1x.com/2022/09/14/vxi2Os.png" alt="vxi2Os.png"></a></p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>​    new&#x2F;delete，是一个C++中堆区内存分配的运算符</p><p>​    new——向堆申请空间</p><p>​    delete——释放堆区的空间</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p><a href="https://imgse.com/i/vxiofU"><img src="https://s1.ax1x.com/2022/09/14/vxiofU.md.png" alt="vxiofU.md.png"></a></p><h5 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h5><ol><li>malloc&#x2F;free是C语言中提供的库函数，new&#x2F;delete是C++中的运算符</li><li>malloc可以在堆区分配空间，但是返回值是void*指针，使用要强制转换；而new&#x2F;delete使用的时候，系统的调度资源少一些。直接通过指针连接回收</li><li>new&#x2F;delete申请对象空间的时候，会调用对象的构造函数和析构函数，而malloc不会调用</li></ol><p>示例代码：</p><p><a href="https://imgse.com/i/vxiclQ"><img src="https://s1.ax1x.com/2022/09/14/vxiclQ.png" alt="vxiclQ.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/2022/09/08/%E9%A2%98%E8%A7%A3/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2022/09/08/%E9%A2%98%E8%A7%A3/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: [10,2]输出: &quot;102&quot;</code></pre><p>示例 2:</p><pre><code>输入: [3,30,34,5,9]输出: &quot;3033459&quot;</code></pre><p> </p><p>提示:</p><pre><code>0 &lt; nums.length &lt;= 100</code></pre><p>说明:</p><pre><code>输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>这里的神来之笔是return a+b&lt;b+a这个操作，巧妙的对数组进行排列。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    string minNumber(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;string&gt;snum;        string res;        for(auto num:nums)&#123;            snum.push_back(to_string(num));        &#125;        sort(snum.begin(),snum.end(),cmp);        for(auto s:snum)&#123;            res+=s;        &#125;        return res;    &#125;    static bool cmp(const string&amp;a,const string b)&#123;        return a+b&lt;b+a;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同构字符串</title>
      <link href="/2022/09/08/%E9%A2%98%E8%A7%A3/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/09/08/%E9%A2%98%E8%A7%A3/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给定两个字符串 s 和 t ，判断它们是否是同构的。如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入：s = &quot;egg&quot;, t = &quot;add&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;foo&quot;, t = &quot;bar&quot;输出：false</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;paper&quot;, t = &quot;title&quot;输出：true</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 5 * 104t.length == s.lengths 和 t 由任意有效的 ASCII 字符组成</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>创建两个桶数组，然后分别存放该字符出现的位置，如果产生冲突就返回false。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/isomorphic-strings">https://leetcode.cn/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组游戏</title>
      <link href="/2022/09/07/%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/09/07/%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。小猫咪表示“我太难了”你能帮帮它么?</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>输入说明：</p><pre><code>会有多组询问首先输入一个数字t (1&lt;=t&lt;=10)接下来有t组数据每组数据里，首先会有一个数n，表示接下来这个数列的长度为n然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><p>输出描述:</p><pre><code>对于每一个提问，请依次输出最多可以选取多少个数</code></pre><p>备注:</p><pre><code>每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题目相对比较简单，注意从左到右依次取，并且取的过程中sum一直非负，而不是最后sum非负，<br>思路:</p><pre><code>从左到右依次遍历，遇到正数或者零直接选，遇到负数则分两种情况，情况1:选了之后sum &gt;= 0，那么直接选。情况2︰选了之后sum &lt; ，那么从已经选择的负数中置换出一个最小的。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main() &#123;    int t;cin &gt; t;    while(t--)&#123;        int n;        while (cin &gt;&gt;n) &#123;            vector&lt;int&gt; nums(n);            for(auto &amp;e : nums) cin &gt;&gt; e;            LL sum = e, cnt = e;            priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;            for(auto &amp;e : nums)&#123;                if(e &gt;= e) &#123;//遥到正数直接选                    sum += e;                    cnt+t;                &#125;                else &#123;                    if(sum + e &gt;= e)&#123;//情况                        sum += e;                        pq.push(e);cnt++;                    &#125;                    else &#123; //情况                        pq. push(e);                        sum += e;                        sum -= pq.top();                        pq. pop();                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; cnt &lt;&lt; endl;    &#125;    return e;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2022/09/07/%E9%A2%98%E8%A7%A3/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/09/07/%E9%A2%98%E8%A7%A3/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>全排列 一般把1~ n 这 n 个整数按某个顺序摆放的结果称为这 n 个整数的一个排列，而全排列指这 n 个整数能形成的所有排列。<br>例如对1、2、3这三个整数来说，(1,2,3)、(1,3,2)、(2,1,3)、(2,3,1 、(3,1,2)、(3,2, I ）就是1<del>3的全排列。<br>从递归的角度去考虑，如果把问题描述成“输出1</del> n 这 n 个整数的全排列”，那么它就可以被分为若干个子问题：“输出以1开头的全排列”“输出以2开头的全排列”…“输出以 n 开头的全排列”。于是不妨设定一个数组 P ，用来存放当前的排列；再设定一个散列数组 hash Table ，其中 hashTable [ x ］当整数 x 已经在数组 P 中时为 true 。<br>现在按顺序往 P 的第1位到第 n 位中填入数字。不妨假设当前已经填好了 P [1]~ P [ index -1]，正准备填 P [ index ]。显然需要枚举1~ n ，如果当前枚举的数字 x 还没有在 P [1]~ P [ index -1］中（即 hashTable [ x ]&#x3D; false )，那么就把它填入 P [ index ]，同时将 hashTable [ x ］置为 true ,然后去处理 P 的第 Tndex +1位（即进行递归）；而当递归完成时，再将 hashTable [ x ］还原为 false ,以便让 P [ index ］填下一个数字。<br>当 index 达到 n +1时，说明 P 的第1~ n 位都已经填好了，此时可以把数组 P 输出，表示生成了一个排列，然后直接 return 即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    # include &lt; cstdio &gt;    const int maxn =1l;    //P为当前排列， hashTable 记录整数 x 是否已经在 P 中     int n , P [maxn], hashTable[maxn]=&#123;false&#125;;    //当前处理排列的第 index 号位    void generateP ( int index )&#123;        if ( index = n +1)&#123;//递归边界，已经处理完排列的1~ n 位            for ( int i = 1 ; i &lt;= n ; i ++)&#123;                printf (&quot;%d&quot;, P [ i ]);//输出当前排列            &#125;            printf (&quot;\n &quot;);            return ;        &#125;        for ( int ×=1;×&lt;= n ;×++)&#123;//枚举1~ n ，试图将×填入 P [ index ]            if ( hashTable [ x ]== false )&#123;//如果×不在P[0]~P [index-1］中             P [ index ]= X ;//令 P 的第 index 位为×，即把×加入当前排列             hashTable [ x ]= true ;//记 x 已在 P 中            generateP ( index +1);//处理排列的第 index +1号位            hashTable [ x ]= false ;//已处理完 P [ index ］为×的子问题，还原状态            &#125;        &#125;    &#125;    int main ()&#123;        n =3;//欲输出1~3的全排列        generateP (1);//从 P [1］开始填         return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期差值</title>
      <link href="/2022/09/06/%E9%A2%98%E8%A7%A3/%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC/"/>
      <url>/2022/09/06/%E9%A2%98%E8%A7%A3/%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>求出两个日期之间的相差的天数，相邻日期算两天</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>示例 1:    输入: 20200111         20200112    输出: 2 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一道比较简单的题，只要月份天数闰年平年，注重细节就好了，记录这道题仅仅是熟悉一个思路比较清晰的方法。</p><p>不妨假设第一个日期早于第二个日期（否则交换即可)。<br>这种求日期之间相差天数的题目有一个很直接的思路，即令日期不断加1天，直到第一个日期等于第二个日期为止，即可统计出答案。具体处理时，如果当加了一天之后天数d等于当前月份m所拥有的天数加1，那么就令月份m加1、同时置天数d为1号（即把日期变为下一个月的1号);如果此时月份m变为了13，那么就令年份y加1、同时置月份m为1月（即把日期变为下一年的1月)。<br>为了方便直接取出每个月的天数，不妨给定一个二维数组int month[13][2]，用来存放每个月的天数，其中第二维为0时表示平年，为1时表示闰年。<br>注意:如果想要加快速度，只需要先把第一个日期的年份不断加1，直到与第二个日期的年份相差1为止，期间根据平年或是闰年来累加365天或者366天即可。之后再进行不断令天数加1的操作。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #include &lt;cstdio&gt;    int month[13][2] =&#123; //平年和闰年的每个月的天数    &#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,    &#123;31, 31&#125;,&#123;31,31&#125;, &#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;    &#125;    bool isLeap(int year) &#123;//判断是否是闰年        return (year % 4== 0 &amp;&amp; year % 100 = 0) &amp;&amp;(year % 400== 0);    &#125;    int main() &#123;        int timel, yl,ml,dl;        int time2, y2,m2,d2;        while(scanf( &quot;%d%d&quot;,&amp;timel,&amp;time2) !=EOF)&#123;            if(time1 &gt;time2)&#123; 1/第一个日期晚于第二个日期,则交换                int temp=timel;                timel = time2;                time2 = temp;            &#125;            y1 = time1 / 10000, ml = time1 % 10000 / 100,d1 = timel % 100;            y2 = time2 / 10000, m2 = time2 % 10000 / 100,d2 = time2 % 100;            int ans =1;//记录结果            //第一个日期没有达到第二个日期时进行循环            //即!((y1 == y2) &amp;&amp; (ml == m2) &amp;&amp;(d1 == d2))            while(yl&lt; y2 || ml&lt; m2 || d1&lt;d2)&#123;                d1++;//天数加1                if(d1 == month [m1] [isLeap(y1)] +1)&#123;//满当月天数                    m1++;//日期变为下个月的1号                    dl =1;                &#125;                if(m1 ==13) &#123; //月份满12个月                    y1++;//日期变为下一年的1月m1=1;                &#125;                ans++;//累计            &#125;        &#125;    return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络边缘</title>
      <link href="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/"/>
      <url>/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ul><li>网路边缘<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心<ul><li>互联着的路由器</li><li>网络的网络</li></ul></li><li>网络接入<ul><li>有线或者无线通信链路</li></ul></li></ul><p>从应用往下看都是网络基础设施</p><h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul><li>端系统（主机）<ul><li>运行应用程序</li><li>如Web，email</li><li>在“网络的边缘”</li></ul></li><li>客户&#x2F;服务器模式 C&#x2F;S<ul><li>客户端向服务器请求接受服务</li><li>如Web浏览器&#x2F;服务器；email客户端&#x2F;服务器</li></ul></li><li>对等模式 P2P<ul><li>很少专门的服务器</li><li>如Emule，KozaA</li></ul></li></ul><h3 id="采用网络设施的面向连接的服务"><a href="#采用网络设施的面向连接的服务" class="headerlink" title="采用网络设施的面向连接的服务"></a>采用网络设施的面向连接的服务</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>在端系统之间传输数据<br><strong>握手</strong>：在数据传输之前做好准备</p><ul><li>人类协议中：你好，你好</li><li>两个通信主机之间为连接建立状态<br>面向连接的通信方式：通信方式只有端节点知道</li></ul><p><strong>TCP-传输控制协议</strong></p><ul><li>Internet上面向连接的服务</li></ul><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠的，按顺序的传送数据<ul><li>确认和重传</li></ul></li><li>流量控制<ul><li>发送方不会淹没接收方</li></ul></li><li>拥塞控制<ul><li>当网络拥塞时，发送方降低发送速率</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="/2022/09/04/%E9%A2%98%E8%A7%A3/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2022/09/04/%E9%A2%98%E8%A7%A3/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一-暴力法"><a href="#一-暴力法" class="headerlink" title="一 暴力法"></a>一 暴力法</h4><pre><code>—略—</code></pre><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><pre><code>其实这道题很明显就满足最优子结构性，如果想用最少的硬币兑换money，这对硬币的子集的总金额所需硬币数一定是最少的，否则用更少的硬币替换这个子集的硬币，则总money所需硬币数一定比原来少。现在的问题是如何获得状态方程。假设硬币的金额有m1,m2...mx,需要兑换的总金额为money，金额为money的硬币数存在f[money]中，那么f[money]一定可以由f[money-m1]+1,f[money-m2]+1...f[money-mx]+1中的一个或者多个组成，上面已经说明最优子结构，这样，我们只需要找f[money-m1],f[money-m2]...f[money-mx]中的最小值。问题不断分解，分解到f[m1],f[m2]...f[mx]这些确定值上面（都为1）。按照这个思路，我们反向进行迭代最终就可以求得f[money];    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int Max = amount + 1;        vector&lt;int&gt; dp(amount + 1, Max);        dp[0] = 0;        for (int i = 1; i &lt;= amount; ++i) &#123;            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;                if (coins[j] &lt;= i) &#123;                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &gt; amount ? -1 : dp[amount];    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/">https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信的三种方式</title>
      <link href="/2022/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="通信的三种方式"><a href="#通信的三种方式" class="headerlink" title="通信的三种方式"></a>通信的三种方式</h4><ul><li><p>客户&#x2F;服务器模型</p></li><li><p>P2P模型</p></li><li><p>混合模型</p></li></ul><h4 id="网络接入"><a href="#网络接入" class="headerlink" title="网络接入"></a>网络接入</h4><ul><li><p>点对点方式接入</p><ul><li>电话线</li><li>电缆&#x2F;光纤混合电路</li><li>光纤到户</li><li>卫星</li></ul></li><li><p>以以太网&#x2F;WIFI的方式</p><ul><li>以太网(有线)</li><li>WiFi(无线)</li></ul></li><li><p>广域无线接入</p></li></ul><h4 id="介质"><a href="#介质" class="headerlink" title="介质"></a>介质</h4><ul><li>导引型介质<ul><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li><li>非导引型介质<ul><li>大气层</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="数据传输的方式"><a href="#数据传输的方式" class="headerlink" title="数据传输的方式"></a>数据传输的方式</h4><ul><li>电路交换网络<ul><li>建立连接</li><li>交换数据</li><li>释放连接</li></ul></li><li>分组交换网络<ul><li>长数据切分成小段</li><li>生成分组，每个数据段加上首部</li><li>发送数据</li><li>接受数据</li><li>恢复原来报文</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2022/09/01/DesignMode/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/01/DesignMode/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，常常拥有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有的原因而无法和任务的整体结构同时实现。<br>我们希望能够在稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义了一组同类型的算法，在不同的类中封装起来，每种算法可以根据当前场景相互替换，从而使算法的变化独立于使用它们的客户端（即算法的调用者）</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>小王同学的爷爷老王刚开始使用电脑，看着电脑里的各种格式.txt、docx、jpg，瞬间眼花缭乱，身为c++程序员出身的小王，立马拍着胸脯说要给爷爷写个程序，通过程序去自动的打开各种格式文件<br>小王打开电脑，三下五除二就把程序写好了</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG&#125;;class filemanager&#123;    public:    void opentxtfile()&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;    void opendocxfile()&#123;        std::cout&lt;&lt;&quot;word is opened&quot;&lt;&lt;std::endl;    &#125;    void openjpgfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;    void openpngfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;int main()&#123;    FILETYPE openfiletype=FILETYPE::TXT;    filemanager file;    switch (openfiletype)&#123;    case FILETYPE::TXT:        file.opentxtfile();        break;    case FILETYPE::DOCX:        file.opendocxfile();        break;    case FILETYPE::JPG:        file.openjpgfile();        break;    case FILETYPE::PNG:        file.openpngfile();        break;        default:        break;    &#125; &#125;</code></pre><p>爷爷选择了一个txt文件，文件就打开了，爷爷笑靥如花，小王仰起了骄傲的头~<br>过了两天，爷爷给小王打电话，说.avi的视频文件打不开<br>于是小王不得不修改了枚举类</p><pre><code>enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG,    avi&#125;;</code></pre><p>然后又修改了switch case</p><pre><code>case FILETYPE::avi:        file.openavifile();        break;</code></pre><p>随着增加格式越来越多.xlsx .mp3 .mp4 …. switch case 越来越长，而且每次修改的地方较多，一不小心会引起其他bug，小王终于受不了了，买了一本设计模式的书~</p><p>初步优化，小王使用策略模式：<br>抽出open接口</p><pre><code>class openinterface&#123;    public:    virtual void open()=0;    virtual ~openinterface()&#123;&#125;&#125;;</code></pre><p>定义各种文件的实现</p><pre><code>//txt fileclass textfile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;//jpg fileclass jgpfile:public openinterface&#123;public:    void open() override&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>引入管理类</p><pre><code>class openfilemanager&#123;public:    openfilemanager(openinterface* pOpen)&#123;        _pOpen=pOpen;    &#125;    void openfile()&#123;        _pOpen-&gt;open();    &#125;    ~openfilemanager()&#123;        if(_pOpen) delete _pOpen;    &#125;private:    openinterface* _pOpen;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    FILETYPE currentfiletype=FILETYPE::TXT;    if(currentfiletype==FILETYPE::TXT;)&#123;        openfilemanager* pmanager=new openfilemanager(new textfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    if(currentfiletype==FILETYPE::JPG)&#123;        openfilemanager* pmanager=new openfilemanager(new jgpfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    return 0;&#125;</code></pre><p>通过这一步的优化，程序可维护性好了，再增加新功能不会对旧功能产生影响，这就是策略模式~但是 switch case 并没有减少，而且枚举也存在，小王还是不满意</p><p>针对这个例子：<br>修改openfilemanager， 增加个map，程序启动的时候加载到内存里</p><pre><code>class openfilemanager&#123;public:    void add(std::string key,openinterface* pFile)&#123;        _filemap.insert(std::make_pair(key,pFile));    &#125;    void openfile(std::string filetype)&#123;        _filemap[filetype]-&gt;open();    &#125;    ~openfilemanager()&#123;        for(auto iter=_filemap.begin();iter!=_filemap.end();iter++)&#123;            delete iter-&gt;second;        &#125;    &#125;private:    std::unordered_map&lt;std::string,openinterface*&gt; _filemap;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    //init    openfilemanager filemanager;    filemanager.add(&quot;txt&quot;,new textfile);    filemanager.add(&quot;jpg&quot;,new jgpfile);    //open file    filemanager.openfile(&quot;txt&quot;);    return 0;&#125;</code></pre><p>爷爷又来电话，说想打开.pdf文件，小王剑指如飞，增加了如下类</p><pre><code>class pdffile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;pdf is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>初始化的时候增加pdf</p><pre><code>openfilemanager filemanager;     filemanager.add(&quot;txt&quot;,new textfile);     filemanager.add(&quot;jpg&quot;,new jgpfile);filemanager.add(&quot;pdf&quot;,new pdffile);</code></pre><p>小王没一会功夫就把程序交给了爷爷，嘿嘿一笑，深藏功与名</p><h2 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h2><p>Strategt类，定义所有支持的算法的公共接口</p><pre><code>class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;</code></pre><p>ConcreteStrategy 封装了具体的算法或行为，继承Strategy</p><pre><code>class ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;</code></pre><p>Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用</p><pre><code>class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;</code></pre><p>整份代码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define free_ptr(p) if(p) delete p; p = nullptr;//Strategt类，定义所有支持的算法的公共接口class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;//ConcreteStrategy 封装了具体的算法或行为，继承Strategyclass ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;//Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;int main() &#123;    Strategy* concreteStrategyA = new ConcreteStrategyA();    Strategy* concreteStrategyB = new ConcreteStrategyB();    Strategy* concreteStrategyC = new ConcreteStrategyC();    concreteStrategyA-&gt;AlgorithmInterface();    concreteStrategyB-&gt;AlgorithmInterface();    concreteStrategyC-&gt;AlgorithmInterface();    free_ptr(concreteStrategyA);    free_ptr(concreteStrategyB);    free_ptr(concreteStrategyC);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件协作模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2022/08/30/cpp/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/30/cpp/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况发⽣。使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域时，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。</p><p><strong>注意！！！智能指针没有从根本上解决了c++内存安全的问题</strong></p><h2 id="常⽤接⼝"><a href="#常⽤接⼝" class="headerlink" title="常⽤接⼝"></a>常⽤接⼝</h2><pre><code>T* get();T&amp; operator*(); T* operator-&gt;();T&amp; operator=(const T&amp; val);T* release();void reset (T* ptr = nullptr);</code></pre><ul><li>T 是模板参数, 也就是传⼊的类型；</li><li>get() ⽤来获取 <strong>auto_ptr</strong> 封装在内部的指针, 也就是获取原⽣指针；</li><li>operator() 重载 , operator-&gt;() 重载了-&gt;, operator&#x3D;()重载了&#x3D;；</li><li>realease() 将 <strong>auto_ptr</strong> 封装在内部的指针置为 nullptr, 但并不会破坏指针所指向的内容, 函数返回的是内部指针置空之前的值；</li><li>直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值,  则将内部指针初始化为该值 (否则将其设置为nullptr；<h2 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h2></li></ul><p><strong>1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</strong></p><pre><code>auto_ptr&lt;std::string&gt; p1 (new string (&quot;hello&quot;));auto_ptr&lt;std::string&gt; p2;p2 = p1; //auto_ptr 不会报错.</code></pre><p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 <strong>auto_ptr</strong> 的缺点是：存在潜在的内存崩溃问题！</p><p><strong>2、unique_ptr（替换 <strong>auto_ptr</strong> ）</strong><br><strong>unique_ptr</strong> 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。<br>采⽤所有权模式，还是上⾯那个例⼦</p><pre><code>unique_ptr&lt;string&gt; p3 (new string (auto));unique_ptr&lt;string&gt; p4;p4 = p3;//此时会报错</code></pre><p>编译器认为 p4&#x3D;p3 ⾮法，避免了 p3 不再指向有效数据的问题。因此，<strong>unique_ptr</strong> ⽐ <strong>auto_ptr</strong> 更安全。</p><p><strong>3、shared_ptr（共享型，强引⽤）</strong><br><strong>shared_ptr</strong>实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。<br>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊<strong>auto_ptr</strong>, <strong>unique_ptr</strong>,<strong>weak_ptr</strong> 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。<br><strong>shared_ptr</strong> 是为了解决 <strong>auto_ptr</strong> 在对象所有权上的局限性 (<strong>auto_ptr</strong> 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。</p><p><strong>4、weak_ptr（弱引⽤）</strong><br><strong>weak_ptr</strong> 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 <strong>shared_ptr</strong> 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 <strong>shared_ptr</strong>。<br><strong>weak_ptr</strong> 只是提供了对管理对象的⼀个访问⼿段。<strong>weak_ptr</strong> 设计的⽬的是为配合 <strong>shared_ptr</strong> ⽽引⼊的⼀种智能指针来协助 <strong>shared_ptr</strong> ⼯作，它只可以从⼀个 <strong>shared_ptr</strong> 或另⼀个 <strong>weak_ptr</strong> 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。<br><strong>weak_ptr</strong> 是⽤来解决 <strong>shared_ptr</strong> 相互引⽤时的死锁问题，如果说两个 <strong>shared_ptr</strong> 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数， 和 <strong>shared_ptr</strong> 之间可以相互转化，<strong>shared_ptr</strong> 可以直接赋值给它，它可以通过调⽤ lock 函数来获得 <strong>shared_ptr</strong>。<br>当两个智能指针都是 <strong>shared_ptr</strong> 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为<strong>weak_ptr</strong>就可以。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nullptr</title>
      <link href="/2022/08/30/cpp/nullptr/"/>
      <url>/2022/08/30/cpp/nullptr/</url>
      
        <content type="html"><![CDATA[<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。在某种意义上来说，传统 C++ 会把 NULL、 0 视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。<br>C++ 不允许直接将 void * 隐式转 换到其他类型，但如果NULL 被定义为 ((void*)0)，那么当编译 char *ch &#x3D; NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导致了 C++ 中重载特性 会发⽣混乱，考虑：<br>    void func(int);<br>    void func(char *);<br>对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL) 这个语句将 会去调⽤ func(int)，从⽽导致代码违反直观。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr 出现的⽬的是为了替代 NULL。<br>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。C++11 引⼊了 nullptr 关键字，专⻔⽤来区分空指针、0.值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：<br>int * a1 &#x3D; nullptr;<br>char * a2 &#x3D; nullptr;<br>double * a3 &#x3D; nullptr;<br>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。<br>当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前k个高频词</title>
      <link href="/2022/08/30/%E9%A2%98%E8%A7%A3/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E8%AF%8D/"/>
      <url>/2022/08/30/%E9%A2%98%E8%A7%A3/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前k个高频词"><a href="#前k个高频词" class="headerlink" title="前k个高频词"></a>前k个高频词</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><pre><code> 给你一个整数数组nums和一个整数k ，请你返回其中出现频率前k高的元素。 你可以按任意顺序返回答案。 </code></pre><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</code></pre><p>注意：</p><pre><code>求前 k 大，用小根堆，求前 k 小，用大根堆。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>方法一：桶+快排</strong></p><p>思路与算法：<br>本弱鸡的思路是先用桶把每个数字出现的次数记录下来，然后通过快排按照桶的大小将高频词前k排序出来。</p><p>代码略</p><p>复杂度分析</p><p><strong>时间复杂度：</strong>O(NlogN)，其中 N 为数组的长度。我们首先遍历原数组，并使用桶记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，取出不为0的数组范围O(N),然后采取快排取出前n大数组，总复杂度 O(NlogN)。<br><strong>空间复杂度</strong> 随着数据范围改变而改变</p><p><strong>方法二：堆</strong></p><p>思路与算法：<br>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。</p><p>最简单的做法是给「出现次数数组」排序。但由于可能有 O(N) 个不同的出现次数（其中 N 为原数组长度），故总的算法复杂度会达到 O(NlogN)，不满足题目的要求。</p><p>在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：</p><p>如果堆的元素个数小于 k，就可以直接插入堆中。<br>如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。<br>遍历完成后，堆中的元素就代表了「出现次数数组」中前 kk 大的值。</p><pre><code>class Solution &#123;public:    static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) &#123;        return m.second &gt; n.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v : nums) &#123;            occurrences[v]++;        &#125;        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp);        for (auto&amp; [num, count] : occurrences) &#123;            if (q.size() == k) &#123;                if (q.top().second &lt; count) &#123;                    q.pop();                    q.emplace(num, count);                &#125;            &#125; else &#123;                q.emplace(num, count);            &#125;        &#125;        vector&lt;int&gt; ret;        while (!q.empty()) &#123;            ret.emplace_back(q.top().first);            q.pop();        &#125;        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：</strong>O(Nlogk)，其中 N 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(logk) 的时间，共需 O(Nlogk) 的时间。二者之和为 O(Nlogk)。<br><strong>空间复杂度：</strong>O(N)。哈希表的大小为 O(N)，而堆的大小为 O(k)，共计为 O(N)。</p><p><strong>方法三：快排</strong></p><p>我们可以使用基于快速排序的方法，求出「出现次数数组」的前 k 大的值。<br>在对数组 arr[l…r] 做快速排序的过程中，我们首先将数组划分为两个部分 arr[i…q−1] 与 arr[q+1…j]，并使得 arr[i…q−1] 中的每一个值都不超过 arr[q]，且arr[q+1…j] 中的每一个值都大于 arr[q]。<br>于是，我们根据 k 与左侧子数组 arr[i…q−1] 的长度（为 q-iq−i）的大小关系：<br>如果k≤q−i，则数组 arr[l…r]前k大的值，就等于子数组arr[i…q−1]前k大的值。<br>否则，数组 arr[l…r] 前 k 大的值，就等于左侧子数组全部元素，加上右侧子数组 arr[q+1…j] 中前 k−(q−i) 大的值。<br>原版的快速排序算法的平均时间复杂度为O(NlogN)。我们的算法中，每次只需在其中的一个分支递归即可，因此算法的平均时间复杂度降为 O(N)O(N)。</p><pre><code>class Solution &#123;public:    void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) &#123;        int picked = rand() % (end - start + 1) + start;        swap(v[picked], v[start]);        int pivot = v[start].second;        int index = start;        for (int i = start + 1; i &lt;= end; i++) &#123;            if (v[i].second &gt;= pivot) &#123;                swap(v[index + 1], v[i]);                index++;            &#125;        &#125;        swap(v[start], v[index]);        if (k &lt;= index - start) &#123;            qsort(v, start, index - 1, ret, k);        &#125; else &#123;            for (int i = start; i &lt;= index; i++) &#123;                ret.push_back(v[i].first);            &#125;            if (k &gt; index - start + 1) &#123;                qsort(v, index + 1, end, ret, k - (index - start + 1));            &#125;        &#125;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v: nums) &#123;            occurrences[v]++;        &#125;        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; kv: occurrences) &#123;            values.push_back(kv);        &#125;        vector&lt;int&gt; ret;        qsort(values, 0, values.size() - 1, ret, k);        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：O(N^2)</strong><br>设处理长度为N的数组的时间复杂度为f(N)。由于处理的过程包括一次遍历和一次子分支的递归，最好情况下，有 f(N)&#x3D;O(N)+f(N&#x2F;2)，根据主定理，能够得到f(N)&#x3D;O(N)。<br>最坏情况下，每次取的中枢数组的元素都位于数组的两端，时间复杂度退化为O(N^2)。但由于我们在每次递归的开始会先随机选取中枢元素，故出现最坏情况的概率很低。<br><em>平均情况下，时间复杂度为 O(N)。</em><br><strong>空间复杂度：O(N)</strong><br>哈希表的大小为O(N)，用于排序的数组的大小也为 O(N)，快速排序的空间复杂度最好情况为 O(logN)，最坏情况为 O(N)。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/2022/08/30/DesignMode/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/08/30/DesignMode/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h2 id="面向对象的设计模式"><a href="#面向对象的设计模式" class="headerlink" title="面向对象的设计模式"></a>面向对象的设计模式</h2><p><strong>底层思维</strong>：如何把握机器底层从微观理解对象构造</p><ul><li>语言构造</li><li>编译转换</li><li>内存模型</li><li>运行时机制</li></ul><p><strong>抽象思维</strong>：如何将我们周围的世界抽象为程序代码</p><ul><li>面向对象</li><li>组件封装</li><li>设计模式</li><li>构架模式</li></ul><p><strong>三大面向对象机制</strong></p><ul><li>封装 隐藏内部实现</li><li>继承 复用现有代码</li><li>多态 改写对象行为</li></ul><h3 id="如何解决软件工程的复杂性？"><a href="#如何解决软件工程的复杂性？" class="headerlink" title="如何解决软件工程的复杂性？"></a>如何解决软件工程的复杂性？</h3><p><strong>分解</strong>：分而治之，将大问题分解成多个小问题<br><strong>抽象</strong>：忽视对象非本质细节，去处理和泛化和理想化的对象模型</p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><strong>依赖倒置原则(DIP)</strong></p><ul><li>高层模块（稳定）不应该依赖于低层模块（变化），二者应该都依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>开放封闭原则(OCP)</strong></p><ul><li>对拓展开放，对更改封闭</li><li>类模块应该是可以拓展的，但是不可修改</li></ul><p><strong>单一职责原则(SRP)</strong></p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p><strong>Liskov替换原则(LSP)</strong></p><ul><li>子类必须能够替代他们的基类(is-A)</li><li>继承表达类型抽象</li></ul><p><strong>接口隔离原则(ISP)</strong></p><ul><li>不应该强迫客户程序依赖他们不用的方法</li><li>接口应该小而完备</li></ul><p><strong>优先使用对象组合，而不是类继承</strong></p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p><strong>封装变化点</strong></p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><p><strong>针对接口编程，而不是针对实现编程</strong></p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需或者对象的具体类型，只需获取对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现”高内聚，松耦合”的类型设计方案</li></ul><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><ul><li><code>+</code> –&gt; public</li><li><code>-</code> –&gt; private</li><li><code>#</code> –&gt; protected</li><li>静态成员，下划线表示</li><li>纯虚函数，斜体</li></ul><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><ul><li>Assocation (knows a)<ul><li>一个对象知道另一个对象的存在，该对象持有另一个对象的指针或者引用。</li></ul></li><li>Dependency (uses a)<ul><li>当类Y与类X彼此独立，而类Y是类X成员函数的一个参数，或者X中成员函数的一个局部变量。</li></ul></li><li>Composition (has a)<ul><li>一个类是另一个类的集合或者容器，但被包含的类与容器本身并不具备相同的生命期</li></ul></li><li>Aggregation (has a)<ul><li>组合（composition）是聚合（Aggregation）的增强版。组合和聚合的根本不同在于类与其所持有元素的是否具有相同的生命期，要求必须相同是一种组合关系。</li></ul></li><li>Inheritance (is a)<ul><li>类间的继承关系表达的是一种derived class B is a base class A。</li></ul></li><li>Class template<ul><li>类模板意味着泛型类。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2022/08/12/%E9%A2%98%E8%A7%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/08/12/%E9%A2%98%E8%A7%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    示例 1:        输入: s = &quot;abcabcbb&quot;        输出: 3         解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。    示例 2:        输入: s = &quot;bbbbb&quot;        输出: 1        解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。    示例 3:        输入: s = &quot;pwwkew&quot;        输出: 3        解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。             请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    采用双指针的做法，通过一个桶记录字符是否出现过以及出现的位置，在O(n)的时间内解决问题</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/08/10/%E9%A2%98%E8%A7%A3/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/08/10/%E9%A2%98%E8%A7%A3/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入: head = [1,2,3,4,5]输出: [5,4,3,2,1]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    有迭代和递归两种做法</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>迭代做法</strong></p><pre><code>class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode prev = nullptr;        ListNode curr = head;        while (curr != null) &#123;            ListNode next = curr.next;            curr.next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;</code></pre><p><strong>递归做法</strong></p><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;            return head;        &#125;        ListNode* ret = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return ret;    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/08/10/cpp/sort/"/>
      <url>/2022/08/10/cpp/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法及其时间和空间复杂度"><a href="#十大排序算法及其时间和空间复杂度" class="headerlink" title="十大排序算法及其时间和空间复杂度"></a>十大排序算法及其时间和空间复杂度</h1><p><img src="/2022/08/10/cpp/sort/TenSort.png" alt="排序算法"><br><img src="/2022/08/10/cpp/sort/TenSort.png" alt="排序算法"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法描述：</p><ul><li>⽐较相邻的元素。如果第⼀个⽐第⼆个⼤，就交换它们两个；</li><li>对每⼀对相邻元素作同样的⼯作，从开始第⼀对到结尾的最后⼀对，这样在最后的元素应该会是最⼤的数；</li><li>针对所有的元素重复以上的步骤，除了最后⼀个；</li><li>重复步骤 1~3，直到排序完成。<br>代码如下：<br>  void BubbleSort(std::vector<int> &amp;nums, int n)<br>  {<br>  if (n &lt;&#x3D; 1) return;<br>  bool is_swap;<br>  for (int i &#x3D; 1; i &lt; n; ++i)<br>  {<br>      &#x2F;&#x2F;设定⼀个标记，若为false，则表示此次循环没有进⾏交换，也就是待排序列已经有序，排序已经完成。<br>      is_swap &#x3D; false;<br><br>      for (int j &#x3D; 1; j &lt; n - i + 1; ++j)<br>      {<br>          if (nums[j] &lt; nums[j-1])<br>          {<br>              &#x2F;&#x2F;表示有数据交换<br>              std::swap(nums[j], nums[j-1]); is_swap &#x3D; true;<br>          }<br>      }<br>      &#x2F;&#x2F;没有数据交换，提前退出<br>      if (!is_swap) break;<br>  }<br>  }</int></li></ul><p>冒泡排序空间复杂度为O(1)，是⼀种原地排序算法。<br>冒泡排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>冒泡排序是一种稳定的排序算法。</p><h3 id="插⼊排序"><a href="#插⼊排序" class="headerlink" title="插⼊排序"></a>插⼊排序</h3><p>算法描述：分为已排序和未排序的区间，初始已排序区间只有⼀个元素–就是数组第⼀个；遍历未排序的每⼀个元素在已排序区间⾥找到合适的位置插⼊并保证数据⼀直有序。<br>代码如下：<br>    void InsertSort(std::vector<int> &amp;nums,int n)<br>    {<br>        if (n &lt;&#x3D; 1) return;<br>        for(int i &#x3D; 0; i &lt; n; ++i) {<br>            for (int j &#x3D; i; j &gt; 0 &amp;&amp; nums[j] &lt; nums [j-1]; –j) {<br>                std::swap(nums[j],nums[j-1]);<br>            }<br>        }<br>    }</int></p><p>插入排序空间复杂度为O(1)，是⼀种原地排序算法。<br>插入排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>插入排序是一种稳定的排序算法。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最⼩的元素，将其放到已排序区间的末尾。<br>    void SelectSort(std::vector<int> &amp;nums, int n)<br>    {<br>        if (n &lt;&#x3D; 1) return;<br>        int mid;<br>        for (int i &#x3D; 0; i &lt; n - 1; ++i)<br>        {<br>            mid &#x3D; i;<br>            for (int j &#x3D; i + 1; j &lt; n; ++j) {<br>                if (nums[j] &lt; nums[mid])<br>                {<br>                    mid &#x3D; j;<br>                }<br>            }<br>            std::swap(nums[mid],nums[i]);<br>        }<br>    }<br>选择排序空间复杂度为O(1)，是⼀种原地排序算法。<br>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>选择排序是一种不稳定的排序算法。</int></p><p><strong>【时间,空间复杂度&#x2F;是否稳定？】</strong></p><p>那选择排序是稳定的排序算法吗？答案是否定的，选择排序是⼀种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最⼩值，并和前⾯的元素交换位置，这样破坏了稳定性.<br>【思考】冒泡排序和插⼊排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插⼊排序要⽐冒泡排序更受欢迎呢？<br>【思路】冒泡排序不管怎么优化，元素交换的次数是⼀个固定值，是原始数据的逆序度。插⼊排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，⽽插⼊排序只需要 1 个。把执⾏⼀个赋值语句的时间粗略地计为单位时间，处理相同规模的数，插⼊排序⽐冒泡排序减少三倍的单位时间！</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><strong>算法描述：</strong><br>先找到⼀个枢纽；在原来的元素⾥根据这个枢纽划分;⽐这个枢纽⼩的元素排前⾯；⽐这个枢纽⼤的元素排后⾯；两部分数据依次递归排序下去直到最终有序。<br>代码如下：<br>    void QuickSort(std::vector<int> &amp;nums,int l,int r)<br>    {<br>        if (l + 1 &gt;&#x3D; r) return;<br>        int first &#x3D; l, last &#x3D; r - 1 ,key &#x3D; nums[first];<br>        while (first &lt; last)<br>        {<br>            while (first &lt; last &amp;&amp; nums[last] &gt;&#x3D; key) last–;&#x2F;&#x2F;右指针 从右向左扫描 将⼩于piv的放<br>            到左边<br>            nums[first] &#x3D; nums[last];<br>            while (first &lt; last &amp;&amp; nums[first] &lt;&#x3D; key) first++;&#x2F;&#x2F;左指针 从左向右扫描 将⼤于piv的<br>            放到右边<br>            nums[last] &#x3D; nums[first];<br>        }<br>        nums[first] &#x3D; key;&#x2F;&#x2F;更新piv<br>        quick_sort(nums, l, first);&#x2F;&#x2F;递归排序 &#x2F;&#x2F;以L为中间值，分左右两部分递归调⽤<br>        quick_sort(nums, first + 1, r);<br>    }<br>快速排序空间复杂度为O(1)，是⼀种原地排序算法。<br>快速排序的最好情况时间复杂度 O(nlogn)、最坏情况 O(n^n)平均情况时间复杂度都为 O(nlogn)。<br>快速排序是一种不稳定的排序算法。</int></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法描述：归并排序是⼀个稳定的排序算法，归并排序的时间复杂度任何情况下都是    O(nlogn)，归并排序不是原地排序算法<br>⽤两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第⼀个元素。⽐较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;&#x3D;A[j]，我们就把 A[i] 放⼊到临时数组 tmp，并且 i 后移⼀位，否则将 A[j] 放⼊到数组 tmp，j 后移⼀位。</p><p>代码如下：<br>    void mergeCount(int a[],int L,int mid,int R)<br>    {<br>        int *tmp &#x3D; new int[L+mid+R];<br>        int i&#x3D;L;<br>        int j&#x3D;mid+1; int k&#x3D;0;<br>        while( i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;R )<br>        {<br>            if(a[i] &lt; a[j])<br>                tmp[k++] &#x3D; a[i++];<br>            else<br>                tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F;判断哪个⼦数组中有剩余的数据<br>        while( i&lt;&#x3D;mid )<br>        {<br>            tmp[k++] &#x3D; a[i++];<br>        }<br>        while( j&lt;&#x3D;R)<br>        {<br>            tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F; 将 tmp 中的数组拷⻉回 A[p…r]<br>        for(int p&#x3D;0; p&lt;k; ++p){<br>            a[L+p] &#x3D; tmp[p]; delete tmp;<br>        }<br>    }<br>    void mergeSort(int a[],int L,int R) {<br>        &#x2F;&#x2F;递归终⽌条件 分治递归<br>        &#x2F;&#x2F; 将 A[L…m] 和 A[m+1…R] 合并为 A[L…R]<br>        if( L&gt;&#x3D;R ) { return; } int mid &#x3D; L + (R - L)&#x2F;2; mergeSort(a,L,mid); mergeSort(a,mid+1,R); mergeCount(a,L,mid,R);<br>    }</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>算法描述：利⽤堆这种数据结构所设计的⼀种排序算法。堆积是⼀个近似完全⼆叉树的结构，并同时满⾜堆积的性质：即⼦结点的键值或索引总是⼩于（或者⼤于）它的⽗节点。堆排序可以⽤到上⼀次的排序结果，所以不像其他⼀般的排序⽅法⼀样，每次都要进⾏n-1次的⽐较，复杂度为O(nlogn)。<br>算法步骤：<br>1、利⽤给定数组创建⼀个堆H[0..n-1]（我们这⾥使⽤最⼩堆），输出堆顶元素<br>2、以最后⼀个元素代替堆顶，调整成堆，输出堆顶元素<br>3、把堆的尺⼨缩⼩ 1<br>4、重复步骤 2，直到堆的尺⼨为 1<br>建堆：将数组原地建成⼀个堆，不借助额外的空间，采⽤从上往下的堆化（对于完全⼆叉树来说，下标是 n&#x2F;2+1到n的节点都是叶⼦节点，不需要堆化）。<br>排序：”删除堆顶元素“：当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后在通过堆化的⽅法，将剩下的n-1个元素重新构建成堆，堆化完成之后，在取堆顶的元素，放到下标为 n-1 的位置，⼀直重复这个过程，直到最后 堆中只剩下标 1 的⼀个元素。<br>优点：O(nlogn)，原地排序，最⼤的特点：每个节点的值⼤于等于(或⼩于等于)其⼦树节点缺点：相⽐于快排，堆排序数据访问的⽅式没有快排友好；数据的交换次数要多于快排。<br>    void HeapSort(int a[], int n)<br>    {<br>        for(int i&#x3D;n&#x2F;2; i&gt;&#x3D;1; –i)<br>        {<br>            Heapify(a, n, i);<br>        }<br>        int k &#x3D; n;<br>        while( k &gt; 1)<br>        {<br>            swap(a[1],a[k]);<br>            –k;<br>            Heapify(a,k,1);<br>        }<br>    }</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>算法描述：将数组分到有限数量的桶⾥。每个桶再个别排序（有可能再使⽤别的排序算法或是以递归⽅式继续使⽤ 桶排序进⾏排序）。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>扩展：如果在⾯试中有⾯试官要求你写⼀个   O(n)   时间复杂度的排序算法，可不要傻乎乎的说这不可能！虽然前⾯基于⽐较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要 满⾜⼀定的范围的整数，⽽且计数排序需要⽐较多的辅助空间。<br>算法描述：其基本思想是，⽤待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序 序列。<br>假设有 8 个考⽣，分数在 0 到 5 分之间。这 8 个考⽣的成绩我们放在⼀个数组 A[8]中，它们分别是：2，5，3， 0，2，3，0，3。<br>考⽣的成绩从 0 到 5 分，我们使⽤⼤⼩为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考<br>⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到       C[6]的值。</p><p>这是我们的数组，从图中可以看出，分数为 3 分的考⽣有 3 个，⼩于 3 分的考⽣有 4 个，所以，成绩为 3 分的考<br>⽣在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。<br>那我们如何快速计算出，每个分数的考⽣在有序数组中对应的存储位置呢？<br>我们对 C[6] 数组顺序求和，C[6]存储的数据就变成了下⾯这样⼦。C[k]⾥存储⼩于等于分数 k 的考⽣个数。</p><p>我们从后到前依次扫描数组 A。⽐如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到⽬前为⽌，包括⾃⼰在内，分数⼩于等于 3 的考⽣有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中<br>下标为 6 的位置）。当 3 放⼊到数组 R 中后，⼩于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。<br>以此类推，当我们扫描到第 2 个分数为 3 的考⽣的时候，就会把它放⼊数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从⼩到⼤有序排列的了。<br>注意：计数排序只能⽤在数据范围不⼤的场景中，如果数据范围 k ⽐要排序的数据 n ⼤很多，就不适合⽤计数排序了。⽽且，计数排序只能给⾮负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对⼤⼩的情况下，   转化为⾮负整数。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独⽴的“位”来⽐较，⽽且位之间有递进的关系，    如果 a 数据的⾼位⽐ b 数据⼤，那剩下的低位就不⽤⽐较了。除此之外，每⼀位的数据范围不能太⼤，要可以⽤线性排序算法来排序，否则，基数排序的时间复杂度就⽆法做到 O(n) 了。<br>基数排序相当于通过循环进⾏了多次桶排序。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>算法描述：通过将⽐较的全部元素分为⼏个区域来提升插⼊排序的性能。这样可以让⼀个元素可以⼀次性地朝最终 位置前进⼀⼤步。然后算法再取越来越⼩的步⻓进⾏排序，算法的最后⼀步就是普通的插⼊排序，但是到了这步， 需排序的数据⼏乎是已排好的了。</p><pre><code>template&lt;typename T&gt;void shell_sort(T array[], int length) &#123;    int h = 1;    while (h &lt; length / 3) &#123;        h = 3 * h + 1;    &#125;    while (h &gt;= 1) &#123;        for (int i = h; i &lt; length; i++) &#123;            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;                std::swap(array[j], array[j - h]);            &#125;        &#125;        h = h / 3;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链接编译联编</title>
      <link href="/2022/08/08/cpp/%E9%93%BE%E6%8E%A5%E7%BC%96%E8%AF%91%E8%BF%9E%E7%BC%96/"/>
      <url>/2022/08/08/cpp/%E9%93%BE%E6%8E%A5%E7%BC%96%E8%AF%91%E8%BF%9E%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h2 id="链接编译联编"><a href="#链接编译联编" class="headerlink" title="链接编译联编"></a>链接编译联编</h2><h3 id="1-动态编译与静态编译"><a href="#1-动态编译与静态编译" class="headerlink" title="1.动态编译与静态编译"></a>1.动态编译与静态编译</h3><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；</p><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库， 则⽤动态编译的可执⾏⽂件就不能运⾏。</p><h3 id="2-动态链接和静态链接区别"><a href="#2-动态链接和静态链接区别" class="headerlink" title="2.动态链接和静态链接区别"></a>2.动态链接和静态链接区别</h3><p><strong>静态连接库</strong>就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；<br><strong>动态链接</strong>就是把调⽤的函数所在⽂件模块(DLL)和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候 再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。</p><p><strong>静态连接库</strong>与<strong>动态链接库</strong>都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib中的指令都全部被直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。<br><strong>静态连接库</strong>和<strong>动态链接库</strong>的另外⼀个区别在于静态链接库中不能再<br>包含其他的动态链接库或者静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。<br><strong>动态库</strong>就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对lib⽂件中同⼀个函数的调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。</p><h3 id="3-动态联编与静态联编"><a href="#3-动态联编与静态联编" class="headerlink" title="3.动态联编与静态联编"></a>3.动态联编与静态联编</h3><p>在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编和动态联编；<br><strong>静态联编</strong>是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成⼜称为早期联编。要实现静态 联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束 定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差。<br><strong>动态联编</strong>是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数 的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象 类型将做出不同的编译结果。C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类 的指针变量名-&gt;虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）</p><h4 id="实现动态联编三个条件："><a href="#实现动态联编三个条件：" class="headerlink" title="实现动态联编三个条件："></a>实现动态联编三个条件：</h4><p>1.必须把动态联编的⾏为定义为类的虚函数；<br>2.类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；<br>3.必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； </p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用方法</title>
      <link href="/2022/08/05/git/git/"/>
      <url>/2022/08/05/git/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><p align="center"><font color="#ff00ff">Git</font></p></h1><h3 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h3><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，<br>将文档的状态作为更新记录保存起来，也可以在任何时间点，<br>将更新记录恢复回来。</p><h3 id="1-2-查看Git的版本"><a href="#1-2-查看Git的版本" class="headerlink" title="1.2 查看Git的版本"></a>1.2 查看Git的版本</h3><pre><code>    git --verson</code></pre><h3 id="1-3-Git-基本工作流程"><a href="#1-3-Git-基本工作流程" class="headerlink" title="1.3 Git 基本工作流程"></a>1.3 Git 基本工作流程</h3><p><strong>工作区</strong> 就是你在电脑里能看到的目录。<br><strong>暂存区</strong> 英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件<br>        （.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。<br><strong>版本库</strong> 工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p><h3 id="1-4-Git-使用前配置"><a href="#1-4-Git-使用前配置" class="headerlink" title="1.4 Git 使用前配置"></a>1.4 Git 使用前配置</h3><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：git config –global user.name “提交人姓名” # (对当前系统用户有效)</li><li>配置提交人姓名：git config –global user.email  “提交人邮箱” # (对当前系统用户有效)<br>作用：识别开发人员，与登陆github的账户无关</li><li>查看git配置信息：git config –list</li></ol><p>注意</p><ol><li>如果要对配置信息进行修改，重复上述命令即可。</li><li>配置只需要执行一次。</li></ol><h3 id="1-5-常用提交步骤"><a href="#1-5-常用提交步骤" class="headerlink" title="1.5 常用提交步骤"></a>1.5 常用提交步骤</h3><ol><li><p>git init  # 初始化git仓库</p></li><li><p>git status  # 查看文件状态</p></li><li><p>git add 文件列表 # 追踪文件</p></li><li><p>git commit -m  “提交信息”  # 向仓库中提交代码(全部文件)<br>vs： git commit -m “提交信息”  文件  # 提交某个文件</p></li><li><p>git log # 显示所有提交记录<br>git log –pretty&#x3D;oneline   # 一行显示版本信息</p></li></ol><p>补充：</p><pre><code>    # 会显示所有关于这个id以及之前的修改记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac     # 加上-1参数表示我们只想看到一行记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac -1 </code></pre><p>而如果想要查看这条提交记录具体修改了什么内容，可以在命令中加入p参数，命令如下:</p><pre><code>    git log Ifa380b502a00b82bfc8d84c5ab5el5b8fbf7dac -1 -p</code></pre><ol start="6"><li><p>git reset  –hard 版本id  # 回退版本</p></li><li><p>git reflog   # 查看所有版本信息</p></li><li><p>git diff  # 表示未使用add命令时的修改</p></li></ol><p>这样可以查看到所有文件的更改内容，<br>如果你只想查看MainActivity.java这个文件的更改内容，可以使用如下命令：</p><pre><code>    git diff app/src/main/java/com/example/providertest/MainActivity.java</code></pre><p>vs：git log 表示最近的改变，git reflog可以看到所有的改变<br>如果文件未被跟踪,即没有使用git add这个命令时,文件为红色,如果使用这个命令,则文件变为绿色。<br>这里涉及到一个知识点，git的本地三个区域+远程仓库<br><img src="/2022/08/05/git/git/git%E4%B8%89%E5%8C%BA.png"></p><p><code>Workspace：</code>工作区，就是你平时存放项目代码的地方;</p><p><code>Index / Stage：</code>暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）;</p><p><code>Repository：</code>仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本;</p><p><code>Remote：</code>远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换;</p><ul><li>git add 是将代码从工作区加入到暂存区</li><li>git commit 是将代码从暂存区递交到本地仓库</li><li>git push则是由本地推送到远程仓库</li></ul><h3 id="1-6-远程仓库-Github"><a href="#1-6-远程仓库-Github" class="headerlink" title="1.6 远程仓库(Github)"></a>1.6 远程仓库(Github)</h3><p>新添加远程仓库</p><pre><code>    git remote add [shortname] [url]</code></pre><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p><pre><code>    git remote</code></pre><p>提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><pre><code>    git fetch</code></pre><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><p>git merg</p><p>删除远程仓库<br>删除远程仓库你可以使用命令：</p><pre><code>    git remote rm [别名]</code></pre><h3 id="1-7-创建分支"><a href="#1-7-创建分支" class="headerlink" title="1.7 创建分支"></a>1.7 创建分支</h3><p>多人协作完成一个项目的时候，不同的人需要完成不同的功能，这时候就需要创建分支。</p><pre><code># 列出所有本地分支git branch # 列出所有远程分支git branch -r # 新建一个分支，但依然停留在当前分支git branch [branchname] # 新建一个分支，并切换到该分支git checkout -b [branchname]# 切换到主分支$ git checkout master    # 合并指定分支到当前分支$ git merge [branchname] # 删除分支$ git branch -d [branchname] # 删除远程分支$ git push origin --delete [branchname]$ git branch -dr [remote/branch]</code></pre><h3 id="1-8-标签"><a href="#1-8-标签" class="headerlink" title="1.8 标签"></a>1.8 标签</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。<br>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”<br>“一串乱七八糟的数字不好找！”<br>如果换一个办法：<br>“请把上周一的那个版本打包发布，版本号是v1.2”<br>“好的，按照tag v1.2查找commit就行！”<br>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><ul><li>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</tagname></li><li>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></li><li>命令git tag可以查看所有标签。</li><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs&#x2F;tags&#x2F;<tagname>可以删除一个远程标签。</tagname></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码风格规定</title>
      <link href="/2022/07/30/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E5%AE%9A/"/>
      <url>/2022/07/30/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="代码风格规定"><a href="#代码风格规定" class="headerlink" title="代码风格规定"></a>代码风格规定</h2><hr><h4 id="单个标识符的命名风格有以下几种"><a href="#单个标识符的命名风格有以下几种" class="headerlink" title="单个标识符的命名风格有以下几种:"></a>单个标识符的命名风格有以下几种:</h4><p><strong>驼峰</strong>:每个单词第一个字母大写，其余小写: VariableName.<br>又可进一步细分为<strong>大驼峰</strong>(VariableName) 和<strong>小驼峰</strong>(variableName)</p><p><strong>内核</strong>:所有字母都小写，用下划线连接: variable name<br>C++的标准库源码都使用该命名方式</p><p><strong>匈牙利</strong>:以大驼峰为基础，给每个变量加上特定前缀表示其类型: iVariableName<br>匈牙利命名法存在可读性、可维护性方面的问题，已被现代编程实践所抛弃。</p><p><strong>全大写加下划线</strong>:所有字母都大写，用下划线连接: VARIABLE NAME<br>一般只用于常量和宏的命名.</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><hr><p>当今业界主流的排版风格:</p><ul><li>函数、类型、复合语句内部缩进一层</li><li>缩进使用空格而不是制表符</li><li>if&#x2F;for&#x2F;while&#x2F;switch和括号之间留一个空格</li><li>双目运算符两边留空格,逗号、分号后面留空格</li><li>圆括号内侧不空格</li><li>函数定义之间空行</li><li>注释符号(&#x2F;&#x2F;) 和内容之间留一个空格</li></ul><h2 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h2><hr><ul><li>程序必须为阅读它的人而编写，只是顺便用于机器执行。</li><li>短小的函数总是更简洁、容易阅读的。</li><li>功能单一的函数更容易被复用，简洁明了的代码更容易维护。</li><li>函数行数(建议不超过40行)</li><li>文件行数(建议不超过500行)</li><li>函数圈复杂度(建议不超过10)</li><li>函数内缩进嵌套层次(建议不超过4层)</li><li>架构度量(上帝类、模块耦合程度… .</li></ul>]]></content>
      
      
      <categories>
          
          <category> 华为可信课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda、资源管理与杂项</title>
      <link href="/2022/07/29/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/lambda%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%82%E9%A1%B9/"/>
      <url>/2022/07/29/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/lambda%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h4 id="1-Lambda捕获列表"><a href="#1-Lambda捕获列表" class="headerlink" title="1.Lambda捕获列表"></a>1.Lambda捕获列表</h4><pre><code class="cpp">   class MyClass &#123;          public:    void Foo()    &#123;        // 虽然看起来是按值捕获，但对        // data的修改会改变成员变量的值        auto Lambda = [=]()) &#123; data++; &#125;;        Lambda();     private:        int data = 0;    &#125;&#125;;</code></pre><p>正确做法：</p><pre><code class="cpp">    class MyClass &#123;    public:        void Foo()        &#123;            auto Lambda =[data = this-&gt; data]0 mutable &#123;                data+ +;            &#125;;            //...            Lambda0;            //....        &#125;    private:        int data = 0;&#125;;</code></pre><p>避免使用默认捕获模式。如果捕获this,需要明确写出。</p><h4 id="2-Lambda捕获局部变量"><a href="#2-Lambda捕获局部变量" class="headerlink" title="2.Lambda捕获局部变量"></a>2.Lambda捕获局部变量</h4><pre><code class="cpp">    例：        auto GetFunc()        &#123;            int thresh = 10;            // GetFunc返回后，局部变量被释放            return [&amp;thresh](int x)&#123; returnx &lt; thresh; &#125;;        &#125;        int main()        &#123;            vector&lt;int&gt; v&#123;0, 1, 3, 5&#125;;            // find if内部访问已被释放的变量导致未定义行为            auto it = find ifv.begin0. v.end0, GetFuncQ);            return 0;        &#125;</code></pre><p>当lambda对象会传递到函数外部的时候，避免按引用捕获局部变</p><h4 id="3-new的失败场景"><a href="#3-new的失败场景" class="headerlink" title="3.new的失败场景"></a>3.new的失败场景</h4><pre><code class="cpp">    auto p = new int[1024*1024];    if (p == nullptr) &#123;        //内存不足的处理    &#125;</code></pre><p>实际上，new操作符不会返回空指针，这是个错误的写法<br>正确写法1：</p><pre><code class="cpp">    try &#123;        auto p = new int[1024 * 1024];    &#125;     catch (std::bad alloc) &#123;        // .内存不足的处理    &#125;</code></pre><p>正确写法2：</p><pre><code class="cpp">    auto p = new(nothrow) int[1024 * 1024];    if (p == nullptr) &#123;        // .内存不足的处理    &#125;</code></pre><p>当需要处理new失败场景时，捕获std:bad _alloc异常或者使用new(nothrow)并判断空指针。</p><h4 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4.智能指针"></a>4.智能指针</h4><pre><code class="cpp">        void Func(shared. _ptr &lt;MyClass&gt; X,shared. ptr&lt;MyClass&gt; y)    &#123;        // ..    &#125;    int main()    &#123;        // 类型被重复写两次        unique_ ptr &lt;MyClass&gt; a(new MyClass);        // 在被智能指针接管前可能发生泄漏        Func(shared ptr&lt;MyClass&gt; (new MyClass),shared ptr&lt;MyClas&gt; (new MyClass));        return 0;    &#125;        </code></pre><p>正确做法：</p><pre><code class="cpp">    void Func(shared ptr &lt;MyClass&gt; x,shared_ ptr &lt;MyClass&gt; y)    &#123;        //....    &#125;    int main()    &#123;         auto a = make_ unique &lt;MyClass&gt;();        //....        Func(make_ shared &lt;MyClass&gt;(), make_ shared&lt;MyClass&gt;());        return 0;    &#125;</code></pre><p>使用std::make_ unique而不是new创建unique_ ptr<br>使用std::make shared而不是new创建shared_ptr</p><h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        for (auto it = numbers.begin(); it != numbers.end();++it) &#123;            if(*it == num) &#123;                // 删除该元素后，迭代器不再指向原有元素                // ++后迭代器指向的不是下一个元素                numbers.erase(it);            &#125;        &#125;    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>正确做法：</p><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        numbers.erase(std:remove(numbers. begin(), numbers.end(), num),numbers.end);    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>使用有效的迭代器，尤其注意在遍历的同时给容器增删元素时</p>]]></content>
      
      
      <categories>
          
          <category> 华为可信课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类与函数</title>
      <link href="/2022/07/29/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/"/>
      <url>/2022/07/29/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="类与函数"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold, int&amp; count)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return SUCCESS;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>函数的输出没有意义，恒为SUCCESS<br>可以将返回值更改为return count;</p><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return count;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>这样输入输出更简洁，设计函数时， 优先使用返回值而不是输出参数。</p><h4 id="2-避免使用宏"><a href="#2-避免使用宏" class="headerlink" title="2.避免使用宏"></a>2.避免使用宏</h4><pre><code class="cpp">    例：        #define SQUARE(a)a*a        #define MAX(a, b) ((a) &lt; (b))? (b) : (a)        int main()        &#123;            intx = SQUARE(1 + 2);// 宏扩展为1+2*1+2,结果为4            unsigned int a = 1;            int y = SQUARE(a++); //a自增多次            a=1;            int b=-1;            cout &lt;&lt; MAX(a, b); //不同参数类型无法检查会导致错误结果            return 0;        &#125;</code></pre><p>可以使用函数替代宏函数</p><pre><code class="cpp">    inline int Square(int a) &#123; returna* a; &#125;    inline int Max(int a, int b)    &#123;        returna&lt;b?b:a;    &#125;    int main()    &#123;        int x = Square(1 + 2);        unsigned int a= 1;        int y = Square(a++);        int b= -1;        cout &lt;&lt; Max(a, b);        return 0;    &#125;</code></pre><p>宏有类型检查、非预期副作用、运算优先级等方面的缺点,应当尽可能用函数、inline函数、 模板函数代替宏。<br>如果不得不使用宏， 则必须在定义宏时使用完备的括号。</p><h4 id="3-类和成员初始化"><a href="#3-类和成员初始化" class="headerlink" title="3.类和成员初始化"></a>3.类和成员初始化</h4><pre><code class="cpp">    class Message &#123;    public:                Message()&#123;&#125;//所有成员都没有初始化        Message(int id, int len) : msglD(id), msgLength(len) &#123;&#125;//msgBuffer指针没有初始化     private:        unsigned int msglD;        unsigned int msgLength;        unsigned char* msgBuffer;    &#125;    int main()    &#123;        Message a;//随机值        Message b(1, 2);//可能访问野指针        return 0;     &#125;</code></pre><p>禁止使用未经初始化的变量作为右值<br>类的所有构造函数都要保证所有成贸被正确初始化<br>优先使用初始化列表或者类内初始化来初始化成员</p><h4 id="4-虚函数重写规则"><a href="#4-虚函数重写规则" class="headerlink" title="4.虚函数重写规则"></a>4.虚函数重写规则</h4><pre><code class="cpp">    例：        class Base &#123;        public:            virtual void mf1() const;            virtual void mf2(int x);            virtual void mf3() &amp;;             void mf4() const;        &#125;;        class Derived : public Base &#123;        public:            virtual void mf1();//没有const            virtual void mf2(unsigned int x);//参数不匹配，重载            virtual void mf3() &amp;&amp;;//this是右值引用，基类是左值引用            void mf4() const;//mf4并没有用virtual修饰        &#125;;    以上函数都没有成功的重载，并且编译器不会发生告警</code></pre><p>C++ 11新增的override可以有效的避免这种编码错误<br>override必须是继承而来的虚函数，否则编译不过<br>在重写虚函数时使用override或者final关键字<br>final不允许子类继续重写虚函数</p><h4 id="5-禁止在构造函数析构函数中调用虚函数"><a href="#5-禁止在构造函数析构函数中调用虚函数" class="headerlink" title="5.禁止在构造函数析构函数中调用虚函数"></a>5.禁止在构造函数析构函数中调用虚函数</h4><pre><code class="cpp">    class Base &#123;    public:        //构造函数中调用虚函数，此时虚表还没有初始化完成        //不会调用到子类的虚函数        Base()&#123; Log(); &#125;;        //调用纯虚函数会产生未定义行为        virtual void Log() = 0;    &#125;;    class Sub : public Base &#123;    public:        virtualvoid Log()&#123;... &#125;;    &#125;</code></pre><p>禁止在构造函数和析构函数中调用虚函数,产生未定义行为或者达不到多态的目的</p><h4 id="6-内存操作函数"><a href="#6-内存操作函数" class="headerlink" title="6.内存操作函数"></a>6.内存操作函数</h4><pre><code class="cpp">    class Point &#123;    public:        virtual ~Point(); //Point对象包含虚表指针    private:        int X;        int y;    &#125;    int main()&#123;        Point a;        memset(&amp;a, 0, sizeof(a));//memset操作会破坏对象的虚表指针        return 0;    &#125;;</code></pre><p>禁止使用memcpy. memset等内存操作函数初始化非POD对象</p><h6 id="POD对象："><a href="#POD对象：" class="headerlink" title="POD对象："></a>POD对象：</h6><p>在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。<br>一般来说，POD对象应该满足如下特性。</p><p>对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，<br>如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，<br>再将其复制回对象，那么该对象的值与原始值一样。</p><p>对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，<br>如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。</p><p>简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，<br>只要其二进制内容在，就能还原出正确无误的POD对象。<br>对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。</p><h4 id="7-析构函数"><a href="#7-析构函数" class="headerlink" title="7.析构函数"></a>7.析构函数</h4><pre><code class="cpp">    class Base &#123;    public:        virtual const char* Name() const        &#123;            return &quot;Base&quot;;         &#125;    &#125;;    class Sub : public Base &#123;    public:        Sub() : numbers(new int[1000]) &#123;&#125;         ~Sub() &#123; delete[] numbers; &#125;        virtual const char* Name() const        &#123;        return &quot;Sub&quot;;        &#125;    private:        int* numbers;    &#125;;    int main(int argc, char* argsQ)    &#123;        Base* b = new Sub();        delete b;        return 0;     &#125;</code></pre><p>基类没有定义虚析构函数，所以main函数中并没有析构子类数据成员，造成内存泄露<br>基类的析构函数应当声明为虚函数</p><h4 id="8-虚函数的缺省参数"><a href="#8-虚函数的缺省参数" class="headerlink" title="8.虚函数的缺省参数"></a>8.虚函数的缺省参数</h4><pre><code class="cpp">    class Base&#123;    public:         virtual void Display(const std:string&amp; text = &quot;Base!&quot;)&#123;            std:.cout &lt;&lt; text &lt;&lt; std::endl;        &#125;        virtual ~ Base()&#123;&#125;    &#125;;    class Sub : public Base &#123;    public:        virtual void Display(const stl:string&amp; text = &quot;Sub!&quot;)        &#123;            std:cout &lt;&lt; text &lt;&lt; std:.endl;        &#125;        virtual ~Sub()&#123;&#125;     &#125;;    int main(        Base* base = new Sub();        Sub* sub = new Sub();        // ..        base-&gt; Display();         sub-&gt; Display();        delete base;         delete sub;        return 0;    &#125;;</code></pre><p>调用的函数是运行时决定的，但缺省参数是编译时决定的，导致使用”Base!” 参数调用Sub<br>类的Display<br>禁止子类的虚函数定义与基类不同的缺省参数</p><h4 id="9-void"><a href="#9-void" class="headerlink" title="9.void*"></a>9.void*</h4><pre><code class="cpp">    class BaseA &#123;    public:        virtual void FunA();         virtual ~BaseA();    &#125;;    class BaseB &#123;    public:        virtual void FunB();        virtual ~ BaseB();    &#125;;    class Sub : public BaseA, public BaseB &#123;    public:        virtual void FunA();         virtual void FunB();        virtual ~Sub();    &#125;;    int main()    &#123;        BaseA* pa = new Sub();        void* pv = pa;        BaseB* pb = (BaseB*)pv;        // ..        delete pb;        return 0;    &#125;;        //  正确做法    //  int main()    //  &#123;    //      BaseA* pa = new Sub();    //      BaseB* pb = dynamic cast&lt;BaseB*&gt; (pa);    //      return 0;    //  &#125;</code></pre><p>BaseA和BaseB的指针虽然指向同一个对象，但它们应该有不同的地址值。<br>如果使用void<em>转换，则使BaseA</em>和BaseB<em>为相同地址，产生未定义行为<br>void</em>丢失了对象的类型信息，失去了编译时的类型检查能力，应避免使用。</p>]]></content>
      
      
      <categories>
          
          <category> 华为可信课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表达式与变量</title>
      <link href="/2022/07/15/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
      <url>/2022/07/15/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="表达式与变量"><a href="#表达式与变量" class="headerlink" title="表达式与变量"></a>表达式与变量</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><h6 id="a-cpp"><a href="#a-cpp" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int g_GlobalX=1;</code></pre><h6 id="b-cpp"><a href="#b-cpp" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int g_GlobalX;    int g_GlobalY=1+g_GlobalX;    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>这里由于全局变量初始化顺序不确定导致结果不唯一。<br>如果先初始化g_GlobalX那么g_GlobalY为2，否则为1。<br>那么该如何解决这个问题呢，下面有一种解决办法：</p><h6 id="a-cpp-1"><a href="#a-cpp-1" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int GetX()&#123;        static int g_GlobalX=1;        return g_GlobalX;    &#125;</code></pre><h6 id="b-cpp-1"><a href="#b-cpp-1" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int GetX();    int g_GlobalY=1+GetX();    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>函数中静态变量一定会在第一次调用函数时初始化<br>这也就解决了全局变量初始化顺序的问题</p><h4 id="2-函数名是函数的地址"><a href="#2-函数名是函数的地址" class="headerlink" title="2.函数名是函数的地址"></a>2.函数名是函数的地址</h4><pre><code class="cpp">    例：        bool isFriday()&#123;            return true;        &#125;        int main()&#123;            if(isFriday)&#123;                cout&lt;&lt;&quot;yes&quot;;            &#125;            else&#123;                cout&lt;&lt;&quot;no&quot;;            &#125;            return 0;        &#125;</code></pre><p>这个的结果恒为真，因为调用函数没有加上（），函数名是地址恒不为0;</p><h4 id="3-switch每个case都要有break"><a href="#3-switch每个case都要有break" class="headerlink" title="3.switch每个case都要有break"></a>3.switch每个case都要有break</h4><pre><code class="cpp">    通常情况下case之后都要有break    但是如果需要滑入下一个分支，必须明确注释或者使用c++17的[[fallthrough]]</code></pre><h4 id="4-和–"><a href="#4-和–" class="headerlink" title="4.++和–"></a>4.++和–</h4><pre><code class="cpp">    例：        int i=0;        int x=0;        int b[10];        x=b[i]+i++;        func(i++,i);    </code></pre><p>同一个表达式中的i，使用的是自增之前的值还是之后的无法确定，存在隐患<br>含有变量自增或者自减的表达式中禁止再次使用该变量.</p><h4 id="5-避免过大的栈上变量"><a href="#5-避免过大的栈上变量" class="headerlink" title="5.避免过大的栈上变量"></a>5.避免过大的栈上变量</h4><pre><code class="cpp">    class Vector&#123;        public :        int value[10000];    &#125;    Vector Decrement(Vector input)&#123;        Vector output;        for(int i=0;i&lt;10000;i++)&#123;            output.value[i]=input.value[i]+100;        &#125;        return output;    &#125;</code></pre><p>当局部变量大小超过1k时就需要审视其合理性<br>较大的函数类型作为函数参数时，应使用引用或者const引用</p><h4 id="6-使用引用代替指针"><a href="#6-使用引用代替指针" class="headerlink" title="6.使用引用代替指针"></a>6.使用引用代替指针</h4><pre><code class="cpp">    void Caculate(int input, char* op, int* output)    &#123;        if (op == nullptr) &#123;            *output = input;        &#125;         else if (strcmp(op, &quot;add&quot;) == 0) &#123;            *output = input + 10;        &#125;         else if (strcmp(op, &quot;subtract&quot;) == 0) &#123;            *output = input - 10;        &#125;    &#125;</code></pre><p>单个对象不允许为空，建议用引用int&amp;<br>但如果传入的是一串对象(数组)，则应当用指针或者封装的类型<br>引用不为空，而且指向的对象不会变化。应当优先使用引用取代指针。</p><h4 id="7-不修改变量、函数采用const修饰"><a href="#7-不修改变量、函数采用const修饰" class="headerlink" title="7.不修改变量、函数采用const修饰"></a>7.不修改变量、函数采用const修饰</h4><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>这里两个成员函数都不修改形参或者是this，所以应采用const修饰</p><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>定义接口时，将不修改的类型声明为const,可以让使用者知晓哪些对象不会被修改。<br> 编码时如不惧将对象修改了，，能够在编译时就发现问题而不是等到运行时debug.</p><h4 id="8-数组作为参数"><a href="#8-数组作为参数" class="headerlink" title="8.数组作为参数"></a>8.数组作为参数</h4><pre><code class="cpp">    int CountLength(char str[])//int CountLength(char str[10])    &#123;        for (inti = 0;i &lt; sizeof(str) / sizeof(char); ++i) &#123;            if(str[] == &#39;\0&#39;) &#123;            return i;            &#125;        &#125;        return sizeof(str);    &#125;</code></pre><p>这里str是一个指针，sizeof(str)返回的是指针的大小，而不是数组的大小<br>不要将指针作为sizeof的参数来获取指向内容的长度。<br>不要对函数的数组参数使用sizeof</p>]]></content>
      
      
      <categories>
          
          <category> 华为可信课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全编码与未定义行为</title>
      <link href="/2022/07/15/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E4%B8%8E%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/"/>
      <url>/2022/07/15/%E5%8D%8E%E4%B8%BA%E5%8F%AF%E4%BF%A1/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E4%B8%8E%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><h4 id="1-不要使用越界的指针或者数组下标"><a href="#1-不要使用越界的指针或者数组下标" class="headerlink" title="1.不要使用越界的指针或者数组下标"></a>1.不要使用越界的指针或者数组下标</h4><pre><code class="cpp">    例：        int a[4];        for(int i=0;i&lt;=4;i++)&#123;            a[i]=i;        &#125;    缓冲区溢出在CWE漏洞库中排名第二  </code></pre><h4 id="2-避免任何可能产生未定义行为的代码"><a href="#2-避免任何可能产生未定义行为的代码" class="headerlink" title="2.避免任何可能产生未定义行为的代码"></a>2.避免任何可能产生未定义行为的代码</h4><pre><code class="cpp">    例：        char *Getstring(bool choice)&#123;            char str[6];            if(choice)&#123;                strcpy(str,&quot;true&quot;);            &#125;            else&#123;                strcpy(str,&quot;false&quot;);            &#125;            return str;        &#125;    因为局部变量保存在栈中，随着函数返回，栈内内容可能会被释放或者被覆盖。</code></pre><h4 id="3-确保整数运算不溢出"><a href="#3-确保整数运算不溢出" class="headerlink" title="3.确保整数运算不溢出"></a>3.确保整数运算不溢出</h4><pre><code class="cpp">    例：        int32_t Average(int32_t x,int32_t y)&#123;            return (x+y)/2;        &#125;    可能发生int溢出，超出int表示范围，导致结果异常        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int64_t&gt; (x+y)/2;        &#125;    这是一个错误的更正,已经发生溢出才进行类型转换。        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int32_t&gt;((static_cast&lt;int64_t&gt;(x)+y)/2);        &#125;    运算时编译器会自动将y进行类型转换为int64_t</code></pre><h4 id="4-char用来表示数值时明确有符号还是无符号"><a href="#4-char用来表示数值时明确有符号还是无符号" class="headerlink" title="4.char用来表示数值时明确有符号还是无符号"></a>4.char用来表示数值时明确有符号还是无符号</h4><pre><code class="cpp">    例：        char a=-100;        unsigned int b=a;        标准并没有规定char类型是否是有符号数，可能导致不同编译器产生不同结果</code></pre><h4 id="5-避免混用有符号和无符号数"><a href="#5-避免混用有符号和无符号数" class="headerlink" title="5.避免混用有符号和无符号数"></a>5.避免混用有符号和无符号数</h4><pre><code class="cpp">    例：        int  a=-1;        unsigned b=1;        cout&lt;&lt;(b&gt;a);    结果是false，因为编译器将有符号转换为了无符号数，所以-1是无符号int最大的正数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为可信课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>define、const、typedef、inline</title>
      <link href="/2022/07/13/cpp/define,const/"/>
      <url>/2022/07/13/cpp/define,const/</url>
      
        <content type="html"><![CDATA[<h2 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h2><h3 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h3><p><strong>const</strong> 定义的常量是变量带类型，⽽  定义的只是个常数不带类型；<br><strong>#define</strong>只在预处理阶段起作⽤，简单的⽂本替换，⽽ <strong>const</strong> 在编译、<br>链接过程中起作⽤；<br><strong>#define</strong>   只是简单的字符串替换没有类型检查。⽽<strong>const</strong>是有数据类型的，<br>是要进⾏判断的，可以避免⼀些低级错误；<br><strong>#define</strong> 预处理后，占⽤代码段空间，<strong>const</strong> 占⽤数据段空间；<br><strong>const</strong>m 不能重定义，⽽**#define** 可以通过#undef取消某个符号<br>的定义，进⾏重定义；<br><strong>define</strong>   独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。</p><h3 id="define-和别名-typedef-的区别"><a href="#define-和别名-typedef-的区别" class="headerlink" title="define  和别名 typedef 的区别"></a><strong>define</strong>  和别名 typedef 的区别</h3><h5 id="执⾏时间不同"><a href="#执⾏时间不同" class="headerlink" title="执⾏时间不同"></a>执⾏时间不同</h5><p><strong>typedef</strong> 在编译阶段有效，<strong>typedef</strong> 有类型检查的功能；**#define**是宏定义，发⽣在预处理阶段，不进⾏类型检查；</p><h5 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h5><p><strong>typedef</strong> ⽤来定义类型的别名，定义与平台⽆关的数据类型，<br>与   <strong>struct</strong>   的结合使⽤等。<br><strong>#define</strong>   不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p><h5 id="作⽤域不同"><a href="#作⽤域不同" class="headerlink" title="作⽤域不同"></a>作⽤域不同</h5><p><strong>#define</strong> 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。<br>⽽ typedef 有⾃⼰的作⽤域。</p><h3 id="define-与-inline-的区别"><a href="#define-与-inline-的区别" class="headerlink" title="define 与 inline 的区别"></a>define 与 inline 的区别</h3><p> #define是关键字，inline是函数；<br>宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；<br>inline 函数有类型检查，相⽐宏定义⽐较安全；</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>非零段划分</title>
      <link href="/2022/06/06/%E9%A2%98%E8%A7%A3/csp/2021_09_2/"/>
      <url>/2022/06/06/%E9%A2%98%E8%A7%A3/csp/2021_09_2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,…,Aj 是一个非零段     当且仅当以下条件同时满足：    ·1≤i≤j≤n；    ·对于任意的整数 k，若 i≤k≤j，则 Ak＞0；    ·i=1 或 Ai-1=0；    ·j=n 或 Aj+1=0。    下面展示了几个简单的例子：    ·A = [3,1,2,0,0,2,0,4,5,0,2]中的4个非零段依次为[3, 1, 2],[2],[4, 5]和[2]；    ·A = [2, 3, 1, 4, 5] 仅有 1 个非零段；    ·A = [0, 0, 0] 则不含非零段（即非零段个数为 0）。    现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。    试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，    可取 p = 1，即不对 A 做任何修改。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入格式    从标准输入读入数据。    输入的第一行包含一个正整数 n。    输入的第二行包含 n 个用空格分隔的自然数 A1, A2, … , An。    输出格式    输出到标准输出。    仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组cnt[]，cnt[i] 表示海平面下降到i时，岛屿数量的变化。差分法是最简洁的解题程序。数组元素d[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中为后缀和）中找出最大值就是所要的结果。程序代码中，STL算法函数unique()用来去除相邻重复的元素。语句“a[0] = a[n + 1] = 0;”用来设置边界值，起辅助计算作用，可以简化程序代码。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* CCF202109-2 非零段划分 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000;const int M = 10000;int a[N + 2], d[M + 1];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    a[0] = a[n + 1] = 0;    n = unique(a, a + n + 2) - a - 1;    memset(d, 0, sizeof d);    for (int i = 1; i &lt; n; i++)        if (a[i - 1] &lt; a[i] &amp;&amp; a[i] &gt; a[i + 1]) d[a[i]]++;        else if (a[i - 1] &gt; a[i] &amp;&amp; a[i] &lt;a[i + 1]) d[a[i]]--;    int ans = 0, sum = 0;   // 差分前缀和即为答案    for (int i = M; i &gt;= 1; i--)        sum += d[i], ans = max(ans, sum);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;&#125;</code></pre><p>来源：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">https://blog.csdn.net/tigerisland45/article/details/120598581</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/2022/03/26/%E9%A2%98%E8%A7%A3/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A82/"/>
      <url>/2022/03/26/%E9%A2%98%E8%A7%A3/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A82/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。在每一天，你可能会决定购买      或出售股票。你在任何时候最多只能持有一股股票。你也可以购买它，然后在同一天出售。返回你能获      得的最大利润。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: prices = [7,1,5,3,6,4]    输出: 7    解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5的时候卖出,       这笔交易所能获得利润 = 5-1 = 4 。    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6） 的时候卖出,       这笔交易所能获得利润 = 6-3 = 3 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，动态规划"><a href="#一，动态规划" class="headerlink" title="一，动态规划"></a>一，动态规划</h4><pre><code>    考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。    定义状态 dp[i][0] 表示第i天交易完后手里没有股票的最大利润，dp[i][1] 表示第i天交易完后手里      持有一支股票的最大利润（i 从 0 开始）。    考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有      股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将      其卖出，并获得prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])    再来考虑dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即      dp[i−1][1]，或者前一天结束时还没有股票，即dp[i−1][0]，这时候我们要将其买入，并减少prices[i]      的收益。可以列出如下的转移方程：                dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125;    对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 0dp[0][0]=0，dp[0][1]=−prices[0]。    因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收      益，因此这时候 dp[n−1][0]的收益必然是大于dp[n−1][1] 的，最后的答案即为dp[n−1][0]。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n = prices.size();        int dp[n][2];        dp[0][0] = 0, dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; ++i) &#123;            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);        &#125;        return dp[n - 1][0];    &#125;&#125;;</code></pre><h4 id="二，（贪心算法）本弱鸡的解法"><a href="#二，（贪心算法）本弱鸡的解法" class="headerlink" title="二，（贪心算法）本弱鸡的解法"></a>二，（贪心算法）本弱鸡的解法</h4><pre><code>    因为可以不限制购买，所以只要是顺序对就把他加入。同时要注意的是，连续的顺序对，比如&#123;1，2，3，4&#125;，      实际购买情况是第一天买入第四天卖出，做题顺序不等于实际购买顺序。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int sum=0;        for(int i=1;i&lt;prices.size();i++)&#123;            if(prices[i]&gt;prices[i-1])sum+=prices[i]-prices[i-1];        &#125;        return sum;    &#125;    &#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/2022/03/26/%E9%A2%98%E8%A7%A3/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A81/"/>
      <url>/2022/03/26/%E9%A2%98%E8%A7%A3/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A81/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。    设计一个算法来计算你所能获取的最大利润。    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入：[7,1,5,3,6,4]    输出：5    解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，暴力法"><a href="#一，暴力法" class="headerlink" title="一，暴力法"></a>一，暴力法</h4><pre><code>—略—</code></pre><h4 id="二，一次遍历"><a href="#二，一次遍历" class="headerlink" title="二，一次遍历"></a>二，一次遍历</h4><pre><code>    如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，      我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么，      我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。因此，我们只需要遍历价格数组      一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖      出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                //不能超过n的值，并不是所有节点都有十个子节点                step += min((long long)n + 1, last) - first;                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><h4 id="三，本弱鸡的解法"><a href="#三，本弱鸡的解法" class="headerlink" title="三，本弱鸡的解法"></a>三，本弱鸡的解法</h4><pre><code>    最近算法课刚刚学习了最大子数组和，所以本弱鸡依葫芦画瓢，从最后一项向前遍历，每一项都等于      减去前一项以后的值。这样就将某两点的最大差值问题变成了该数组之间的最大子数组和问题。注意，      计算子数组和时忽略掉第零项。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        for(int i=prices.size()-1;i&gt;0;i--)&#123;            prices[i]=prices[i]-prices[i-1];        &#125;        int sum=0,maxProfit=0;        for(int i=1;i&lt;prices.size();i++)&#123;            sum+=prices[i];            if(sum&gt;maxProfit)maxProfit=sum;            if(sum&lt;0)sum=0;        &#125;        return maxProfit;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序的第k大数字</title>
      <link href="/2022/03/23/%E9%A2%98%E8%A7%A3/%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACk%E5%A4%A7%E6%95%B0%E5%AD%97/"/>
      <url>/2022/03/23/%E9%A2%98%E8%A7%A3/%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACk%E5%A4%A7%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。  </code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: n = 13, k = 2    输出: 10    解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    这里的字典树其实就是一个十叉树，我们只需要构建一个十叉树，然后进行先序遍历就好了。但是      仔细想一下，n的范围一旦很大，对于空间的开销是难以想象的。所以我们要根据十叉树的思想，来      模拟遍历。根据十叉树的性质，每一层中的个数十上一层树的十倍，比如1000~9999就是100~999的      十倍，那么以100~199为前缀的第四层结点个数等于第三层节点个数。也就是说如果从某一棵树第n层      的节点总和大于k的话，那么第k大的元数必定在n-1层。根据这个性质，我们从1为根节点的子树开始      遍历，如果第一层中的结点数大于k，那么第k大的数在第一棵子树上，否则在剩下子树中。遍历下去，      直到找到结果。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                step += min((long long)n + 1, last) - first;//不能超过n的值，并不是所有节点都有十个子节点                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><p>来源：力扣（LeetCode）<br>    链接：<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order</a><br>    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Easy Strings Merging</title>
      <link href="/2022/03/03/%E9%A2%98%E8%A7%A3/EasyStrings/"/>
      <url>/2022/03/03/%E9%A2%98%E8%A7%A3/EasyStrings/</url>
      
        <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><pre><code>给定 nn 个 01 串，每次你可以从某个串开头移除一个字符并把它加入一个新串 SS 的末尾。最大化 SS 中相邻两个字符相同的对数。(P8001)</code></pre><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><pre><code>第一行一个正整数 nn 表示串的个数。接下来 nn 行，每行一个 01 字符串。</code></pre><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><pre><code>一行一个整数表示答案。</code></pre><h5 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h5><pre><code>    输入 ：                                  输出：9    3    0011    0110    1100</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    暴力模拟！！！！！！！！！！用的c语言，没有用String类，只能拿到75分。暂未解决空间溢出问题。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #pragma warning(disable:4996)    #include&lt;stdio.h&gt;    #include&lt;string.h&gt;    char a[10001][10001];    int b[1001];    int c[1001];    int check[1001];    int main() &#123;        int sum1 = 0, sum2 = 0,flag=0;        int n, i, temp;        scanf(&quot;%d&quot;, &amp;n);        temp = n;        for (i = 0; i &lt; n; i++) &#123;            scanf(&quot;%s&quot;, a[i]);            c[i] = strlen(a[i]);        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (!check[i]&amp;&amp;b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum1--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum1--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        temp = n;        for (i = 0; i &lt; n; i++) &#123;            b[i] = 0;            check[i] = 0;        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum2--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum2--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        if (sum1 &gt; sum2)printf(&quot;%d&quot;, sum1);        else printf(&quot;%d&quot;, sum2);        return 0;    &#125;                                                                                 </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><pre><code>    暂时无</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>779 第k个语法符号</title>
      <link href="/2022/03/03/%E9%A2%98%E8%A7%A3/%E7%AC%ACk%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2022/03/03/%E9%A2%98%E8%A7%A3/%E7%AC%ACk%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><pre><code>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）例子:输入: N = 1, K = 1输出: 0输入: N = 2, K = 1输出: 0输入: N = 2, K = 2输出: 1输入: N = 4, K = 5输出: 1解释:第一行: 0第二行: 01第三行: 0110第四行: 01101001来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/k-th-symbol-in-grammar</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    可以将第n个数字串平均分两部分，前半部分和第n-1数字串相同，后半部分则是第n-1数字串按位取反    那么我们可以判断k的位置，从而不断缩小数字串的长度，最终到第一个字符串；</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    int kthGrammar(int n, int k)&#123;    int sign=1;    while(1)&#123;        if(k&lt;=(1&lt;&lt;(n-1)))&#123;            n--;        &#125;        if(n&amp;&amp;k&gt;(1&lt;&lt;(n-1)))&#123;            k=k-(1&lt;&lt;(n-1));            sign*=-1;        &#125;        if(k==1)&#123;            return sign&gt;0?0:1;        &#125;    &#125;&#125;                                                                                      </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><p>经过观察发现这道题的解其实就是对K-1进行了一个奇偶校验，因此连N这个参数都用不着，O(1)时间空间复杂度求解</p><pre><code>    int kthGrammar(int N, unsigned int K) &#123;        K -= 1;        K ^= K &gt;&gt; 1;        K ^= K &gt;&gt; 2;        K = (K &amp; 0x11111111U) * 0x11111111U;        return (K &gt;&gt; 28) &amp; 1;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><pre><code class="bash">$ 并查集是一种树型的数据结构。</code></pre><h2 id="并查集的用途"><a href="#并查集的用途" class="headerlink" title="并查集的用途"></a>并查集的用途</h2><ol><li>处理不相交的集合的合并、查询问题。</li><li>检查一个图上面是否有一个环。<br>简单说就是先把每一个顶点放在一个独立的集合（树）里，如果顶点之间是邻接的那么就把他们合并为一个<br>集合（树）。一个集合（树）里有一个根结点，如果有两个顶点他们的根结点相同说明他们处于同一个集合<br>（树），那这两个结点邻接必定形成一个环（为什么？ 因n个顶点和n-1条边形成的连通图如果再加一条边<br>一定出现环）。如果他们的根结点不同，就把这两个集合合成一个集合。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>for(int i=1;i&lt;=n;i++)&#123;    father[i]=i;&#125;</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>非递归写法</strong></p><pre><code>int findFather(int x)&#123;    while(x!=father[x])&#123;        x=father[x];    &#125;    return x;&#125;</code></pre><p><strong>递归写法</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    return findfather(father[x]);&#125;</code></pre><p><strong>合并</strong></p><pre><code>void Union(int a,int b)&#123;    int faA =findFather(a);    int faB=findFather(b);    if(faA==faB)return ;    else&#123;        father[faA]=faB;    &#125;&#125;</code></pre><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>非递归写法：</strong></p><pre><code>int findFather(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        father[a]=x;        a=father[z];    &#125;    return x;&#125;</code></pre><p><strong>递归写法：</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    else&#123;        int F=findFather(father[x]);        father[x]=F;        return F;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/01/hello-world/"/>
      <url>/2022/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
