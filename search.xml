<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebAssembly与Go实践</title>
      <link href="/p/f113fd4.html"/>
      <url>/p/f113fd4.html</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="..\..\WebAssembly与Go实践.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/p/122fc4b2.html"/>
      <url>/p/122fc4b2.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><ul><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li>一个设计良好的类，应该是兼顾信息和行为并且高内聚。而不同的类之间，应该做到松耦合</li><li>类之间的关系：<ul><li>泛化关系</li><li>实现关系</li><li>依赖关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li></ul></li></ul><p>对于<code>继承</code>、<code>实现</code>这两种关系比较简单，它们体现的是一种类与类、或者类与接口之间的纵向关系。 其他的四种关系则体现的是类与类、或者类与接口之间的引用&#x2F;横向关系。这四种关系所表现的强弱程度来看，从强到弱依次为：组合&gt;聚合&gt;关联&gt;依赖。<br><a href="https://imgse.com/i/pCpc14x"><img src="https://s1.ax1x.com/2023/06/03/pCpc14x.png" alt="类图关系"></a></p><ul><li><p>泛化（继承），描述一种特殊与一般的关系</p><ul><li>实线空心三角箭头</li><li>代码体现：子类继承父类。</li><li>例如，人类与科学家，科学家是人类的一种。</li><li>如果A类继承了B类，那么A和B就存在泛化关系。</li></ul></li><li><p>实现，描述一种具有关系</p><ul><li>虚线空心三角箭头</li><li>代码体现：实现接口或继承某个抽象类。</li><li>例如，飞翔之于鸟，鸟具有飞翔能力。</li><li>实现关系就是A类实现B接口</li></ul></li><li><p>组合，描述一种整体和部分的关系，强调部分不可脱离整体而存在</p><ul><li>实线实心菱形箭头</li><li>代码体现：成员变量。</li><li>例如，头与眼睛，眼睛不可与头分割。</li></ul></li><li><p>聚合，描述一种整体和部分的关系，强调部分可脱离整体而存在</p><ul><li>实线空心菱形箭头</li><li>代码体现：成员变量    </li><li>例如，学校和老师，老师可脱离学校而存在。</li><li>整体与部分可以分开。聚合关系是关联关系的特例，所以它具有关联的导航性和多重性。</li></ul></li><li><p>关联，描述一种比较固定的关系</p><ul><li>实线箭头</li><li>代码体现：成员变量。</li><li>例如，人与住址。</li><li>类B以类属性的形式出现在关联类A中。</li></ul></li><li><p>依赖，描述一种临时关系</p><ul><li>虚线箭头</li><li>代码体现：局部变量、方法的参数和静态方法的调用。</li><li>例如，人与交通工具，人依赖交通工具。</li><li>只要在类中用到了对方，那么它们之间就存在依赖关系。如果没有对方，则编译不能通过。</li><li>A类中用到了B类</li><li>B类是A类的成员属性</li><li>B类作为A类的方法的返回类型</li><li>B类是A类方法中的参数类型</li><li>A类方法中用到B类</li></ul></li></ul><p>在 A 类中引用 B 类的一个引用 b，当 A 类消亡时，b 这个引用所指对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫组合，反之 b 所指的对象还会有另外的引用它，这种情况叫聚合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libevent可执行文件生成</title>
      <link href="/p/789273fd.html"/>
      <url>/p/789273fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="libevent可执行文件生成"><a href="#libevent可执行文件生成" class="headerlink" title="libevent可执行文件生成"></a>libevent可执行文件生成</h1><p>本来之前编译的32位已经足够用了，奈何后面程序需要用到protobuf，protobuf是64位编译的，联合使用几十行代码就能报了几百条错误，吓人！搞了好久终于把依赖的库文件重新编译完了。</p><h2 id="编译环境："><a href="#编译环境：" class="headerlink" title="编译环境："></a>编译环境：</h2><ul><li>win10 64位</li><li>vs2019 profession</li><li>libevent 2.1.11</li><li>libevent解压的文件夹目录为：D:\test\libevent-2.1.11-stable.tar\libevent-2.1.11-stable</li></ul><p>cmake之类的之前安装的，具体需要哪些也已经遗忘了，如果提示下载按需下载即可。（抱歉，我是菜狗）<br>其中libevent源代码在<a href="https://libevent.org/%E4%B8%8B%E8%BD%BD">https://libevent.org/下载</a><br><a href="https://imgse.com/i/p9TIbOP"><img src="https://s1.ax1x.com/2023/05/23/p9TIbOP.png" alt="libevent源代码"></a></p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>修改 libevent 目录下的 Makefile.nmake 文件：<br>找到 CFLAGS&#x3D;$(CFLAGS) &#x2F;Ox &#x2F;W3 &#x2F;wd4996 &#x2F;nologo，在后面加上 &#x2F;Zi<br>即改成 CFLAGS&#x3D;$(CFLAGS) &#x2F;Ox &#x2F;W3 &#x2F;wd4996 &#x2F;nologo &#x2F;Zi<br><a href="https://imgse.com/i/p9TIvFg"><img src="https://s1.ax1x.com/2023/05/23/p9TIvFg.png" alt="p9TIvFg.png"></a></p><p>因为我们要编译64位的lib库文件，所以还修改 libevent 目录下的 Makefile.nmake 文件<br>将 LIBFLAGS&#x3D;&#x2F;nologo<br>修改为：LIBFLAGS&#x3D;&#x2F;nologo &#x2F;MACHINE:X64<br><a href="https://imgse.com/i/p9ToFmV"><img src="https://s1.ax1x.com/2023/05/23/p9ToFmV.png" alt="p9ToFmV.png"></a></p><p>打开 libevent 目录下的 mm-internal.h 添加 #include &lt;stdint.h&gt;<br>注意：一定要添加到#ifndef MM_INTERNAL_H_INCLUDED_之前，否则会报错，一堆warning<br><a href="https://imgse.com/i/p9To4BV"><img src="https://s1.ax1x.com/2023/05/23/p9To4BV.png" alt="p9To4BV.png"></a></p><p>找到vs下的命令提示符 x64 Native Tools Command Prompt for VS 2019<br><a href="https://imgse.com/i/p9Tojnx"><img src="https://s1.ax1x.com/2023/05/23/p9Tojnx.png" alt="p9Tojnx.png"></a></p><p>使用控制台命令进入到 libevent 目录下：略<br>执行命令 nmake &#x2F;f Makefile.nmake，（成功的时候只有几行输出，如果有很多行输出，比如变量转换可能导致数据丢失，就说明编译失败了，就算生成了三个 lib 文件，也是失败的）<br><a href="https://imgse.com/i/pCp48wF"><img src="https://s1.ax1x.com/2023/06/03/pCp48wF.png" alt="成功输出"></a><br>成功后，在 libevent 目录下会生成三个文件</p><ul><li>libevent.lib</li><li>libevent_core.lib</li><li>libevent_extras.lib</li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/p/330a6169.html"/>
      <url>/p/330a6169.html</url>
      
        <content type="html"><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="避免默认的捕获模式"><a href="#避免默认的捕获模式" class="headerlink" title="避免默认的捕获模式"></a>避免默认的捕获模式</h2><p>在c++11中，有两种默认的捕获模式：值捕获和引用捕获。默认的引用捕获可能会造成悬挂引用现象。<br>按引用捕获会导致闭包包含涉及到局部变量的引用，或者涉及到定义lambda式子的作用域内形参的引用。</p><pre><code>using FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters;void addDivisorFilter() &#123;    auto calc1 = computeSomeValue1();    auto calc2 = computeSomeValue2();        auto divisor = computeDivisor(calc1, calc2);            filters.emplace_back(                    // 危险，对divisor的指涉可能空悬！        [&amp;](int value)&#123; return value % divisor == 0;&#125;    );&#125;</code></pre><p>上述代码随时会出错，lambda式指涉到局部变量diviisor的引用，但该变量在addDivisorFilter返回时即不存在。<br>就算不这样做，换作以显示方式按引用捕获divisor，问题依旧。</p><pre><code>filters.emplace_back(                    // 危险，对divisor的指涉可能空悬！    [&amp;divisor](int value)&#123; return value % divisor == 0;&#125;</code></pre><p>解决这个问题的一个办法就是使用按值捕获的方式：</p><pre><code>filters.emplace_back(                        [=](int value)&#123; return value % divisor == 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特种成员函数的生成机制</title>
      <link href="/p/7296bf5f.html"/>
      <url>/p/7296bf5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="特种成员函数的生成机制"><a href="#特种成员函数的生成机制" class="headerlink" title="特种成员函数的生成机制"></a>特种成员函数的生成机制</h1><p>特种成员函数包括默认拷贝函数、析构函数、复制构造函数、复制赋值运算符、移动构造函数以及移动赋值运算符。<br>这些特种成员函数在特定场合，编译器都可以自动为其生成，且访问权限都是public的，inline类型的。</p><h2 id="特种成员函数的生成规则"><a href="#特种成员函数的生成规则" class="headerlink" title="特种成员函数的生成规则"></a>特种成员函数的生成规则</h2><p>一个类没有声明任何构造函数时，编译器才会自动生成默认构造函数。<br>两种复制（复制构造函数与复制赋值运算符）操作是彼此独立的：声明了其中一个，并不会阻止编译器生成另外一个。<br>两种移动（移动构造函数与移动赋值运算符）操作是彼此不独立的：声明了其中一个，会阻止编译器生成另外一个。<br>如果你声明了复制构造函数，复制赋值运算符，或者析构函数中的任何一个，你就得同时声明所有的这个三个；<br>移动操作(移动拷贝构造函数和移动赋值运算符)仅当类中未包含用户显示声明的复制操作、移动操作和析构函数时编译器才会自动生成。<br>显式声明的析构函数会删除复制操作，<br>显式声明的移动操作也会删除复制操作</p><p>基类特种成员函数对派生类特种成员函数生成的影响</p><p>基类未定义(删除)的复制构造函数会阻止派生类默认复制构造函数的生成<br>基类未定义(删除)的复制赋值运算符会阻止派生类复制赋值运算符的生成<br>当基类的析构函数是虚函数时，编译器为子类生成的默认析构函数也才会是虚函数，且析构函数默认为noexcept的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++11对于特殊成员函数处理的规则如下：</p><p>默认构造函数：仅当类不存在用户声明的构造函数时才自动生成。<br>析构函数：基本上和C++98相同；稍微不同的是现在析构函数默认noexcept，和C++98一样，仅当基类析构为虚函数，派生类的析构函数才是虚的。<br>拷贝构造函数：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造时才生成。如果该类声明了移动操作，则复制构造函数将被删除。当用户声明了拷贝赋值运算符或析构函数时，拷贝构造函数不再自动生成。<br>拷贝赋值运算符：和C++98运行时行为一样：逐成员拷贝赋值非static数据。仅当类没有用户定义的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符就是delete。当用户声明了拷贝构造或者析构函数，拷贝赋值运算符不再自动生成。<br>移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动。仅当类中不包含用户声明的拷贝操作，移动操作和析构函数时才生成。<br>请注意，没有成员函数模板阻止编译器生成特殊成员函数的规则。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/p/15bc60d.html"/>
      <url>/p/15bc60d.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h2><p>每次选取集合中距离最小的点进行拓展，贪心算法；<br>采用邻接矩阵：</p><pre><code>#include &lt;iostream&gt;#include&lt;fstream&gt;const int INF 0x7fffffff;const int N = 10010;using namespace std;int map[N][N], dis[N], mark[N]int main()&#123;    int i, j, n, m, t1, t2, t3, cur, v, min;    cin &gt;&gt; n &gt;&gt; m;    for (i = 1; i &lt;= n; i++) &#123;        for (j = 1; j &lt;= n; j++) &#123;            if (i == j) map[i][j] = 0;            else map[i][j] = INF;        &#125;    &#125;    for (i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;        map[t1][t2] = t3;    &#125;    //初始化dis数组,代表源点到其他顶点的初始路程    for (i = 1; i &lt;= n; i++) &#123;        dis[i] = map[1][i];        mark[i] = 0;    &#125;    //从源点开始    mark[1] = 1;    //Dijkstra算法核心代码--贪心策略    for (i = 1; i &lt;= n - 1; i++) &#123; // 总共需要更新n-1次，对除去源点以外的n-1个点进行松弛        //寻找距离源点最近的顶点        min = INF;        for (j = 1; j &lt;= n; j++) &#123;            if (mark[j] == 0 &amp;&amp; dis[j] &lt; min) &#123;                min = dis[j];                cur = j;            &#125;        &#125;        //cur代表距离源点最近的        mark[cur] = 1;        for (v = 1; v &lt;= n; v++) &#123;            if (map[cur][v] &lt; INF) &#123;                if (dis[v] &gt; dis[cur] + map[cur][v]) &#123;                    dis[v] = dis[cur] + map[cur][v];                &#125;            &#125;        &#125;    &#125;    for (i = 1; i &lt;= n; i++) &#123;        cout &lt;&lt; dis[i];    &#125;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><p>采用邻接表(链式向前星)：</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;const int INF=2147483647;long long dis[10001];bool mark[100001];//STL优先队列（使用pair的情况下）的定义方法。由于要采用小根堆，所以需要这样定义。priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q;int fir[500001],to[500001],val[500001],nex[500001];    int cnt;void add_edge(int a,int b,int c)//链式前向星存图&#123;    to[++cnt]=b;    val[cnt]=c;    nex[cnt]=fir[a];    fir[a]=cnt;&#125;int main()&#123;    int n,m,s;    int u,v,w;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    for(int i=1; i&lt;=m; i++)    &#123;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        add_edge(u,v,w);     &#125;    for(int i=1; i&lt;=n; i++)        dis[i]=inf;    dis[s]=0;//初始化dis数组     q.push(make_pair(0,s));//这里采用C++自带二元组编写    while(q.size())//当堆中还有元素     &#123;        int x=q.top().second;//q.top()取出堆顶，也就是当前距离起点最近的点。         q.pop();//取完就删         if(mark[x]) continue;//如果这个定点标记过了，就不用。        mark[x]=1;//标记一下         for(int i=fir[x]; i; i=nex[i])        &#123;            if(dis[to[i]]&gt;dis[x]+val[i])//dijkstra算法核心语句             &#123;                dis[to[i]]=dis[x]+val[i];                q.push(make_pair(dis[to[i]],to[i]));//每次松弛成功，把关于当前点的信息压入堆。             &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)        cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;     return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>std::move和std::forword</title>
      <link href="/p/39842.html"/>
      <url>/p/39842.html</url>
      
        <content type="html"><![CDATA[<h1 id="std-move和std-forword"><a href="#std-move和std-forword" class="headerlink" title="std::move和std::forword"></a>std::move和std::forword</h1><h2 id="两者异同点"><a href="#两者异同点" class="headerlink" title="两者异同点"></a>两者异同点</h2><p>相同点：std::move并不进行任何移动操作，std::forward也并不进行任何转发操作，都只是仅仅执行强制类型转换的模版函数。<br>不同点：std::move无条件地将实参强制转换成右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。</p><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>来看一个简单的std::move的示例实现，他不符合标准的所有细节，但十分接近了。</p><pre><code>template&lt;typename T&gt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;move(T&amp;&amp; param) &#123; // 万能引用    // 确保返回的一定是右值引用    using ReturnType = typename std::remove_reference&lt;T&gt;::type&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param); // 类型转换&#125;</code></pre><p>此外，std::move在C++14中可以被更简单地实现。利用函数返回值类型推导和标准库的模板别名std::remove_reference_t，std::move可以这样写：</p><pre><code>template&lt;typename T&gt;decltype(auto) move(T&amp;&amp; param)          //C++14，仍然在std命名空间&#123;    using ReturnType = remove_referece_t&lt;T&gt;&amp;&amp;;    return static_cast&lt;ReturnType&gt;(param);&#125;</code></pre><h3 id="保留常量属性"><a href="#保留常量属性" class="headerlink" title="保留常量属性"></a>保留常量属性</h3><p>move移动过程实际上就是一个类型转换的过程，但是这并不改变T的常量性；<br>举例如下：</p><pre><code>class Annotation &#123;public:    explicit Annotation(const std::string test) : value_(std::move(test)) &#123;&#125;private:    std::string value_;&#125;;class string &#123; // std::string实际是std::basic_string&lt;char&gt;的typedefpublic:    string(const std::string&amp;); // 拷贝构造函数（形参为const）    string(std::string&amp;&amp;);      // 移动构造函数（形参非const）&#125;;</code></pre><p>实际上在这儿调用的是拷贝构造函数进行了复制操作，并非是被移动的。具体原因：<br>std::move仅仅做引用类型的转换，const常量属性依旧会被保留下来。也就是test经过std::move后返回类型为const std::string的右值引用。<br>移动构造函数、移动赋值运算符因为会更改被移动对象的成员变量值，因此其形参不是const类型，也就是实参不能是常量右值引用。<br>复制构造函数、赋值运算符的形参类型为常量的左值引用，其可以绑定到常量右值引用的实参，因此可以调用复制构造函数、赋值运算符。<br>这种行为是为了保证原对象的常量属性。只要对象是const类型，即是经过std::move也不能更改其常量属性，也就不能传递给可能更改对象值的函数（移动构造函数、移动赋值运算符）。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>std::forward通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。<br>示例实现</p><pre><code>template&lt;class T&gt;constexpr T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; arg) noexcept&#123;    // forward an lvalue as either an lvalue or an rvalue    return (static_cast&lt;T&amp;&amp;&gt;(arg));&#125;template&lt;class T&gt;constexpr T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp;&amp; arg) noexcept&#123;    // forward an rvalue as an rvalue    return (static_cast&lt;T&amp;&amp;&gt;(arg));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wasm</title>
      <link href="/p/a9a8d1fe.html"/>
      <url>/p/a9a8d1fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="wasm"><a href="#wasm" class="headerlink" title="wasm"></a>wasm</h1><p>WASM是“WebAssembly”的缩写。WebAssembly是一种新的代码格式，是一种低级别、代码密集型的虚拟机，可以被浏览器支持，以便在浏览器中高效地运行各种语言的代码。<br>WebAssembly是一种与JavaScript类似的虚拟机，但它并不基于文本，而是一种二进制格式，无需编译器处理即可运行。WebAssembly 可以为那些不想或难以通过JavaScript实现的计算任务提供一种性能非常优秀的运行方式，其中包括数据密集型任务、游戏以及机器学习应用。<br>WebAssembly 在与 JavaScript 应用协同工作方面非常优秀，可以通过JavaScript与WebAssembly代码进行交互，并允许网络应用程序在客户端和服务器之间快速共享代码。由于WASM是一种跨平台、低级别的虚拟机，因此也可以在移动应用、桌面应用等上下文中使用，从而实现高效的多平台代码共享。 </p><p>WebAssembly（WASM）的优势有以下几个方面</p><ul><li>高效性：WASM 可以实现高效的解释和编译，因此可以快速执行计算密集型任务，提高 Web 应用程序的性能。与 JavaScript 相比，它更加接近计算机本身的机器语言，因此可以在不增加时间和内存开销的情况下加快许多任务的执行速度。<br>可移植性：WASM 是一种与平台无关的格式，可以在任何浏览器和操作系统上运行。这意味着，WASM 应用程序不需要为每个平台编写代码或重新编译代码，从而大大降低了开发和维护成本。</li><li>安全性：WASM 代码在运行之前需要通过一系列的检查程序，以确保其不会访问到不安全的资源或内存，并且其执行不会导致不安全的行为。因此，WASM 在安全性方面有着很大的优势，也更容易通过常规的安全审计程序获得通过。</li><li>可组合性：由于 WebAssembly 可以与 JavaScript 代码无缝协作，因此可以简化现有技术栈之间的迁移和相互支持，例如可以将现有的 JavaScript 库包装成 WebAssembly 模块，以更快、更高效地执行计算密集型任务。</li><li>扩展性：WASM 支持多种编程语言，如 C++、Rust 和 Kotlin 等，这可以帮助开发者来扩展现有的技术栈并更快地将不同的代码整合到一个应用程序中。</li></ul><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="Go编译为wasm"><a href="#Go编译为wasm" class="headerlink" title="Go编译为wasm"></a>Go编译为wasm</h3><p>将Golang程序编译为wasm格式，一般有两种方式：</p><ol><li>采用Go原生编译器(Go1.11及以后)进行编译：无需安装第三方编译库，但此种编译的wasm不支持wasi规范</li><li>使用第三方编译工具，例如TinyGo编译器进行编译</li></ol><h3 id="安装tinygo"><a href="#安装tinygo" class="headerlink" title="安装tinygo"></a>安装tinygo</h3><p>参照官方文档<a href="https://tinygo.org/getting-started/overview/">https://tinygo.org/getting-started/overview/</a></p><h4 id="通过-Scoop-快速安装"><a href="#通过-Scoop-快速安装" class="headerlink" title="通过 Scoop 快速安装"></a>通过 Scoop 快速安装</h4><blockquote><p>scoop install tinygo<br>您的$PATH环境变量将通过 scoop 包更新。默认情况下，在~&#x2F;scoop&#x2F;shims&#x2F;tinygo.</p></blockquote><p>可以通过 scoop 升级到最新的 TinyGo 版本：</p><blockquote><p>scoop update tinygo</p></blockquote><p>version您可以通过运行应显示版本号的命令来测试安装是否成功：</p><blockquote><p>tinygo version<br>tinygo version 0.27.0 windows&#x2F;amd64 (using go version go1.20 and LLVM version 15.0.0)</p></blockquote><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>从<a href="https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip%E4%B8%8B%E8%BD%BD%E9%80%82%E7%94%A8%E4%BA%8E">https://github.com/tinygo-org/tinygo/releases/download/v0.27.0/tinygo0.27.0.windows-amd64.zip下载适用于</a> Windows 的 TinyGo 二进制文件</p><p>然后解压文件：</p><p>文件夹解压完成后，需要添加your-path\tinygo\bin到您的 PATH。</p><blockquote><p>set PATH&#x3D;%PATH%;”your-path\tinygo\bin”;</p></blockquote><h3 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h3><p>wasm-opt 工具用于优化 WebAssembly 二进制文件，通常随 Emscripten SDK 一起提供。Emscripten SDK 安装过程中需要使用 Python 解释器来执行一些操作。</p><p><a href="https://www.python.org/downloads/windows/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%89%88%E6%9C%ACinstaller">https://www.python.org/downloads/windows/官网下载相应版本installer</a><br>安装过程中记得勾选将python加入到环境变量选项</p><h3 id="Emscripten-SDK"><a href="#Emscripten-SDK" class="headerlink" title="Emscripten SDK"></a>Emscripten SDK</h3><p>Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，</p><p>从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。</p><pre><code># Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk</code></pre><p>再使用如下命令安装配置Emscripten。</p><pre><code># Fetch the latest registry of available tools.git pull# Download and install the latest SDK tools. Need install Python first. ./emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)./emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal./emsdk_env.bat</code></pre><p>完成上述步骤以后，需要将upstream内的bin目录加入到环境变量，或者手动设置 WASMOPT 环境变量</p><pre><code>export WASMOPT=path/to/wasm-opt</code></pre><p>注意，path&#x2F;to&#x2F;wasm-opt 应替换为实际的 wasm-opt 可执行文件路径。</p><h3 id="安装wasm的运行时环境"><a href="#安装wasm的运行时环境" class="headerlink" title="安装wasm的运行时环境"></a>安装wasm的运行时环境</h3><p>运行wasm需要有一个运行时环境，由于浏览器内置了wasm的runtime，因此大部分浏览器内可以直接运行wasm。而在非浏览器环境，则需要有一个运行时来执行wasm<br>wazero is the only zero dependency WebAssembly runtime written in Go.</p><p><a href="https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go">https://tetrate.io/blog/introducing-wazero-from-tetrate/#h-a-short-history-of-running-webassembly-in-go</a><br>可以在这里面下载windows安装版本，默认安装到C:\Program Files\wazero<br>将其加入到环境变量以便可以在其他文件夹运行该文件。</p><h2 id="tinygo将Go代码编译为wasi格式"><a href="#tinygo将Go代码编译为wasi格式" class="headerlink" title="tinygo将Go代码编译为wasi格式"></a>tinygo将Go代码编译为wasi格式</h2><p>创建一个hello文件</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello world!&quot;)&#125;</code></pre><p>构建命令</p><pre><code>tinygo build -o hello.wasm -target=wasi hello.gotarget有两种目标，一种是wasm，主要是运行在web浏览器环境；一种是wasi，即非web环境下运行。-o 参数指定输出的文件路径及名称，-target参数指定编译格式，最后main.go代表需要编译的文件入口。</code></pre><p>运行文件</p><pre><code>wazero run hello.wasm</code></pre><p>得到输出</p><pre><code>Hello world!</code></pre><p>官方wiki指南：<a href="https://github.com/golang/go/wiki/WebAssembly%EF%BC%8CGo%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%98%E6%96%B9%E5%B7%B2%E6%94%AF%E6%8C%81%E5%B0%86%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%BAwasm%E6%A8%A1%E5%9D%97%EF%BC%8C%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E3%80%82">https://github.com/golang/go/wiki/WebAssembly，Go编译器官方已支持将代码编译为wasm模块，无需借助第三方编译工具。</a></p><p>将编写好的go程序编译成wasm格式，在编译时需要指定编译参数：</p><pre><code>GOOS=js GOARCH=wasm go build -o ../dist/main.wasm</code></pre><p>获取go官方准备的js胶水文件：</p><pre><code>cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; .</code></pre><p>PS: JS 胶水文件（JavaScript glue file）是指一类用于连接 JavaScript 代码与其他语言的代码的文件。常见的使用 JS 胶水文件的场景包括使用 JavaScript 调用 C&#x2F;C++ 程序、使用 JavaScript 调用 Python 程序等等。JS 胶水文件通常会包含一些 C&#x2F;C++ 或 Python 的函数定义，以及这些函数的映射关系。在 JavaScript 代码中调用这些函数时，JS 胶水文件会将函数调用转换为对应的 C&#x2F;C++ 或 Python 函数调用。JS 胶水文件的实现方式有多种，比较常见的方式包括使用 Node.js 的 ffi 模块、使用 Emscripten 编译 C&#x2F;C++ 代码为 WebAssembly 等。</p><p>创建一个html文件，引入wasm：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const go = new Go();        WebAssembly.instantiateStreaming(fetch(&quot;hello.wasm&quot;), go.importObject).then((result) =&gt; &#123;            go.run(result.instance);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;WebAssembly Demo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后 Web 服务器启动index.html、wasm_exec.js和main.wasm<br>例如，goexec：</p><pre><code># install goexec: go get -u github.com/shurcooL/goexecgoexec &#39;http.ListenAndServe(`:8080`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>这个命令将在当前目录启动一个 Go 的 HTTP 服务器，用于提供您的静态文件。在终端中运行该命令后，您应该可以通过 <a href="http://localhost:8080/">http://localhost:8080/</a> 访问网页，其中 . 是当前目录的路径。如果网页文件是 index.html，那么可以通过 <a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a> 访问它。<br>导航到<a href="http://localhost:8080/index.html%EF%BC%8C%E6%89%93%E5%BC%80">http://localhost:8080/index.html，打开</a> JavaScript 调试控制台，您应该会看到输出。您可以修改程序、重建main.wasm和刷新以查看新的输出。<br>注意：要使goexec命令在类 Unix 系统上运行，您必须将 Go的路径环境变量添加到 shell 的profile.</p><p>go编写的函数如何暴露给js调用<br><a href="https://pkg.go.dev/syscall/js">https://pkg.go.dev/syscall/js</a></p><h3 id="示例-格式化json对象"><a href="#示例-格式化json对象" class="headerlink" title="示例-格式化json对象"></a>示例-格式化json对象</h3><p>json.go :</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;syscall/js&quot;    &quot;time&quot;)func main() &#123;    fmt.Println(&quot;Hello WebAssembly!&quot;)    //注册为全局变量    js.Global().Set(&quot;prettyJSON&quot;, jsonWrapper())    &lt;-make(chan bool)&#125;func prettyJson(input string) (string, error) &#123;    start := time.Now()    var raw interface&#123;&#125;    if err := json.Unmarshal([]byte(input), &amp;raw); err != nil &#123;        return &quot;&quot;, err    &#125;    pretty, err := json.MarshalIndent(raw, &quot;&quot;, &quot; &quot;)    if err != nil &#123;        return &quot;&quot;, err    &#125;    cost := time.Since(start)    fmt.Println(&quot;wasm json耗时: &quot;, cost)    return string(pretty), nil&#125;// 将Go函数封装并返回js.Func对象，才可以被js所调用func jsonWrapper() js.Func &#123;    jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) interface&#123;&#125;&#123;        if len(args) != 1 &#123;            return &quot;Invalid no of arguments passed&quot;        &#125;        inputJSON := args[0].String()        // fmt.Printf(&quot;input %s\n&quot;, inputJSON)        pretty, err := prettyJson(inputJSON)        if err != nil &#123;            fmt.Printf(&quot;unable to convert to json %s\n&quot;, err)            return err.Error()        &#125;        return pretty    &#125;)    return jsonFunc&#125;</code></pre><p>定义html文件：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        const go = new Go();        WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject).then((result) =&gt; &#123;            go.run(result.instance);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;WebAssembly Demo&lt;/h1&gt;&lt;input type=&quot;text&quot; id=&quot;jsonInput&quot;&gt;&lt;button id=&quot;btn-wasm&quot;&gt;解析(wasm)&lt;/button&gt;&lt;br /&gt;&lt;textarea id=&quot;prettyJsonArea&quot;&gt;&lt;/textarea&gt;&lt;script src=&quot;handle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>定义handle.js:</p><pre><code>const convertBtnByWasm = document.getElementById(&#39;btn-wasm&#39;);const jsonInput = document.getElementById(&#39;jsonInput&#39;)convertBtnByWasm.addEventListener(&#39;click&#39;, () =&gt; &#123;const content = jsonInput.value;const pretty = window.globalThis.prettyJSON(content);prettyJsonArea.value = pretty&#125;)</code></pre><p><a href="https://imgse.com/i/p9mOfne"><img src="https://s1.ax1x.com/2023/04/24/p9mOfne.png" alt="p9mOfne.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于xfx torm的学习开发和容器化打包部署</title>
      <link href="/p/2ecd4e0f.html"/>
      <url>/p/2ecd4e0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于xfx-torm的学习开发和容器化打包部署"><a href="#基于xfx-torm的学习开发和容器化打包部署" class="headerlink" title="基于xfx torm的学习开发和容器化打包部署"></a>基于xfx torm的学习开发和容器化打包部署</h1><h2 id="stage-生成代码"><a href="#stage-生成代码" class="headerlink" title="stage 生成代码"></a>stage 生成代码</h2><p>stage 可以帮助开发人员定义并产出规范的工程项目。利用 stage 我们可以用极快的速度生产：</p><pre><code>mkdir -p ./src/hellocd ./src/hellostage initecho &quot;get /hello 200 &#123;greeting: string&#125;;&quot; &gt;&gt; spec/hello.xidlstage gengo mod tidymake build./run serve</code></pre><p>编译后的 hello 是一个可以直接运行的服务器程序。可以通过 curl 命令验证服务器是否运行正常：</p><pre><code>curl http://localhost:8080/hello</code></pre><p>stage init 命令类似于 git init 命令，将一个目录初始化为规范工程，它产生了一个 spec&#x2F;hello.xidl 文件，这个文件用来定义程序接口规格，默认情况下 stage 定义好了最基本的命令行接口。</p><pre><code>stage init</code></pre><p>然后向 hello.xidl 追加了一条 &#x2F;hello 的定义，这是一种紧凑型的接口定义语言。</p><pre><code>echo &quot;get /hello 200 &#123;greeting: string&#125;;&quot; &gt;&gt; spec/hello.xidl</code></pre><p>stage gen 命令会根据接口规格描述产生工程代码。</p><pre><code>stage gen</code></pre><p>注：<br>需要配置完成go环境以后使用stage<br>需要将stage.exe 加入到环境变量方便我们在其他文件夹内使用该命令<br>make命令需要下载MinGW 并且配置make环境变量</p><h2 id="利用docker搭建数据库MYSQL"><a href="#利用docker搭建数据库MYSQL" class="headerlink" title="利用docker搭建数据库MYSQL"></a>利用docker搭建数据库MYSQL</h2><p>点击 <a href="https://yeasy.gitbook.io/docker_practice/install/windows">链接</a> 下载 Docker Desktop for Windows<br>下载完成后</p><pre><code>docker pull mysql</code></pre><p>拉取mysql镜像后，创建mysql容器</p><pre><code># ~/docker/conf/mysql目录下为mysql配置文件# ~/docker/data/mysql目录下为mysql数据文件# 本机的3306和33060端口分别映射docker内部的3306和33060端口# 数据库root密码为crane# -d后台运行dockerdocker run --name mysql -v ~/docker/conf/mysql:/etc/mysql/conf.d -v ~/docker/data/mysql:/var/lib/mysql -p 3306:3306 -p 33060:33060 -e MYSQL_ROOT_PASSWORD=crane -d mysql</code></pre><p>部分会用到的docker命令：</p><pre><code>docker ps -a查看容器列表docker inspect — 查看关于容器的信息docker kill — 立即停止容器中的主要进程docker stop — 停止正在运行的容器docker start — 启动一个已有的容器docker run — 创建一个新的容器并且启动它docker build — 构建一个镜像</code></pre><p>注：<br>通过主机ip以及映射到主机的3306端口来访问mysql<br>或者使用localhost+ip连接数据库，但是容器化部署项目以后该方式会有问题</p><h2 id="产生DAO代码"><a href="#产生DAO代码" class="headerlink" title="产生DAO代码"></a>产生DAO代码</h2><pre><code>go install ksogit.kingsoft.net/o/stage/v2@latest# v2go get ksogit.kingsoft.net/o/xfx@dev2</code></pre><p>新建一个用户相关 API 的工程：</p><pre><code>mkdir ./src/usercd ./src/userstage init</code></pre><p>然后往 spec&#x2F;user.xidl 文件中追加创建用户的接口定义：</p><pre><code>schema user &#123;    id: string    name: string&#125;schema user_create_request &#123;    name: string&#125;@name &quot;create_user&quot;post /users    . user_create_request    200 user;</code></pre><p>通过运行 stage gen 后，stage 产生了 NewCreateUserService 的代码，我们只要关注这个 service 进行编写相关的业务代码即可。 但是，这个例子中核心模型 user 是需要入库的，因此，我们还需要编写枯燥的 DAO 来辅助 service 对 user 进行相关的持久化操作。我们可以通过stage解决这个问题，stage 产生 DAO 代码是靠 @table 和 @column 两个注解来进行定义的：</p><pre><code>@table &quot;tb_user;ORM(torm)&quot;schema user &#123;    @column &quot;pk;ai&quot;    id: string    name: string&#125;schema user_create_request &#123;    name: string&#125;@name &quot;create_user&quot;post /users    . user_create_request    200 user;</code></pre><p>@table 指示 user 采用 “tb_user” 作为表名。@column 指示了 id 是主键(pk)和自增长(ai)字段。 ORM(torm) 指定了要用的 ORM 库</p><p>stage gen 针对这种定义主要做了三件事：</p><p>一、将 DAO 相关的代码产生到工程目录下的 dao 子目录中。</p><pre><code>dao├── mysql_db.go├── mysql_interface.go├── runtime.go├── mysql_tx.go├── user_batch_insert.go├── user_builder.go├── user_constants.go├── user_delete.go├── user_insert.go├── user_model.go├── user_order.go├── user_select.go├── user_set.go├── user_update.go├── user_where.go└── util.go</code></pre><p>二、产生后端服务对接代码。</p><pre><code>// Code generated by xfx; DO NOT EDIT.package ctximport (    &quot;user/dao&quot;)type backingServices struct &#123;    MysqlDB  *dao.MysqlDB&#125;func newBackingServices(c *ModuleContext) *backingServices &#123;    var mysqlDB *dao.MysqlDB    &#123;        writeWithoutPrepare, err := opts.GetBool(&quot;mysql-db-write-without-prepare&quot;, false)        if err != nil &#123;            panic(err)        &#125;        mysqlDB = dao.NewMysqlDB(            c.AppContext.TORM(&quot;MYSQL&quot;),            dao.WithUniversalSQL(writeWithoutPrepare),        )    &#125;    return &amp;backingServices&#123;        MysqlDB: mysqlDB,    &#125;&#125;</code></pre><p>三、在工程目录中的 env 文件中配置数据库信息。</p><pre><code>export USER_TORM_NAMES=&quot;MYSQL&quot;export USER_DB_MYSQL_HOST=&quot;your IP&quot;export USER_DB_MYSQL_PORT=&quot;3306&quot;export USER_DB_MYSQL_NAME=&quot;test&quot;export USER_DB_MYSQL_USER=&quot;root&quot;export USER_DB_MYSQL_PASSWD=&quot;your password&quot;export USER_DB_MYSQL_PARAMS=&quot;loc=Local&amp;parseTime=True&amp;charset=utf8&quot;export USER_DB_MYSQL_VERBOSE=&quot;false&quot;export USER_DB_MYSQL_MAX_IDLE_CONNS=&quot;30&quot;export USER_DB_MYSQL_MAX_OPEN_CONNS=&quot;150&quot;# export USER_DB_SAMPLE_READ_CIRCUIT_BREAKER=&quot;&quot;# export USER_DB_SAMPLE_WRITE_CIRCUIT_BREAKER=&quot;&quot;# export USER_DB_SAMPLE_READ_RETRY=&quot;&quot;# export USER_DB_SAMPLE_WRITE_RETRY=&quot;&quot;</code></pre><p>最后，可以用 make 进行构建工程了。</p><pre><code>make build</code></pre><p>注：<br>配置env文件需要删除注释…<br>需要在mysql中提前创建对应的数据库<br>ip可以用本机ip访问，也可以使用localhost，容器化部署以后用本机ip</p><h2 id="利用生成的代码进行数据持久化"><a href="#利用生成的代码进行数据持久化" class="headerlink" title="利用生成的代码进行数据持久化"></a>利用生成的代码进行数据持久化</h2><p>Endpoint（端点）是一个网络服务的访问地址，客户端可以通过该地址与服务进行交互。在Web服务中，Endpoint通常指一个URL（Uniform Resource Locator，统一资源定位符），用于描述服务所在的网络位置以及可用的操作。Endpoint可以被认为是一个API的入口点，客户端可以使用它来访问服务并执行各种操作，例如获取数据、执行业务逻辑或进行状态更改。在SOAP协议中，Endpoint通常由一个地址（URL）和一个绑定（Binding）组成，它定义了如何对服务进行调用以及如何进行消息传输。在RESTful服务中，Endpoint通常由HTTP方法和URL组成，用于定义可以对资源执行的操作。</p><p>我们在创建User对象的时候，把name初始化</p><pre><code>func NewCreateUserService(moduleCtx *ctx.ModuleContext) CreateUserFunc &#123;    return func(ctx context.Context, request *CreateUserRequest) (*CreateUserResponse, error) &#123;        //验证标签合法        err := validator.Validate(request)        if err != nil &#123;            return nil, err        &#125;        out := NewCreateUserResponse()        out.Name = request.Name        return &amp;out, nil    &#125;&#125;</code></pre><p>我们在Endpoint中调用数据库代码，将id和user持久化到数据库。</p><pre><code>func (h *CreateUser) Endpoint(app xfx.App) endpoint.Endpoint &#123;    callService := srv.NewCreateUserService(ctx.Get(app))    return func(w http.ResponseWriter, r *http.Request) error &#123;        w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)        in, err := parseCreateUserRequest(w, r)        if err != nil &#123;            return rw.WriteError(w, r, el.Adapt(err))        &#125;        in.EscapeStrings()        out, err := callService(r.Context(), in)        if err != nil &#123;            return rw.WriteError(w, r, err)        &#125;        moduleCtx := ctx.Get(app)        db:=moduleCtx.MysqlDB        db.User().Insert(&amp;dao.UserSet&#123;            Name:dao.String(out.Name),        &#125;).Exec(context.Background())        userBuilder :=db.User().Select().Where(func(b *dao.UserWhereBuilder) &#123;            b.IdGT(0)        &#125;)        userid,_ := userBuilder.Count(context.Background())        out.Id =fmt.Sprintf(&quot;%d&quot;, userid)        return rw.WriteJson(w, 200, out)    &#125;&#125;</code></pre><p>注：<br>term的使用方式<a href></a></p><h2 id="将该服务打包成镜像"><a href="#将该服务打包成镜像" class="headerlink" title="将该服务打包成镜像"></a>将该服务打包成镜像</h2><p>配置Dockerfile文件</p><pre><code>ARG GIT_BRANCHARG BASE_IMAGE=hub-mirror.wps.cn/priopen/golang-nodejs-builder:1.18.7-alpine-v3ARG USERARG PASSWORDFROM $&#123;BASE_IMAGE&#125; as golang-build# 根据CI配置克隆目录修改PROJECT_NAME参数ARG PROJECT_NAME=userARG APP_NAME=userENV PROJECT_NAME=$&#123;PROJECT_NAME&#125;ENV APP_NAME=$&#123;APP_NAME&#125;ENV GIT_BRANCH=$&#123;GIT_BRANCH&#125;ENV TERM=xtermRUN export GONOSUMDB=*.kingsoft.netRUN export GOPRIVATE=*.kingsoft.netRUN git config --global --add url.&quot;git@ksogit.kingsoft.net:&quot;.insteadof &quot;https://ksogit.kingsoft.net/&quot;RUN git config --global credential.helper cacheRUN git config --global user.name &quot;xxxxxxxxxx&quot;RUN git config --global user.password &quot;xxxxxxxxxxxxxx&quot;RUN git config --global user.email &quot;xxxxxx@kingsoft.com&quot;# 指定当前工作目录为 /opt/$&#123;PROJECT_NAME&#125;/$&#123;APP_NAME&#125;WORKDIR /opt/$&#123;PROJECT_NAME&#125;# ADD ./docker /optCOPY . /opt/$&#123;PROJECT_NAME&#125;RUN echo http://mirrors.aliyun.com/alpine/v3.15/main/ &gt; /etc/apk/repositories &amp;&amp; \    echo http://mirrors.aliyun.com/alpine/v3.15/community/ &gt;&gt; /etc/apk/repositoriesRUN source /opt/$PROJECT_NAME/env# 执行 make 命令生成代码，并进行构建RUN /usr/local/go/bin/go build -o user -v -ldflags &quot; \    -X user/cmds.GitHash=$(shell git rev-parse HEAD 2&gt; /dev/null) \    -X user/cmds.BuildTime=$(shell date &quot;+%Y-%m-%dT%H:%M:%SZ&quot;)&quot;FROM hub-mirror.wps.cn/priopen/golang-runner:1.17.13-alpine# 根据CI配置克隆目录修改PROJECT_NAME参数ENV PROJECT_NAME=userENV APP_NAME=userWORKDIR /opt/$&#123;PROJECT_NAME&#125;COPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/docker ./dockerCOPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/$&#123;APP_NAME&#125; ./COPY --from=golang-build  /opt/$&#123;PROJECT_NAME&#125;/env ./RUN chmod +x ./docker/start.shRUN chmod +x ./docker/livenessProbe.shRUN chmod +x ./docker/readinessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/docker/livenessProbe.sh /usr/local/bin/livenessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/docker/readinessProbe.sh /usr/local/bin/readinessProbe.shRUN cp /opt/$&#123;PROJECT_NAME&#125;/env /usr/local/bin/envRUN /bin/bash -c &quot;source /opt/$&#123;PROJECT_NAME&#125;/env&quot;EXPOSE 80 8081ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;,&quot;/opt/$&#123;PROJECT_NAME&#125;/docker/start.sh&quot;]</code></pre><p>配置完Dockerfile以后，使用</p><pre><code>docker build -t user .</code></pre><p>构建一个名字为user的镜像,构建完成后，由该镜像构建一个容器</p><pre><code>docker run user -p 8080:8080</code></pre><p>注：<br>构建过程中需要export GONOSUMDB&#x3D;<em>.kingsoft.net  export GOPRIVATE&#x3D;</em>.kingsoft.net  否则会因为权限问题无法拉取xfx&#x2F;o&#x2F;wps 的仓库。<br>需要更新一下env配置，RUN &#x2F;bin&#x2F;bash -c “source &#x2F;opt&#x2F;${PROJECT_NAME}&#x2F;env” 否则运行会产生错误</p><h2 id="测试服务是否启动成功"><a href="#测试服务是否启动成功" class="headerlink" title="测试服务是否启动成功"></a>测试服务是否启动成功</h2><p>我们利用postman 来发送post请求<br><a href="https://imgse.com/i/p9AquZV"><img src="https://s1.ax1x.com/2023/04/21/p9AquZV.png" alt="p9AquZV.png"></a><br>这里需要解决跨域请求的问题，我们要在headers中加入<br><a href="https://imgse.com/i/p9AqdIO"><img src="https://s1.ax1x.com/2023/04/21/p9AqdIO.png" alt="p9AqdIO.png"></a></p><p>最终我们启动mysql服务，然后启动user服务<br><a href="https://imgse.com/i/p9AqyQA"><img src="https://s1.ax1x.com/2023/04/21/p9AqyQA.png" alt="p9AqyQA.png"></a><br>测试最终的执行效果,可以看到我们已经将内容持久化数据库并且id自增存储，返回的json和存储内容一致。<br><a href="https://imgse.com/i/p9AqhFS"><img src="https://s1.ax1x.com/2023/04/21/p9AqhFS.png" alt="p9AqhFS.png"></a><br><a href="https://imgse.com/i/p9AqIzj"><img src="https://s1.ax1x.com/2023/04/21/p9AqIzj.png" alt="p9AqIzj.png"></a><br><a href="https://imgse.com/i/p9AOLPU"><img src="https://s1.ax1x.com/2023/04/21/p9AOLPU.png" alt="p9AOLPU.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信的三种方式</title>
      <link href="/p/d0681926.html"/>
      <url>/p/d0681926.html</url>
      
        <content type="html"><![CDATA[<h4 id="通信的三种方式"><a href="#通信的三种方式" class="headerlink" title="通信的三种方式"></a>通信的三种方式</h4><ul><li><p>客户&#x2F;服务器模型</p></li><li><p>P2P模型</p></li><li><p>混合模型</p></li></ul><h4 id="网络接入"><a href="#网络接入" class="headerlink" title="网络接入"></a>网络接入</h4><ul><li><p>点对点方式接入</p><ul><li>电话线</li><li>电缆&#x2F;光纤混合电路</li><li>光纤到户</li><li>卫星</li></ul></li><li><p>以以太网&#x2F;WIFI的方式</p><ul><li>以太网(有线)</li><li>WiFi(无线)</li></ul></li><li><p>广域无线接入</p></li></ul><h4 id="介质"><a href="#介质" class="headerlink" title="介质"></a>介质</h4><ul><li>导引型介质<ul><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li><li>非导引型介质<ul><li>大气层</li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="数据传输的方式"><a href="#数据传输的方式" class="headerlink" title="数据传输的方式"></a>数据传输的方式</h4><ul><li>电路交换网络<ul><li>建立连接</li><li>交换数据</li><li>释放连接</li></ul></li><li>分组交换网络<ul><li>长数据切分成小段</li><li>生成分组，每个数据段加上首部</li><li>发送数据</li><li>接受数据</li><li>恢复原来报文</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络边缘</title>
      <link href="/p/2f9ed4ad.html"/>
      <url>/p/2f9ed4ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ul><li>网路边缘<ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul></li><li>网络核心<ul><li>互联着的路由器</li><li>网络的网络</li></ul></li><li>网络接入<ul><li>有线或者无线通信链路</li></ul></li></ul><p>从应用往下看都是网络基础设施</p><h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul><li>端系统（主机）<ul><li>运行应用程序</li><li>如Web，email</li><li>在“网络的边缘”</li></ul></li><li>客户&#x2F;服务器模式 C&#x2F;S<ul><li>客户端向服务器请求接受服务</li><li>如Web浏览器&#x2F;服务器；email客户端&#x2F;服务器</li></ul></li><li>对等模式 P2P<ul><li>很少专门的服务器</li><li>如Emule，KozaA</li></ul></li></ul><h3 id="采用网络设施的面向连接的服务"><a href="#采用网络设施的面向连接的服务" class="headerlink" title="采用网络设施的面向连接的服务"></a>采用网络设施的面向连接的服务</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>在端系统之间传输数据<br><strong>握手</strong>：在数据传输之前做好准备</p><ul><li>人类协议中：你好，你好</li><li>两个通信主机之间为连接建立状态<br>面向连接的通信方式：通信方式只有端节点知道</li></ul><p><strong>TCP-传输控制协议</strong></p><ul><li>Internet上面向连接的服务</li></ul><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠的，按顺序的传送数据<ul><li>确认和重传</li></ul></li><li>流量控制<ul><li>发送方不会淹没接收方</li></ul></li><li>拥塞控制<ul><li>当网络拥塞时，发送方降低发送速率</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字编程</title>
      <link href="/p/1bcba982.html"/>
      <url>/p/1bcba982.html</url>
      
        <content type="html"><![CDATA[<h1 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 - Socket"></a>套接字 - Socket</h1><p>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）表示，区分不同应用程序进程间的网络通信和连接,主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。</p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>中国大陆一共有344514560个。占全球可用IPv4地址数量超过8%。<br>如果加上香港的12614144个，也仅仅是8.3%。<br><strong>查看IP</strong></p><pre><code># linux$ ifconfig# windows$ ipconfig# 测试网络是否畅通# 主机a: 192.168.1.11# 当前主机: 192.168.1.12$ ping 192.168.1.11     # 测试是否可用连接局域网$ ping www.baidu.com    # 测试是否可用连接外网# 特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的# 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</code></pre><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>在计算机的世界中有两种字节序</p><ul><li>大端字节序：高地址存低位，低地址存高位</li><li>小端字节序：低地址存低位，高地址存高位</li></ul><p>TCP&#x2F;IP协议规定，网络数据流应采用大端字节序，即低地址高字节。如果你的主机不是采用大端字节序就转为大端字节序在发送数据流时就回转换成大端字节序，如果你是大端字节序就不进行转换。我们使用的 PC 机，数据的存储默认使用的是小端。</p><pre><code>#include &lt;arpa/inet.h&gt;// u:unsigned// 16: 16位, 32:32位// h: host, 主机字节序// n: net, 网络字节序// s: short// l: int// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换// 将一个短整形从主机字节序 -&gt; 网络字节序uint16_t htons(uint16_t hostshort);    // 将一个整形从主机字节序 -&gt; 网络字节序uint32_t htonl(uint32_t hostlong);    // 将一个短整形从网络字节序 -&gt; 主机字节序uint16_t ntohs(uint16_t netshort)// 将一个整形从网络字节序 -&gt; 主机字节序uint32_t ntohl(uint32_t netlong);</code></pre><p>虽然 IP 地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述，下面的函数描述了如何将一个字符串类型的 IP 地址进行大小端转换：</p><pre><code>// 主机字节序的IP地址转换为网络字节序// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形int inet_pton(int af, const char *src, void *dst); </code></pre><p>参数:</p><pre><code>af: 地址族 (IP 地址的家族包括 ipv4 和 ipv6) 协议AF_INET: ipv4 格式的 ip 地址AF_INET6: ipv6 格式的 ip 地址src: 传入参数，对应要转换的点分十进制的 ip 地址: 192.168.1.100dst: 传出参数，函数调用完成，转换得到的大端整形 IP 被写入到这块内存中返回值：成功返回 1，失败返回 0 或者 - 1#include &lt;arpa/inet.h&gt;// 将大端的整形数, 转换为小端的点分十进制的IP地址        const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code></pre><p>参数:</p><pre><code>af: 地址族协议AF_INET: ipv4 格式的 ip 地址AF_INET6: ipv6 格式的 ip 地址src: 传入参数，这个指针指向的内存中存储了大端的整形 IP 地址dst: 传出参数，存储转换得到的小端的点分十进制的 IP 地址size: 修饰 dst 参数的，标记 dst 指向的内存中最多可以存储多少个字节</code></pre><p>返回值:</p><pre><code>成功：指针指向第三个参数对应的内存地址，通过返回值也可以直接取出转换得到的 IP 字符串失败: NULL</code></pre><p>还有一组函数也能进程 IP 地址大小端的转换，但是只能处理 ipv4 的 ip 地址：</p><pre><code>// 点分十进制IP -&gt; 大端整形in_addr_t inet_addr (const char *cp);// 大端整形 -&gt; 点分十进制IPchar* inet_ntoa(struct in_addr in);</code></pre><h2 id="Socket-的-2-种类型"><a href="#Socket-的-2-种类型" class="headerlink" title="Socket 的 2 种类型"></a>Socket 的 2 种类型</h2><p>Socket 是一个抽象概念，代表了通信双方的端点（Endpoint），通信双方通过Socket 发送或接收数据。<br>在 Winsock 里，用数据类型SOCKET 作为 Windows Sockets 对象的句柄，就好像一个窗口的句柄HWND、一个打开的文件的文件指针一样。下面我们会看到，在 Winsock API 的许多函数里，都会用到 SOCKET 类型的参数。</p><p>Socket 有 2 种类型：</p><ul><li>流类型（Stream Sockets）。<ul><li>流式套接字提供了一种可靠的、面向连接的数据传输方法，使用传输控制协议 TCP。</li></ul></li><li>数据报类型（Datagram Sockets）。<ul><li>数据报套接字提供了一种不可靠的、非连接的数据包传输方式，使用用户数据报协议 UDP。</li></ul></li></ul><h2 id="Socket-I-x2F-O-的-2-种模式"><a href="#Socket-I-x2F-O-的-2-种模式" class="headerlink" title="Socket I&#x2F;O 的 2 种模式"></a>Socket I&#x2F;O 的 2 种模式</h2><p>一个 SOCKET 句柄可以看成代表了一个 I&#x2F;O 设备。在 Windows Sockets 里，有 2 种 I&#x2F;O 模式：</p><ul><li>阻塞式 I&#x2F;O（blocking I&#x2F;O）<br>在阻塞方式下，收发数据的函数在调用后一直要到传送完毕或者出错才能完成，在阻塞期间，除了等待网络操作的完成不能进行任何操作。阻塞式 I&#x2F;O 是一个 Winsock API 函数的缺省行为。 </li><li>非阻塞式 I&#x2F;O（non-blocking I&#x2F;O）<br>对于非阻塞方式，Winsock API 函数被调用后立即返回；当网络操作完成后，由 Winsock 给应用程序发送消息（Socket Notifications）通知操作完成，这时应用程序可以根据发送的消息中的参数对消息做出响应。Winsock 提供了 2 种异步接受数据的方法：一种方法是使用 BSD 类型的函数 select（），另外一种方法是使用 Winsock 提供的专用函数WSAAsyncSelect（）。</li></ul><h2 id="套接字部分库函数列表"><a href="#套接字部分库函数列表" class="headerlink" title="套接字部分库函数列表"></a>套接字部分库函数列表</h2><h3 id="WSAStartup（）"><a href="#WSAStartup（）" class="headerlink" title="WSAStartup（）"></a>WSAStartup（）</h3><p>函数原型：</p><pre><code>int WSAStartup (WORD wVersionRequested,LPWSADATA lpWSAData    );</code></pre><p>参数</p><pre><code>wVersionRequested[in] 表示欲使用的Windows Sockets API 版本；这是个WORD 类型的整数，高字节定义的是次版本号，低字节定义的是主版本号。lpWSAData[in] 指向 WSAData 资料的指针。WSAData 是结构数据类型，描述了关于 Windows Sockecs 底层实现的相关信息。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回如下错误代码：WSASYSNOTREADY：    底层网络子系统没有准备好。WSAVERNOTSUPPORTED：Winsock 版本信息号不支持。WSAEINPROGRESS：    阻塞式 Winsock1.1 存在于进程中。WSAEPROCLIM：    已经达到 Winsock 使用量的上限。WSAEFAULT：    lpWSAData 不是一个有效的指针。</code></pre><p>函数功能</p><pre><code>这个函数是应用程序应该第一个调用的 Winsock API 函数，以完成一系列初始化的工作。</code></pre><p>相关数据结构</p><pre><code>WSADATA 的定义如下：typedef struct WSAData &#123;     WORD wVersion;     WORD wHighVersion;    char   szDescription[WSADESCRIPTION_LEN+1];    char szSystemStatus[WSASYS_STATUS_LEN+1];     unsigned short iMaxSockets;    unsigned short   iMaxUdpDg;     char FAR *    lpVendorInfo;&#125; WSADATA, FAR * LPWSADATA;</code></pre><p>其中，各结构成员的含义为:</p><pre><code>wVersion应用程序应该使用的 Winsock 版本号。wHighVersion DLL 所支持的最高版本号。通常应该等于 wVersion。 szDescription 以 0 结尾的 ASCII 字符串，关于 Winsock 底层实现的描述信息。szSystemStatus 以 0 结尾的 ASCII 字符串，关于 Winsock 底层状态或者配置信息。iMaxSockets 一个进程最多可使用的套接字数，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。iMaxUdpDg 最大的 UDP 报文大小，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。对于 Winsock 2.0，应该使用getsockopt函数取得 SO_MAX_MSG_SIZE。lpVendorInfo Winsock 开发厂商信息，，仅用于 Winsock1.1，Winsock 2.0 应该忽略该成员。对于 Winsock 2.0，应该使用 getsockopt函数取得PVD_CONFIG。</code></pre><p>示例代码</p><pre><code>#include &lt;winsock.h&gt;//对于 Winsock 2, include &lt;winsock2.h&gt;WSADATA wsaData;int nRc = WSAStartup(0x0101, &amp; wsaData); if(nRc)&#123;    //Winsock 初始化错误    return;&#125;if(wsaData.wVersion != 0x0101)&#123;    //版本支持不够    //报告错误给用户，清除 Winsock，返回WSACleanup();    return;&#125;</code></pre><h3 id="socket（）"><a href="#socket（）" class="headerlink" title="socket（）"></a>socket（）</h3><p>函数原型</p><pre><code>SOCKET socket(int af, int type, int protocol);</code></pre><p>参数</p><pre><code>af[in] 指定地址族（address family），一般填AF_INET（使用 Internet 地址）。AF_INET(ipv6)type[in] 指定 SOCKET 的类型：SOCK_STREAM（流类型），SOCK_DGRAM（数据报类型）。protocol[in] 指定 af 参数指定的地址族所使用的具体一个协议。建议设为 0，那么它就会根据地址格式和 SOCKET 类型， 自动为你选择一个合适的协议。另外 2 个常用的值为：IPPROTO_UDP 和 IPPROTO_TCP。</code></pre><p>返回值</p><pre><code>函数执行成功返回一个新的 SOCKET，失败则返回 INVALID_SOCKET。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>所有的通信在建立之前都要创建一个 SOCKET。</code></pre><p>示例代码</p><pre><code>//创建数据报 socketSCOKET udpSock = socket(AF_INET,SOCK_DGRAM, IPPROTO_UDP);//创建流 socketSCOKET tcpSock = socket(AF_INET,SOCK_STREAM, IPPROTO_TCP);</code></pre><h3 id="bind（）"><a href="#bind（）" class="headerlink" title="bind（）"></a>bind（）</h3><p>函数原型</p><pre><code>int bind(SOCKET sockfd, const struct sockaddr FAR* name, int namelen);</code></pre><p>参数</p><pre><code>sockfd[in] 一个需要绑定的SOCKET，例如用 socket 函数创建的 SOCKET。name[in] 指向描述通信对象地址信息的结构体 sockaddr 的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。namelen[in] name 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>成功地创建了一个 SOCKET 后，用bind 函数将SOCKET 和主机地址绑定。</code></pre><p>相关数据结构</p><pre><code>struct sockaddr &#123;    u_short    sa_family;    char    sa_data[14];&#125;;sa_family地址族，比如AF_INET，2 个字节大小。sa_data用来存放地址和端口，14 个字节大小。</code></pre><p>sockaddr 结构是一个通用的结构（因为 Winsock 支持的协议族不只是TCP&#x2F;IP）。对 TCP&#x2F;IP 协议，用如下结构来定义地址和端口。</p><pre><code>typedef unsigned short  uint16_t;typedef unsigned int    uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;typedef unsigned short int sa_family_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))struct sockaddr_in &#123;    short    sin_family;    u_short        sin_port;     struct    in_addr    sin_addr;     char        sin_zero[8];&#125;;sin_family地址族，设为AF_INET。sin_port端口号。如果端口号为 0，Winsock 会自动为应用程序分配一个值在 1024-5000 间的一个端口号，所以客户端一般把 sin_port 设为 0。sin_addr为 in_addr 结构类型，用来指定 IP 地址。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。结构 in_addr 下面介绍。sin_zero8 字节的数组，值全为 0。这个 8 个字节用来填充结构sockaddr_in，使其大小等于结构 sockaddr（16 字节）。结构 in_addr 用来指定 IP 地址，其定义为：struct in_addr &#123;    union &#123;        struct &#123;             u_char s_b1,s_b2,s_b3,s_b4;        &#125; S_un_b;                 struct &#123;            u_short s_w1,s_w2;         &#125; S_un_w;                u_long S_addr;    &#125; S_un;&#125;;</code></pre><p>对于 IP 地址 10.14.25.90，sockaddr_in 结构中的 sin_addr 可以这样赋值：</p><pre><code>sin_addr. S_un .S_un_b. s_b1 = 10; sin_addr. S_un .S_un_b. s_b2 = 14; sin_addr. S_un .S_un_b. s_b3 = 25; sin_addr. S_un .S_un_b. s_b4 = 90;</code></pre><p>或者</p><pre><code>sin_addr. S_un . S_un_w. s_w1 = (14&lt;&lt;8)|10; sin_addr. S_un . S_un_w. s_w2 = (90&lt;&lt;8)|25;</code></pre><p>或者</p><pre><code>sin_addr. S_un . S_addr = (90&lt;&lt;24)|(25&lt;&lt;16)|(14&lt;&lt;8)|10;    </code></pre><p>或者</p><pre><code>sin_addr. S_un . S_addr = inet_addr(“10.14.25.90”);</code></pre><p>这里的 inet_addr 函数可以将字符串形式的 IP 地址转换为 unsigned long 形式的值。</p><p>示例代码</p><pre><code>SOCKET sServSock; sockaddr_in addr;//创建 socketsServSock = socket(AF_INET, SOCK_STREAM, 0); addr.sin_family = AF_INET;//htons 和 htonl 函数把主机字节顺序转换为网络字节顺序，分别用于//短整型和长整型数据addr.sin_port = htons(5050); addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);// LPSOCKADDR 类型转换是必须的int nRc = bind(sServSock, (LPSOCKADDR)&amp;addr, sizeof(addr) );</code></pre><h3 id="listen（）"><a href="#listen（）" class="headerlink" title="listen（）"></a>listen（）</h3><p>函数原型</p><p>int listen (SOCKET s,    int backlog);</p><p>参数</p><pre><code>s[in] 一个已经绑定但未连接的 SOCKET。backlog[in] 等待连接的队列的长度，可取 SOMAXCONN。如果某个客户程序要求连接的时候，服务器已经与其他客户程序连接，则后来的连接请求会放在等待队列中，等待服务器空闲时再与之连接。当等待队列达到最大长度（backlog 指定的值）时，再来的连接请求都将被拒绝。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>对于服务器的程序，当申请到 SOCKET,并将通信对象指定为INADDR_ANY 之后，就应该等待一个客户机的程序来要求连接，listen 函数就是把一个SOCKET 设置为这个状态。</code></pre><h3 id="accept（）"><a href="#accept（）" class="headerlink" title="accept（）"></a>accept（）</h3><p>函数原型</p><pre><code>SOCKET accept (SOCKET s, struct sockaddr FAR* addr,int FAR* addrlen );</code></pre><p>参数</p><pre><code>s[in] 一个已经处于listen 状态的 SOCKET。addr[out] 指向 sockaddr 结构体的指针，里面包含了客户端的地址和端 口。addrlen[out] int 型指针，指向的内容为 addr 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>如果函数执行成功，会建立并返回一个新的 SOCKET 来与对方通信，新建的 SOCKET 与原来的 SOCKET（函数的第一个参数 s）有相同的特性，包括端口号。原来的 SOCKET 继续等待其他的连接请求。而新生成的SOCKET 才是与客户端通信的实际 SOCKET。所以一般将参数中的 SOCKET 称作“监听”SOCKET，它只负责接受连接，不负责通话；而对于函数返回的 SOCKET，把它称作“会话”SOCKET，它负责与客户端通话。如果失败则返回 INVALID_SOCKET。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>accept 函数从等待连接的队列中取第一个连接请求，并且创建一个新的 SOCKET 来负责与客户端会话。</code></pre><p>示例代码</p><pre><code>SOCKET sServSock;    //服务器监听 socket sockaddr_in addr;int nSockErr;int nNumConns = 0;    //当前请求连接数SOCKET sConns[5];    //会话 SOCKET 数组sockaddr ConnAddrs[5];//请求连接的客户端地址int nAddrLen;//创建服务器监听 socketsServSock = socket(AF_INET, SOCK_STREAM, 0);addr.sin_family = AF_INET; addr.sin_port = htons(5050);addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);if( bind(sServSock,(LPSOCKADDR)&amp;addr,sizeof(addr)) == SOCKET_ERROR )&#123;    nSockErr = WSAGetLastError();    //绑定出错处理&#125;//监听客户端请求连接if( listen(sServSock, 2)    ==    SOCKET_ERROR)&#123;    nSockErr = WSAGetLastError();    //出错处理&#125;while( nNumConns &lt; 5)&#123;    //每当收到客户端连接请求，创建新的会话 SOCKET，保存在sConns 数组中    //客户端地址保存在 ConnAddrs 数组中    sConns[nNumConns] = accept(sServSock,ConnAddrs[nNumConns], &amp;nAddrLen);     if(sConns[nNumConns] == INVALID_SOCKET)    &#123;        nSockErr = WSAGetLastError();        //创建会话 SOCKET 出错处理    &#125;    else    &#123;        //创建会话 SOCKET 成功，启动新的线程与客户端会话        StartNewHandlerThread(sConns[nNumConns]);        //当前请求连接数+1         nNumConns ++;    &#125;&#125;</code></pre><h3 id="connect（）"><a href="#connect（）" class="headerlink" title="connect（）"></a>connect（）</h3><p>函数原型</p><pre><code>int connect (SOCKET s, const struct sockaddr FAR* name,int    namelen );</code></pre><p>参数</p><pre><code>s[in] 一个未连接SOCKET，一般是由 socket 函数建立的。name[in] 指向描述通信对象地址信息的结构体 sockaddr 的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为 INADDR_ANY（一个主机可能有多个网卡）。namelen[in] name 指针指向的结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>向对方主动提出连接请求。</code></pre><h3 id="send（）"><a href="#send（）" class="headerlink" title="send（）"></a>send（）</h3><p>函数原型</p><pre><code>int send (SOCKET s, char * buf, int len ,int flags);</code></pre><p>参数</p><pre><code>s[in] 一个已经连接的SOCKET。buf[in] 指向要传输的数据的缓冲区的指针。len[in] buf 的长度。flags[in]指定函数调用的方式。一般不使用，指定为0。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>通过已经连接的 SOCKET 发送数据。</code></pre><h3 id="recv（）"><a href="#recv（）" class="headerlink" title="recv（）"></a>recv（）</h3><p>函数原型</p><pre><code>int recv (SOCKET s, char * buf, int len ,int flags);</code></pre><p>参数</p><pre><code>s[in]   一个已经连接的SOCKET。buf[out] 指向接收数据的缓冲区的指针。len[in] buf 的长度。flags[in]指定函数调用的方式。一般不使用，指定为0。</code></pre><p>返回值</p><pre><code>函数执行成功返回接收到数据的字节数。如果失败则返回 SOCKET_ERROR。这时可以调用 WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>通过已经连接的 SOCKET 接收数据。当读到的数据字节少于规定接受的数目（len）时，就把数据全部接收，并返回实际接收到的字节数；当读到的数据多于规定的值时，在流方式下剩余的数据由下个 recv 读出，在数据报方式下多余的数据被丢弃。</code></pre><h3 id="sendto（）"><a href="#sendto（）" class="headerlink" title="sendto（）"></a>sendto（）</h3><p>函数原型</p><pre><code>int sendto (SOCKET s, char * buf, int len ,int flags,struct sockaddr_in * to, int tolen);</code></pre><p>参数</p><pre><code>s[in] 一个 SOCKET(可能已连接)。buf[in] 指向要传输的数据的缓冲区的指针。len[in] buf 的长度。flags[in] 指定函数调用的方式。一般取 0。to[in] 指向目标地址结构体的指针。tolen[in] 目标地址结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>该函数一般用于通过无连接的 SOCKET 发送数据报文，报文的接受者由 to 参数指定。</code></pre><h3 id="recvfrom（）"><a href="#recvfrom（）" class="headerlink" title="recvfrom（）"></a>recvfrom（）</h3><p>函数原型</p><pre><code>int recvfrom (SOCKET s, char * buf, int len ,int flags,struct sockaddr_in * from, int * fromlen);</code></pre><p>参数</p><pre><code>s[in] 一个已经绑定的SOCKET。buf[out] 指向接收数据的缓冲区的指针。len[in] buf 的长度。flags[in] 指定函数调用的方式。一般取 0。from[out] 指向源地址结构体的指针。fromlen[in/out] 源地址结构体的长度。</code></pre><p>返回值</p><pre><code>函数执行成功返回发送的字节数（可能小于 len），失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>该函数一般用于通过无连接的 SOCKET 接收数据报文，报文的发送者由 from 参数指定。</code></pre><h3 id="closesocket（）"><a href="#closesocket（）" class="headerlink" title="closesocket（）"></a>closesocket（）</h3><p>函数原型</p><pre><code>int closesocket (SOCKET s);</code></pre><p>参数</p><pre><code>s[in] 要关闭的 SOCKET。</code></pre><p>返回值</p><pre><code>函数执行成功返回 0，失败则返回 SOCKET_ERROR。这时可以调用WSAGetLastError 函数取得具体的错误代码。</code></pre><p>函数功能</p><pre><code>关闭指定的 SOCKET。</code></pre><h2 id="Winsock-2-0"><a href="#Winsock-2-0" class="headerlink" title="Winsock 2.0"></a>Winsock 2.0</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Winsock 1.1 原先设计的时候把API 限定在 TCP&#x2F;IP 的范畴里，它不象 Berkerly 模型那样支持多种协议。而 Winsock<br>2.0 正规化了一些其它的协议（如 ATM、IPX&#x2F;SPX 和DECNet 协议）的API。<br>Winsock 2.0 之所以能支持多种协议，是因为 Winsock 2.0 在 Windows Sockets DLL 和底层协议栈之间定义了一个<br>SPI（Service Provider Interface）接口，这样，通过一个 Windows Sockets DLL 可以同时访问底层不同厂商的协议栈。<br>Winsock 2.0 不仅允许多种协议栈的并存，而且从理论上讲，它还允许创造一个与网络协议无关的应用程序。Winsock<br>2.0 可以基于服务的需要透明地选择协议，应用程序可以适用于不同的网络名和网络地址。<br>Winsock 2.0 还扩展了它的API 函数集，当然 Winsock 2.0 是向下兼容的，可以把 Winsock 1.1 的代码原封不动地用在 Winsock 2.0 中。</p><h3 id="Winsock-2-0-新特性"><a href="#Winsock-2-0-新特性" class="headerlink" title="Winsock 2.0 新特性"></a>Winsock 2.0 新特性</h3><p>下面列出了一些 Winsock 2.0 的重要新特性：</p><ul><li>多重协议支持：SPI 接口使得新的协议可以被支持。</li><li>传输协议独立：根据服务提供不同的协议。</li><li>多重命名空间：根据需要的服务和解析的主机名选择协议。</li><li>分散和聚集： 从多个缓冲区接受和发送数据。</li><li>重叠 I&#x2F;O 和事件对象：增强吞吐量。</li><li>服务质量（Qos）：协商和跟踪网络带宽。</li><li>条件接受：可以选择性地决定是否接受连接。</li><li>Socket 共享：多个进程可以共享一个 SOKCKET 句柄。</li></ul><h3 id="Winsock-2-0-新增函数"><a href="#Winsock-2-0-新增函数" class="headerlink" title="Winsock 2.0 新增函数"></a>Winsock 2.0 新增函数</h3><p>下面列出了一些 Winsock 2.0 的重要新增函数：</p><ul><li><p>WSAAccept（）：accept（）函数的扩展版本，支持条件接受和套接字分组。</p></li><li><p>WASCloseEvent（）：释放一个时间对象。</p></li><li><p>WSAConnect（）：connect（）函数的扩展版本，支持连接数据交换和Qos 规范。</p></li><li><p>WSACreatEvent（）：创建一个事件对象。</p></li><li><p>WSADuplicateSocket（）：为一个共享套接字创建一个新的套接字。</p></li><li><p>WSAEnumNetworkEvents（）：检查是否有网络事件发生。</p></li><li><p>WSAEnumProtocols（）：得到每个可用的协议的信息。</p></li><li><p>WSAEventSelect（）：把一个网络事件和一个事件对象连接。</p></li><li><p>WSAGetOverlappedResu（）：得到重叠操作的完成状态。</p></li><li><p>WSAHtonl（）：htonl（）函数的扩展版本。</p></li><li><p>WSAHtons（）：htons（）函数的扩展版本。</p></li><li><p>WSAIoctl（）：ioctlsocket（）函数允许重叠操作的扩展版本。</p></li><li><p>WSANtohl（）：ntohl（）函数的扩展版本。</p></li><li><p>WSANtohs（）：ntohs（）函数的扩展版本。</p></li><li><p>WSARecv（）：recv（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSARecvDisconnect（）：终止套接字的接受操作。</p></li><li><p>WSARecvFrom（）：recvfrom（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSAResetEvent（）：重新初始化事件对象。</p></li><li><p>WSASend（）：send（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSARecvDisconnect（）：终止套接字的接受操作。</p></li><li><p>WSASendDisconnect（）：终止套接字的发送操作。</p></li><li><p>WSASendTo（）：sendto（）的扩展版本，支持分散&#x2F;聚集&#x2F;重叠 I&#x2F;O。</p></li><li><p>WSASetEvent（）：设置事件对象。</p></li><li><p>WSASocket（）：socket（）函数的扩展版本。它以一个 PROTOCOL_INFO 结构作为输入参数，并且允许创建重叠套接字，还允许创建套接字组。</p></li><li><p>WSAWaitForMultipleEvents（）：阻塞多个事件对象。</p></li></ul><p>关于这些函数的具体细节，请查阅 MSDN。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>在 tcp 的服务器端，有两类文件描述符</p><ul><li>监听的文件描述符<ul><li>只需要有一个</li><li>不负责和客户端通信，负责检测客户端的连接请求，检测到之后调用 accept 就可以建立新的连接</li></ul></li><li>通信的文件描述符<ul><li>负责和建立连接的客户端通信</li><li>如果有 N 个客户端和服务器建立了新的连接，通信的文件描述符就有 N 个，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul><p>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</p><ul><li>读数据: 通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</li><li>写数据: 通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</li></ul><p>监听的文件描述符:</p><ul><li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据，说明有新的客户端连接</li><li>调用 accept () 函数，这个函数会检测监听文件描述符的读缓冲区</li><li>检测不到数据，该函数阻塞</li><li>如果检测到数据，解除阻塞，新的连接建立</li></ul><p>通信的文件描述符:</p><ul><li>客户端和服务器端都有通信的文件描述符</li><li>发送数据：调用函数 write () &#x2F;send ()，数据进入到内核中<ul><li>数据并没有被发送出去，而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据，内核会将数据发送到网络中</li></ul></li><li>接收数据：调用的函数 read () &#x2F;recv (), 从内核读数据<ul><li>数据如何进入到内核程序猿不需要处理，数据进入到通信的文件描述符的读缓冲区中</li><li>数据进入到内核，必须使用通信的文件描述符，将数据从读缓冲区中读出即可</li></ul></li></ul><p>服务器端代码示例：</p><pre><code>// server.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    // 1. 创建监听的套接字    //基于TCP 所以选择流式协议    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if(lfd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 将socket()返回值和本地的IP端口绑定到一起    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址    // 这个宏可以代表任意一个IP地址    // 这个宏一般用于本地的绑定操作    addr.sin_addr.s_addr = INADDR_ANY;  // 这个宏的值为0 == 0.0.0.0    //inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = bind(lfd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;bind&quot;);        exit(0);    &#125;    // 3. 设置监听    ret = listen(lfd, 128);    if(ret == -1)    &#123;        perror(&quot;listen&quot;);        exit(0);    &#125;    // 4. 阻塞等待并接受客户端连接    struct sockaddr_in cliaddr;    int clilen = sizeof(cliaddr);    int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;clilen);    if(cfd == -1)    &#123;        perror(&quot;accept&quot;);        exit(0);    &#125;    // 打印客户端的地址信息    char ip[24] = &#123;0&#125;;    printf(&quot;客户端的IP地址: %s, 端口: %d\n&quot;,        inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, sizeof(ip)),ntohs(cliaddr.sin_port));    // 5. 和客户端通信    while(1)    &#123;        // 接收数据        char buf[1024];        memset(buf, 0, sizeof(buf));        int len = read(cfd, buf, sizeof(buf));        if(len &gt; 0)        &#123;            printf(&quot;客户端say: %s\n&quot;, buf);            write(cfd, buf, len);        &#125;        else if(len  == 0)        &#123;            printf(&quot;客户端断开了连接...\n&quot;);            break;        &#125;        else        &#123;            perror(&quot;read&quot;);            break;        &#125;    &#125;    close(cfd);    close(lfd);    return 0;&#125;</code></pre><p>客户端代码示例：</p><pre><code>// client.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123;    // 1. 创建通信的套接字    int fd = socket(AF_INET, SOCK_STREAM, 0);    if(fd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 连接服务器    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;connect&quot;);        exit(0);    &#125;    // 3. 和服务器端通信    int number = 0;    while(1)    &#123;        // 发送数据        char buf[1024];        sprintf(buf, &quot;你好, 服务器...%d\n&quot;, number++);        write(fd, buf, strlen(buf)+1);                // 接收数据        memset(buf, 0, sizeof(buf));        int len = read(fd, buf, sizeof(buf));        if(len &gt; 0)        &#123;            printf(&quot;服务器say: %s\n&quot;, buf);        &#125;        else if(len  == 0)        &#123;            printf(&quot;服务器断开了连接...\n&quot;);            break;        &#125;        else        &#123;            perror(&quot;read&quot;);            break;        &#125;        sleep(1);   // 每隔1s发送一条数据    &#125;    close(fd);    return 0;&#125;</code></pre><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li>accept()：如果服务器端没有新客户端连接，阻塞当前进程 &#x2F; 线程，如果检测到新连接解除阻塞，建立连接</li><li>read()：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程 &#x2F; 线程，检测到数据解除阻塞，接收数据</li><li>write()：如果通信的套接字写缓冲区被写满了，阻塞当前进程 &#x2F; 线程（这种情况比较少见）<br>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用 accept() 函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被 accept() 阻塞就无法通信，被 read() 阻塞就无法和客户端建立新连接。</li></ul><p>因此得出一个结论，基于上述处理方式，在单线程 &#x2F; 单进程场景下，服务器是无法处理多连接的，解决方案也有很多：</p><ul><li>使用多线程实现</li><li>使用多进程实现</li><li>使用 IO 多路转接（复用）实现</li><li>使用 IO 多路转接 + 多线程实现</li></ul><p>多进程并发<br>如果要编写多进程版的并发服务器程序，首先要考虑，创建出的多个进程都是什么角色，这样就可以在程序中对号入座了。在 Tcp 服务器端一共有两个角色，分别是：监听和通信，监听是一个持续的动作，如果有新连接就建立连接，如果没有新连接就阻塞。关于通信是需要和多个客户端同时进行的，因此需要多个进程，这样才能达到互不影响的效果。进程也有两大类：父进程和子进程，通过分析我们可以这样分配进程：</p><p>父进程：</p><ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用 accept() 函数</li><li>创建子进程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子进程资源：子进程退出回收其内核 PCB 资源，防止出现僵尸进程</li><li>子进程：负责通信，基于父进程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。</li><li>发送数据：send() &#x2F; write()</li><li>接收数据：recv() &#x2F; read()</li></ul><p>在多进程版的服务器端程序中，多个进程是有血缘关系，对应有血缘关系的进程来说，还需要想明白他们有哪些资源是可以被继承的，哪些资源是独占的，以及一些其他细节：</p><ul><li>子进程是父进程的拷贝，在子进程的内核区 PCB 中，文件描述符也是可以被拷贝的，因此在父进程可以使用的文件描述符在子进程中也有一份，并且可以使用它们做和父进程一样的事情。</li><li>父子进程有用各自的独立的虚拟地址空间，因此所有的资源都是独占的</li><li>为了节省系统资源，对于只有在父进程才能用到的资源，可以在子进程中将其释放掉，父进程亦如此。</li><li>由于需要在父进程中做 accept() 操作，并且要释放子进程资源，如果想要更高效一下可以使用信号的方式处理</li></ul><p>服务器端代码示例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;// 信号处理函数void callback(int num)&#123;    while(1)    &#123;        pid_t pid = waitpid(-1, NULL, WNOHANG);        if(pid &lt;= 0)        &#123;            printf(&quot;子进程正在运行, 或者子进程被回收完毕了\n&quot;);            break;        &#125;        printf(&quot;child die, pid = %d\n&quot;, pid);    &#125;&#125;int childWork(int cfd);int main()&#123;    // 1. 创建监听的套接字    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if(lfd == -1)    &#123;        perror(&quot;socket&quot;);        exit(0);    &#125;    // 2. 将socket()返回值和本地的IP端口绑定到一起    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(10000);   // 大端端口    // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址    // 这个宏可以代表任意一个IP地址    // 这个宏一般用于本地的绑定操作    addr.sin_addr.s_addr = INADDR_ANY;  // 这个宏的值为0 == 0.0.0.0    //    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);    int ret = bind(lfd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == -1)    &#123;        perror(&quot;bind&quot;);        exit(0);    &#125;    // 3. 设置监听    ret = listen(lfd, 128);    if(ret == -1)    &#123;        perror(&quot;listen&quot;);        exit(0);    &#125;    // 注册信号的捕捉    struct sigaction act;    act.sa_flags = 0;    act.sa_handler = callback;    sigemptyset(&amp;act.sa_mask);    sigaction(SIGCHLD, &amp;act, NULL);    // 接受多个客户端连接, 对需要循环调用 accept    while(1)    &#123;        // 4. 阻塞等待并接受客户端连接        struct sockaddr_in cliaddr;        int clilen = sizeof(cliaddr);        int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;clilen);        if(cfd == -1)        &#123;            if(errno == EINTR)            &#123;                // accept调用被信号中断了, 解除阻塞, 返回了-1                // 重新调用一次accept                continue;            &#125;            perror(&quot;accept&quot;);            exit(0);        &#125;        // 打印客户端的地址信息        char ip[24] = &#123;0&#125;;        printf(&quot;客户端的IP地址: %s, 端口: %d\n&quot;,            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, sizeof(ip)),            ntohs(cliaddr.sin_port));        // 新的连接已经建立了, 创建子进程, 让子进程和这个客户端通信        pid_t pid = fork();        if(pid == 0)        &#123;            // 子进程 -&gt; 和客户端通信            // 通信的文件描述符cfd被拷贝到子进程中            // 子进程不负责监听            close(lfd);            while(1)            &#123;                int ret = childWork(cfd);                if(ret &lt;=0)                &#123;                    break;                &#125;            &#125;            // 退出子进程            close(cfd);            exit(0);        &#125;        else if(pid &gt; 0)        &#123;            // 父进程不和客户端通信            close(cfd);        &#125;    &#125;    return 0;&#125;// 5. 和客户端通信int childWork(int cfd)&#123;    // 接收数据    char buf[1024];    memset(buf, 0, sizeof(buf));    int len = read(cfd, buf, sizeof(buf));    if(len &gt; 0)    &#123;        printf(&quot;客户端say: %s\n&quot;, buf);        write(cfd, buf, len);    &#125;    else if(len  == 0)    &#123;        printf(&quot;客户端断开了连接...\n&quot;);    &#125;    else    &#123;        perror(&quot;read&quot;);    &#125;    return len;&#125;</code></pre><h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。根据多进程的处理思路，就可以这样设计了：</p><p><strong>主线程：</strong></p><ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用 accept() 函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响 accept()，直接做线程分离即可。</li></ul><p><strong>子线程：</strong></p><ul><li><p>负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。</p></li><li><p>发送数据：send() &#x2F; write()</p></li><li><p>接收数据：recv() &#x2F; read()<br>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，下面来分析一些其中的一些细节：</p></li><li><p>同一地址空间中的多个线程的栈空间是独占的</p></li><li><p>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此需要注意数据覆盖问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。</p></li></ul><p>代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;struct SockInfo&#123;    int fd;                      // 通信    pthread_t tid;               // 线程ID    struct sockaddr_in addr;     // 地址信息&#125;;struct SockInfo infos[128];void* working(void* arg)&#123;    while(1)    &#123;        struct SockInfo* info = (struct SockInfo*)arg;        // 接收数据        char buf[1024];        int ret = read(info-&gt;fd, buf, sizeof(buf));        if(ret == 0)        &#123;            printf(&quot;客户端已经关闭连接...\n&quot;);            info-&gt;fd = -1;            break;        &#125;        else if(ret == -1)        &#123;            printf(&quot;接收数据失败...\n&quot;);            info-&gt;fd = -1;            break;        &#125;        else        &#123;            write(info-&gt;fd, buf, strlen(buf)+1);        &#125;    &#125;    return NULL;&#125;</code></pre><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p><p><strong>注：</strong><br>本文参照了苏丙榅的博客 链接: <a href="https://subingwen.cn/linux/concurrence/#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91">https://subingwen.cn/linux/concurrence/#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91</a><br>以及华中科技大学计算机网络与通信实验指导书</p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信与网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/p/c517589e.html"/>
      <url>/p/c517589e.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><pre><code class="bash">$ 并查集是一种树型的数据结构。</code></pre><h2 id="并查集的用途"><a href="#并查集的用途" class="headerlink" title="并查集的用途"></a>并查集的用途</h2><ol><li>处理不相交的集合的合并、查询问题。</li><li>检查一个图上面是否有一个环。<br>简单说就是先把每一个顶点放在一个独立的集合（树）里，如果顶点之间是邻接的那么就把他们合并为一个<br>集合（树）。一个集合（树）里有一个根结点，如果有两个顶点他们的根结点相同说明他们处于同一个集合<br>（树），那这两个结点邻接必定形成一个环（为什么？ 因n个顶点和n-1条边形成的连通图如果再加一条边<br>一定出现环）。如果他们的根结点不同，就把这两个集合合成一个集合。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>for(int i=1;i&lt;=n;i++)&#123;    father[i]=i;&#125;</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>非递归写法</strong></p><pre><code>int findFather(int x)&#123;    while(x!=father[x])&#123;        x=father[x];    &#125;    return x;&#125;</code></pre><p><strong>递归写法</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    return findfather(father[x]);&#125;</code></pre><p><strong>合并</strong></p><pre><code>void Union(int a,int b)&#123;    int faA =findFather(a);    int faB=findFather(b);    if(faA==faB)return ;    else&#123;        father[faA]=faB;    &#125;&#125;</code></pre><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>非递归写法：</strong></p><pre><code>int findFather(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        father[a]=x;        a=father[z];    &#125;    return x;&#125;</code></pre><p><strong>递归写法：</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    else&#123;        int F=findFather(father[x]);        father[x]=F;        return F;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/p/ea4681d0.html"/>
      <url>/p/ea4681d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h1><ul><li><p>Pre-Order Traversal ： 到达一个节点后，即刻输出该节点的值，并继续遍历其左右子树。                                VLR</p></li><li><p>In-Order Traversal  ：   到达一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。LVR</p></li><li><p>Post-Order Traversal:   到达一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。                          LRV</p></li></ul><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p><strong>递归实现</strong></p><pre><code>void preOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void preOrderTraverse2(node *root) &#123;    LinkedList&lt;node*&gt; stack = new LinkedList&lt;&gt;();    node *pNode = root;    while (pNode != nullptr || !stack.isEmpty()) &#123;        if (pNode != nullptr) &#123;            System.out.print(pNode.val+&quot;  &quot;);            stack.push(pNode);            pNode = pNode.left;        &#125;         else &#123; //pNode == nullptr &amp;&amp; !stack.isEmpty()            nodeNode node = stack.pop();            pNode = node.right;        &#125;    &#125;&#125;</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    printf(&quot;%d\n&quot;,root-&gt;data);    preOrder(root-&gt;rchild);&#125;</code></pre><p><strong>非递归实现</strong></p><pre><code>void inOrderTraverse(node *root)&#123;    if (root == nullptr)        return;    node *p = root;    stack&lt;node*&gt;s;    while (p != nullptr || !s.empty())    &#123;        while (p!=nullptr)        &#123;            s.push(p);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;             p = s.top();            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        //第二次遇见的时候输出            s.pop();            p = p-&gt;rchild;        &#125;    &#125;&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>递归实现</strong></p><pre><code>void postOrderTraverse(node *root)&#123;    if(root==nullptr)&#123;        return ;    &#125;    preOrder(root-&gt;lchild);    preOrder(root-&gt;rchild);    printf(&quot;%d\n&quot;,root-&gt;data);&#125;</code></pre><p><strong>非递归实现</strong><br>第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问。其右孩子还未被访问,所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是 否是第一次出现在栈顶。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == nullptr)        return;    stack&lt;node*&gt;s;    Binode p = root;    node tmp;    while (p!=nullptr || !s.empty())    &#123;        while (p != nullptr)            //沿左子树一直往下搜索，直至出现没有左子树的结点        &#123;            node btn = (node)malloc(sizeof(Node));            btn-&gt;btnode = p;            btn-&gt;isfirst = true;            s.push(btn);            p = p-&gt;lchild;        &#125;        if (!s.empty())        &#123;            tmp = s.top();            s.pop();            if (tmp-&gt;isfirst == true)    //第一次出现在栈顶            &#123;                tmp-&gt;isfirst = false;                s.push(tmp);                p = tmp-&gt;btnode-&gt;rchild;            &#125;            else                //第二次出现在栈顶            &#123;                cout &lt;&lt; tmp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;;                p = nullptr;            &#125;        &#125;    &#125;&#125;</code></pre><p>第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p><pre><code>void postOrderTraverse(node* root)&#123;    if (root == nullptr)        return;    stack&lt;node*&gt;s;    node* cur = root, *pre = nullptr;    s.push(root);    while (!s.empty())    &#123;        cur = s.top();        if ((cur-&gt;lchild == nullptr&amp;&amp;cur-&gt;rchild == nullptr) ||            ((pre == cur-&gt;lchild || pre == cur-&gt;rchild) &amp;&amp; pre != nullptr))        &#123;            cout &lt;&lt; cur-&gt;data &lt;&lt; &quot; &quot;;            s.pop();            pre = cur;        &#125;        else        &#123;            if (cur-&gt;rchild != nullptr)                s.push(cur-&gt;rchild);            if (cur-&gt;lchild != nullptr)                s.push(cur-&gt;lchild);        &#125;    &#125;&#125;</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><strong>非递归遍历</strong></p><pre><code>void layerOrderTraverse(node* root)&#123;    queue&lt;node*&gt; q;    q.push(root);    while(!q.empty())&#123;        node*now=q.front();        q.pop();        cout&lt;&lt; now-&gt;data&lt;&lt;endl;        if(now-&gt;lchild!=nullptr)q.push(now-&gt;lchild);        if(now-&gt;rchild!=nullptr)q.push(now-&gt;rchild);    &#125;&#125;</code></pre><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><pre><code>void DFS(node* root)&#123;    Stack&lt;node*&gt; nodeStack;    nodeStack.push(root);    while(!nodeStack.empty())    &#123;        root=nodeStack.top();        printf(format, root-&gt;data);        nodeStack.pop();        if(root-&gt;rChild)        &#123;            nodeStack.push(root-&gt;rChild);        &#125;        if(root-&gt;lChild)        &#123;            nodeStack.push(root-&gt;lChild);        &#125;            &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类</title>
      <link href="/p/8398734e.html"/>
      <url>/p/8398734e.html</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>传统C++的enum只要有作用域包含这个枚举类型，那么在这个作用域内这个枚举的变量名就生效了。即枚举量的名字泄露到了包含这个枚举类型的作用域内。在这个作用域内就不能有其他实体取相同的名字。所以在C++98中这个称之为不限范围的枚举型别</p><pre><code>enum Color&#123;black,white,red&#125;;    //black、white、red作用域和color作用域相同auto white = false;    //错误，white已经被声明过了</code></pre><h2 id="enum-class-的优点"><a href="#enum-class-的优点" class="headerlink" title="enum class 的优点"></a>enum class 的优点</h2><h3 id="防止命名空间污染"><a href="#防止命名空间污染" class="headerlink" title="防止命名空间污染"></a>防止命名空间污染</h3><p>enum class 将 { } 内的变量，加上 class 限制其在 { } 作用域内可见，是”域内枚举” (scoped enums)，可以防止命名空间污染</p><pre><code>// yellow, green, blue are scoped to Colorenum class Color &#123; yellow, green, blue&#125;;// fine, no other &quot;yellow&quot; in scopeauto yellow = false;// also fine　　auto c = Color::yellow;  </code></pre><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>传统的不限范围的枚举类是可以发生隐式转换的：</p><pre><code>enum Color&#123;black,white,red&#125;;std::vector&lt;std::size_t&gt; primeFactors(std::size_t x);    //函数返回x的质因数Color c = red;if(c &lt; 14.5)    //将color型别和double型别比较，发生隐式转换&#123;    auto factors = primeFactors(c);  //计算一个color型别的质因数，发生隐式转换&#125;</code></pre><p>限定作用域的枚举型别不允许发生任何隐式转换。如果非要转换，按就只能使用static_cast进行强制转换。</p><pre><code>enum class Color&#123;black,white,red&#125;;Color c = Color::red;if(c &lt; 14.5)    //错误，不能将枚举类和double进行比较&#123;    auto factors = primeFactors(c); //错误，Color不能转化为size_t型别&#125;</code></pre><h3 id="可以前置声明"><a href="#可以前置声明" class="headerlink" title="可以前置声明"></a>可以前置声明</h3><p>在不指定类型的情况下允许前置声明：</p><pre><code>enum Color;            //错误enum class Color;    //正确</code></pre><p>如果你想enum前置声明，则需要指定底层型别</p><pre><code>enum Color:std:uint8_t;    //提前指定底层型别，可以进行前置声明enum class Status:std::uint32_t&#123;        //在定义中设置底层型别    good = 0,    failed = 1,    incomplate = 100&#125;;</code></pre><h2 id="enum优点"><a href="#enum优点" class="headerlink" title="enum优点"></a>enum优点</h2><p>传统的enum并非被完全取代了，在一种情况下它还是具有优势，即需要引用C++11中的std::tuple型别的各个域时。</p><pre><code>//********文件A********//using UserInfo = std::tuple&lt;std::string, //名字            std::string //邮件            std::size_t&gt;; //声望值//********文件B*******//UserInfo uInfo;auto val = std::get&lt;1&gt;(uInfo);  //取用域1的值</code></pre><p>在上述代码中，在文件B中我们要取tuple中第二个值，但是如果第一次接触这段代码，很难知道这第2个值到底是什么意思。使用不限范围的枚举型别和域序数关联就可以消除这种问题：</p><pre><code>eunm UserInfoFields&#123;uiName,uiEmail,uiReputation&#125;;UserInfo uInfo;auto val = std::get&lt;uiEmail&gt;(uInfo);  //一目了然，要去邮件这个值</code></pre><p>以上代码能够运行的原理就是不限范围的枚举类型可以隐式转换。而使用enum class来定义的话，由于限定作用域的枚举类型不接受隐式转换，就要使用static_cast进行强转，整个代码会变得很啰嗦。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化方式</title>
      <link href="/p/814162d0.html"/>
      <url>/p/814162d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><p>c++初始化方式有很多种，例如</p><pre><code>int x(0);int y = 0;int z&#123;0&#125;;int u = &#123;0&#125;;//=&#123;&#125;通常按照上述&#123;&#125;方式处理</code></pre><p>对于非静态成员，可以用{}和&#x3D; 指定默认初始化值，但是不可以用()</p><pre><code>class Widget&#123;    ...private:     int x&#123;0&#125;;    int y = 0;    int z(0);//不可行！！！&#125;</code></pre><p>但是对于不可复制的对象（比如std::atomic类型的对象)可以采用大括号小括号，却不能用‘&#x3D;’<br>    std::atomic<int> ai1{0};<br>    std::atomic<int> ai2 &#x3D;0;&#x2F;&#x2F;不可行！！！<br>    std::atomic<int> ai3(0);</int></int></int></p><p>由此可见{}应用更为普适。但是{}禁止内建型别隐式窄化型别转换</p><pre><code>double x,y,z;...int sum = &#123;x+y+z&#125;;//不可行</code></pre><p>但是小括号和&#x3D;则可以窄化转换<br>    int sum(x+y+z);<br>    int sum &#x3D; x + y + z;</p><p>但是{}有个很大的问题，如果构造函数声明了任何一个具备std::initializer_list类型的形参，那么{}初始化语法的句子会优先匹配std::initializer_list对应的重载版本。</p><pre><code>class Widget&#123;public:    Widget(int i,bool j);    Widget(int i,double j);    Widget(std::initializer_list&lt;long double&gt;il);&#125;Widget w1(10,true);//调用第一个构造函数Widget w1&#123;10,true&#125;;//调用第三个构造函数Widget w3(10,3.0);//调用第二个构造函数Widget w4&#123;10,3.0&#125;;//调用第三个构造函数</code></pre><p>同理，复制或者移动构造函数都会被std::initializer_list型别的构造函数劫持。</p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;long double&gt; il);operator float() const;   // 支持隐式转换为float类型...&#125;;Widget w5(w4);    // 使用圆括号，调用拷贝构造函数Widget w6&#123;w4&#125;;   // 使用大括号，调用第三个构造函数                // 原因是先把w4转换为float，再把float转换为long dobuleWidget w7(std::move(m4));  // 使用圆括号，调用移动构造函数Widget w8&#123;std::move(m4)&#125;;  // 使用大括号，调用第三个构造函数，理由同w6</code></pre><p>编译器用带有std::initializer_list构造函数匹配大括号初始值的决心是<br>如此的坚定，就算带有std::initializer_list的构造函数是无法调用的：</p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;bool&gt; il);  // long double 改为 bool...&#125;;Widget w&#123;10, 5.0&#125;;  // 报错，因为发生范围窄化转换</code></pre><p>就算是这样，编译器也会忽略另外两个构造函数(第二个还是参数精确匹配的)，并且尝试调用带有std::initializer_list<bool>的构造函数。而调用第三个构造函数会让一个int(10)值和一个double(5.0)值转换为bool类型。这两个转换都是范围窄化转换(bool的大小不能准确描述它们的值)，然而窄化转换在大括号初始化语法中是被禁止的，所以这个函数调用无效，代码无法编译通过。</bool></p><p>只有当大括号内的值无法转换为std::initializer_list元素的类型时，编译器才会使用正常的重载选择方法，例如把上面的std::initializer_list<bool>改为std::initializer_list<a href="std::string">std::string</a>，那么那些非std::initializer_list构造函数会重新成为候选函数，因为没有办法从数值转换为std::string：</bool></p><pre><code>class Widget &#123;public:Widget(int i, bool b);Widget(int i, double d);Widget(std::initializer_list&lt;std::string&gt; il);  // bool 改为 std::string...&#125;;Widget w1(10, true);  // 使用圆括号，调用第一个构造函数Widget w2&#123;10, true&#125;;  // 使用大括号，不过调用第一个构造函数Widget w3(10, 5.0);   // 使用圆括号，调用第二个构造函数Widget w4&#123;10, 5.0&#125;;  // 使用大括号， 不过调用第二个构造函数</code></pre><p>这就会让编译器检查大括号内的初始值然后选择重载函数，不过这里有一个有趣的边缘情况。一个大括号内无参的构造函数，不仅可以表示默认构造，还可以表示带std::initializer_list的构造函数。你的空括号是表示哪一种情况呢？如果它表示不带参数，那么就是默认构造，如果它表示一个空的std::initializer_list，那么就是从一个不带元素的std::initializer_list进行构造。</p><p>正确答案是你将使用默认构造，一个空的大括号表示的是没有参数，而不是一个空的std::initializer_list：</p><pre><code>class Widget &#123;public:    Widget();    Widget(std::initializer_list&lt;int&gt; il);    ...&#125;;Widget w1;   // 调用默认构造函数Widget w2&#123;&#125;;   // 调用默认构造函数Widget w3();   // 出现most vexing parse，声明了一个函数</code></pre><p>如果你想要用一个空的std::initializer_list参数来调用带std::initializer_list构造函数，那么你需要把大括号作为参数，即把空的大括号放在圆括号内或者大括号内：</p><pre><code>Widget w4(&#123;&#125;);   // 用了一个空的list来调用带std::initializer_list构造函数Widget w5&#123;&#123;&#125;&#125;;   // 同上</code></pre><p>std::vector中有一个可以指定容器的大小和容器内元素的初始值的不带std::initializer_list构造函数，但它也有一个可以指定容器中元素值的带std::initializer_list函数。如果你想要创建一个数值类型的std::vector(例如std::vector)，然后你要传递两个值作为构造函数的参数，那么使用大括号与圆括号的行为是不同的：</p><pre><code>std::vector&lt;int&gt; v1(10, 20);   // 使用不带std::initializer_list的构造函数                        // 创建10个元素的vector，每个元素的值为20std::vector&lt;int&gt; v2&#123;10, 20&#125;;   // 使用带std::initializer_list的构造函数                        // 创建2个元素的vector，元素值为10和20</code></pre><p>我们先忽视std::vector和圆括号，大括号，构造函数重载规则。这次讨论不涉及两个要素。首先，作为一个类的作者，你需要知道如果你的构造函数集中包含一个带std::initializer构造函数，客户代码中使用了大括号初始化的话看起来好像只有带std::initializer构造函数。因此，你最好把构造函数设计得重载调用不受大括号和圆括号影响。换句话说，把上面std::vector出现的情况中当作错误，自己写代码时应该避免这样。</p><p>如果你的类一开始不含有带std::initializer_list构造函数，后来你加了一个，那么用户会发现，原理使用大括号初始化时选择的是不带std::initializer_list构造函数，而现在全部都选择带std::initializer_list构造函数。当然，这种事情在你为重载函数再添加一个实现时也有可能发生：本来是调用旧的重载函数可能会选择新加入的函数。不过std::initializer_list构造函数的不同之处是，带std::initializer_list构造函数不用与其它构造函数竞争，它直接遮蔽了其它的构造函数。所以加入带std::initializer_list需要深思熟虑。</p><p>你想通过随意的数值参数来创建一个数值类型对象。一个可变参数模板在概念上可以很直接的实现：</p><pre><code>template &lt;typename T, typename... Ts&gt;void doSomeWork(Ts&amp;&amp;... params)&#123;create local T object from params...  //伪代码...&#125;</code></pre><p>在伪代码中有两种选择：</p><pre><code>T localObject(std::forward&lt;Ts&gt;(params)...);    // 使用圆括号T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;;    // 使用大括号</code></pre><p>然后考虑以下代码：</p><pre><code>std::vector&lt;int&gt; v;...doSomeWork&lt;std::vector&lt;int&gt;&gt;(10,20);</code></pre><p>如果doSomeWork使用的是圆括号的方式创建对象，那么局部对象std::vector有10个元素。如果doSomeWork使用的是大括号的方式创建对象，那么局部对象std::vector只有2个元素。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树和B树的区别</title>
      <link href="/p/39914.html"/>
      <url>/p/39914.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户和权限</title>
      <link href="/p/56191.html"/>
      <url>/p/56191.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux用户和权限"><a href="#Linux用户和权限" class="headerlink" title="Linux用户和权限"></a>Linux用户和权限</h1><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><ul><li><code>-</code>符号是可选的，表示是否在切换用户后加载环境变量，建议带上</li><li>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</li><li>切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl + d</li></ul><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222035.png" alt="image-20221027222035337"></p><p>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</p><p>比如：</p><pre><code class="shell">itheima ALL=(ALL)       NOPASSWD: ALL</code></pre><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>Linux系统中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组中</li></ul><p>Linux中关于权限的管控级别有2个级别，分别是：</p><ul><li>针对用户的权限控制</li><li>针对用户组的权限控制</li></ul><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222354.png" alt="image-20221027222354498"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222407.png" alt="image-20221027222407618"></p><h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222446.png" alt="image-20221027222446514"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222512.png" alt="image-20221027222512274"></p></li></ul><h2 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h2><p>rwx到底代表什么</p><ul><li>r表示读权限</li><li>w表示写权限</li><li>x表示执行权限</li></ul><p>针对文件、文件夹的不同，rwx的含义有细微差别</p><ul><li>r，针对文件可以查看文件内容<ul><li>针对文件夹，可以查看文件夹内容，如ls命令</li></ul></li><li>w，针对文件表示可以修改此文件<ul><li>针对文件夹，可以在文件夹内：创建、删除、改名等操作</li></ul></li><li>x，针对文件表示可以将文件作为程序执行<ul><li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li></ul></li></ul><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。<br>注意，只有文件、文件夹的所属用户或root用户可以修改。</p><p>修改文件、文件夹权限<br>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222157.png" alt="image-20221027222157276"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222326.png" alt="image-20221027222326192"></p><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/p/13375.html"/>
      <url>/p/13375.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><h2 id="万能的帮助命令"><a href="#万能的帮助命令" class="headerlink" title="万能的帮助命令"></a>万能的帮助命令</h2><p>man 是manual的缩写</p><pre><code>man lsman manman 7 conmandsman -a conmands</code></pre><p>help帮助</p><pre><code>help cd 内部命令ls  --help  外部命令可以通过type cd获取外部命令还是内部命令</code></pre><p>info 帮助</p><pre><code>info lsinfo帮助比help更加详细，不过是全英文</code></pre><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录，以平铺的方式列出当前工作目录下的内容</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小，单独使用无用</li><li>-a，显示隐藏文件</li></ul><p>ls -l -a<br>ls -a -l<br>ls -la<br>ls -al<br>以上写法等价</p><h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录(change directory)</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径,必填可以使用绝对路径，相对路径</li><li>选项：-p，可选，表示创建前置路径，创建连续的层级目录（多个文件夹）<ul><li>mkdir .&#x2F;2&#x2F;3&#x2F;4 前置的2，3目录不存在则会报错</li><li>加上-p 即可执行</li></ul></li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li><li><code>回车</code>一行一行看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的文件或者文件夹，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><p>rm命令支持通配符 *，用来做模糊匹配</p><ul><li>符号* 表示通配符，即匹配任意内容（包含空），示例：</li><li>test*，表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li><em>test</em>，表示匹配任何包含test的内容</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><p>如下命令，请千万千万不要在root管理员用户下执行：</p><ul><li>rm -rf &#x2F;</li><li>rm -rf &#x2F;*</li><li>效果等同于在Windows上执行C盘格式化。</li></ul><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径，</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*匹配任意内容（包含空）， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><p>示例：</p><ul><li>test*，表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li><em>test</em>，表示匹配任何包含test的内容</li></ul><p>基于通配符的含义，可以结合find命令做文件的模糊查询。</p><p>语法2按文件大小搜索：<code>find 起始路径 -size +|-n[KMG]</code></p><ul><li>+、- 表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li></ul><p>示例：</p><ul><li>查找小于10KB的文件： find &#x2F; -size -10k</li><li>查找大于100MB的文件：find &#x2F; -size +100M</li><li>查找大于1GB的文件：find &#x2F; -size +1G</li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="96-反引号"><a href="#96-反引号" class="headerlink" title="&#96;反引号"></a>&#96;反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-f，持续跟踪文件修改，随时更新其他终端对于文件的更改ctrl+c退出</li><li>-4 查看尾部四行</li></ul><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221906.png" alt="image-20221027221906247"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221939.png" alt="image-20221027221939899"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件管理</title>
      <link href="/p/26649.html"/>
      <url>/p/26649.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h1><h2 id="常见目录介绍"><a href="#常见目录介绍" class="headerlink" title="常见目录介绍"></a>常见目录介绍</h2><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。</td></tr><tr><td>&#x2F;home</td><td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示</td></tr><tr><td>&#x2F;usr</td><td>用于存放系统应用程序，比较重要的目录 &#x2F;usr&#x2F;local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。 &#x2F;usr&#x2F;x11r6 存放x window的目录 &#x2F;usr&#x2F;bin 众多的应用程序 &#x2F;usr&#x2F;sbin 超级用户的一些管理程序 &#x2F;usr&#x2F;doc linux文档 &#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件 &#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件 &#x2F;usr&#x2F;man 帮助文档 &#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里 &#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令 &#x2F;usr&#x2F;local&#x2F;lib 本地增加的库</td></tr><tr><td>&#x2F;opt</td><td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td></tr><tr><td>&#x2F;proc</td><td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td></tr><tr><td>&#x2F;root</td><td>超级用户（系统管理员）的主目录（特权阶级^o^）</td></tr><tr><td>&#x2F;sbin</td><td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td></tr><tr><td>&#x2F;dev</td><td>用于存放设备文件。</td></tr><tr><td>&#x2F;mnt</td><td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td></tr><tr><td>&#x2F;boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>&#x2F;lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td></tr><tr><td>&#x2F;tmp</td><td>用于存放各种临时文件，是公用的临时文件存储点。</td></tr><tr><td>&#x2F;var</td><td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td></tr><tr><td>&#x2F;lost+found</td><td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td></tr><tr><td>&#x2F;etc</td><td>配置文件目录</td></tr></tbody></table><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>pwd 显示当前所在目录名称</p><p>ls 列举当前文件名下的所有文件</p><ul><li>ls后面可以加多个文件路径</li><li>ls -l长格式显示 文件类型权限 文件夹内文件个数 创建用户 用户组 大小 最后修改时间 文件名</li><li>ls -a 显示隐藏文件&#x2F;文件夹</li><li>ls -r 逆向排序</li><li>ls -t 按照时间排序</li><li>ls -R 递归显示</li><li>命令选项可以合并使用 例如 ls -l -a -r &#x3D;&#x3D;&#x3D; ls -lar</li></ul><p>cd 更改当前的操作目录</p><ul><li>cd &#x2F;绝对目录</li><li>cd .&#x2F;相对路径</li><li>cd ..&#x2F; 上一级目录</li><li>cd - 回到刚才目录</li></ul><p>mkdir 创建目录</p><ul><li>mkdir &#x2F;a </li><li>mkdir b c d</li><li>目录已存在则创建失败</li><li>mkdir -p &#x2F;a&#x2F;b&#x2F;c 创建多级目录</li></ul><p>rmdir 只能删除空白目录</p><ul><li>rm -r &#x2F;a 需要确认目录内内容</li><li>rm -r -f 不进行提示</li></ul><p>cp 复制文件和目录</p><ul><li>cp  a  &#x2F;tmp</li><li>cp  -r  b  &#x2F;tmp  复制目录加-r</li><li>cp -p 保留原有创建时间</li><li>cp -a 保留原有组和权限</li></ul><p>mv 移动文件 </p><ul><li>mv filea  fileb 重命名</li><li>mv filea  &#x2F;tmp&#x2F;filea 移动</li><li>mv * &#x2F;tmp </li><li>可以使用通配符* ？ 匹配多个字母 单个字母</li></ul><p>文本查看命令 </p><ul><li>cat 文本显示在终端</li><li>head -5 查看文件开头</li><li>tail -3 查看结尾文件</li><li>tail -f 跟踪查看结尾文件</li><li>wc -l 查看文件多少行</li><li>more&#x2F;less  分行显示</li></ul><h2 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h2><p>打包+压缩<br>打包 tar</p><ul><li>c 打包</li><li>x 解包</li><li>f 指定操作类型为文件</li><li>tar cf &#x2F;test.tar  &#x2F;etc 把etc打包成test.tar</li></ul><p>gzip  bzip2进行压缩</p><p>可以同时打包压缩</p><ul><li>tar czf &#x2F;test.tar.gz  &#x2F;etc </li><li>tar cjf &#x2F;test.tar.bz2  &#x2F;etc</li></ul><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><p>实例：</p><ul><li><p>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</p></li><li><p>ln -s &#x2F;etc&#x2F;yum ~&#x2F;yum</p><h2 id="文本编辑器-vi"><a href="#文本编辑器-vi" class="headerlink" title="文本编辑器 vi"></a>文本编辑器 vi</h2><p>vi 进入到vi编辑器  vim是vi向上兼容的版本</p></li><li><p>命令模式（Command mode）</p><ul><li>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。此模型下，不能自由进行文本编辑。</li></ul></li><li><p>输入模式（Insert mode）</p><ul><li>也就是所谓的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。</li></ul></li><li><p>底线命令模式（Last line mode）</p><ul><li>以：开始，通常用于文件的保存、退出。</li></ul></li></ul><p>vim兼容全部的vi功能，后续全部使用vim命令</p><ul><li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li><li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li><li><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3></li></ul><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png" alt="image-20221027215841573"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png" alt="image-20221027215846581"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png" alt="image-20221027215849668"></p><h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png" alt="image-20221027215858967"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/p/226.html"/>
      <url>/p/226.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池定义"><a href="#线程池定义" class="headerlink" title="线程池定义"></a>线程池定义</h2><ul><li>首先，线程池往往不需要反复创建，所以采用了<a href="https://whl963854.github.io/p/46132.html">单例模式</a></li><li>线程池需要提供几个接口：<ul><li>static XThreadPool* Get() 获取线程池对象</li><li>void init(int threadCount);  初始化函数，需要指定线程池大小</li><li>void dispatch(XTask* task);  分发任务函数，需要将任务轮询分配给相应线程</li></ul></li><li>线程池基于libevent做的（相关资料待整理）</li></ul><p>具体类定义如下：</p><pre><code>#ifndef XTHREAD_POOL_H#define XTHREAD_POOL_H#include &lt;vector&gt;class XThread;class XTask;class XThreadPool&#123;public:    static XThreadPool* Get()    &#123;        static XThreadPool p;        return &amp;p;    &#125;    void init(int threadCount);    void dispatch(XTask* task);    XThreadPool() &#123;&#125;;private:    ///线程数量    int m_threadCount = 0;    ///上一次分发得到线程，用于轮询    int m_lastThread = -1;    ///线程池线程队列    std::vector&lt;XThread*&gt;m_threads;&#125;;#endif //XTHREAD_POOL_H</code></pre><h3 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h3><p>初始化所有线程并启动线程</p><pre><code>void XThreadPool::init(int threadCount)&#123;    this-&gt;m_threadCount = threadCount;    this-&gt;m_lastThread = -1;    for (int i = 0; i &lt; threadCount; i++)    &#123;        XThread* t = new XThread();        t-&gt;setId(i + 1);        cout &lt;&lt; &quot;Create thread &quot; &lt;&lt; i &lt;&lt; endl;        //启动线程        t-&gt;start();        m_threads.push_back(t);        this_thread::sleep_for(10ms);    &#125;&#125;</code></pre><h3 id="分发线程"><a href="#分发线程" class="headerlink" title="分发线程"></a>分发线程</h3><p>分发策略采取轮询的方式，可以设计更好的方式，相对轮询是最简单的<br>主线程分发不会产生问题，不需要加锁，暂时不考虑多线程分发，如有需要再进行更改</p><pre><code>void XThreadPool::dispatch(XTask* task)&#123;    //轮询    if (task==nullptr)return;    int tid = (m_lastThread + 1) % m_threadCount;    m_lastThread = tid;    XThread* t = m_threads[tid];    t-&gt;addTask(task);    //激活线程    t-&gt;activate();&#125;</code></pre><h3 id="对应实现完整代码"><a href="#对应实现完整代码" class="headerlink" title="对应实现完整代码"></a>对应实现完整代码</h3><pre><code>#ifndef XTHREAD_POOL_CPP#define XTHREAD_POOL_CPP#include &quot;xthreadpool.h&quot;#include &quot;xthread.h&quot;#include &lt;thread&gt;#include &lt;iostream&gt;#include &quot;xtask.h&quot;using namespace std;//分发线程void XThreadPool::dispatch(XTask* task)&#123;    //轮询    if (task==nullptr)return;    int tid = (m_lastThread + 1) % m_threadCount;    m_lastThread = tid;    XThread* t = m_threads[tid];    t-&gt;addTask(task);    //激活线程    t-&gt;activate();&#125;//初始化所有线程并启动线程void XThreadPool::init(int threadCount)&#123;    this-&gt;m_threadCount = threadCount;    this-&gt;m_lastThread = -1;    for (int i = 0; i &lt; threadCount; i++)    &#123;        XThread* t = new XThread();        t-&gt;setId(i + 1);        cout &lt;&lt; &quot;Create thread &quot; &lt;&lt; i &lt;&lt; endl;        //启动线程        t-&gt;start();        m_threads.push_back(t);        this_thread::sleep_for(10ms);    &#125;&#125;#endif //XTHREAD_POOL_CPP</code></pre><h2 id="线程函数定义"><a href="#线程函数定义" class="headerlink" title="线程函数定义"></a>线程函数定义</h2><ul><li>线程需要提供以下接口： <ul><li>void start();  启动线程函数</li><li>void entry();  线程入口函数</li><li>bool setUp();  线程安装函数</li><li>void activate();        线程激活函数</li><li>void addTask(XTask *t); 添加任务函数</li><li>void notify(int fd, short which);   收到主线程发出的激活消息处理函数</li></ul></li></ul><p>具体线程类定义如下：</p><pre><code>#ifndef XTHREAD_H#define XTHREAD_H#include &lt;list&gt;#include &lt;mutex&gt;class XTask;class XThread&#123;public:    int getId();    void setId(int id);    //启动线程    void start();    //线程入口函数    void entry();    //安装线程，初始化event_base和管道监听事件用于激活    bool setUp();    //收到主线程发出的激活消息（线程池的分发）    void notify(int fd, short which);    //线程激活    void activate();    //添加处理的任务，一个线程同时可以处理多个任务，共用一个event_base    void addTask(XTask *t);    XThread();    ~XThread();private:    //线程编号    int m_id = 0;    int m_notifyFd = 0;    struct event_base *m_base = 0;    //任务列表    std::list&lt;XTask*&gt; m_tasks;    //线程安全 互斥    std::mutex m_tasksMux;&#125;;#endif</code></pre><h3 id="启动线程函数"><a href="#启动线程函数" class="headerlink" title="启动线程函数"></a>启动线程函数</h3><p>启动线程，线程启动需要初始化安装，同时需要与主线程断开联系，否则线程运行后会被释放</p><pre><code>void XThread::start()&#123;    setUp();    //启动线程    thread th(&amp;XThread::entry,this);    //断开与主线程联系    th.detach();&#125;</code></pre><h3 id="线程入口函数"><a href="#线程入口函数" class="headerlink" title="线程入口函数"></a>线程入口函数</h3><p>线程入口函数需要开启event_base_dispatch()事件循环，event_base_dispatch()内部调用的event_base_loop，event_base_loop内部是一个while循环，所以调用event_base_dispatch()的线程是阻塞的，除非调用了event_base_loopbreak() 或者 event_base_loopexit()才会退出<br>理论上除非主程序退出，不然线程池不需要释放线程</p><pre><code>void XThread::entry()&#123;    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() begin&quot; &lt;&lt; endl;    if (!m_base)    &#123;        cerr &lt;&lt; &quot;XThread::Main faield! m_base is null &quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;In windows set WSAStartup(MAKEWORD(2, 2), &amp;wsa)&quot; &lt;&lt; endl;        return;    &#125;    //  This loop will run the event base until either there are no more pending or    //    active, or until something calls event_base_loopbreak() or    //    event_base_loopexit().    event_base_dispatch(m_base);    event_base_free(m_base);    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() end&quot; &lt;&lt; endl;&#125;</code></pre><h3 id="线程安装函数"><a href="#线程安装函数" class="headerlink" title="线程安装函数"></a>线程安装函数</h3><p>安装线程，初始化event_base</p><pre><code>bool XThread::setUp()&#123;    //windows用配对socket     //创建一个socketpair 可以互相通信 fds[0] 读 fds[1]写 类似于管道    evutil_socket_t fds[2];    if (evutil_socketpair(AF_INET, SOCK_STREAM, 0, fds) &lt; 0)    &#123;        cout &lt;&lt; &quot;evutil_socketpair failed!&quot; &lt;&lt; endl;        return false;    &#125;    //设置成非阻塞    evutil_make_socket_nonblocking(fds[0]);    evutil_make_socket_nonblocking(fds[1]);    //读取绑定到event事件中，写入要保存    m_notifyFd = fds[1];    //创建libevent上下文（无锁）    event_config *ev_conf = event_config_new();    event_config_set_flag(ev_conf, EVENT_BASE_FLAG_NOLOCK);    this-&gt;m_base = event_base_new_with_config(ev_conf);    event_config_free(ev_conf);    if (!m_base)    &#123;        cerr &lt;&lt; &quot;event_base_new_with_config failed in thread!&quot; &lt;&lt; endl;        return false;    &#125;    //添加管道监听事件，用于激活线程执行任务    //EV_READ  只要网络缓冲中还有数据，回调函数就会被触发；    //EV_PERSIST  不指定这个属性，回调函数被触发后事件会被删除；    event *ev = event_new(m_base, fds[0], EV_READ | EV_PERSIST, notifyCB, this);    //函数参数ev是指向要注册的事件，tv是超时时间，    event_add(ev, 0);    return true;&#125;</code></pre><h3 id="线程激活函数"><a href="#线程激活函数" class="headerlink" title="线程激活函数"></a>线程激活函数</h3><p>线程激活，发送信号，由消息处理函数进行处理激活后的内容</p><pre><code>void XThread::activate()&#123;    int re = send(this-&gt;m_notifyFd, &quot;c&quot;, 1, 0);    if (re &lt;= 0)    &#123;        cerr &lt;&lt; &quot;XThread::Activate() failed!&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="添加任务函数"><a href="#添加任务函数" class="headerlink" title="添加任务函数"></a>添加任务函数</h3><p>目前只有一个线程池，并且只有线程池才会分发任务，暂时不会涉及到多线程</p><pre><code>void XThread::addTask(XTask *t)&#123;    if (t==nullptr)return;    t-&gt;setBase(this-&gt;m_base);    //m_tasksMux.lock();    m_tasks.push_back(t);    //m_tasksMux.unlock();&#125;</code></pre><h3 id="收到主线程发出的激活消息处理函数"><a href="#收到主线程发出的激活消息处理函数" class="headerlink" title="收到主线程发出的激活消息处理函数"></a>收到主线程发出的激活消息处理函数</h3><p>回调函数必须是static，因为成员函数默认有一个this指针参数，导致回调函数参数不匹配，而静态函数没有this指针，没有这个问题。如果采用普通函数则会破坏函数封装性，破坏面向对象设计方式。<br>线程分发后回调函数多线程并行执行，有可能会导致问题，所以需要加上锁保护函数<br>这里任务类需要统一实现init函数</p><pre><code>static void notifyCB(int fd, short which, void *arg)&#123;    XThread *t = (XThread *)arg;    t-&gt;notify(fd, which);&#125;void XThread::notify(int fd, short which)&#123;    //水平触发 只要没有接受完成，会再次进来    char buf[2] = &#123; 0 &#125;;    int re = recv(fd, buf, 1, 0);    if (re &lt;= 0)        return;    cout &lt;&lt; m_id &lt;&lt; &quot; thread &quot; &lt;&lt; buf &lt;&lt; endl;    XTask *task = nullptr;    //获取任务，并初始化任务    m_tasksMux.lock();    if (m_tasks.empty())    &#123;        m_tasksMux.unlock();        return;    &#125;    task = m_tasks.front(); //先进先出    m_tasks.pop_front();    m_tasksMux.unlock();    task-&gt;init();&#125;</code></pre><h3 id="线程完整函数定义"><a href="#线程完整函数定义" class="headerlink" title="线程完整函数定义"></a>线程完整函数定义</h3><pre><code>#ifndef XTHREAD_CPP#define XTHREAD_CPP#include &quot;xthread.h&quot;#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;event2/event.h&gt;#include &quot;xtask.h&quot;using namespace std;//激活线程任务的回调函数static void notifyCB(int fd, short which, void *arg)&#123;    XThread *t = (XThread *)arg;    t-&gt;notify(fd, which);&#125;void XThread::notify(int fd, short which)&#123;    //水平触发 只要没有接受完成，会再次进来    char buf[2] = &#123; 0 &#125;;    int re = recv(fd, buf, 1, 0);    if (re &lt;= 0)        return;    cout &lt;&lt; m_id &lt;&lt; &quot; thread &quot; &lt;&lt; buf &lt;&lt; endl;    XTask *task = nullptr;    //获取任务，并初始化任务    m_tasksMux.lock();    if (m_tasks.empty())    &#123;        m_tasksMux.unlock();        return;    &#125;    task = m_tasks.front(); //先进先出    m_tasks.pop_front();    m_tasksMux.unlock();    task-&gt;init();&#125;void XThread::addTask(XTask *t)&#123;    if (t==nullptr)return;    t-&gt;setBase(this-&gt;m_base);    m_tasksMux.lock();    m_tasks.push_back(t);    m_tasksMux.unlock();&#125;//线程激活void XThread::activate()&#123;    int re = send(this-&gt;m_notifyFd, &quot;c&quot;, 1, 0);    if (re &lt;= 0)    &#123;        cerr &lt;&lt; &quot;XThread::Activate() failed!&quot; &lt;&lt; endl;    &#125;&#125;//启动线程void XThread::start()&#123;    setUp();    //启动线程    thread th(&amp;XThread::entry,this);    //断开与主线程联系    th.detach();&#125;//安装线程，初始化event_basebool XThread::setUp()&#123;    //windows用配对socket     //创建一个socketpair 可以互相通信 fds[0] 读 fds[1]写     evutil_socket_t fds[2];    if (evutil_socketpair(AF_INET, SOCK_STREAM, 0, fds) &lt; 0)    &#123;        cout &lt;&lt; &quot;evutil_socketpair failed!&quot; &lt;&lt; endl;        return false;    &#125;    //设置成非阻塞    evutil_make_socket_nonblocking(fds[0]);    evutil_make_socket_nonblocking(fds[1]);    //读取绑定到event事件中，写入要保存    m_notifyFd = fds[1];    //创建libevent上下文（无锁）    event_config *ev_conf = event_config_new();    event_config_set_flag(ev_conf, EVENT_BASE_FLAG_NOLOCK);    this-&gt;m_base = event_base_new_with_config(ev_conf);    event_config_free(ev_conf);    if (!m_base)    &#123;        cerr &lt;&lt; &quot;event_base_new_with_config failed in thread!&quot; &lt;&lt; endl;        return false;    &#125;    //添加管道监听事件，用于激活线程执行任务    //EV_READ  只要网络缓冲中还有数据，回调函数就会被触发；    //EV_PERSIST  不指定这个属性，回调函数被触发后事件会被删除；    event *ev = event_new(m_base, fds[0], EV_READ | EV_PERSIST, notifyCB, this);    event_add(ev, 0);    return true;&#125;//线程入口函数void XThread::entry()&#123;    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() begin&quot; &lt;&lt; endl;    if (!m_base)    &#123;        cerr &lt;&lt; &quot;XThread::Main faield! m_base is null &quot; &lt;&lt; endl;        cerr &lt;&lt; &quot;In windows set WSAStartup(MAKEWORD(2, 2), &amp;wsa)&quot; &lt;&lt; endl;        return;    &#125;    //  This loop will run the event base until either there are no more pending or    //    active, or until something calls event_base_loopbreak() or    //    event_base_loopexit().    event_base_dispatch(m_base);    event_base_free(m_base);    cout &lt;&lt; m_id &lt;&lt; &quot; XThread::Main() end&quot; &lt;&lt; endl;&#125;XThread::XThread()&#123;&#125;XThread::~XThread()&#123;&#125;int XThread::getId()&#123;    return m_id;&#125;void XThread::setId(int id)&#123;    m_id = id;&#125;#endif //XTHREAD_CPP</code></pre><h2 id="任务接口定义"><a href="#任务接口定义" class="headerlink" title="任务接口定义"></a>任务接口定义</h2><p>为线程提供一个所需执行任务的接口类，任何需要使用线程池的函数都需要继承这个接口，实现接口函数。<br>这里可以不需要相关sock等成员，只需要提供一个init 函数即可 ，但是如果需要执行网络交互则必须有相应成员变量</p><pre><code>#ifndef XTASK_H#define XTASK_Hclass XTask&#123;public:    //初始化任务    virtual bool init() = 0;    int getThreadId() &#123; return m_threadId; &#125;    void setThreadId(int getThreadId) &#123; m_threadId = getThreadId; &#125;    int getSock() &#123; return m_sock; &#125;    void setSock(int getSock) &#123; this-&gt;m_sock = getSock; &#125;    struct event_base* getBase() &#123; return m_base; &#125;    void setBase(struct event_base* getBase) &#123; this-&gt;m_base = getBase; &#125;private:    struct event_base* m_base = 0;    int m_sock = 0;    int m_threadId = 0;&#125;;#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/p/0.html"/>
      <url>/p/0.html</url>
      
        <content type="html"><![CDATA[<p>多进程并发<br>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也造就了多进程并发的两个缺点：</p><p>在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。<br>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。<br>当多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发并不是一个好的选择。所以就引入了多线程的并发。</p><p>多线程并发<br>多线程并发指的是在同一个进程中执行多个线程。</p><p>优点：有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。</p><p>缺点：由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/p/28384.html"/>
      <url>/p/28384.html</url>
      
        <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote><p>想着凭自己理解去面试而不背面经只会一败涂地 初面挂后感</p></blockquote><h2 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h2><ul><li>互斥条件<ul><li>临界资源是独占资源，进程应互斥且排他的使用这些资源。</li></ul></li><li>占有和等待条件<ul><li>进程在请求资源得不到满足而等待时，不释放已占有资源。</li></ul></li><li>不剥夺条件<ul><li>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</li></ul></li><li>循环等待条件<ul><li>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li></ul></li></ul><h2 id="死锁解决的方法"><a href="#死锁解决的方法" class="headerlink" title="死锁解决的方法"></a>死锁解决的方法</h2><p>主要有一下三种方法：</p><ul><li>死锁防止</li><li>死锁避免</li><li>死锁检测和恢复</li></ul><h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p><strong>破坏互斥条件</strong><br>使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。<br>只读数据文件、磁盘等软硬件资源均可采用这种办法管理；<br>但是许多资源是独占性资源，如可写文件、键盘等只能互斥的占有；<br>所以这种做法在许多场合是不适用的。</p><p><strong>破坏占有和等待条件</strong><br>采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。<br>实现简单，但是严重的减低了资源利用率。<br>因为在每个进程占有的资源中，有些资源在运行后期使用，有些资源在例外情况下才被使用，可能会造成进程占有一些几乎用不到的资源，而使其他想使用这些资源的进程等待。</p><p><strong>破坏不剥夺条件</strong><br>剥夺调度能够防止死锁，但是只适用于内存和处理器资源。</p><ul><li>方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。</li><li>方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。</li></ul><p><strong>破坏循环等待条件</strong><br>给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。<br>采用层次分配策略，将系统中所有的资源排列到不同层次中<br>一个进程得到某层的一个资源后，只能申请较高一层的资源<br>当进程释放某层的一个资源时，必须先释放所占有的较高层的资源<br>当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源</p><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。<br>在程序运行时避免发生死锁。<br><strong>单个资源的银行家算法</strong><br>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。<br>注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。<br>检查一个状态是否安全的算法如下：<br>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。<br>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。<br>重复以上两步，直到所有进程都标记为终止，则状态时安全的。<br>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>对资源的分配加以适当限制可防止或避免死锁发生，但不利于进程对系统资源的充分共享。<br>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ul><li>如果进程 - 资源分配图中无环路，此时系统没有发生死锁。</li><li>如果进程 - 资源分配图中有环路，则可分为以下两种情况：<ul><li>每种资源类中仅有一个资源，则系统发生了死锁。此时，环路是系统发生死锁的充分必要条件，环路中的进程就是死锁进程。</li><li>每种资源类中有多个资源，则环路的存在只是产生死锁的必要不充分条件，系统未必会发生死锁。</li></ul></li></ul><p><strong>每种资源类中仅有一个资源的死锁检测</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>每种资源类中有多个资源的死锁检测</strong></p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><p>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>如果没有这样一个进程，算法终止。</p><h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><ul><li>资源剥夺法<ul><li>剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</li></ul></li><li>进程回退法<ul><li>根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</li></ul></li><li>进程撤销法<ul><li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li><li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li><li>可选择符合下面条件之一的先撤销： <ul><li>CPU消耗时间最少者</li><li>产生的输出量最小者</li><li>预计剩余执行时间最长者 </li><li>分得的资源数量最少者或优先级最低者</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志类型</title>
      <link href="/p/41558.html"/>
      <url>/p/41558.html</url>
      
        <content type="html"><![CDATA[<h1 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h1><p>MySQL中有七种日志文件，分别是：</p><ul><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>二进制日志（binlog）</li><li>错误日志（errorlog）</li><li>慢查询日志（slow query log）</li><li>通用查询日志（general log）</li><li>中继日志（relay log）</li></ul><h2 id="undo-log-和-redo-log"><a href="#undo-log-和-redo-log" class="headerlink" title="undo log 和 redo log"></a>undo log 和 redo log</h2><p>undo log 和 redo log 其实都不是 MySQL 数据库层面的日志，而是 InnoDB 存储引擎的日志。二者的作用联系紧密，事务的隔离性由锁来实现，原子性、一致性、持久性通过数据库的 redo log 或 redo log 来完成。redo log 又称为重做日志，用来保证事务的持久性，undo log 用来保证事务的原子性和 MVCC。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存Buffer Pool。这个缓存中包含了磁盘中部分数据页（page）的映射，以此来缓解数据库的磁盘压力。<br>当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为脏页，Buffer Pool中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为刷脏页。如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时Buffer Pool中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。</p><p>为了解决这个问题引入了redo log，redo Log它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。和大多数关系型数据库一样，InnoDB 记录了对数据文件的物理更改，并保证总是日志先行，在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。由于 redo log 是顺序整块写入，所以性能要更好。redo log 的存储都是以块(block)为单位进行存储的，每个块的大小为 512 字节。同磁盘扇区大小一致，可以保证块的写入是原子操作。另外 redo log 占用的空间是固定的，会循环写入。文件大小由innodb_log_file_size参数控制。</p><p>重做日志两部分组成：一是内存中的重做日志缓冲(redo log buffer)，是易失的；二是重做日志文件(redo log file)，是持久的。redo log 记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。</p><p>在一条语句进行执行的时候，InnoDB 引擎会把新记录写到 redo log 日志中，然后更新内存，更新完成后就算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将 redo log 中的内容更新到磁盘中。</p><p>更详细的步骤，需要了解两个关键词：checkpoint 和 LSN(Log Sequence Number)，前者检查点简单来说就是把脏页刷到磁盘的时间点，这个时间点之前的数据都已经保存到了持久存储。而 LSN 是 InnoDB 使用的一个版本标记的计数，它是一个单调递增的值。数据页和 redo log 都有各自的 LSN。每次把 redo log 中的内容写入到实际的数据页之后，就会把 LSN 也同步过去。如果发生了宕机，我们可以根据数据页中的 LSN 值和 redo log 中 LSN 的值判断需要恢复的 redo log 的位置和大小。redo log 同样也有自己的缓存，所以也涉及到刷盘策略，是通过innodb_flush_log_at_trx_commit这个参数控制的。</p><p>当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 有两个作用：提供回滚和多版本并发控制下的读(MVCC)，也即非锁定读。在数据修改的时候，不仅记录了redo，还记录了相对应的 undo，如果因为某些原因导致事务失败或回滚了，可以借助该 undo 进行回滚。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。</p><p>有时候应用到行版本控制的时候，也是通过 undo log 来实现的：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p><p>undo log 是采用段(segment)的方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment。</p><p>另外，undo log 也会产生 redo log，因为 undo log 也要实现持久性保护。</p><p>当事务提交的时候，InnoDB 不会立即删除 undo log，因为后续还可能会用到 undo log，如隔离级别为 repeatable read 时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即 undo log 不能删除。</p><p>当事务提交之后，undo log 并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否有其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间。</p><p>在 MySQL 5.7 之前，undo log 存储在共享表空间中，因此有可能大大增加表空间的占用，5.7 之后可以通过配置选择存储在独立的表空间中。</p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为hostname.err，其中，hostname为服务器主机名。<br>log_error 参数控制错误日志是否写入文件及文件名称，默认情况下，错误日志被写入终端标准输出stderr。当然，推荐指定 log_error 参数，自定义错误日志文件位置及名称。<br>下面我们来看一下它的位置。</p><pre><code>mysql&gt; show variables like &#39;%log_error%&#39;;+---------------------+---------------------+| Variable_name       | Value               |+---------------------+---------------------+| log_error           | /var/log/mysqld.log |+---------------------+---------------------+3 rows in set (0.13 sec)</code></pre><p>其中，&#x2F;var&#x2F;log&#x2F;mysqld.log 就是 MySQL 数据库错误日志的路径。</p><p>如果，要想将错误信息写入到错误日志中，还受 MySQL 数据库中 log_warnings 参数的影响，该参数有三个参数，分别是 0、1 和大于 1 三个参数。</p><ul><li>当 log_warnings 的结果为 0 时，不记录警告日志。</li><li>当 log_warnings 的结果为 1 时，记录错误日志，并且将警告日志也记录到错误日志之中。</li><li>当 log_warnings 的结果大于 1 时，除了记录警告日志和错误日志之外，还将连接失败的信息也记录到错误日志。</li></ul><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。<br>几个配置参数：</p><ul><li>slow_query_log 慢查询开启状态</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要 MySQL 的运行帐号的可写权限，一般设置为 MySQL 的数据存放目录）</li><li>long_query_time 查询超过多少秒才记录</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）</li></ul><p>修改参数可以通过配置文件，也可以在数据库中通过SET关键字来设置。</p><p>可以通过以下命令启动慢查询日志、设置指定时间：</p><pre><code>SET GLOBAL slow_query_log=ON/OFF;SET GLOBAL long_query_time=n;</code></pre><p>慢查询日志可以使用 mysqladmin 命令来删除。也可以使用手工方式来删除。mysqladmin 命令的语法如下：</p><pre><code>mysqladmin -uroot -p flush-logs</code></pre><p>执行该命令后，命令行会提示输入密码。输入正确密码后，将执行删除操作。新的慢查询日志会直接覆盖旧的查询日志，不需要再手动删除。</p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p>二进制日志（Binary Log）也可叫作变更日志（Update Log），可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select）,以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。<br><strong>注：</strong></p><pre><code>DDL----Data Definition Language 数据库定义语言 主要的命令有create、alter、drop等，ddl主要是用在定义或改变表(table)的结构,数据类型，表之间的连接和约束等初始工作上，他们大多在建表时候使用。DML----Data Manipulation Language 数据操纵语言主要命令是slect,update,insert,delete,就像它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</code></pre><p>二进制日志有以下功能</p><ul><li><p>恢复（recovery）</p><ul><li>某些数据的恢复需要二进制日志。例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。</li></ul></li><li><p>复制（replication）</p><ul><li>其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或者standby）与一台MySQL数据库（一般称为master或者primary）进行实时同步。</li></ul></li><li><p>审计（audit）</p><ul><li>用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul></li><li><p>除了上面介绍的几个作用外，binlog对于事务存储引擎的崩溃恢复也有非常重要的作用。</p><ul><li>在开启binlog的情况下，为了保证binlog与redo的一致性，MySQL将采用事务的两阶段提交协议。当MySQL系统发生崩溃时，事务在存储引擎内部的状态可能为prepared和commit两种。对于prepared状态的事务，是进行提交操作还是进行回滚操作，这时需要参考binlog：如果事务在binlog中存在，那么将其提交；如果不在binlog中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</li></ul></li></ul><p>mysqlbinlog常见的选项有一下几个：</p><p>a、–start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地计算机的时间<br>b、–stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地计算机的时间 取值和上述一样<br>c、–start-position：从二进制日志中读取指定position 事件位置作为开始。<br>d、–stop-position：从二进制日志中读取指定position 事件位置作为事件截至<br>3、一般来说开启binlog日志大概会有1%的性能损耗。</p><h2 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h2><p>通用查询日志（general query log）用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发送给MySQL数据库服务器的所有SQL指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，准确定位问题。</p><ul><li>查看日志是否开启<ul><li>SHOW VARIABLES LIKE ‘general_log’;</li></ul></li><li>开启日志功能<ul><li>SET GLOBAL general_log&#x3D;’ON’;</li></ul></li><li>关闭日志功能<ul><li>SET GLOBAL general_log&#x3D;’OFF’;</li></ul></li><li>看看日志文件保存位置<ul><li>SHOW VARIABLES LIKE ‘general_log_file’;</li></ul></li><li>设置日志文件保存位置<ul><li>SET GLOBAL general_log_file&#x3D;’C:\tmp.log’;</li></ul></li><li>看看日志输出类型 TABLE 或 FILE<ul><li>SHOW VARIABLES LIKE ‘log_output’;</li></ul></li><li>设置输出类型为 TABLE<ul><li>SET GLOBAL log_output&#x3D;’TABLE’;</li></ul></li><li>设置输出类型为FILE<ul><li>SET GLOBAL log_output&#x3D;’FILE’;</li></ul></li></ul><h2 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h2><p>中继日志只在主从服务器架构的从服务器上存在，从服务器（slave）为了与主服务器(Master)保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p><p><a href="https://imgse.com/i/pp5ibLV"><img src="https://s1.ax1x.com/2023/04/04/pp5ibLV.png" alt="pp5ibLV.png"></a></p><ul><li>Master收到客户端请求语句，在语句结束之前向二进制日志写入一条记录，可能包含多个事件</li><li>此时，一个Slave连接到Master，Master的dump线程从binlog读取日志并发送到Slave的IO线程。</li><li>IO线程从master.info读取到上一次写入的最后的位置。</li><li>IO线程写入日志到relay-log中继日志，如果超过指定的relay-log大小，写入轮换事件，创建一个新的relay-log。</li><li>更新master.info的最后位置</li><li>SQL线程从relay-log.info读取进上一次读取的位置</li><li>SQL线程读取日志事件</li><li>在数据库中执行sql</li><li>更新relay-log.info的最后位置</li><li>Slave记录自己的binlog日志</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务三种提交问题</title>
      <link href="/p/33810.html"/>
      <url>/p/33810.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务三种提交问题"><a href="#事务三种提交问题" class="headerlink" title="事务三种提交问题"></a>事务三种提交问题</h1><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B又用回滚把数据恢复成原来的值，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p><table><thead><tr><th>步骤</th><th>操作</th><th>余额变化</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td>N&#x2F;A</td><td></td></tr><tr><td>2</td><td>开始事务</td><td>N&#x2F;A</td><td></td></tr><tr><td>3</td><td>查询账户余额为2000元</td><td>N&#x2F;A</td><td></td></tr><tr><td>4</td><td>取款1000元</td><td>-1000元</td><td>余额变更为1000元</td></tr><tr><td>5</td><td>查询账户余额为1000元</td><td>N&#x2F;A</td><td>脏读产生，实际余额为未提交前的1000元</td></tr><tr><td>6</td><td>事务回滚</td><td>+1000元</td><td>余额变更为2000元</td></tr><tr><td>7</td><td>转入2000元</td><td>+2000元</td><td>脏读的1000元+2000元，余额变更为3000元</td></tr><tr><td>8</td><td>提交事务</td><td>N&#x2F;A</td><td>最终余额应该为4000元</td></tr></tbody></table><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。</p><p>这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。</p><table><thead><tr><th>时间顺序</th><th>事务</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>开始事务</td></tr><tr><td>2</td><td>A</td><td>第一次查询，小明的年龄为20岁</td></tr><tr><td>3</td><td>B</td><td>开始事务</td></tr><tr><td>4</td><td>B</td><td>其他操作</td></tr><tr><td>5</td><td>B</td><td>更改小明的年龄为30岁</td></tr><tr><td>6</td><td>B</td><td>提交事务</td></tr><tr><td>7</td><td>A</td><td>第二次查询，小明的年龄为30岁</td></tr></tbody></table><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。</p><p>幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。</p><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td></td><td>其他操作</td></tr><tr><td>5</td><td></td><td>新增100条数据</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，数据总量为200条</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据总量应该一致</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务隔离级别</title>
      <link href="/p/14751.html"/>
      <url>/p/14751.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ul><li>读未提交（READ UNCOMMITTED）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>可重复读 （REPEATABLE READ）事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>串行化 （SERIALIZABLE）确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p>事务提交存在很多问题需要我们设置对应的隔离级别<a href="#">Post not found: 事务三种提交问题 事务三种提交问题</a></p><p>只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。</p><h2 id="如何设置隔离级别"><a href="#如何设置隔离级别" class="headerlink" title="如何设置隔离级别"></a>如何设置隔离级别</h2><pre><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; 其中，隔离级别格式： &gt; READ UNCOMMITTED &gt; READ COMMITTED &gt; REPEATABLE READ &gt; SERIALIZABLE</code></pre><p>或者</p><pre><code>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#39;隔离级别&#39; #其中，隔离级别格式： &gt; READ-UNCOMMITTED &gt; READ-COMMITTED &gt; REPEATABLE-READ &gt; SERIALIZABLE</code></pre><p><a href="https://imgse.com/i/pp5CeWn"><img src="https://s1.ax1x.com/2023/04/04/pp5CeWn.md.png" alt="pp5CeWn.md.png"></a></p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。</p><p>我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p><p><a href="https://imgse.com/i/pp5C1wF"><img src="https://s1.ax1x.com/2023/04/04/pp5C1wF.md.png" alt="pp5C1wF.md.png"></a><br>按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。</p><p>快照，学名叫做一致性视图，这是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p><p>对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：</p><p>当前事务内的更新，可以读到；<br>版本未提交，不能读到；<br>版本已提交，但是却在快照创建后提交的，不能读到；<br>版本已提交，且是在快照创建前提交的，可以读到；<br>利用上面的规则，再返回去套用到读提交和可重复读的那两张图上就很清晰了。还是要强调，两者主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。</p><p>和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。<br>串行化</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/p/61809.html"/>
      <url>/p/61809.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><pre><code class="bash">$ 并查集是一种树型的数据结构。</code></pre><h2 id="并查集的用途"><a href="#并查集的用途" class="headerlink" title="并查集的用途"></a>并查集的用途</h2><ol><li>处理不相交的集合的合并、查询问题。</li><li>检查一个图上面是否有一个环。<br>简单说就是先把每一个顶点放在一个独立的集合（树）里，如果顶点之间是邻接的那么就把他们合并为一个<br>集合（树）。一个集合（树）里有一个根结点，如果有两个顶点他们的根结点相同说明他们处于同一个集合<br>（树），那这两个结点邻接必定形成一个环（为什么？ 因n个顶点和n-1条边形成的连通图如果再加一条边<br>一定出现环）。如果他们的根结点不同，就把这两个集合合成一个集合。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>for(int i=1;i&lt;=n;i++)&#123;    father[i]=i;&#125;</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>非递归写法</strong></p><pre><code>int findFather(int x)&#123;    while(x!=father[x])&#123;        x=father[x];    &#125;    return x;&#125;</code></pre><p><strong>递归写法</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    return findfather(father[x]);&#125;</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><pre><code>void Union(int a,int b)&#123;    int faA =findFather(a);    int faB=findFather(b);    if(faA==faB)return ;    else&#123;        father[faA]=faB;    &#125;&#125;</code></pre><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>非递归写法：</strong></p><pre><code>int findFather(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        father[a]=x;        a=father[z];    &#125;    return x;&#125;</code></pre><p><strong>递归写法：</strong></p><pre><code>int findFather(int x)&#123;    if(x==father[x])return x;    else&#123;        int F=findFather(father[x]);        father[x]=F;        return F;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>带权并查集</title>
      <link href="/p/56030.html"/>
      <url>/p/56030.html</url>
      
        <content type="html"><![CDATA[<h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><h2 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h2><p>记录当前并查集集合内的节点个数，简单来说：就是在朴素版的并查集的基础上维护多一个信息size，从而记录当前并查集集合内的节点个数<br>此并查集一般作用于计算连通块中点的数量的题目</p><h3 id="定义并查集-amp-初始化："><a href="#定义并查集-amp-初始化：" class="headerlink" title="定义并查集&amp;初始化："></a>定义并查集&amp;初始化：</h3><pre><code>int p[N], _size[N];for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;        size[i] = 1;&#125;</code></pre><p>p[]存储的是每个点的祖宗节点</p><p>size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</p><h3 id="并查集的查询操作："><a href="#并查集的查询操作：" class="headerlink" title="并查集的查询操作："></a>并查集的查询操作：</h3><p>int find(int x)<br>{<br>    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);</p><pre><code>return p[x];</code></pre><p>}</p><h3 id="并查集的合并操作："><a href="#并查集的合并操作：" class="headerlink" title="并查集的合并操作："></a>并查集的合并操作：</h3><p>bool merge(int x, int y)<br>{<br>    x &#x3D; find(x);<br>    y &#x3D; find(y);</p><pre><code>if (x == y) return false;_size[x] += _size[y];p[y] = x;return true;</code></pre><p>}<br>因为是合并集合，固然也需要将原来集合内的节点总个数加到新合并的集合中</p><h2 id="维护dist的并查集"><a href="#维护dist的并查集" class="headerlink" title="维护dist的并查集"></a>维护dist的并查集</h2><p>简单来说：就是在朴素版的并查集的基础上维护多一个信息dist，从而记录当前节点到根节点之间的距离</p><h3 id="定义并查集-amp-初始化：-1"><a href="#定义并查集-amp-初始化：-1" class="headerlink" title="定义并查集&amp;初始化："></a>定义并查集&amp;初始化：</h3><pre><code>int p[N], _dist[N];for (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;        _dist[i] = 0;&#125;</code></pre><p>p[]存储的是每个点的祖宗节点</p><p>d[x]存储的是编号为x的节点到p[x]（祖宗节点）的距离</p><h3 id="并查集的查询操作：-1"><a href="#并查集的查询操作：-1" class="headerlink" title="并查集的查询操作："></a>并查集的查询操作：</h3><pre><code>int find(int x)&#123;    if (p[x] != x)    &#123;        int root = find(p[x]);                _dist[x] += _dist[p[x]];                p[x] = root;    &#125;        return p[x];&#125;</code></pre><p>在路径压缩的过程中，我们需要顺带计算此节点距离祖宗节点的距离，此时我们便需要提前记录每一次递归（即寻找到父亲节点）前的节点的编号<br>即记录下当前所操作的节点编号，这样就能在递归回溯的时候，对记录下的节点进行距离根节点的距离的更新<br>从而可以达到借助路径压缩的优化达到不仅仅是对路径节点的优化，也达到了对dist的优化，即一次查询即可更新路径上所有的点到根节点的距离</p><h3 id="并查集的合并操作：-1"><a href="#并查集的合并操作：-1" class="headerlink" title="并查集的合并操作："></a>并查集的合并操作：</h3><p>bool merge(int x, int y)<br>{<br>    x &#x3D; find(x);<br>    y &#x3D; find(y);</p><pre><code>if (x == y) return false;_dist[y] += _dist[x] + 1;p[y] = x;return true;</code></pre><p>}</p><p>为什么y集合合并到x集合，只需要更新y集合的根节点距离新集合根节点的距离，而不需要将y集合内的所有节点距离新根节点的距离全部更新呢？<br>这是因为：只要后续操作中，需要对原y集合内的某个节点进行查询操作的时候，查询操作便会对此点所在路径上的所有点全部进行数据的更新，即相当于原y集合内的节点的p[x]和_dist[x]都会更新为指向合并后新的根节点和距离新根节点的距离<br>也就是说，只要合并的时候更新好原根节点距离新根节点的距离，后续只需要一次查询操作，便可将数据都更新为最新的了</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚函数表</title>
      <link href="/p/14976.html"/>
      <url>/p/14976.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表</p><h2 id="什么是虚函数表？"><a href="#什么是虚函数表？" class="headerlink" title="什么是虚函数表？"></a>什么是虚函数表？</h2><p>对于一个类来说，如果类中存在虚函数，那么该类的大小就会多4个字节，然而这4个字节就是一个指针的大小，这个指针指向虚函数表。所以，如果对象存在虚函数，那么编译器就会生成一个指向虚函数表的指针，所有的虚函数都存在于这个表中，虚函数表就可以理解为一个数组，每个单元用来存放虚函数的地址。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp代码到exe</title>
      <link href="/p/43341.html"/>
      <url>/p/43341.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-从代码到可执行二进制文件"><a href="#C-从代码到可执行二进制文件" class="headerlink" title="C++从代码到可执行二进制文件"></a>C++从代码到可执行二进制文件</h1><p>test.cpp–test.i–test.s–test.o</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是预处理器cpp来完成的，你可以通过如下命令对test.c进行预处理：</p><pre><code>gcc -E -I./inc main.cpp -o main.i</code></pre><p>或者直接调用cpp命令</p><pre><code>$ cpp main.cpp -I./inc -o main.i</code></pre><p>上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-I指定头文件目录，这里指定的是我们自定义的头文件目录；-o指定输出文件名。<br>经过预处理之后代码体积会大很多,预处理之后的程序还是文本，可以用文本编辑器打开</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译只是把我们写的代码转为汇编代码，它的工作是检查词法和语法规则，所以，如果程序没有词法或则语法错误，那么不管逻辑是怎样错误的，都不会报错。<br>编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。</p><pre><code>$ gcc -S -I./inc main.cpp -o main.s</code></pre><p>上述命令中-S让编译器在编译之后停止，不进行后续过程。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程将上一步的汇编代码(main.s)转换成机器码(machine code)，这一步产生的文件叫做目标文件(main.o)，是二进制格式。<br>gcc&#x2F;g++的汇编过程通过 as 命令完成，所以我们可以通过g++ -c或as命令完成汇编：</p><pre><code>g++ -c -I include/ main.cpp -o main.o</code></pre><p>或者直接调用 as 命令</p><pre><code>as main.s -o main.o</code></pre><p>上述指令中： - g++ -c让编译器在汇编之后退出，等价于 as - -I include&#x2F;仍是用于指定头文件目录 - main.cpp是要汇编的源文件 - -o main.o用于指定生成的文件名<br>汇编这一步需要为每一个源文件（本文示例代码中为main.cpp、func.cpp）产生一个目标文件。因此func.cpp也需要执行一次这个汇编过程产生一个func.o文件:</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>C&#x2F;C++代码经过汇编之后生成的目标文件(*.o)并不是最终的可执行二进制文件，而仍是一种中间文件(或称临时文件)，目标文件仍然需要经过链接(Link)才能变成可执行文件。</p><p>既然目标文件和可执行文件的格式是一样的（都是二进制格式），为什么还要再链接一次呢？<br>因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。<br>链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件(.o)和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。<br>此外需要注意的是：C++程序编译的时候其实只识别.cpp文件，每个cpp文件都会分别编译一次，生成一个.o文件。这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个.o或者.obj文件组合起来，生成最终的可执行文件(Executable file)。<br>以本文中的代码为例，将func.o和main.o链接成可执行文件main.out，指令如下:</p><pre><code>g++ src/func.o main.o -o main.out</code></pre><p>-o main.out用于指定生成的可执行二进制文件名<br>由于g++自动链接了系统组件，所以我们只需要把自定义函数的目标文件与main.o链接即可。<br>运行main.out，结果如下：</p><pre><code>./main.outa + b = 3</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/p/63561.html"/>
      <url>/p/63561.html</url>
      
        <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><ul><li>没有从形式上体现转换功能和风险的不同。</li><li>将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</li><li>难以在程序中寻找到底什么地方进行了强制类型转换。</li></ul><p>C++ 的四种强制转换包括： static_cast, dynamic_cast, const_cast, reinterpret_cast</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><blockquote><p>static_cast<type>(expression)</type></p></blockquote><p>static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。如果对象所属的类重载了强制类型转换运算符 T（如 T是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。</p><pre><code>uint x = 1;int y = static_cast&lt;int&gt;(x); // 转换正确int x = 1;double y = static_cast&lt;double&gt;(x); // 转换正确</code></pre><p>需要注意的是：static_cast 没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全。<br>static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。空类型指针转换为任意基本类型的指针,空指针转换这里面很容易出错，因为有可能出现未知的转换结果，要保证转换的正确性就必须保证转换后所得的类型就是指针原先的类型。</p><pre><code>int x = -1;uint y = static_cast&lt;uint&gt;(x) // 转换错误double x = 1.23;int y = static_cast&lt;int&gt;(x) // 转换丢失精度</code></pre><p>static_cast 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类，所以主要执⾏⾮多态的转换作；</p><pre><code>// 上行转换，派生类→基类Derive* d = new Derive();Base* b = static_cast&lt;Base*&gt;(d);// 下行转换，基类→派生类Base* b = new Base();Derive* d = static_cast&lt;Derive*&gt;(b);</code></pre><p>这是因为派生类包含基类信息，所以上行转换（只能调用基类的方法和成员变量），一般是安全的；<br>而基类没有派生类的任何信息，而下行转换后会用到派生类的方法和成员变量，这些基类都没有，很容易”指鹿为马”，或指向不存在的空间。</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><blockquote><p>dynamic_cast<type>(expression)   type 必须是类指针，类引⽤或void*，<br>dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，对于下⾏转换是安全的，当类型不⼀致时（即我们的父类指针指向的实际内存不是目标对象type-id *），转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的是错误意义的指针，可能造成⾮法访问等问题。只能用于含有虚函数的类转换，用于类向上和向下转换<br>dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</type></p></blockquote><p>dynamic_cast使用的场景:</p><p>如果你必须做一个非多态的工作在继承类B和C上,但只能接收基类A,则需要如下的操作:<br>比如下面这段代码：</p><pre><code>class A &#123; public: virtual ~A()&#123;&#125; &#125;;class B: public A&#123; public: void work4B()&#123;&#125; &#125;;class C: public A&#123; public: void work4C()&#123;&#125; &#125;; void non_polymorphic_work(A* ap)&#123;    //因为不知道传入来的是那个对象，但是又想统一的调用一个函数，但我们又不能用多态来实现这个效果    if (B* bp =dynamic_cast&lt;B*&gt;(ap))        bp-&gt;work4B();     if (C* cp =dynamic_cast&lt;C*&gt;(ap))        cp-&gt;work4C(); &#125;</code></pre><p>在C++面向对象的思想中，虚函数是实现多态的关键机制。当一个类中有虚函数时，那么编译器就会构建出一个虚函数表来指示这些函数的地址。当用基类的指针指向派生类的对象，调用方法时就会根据虚函数表找到对应派生类的方法。<br>注意：A 要有虚函数，否则会编译出错；static_cast则没有这个限制。</p><p>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><blockquote><p>const_cast<type>(expression)<br>该运算符用来修改 expression 的 const 或 volatile 属性。这里需要注意：expression 和 type 的类型一样的。</type></p></blockquote><p>比如下面的代码，指针 px 由于有 const 修饰，无法直接通过其修改 x 的值，但又期望能修改 x 的值时，怎么办呢？这时就需要用到 const_cast。</p><pre><code>int main()&#123;    int x = 1;    cout &lt;&lt; &quot;before: &quot; &lt;&lt; x &lt;&lt; endl;    const int* px = &amp;x;    // *px = 2; // 编译错误    int* py = const_cast&lt;int*&gt;(px);    *py = 2;    cout &lt;&lt; &quot;px: &quot; &lt;&lt; px &lt;&lt; endl;    cout &lt;&lt; &quot;py: &quot; &lt;&lt; py &lt;&lt; endl;    cout &lt;&lt; &quot;after : &quot; &lt;&lt; x &lt;&lt; endl;    return 0;&#125;</code></pre><p>px 和 py 指向同一个地址，但通过 py 就可以修改 x 的值了。</p><p>这是因为通过const_cast，就把 const 类型的指针 px 转换成非 const 类型的指针 py 了。</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><blockquote><p>reinterpret_cast<type>(expression)</type></p></blockquote><p>reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</p><p>这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作</p><pre><code>#include &lt;iostream&gt;using namespace std;class A&#123;public:    int i;    int j;    A(int n):i(n),j(n) &#123; &#125;&#125;;int main()&#123;    A a(100);    int &amp;r = reinterpret_cast&lt;int&amp;&gt;(a); //强行让 r 引用 a    r = 200;  //把 a.i 变成了 200    cout &lt;&lt; a.i &lt;&lt; &quot;,&quot; &lt;&lt; a.j &lt;&lt; endl;  // 输出 200,100    int n = 300;    A *pa = reinterpret_cast&lt;A*&gt; ( &amp; n); //强行让 pa 指向 n    pa-&gt;i = 400;  // n 变成 400    pa-&gt;j = 500;  //此条语句不安全，很可能导致程序崩溃    cout &lt;&lt; n &lt;&lt; endl;  // 输出 400    long long la = 0x12345678abcdLL;    pa = reinterpret_cast&lt;A*&gt;(la); //la太长，只取低32位0x5678abcd拷贝给pa    unsigned int u = reinterpret_cast&lt;unsigned int&gt;(pa);//pa逐个比特拷贝到u    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  //输出 5678abcd    typedef void (* PF1) (int);    typedef int (* PF2) (int,char *);    PF1 pf1;  PF2 pf2;    pf2 = reinterpret_cast&lt;PF2&gt;(pf1); //两个不同类型的函数指针之间可以互相转换&#125;</code></pre><p>程序的输出结果是：</p><pre><code>200, 1004005678abed</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，在使用强制类型转换时，需要首先考虑清楚使用目的，总结如下：</p><p>static_cast：基本类型转换，低风险；<br>dynamic_cast：类层次间的上行转换或下行转换，低风险；<br>const_cast：去 const 属性，低风险；<br>reinterpret_cast：转换不相关的类型，高风险。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动语义</title>
      <link href="/p/27999.html"/>
      <url>/p/27999.html</url>
      
        <content type="html"><![CDATA[<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>对于移动语义，相关一个话题就是异常，对于移动构造函数来说，抛出异常有时候是个危险的事情，因为可能移动语义还没有完成一个异常就会抛出造成悬挂指针。因此移动构造函数应该为其添加一个noexception关键字，保证异常抛出以后直接调用terminate程序终止执行。</p><p>在标准库中，我们可以使用std::move_if_noexception来代替move函数，该函数在移动构造函数没有noexception关键字修饰的时候返回一个左值引用从而使变量使用拷贝语义。在移动构造函数有noexception关键字修饰的时候返回一个右值引用从而使变量使用移动语义。</p><p>与移动语义相关但是关联不多的一个话题是：RVO&#x2F;NRVO优化</p><pre><code>A returnRvalue()&#123;A a();return a;&#125;A b=returnRvalue();</code></pre><p>编译器优化后，从returnRvalue函数中a的变量拷贝  临时变量拷贝通通没有了，b变量实际上霸占了a变量。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>move</title>
      <link href="/p/64202.html"/>
      <url>/p/64202.html</url>
      
        <content type="html"><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><p>为什么要引入move，我们来看一个例子</p><pre><code>class A &#123;    public:        A()&#123;            std::cout &lt;&lt; &quot;A construct...&quot; &lt;&lt; std::endl;            ptr_ = new int(100);        &#125;        A(const A &amp; a)&#123;            std::cout &lt;&lt; &quot;A copy construct ...&quot; &lt;&lt; std::endl;            ptr_ = new int();            memcpy(ptr_, a.ptr_, sizeof(int));        &#125;        ~A()&#123;            std::cout &lt;&lt; &quot;A deconstruct ...&quot; &lt;&lt; std::endl;            if(ptr_)&#123;                delete ptr_;            &#125;        &#125;        A&amp; operator=(const A &amp; a) &#123;            std::cout &lt;&lt; &quot; A operator= ....&quot; &lt;&lt; std::endl;            return *this;        &#125;        int * getVal()&#123;            return ptr_;        &#125;    private:        int *ptr_;&#125;;int main(int argc, char *argv[])&#123;    std::vector&lt;A&gt; vec;    vec.push_back(A());&#125;</code></pre><p>输出结果</p><pre><code>A construct...          //main中创建的A对象A copy construct ...    //vector内部创建的A对象A deconstruct ...       //vector内部创建的A对象被析构A deconstruct ...       //main中创建的A对象析构</code></pre><p>但是如果使用move：</p><pre><code>class A &#123;    public:        ...        A(A &amp;&amp; a)&#123;            std::cout &lt;&lt; &quot;A move construct ...&quot; &lt;&lt; std::endl;            ptr_ = a.ptr_;            a.ptr_ = nullptr;        &#125;        ...&#125;;int main()&#123;    std::vector&lt;A&gt; vec;    vec.push_back(std::move(A())); &#125;</code></pre><p>输出结果</p><pre><code>A construct...          //main中创建的A对象A move construct ...    //vector内部创建的A对象A deconstruct ...       //vector内部创建的A对象被析构A deconstruct ...       //main中创建的A对象析构</code></pre><p>可以看到td::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p><p>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。</p><p>std::move是为性能而生。std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。</p><p>例如：</p><pre><code>#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;string&gt;int main()&#123;    std::string str = &quot;Hello&quot;;    std::vector&lt;std::string&gt; v;    //调用常规的拷贝构造函数，新建字符数组，拷贝数据    v.push_back(str);    std::cout &lt;&lt; &quot;After copy, str is \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    //调用移动构造函数，掏空str，掏空后，最好不要使用str    v.push_back(std::move(str));    std::cout &lt;&lt; &quot;After move, str is \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    std::cout &lt;&lt; &quot;The contents of the vector are \&quot;&quot; &lt;&lt; v[0]                                        &lt;&lt; &quot;\&quot;, \&quot;&quot; &lt;&lt; v[1] &lt;&lt; &quot;\&quot;\n&quot;;&#125;</code></pre><p>输出：</p><pre><code>After copy, str is &quot;Hello&quot;After move, str is &quot;&quot;The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值右值</title>
      <link href="/p/3763.html"/>
      <url>/p/3763.html</url>
      
        <content type="html"><![CDATA[<h1 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h1><p>在 C++11 中，一共有 5 种 value：</p><p>lvalue (Left-hand-side value)<br>rvalue (Right-hand-side value)<br>xvalue (eXpiring value)<br>prvalue (Pure rvalue)<br>glvalue (Generalized lvalue)</p><p>他们的关系大致如下图所示：<br><a href="https://imgse.com/i/ppfUKTe"><img src="https://s1.ax1x.com/2023/04/02/ppfUKTe.png" alt="valueTyoe.png"></a></p><p>lvalue 和 xvalue 合称为 glvalue。<br>prvalue 和 xvalue 合称为 rvalue。</p><p>有”身份”[has identity]：能够确定某个表达式是否和另一个表达式指涉[refers to]同一个实体，例如，通过比较它们标识[identify]出来的函数或者对象的地址(直接或间接得到的)。<br>能被移动[can be moved from]：能够被移动构造函数、移动赋值操作符或者其它实现[implement]移动语义[move semantics]的重载函数绑定[bind to]。<br>根据上面两个属性，我们可以对表达式进行分类：</p><p>有”身份”但是不能”被移动”的表达式被称为左值表达式[lvalue expression];<br>有”身份”同时能”被移动”的表达式被称为 xvalue 表达式[xvalue expression];<br>没有”身份”但是能”被移动”的表达式被称为纯右值表达式[prvalue expression];<br>C++没有既没有”身份”也不能”被移动”的表达式；<br><a href="https://imgse.com/i/ppfUvhd"><img src="https://s1.ax1x.com/2023/04/02/ppfUvhd.png" alt="ppfUvhd.png"></a></p><h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h2><p>如果你可以对一个表达式取地址，那这个表达式就是个lvalue。<br>如果一个表达式的类型是一个lvalue reference (例如, T&amp; 或 const T&amp;, 等.)，那这个表达式就是一个lvalue。<br>一个 lvalue 是通常可以放在等号左边的表达式<br>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：<br>变量、函数或数据成员<br>返回左值引用的表达式如：</p><pre><code>++x、x = 1、cout &lt;&lt; &#39; &#39;int x = 0;cout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;cout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;cout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;//cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl; // errorcout &lt;&lt; &quot;(cout &lt;&lt; &#39; &#39;).addr=&quot; &lt;&lt; &amp;(cout &lt;&lt; &#39; &#39;) &lt;&lt; endl;</code></pre><p>字符串字面量是左值，而且是不可被更改的左值。字符串字面量并不具名，但是可以用&amp;取地址所以也是左值。如：</p><pre><code>&quot;hello&quot;,在c++中是 char const [6] 类型，而在c中是 char [6] 类型cout &lt;&lt; &quot;(\&quot;hello\&quot;).addr=&quot; &lt;&lt; &amp;(&quot;hello&quot;) &lt;&lt; endl;</code></pre><p>如果一个表达式的类型是一个lvalue reference (例如, T&amp; 或 const T&amp;, 等.)，那这个表达式就是一个lvalue。</p><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><h3 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h3><p>通常指代一个生存周期即将结束的值（因此其资源可以被转移）。是某些涉及到右值引用的表达式的值，根据C++11标准，以下四种情况属于xvalue：</p><ul><li>调用函数（无论是隐式还是显式）的结果，该函数的返回类型是对对象类型的右值引用，</li><li>对对象类型的右值引用的强制转换，</li><li>类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue，或</li><li>指向成员表达式的*指针，其中第一个操作数是xvalue，第二个操作数是指向数据成员的指针。</li></ul><h3 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h3><p>prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p><p>返回非引用类型的表达式 如 x++、x + 1<br>除字符串字面量之外的字面量 如 42、true<br>隐式或显式调用函数的结果，该函数的返回类型是对所返回对象类型的右值引用</p><pre><code>int&amp;&amp; f()&#123;    return 3;&#125;int main()&#123;    f(); // The expression f() belongs to the xvalue category, because f() return type is an rvalue reference to object type.    return 0;&#125;</code></pre><p>类成员访问表达式，指定非引用类型的非静态数据成员，其中对象表达式是xvalue</p><pre><code>struct As&#123;    int i;&#125;;As&amp;&amp; f()&#123;    return As();&#125;int main()&#123;    f().i; // The expression f().i belongs to the xvalue category, because As::i is a non-static data member of non-reference type, and the subexpression f() belongs to the xvlaue category.    return 0;&#125;</code></pre><p>对对象类型右值引用的转换</p><pre><code>int main()&#123;    static_cast&lt;int&amp;&amp;&gt;(7); // The expression static_cast&lt;int&amp;&amp;&gt;(7) belongs to the xvalue category, because it is a cast to an rvalue reference to object type.    std::move(7); // std::move(7) is equivalent to static_cast&lt;int&amp;&amp;&gt;(7).    return 0;&#125;</code></pre><p>从语法上来看，声明右值引用看起来和声明”普通”的引用很像，只不过要用&amp;&amp;而不是&amp;。下面这个函数需要一个类型为rvalue-reference-to-Widget:的参数:</p><pre><code>void f(Widget&amp;&amp; param);</code></pre><p>假设右值引用是使用&amp;&amp;声明的，那么假设类型声明中出现&amp;&amp; 表示右值引用似乎是合理的。事实并非如此:</p><pre><code>Widget&amp;&amp; var1 = someWidget;      // here, “&amp;&amp;” means rvalue referenceauto&amp;&amp; var2 = var1;              // here, “&amp;&amp;” does not mean rvalue referencetemplate&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param);  // here, “&amp;&amp;” means rvalue referencetemplate&lt;typename T&gt;void f(T&amp;&amp; param);               // here, “&amp;&amp;”does not mean rvalue reference</code></pre><p>因此正确的区分这两种含义非常重要，如果你看到“&amp;&amp;”就以为是右值引用的话，会误读很多c++11代码。</p><p>2.引入万能引用<br>这个问题的本质实际上是，类型声明当中的“&amp;&amp;”有的时候意味着rvalue reference，但有的时候意味着rvalue reference 或者 lvalue reference。因此，源代码当中出现的 “&amp;&amp;” 有可能是 “&amp;” 的意思，即是说，语法上看着像rvalue reference (“&amp;&amp;”)，但实际上却代表着一个lvalue reference (“&amp;”)。在这种情况下，此种引用比lvalue references 或者 rvalue references都要来的更灵活。<br>Rvalue references只能绑定到右值上，lvalue references除了可以绑定到左值上，在某些条件下还可以绑定到右值上。</p><p>例如：</p><pre><code>string &amp;s = &quot;asd&quot;;  // errorconst string &amp;s = &quot;asd&quot;;  // ok</code></pre><p>规则简化如下：</p><pre><code>左值引用   &#123;左值&#125;  右值引用   &#123;右值&#125;常左值引用  &#123;右值&#125;</code></pre><p>相比之下，声明中带 “&amp;&amp;” 的，可能是lvalue references 或者 rvalue references 的引用可以绑定到任何东西上。这种引用称它们为 universal references(万能引用或转发引用、通用引用)。</p><pre><code>string f() &#123; return &quot;abc&quot;; &#125;​void g() &#123;    const string &amp;s = f();       // still legal?    cout &lt;&lt; s &lt;&lt; endl;&#125;</code></pre><p>上面g函数中合法？</p><p>答案是合法的，原因是s是个左值，类型是常左值引用，而f()是个右值，前面提到常左值引用可以绑定到右值！所以合法，当然把const去掉，便是不合法！</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美转发</title>
      <link href="/p/50074.html"/>
      <url>/p/50074.html</url>
      
        <content type="html"><![CDATA[<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>在说明完美转发之前先来介绍一下引用折叠</p><pre><code>A&amp; &amp; 变成 A&amp;A&amp; &amp;&amp; 变成 A&amp;A&amp;&amp; &amp; 变成 A&amp;A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;</code></pre><h2 id="完美转发-1"><a href="#完美转发-1" class="headerlink" title="完美转发"></a>完美转发</h2><p><strong>转发</strong>：函数将一个或多个实参传递给其他函数的过程<br><strong>完美转发（perfect forwarding）</strong>：转发过程中，保持被转发实参的所有原始性质，包括实参类型是否为const，左值 or 右值等</p><p>我们先来看一个例子</p><pre><code>void f(int v1, int v2);template&lt;typename F, typename T1, typename T2&gt;void test1(F f, T1 t1, T2 t2) &#123;     f(t2, t1);&#125;</code></pre><p>理论上我们完成了转发，但是这有很多问题，比如当我们希望它调用一个接受引用参数的函数时，会出现问题：</p><pre><code>void f(int v1, int&amp; v2) &#123; // v2是一个引用类型    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;&#125;</code></pre><p>代码中，f改变了绑定到v2的实参值，但并不会影响test1的实参。因为实参传递给test1的形参，只是一个普通的int，而非引用（int&amp;），所以改变test1的形参并不会影响实参。<br>此外，采用拷贝而不是移动语义回导致效率造成损失。</p><p>为了让test函数传递一个引用，可以重写test函数，使其参数能保持给定实参的“左值性”，以及const属性（常量性）。</p><pre><code>template&lt;typename F, typename T1, typename T2&gt;void test2(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(t2, t1);&#125;</code></pre><p>如果t1或t2对应实参是左值（int&amp;），通过引用折叠，转换成int&amp;，继续保持左值属性；<br>如果实参是右值（int&amp;&amp;），同样地，转换成int&amp;&amp;，继续保持右值属性。</p><p>这个版本的翻转函数test2只解决了一半问题，对于接受一个左值引用的函数工作正常，但是对于接受右值引用的函数，却无法正常工作。</p><pre><code>// 接受一个右值引用和一个左值引用的函数void f(int&amp;&amp; i, int&amp;&amp; j) &#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;&#125;</code></pre><p>test2(f, i, 42); &#x2F;&#x2F; 错误：不能从一个左值实例化int&amp;&amp;<br>虽然test2的实参42是右值，但在test2内部调用f，传给f的实参将是test2的参数t2（值为42），而函数参数t2与其他任何变量一样，都是左值表达式。将左值实参直接传递给右值形参，将导致编译错误。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>C++11中，可以使用std::forward传递test2的参数，使它能保持原始实参的类型的所有细节。<br>当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个左值。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推导，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。<br>这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。</p><p>与move调用不同的是，forward必须通过显式模板实参来调用。forward返回该显式实参类型的右值引用，i.e. forward返回类型为T&amp;&amp;。</p><p>使用forward重写test函数：</p><pre><code>// OKtemplate&lt;typename F, typename T1, typename T2&gt;void test3(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125;// 像这样调用不再有问题int i = 10, j = 20;test3(f, i, 20); // OK</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>c++中很多小巧的函数都通过完美转发实现了，比如make_pair,make_unique</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/p/52505.html"/>
      <url>/p/52505.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存</title>
      <link href="/p/10970.html"/>
      <url>/p/10970.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="静态内存"><a href="#静态内存" class="headerlink" title="静态内存"></a>静态内存</h2><p>静态内存可以被看作全局变量，这些变量和他们的值可以在任何时候被任何程序的任何部分访问。</p><p>例如</p><pre><code>#include&lt;iostream&gt;using namespace std;unsigned int counter=0;void increaseCount()&#123;    counter+=10;    cout&lt;&lt;&quot;counter is&quot;&lt;&lt;counter&lt;&lt;endl;&#125;int main()&#123;    counter+=5;    cout&lt;&lt;&quot;counter is&quot;&lt;&lt;counter&lt;&lt;endl;    increaseCount();    return 0;&#125;</code></pre><p>结果：</p><pre><code>counter is 5counter is 15</code></pre><p>全局变量在某些确定的情况下有用，但是在很多情况下会导致问题。<br>静态成员变量也是全局变量的一种，他的一个普遍问题是创建顺序，c++标准不保证按照某种顺序初始化，这会导致许多相关全局变量的程序由于意外的初始化顺序而出现问题导致崩溃。全局变量在多线程也会产生问题。<br>通常建议将全局变量的使用限度降到最低，同时相同名称的局部变量会获取更高的优先权。</p><p>例如</p><pre><code>#include&lt;iostream&gt;using namespace std;unsigned int counter=0;void increaseCount()&#123;    counter+=10;    cout&lt;&lt;&quot;counter is &quot;&lt;&lt;counter&lt;&lt;endl;&#125;int main()&#123;    unsigned int counter=0;    counter+=5;    cout&lt;&lt;&quot;counter is &quot;&lt;&lt;counter&lt;&lt;endl;    increaseCount();    return 0;&#125;</code></pre><p>结果：</p><pre><code>counter is 5counter is 10</code></pre><h2 id="栈内存的使用"><a href="#栈内存的使用" class="headerlink" title="栈内存的使用"></a>栈内存的使用</h2><p>在函数工作时，需要内存来存储临时变量<br>c++通过栈来为局部变量分配空间，主要通过ebp，esp来完成。</p><h2 id="堆内存的使用"><a href="#堆内存的使用" class="headerlink" title="堆内存的使用"></a>堆内存的使用</h2><h2 id="自动共享内存的使用"><a href="#自动共享内存的使用" class="headerlink" title="自动共享内存的使用"></a>自动共享内存的使用</h2>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/p/47719.html"/>
      <url>/p/47719.html</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>具体请查看</p><h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与时间有关的程序</title>
      <link href="/p/6239.html"/>
      <url>/p/6239.html</url>
      
        <content type="html"><![CDATA[<h1 id="与时间有关的程序"><a href="#与时间有关的程序" class="headerlink" title="与时间有关的程序"></a>与时间有关的程序</h1><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><pre><code>#include&lt;ctime&gt;#include&lt;chrono&gt;#include&lt;iostream&gt;using namespace chrono;int main()&#123;    auto currentTimePoint=system_clock::now();    auto currentTime = system_clock::to_time_t(currentTimePoint);    auto timeText=ctime(&amp;currentTime);    std::cout&lt;&lt;timeTixt&lt;&lt;std::endl;    return 0;&#125;</code></pre><p>system_clock::now()返回的对象是一个time_point类型，他表示从某一个时间点（epoch）开始的偏移，epoch是一个参考时间，系统用它来偏移其他时间。但是如果系统使用不同的epoch来计算时间，那么一台计算机上的时间可能不能够一直到另一条计算机上。<br>time_point结构不能直接输出，也无法转换成字符串，但是该类型能够转换成time_t，time_t可以通过ctime函数转换成字符串类型。</p><h2 id="比较时间"><a href="#比较时间" class="headerlink" title="比较时间"></a>比较时间</h2><pre><code>#include&lt;ctime&gt;#include&lt;chrono&gt;#include&lt;iostream&gt;#include&lt;thread&gt;using namespace literals;using namespace chrono;int main()&#123;    auto startTimePoint=system_clock::now();    this_thread::sleep(5s);    auto endTimePoint=system_clock::now();    auto timeTaken = duration_cast&lt;milliseconds&gt;(endTimeoint-startTimePoint);    std::cout&lt;&lt;&quot;time taken: &quot;timeTaken.count()&lt;&lt;std::endl;    return 0;&#125;</code></pre><p>duration_cast将减法的结果转换成一个具有特定时间类型的具体时间。<br>此外，sleep函数内采用了字面量，h，min，s，ms，us，ns这些字面量只能在c++14使用，c++11和c++98不支持。</p><h2 id="三种使用时钟类型"><a href="#三种使用时钟类型" class="headerlink" title="三种使用时钟类型"></a>三种使用时钟类型</h2><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;ctime&gt;//local_time#include&lt;chrono&gt;//time_futures#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;iomanip&gt;//put_timeusing namespace std;int main()&#123;    chrono::system_clock::time_point pc_clock = chrono::system_clock::now();    time_t pc_clock_time = chrono::system_clock::to_time_t(pc_clock);    cout &lt;&lt; &quot;The time according to the computer clock is:&quot; &lt;&lt; put_time(localtime(&amp;pc_clock_time), &quot;%T %p&quot;) &lt;&lt; endl;    chrono::steady_clock::time_point start = chrono::steady_clock::now();    //when we start    chrono::high_resolution_clock::time_point start2 = chrono::high_resolution_clock::now();//high res clock    chrono::system_clock::time_point now = chrono::system_clock::now();    //current time    time_t now_c = chrono::system_clock::to_time_t(now);    cout &lt;&lt; &quot;\n\nThe time now is: &quot; &lt;&lt; put_time(localtime(&amp;now_c), &quot;%F %T %b %I %p&quot;) &lt;&lt; endl;    time_t now_p = chrono::system_clock::to_time_t(now - chrono::hours(2));    cout &lt;&lt; &quot;The time 2 hours ago was: &quot; &lt;&lt; put_time(localtime(&amp;now_p), &quot;%F %T %B %A&quot;) &lt;&lt; &quot;\n\n&quot;;    chrono::steady_clock::time_point end = chrono::steady_clock::now();//it is over    chrono::high_resolution_clock::time_point end2 = chrono::high_resolution_clock::now();    cout &lt;&lt; &quot;computing lasted &quot; &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() &lt;&lt; &quot;ms&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;computing with high_resolution_clock yielded &quot; &lt;&lt; chrono::duration_cast&lt;chrono::nanoseconds&gt;(end2 - start2).count()        &lt;&lt; &quot;nanoseconds!&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>结果如下</p><pre><code>The time according to the computer clock is:23:19:00 PMThe time now is: 2023-03-11 23:19:00 Mar 11 PMThe time 2 hours ago was: 2023-03-11 21:19:00 March Saturdaycomputing lasted 2311mscomputing with high_resolution_clock yielded 2311700nanoseconds!</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值引用和右值引用</title>
      <link href="/p/64657.html"/>
      <url>/p/64657.html</url>
      
        <content type="html"><![CDATA[<h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>移动语义是现代c++重要特性，移动语义不适用于通过const引用将传递参数替换为方法。移动操作可能比拷贝操作快，但最坏情况下，他可能比拷贝慢，并且总是比通过const引用传递慢。</p><pre><code>#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);    &#125;    ~MyClass()    &#123;        --(*m_Member);        m_Member = nullptr;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;int main()&#123;    auto object1 = MyClass();    cout &lt;&lt; object1.GetValue()&lt;&lt;endl;    &#123;        auto object2 = MyClass();        cout &lt;&lt; object2.GetValue() &lt;&lt; endl;    &#125;    auto object3 = MyClass();    cout &lt;&lt; object3.GetValue() &lt;&lt; endl;    return 0;&#125;</code></pre><p>利用static成员统计内存中类的活动实例数<br>当MyClass包含拷贝构造函数后</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Constructing: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    ~MyClass()    &#123;        --(*m_Member);        m_Member = nullptr;        cout &lt;&lt; &quot;Destructing: &quot; &lt;&lt; s_Counter &lt;&lt; endl;    &#125;    MyClass(const MyClass&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Copying: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;MyClass CopyMyClass(MyClass parameter)&#123;    cout &lt;&lt; &quot;!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl;    return parameter;&#125;int main()&#123;    auto object1 = MyClass();    &#123;        auto object2 = MyClass();    &#125;    auto object3 = MyClass();    auto object4 = CopyMyClass(object3);    return 0;&#125;</code></pre><p>输出结果为：</p><pre><code>Constructing: 1Constructing: 2Destructing: 1Constructing: 2Copying: 3!!!!!!!!!!!!Copying: 4Destructing: 3Destructing: 2Destructing: 1Destructing: 0</code></pre><p>这里object3拷贝到参数中，然后返回值拷贝到object4中，之后调用析构函数析构这两个临时参数。<br>移动构造函数可以用来降低拷贝构造函数的复杂性，运行时将有同样多的对象，右值引用是编译器包中变量引用的对象是临时对象，所以可以随意拆解对象，可以进行更快的拷贝操作。</p><pre><code>#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;class MyClass &#123;private:    static int s_Counter;    int* m_Member&#123; &amp;s_Counter &#125;;public:    MyClass()    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Constructing: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    ~MyClass()    &#123;        if (m_Member)        &#123;            --(*m_Member);            m_Member = nullptr;            cout &lt;&lt; &quot;Destructing: &quot; &lt;&lt; s_Counter &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;Destroying a moved-from instance&quot; &lt;&lt; endl;        &#125;            &#125;    MyClass(const MyClass&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        ++(*m_Member);        cout &lt;&lt; &quot;Copying: &quot; &lt;&lt; GetValue() &lt;&lt; endl;    &#125;    MyClass(MyClass&amp;&amp; rhs)        : m_Member&#123; rhs.m_Member &#125;    &#123;        cout &lt;&lt; hex &lt;&lt; showbase;        cout &lt;&lt; &quot;Moving: &quot; &lt;&lt; &amp;rhs &lt;&lt; &quot; to &quot; &lt;&lt; this &lt;&lt; endl;        cout &lt;&lt; noshowbase &lt;&lt;dec;        rhs.m_Member = nullptr;    &#125;    int GetValue()const    &#123;        return *m_Member;    &#125;&#125;;int MyClass::s_Counter&#123; 0 &#125;;MyClass CopyMyClass(MyClass parameter)&#123;    cout &lt;&lt; &quot;!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl;    return parameter;&#125;int main()&#123;    auto object1 = MyClass();    &#123;        auto object2 = MyClass();    &#125;    auto object3 = MyClass();    auto object4 = CopyMyClass(object3);    return 0;&#125;</code></pre><p>运行结果为：</p><pre><code>Constructing: 1Constructing: 2Destructing: 1Constructing: 2Copying: 3!!!!!!!!!!!!!!!!!Moving: 001CF894 to 001CF988Destroying a moved-from instanceDestructing: 2Destructing: 1Destructing: 0</code></pre><p>返回语句结束后，编译器不需要维护参数的状态，可以调用移动构造来创建object4</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda的使用</title>
      <link href="/p/57725.html"/>
      <url>/p/57725.html</url>
      
        <content type="html"><![CDATA[<h1 id="lambda的使用"><a href="#lambda的使用" class="headerlink" title="lambda的使用"></a>lambda的使用</h1><p>c++ 引入了lambda，可以用来创建闭包并且在代码中传递</p><p>例如：</p><pre><code>int main()&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    std::for_each(myArray.begin(),myArray.end(),[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;);    return 0;&#125;</code></pre><p>lambda还可以通过变量来引用:</p><pre><code>int main()&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    auto func=[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;;    std::for_each(myArray.begin(),myArray.end(),func);    return 0;&#125;</code></pre><p>func存储了闭包类型，c++提供了一种方法来传递不同类型的对象，这些对象可以像函数一样调用</p><pre><code>void print(const std::function&lt;void(std::array&lt;uint32_t,5&gt;::value_type)&gt;&amp;func)&#123;    std::array&lt;uint32_t,5&gt; myArray&#123;1,2,3,4,5&#125;;    std::for_each(myArray.begin(),myArray.end(),func);&#125;int main()&#123;    auto func=[](auto&amp;&amp; number)    &#123;        std::cout&lt;&lt;number&lt;&lt;std::endl;    &#125;;    print(func);    return 0;&#125;</code></pre><p>同时，lambda表达式还可以通过引用捕获来共享变量来进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译时常量的使用</title>
      <link href="/p/28630.html"/>
      <url>/p/28630.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译时常量的使用"><a href="#编译时常量的使用" class="headerlink" title="编译时常量的使用"></a>编译时常量的使用</h1><p>constexpr 关键字可以用于创建变量和函数，保证编译时对他们进行计算</p><p>例1：</p><pre><code>int main()&#123;    constexpr uint32_t ARRAY_SIZE&#123;5&#125;;    std::array&lt;uint32_t,ARRAY_SIZE&gt;myArray&#123;1,2,3,4,5&#125;;    for(auto&amp;&amp; num:myArray)    &#123;        std::cout&lt;&lt;num&lt;&lt;std::endl;    &#125;    return 0;&#125;</code></pre><p>constexpr 保证了在编译时可以计算值的大小，因为Array的大小必须在编译时确定。<br>此外，函数也可以使用constexpr</p><p>例2：</p><pre><code>constexpr uint32_t A(int a)&#123;    return a;&#125;</code></pre><p>constexpr还可以构建一个类<br>例3:</p><pre><code>class Test&#123;private:    uint32_t m_member;public:    constexpr Test(uint32_t a)        : m_member(a)    &#123;    &#125;    constexpr uint32_t getValue()&#123;        return m_member;    &#125;&#125;</code></pre><p>在c++11当中，constexpr不可以做c++代码的许多事情，比如创建变量和使用if语句循环语句<br>下面代码展示了c++14的constexpr用法<br>例4:</p><pre><code>constexpr uint32_t ArraySizeFunc(uint32_t para)&#123;    uint32_t value&#123;para&#125;;    if(value&gt;10)    &#123;        value=10;    &#125;    return value;&#125;</code></pre><p>实际上,constexpr返回的并不是常量<br>例5：</p><pre><code>constexpr int count()&#123;    return 99;&#125;int main()&#123;    int temp=count();    temp=2;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型推断</title>
      <link href="/p/5639.html"/>
      <url>/p/5639.html</url>
      
        <content type="html"><![CDATA[<h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><h2 id="模板型别推导"><a href="#模板型别推导" class="headerlink" title="模板型别推导"></a>模板型别推导</h2><p>模板的型别推导是现代c++最广泛应用的特性之一————————auto的基础，了解作为auto基础的模板型别推导就十分重要。<br>函数模板大致形如：</p><pre><code>template&lt;typename T&gt;void f(ParamType param);</code></pre><p>而一次调用则形如：</p><pre><code>f(expr);   //以某个表达式调用f</code></pre><p>在编译期，编译器会通过expr推导两个型别：一个是T的型别，另一个是ParamType 的型别，两个型别往往不一样，因为ParamType常会包含了一些修饰词，如const或引用符号等限定词。例如，若模板声明如下：</p><pre><code>template&lt;typename T&gt;void f(const T&amp; param);</code></pre><p>而调用语句如下：</p><pre><code>int x=0;f(x);</code></pre><p>在此例中，T会被推导为int，ParamType则被推导为const int&amp;。<br>但具体而言，T的型别推导结果不仅依赖于expr的型别，还依赖于ParamType 的形式，具体分为三种情况讨论：</p><ul><li>ParamType具有指针或者引用型别，但不是万能引用</li><li>ParamType是一个万能引用</li><li>ParamType既非指针也非引用</li></ul><h3 id="ParamType具有指针或者引用型别，但不是万能引用"><a href="#ParamType具有指针或者引用型别，但不是万能引用" class="headerlink" title="ParamType具有指针或者引用型别，但不是万能引用"></a>ParamType具有指针或者引用型别，但不是万能引用</h3><ol><li>若expr具有引用型别，先将引用部分忽略</li><li>对expr的型别和ParamType 的型别执行模式匹配，来决定T的型别。</li></ol><p>例如模式如下：</p><pre><code>template&lt;typename T&gt;void f(T&amp; param);</code></pre><p>又声明了下列变量：</p><pre><code>int x = 27;const int cx = x;const int&amp; rx = x;</code></pre><p>在各次调用中，对param和T 的型别推导结果如下：</p><pre><code>f(x);   //T的型别是int，param的型别是int&amp;f(cx);  //T的型别是const int，param的型别是const int&amp;f(rx);  //T的型别是const int，param的型别是const int&amp;</code></pre><p>rx 的引用性会在型别推导过程中被忽略</p><p>如果我们在ParamType中加入const属性：</p><pre><code>template&lt;typename T&gt;void f(const T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int，param的型别是const int&amp;f(cx);  //T的型别是int，param的型别是const int&amp;f(rx);  //T的型别是int，param的型别是const int&amp;</code></pre><p>同上，rx 的引用性会在型别推导过程中被忽略。</p><p>如果param是一个指针，而非引用，运作方式本质上并无不同：<br>    template<typename t><br>    void f(T* param);</typename></p><pre><code>int x = 27;const int *px = &amp;x;f(&amp;x);   //T的型别是int，param的型别是int*f(px);  //T的型别是const int，param的型别是const int*</code></pre><h3 id="ParamType是一个万能引用"><a href="#ParamType是一个万能引用" class="headerlink" title="ParamType是一个万能引用"></a>ParamType是一个万能引用</h3><ol><li>如果expr是个左值，T和ParamType都会被推导为左值引用。</li><li>如果expr是个右值，则应用第一条规则。</li></ol><p>例如：</p><pre><code>template&lt;typename T&gt;void f(T&amp;&amp; param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int&amp;，param的型别是int&amp;f(cx);  //T的型别是const int&amp;，param的型别是const int&amp;f(rx);  //T的型别是const int&amp;，param的型别是const int&amp;f(27);  //T的型别是int，param的型别是int&amp;&amp;</code></pre><h3 id="ParamType既非指针也非引用"><a href="#ParamType既非指针也非引用" class="headerlink" title="ParamType既非指针也非引用"></a>ParamType既非指针也非引用</h3><ol><li>若expr具有引用型别，先将引用部分忽略</li><li>若expr是个const,volatile对象，则忽略之</li></ol><p>例如：</p><pre><code>template&lt;typename T&gt;void f(T param);int x = 27;const int cx = x;const int&amp; rx = x;f(x);   //T的型别是int，param的型别是intf(cx);  //T的型别是int，param的型别是intf(rx);  //T的型别是int，param的型别是int</code></pre><p>param是个完全独立于cx和rx的对象，是他的一个副本，即使expr不可修改，param也和他无关。<br>需要说明的是，expr是个指向const对象的const指针，且expr按值传给param：</p><pre><code>template&lt;typename T&gt;void f(T param);const char* const ptr = &quot;test&quot;;f(ptr);   //T的型别是const char*，param的型别是const char*</code></pre><h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>数组型别有别于指针型别，数组会退化成首元素的指针。</p><pre><code>const char name[] = &quot;Test&quot;;    //name的型别是const char[5]; &#39;\0&#39;const char* ptrToName = name;  //数组退化成指针 const char *</code></pre><p>当一个数组传递到持有按值形参的模板时</p><pre><code>template&lt;typename T&gt;void f(T param);f(name);void myFunc(int param[]);//这意味着myFunc等价的声明如下：void myFunc(int* param);</code></pre><p>这种数组和指针形参的等价性，是c++基础的c根源遗迹，它使得“数组和指针型别是一回事”<br>由于数组形参声明会按照他们好像是指针形参那样加以处理，按值传递给函数模板的数组型别将被推导成指针型别。<br>也就是说，在模板f的调用中，其类型形参T会被推到成const char*</p><pre><code>f(name);   //name是个数组，但是却被推导成了const char*</code></pre><p>尽管函数无法声明数组类型的形参，他们却可以声明形参为数组的引用！</p><pre><code>template&lt;typename T&gt;void f(T&amp; param);f(name);</code></pre><p>在这种情况下，T会被推导成实际的数组类型，这个型别会包含数组的尺寸 T 的推导类型为const char[5];param则被推导为const char(&amp;)[5];</p><pre><code>template&lt;typename T,std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N])noexception&#123;    return N;&#125;</code></pre><p>我们可以利用模板推导出数组含有的元素个数。</p><h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3><p>和数组一样，函数也会退化成函数指针</p><pre><code>void someFunc(int,double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc);  //param具体型别 void (*)(int,double)f2(someFunc);  //param具体型别 void (&amp;)(int,double)</code></pre><h2 id="auto-型别推导"><a href="#auto-型别推导" class="headerlink" title="auto 型别推导"></a>auto 型别推导</h2><p>auto推导规则和模板类型推导大致相同，也是分为三种类型</p><ul><li>ParamType具有指针或者引用型别，但不是万能引用</li><li>ParamType是一个万能引用</li><li>ParamType既非指针也非引用</li></ul><p>这里不进行细致研究，下面是一些例子，规则参考模板类型推导：</p><pre><code>auto x = 27;const auto cx = x;const auto&amp; rx = x;auto&amp;&amp; uref1 = x;// int&amp;auto&amp;&amp; uref1 = cx;// const int&amp;auto&amp;&amp; uref1 = 27;// int&amp;&amp;</code></pre><p>同时，关于数组指针以及函数指针相关退化规则也完全相同：</p><pre><code>const char name[] = &quot;test&quot;;auto arr1 = name;// const char*auto arr2 = name;// const char (&amp;)[5]void someFunc(int,double);auto func1 = someFunc;// void (*)(int,double)auto&amp; func2 = someFunc;// void (&amp;)(int,double)</code></pre><p>但是auto类型推导有一个例外，由于c++支持统一初始化</p><pre><code>int x3 = &#123;2&#125;;auto x4 = &#123;2&#125;;</code></pre><p>这里x3是int类型，但是x4类型并不是int，而是std::initializer_list<int><br>这也是auto和模板类型推导的主要区别，例如：</int></p><pre><code>auto x = &#123;1,2,3,4,5&#125;;// x的类型是std::initializer_list&lt;int&gt; template&lt;typename T&gt;void f(T param);f(&#123;1,2,3,4,5&#125;);//错误，无法推导T的型别</code></pre><p>但是如果你指定模板参数类型为std::initializer_list<T> 推导机制则会推导出T的类型</T></p><pre><code>template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; param);f(&#123;1,2,3,4,5&#125;);//推导T的型别为int</code></pre><h2 id="auto-作为函数返回类型"><a href="#auto-作为函数返回类型" class="headerlink" title="auto 作为函数返回类型"></a>auto 作为函数返回类型</h2><p>c++处理函数时使用类型推断的情况有两种类型</p><ul><li>创建一个模板函数并在没有显式具体化的情况下调用该函数，可以推断函数参数的类型</li><li>代替函数的返回值类型</li></ul><p>例如：</p><pre><code>auto AutoFunction(int t)&#123;    return t;&#125;</code></pre><p>c++11 这里会出现错误，后续版本解决了这个问题。<br>c++11解决该问题的方法是指定函数返回类型：</p><pre><code>auto AutoFunction(int t)-&gt;int&#123;    return t;&#125;</code></pre><p>但是如果在模板函数中，返回类型不确定，这时候需要引入一个新的关键字来进行推导：<strong>decltype</strong></p><pre><code>template&lt;typename T&gt;auto AutoFunction(T t)-&gt;decltype(t)&#123;    return t;&#125;</code></pre><p>c++14 纠正了这一情况，即使是和模板一起使用auto推导返回值类型也不需要后置返回值类型。<br>在C++14中，编译器可以直接推断出函数的返回类型了，所以可以写成下边的样子：</p><pre><code>decltype(auto) AutoFunction(int t)-&gt;int&#123;    return t;&#125;  //或者直接下面这种方式也可以 auto AutoFunction(int t)-&gt;int&#123;    return t;&#125;</code></pre><p>但是二者有所区别，auto会自动去除返回值的引用性，但是decltyoe会保留原有属性，<br>在一般情况下，decltype都是返回给定表达式或者给定的名字的类型，但是在某些情况下还是有点问题,如果仅有一个名字，那么decltype的行为保持不变，但如果是一个复杂度左值表达式，decltype会返回一个左值引用。</p><pre><code>//返回intdelctype(auto) f1()&#123;    int x = 0;    ....    return x;&#125;//返回int&amp;delctype(auto) f1()&#123;    int x = 0;    ....    return (x);&#125;</code></pre><p>auto的使用还需要注意一下代理类相关的问题。比如：</p><pre><code>std::vector&lt;bool&gt; features(const Widget&amp; w);Widget w;auto temp = features(w)[5];</code></pre><p>temp的类型并不是我们想象中的bool，这是因为vector对bool类型做过特化，每一个bool元素用一个比特位进行表示，返回值并不是bool类型，而是std::vector<bool>::reference;std::vector<bool>::reference能够向bool进行隐式类型转换</bool></bool></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化变量</title>
      <link href="/p/54280.html"/>
      <url>/p/54280.html</url>
      
        <content type="html"><![CDATA[<h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>统一初始化是c++11的一个重要特性<br>例如：</p><pre><code>class MyClass&#123;&#125;int main()&#123;    MyClass a;    MyClass b(MyClass());    return 0;&#125;</code></pre><p>c++编译器不会把<code>MyClass b(MyClass());</code>看作是定义了一个类型为MyClass且名称为b的变量，它调用了一个构造函数并且接收MyClass产生的对象，实际上，编译器会认为这是一个函数声明，声明一个b的函数，返回MyClass，有一个未命名的函数指针指向返回MyClass对象的函数。</p><pre><code>class MyClass&#123;&#125;int main()&#123;    MyClass a;    MyClass b&#123; MyClass&#123;&#125; &#125;;    return 0;&#125;</code></pre><p>统一初始化几乎可以初始化所有变量，他的另一个好处就是可以防止变量缩窄</p><pre><code>char a=&#123;512&#125;;</code></pre><p>除非强制类型转换告诉编译器我要允许缩窄，否则编译器不会编译此代码。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委派构造函数</title>
      <link href="/p/19966.html"/>
      <url>/p/19966.html</url>
      
        <content type="html"><![CDATA[<h1 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h1><p>委派构造函数是在C++11标准新引入的一项改进，主要目的是为了减少程序员在构造函数方面花费的工作。通过委派构造函数使之对于构造函数的编写更加简单。</p><h2 id="委派构造函数引入"><a href="#委派构造函数引入" class="headerlink" title="委派构造函数引入"></a>委派构造函数引入</h2><p>在下面这段代码中，定义了一个Class Info。这个类中有俩个成员变量，三个构造函数，但是三个构造函数都共同调用了InitRest方法。所以我们看到各个构造函数都有或多或少的相似之处。为此C++11引入了委派构造函数。</p><pre><code>class Info&#123;public:    Info() :type(1), name(&#39;a&#39;)    &#123;        InitRest();    &#125;    Info(int i) :type(i), name(&#39;a&#39;)    &#123;        InitRest();    &#125;    Info(char ch) :type(1), name(ch)    &#123;        InitRest();    &#125;private:    void InitRest()&#123; /* 其他初始化 */ &#125;    int type;    char name;&#125;;</code></pre><p>可以看到，我们声明了一个Info的自定义类型。该类型拥有2个成员变量以及3个构造函数。这里的3个构造函数都声明了初始化列表来初始化成员type和name，并且都调用了相同的函数InitRest。可以看到，除了初始化列表有的不同，而其他的部分，3个构造函数基本上是相似的，因此其代码存在着很多重复。这里其实我们可以通过成员初始化方式，可以使得初始化列表变得简洁化。</p><pre><code>class Info&#123;public:    Info()    &#123;        InitRest();    &#125;    Info(int i) :type(i)    &#123;        InitRest();    &#125;    Info(char ch) :name(ch)    &#123;        InitRest();    &#125;private:    void InitRest() &#123; /* 其他初始化 */&#125;    int type &#123;1&#125;;    char name &#123;&#39;a&#39;&#125;;&#125;;</code></pre><p>可以看到，我们的代码相对简洁了很多，但是每个构造函数还是需要调用InitRest函数进行初始化。而现实编程中，构造函数中的代码还会更长，比如可能还需要调用一些基类的构造函数等。那能不能让代码进一步优化呢？这里就用到了委派构造函数方式进行优化。</p><pre><code>// 通过委派构造函数进行优化class Info&#123;public:    Info()    &#123;        InitRest();    &#125;    Info(int i) : Info()    &#123;        type = i;    &#125;    Info(char ch) : Info() // 委派构造函数不能使用初始化列表 初始化成员变量    &#123;        name = ch;    &#125;private:    void InitRest() &#123; /* 其他初始化 */&#125;    int type&#123; 1 &#125;;    char name&#123; &#39;a&#39; &#125;;&#125;;</code></pre><p>委派构造函数说白了就是将构造的任务分派给一个目标构造函数来完成。</p><ul><li>委派构造函数：初始化列表中调用“基准版本”的构造函数就是委派构造函数。</li><li>目标构造函数：被调用“基准版本”构造函数就是目标构造函数。</li></ul><p>构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计子矩阵</title>
      <link href="/p/35775.html"/>
      <url>/p/35775.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>给定一个 N × M 的矩阵 A , 请你统计有多少个子矩阵 (最小 1 × 1, 最大 N × M ) 满足子矩阵中所有数的和不超过给定的整数 K  ?</p><p>输入格式<br>第一行包含三个整数 N , M 和 K .</p><p>之后 N行每行包含 M 个整数, 代表矩阵 A.</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入：    3 4 10    1 2 3 4    5 6 7 8    9 10 11 12输出：19</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>首先，求取一个矩阵的和可以采用二维前缀和简化计算，降低复杂度。其次，不难想到，我们可以枚举左上角坐标以及右下角坐标求出所有满足条件的矩阵，但是这样复杂度就是n^4，时间复杂度相对难以接受。所以我们应该想办法降低复杂度，根据题目要求，不大于k,那么一个矩阵的子矩阵大于k则该矩阵就无需判断，这样利用双指针，我们可以在O(n)的时间求出这一行的矩阵。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include &lt;iostream&gt;using namespace std;int a[510][510];int sum1(int x1,int y1,int x2,int y2)&#123;    return a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1];&#125;int main()&#123;    int n,m,k;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);    long long int ans=0;    int temp;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;        scanf(&quot;%d&quot;,&amp;temp);        a[i][j]=a[i-1][j]+a[i][j-1]+temp-a[i-1][j-1];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = i; j &lt;= n; ++j) &#123;                for (int l = 1, r = 1; r &lt;= m; ++r) &#123;                    while (l &lt;= r &amp;&amp; sum1(i, l, j, r) &gt; k) l++;                    ans += r - l + 1;                &#125;            &#125;        &#125;    cout &lt;&lt; ans;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashtable</title>
      <link href="/p/51768.html"/>
      <url>/p/51768.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>hashtable 的目的是为了提供任何操作都是常数级别</p><h2 id="hashtable基本概念"><a href="#hashtable基本概念" class="headerlink" title="hashtable基本概念"></a>hashtable基本概念</h2><p>功能：将数据进行链式存储<br>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列结点组成<br>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p><strong>list的优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点：</strong></p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</T></li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    list&lt;int&gt;L2(L1.begin(),L1.end());    printList(L2);    list&lt;int&gt;L3(L2);    printList(L3);    list&lt;int&gt;L4( 10 , 1000 );    printList(L4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h2><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    //赋值    list&lt;int&gt;L2;    L2 = L1;    printList(L2);    list&lt;int&gt;L3;    L3.assign(L2.begin(), L2.end());    printList(L3);    list&lt;int&gt;L4;    L4.assign( 10 , 100 );    printList(L4);&#125;//交换void test02()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    list&lt;int&gt;L2;    L2.assign( 10 , 100 );    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);    cout &lt;&lt; endl;    L1.swap(L2);    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    if (L1.empty())    &#123;        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;    &#125;    //重新指定大小    L1.resize( 10 );    printList(L1);    L1.resize( 2 );    printList(L1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h2><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;//插入和删除void test01()&#123;    list&lt;int&gt; L;    //尾插    L.push_back( 10 );    L.push_back( 20 );    L.push_back( 30 );    //头插    L.push_front( 100 );    L.push_front( 200 );    L.push_front( 300 );    printList(L);    //尾删    L.pop_back();    printList(L);    //头删    L.pop_front();    printList(L);    //插入    list&lt;int&gt;::iterator it = L.begin();    L.insert(++it, 1000 );    printList(L);    //删除    it = L.begin();    L.erase(++it);    printList(L);    L.push_back( 10000 );    L.push_back( 10000 );    L.push_back( 10000 );    printList(L);    L.remove( 10000 );    printList(L);    //清空    L.clear();    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h2><ul><li><p>front(); &#x2F;&#x2F;返回第一个元素。</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素。</p></li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;//数据存取void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;    //list容器的迭代器是双向迭代器，不支持随机访问    list&lt;int&gt;::iterator it = L1.begin();    //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：list容器中不可以通过[]或者at方式访问数据</p><ul><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h2 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h2><ul><li><p>reverse(); &#x2F;&#x2F;反转链表</p></li><li><p>sort(); &#x2F;&#x2F;链表排序</p></li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;    return val1 &gt; val2;&#125;//反转和排序void test01()&#123;    list&lt;int&gt; L;    L.push_back( 90 );    L.push_back( 30 );    L.push_back( 20 );    L.push_back( 70 );    printList(L);    //反转容器的元素    L.reverse();    printList(L);    //排序    L.sort(); //默认的排序规则 从小到大    printList(L);    L.sort(myCompare); //指定规则，从大到小    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h3><h4 id="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"><a href="#案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高" class="headerlink" title="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"></a>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</h4><h4 id="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"><a href="#排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序" class="headerlink" title="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"></a>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</h4><h5 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:    Person(string name, int age , int height) &#123;        m_Name = name;        m_Age = age;        m_Height = height;    &#125;public:    string m_Name; //姓名    int m_Age; //年龄    int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    else    &#123;        return p1.m_Age &lt; p2.m_Age;    &#125;&#125;void test01() &#123;    list&lt;Person&gt; L;    Person p1(&quot;刘备&quot;, 35 , 175 );    Person p2(&quot;曹操&quot;, 45 , 180 );    Person p3(&quot;孙权&quot;, 40 , 170 );    Person p4(&quot;赵云&quot;, 25 , 190 );    Person p5(&quot;张飞&quot;, 35 , 160 );    Person p6(&quot;关羽&quot;, 35 , 200 );    L.push_back(p1);    L.push_back(p2);    L.push_back(p3);    L.push_back(p4);    L.push_back(p5);    L.push_back(p6);    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;    L.sort(ComparePerson); //排序    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/p/1.html"/>
      <url>/p/1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-回答下面的问题（请编写-Markdown-文档一并上传到仓库）"><a href="#1-回答下面的问题（请编写-Markdown-文档一并上传到仓库）" class="headerlink" title="1. 回答下面的问题（请编写 Markdown 文档一并上传到仓库）"></a>1. 回答下面的问题（请编写 Markdown 文档一并上传到仓库）</h2><h3 id="问题1-根据下面的图片，回答问题"><a href="#问题1-根据下面的图片，回答问题" class="headerlink" title="问题1 : 根据下面的图片，回答问题"></a>问题1 : 根据下面的图片，回答问题</h3><p><a href="https://imgse.com/i/ppf2lbd"><img src="https://s1.ax1x.com/2023/04/02/ppf2lbd.png" alt="ppf2lbd.png"></a></p><h5 id="解释下面概念"><a href="#解释下面概念" class="headerlink" title="解释下面概念"></a>解释下面概念</h5><pre><code>◦ workspace : 工作区，平时存放项目代码的地方◦ staging area :暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件◦ local repository : 仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本;◦ remote repository : 远程仓库，托管代码的服务器</code></pre><h3 id="问题2-：-如何解决-git-冲突"><a href="#问题2-：-如何解决-git-冲突" class="headerlink" title="问题2 ： 如何解决 git 冲突?"></a>问题2 ： 如何解决 git 冲突?</h3><p>删除代码中矛盾的代码或者恢复到以前版本</p><h3 id="问题3-出现下面问题的原因与解决方案是什么"><a href="#问题3-出现下面问题的原因与解决方案是什么" class="headerlink" title="问题3 : 出现下面问题的原因与解决方案是什么?"></a>问题3 : 出现下面问题的原因与解决方案是什么?</h3><pre><code>◦ 更新代码后显示： unable to unlink old ‘xxx/xxx/xx’ : invalid argument    ▪ 原因:因为XXX正在被运行，        ▪ 解决方案:先把它的进程关闭，重试一下就好了。    ◦ 更新代码后显示 :  the following untracked working tree files would be overwritten by checkout    ▪ 原因: Error 所列出的文件在本地的当前分支下未授权给 git 追踪，但同样命名的文件，也即出现在另一个（远程）分支下的同一文件却正在远程仓库或其它分支被 git 进行追踪        ▪ 解决方案: git clean -d -fx 删除当前目录及子文件夹下的未 track 的文件及文件夹◦ 更新代码后显示 : your local changes to the following files would be overwritten by merge…please move or remove them before you merge    ▪ 原因:git merge时本地分支的更改没有保存下来        ▪ 解决方案:暂存到堆栈区◦ 版本回退git reset --hard &#123;hash&#125;后提示：fatal: could not parse object “hash id”    ▪ 原因:切换到master分支后没有更新最新代码        ▪ 解决方案:先通过git pull --rebase更新当前分支代码，然后再执行git reset◦ git push后提示:to https://.git![rejected] localRepo-&gt;remoteRepo(fetch first)error: failed to push some refs to ‘https://.git’Updates were rejected because the remote contain work that you do not have locally.    ▪ 原因:远程包含的事务不在你的本地，在push前需要整合远端，    ▪ 解决方案:拉取远端的代码然后进行整合到本地，再push到远端即可</code></pre><h2 id="2-完成下列操作"><a href="#2-完成下列操作" class="headerlink" title="2. 完成下列操作"></a>2. 完成下列操作</h2><h5 id="下面的操作完成后，"><a href="#下面的操作完成后，" class="headerlink" title="下面的操作完成后，"></a>下面的操作完成后，</h5><pre><code>a. 克隆仓库 git clone + urlb. 提交修改到暂存区 git add .c. 提交修改到远程仓库 git push commit -m &quot;xxxx&quot;d. 从远程仓库下载代码 git pulle. 查看仓库状态 git statusf. 比较文件的不同,即暂存区与工作区的差别 git  diffg. 创建分支/切换分支/查看分支列表 git branch xxx /git check out /git branch -vh. 上传代码到分支上 git push -u origin xxxi. 合并分支到主分支 git merge xxxj. 删除分支 删除远程分支xxx git push origin --delete xxx /删除本地分支xxx  git branch -d xxxk. 回退到某个版本 git reset --hard 版本库地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>棘手怀念摧毁</title>
      <link href="/p/12758.html"/>
      <url>/p/12758.html</url>
      
        <content type="html"><![CDATA[<h1 id="棘手怀念摧毁"><a href="#棘手怀念摧毁" class="headerlink" title="棘手怀念摧毁"></a>棘手怀念摧毁</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p><img src="/p/12758.htm/%E6%A3%98%E6%89%8B%E6%80%80%E5%BF%B5%E6%91%A7%E6%AF%81.png"></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>输入格式:第一行有三个整数n,m，A ;<br>第二行有n个数ai，表示每头大象的愤怒值。<br>输出格式:一个整数表示新大象住下后象棚最大的愤怒值。</p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>样例1</p><pre><code>输入:   3 2 50        60 100 70输出:270</code></pre><p>备注<br>其中:1≤m≤n ≤5* 106，0 ≤ai, A ≤100。【样例解释】<br>1.当新大象在第一个位置时(50,60,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 60,100 + max 100,70，即60＋100＋100&#x3D;260。<br>2.当新大象在第二个位置时( 60,50,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 50,100 + max 100,70，即60＋100+100&#x3D; 260。<br>3.当新大象在第三个位置时( 60,100,50,70 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,50 + max 50,70，即100＋100＋70 &#x3D; 270。<br>4.当新大象在第四个位置时( 60,100,70,50 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,70 + max 70,50，即70＋100＋100 &#x3D; 270。<br>整个象棚的愤怒值的最大值为max 260,260,270,270 &#x3D; 270。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataRedis</title>
      <link href="/p/5455.html"/>
      <url>/p/5455.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1652976773295.png" alt="1652976773295"></p><h2 id="导入pom坐标"><a href="#导入pom坐标" class="headerlink" title="导入pom坐标"></a>导入pom坐标</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.7&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;artifactId&gt;redis-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;redis-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--redis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--common-pool--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="yaml">spring:  redis:    host: 192.168.150.101    port: 6379    password: 123321    lettuce:      pool:        max-active: 8  #最大连接        max-idle: 8   #最大空闲连接        min-idle: 0   #最小空闲连接        max-wait: 100ms #连接等待时间</code></pre><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre><code class="java">@SpringBootTestclass RedisDemoApplicationTests &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        redisTemplate.opsForValue().set(&quot;name&quot;, &quot;虎哥&quot;);        // 获取string数据        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;&#125;</code></pre><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h2 id="数据序列化器"><a href="#数据序列化器" class="headerlink" title="数据序列化器"></a>数据序列化器</h2><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://i.imgur.com/OEMcbuu.png"></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://i.imgur.com/5FjtWk5.png"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><pre><code class="java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;        // 创建RedisTemplate对象        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置连接工厂        template.setConnectionFactory(connectionFactory);        // 创建JSON序列化工具        GenericJackson2JsonRedisSerializer jsonRedisSerializer =                                         new GenericJackson2JsonRedisSerializer();        // 设置Key的序列化        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // 设置Value的序列化        template.setValueSerializer(jsonRedisSerializer);        template.setHashValueSerializer(jsonRedisSerializer);        // 返回        return template;    &#125;&#125;</code></pre><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://i.imgur.com/XOAq3cN.png"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h2><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://i.imgur.com/zXH6Qn6.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testString() &#123;        // 写入一条String数据        stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;);        // 获取string数据        Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;    private static final ObjectMapper mapper = new ObjectMapper();    @Test    void testSaveUser() throws JsonProcessingException &#123;        // 创建对象        User user = new User(&quot;虎哥&quot;, 21);        // 手动序列化        String json = mapper.writeValueAsString(user);        // 写入数据        stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json);        // 获取数据        String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;);        // 手动反序列化        User user1 = mapper.readValue(jsonUser, User.class);        System.out.println(&quot;user1 = &quot; + user1);    &#125;&#125;</code></pre><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="/p/5455.htm/.%5CRedis.assets%5C1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h2 id="Hash结构操作"><a href="#Hash结构操作" class="headerlink" title="Hash结构操作"></a>Hash结构操作</h2><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><pre><code class="java">@SpringBootTestclass RedisStringTests &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testHash() &#123;        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;name&quot;, &quot;虎哥&quot;);        stringRedisTemplate.opsForHash().put(&quot;user:400&quot;, &quot;age&quot;, &quot;21&quot;);        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:400&quot;);        System.out.println(&quot;entries = &quot; + entries);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis</title>
      <link href="/p/26793.html"/>
      <url>/p/26793.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Jedis入门"><a href="#Jedis入门" class="headerlink" title="Jedis入门"></a>Jedis入门</h2><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="/p/26793.htm/%5CRedis.assets%5C1652959239813.png" alt="1652959239813"></p><p>1）引入依赖：</p><pre><code class="xml">&lt;!--jedis--&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--单元测试--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><pre><code class="java">private Jedis jedis;@BeforeEachvoid setUp() &#123;    // 1.建立连接    // jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);    jedis = JedisConnectionFactory.getJedis();    // 2.设置密码    jedis.auth(&quot;123321&quot;);    // 3.选择库    jedis.select(0);&#125;</code></pre><p>3）测试：</p><pre><code class="java">@Testvoid testString() &#123;    // 存入数据    String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;);    System.out.println(&quot;result = &quot; + result);    // 获取数据    String name = jedis.get(&quot;name&quot;);    System.out.println(&quot;name = &quot; + name);&#125;@Testvoid testHash() &#123;    // 插入hash数据    jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;);    jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;);    // 获取    Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;);    System.out.println(map);&#125;</code></pre><p>4）释放资源</p><pre><code class="java">@AfterEachvoid tearDown() &#123;    if (jedis != null) &#123;        jedis.close();    &#125;&#125;</code></pre><h2 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h2><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h3 id="创建Jedis的连接池"><a href="#创建Jedis的连接池" class="headerlink" title="创建Jedis的连接池"></a>创建Jedis的连接池</h3><pre><code class="java">public class JedisConnectionFacotry &#123;     private static final JedisPool jedisPool;     static &#123;         //配置连接池         JedisPoolConfig poolConfig = new JedisPoolConfig();         poolConfig.setMaxTotal(8);         poolConfig.setMaxIdle(8);         poolConfig.setMinIdle(0);         poolConfig.setMaxWaitMillis(1000);         //创建连接池对象         jedisPool = new JedisPool(poolConfig,                 &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;);     &#125;     public static Jedis getJedis()&#123;          return jedisPool.getResource();     &#125;&#125;</code></pre><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h3 id="改造原始代码"><a href="#改造原始代码" class="headerlink" title="改造原始代码"></a>改造原始代码</h3><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><pre><code class="java">    @BeforeEach    void setUp()&#123;        //建立连接        /*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/        jedis = JedisConnectionFacotry.getJedis();         //选择库        jedis.select(0);    &#125;   @AfterEach    void tearDown() &#123;        if (jedis != null) &#123;            jedis.close();        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见命令</title>
      <link href="/p/31805.html"/>
      <url>/p/31805.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><h2 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="/p/31805.htm/1652887393157.png" alt="1652887393157"></p><p>Redis为了方便学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="/p/31805.htm/1652887648826.png" alt="1652887648826"></p><p>也可以通过Help命令来帮助我们去查看命令</p><p><img src="/p/31805.htm/1652887748279.png" alt="1652887748279"></p><h2 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="/p/31805.htm/1652887865189.png" alt="1652887865189"></p><p>代码如下</p><ul><li>KEYS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;# 查询以a开头的key127.0.0.1:6379&gt; keys a*1) &quot;age&quot;</code></pre><p><strong>在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help del  DEL key [key ...]  summary: Delete a key  since: 1.0.0  group: generic127.0.0.1:6379&gt; del name #删除单个(integer) 1  #成功删除1个127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;4) &quot;age&quot;127.0.0.1:6379&gt; del k1 k2 k3 k4(integer) 3   #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回127.0.0.1:6379&gt;127.0.0.1:6379&gt; keys * #再查询全部的key1) &quot;age&quot;    #只剩下一个了</code></pre><ul><li>EXISTS</li></ul><pre><code class="sh">127.0.0.1:6379&gt; help EXISTS  EXISTS key [key ...]  summary: Determine if a key exists  since: 1.0.0  group: generic127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; exists name(integer) 0</code></pre><ul><li>EXPIRE</li></ul><p><strong>内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</strong></p><pre><code class="sh">127.0.0.1:6379&gt; expire age 10(integer) 1127.0.0.1:6379&gt; ttl age(integer) 8127.0.0.1:6379&gt; ttl age(integer) 6127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; ttl age(integer) -2  #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间OK127.0.0.1:6379&gt; ttl age(integer) -1  # ttl的返回值就是-1</code></pre><h2 id="Redis命令-String命令"><a href="#Redis命令-String命令" class="headerlink" title="Redis命令-String命令"></a>Redis命令-String命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p>数值类型得字符串Redis会将其转为对应的二进制</p><p><img src="/p/31805.htm/1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><pre><code class="java">127.0.0.1:6379&gt; set name Rose  //原来不存在OK127.0.0.1:6379&gt; get name &quot;Rose&quot;127.0.0.1:6379&gt; set name Jack //原来存在，就是修改OK127.0.0.1:6379&gt; get name&quot;Jack&quot;</code></pre><ul><li>MSET和MGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; MGET name age k1 k2 k31) &quot;Jack&quot; //之前存在的name2) &quot;10&quot;   //之前存在的age3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v3&quot;</code></pre><ul><li>INCR和INCRBY和DECY</li></ul><pre><code class="java">127.0.0.1:6379&gt; get age &quot;10&quot;127.0.0.1:6379&gt; incr age //增加1(integer) 11    127.0.0.1:6379&gt; get age //获得age&quot;11&quot;127.0.0.1:6379&gt; incrby age 2 //一次增加2(integer) 13 //返回目前的age的值    127.0.0.1:6379&gt; incrby age 2(integer) 15    127.0.0.1:6379&gt; incrby age -1 //也可以增加负数，相当于减(integer) 14    127.0.0.1:6379&gt; incrby age -2 //一次减少2个(integer) 12    127.0.0.1:6379&gt; DECR age //相当于 incr 负数，减少正常用法(integer) 11    127.0.0.1:6379&gt; get age &quot;11&quot;</code></pre><ul><li>SETNX</li></ul><pre><code class="java">127.0.0.1:6379&gt; help setnx  SETNX key value  summary: Set the value of a key, only if the key does not exist  since: 1.0.0  group: string127.0.0.1:6379&gt; set name Jack  //设置名称OK127.0.0.1:6379&gt; setnx name lisi //如果key不存在，则添加成功(integer) 0127.0.0.1:6379&gt; get name //由于name已经存在，所以lisi的操作失败&quot;Jack&quot;127.0.0.1:6379&gt; setnx name2 lisi //name2 不存在，所以操作成功(integer) 1127.0.0.1:6379&gt; get name2 &quot;lisi&quot;</code></pre><ul><li>SETEX</li></ul><pre><code class="sh">127.0.0.1:6379&gt; setex name 10 jackOK127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 5</code></pre><h2 id="Redis命令-Key的层级结构"><a href="#Redis命令-Key的层级结构" class="headerlink" title="Redis命令-Key的层级结构"></a>Redis命令-Key的层级结构</h2><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="/p/31805.htm/1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如项目名称叫 hust，有user和product两种不同类型的数据，可以这样定义key：</p><ul><li><p>user相关的key：<strong>hust:user:1</strong></p></li><li><p>product相关的key：<strong>hust:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>hust:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>hust:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="Redis命令-Hash命令"><a href="#Redis命令-Hash命令" class="headerlink" title="Redis命令-Hash命令"></a>Redis命令-Hash命令</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/p/31805.htm/1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/p/31805.htm/1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><ul><li>HSET和HGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; HSET hust:user:3 name Lucy//大key是 hust:user:3 小key是name，小value是Lucy(integer) 1127.0.0.1:6379&gt; HSET hust:user:3 age 21// 如果操作不存在的数据，则是新增(integer) 1127.0.0.1:6379&gt; HSET hust:user:3 age 17 //如果操作存在的数据，则是修改(integer) 0127.0.0.1:6379&gt; HGET hust:user:3 name &quot;Lucy&quot;127.0.0.1:6379&gt; HGET hust:user:3 age&quot;17&quot;</code></pre><ul><li>HMSET和HMGET</li></ul><pre><code class="java">127.0.0.1:6379&gt; HMSET hust:user:4 name HanMeiMeiOK127.0.0.1:6379&gt; HMSET hust:user:4 name LiLei age 20 sex manOK127.0.0.1:6379&gt; HMGET hust:user:4 name age sex1) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HGETALL</li></ul><pre><code class="java">127.0.0.1:6379&gt; HGETALL hust:user:41) &quot;name&quot;2) &quot;LiLei&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;man&quot;</code></pre><ul><li>HKEYS和HVALS</li></ul><pre><code class="java">127.0.0.1:6379&gt; HKEYS hust:user:41) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; HVALS hust:user:41) &quot;LiLei&quot;2) &quot;20&quot;3) &quot;man&quot;</code></pre><ul><li>HINCRBY</li></ul><pre><code class="java">127.0.0.1:6379&gt; HINCRBY  hust:user:4 age 2(integer) 22127.0.0.1:6379&gt; HVALS hust:user:41) &quot;LiLei&quot;2) &quot;22&quot;3) &quot;man&quot;127.0.0.1:6379&gt; HINCRBY  hust:user:4 age -2(integer) 20</code></pre><ul><li>HSETNX</li></ul><pre><code class="java">127.0.0.1:6379&gt; HSETNX hust:user4 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL hust:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;127.0.0.1:6379&gt; HSETNX hust:user:3 sex woman(integer) 1127.0.0.1:6379&gt; HGETALL hust:user:31) &quot;name&quot;2) &quot;Lucy&quot;3) &quot;age&quot;4) &quot;17&quot;5) &quot;sex&quot;6) &quot;woman&quot;</code></pre><h2 id="Redis命令-List命令"><a href="#Redis命令-List命令" class="headerlink" title="Redis命令-List命令"></a>Redis命令-List命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="/p/31805.htm/.%5CRedis.assets%5C1652943604992.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><pre><code class="java">127.0.0.1:6379&gt; LPUSH users 1 2 3(integer) 3127.0.0.1:6379&gt; RPUSH users 4 5 6(integer) 6</code></pre><ul><li>LPOP和RPOP</li></ul><pre><code class="java">127.0.0.1:6379&gt; LPOP users&quot;3&quot;127.0.0.1:6379&gt; RPOP users&quot;6&quot;</code></pre><ul><li>LRANGE</li></ul><pre><code class="java">127.0.0.1:6379&gt; LRANGE users 1 21) &quot;1&quot;2) &quot;4&quot;</code></pre><h2 id="Redis命令-Set命令"><a href="#Redis命令-Set命令" class="headerlink" title="Redis命令-Set命令"></a>Redis命令-Set命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png"></p><p><strong>具体命令</strong></p><pre><code class="java">127.0.0.1:6379&gt; sadd s1 a b c(integer) 3127.0.0.1:6379&gt; smembers s11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; srem s1 a(integer) 1    127.0.0.1:6379&gt; SISMEMBER s1 a(integer) 0    127.0.0.1:6379&gt; SISMEMBER s1 b(integer) 1    127.0.0.1:6379&gt; SCARD s1(integer) 2</code></pre><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><pre><code class="java">127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu(integer) 3    127.0.0.1:6379&gt; SADD ls wangwu mazi ergou(integer) 3    127.0.0.1:6379&gt; SCARD zs(integer) 3    127.0.0.1:6379&gt; SINTER zs ls1) &quot;wangwu&quot;    127.0.0.1:6379&gt; SDIFF zs ls1) &quot;zhaoliu&quot;2) &quot;lisi&quot;    127.0.0.1:6379&gt; SUNION zs ls1) &quot;wangwu&quot;2) &quot;zhaoliu&quot;3) &quot;lisi&quot;4) &quot;mazi&quot;5) &quot;ergou&quot;    127.0.0.1:6379&gt; SISMEMBER zs lisi(integer) 1    127.0.0.1:6379&gt; SISMEMBER ls zhangsan(integer) 0    127.0.0.1:6379&gt; SREM zs lisi(integer) 1    127.0.0.1:6379&gt; SMEMBERS zs1) &quot;zhaoliu&quot;2) &quot;wangwu&quot;</code></pre><h2 id="Redis命令-SortedSet类型"><a href="#Redis命令-SortedSet类型" class="headerlink" title="Redis命令-SortedSet类型"></a>Redis命令-SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>SortedSet具有可排序特性，所以经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL</title>
      <link href="/p/28345.html"/>
      <url>/p/28345.html</url>
      
        <content type="html"><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h2 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h2><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://i.imgur.com/4tUgFo6.png"></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://i.imgur.com/GdqOSsj.png"></p><p>也可以是文档型：</p><p><img src="https://i.imgur.com/zBBQfcc.png"></p><p>甚至可以是图格式：</p><p><img src="https://i.imgur.com/zBnKxWf.png"></p><h2 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h2><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://i.imgur.com/tXYSl5x.png"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre><code class="json">&#123;  id: 1,  name: &quot;张三&quot;,  orders: [    &#123;       id: 1,       item: &#123;     id: 10, title: &quot;荣耀6&quot;, price: 4999       &#125;    &#125;,    &#123;       id: 2,       item: &#123;     id: 20, title: &quot;小米11&quot;, price: 3999       &#125;    &#125;  ]&#125;</code></pre><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h2 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h2><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://i.imgur.com/AzaHOTF.png"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://i.imgur.com/J1MqOJM.png"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><a href="https://imgse.com/i/z7g2qg"><img src="https://s1.ax1x.com/2022/12/16/z7g2qg.png" alt="z7g2qg.png"></a></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/p/24227.html"/>
      <url>/p/24227.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul><li>并行是指两个或多个独立的操作同时进行。</li><li>并发是指一个时间段内执行多个操作。</li></ul><p><strong>线程：</strong> 线程是操作系统能够进行CPU调度的最小单位，它被包含在进程之中，一个进程可包含单个或者多个线程。可以用多个线程去完成一个任务，也可以用多个进程去完成一个任务，它们的本质都相当于多个人去合伙完成一件事。</p><p><strong>多线程并发：</strong> 多线程是实现并发的一种手段，多线程并发即多个线程同时执行,一般而言，多线程并发就是把一个任务拆分为多个子任务，然后交由不同线程处理不同子任务,使得这多个子任务同时执行。</p><p><strong>C++多线程并发：</strong>  （简单情况下）实现C++多线程并发程序的思路如下：将任务的不同功能交由多个函数分别实现，创建多个线程，每个线程执行一个函数，一个任务就这样同时分由不同线程执行了。</p><p><a href="https://imgse.com/i/ppISCnO"><img src="https://s1.ax1x.com/2023/04/05/ppISCnO.png" alt="c++多线程.png"></a></p><h2 id="C-11-多线程相关的头文件："><a href="#C-11-多线程相关的头文件：" class="headerlink" title="C++11 多线程相关的头文件："></a>C++11 多线程相关的头文件：</h2><ul><li><p>atomic：该头文件主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</p></li><li><p>thread：该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。</p></li><li><p>mutex：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock，std::try_lock std::lock_guard, std::unique_lock, 以及其他的类型和函数。</p></li><li><p>condition_variable&gt;：该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any。</p></li><li><p>future：该头文件主要声明了 std::promise, std::package_task 两个 Provider 类，以及 std::future 和 std::shared_future 两个 Future 类，另外还有一些与之相关的类型和函数，std::async() 函数就声明在此头文件中。</p></li></ul><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>首先要引入头文件#include<thread>，管理线程的函数和类在该头文件中声明，其中包括std::thread类。<br>语句”std::thread th1(proc1);”创建了一个名为th1的线程，并且线程th1开始执行。</thread></p><pre><code>#include&lt;iostream&gt;#include&lt;thread&gt;using namespace std;void proc1(int &amp;a)&#123;    cout &lt;&lt; &quot;我是子线程,传入参数为&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;子线程中显示子线程id为&quot; &lt;&lt; this_thread::get_id()&lt;&lt; endl;&#125;int main()&#123;    cout &lt;&lt; &quot;我是主线程&quot; &lt;&lt; endl;    int a = 9;    //第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。    thread th1(proc1,ref(a));    cout &lt;&lt; &quot;主线程中显示子线程id为&quot; &lt;&lt; th1.get_id() &lt;&lt; endl;    //此处省略多行，不要在创建完线程后马上join,应该在程序结束前join    th1.join()；//此时主线程被阻塞直至子线程执行结束。    return 0;&#125;</code></pre><p>如果仅仅是调用无参数的构造函数，不会启动一个新的线程，直到指定了线程函数。</p><pre><code>std::vector&lt;std::thread&gt; threads(10); // 此时没有启动线程​for(int i=0;i&lt;10;++i)&#123;    threads[i]=std::thread(do_some_work);    // 此时才启动线程&#125;</code></pre><h3 id="C-11-std-thread源码"><a href="#C-11-std-thread源码" class="headerlink" title="C++11 std::thread源码"></a>C++11 std::thread源码</h3><pre><code>class thread&#123;    //.....    thread() noexcept : _Thr&#123;&#125; &#123;&#125;    explicit thread(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123;        //.....        _Thr._Hnd =reinterpret_cast&lt;void*&gt;(_CSTD _beginthreadex(nullptr, 0,                                           _Invoker_proc,_Decay_copied.get(), 0, &amp;_Thr._Id));    &#125;    ~thread() noexcept &#123;        if (joinable()) &#123;            _STD terminate();        &#125;    &#125;&#125;;</code></pre><h3 id="如何传递参数"><a href="#如何传递参数" class="headerlink" title="如何传递参数"></a>如何传递参数</h3><p>新拉起的线程肯定是开辟新的参数副本，这样就能避免临界区竞争、访问已经被析构的变量等问题。<br><code>std::thread</code>拉起一个新线程，会进行两次copy：</p><ul><li>第一次在调用std::thread构造函数时，会在新线程保存一份变量。可以是赋值构造、也可以是移动构造；</li><li>第二次在把保存的变量传递给线程函数时，这里统一是用std::move，即移动构造；</li></ul><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>下面是一个示例</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Para&#123;public:    Para() &#123; cout &lt;&lt; &quot;Create Para&quot; &lt;&lt; endl; &#125;    Para(const Para&amp; p) &#123; cout &lt;&lt; &quot;Copy Para&quot; &lt;&lt; endl; &#125;    ~Para() &#123; cout &lt;&lt; &quot;Drop Para&quot; &lt;&lt; endl; &#125;    string name;&#125;;void ThreadMain(int p1, float p2, string str, Para p4)&#123;    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;ThreadMain &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt;&quot; &quot;&lt;&lt;p4.name&lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    thread th;    &#123;        float f1 = 12.1f;        Para p;        p.name = &quot;test Para class&quot;;        //所有的参数做复制        th =  thread(ThreadMain, 101, f1, &quot;test string para&quot;,p);    &#125;    th.join();    return 0;&#125;</code></pre><p>输出结果</p><pre><code>Create ParaCopy ParaDrop ParaCopy ParaThreadMain 101 12.1 test string paraDrop ParaDrop Para</code></pre><p>示例2：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;//Linux -lpthreadusing namespace std;class Para&#123;public:    Para() &#123; cout &lt;&lt; &quot;Create Para&quot; &lt;&lt; endl; &#125;    Para(const Para&amp; p) &#123; cout &lt;&lt; &quot;Copy Para&quot; &lt;&lt; endl; &#125;    Para(Para&amp;&amp; p) &#123; cout &lt;&lt; &quot;move Para&quot; &lt;&lt; endl; &#125;    ~Para() &#123; cout &lt;&lt; &quot;Drop Para&quot; &lt;&lt; endl; &#125;    string name;&#125;;void ThreadMain(int p1, float p2, string str, Para p4)&#123;    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;ThreadMain &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt;&quot; &quot;&lt;&lt;p4.name&lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    thread th;    &#123;    float f1 = 12.1f;    Para p;    p.name = &quot;test Para class&quot;;    //所有的参数做复制    th =  thread(ThreadMain, 101, f1, &quot;test string para&quot;,p);    &#125;    th.join();    return 0;&#125;</code></pre><p>输出结果</p><pre><code>Create ParaCopy ParaDrop Paramove ParaThreadMain 101 12.1 test string paraDrop ParaDrop Para</code></pre><p>可以看到有移动拷贝则使用移动拷贝，否则使用赋值拷贝</p><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>因为新的线程是开辟了新的参数副本，但这样做也有缺点，不能用引用传递参数了，也就不能修改原值。<br>这时我们需要用c++11提供的std::ref这个模板函数，它会返回一个类，本质上是维护了一个指针，所有操作都会改变指针指向的变量，相当于起到引用的功能。</p><p>举个例子：</p><pre><code>void update_data_for_widget(widget_id w,widget_data&amp; data); // 引用传参void oops_again(widget_id w)&#123;    widget_data data;    std::thread t(update_data_for_widget,w,data); // error 右值不可以匹配到左值引用    display_status();    t.join();&#125;</code></pre><p>因为在第二次传参时，发生了std::move强转为右值，不能匹配widget_data&amp;左值引用，自然报错。如果非要用引用传参，需要用std::ref。</p><p>把那一行代码改为std::thread t(update_data_for_widget,w,std::ref(data));就可以了。</p><p>我们会发现std::thread和std::bind的参数传递过程很像，先在本地copy一份副本，当真正执行时，再把参数传入到执行函数。本质上是因为thread和bind都不知道用户何时执行，为了避免发生悬挂指针等错误，保存一份副本是值得的行为。</p><h4 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h4><p>在向线程函数传递参数时，我们需要注意以下场景：</p><p>浅拷贝了一个指针<br>    void f(int i,std::string const&amp; s);<br>    void oops(int some_param)<br>    {<br>        char buffer[1024];<br>        sprintf(buffer, “%i”,some_param);<br>        std::thread t(f,3,buffer);<br>        t.detach();<br>    }<br>buffer是数组指针，在构造时采用浅拷贝，只拷贝了buffer指针，所以新的线程还是访问了主线程的buffer[1024]。让事情雪上加霜的是，采用非阻塞式detach，这意味着很有可能新线程在访问数组时，数组已经被析构了！</p><p>解决方法是采用深拷贝，在传入前转换为std::string：</p><pre><code>void f(int i,std::string const&amp; s);void oops(int some_param)&#123;    char buffer[1024];     sprintf(buffer, &quot;%i&quot;,some_param);    std::thread t(f,3,std::string(buffer)); // 避免悬挂指针    t.detach(); &#125;</code></pre><h4 id="使用成员函数作为参数"><a href="#使用成员函数作为参数" class="headerlink" title="使用成员函数作为参数"></a>使用成员函数作为参数</h4><pre><code>class MyThread&#123;public:    //入口线程函数    void Main()    &#123;        cout &lt;&lt; &quot;MyThread Main &quot; &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; age;    &#125;    string name;    int age = 100;&#125;;int main()&#123;    MyThread myth;    myth.name = &quot;Test name 001&quot;;    myth.age = 20;    //需要传入对象地址    thread th(&amp;MyThread::Main, &amp;myth);    th.join();    return 0;&#125;</code></pre><h4 id="使用lambda表达式作为参数"><a href="#使用lambda表达式作为参数" class="headerlink" title="使用lambda表达式作为参数"></a>使用lambda表达式作为参数</h4><pre><code>class TestLambda&#123;public:    void Start()    &#123;        thread th([this]() &#123;cout &lt;&lt; &quot;name = &quot; &lt;&lt; name &lt;&lt; endl; &#125;);        th.join();    &#125;    string name = &quot;test lambda&quot;;&#125;;int main()&#123;    thread th(        [](int i) &#123;cout &lt;&lt; &quot;test lmbda &quot; &lt;&lt; i &lt;&lt; endl; &#125;,        123    );    th.join();    TestLambda test;    test.Start();    return 0;&#125;</code></pre><h2 id="线程等待和分离"><a href="#线程等待和分离" class="headerlink" title="线程等待和分离"></a>线程等待和分离</h2><p>detach其实就是一个守护线程。</p><p>守护进程的概念：发起就遗忘，即使当前进程运行到结束，但守护进程依旧继续执行，直到整个程序被关闭了。总而言之，守护进程不需要.join()等待了，拉起来就让它一直伴随左右。<br>由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。<br>但是守护进程却能够突破这种限制，它从被执行开始运转，直到接收到某种信号或者整个系统关闭时才会退出。如果想让某个进程不因为用户、终端或者其他的变化而受到影响，那么就必须把这个进程变成一个守护进程。</p><p>此外，std::thread还有一个joinable()方法用于检测线程是否有效。<br>joinable：代表该线程是可执行线程（即刚初始化完成，拥有线程所有权，且没结束运行）<br>not-joinable：通常一下几种情况会导致线程成为not-joinable：</p><ul><li>由thread的缺省构造函数构造而成(thread()没有参数)；</li><li>该thread被move过（包括move构造和move赋值）；</li><li>该线程调用过join或者detach（调用过后就置为non-joinable）；</li></ul><p>线程不安全行为<br>下面介绍detach和join这两种情况下的不安全行为：<br>detach。由于detach不阻塞，很有可能访问到已经析构的对象。如：</p><pre><code>struct func&#123;    int&amp; i;    func(int&amp; i_) : i(i_) &#123;&#125;    void operator() ()    &#123;        for (unsigned j=0 ; j&lt;1000000 ; ++j)        &#123;            do_something(i); // 潜在访问隐患： 悬空引用        &#125;    &#125;&#125;;​void oops()&#123;    int some_local_state=0;    func my_func(some_local_state);    std::thread my_thread(my_func);    my_thread.detach();     // detach不等待线程结束，所以很有可能变量i已经析构了&#125;</code></pre><p>join。当发生异常时，容易忘记执行join。</p><pre><code>struct func; void f()&#123;    int some_local_state=0;    func my_func(some_local_state);    std::thread t(my_func);    try&#123;        do_something_in_current_thread();    &#125;    catch(...)&#123;        t.join();         throw;    &#125;    t.join(); &#125;</code></pre><p>当发生异常这类特殊情况时，join很容易遗漏，发生不安全的行为。</p><pre><code>class thread_guard&#123;private:    std::thread&amp; t;public:    explicit thread_guard(std::thread&amp; t_):t(t_)&#123;&#125;        ~thread_guard()&#123;        if(t.joinable())&#123; // 是否是可执行的线程            t.join();         &#125;    &#125;&#125;;</code></pre><h2 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h2><p>std:call_once的作用，确保函数或代码片段在多线程环境下，只需要执行一次，常用的场景如Init()操作或一些系统参数的获取等。<br>相对来说，std::call_once用法比较简单，配合std::once_flag即可实现，代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::once_flag flag;void Initialize()&#123;    std::cout &lt;&lt; &quot;Run into Initialize..&quot; &lt;&lt; std::endl;&#125;void Init()&#123;    std::call_once(flag, Initialize);&#125;int main()&#123;    std::thread t1(Init);    std::thread t2(Init);    std::thread t3(Init);    std::thread t4(Init);    t1.join();    t2.join();    t3.join();    t4.join();&#125;</code></pre><p>最终Initialize()只调用了一次</p><h2 id="多线程状态"><a href="#多线程状态" class="headerlink" title="多线程状态"></a>多线程状态</h2><p><a href="https://imgse.com/i/ppIPYoF"><img src="https://s1.ax1x.com/2023/04/05/ppIPYoF.png" alt="ppIPYoF.png"></a></p><ul><li><p>初始化状态：在执行new Thread(s)，线程对象一旦创建就进入初始化状态</p></li><li><p>就绪状态：在线程对象创建完成后调用start方法，但是线程不会立刻调度执行，而是进入就绪状态，因为在运行前还有一些准备工作要做</p></li><li><p>运行状态：准备工作完成后进入运行状态，一个运行状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间（Java的规范说明没有将它作为一个单独状态，准确的说这个状态应该是可运行状态，因为任何时刻，这个状态的某个线程可能正在运行也可能没有运行）</p></li><li><p>阻塞状态： 当一个线程被插队、礼让别的线程或者休眠时就会进入到阻塞状态，阻塞状态解除后回到就绪状态，等待CPU调度执行</p></li><li><p>退出状态 当一个运行状态的线程自然执行完毕后或者中断后线程进入退出状态，退出后无法再次启动</p></li></ul><h3 id="竞争状态和临界状态"><a href="#竞争状态和临界状态" class="headerlink" title="竞争状态和临界状态"></a>竞争状态和临界状态</h3><ul><li><p>竞争条件</p><ul><li>竞争条件是指多个任务以非互斥的方式同时进入临界区， 大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。</li></ul></li><li><p>临界区</p><ul><li>程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。怕有同学看得不仔细，强调一下，临界区是指程序中那些访问公共资源的指令代码，即临界区是指令，并不是受访的静态公共资源。</li></ul></li><li><p>互斥</p><ul><li>互斥也可称为排他， 是指某一时刻公共资源只能被 1 个任务独享， 即不允许多个任务同时出现在自己的临界区中。公共资源在任意时刻只能被一个任务访问，即只能有一个任务在自己的临界区中执行，其他任务想访问公共资源时，必须等待当前公共资源的访问者完全执行完他自己的临界区代码后（使用完资源后）再开始访问。</li></ul></li></ul><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。<br>mutex常用操作：</p><ul><li>lock()：资源上锁</li><li>unlock()：解锁资源</li><li>trylock()：查看是否上锁，它有下列3种类情况：<ul><li>未上锁返回false，并锁住；</li><li>其他线程已经上锁，返回true；</li><li>同一个线程已经对它上锁，将会产生死锁。</li></ul></li></ul><p>通过锁可以防止临界区的冲突</p><pre><code>#include &lt;iostream&gt;  // std::cout#include &lt;thread&gt;  // std::thread#include &lt;mutex&gt;  // std::mutexstd::mutex mtx;  // mutex for critical sectionvoid print_block (int n, char c) &#123;    mtx.lock();    for (int i=0; i&lt;n; ++i)     &#123;        std::cout &lt;&lt; c;     &#125;    std::cout &lt;&lt; &#39;\n&#39;;    mtx.unlock();&#125;int main ()&#123;    std::thread th1 (print_block,50,&#39;&#39;);//线程1：打印*    std::thread th2 (print_block,50,&#39;$&#39;);//线程2：打印$    th1.join();    th2.join();    return 0;&#125;</code></pre><h4 id="互斥锁需要注意的地方"><a href="#互斥锁需要注意的地方" class="headerlink" title="互斥锁需要注意的地方"></a>互斥锁需要注意的地方</h4><p>多线程锁有一个问题就是在解锁之后立刻请求锁，这样会导致可能一个线程一直占用着锁导致其他线程无法获得锁。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;using namespace std;static mutex mux;void ThreadMainMux(int i)&#123;    for (;;)    &#123;        mux.lock();        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        mux.unlock();    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadMainMux, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><p>解决的一个办法是解锁后等待一个时间段以后再重新请求锁</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;//Linux -lpthreadusing namespace std;static mutex mux;void ThreadMainMux(int i)&#123;    for (;;)    &#123;        mux.lock();        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        mux.unlock();        //this_thread::sleep_for(1ms);    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadMainMux, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h3 id="超时锁"><a href="#超时锁" class="headerlink" title="超时锁"></a>超时锁</h3><p>功能：避免长时间死锁，可以记录锁获取情况，多次超时，可以记录日志，获取错误情况<br>由于try_lock(）不会阻塞该线程，那么将会一直占着CPU资源，因此加入sleep_for(100ms)延时给其他线程一点机会，然而延时是调用的this_thread下的函数：</p><pre><code>if (!mux.try_lock())&#123;    cout &lt;&lt; &quot;.&quot; &lt;&lt; flush;    this_thread::sleep_for(100ms);    continue;&#125;</code></pre><p>c++还提供了另外一个解决方法，就是使用超时锁</p><pre><code>timed_mutex tmux;void ThreadMainTime(int i)&#123;    for (;;)    &#123;        if (!tmux.try_lock_for(chrono::milliseconds(500)))        &#123;             //如果未在规定时间内拿到锁，那么这段代码可能会出现问题，这里可以进行日志的写入，便于调试            cout &lt;&lt; i &lt;&lt; &quot;[try_lock_for timeout]&quot; &lt;&lt; endl;            continue;        &#125;        cout &lt;&lt; i &lt;&lt; &quot;[in]&quot; &lt;&lt; endl;        this_thread::sleep_for(2000ms);        tmux.unlock();        this_thread::sleep_for(1ms);    &#125;&#125;</code></pre><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>递归锁允许同一个线程多次获取该互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;struct Complex&#123;    std::mutex mutex;    int i;    Complex() : i(0)&#123;&#125;    void mul(int x)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        i *= x;    &#125;    void div(int x)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        i /= x;    &#125;    void both(int x, int y)    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex);        mul(x);        div(y);    &#125;&#125;;int main(void)&#123;    Complex complex;    complex.both(32, 23);    return 0;&#125;</code></pre><p>运行后出现死锁的情况。在调用both时获取了互斥量，在调用mul时又要获取互斥量，但both的并没有 释放，从而产生死锁。</p><p>使用递归锁解决同一个线程的死锁问题：</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;struct Complex&#123;    std::recursive_mutex mutex;    int i;    Complex() : i(0)&#123;&#125;    void mul(int x)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        i *= x;    &#125;    void div(int x)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        i /= x;    &#125;    void both(int x, int y)    &#123;        std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);        mul(x);        div(y);    &#125;&#125;;int main(void)&#123;    Complex complex;    complex.both(32, 23); //因为同一线程可以多次获取同一互斥量，不会发生死锁    std::cout &lt;&lt; &quot;main finish\n&quot;;    return 0;&#125;</code></pre><h3 id="共享锁-shared-mutex"><a href="#共享锁-shared-mutex" class="headerlink" title="共享锁 shared_mutex"></a>共享锁 shared_mutex</h3><p>C++17起，shared_mutex 类是一个同步原语，可用于保护共享数据不被多个线程同时访问。与便于独占访问的其他互斥类型不同，shared_mutex 拥有二个访问级别：</p><ul><li>共享 - 多个线程能共享同一互斥的所有权；</li><li>独占性 - 仅一个线程能占有互斥。<br>1）若一个线程已经通过lock或try_lock获取独占锁（写锁），则无其他线程能获取该锁（包括共享的）。尝试获得读锁的线程也会被阻塞。<br>2）仅当任何线程均未获取独占性锁时，共享锁（读锁）才能被多个线程获取（通过 lock_shared 、try_lock_shared ）。<br>3）在一个线程内，同一时刻只能获取一个锁（共享或独占性）。</li></ul><p>按照如下代码，读取只能有一个线程进入，在很多业务场景中，没有充分利用 cpu 资源</p><pre><code>//读取 同时只能有一个线程读取mux.lock();cout&lt;&lt;share&lt;&lt;endl;mux.unlock();//写入mux.lock() share++; mux.unlock()</code></pre><p>可以看到这个无论读还是写都无法并行处理，显然读操作即上面打印操作是可以并行的</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;using namespace std;//c++17  共享锁//shared_mutex smux;//c++14 shared_timed_mutex stmux;void ThreadRead(int i)&#123;    for (;;)    &#123;        stmux.lock_shared();        cout &lt;&lt; i &lt;&lt; &quot; Read&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        stmux.unlock_shared();        this_thread::sleep_for(1ms);    &#125;&#125;void ThreadWrite(int i)&#123;    for (;;)    &#123;        stmux.lock_shared();        //读取数据        stmux.unlock_shared();        stmux.lock(); //互斥锁 写入        cout &lt;&lt; i &lt;&lt; &quot; Write&quot; &lt;&lt; endl;        this_thread::sleep_for(1000ms);        stmux.unlock();        this_thread::sleep_for(1ms);    &#125;&#125;int main(int argc, char* argv[])&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadWrite, i + 1);        th.detach();    &#125;    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadRead, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="RAII风格锁"><a href="#RAII风格锁" class="headerlink" title="RAII风格锁"></a>RAII风格锁</h2><p><strong>什么是RAII：</strong><br>资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期绑定与一个对象的生存期相绑定。<br><strong>RAII 可总结如下:</strong><br>将每个资源封装入一个类，其中构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，析构函数释放资源并决不抛出异常；始终经由 RAII 类的实例使用满足要求的资源，该资源自身拥有自动存储期或临时生存期，或具有与自动或临时对象的生存期绑定的生存期。移动语义使得在对象间，跨作用域，以及在线程内外安全地移动所有权，而同时维护资源安全成为可能。</p><p>手动实现一个最简单的RAII锁：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;using namespace std;class XMutex&#123;public:    XMutex(mutex&amp; mux):mux_(mux)    &#123;        mux.lock();    &#125;    ~XMutex()    &#123;        mux_.unlock();    &#125;private:    mutex&amp; mux_;&#125;;static mutex mux;void TestMutex(int status)&#123;    XMutex test(mux);    if (status == 1)    &#123;        cout &lt;&lt; &quot;=1&quot; &lt;&lt; endl;        return;    &#125;    else    &#123;        cout &lt;&lt; &quot;!=1&quot; &lt;&lt; endl;        return;    &#125;&#125;int main(int argc, char* argv[])&#123;    TestMutex(1);    TestMutex(2);    getchar();    return 0;&#125;</code></pre><p>上面是一个最简单的体现RAII思维的锁，还需要实现模板，移动语义以及如果构造参数传入的锁锁住以后防止死锁等。</p><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p>这是构造互斥锁的写法，会在lock_guard构造函数里加锁，在析构函数里解锁，这个写法，C++委员会的解释是防止使用mutex加锁解锁的时候，忘记解锁unlock了。</p><pre><code>template &lt;class _Mutex&gt;class lock_guard &#123; public:    using mutex_type = _Mutex;    explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123;         _MyMutex.lock();    &#125;    lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123;&#125;    ~lock_guard() noexcept &#123;        MyMutex.unlock();    &#125;    lock_guard(const lock_guard&amp;) = delete;     lock_guard&amp; operator=(const lock_guard&amp;) = delete;&#125;；</code></pre><p>可以看到锁的所有权是不会改变的，拷贝构造移动构造都被禁止使用了<br>下面这个例子利用了lock_guard自动对锁进行释放<br>    #include <iostream><br>    #include <thread><br>    #include <string><br>    #include <mutex><br>    using namespace std;</mutex></string></thread></iostream></p><pre><code>mutex mt;void thread_task()&#123;    for (int i = 0; i &lt; 1000; i++)    &#123;        lock_guard&lt;mutex&gt; guard(mt);        cout &lt;&lt; &quot;print thread: &quot; &lt;&lt; i &lt;&lt; endl;    &#125;&#125;int main()&#123;    thread t(thread_task);    for (int i = 0; i &gt; -1000; i--)    &#123;        lock_guard&lt;mutex&gt; guard(mt);        cout &lt;&lt; &quot;print main: &quot; &lt;&lt; i &lt;&lt; endl;    &#125;    t.join();    return 0;&#125;</code></pre><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p>虽然lock_guard挺好用，但他有个很大的缺陷，在定义lock_guard的地方会调用构造函数加锁，在离开定义域的话lock_guard就会被销毁，调用析构函数解锁。这就产生了一个问题，如果这个定义域范围很大的话，那么锁的粒度就很大，很大程序上会影响效率。为了解决lock_guard锁的粒度过大的原因，unique_lock就出现了。<br>unique_lock C++11 实现可移动的互斥体所有权包装器</p><ul><li>支持临时释放锁 unlock</li><li>支持 adopt_lock（已经拥有锁，不加锁，出栈区会释放） </li><li>支持 defer_lock （延后拥有，不加锁，出栈区不释放）</li><li>支持 try_to_lock 尝试获得互斥的所有权而不阻塞 ，获取失败退出栈区不会释放，通过owns_lock()函数判断</li><li>支持超时参数，超时不拥有锁</li></ul><h4 id="unique-lock的第二个参数"><a href="#unique-lock的第二个参数" class="headerlink" title="unique_lock的第二个参数"></a>unique_lock的第二个参数</h4><p>unique_lock 可以带第二个参数：<br>std::unique_lock<a href="std::mutex">std::mutex</a> sbguard1(my_mutex1, std::adopt_lock);&#x2F;&#x2F; std::adopt_lock标记作用；</p><h5 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h5><p>表示这个互斥量已经被lock了（你必须要把互斥量提前lock了 ，否者会报异常）；std::adopt_lock标记的效果就是假设调用一方已经拥有了互斥量的所有权（已经lock成功了）；通知lock_guard不需要再构造函数中lock这个互斥量了。<br>unique_lock也可以带std::adopt_lock标记，含义相同，就是不希望再unique_lock()的构造函数中lock这个mutex。<br>用std::adopt_lock的前提是，自己需要先把mutex lock上；用法与lock_guard相同。</p><h5 id="std-try-to-lock"><a href="#std-try-to-lock" class="headerlink" title="std::try_to_lock"></a>std::try_to_lock</h5><p>try_to_lock的意思是尝试加锁，它的好处就是——当线程A拿不到锁的时候，线程A不会等在那里，它会去做一些别的事情，用这个try_to_lock的前提是你自己不能先lock。</p><h5 id="std-defer-lock"><a href="#std-defer-lock" class="headerlink" title="std::defer_lock"></a>std::defer_lock</h5><p>用std::defer_lock的前提是，你不能自己先lock,否则会报异常，std::defer_lock的意思就是并没有给mutex加锁：初始化了一个没有加锁的mutex。我们借着defer_lock的话题，来介绍一些unique_lock的重要成员函数。</p><h3 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h3><p>shared_lock  c++14开始引入<br>类 shared_lock 是通用共享互斥所有权包装器（unique_lock则是独占互斥所有权包装器），允许延迟锁定、定时锁定和锁所有权的转移。锁定 shared_lock，会以共享模式锁定关联的共享互斥</p><pre><code>//共享锁static shared_timed_mutex  tmux;//读取锁 共享锁&#123;    //调用共享锁     shared_lock&lt;shared_timed_mutex&gt; lock(tmux);    cout &lt;&lt; &quot;read data&quot; &lt;&lt; endl;    //退出栈区 释放共享锁&#125;//写入锁 互斥锁&#123;    unique_lock&lt;shared_timed_mutex&gt; lock(tmux);    cout &lt;&lt; &quot;write data&quot; &lt;&lt; endl;&#125;</code></pre><p>shared_lock是read lock。被锁后仍允许其他线程执行同样被shared_lock的代码。这是一般做读操作时的需要。<br>unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。在写操作时，一般用这个，可以同时限制unique_lock的写和share_lock的读。</p><h3 id="scoped-lock区域锁"><a href="#scoped-lock区域锁" class="headerlink" title="scoped_lock区域锁"></a>scoped_lock区域锁</h3><p>scoped_lock C++17<br>将多个锁（std::mutex等）包装成一种锁类型，用于线程一次性申请多个锁，避免死锁。<br>scoped_lock使用std::lock函数，其会调用一个特殊的算法对所提供的互斥量调用try_lock函数，这是为了避免死锁。因此，在加锁与解锁的顺序相同的情况下，使用scoped_lock或对同一组锁调用std::lock都是非常安全的。可以同时对一堆锁同时加锁，要么同时成功，要么加锁同时失败，不会出现死锁情况。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;void TestScope1()&#123;    //模拟死锁 停100ms等另一个线程锁mux2    this_thread::sleep_for(100ms);     cout &lt;&lt;this_thread::get_id()&lt;&lt; &quot; begin mux1 lock&quot; &lt;&lt; endl;    //mux1.lock();    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux2 lock&quot; &lt;&lt; endl;    //mux2.lock(); //死锁    //c++11    // lock(mux1, mux2);    //c++17     scoped_lock lock(mux1, mux2); // 解决死锁        cout &lt;&lt; &quot;TestScope1&quot; &lt;&lt; endl;    this_thread::sleep_for(1000ms);        //mux1.unlock();    //mux2.unlock();&#125;void TestScope2()&#123;    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux2 lock&quot; &lt;&lt; endl;    mux2.lock();    this_thread::sleep_for(500ms);    cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; begin mux1 lock&quot; &lt;&lt; endl;    mux1.lock();//死锁    cout &lt;&lt; &quot;TestScope2&quot; &lt;&lt; endl;    this_thread::sleep_for(1500ms);    mux1.unlock();    mux2.unlock();&#125;int main(int argc, char* argv[])&#123;    //演示死锁情况    &#123;        thread th(TestScope1);        th.detach();    &#125;    &#123;        thread th(TestScope2);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待<br>条件变量的条件成立而挂起;另一个线程使条件成立（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥量结合在一起。</p><h3 id="改变共享变量的线程步骤"><a href="#改变共享变量的线程步骤" class="headerlink" title="改变共享变量的线程步骤"></a>改变共享变量的线程步骤</h3><p><strong>准备好信号量</strong></p><pre><code>std::condition_variable cv;</code></pre><p><strong>1获得 std::mutex （常通过 std::unique_lock ）</strong></p><pre><code>unique_lock lock(mux);</code></pre><p><strong>2在获取锁时进行修改</strong></p><pre><code>msgs_.push_back(data);</code></pre><p><strong>3释放锁并通知读取线程</strong></p><pre><code>lock.unlock();cv.notify_one(); //通知一个等待信号线程cv.notify_all(); //通知所有等待信号线程</code></pre><h3 id="等待信号读取共享变量的线程步骤"><a href="#等待信号读取共享变量的线程步骤" class="headerlink" title="等待信号读取共享变量的线程步骤"></a>等待信号读取共享变量的线程步骤</h3><p><strong>1获得与改变共享变量线程共同的mutex</strong></p><pre><code>unique_lock lock(mux);</code></pre><p><strong>2 wait() 等待信号通知</strong><br>2.1无lambada 表达式</p><pre><code>//解锁lock,并阻塞等待 notify_one notify_all 通知cv.wait(lock);//接收到通知会再次获取锁标注，也就是说如果此时mux资源被占用，wait函数会阻塞msgs_.front();//处理数据msgs_.pop_front();</code></pre><p>2.2lambada 表达式cv.wait(lock, [] {return !msgs_.empty();});<br>只在 std::unique_lock<a href="std::mutex">std::mutex</a> 上工作的 std::condition_variable</p><pre><code>void wait(unique_lock&lt;mutex&gt;&amp; _Lck) &#123;     // wait for signal    // Nothing to do to comply with LWG‐2135 because std::mutex lock/unlock are nothrow    _Check_C_return(_Cnd_wait(_Mycnd(), _Lck.mutex()‐&gt;_Mymtx()));&#125;template &lt;class _Predicate&gt;void wait(unique_lock&lt;mutex&gt;&amp; _Lck, _Predicate _Pred) &#123;     // wait for signal and test predicate    while (!_Pred())    &#123;         wait(_Lck);    &#125;&#125;</code></pre><p>代码示例：</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;list&lt;string&gt; msgs_;mutex mux;condition_variable cv;void ThreadWrite()&#123;    for (int i = 0;;i++)    &#123;        stringstream ss;        cout &lt;&lt; &quot;write msg &quot; &lt;&lt; i &lt;&lt; endl;        ss &lt;&lt; &quot;msg &quot; &lt;&lt; i;        unique_lock&lt;mutex&gt; lock(mux);        msgs_.push_back(ss.str());        lock.unlock();        cv.notify_one(); //发送信号        this_thread::sleep_for(3000ms);    &#125;&#125;void ThreadRead(int i)&#123;    while(1)    &#123;        unique_lock&lt;mutex&gt; lock(mux);        //cv.wait(lock);//解锁、阻塞等待信号        cv.wait(lock, [i]         &#123;            return !msgs_.empty();         &#125;);        //获取信号后锁定        while (!msgs_.empty())        &#123;            cout &lt;&lt; &quot;ThreadRead &quot; &lt;&lt; i &lt;&lt; &quot; read &quot; &lt;&lt; msgs_.front() &lt;&lt; endl;            msgs_.pop_front();        &#125;    &#125;&#125;int main(int argc, char* argv[])&#123;    thread th(ThreadWrite);    th.detach();    for (int i = 0; i &lt; 3; i++)    &#123;        thread th(ThreadRead, i + 1);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><h2 id="线程异步和通信"><a href="#线程异步和通信" class="headerlink" title="线程异步和通信"></a>线程异步和通信</h2><h3 id="promise-和-future"><a href="#promise-和-future" class="headerlink" title="promise 和 future"></a>promise 和 future</h3><p>future和promise的作用是在不同线程之间传递数据。使用指针也可以完成数据的传递，但是指针非常危险，因为互斥量不能阻止指针的访问；而且指针的方式传递的数据是固定的，如果更改数据类型，那么还需要更改有关的接口，比较麻烦；promise支持泛型的操作，更加方便编程处理。</p><ul><li>promise 用于异步传输变量<ul><li>std::promise 提供存储异步通信的值，再通过其对象创建的std::future异步获得结果。</li><li>std::promise 只能使用一次。 void set_value(_Ty&amp;&amp; _Val) 设置传递值，只能掉用一次</li></ul></li><li>std::future 提供访问异步操作结果的机制<ul><li>get() 阻塞等待promise set_value 的值</li></ul></li></ul><p>下面是一个例子，可以看到如果没有set  get会一直堵塞住</p><pre><code>#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;future&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;cstdlib&gt;void thread_set_promise(std::promise&lt;int&gt;&amp; p) &#123;    std::this_thread::sleep_for(std::chrono::milliseconds(3000));    p.set_value(35);&#125;int main() &#123;    std::promise&lt;int&gt; p;    std::future&lt;int&gt; f = p.get_future();    std::thread t(&amp;thread_set_promise, std::ref(p));    std::cout &lt;&lt; f.get() &lt;&lt; std::endl;    t.join();    getchar();    return 0;&#125;</code></pre><p>三秒后屏幕输出35 ，get一直堵塞，直到set函数调用以后截止</p><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::packaged_task的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个函数操作，并将其返回值传递给对应的future，而这个future在另外一个线程中也可以安全的访问到这个值。与bind的区别，可异步调用，函数访问和获取返回值分开调用</p><pre><code>#include &lt;iostream&gt;     // std::cout#include &lt;future&gt;       // std::packaged_task, std::future#include &lt;chrono&gt;       // std::chrono::seconds#include &lt;thread&gt;       // std::thread, std::this_thread::sleep_forusing namespace std;int countdown(int from, int to) &#123;    for (int i = from; i != to; --i) &#123;        std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;        std::this_thread::sleep_for(1s);    &#125;    std::cout &lt;&lt; &quot;Lift off!\n&quot;;    return from - to;&#125;int main()&#123;    std::packaged_task&lt;int(int, int)&gt; tsk(countdown);   // set up packaged_task    std::future&lt;int&gt; ret = tsk.get_future();            // get future    std::thread th(std::move(tsk), 10, 0);   // spawn thread to count down from 10 to 0    int value = ret.get();                  // wait for the task to finish and get result    std::cout &lt;&lt; &quot;The countdown lasted for &quot; &lt;&lt; value &lt;&lt; &quot; seconds.\n&quot;;    th.join();    return 0;&#125;</code></pre><h3 id="async-创建异步线程"><a href="#async-创建异步线程" class="headerlink" title="async 创建异步线程"></a>async 创建异步线程</h3><p>std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用 线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取。它解耦了线程的创建和执行，使得我们可以在需要的时候获取异步 操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），使得我们可以以多种方式去创建线程。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;string&gt;using namespace std;string TestAsync(int index)&#123;    this_thread::sleep_for(2s);    return &quot;test&quot;;&#125;int main(int argc, char* argv[])&#123;    //不创建线程启动异步任务    auto future = async(launch::deferred, TestAsync,100);    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;future.get() = &quot; &lt;&lt; future.get() &lt;&lt; endl&lt;&lt;endl;    //创建异步线程    auto future2 = async(TestAsync, 101);    this_thread::sleep_for(100ms);    cout &lt;&lt; &quot;future2.get() = &quot; &lt;&lt; future2.get() &lt;&lt; endl;    getchar();    return 0;&#125;</code></pre><p>std::async 可以延迟调用，在get的时候调用函数。但是下面是启动了一个线程，该线程会直接启动执行。std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选</p><pre><code>//#include &lt;execution&gt; c++17 std::for_each(std::execution::par, //并行计算 多核in_data.begin(), in_data.end(),[&amp;]()&#123;&#125;); //多线程进入此函数</code></pre><h2 id="c-20-线程特性"><a href="#c-20-线程特性" class="headerlink" title="c++20 线程特性"></a>c++20 线程特性</h2><h3 id="std-barrier-屏障"><a href="#std-barrier-屏障" class="headerlink" title="std::barrier 屏障"></a>std::barrier 屏障</h3><ul><li>arrive<ul><li>到达屏障并减少期待计数</li></ul></li><li>wait<ul><li>在阶段同步点阻塞，直至运行其阶段完成步骤</li></ul></li><li>arrive_and_wait <ul><li>到达屏障并把期待计数减少一，然后阻塞直至当前阶段完成</li></ul></li><li>arrive_and_drop<ul><li>将后继阶段的初始期待计数和当前阶段的期待计数均减少一</li></ul></li></ul><p>下面是一个示例，目前使用的vs2019不支持，并没有下载最新版vs进行测试。</p><pre><code>#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;barrier&gt;using namespace std;void TestBar(int i, barrier&lt;&gt;* bar)&#123;    this_thread::sleep_for(chrono::seconds(i));    cout &lt;&lt; i &lt;&lt; &quot; begin wait&quot; &lt;&lt; endl;    bar-&gt;wait(bar-&gt;arrive()); //期待数 -1 阻塞等待，期待为0是返回    cout &lt;&lt; i &lt;&lt; &quot; end wait&quot; &lt;&lt; endl;&#125;int main(int argc, char* argv[])&#123;    int count = 3;    barrier bar(count);//初始数量    for (int i = 0; i &lt; count; i++)    &#123;        thread th(TestBar, i, &amp;bar);        th.detach();    &#125;    getchar();    return 0;&#125;</code></pre><p>输出：</p><pre><code>begin waitbegin waitbegin waitend waitend waitend wait</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析器模式</title>
      <link href="/p/50156.html"/>
      <url>/p/50156.html</url>
      
        <content type="html"><![CDATA[<h1 id="解析器模式"><a href="#解析器模式" class="headerlink" title="解析器模式"></a>解析器模式</h1><p>解析器模式定义语言的文法，并且建立一个解析器来解释该语言（规定格式和语法的代码）中的句子。它包含抽象表达式，终结符表达式，非终结符表达式，Context环境类。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里参照了李建忠老师的设计模式课程</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;stack&gt;class Expression&#123;public:    virtual int interpreter(std::map&lt;char, int&gt;) = 0;    virtual ~Expression() &#123;&#125;&#125;;//变量表达式class VarExpression :public Expression&#123;public:    VarExpression(const char&amp; k) :key(k) &#123;&#125;    int interpreter(std::map&lt;char, int&gt;var) override    &#123;        return var[key];    &#125;private:    char key;&#125;;class SymbolExpression :public Expression&#123;public:    SymbolExpression(Expression* l, Expression* r) :left(l), right(r) &#123;&#125;protected:    Expression* left;    Expression* right;&#125;;class AddExpression : public SymbolExpression&#123;public:    AddExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) + right-&gt;interpreter(var);    &#125;&#125;;class SubExpression :public SymbolExpression&#123;public:    SubExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) - right-&gt;interpreter(var);    &#125;&#125;;class MulExpression :public SymbolExpression&#123;public:    MulExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) * right-&gt;interpreter(var);    &#125;&#125;;class DivExpression :public SymbolExpression&#123;public:    DivExpression(Expression* left, Expression* right) :SymbolExpression(left, right) &#123;&#125;    int interpreter(std::map&lt;char, int&gt; var) override    &#123;        return left-&gt;interpreter(var) / right-&gt;interpreter(var);    &#125;&#125;;Expression* analyse(std::string expStr)&#123;    std::stack&lt;Expression*&gt; expStack;    Expression* left = nullptr;    Expression* right = nullptr;    for (int i = 0; i &lt; expStr.size(); ++i)    &#123;        switch (expStr[i])        &#123;        case &#39;+&#39;:            // 加法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new AddExpression(left, right));            break;        case &#39;-&#39;:            // 减法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new SubExpression(left, right));            break;        case &#39;*&#39;:            // 乘法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new MulExpression(left, right));            break;        case &#39;/&#39;:            // 除法运算            left = expStack.top();            right = new VarExpression(expStr[++i]);            expStack.push(new DivExpression(left, right));            break;        default:            // 变量表达式            expStack.push(new VarExpression(expStr[i]));        &#125;    &#125;    Expression* expression = expStack.top();    return expression;&#125;void release(Expression* expression) &#123;    //释放表达式树的节点内存...&#125;int main()&#123;    std::string expStr = &quot;a+b-c+d-e*f/g&quot;;    std::map&lt;char, int&gt; var;    var.insert(std::make_pair(&#39;a&#39;, 5));    var.insert(std::make_pair(&#39;b&#39;, 2));    var.insert(std::make_pair(&#39;c&#39;, 1));    var.insert(std::make_pair(&#39;d&#39;, 6));    var.insert(std::make_pair(&#39;e&#39;, 10));    var.insert(std::make_pair(&#39;f&#39;, 8));    var.insert(std::make_pair(&#39;g&#39;, 4));    Expression* expression = analyse(expStr);    int result = expression-&gt;interpreter(var);    std::cout &lt;&lt; result &lt;&lt; std::endl;    release(expression);    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解析在日常开发经常使用，但是解析器模式可能用的比较少，使用方式就是将一个需要解释执行的语言中的句子表示为一个抽象语法树，完成解析。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问器模式</title>
      <link href="/p/5265.html"/>
      <url>/p/5265.html</url>
      
        <content type="html"><![CDATA[<h1 id="访问器模式"><a href="#访问器模式" class="headerlink" title="访问器模式"></a>访问器模式</h1><p>在软件构建中，由于需求的变化，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中添加，会给子类带来繁重的变更负担，破坏原有设计。<br>访问器模式：表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素类的前提下定义（扩展）作用于这些元素的新操作（变化）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：主要将数据结构与数据操作分离。</p><p>主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p><p>如何解决：在被访问的类里面加一个对外提供接待访问者的接口。</p><p>关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p>优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p><p>缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p>使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>参照李建忠老师的课程代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;class Visitor;class Element&#123;public:    virtual void accept(Visitor&amp; visitor) = 0; //第一次多态辨析    virtual ~Element()&#123;&#125;&#125;;class ElementA : public Element&#123;public:    void accept(Visitor &amp;visitor) override &#123;        visitor.visitElementA(*this);    &#125;&#125;;class ElementB : public Element&#123;public:    void accept(Visitor &amp;visitor) override &#123;        visitor.visitElementB(*this); //第二次多态辨析    &#125;&#125;;class Visitor&#123;public:    virtual void visitElementA(ElementA&amp; element) = 0;    virtual void visitElementB(ElementB&amp; element) = 0;    virtual ~Visitor()&#123;&#125;&#125;;//==================================//扩展1class Visitor1 : public Visitor&#123;public:    void visitElementA(ElementA&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor1 is processing ElementA&quot; &lt;&lt; endl;    &#125;          void visitElementB(ElementB&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor1 is processing ElementB&quot; &lt;&lt; endl;    &#125;&#125;;    //扩展2class Visitor2 : public Visitor&#123;public:    void visitElementA(ElementA&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor2 is processing ElementA&quot; &lt;&lt; endl;    &#125;        void visitElementB(ElementB&amp; element) override&#123;        cout &lt;&lt; &quot;Visitor2 is processing ElementB&quot; &lt;&lt; endl;    &#125;&#125;;        int main()&#123;    Visitor2 visitor;    ElementB elementB;    elementB.accept(visitor);// double dispatch        ElementA elementA;    elementA.accept(visitor);        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职责链模式</title>
      <link href="/p/52113.html"/>
      <url>/p/52113.html</url>
      
        <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，直到有一个对象处理它为止；</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p>何时使用：在处理消息的时候以过滤很多道。</p><p>关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p>优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p>缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p>使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define SAFE_DELETE(p) if(p)&#123;delete p;p=NULL;&#125;//假期请求的类class HolidayRequest&#123;public:    HolidayRequest(int hour) :m_iHour(hour) &#123;&#125;    int GetHour() &#123; return m_iHour; &#125;private:    int m_iHour;&#125;;//假期处理请求接口class Manager&#123;public:    virtual bool HandleRequest(HolidayRequest *pRequest) = 0;&#125;;//项目经理class PM :public Manager&#123;public:    PM(Manager* handler):m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        if (pRequest-&gt;GetHour() &lt;= 2 || m_pHandler == NULL)        &#123;            cout &lt;&lt; &quot;项目经理说ok&quot; &lt;&lt; endl;            return true;        &#125;        return m_pHandler-&gt;HandleRequest(pRequest);    &#125;private:    Manager* m_pHandler;&#125;;//部门经理class DM :public Manager&#123;public:    DM(Manager* handler) :m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        cout &lt;&lt; &quot;部门经理说Ok了&quot; &lt;&lt; endl;        return true;    &#125;    //部门经理说ok了    bool IsIn()    &#123;        return true;    &#125;private:    Manager* m_pHandler;&#125;;//项目主管class PS :public Manager&#123;public:    PS(Manager* handler) :m_pHandler(handler) &#123;&#125;    bool HandleRequest(HolidayRequest* pRequest)    &#123;        DM* pDM = dynamic_cast&lt;DM*&gt;(m_pHandler);        if (pDM != NULL)        &#123;            if (pDM-&gt;IsIn())            &#123;                return pDM-&gt;HandleRequest(pRequest);            &#125;        &#125;        cout &lt;&lt; &quot;项目主管说ok&quot; &lt;&lt; endl;        return true;    &#125;    private:    Manager* m_pHandler;&#125;;int main(int argc, char* argv[])&#123;    DM* pDM = new DM(NULL);    PS* pPS = new PS(pDM);    PM* pPM = new PM(pPS);  //在客户端中定义职责链的顺序,逆着来，注意这里    HolidayRequest* pHolidayRequest = new HolidayRequest(10);    pPM-&gt;HandleRequest(pHolidayRequest);  //输出&quot;部门经理说ok了&quot;    SAFE_DELETE(pHolidayRequest);    pHolidayRequest = new HolidayRequest(2);    pPM-&gt;HandleRequest(pHolidayRequest);  //输出&quot;项目经理说ok了&quot;    SAFE_DELETE(pDM);    SAFE_DELETE(pPS);    SAFE_DELETE(pPM);    SAFE_DELETE(pHolidayRequest);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/p/28241.html"/>
      <url>/p/28241.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>迭代器模式（Iterator Pattern）是非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>在金山WPS课程中对此有所实现。<br>这种方式在c++当中已经过时了，泛型编程相对于GOF提出的面向对象的迭代器性能更好一些。虚函数需要二次指针间接运算，性能相对较差。c++使用泛型实现的迭代器采用的编译时多态，基于模板来实现的。但是这种设计思路在java等编程语言得到了极大的应用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p>优点： </p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ul><p>缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p><p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>#pragma once#include &lt;string&gt;#include &lt;vector&gt;/*** @brief 简单概述* @brief 迭代器基类*/class Iterator&#123;public:    Iterator() &#123;&#125;    ~Iterator()&#123;&#125;    virtual std::string First() = 0;    virtual std::string Next() = 0;    virtual std::string Current() = 0;    virtual bool IsEnd() = 0;&#125;;/*** @brief 简单概述* @brief 对象基类*/class Object&#123;public:    Object() &#123;&#125;    ~Object()&#123;&#125;    virtual Iterator* CreateIterator() = 0;    virtual int Count() = 0;    virtual void Push(std::string) = 0;    virtual std::string Pop(int) = 0;&#125;;/*** @brief 简单概述* @brief 迭代器子类*/class SubIterator : public Iterator&#123;public:    SubIterator(Object* obj):Iterator(), m_pObj(obj), m_Cur(0)&#123;&#125;    ~SubIterator()&#123;&#125;    std::string First()    &#123;        return m_pObj-&gt;Pop(0);    &#125;    std::string Next()    &#123;        std::string str;        if (m_Cur &lt; m_pObj-&gt;Count() - 1)        &#123;            m_Cur++;            str = m_pObj-&gt;Pop(m_Cur);        &#125;        return str;    &#125;    std::string Current()    &#123;        return m_pObj-&gt;Pop(m_Cur);    &#125;    bool IsEnd()    &#123;        return (m_Cur == m_pObj-&gt;Count()-1);    &#125;private:    Object* m_pObj;    int m_Cur;&#125;;/*** @brief 简单概述* @brief 对象类*/class Children : public Object&#123;public:    Children() : Object(), m_pIterator(NULL) &#123;&#125;    ~Children()&#123;&#125;    Iterator* CreateIterator()    &#123;        if(m_pIterator == NULL)            m_pIterator = new SubIterator(this);        return m_pIterator;    &#125;    int Count()    &#123;        return vec_str.size();    &#125;    void Push(std::string s)    &#123;        vec_str.push_back(s);    &#125;    std::string Pop(int i)    &#123;        std::string str;        if (i &gt;= 0 &amp;&amp; i &lt; vec_str.size())        &#123;            str = vec_str[i];        &#125;        return str;    &#125;private:    std::vector&lt;std::string&gt; vec_str;    Iterator*    m_pIterator;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/p/55487.html"/>
      <url>/p/55487.html</url>
      
        <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。（接口隔离）</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p>何时使用：多个类相互耦合，形成了网状结构。</p><p>如何解决：将上述网状结构分离为星型结构。</p><p>关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p>应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p>优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p><p>缺点：中介者会庞大，变得复杂难以维护。</p><p>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p><p>注意事项：不应当在职责混乱的时候使用。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里采用大话设计模式中的例子</p><pre><code>class Mediator;//抽象人class Person&#123;protected:    Mediator *m_mediator; //中介public:    virtual void SetMediator(Mediator *mediator)&#123;&#125; //设置中介    virtual void SendMessage(string message) &#123;&#125;    //向中介发送信息    virtual void GetMessage(string message) &#123;&#125;     //从中介获取信息&#125;;//抽象中介机构class Mediator&#123;public:    virtual void Send(string message, Person *person) &#123;&#125;    virtual void SetA(Person *A) &#123;&#125;  //设置其中一方    virtual void SetB(Person *B) &#123;&#125;&#125;;//租房者class Renter: public Person&#123;public:    void SetMediator(Mediator *mediator) &#123; m_mediator = mediator; &#125;    void SendMessage(string message) &#123; m_mediator-&gt;Send(message, this); &#125;    void GetMessage(string message) &#123; cout&lt;&lt;&quot;租房者收到信息&quot;&lt;&lt;message; &#125;&#125;;//房东class Landlord: public Person&#123;public:    void SetMediator(Mediator *mediator) &#123; m_mediator = mediator; &#125;    void SendMessage(string message) &#123; m_mediator-&gt;Send(message, this); &#125;    void GetMessage(string message) &#123; cout&lt;&lt;&quot;房东收到信息：&quot;&lt;&lt;message; &#125;&#125;;//房屋中介class HouseMediator : public Mediator&#123;private:    Person *m_A; //租房者    Person *m_B; //房东public:    HouseMediator(): m_A(0), m_B(0) &#123;&#125;    void SetA(Person *A) &#123; m_A = A; &#125;    void SetB(Person *B) &#123; m_B = B; &#125;    void Send(string message, Person *person)     &#123;        if(person == m_A) //租房者给房东发信息            m_B-&gt;GetMessage(message); //房东收到信息        else            m_A-&gt;GetMessage(message);    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/p/44993.html"/>
      <url>/p/44993.html</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式 Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>在金山WPS企业课程中对此有所实践，当时做的是一个复杂图形以及简单图形面积求解问题，复杂图形可以包含其他复杂图形或者简单图形。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p>何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p>应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p>优点： 1、高层模块调用简单。 2、节点自由增加。</p><p>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p>何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在windows里面无论是对于什么后缀的文件还是目录，我们都可以用删除，添加，重命名等统一的操作，不需要区别对待。手机菜单，话机菜单等等一切目录菜单也是一样的，我们可以用统一的接口操作。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class fileSystem &#123;    public:        string name;        virtual void add(fileSystem* node) = 0;        virtual void rename(string newname) = 0;        virtual void remove(fileSystem* node) = 0;        virtual fileSystem* enter() = 0;        virtual fileSystem* GetNode(int index) &#123;&#125;        void showName() &#123;            cout &lt;&lt;&quot;文件名字:&quot;&lt;&lt;name&lt;&lt;endl;        &#125;&#125;;class dir :public fileSystem &#123;    private:        vector &lt;fileSystem*&gt; file;    public:        dir(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            file.push_back(node);        &#125;        void remove(fileSystem* node) &#123;             for(auto it=file.begin();it!=file.end();it++) &#123;                if(*it == node)                    file.erase(it);            &#125;               &#125;        void rename(string newName) &#123;            name = newName;        &#125;        fileSystem* enter() &#123;      //目录点击去就是显示里面有什么            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的目录&quot;&lt;&lt;endl;            for(auto it=file.begin();it!=file.end();it++) &#123;                cout&lt;&lt;(*it)-&gt;name&lt;&lt;endl;            &#125;            return this;               &#125;        fileSystem* GetNode(int index) &#123;    //电脑会进行按键扫描返回是第几个文件也就是index            return file[index];        &#125;&#125;;class cppfile :public fileSystem &#123;    public:        cppfile(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void remove(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void rename(string newName) &#123;                name = newName;        &#125;        fileSystem* enter() &#123;      //文件就是打开            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的文件&quot;&lt;&lt;endl;            return this;        &#125;&#125;;class txtfile :public fileSystem &#123;    public:        txtfile(string name) &#123;            this-&gt;name = name;        &#125;        void add(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void remove(fileSystem* node) &#123;            cout&lt;&lt;&quot;不支持这个操作&quot;&lt;&lt;endl;        &#125;        void rename(string newName) &#123;            name = newName;        &#125;        fileSystem* enter() &#123;      //文件就是打开            cout&lt;&lt;&quot;打开名叫&quot;&lt;&lt;name&lt;&lt;&quot;的文件&quot;&lt;&lt;endl;            return this;        &#125;&#125;;int main() &#123;    fileSystem * d = new dir(&quot;1dir&quot;);     //创建根目录1dir    d-&gt;showName();    d-&gt;add(new txtfile(&quot;2txt&quot;));          //创建三个类型文件    d-&gt;add(new cppfile(&quot;3cpp&quot;));    d-&gt;add(new dir(&quot;4dir&quot;));    d = d-&gt;enter();                       //进入1dir目录，展示下面有哪些文件                  d = d-&gt;GetNode(2);                    //按键扫描，表示接下来操作的是哪个位置上的文件    d = d-&gt;enter();                       //进入4dir目录，展示下面有哪些文件     d-&gt;showName();    d-&gt;add(new cppfile(&quot;5cpp&quot;));          //创建5cpp    d = d-&gt;GetNode(0);                    //按键扫描，表示接下来操作的是哪个位置上的文件    d = d-&gt;enter();    d-&gt;showName();    return 0; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>门面模式</title>
      <link href="/p/58978.html"/>
      <url>/p/58978.html</url>
      
        <content type="html"><![CDATA[<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h1><p>门面模式也叫做外观模式，实质就是一个封装接口，通常是将一类功能或者一个层次功能用一个函数封装起来，供客户端统一调用。</p><p><strong>缺点</strong>    门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，门面对象可是重中之重，一旦在系统投产后发现有一个小错误，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获</p><p><strong>适用场景</strong></p><ul><li>为一个复杂的模块或子系统提供一个供外界访问的接口，子系统相对独立一外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散，比如一个低水平的技术人员参与项目开发，为降低个人代码质量对整体项目的影响风险，一般的做法是 “画地为牢”，只能在指定的子系统中开发，然后再提供面接口进行访问操作 .</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>写信大致分为四个步骤：先写信件的内容,然后写信封,再把信放到信封中, 投递到信箱中进行邮递。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;//#include&lt;vld.h&gt;using namespace std;//门面模式//写信过程接口class ILetterProcess&#123;public:    //首先要写信的内容    virtual void writeContext(string context) = 0 ;    //其次写信封    virtual void fillEnvelope(string address) = 0 ;    //把信放到信封里    virtual void letterInotoEnvelope() = 0 ;    //然后邮递    virtual void sendLetter() = 0 ;&#125;;//写信过程的实现class LetterProcessImpl : public ILetterProcess&#123;public:    //写信    void writeContext(string context)    &#123;        cout&lt;&lt;&quot;填写信的内容...&quot;+context&lt;&lt;endl;    &#125;    //在信封上填写必要的信息    void fillEnvelope(string address)    &#123;        cout&lt;&lt;&quot;填写收件人地址及姓名...&quot;+address&lt;&lt;endl;    &#125;    //把信放到信封中 , 并封好    void letterInotoEnvelope()    &#123;        cout&lt;&lt;&quot;把信放到信封中...&quot;&lt;&lt;endl;    &#125;    //塞到邮箱中 , 邮递    void sendLetter()    &#123;        cout&lt;&lt;&quot;邮递信件...&quot;&lt;&lt;endl;    &#125;&#125;;//场景1int main()&#123;    //创建一个处理信件的过程    ILetterProcess* letterProcess = new LetterProcessImpl() ;    //开始写信    letterProcess-&gt;writeContext(&quot;Hello , It&#39;s me , do you know who I am ? I&#39;m you dad . I&#39;d like to ...&quot;);    //开始写信封    letterProcess-&gt;fillEnvelope(&quot;Happy Road No.666 , God Province , Heaven&quot;);    //把信放到信封里 , 并封装好    letterProcess-&gt;letterInotoEnvelope();    //跑到邮局把信塞到邮箱 , 投递    letterProcess-&gt;sendLetter();    delete letterProcess;    return 0;&#125;</code></pre><p>我们回头来看看这个过程 , 它与高内聚的要求相差甚远 , 更不要说迪米特法则 , 接口隔离原则 . 你要知道者4个步骤 , 而且还要知道他们的顺序 , 一旦出错 , 信就不可能邮寄出去 , 这在面向对象的编程中是极度的不合适 , 它根本没有完成一个类所具有的单一职责 .还有 , 如果信件多了就非常麻烦 , 每封信都要这样运转一遍 , 非得累死 , 更别说要发个广告信了 , 那怎么办? 还好, 现在邮局开发了一个新业务 , 你只要把信件的必要信息告诉我 , 我给你发 , 我来完成这4个过程 , 只要把信件交给我就成了 , 其他的不要管 .</p><pre><code>//现代化邮局class ModenPostOffice &#123;public:    ModenPostOffice()    &#123;        letterProcess = new LetterProcessImpl();    &#125;    ~ModenPostOffice()    &#123;        if(letterProcess != nullptr)            delete letterProcess;    &#125;    //写信 , 封装 , 投递  ,一体化    void sendLetter(string context , string address)    &#123;        //帮你写信        letterProcess-&gt;writeContext(context);        //写好信封        letterProcess-&gt;fillEnvelope(address);        //把信放到信封中        letterProcess-&gt;letterInotoEnvelope();        //邮递信件        letterProcess-&gt;sendLetter();    &#125;private:    ILetterProcess* letterProcess ;&#125;;</code></pre><p>这就是门面模式，可以相比于数据库DBMS，以及物理层面比如我们个人使用的电脑，包括usb接口，蓝牙接口，都是稳定的，哪怕不同品牌电脑内部构造不同，也能使用同一个u盘；</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/p/65163.html"/>
      <url>/p/65163.html</url>
      
        <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>运用共享技术有效的支持大量细粒度的对象          —–《设计模式》GOF</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p><p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p><p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p><p><strong>内部状态</strong> 指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变；</p><p><strong>外部状态</strong> 指对象得以依赖的一个标记，随环境的改变而改变，不可共享。</p><p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p>如：连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这里以《大话设计模式》中创建多个相似的网站为例，实现享元模式代码。</p><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;map&gt;//*************************Flyweight Pattern********************class User&#123;private:    std::string name;public:    User(const std::string&amp; strName): name(strName)&#123;&#125;    std::string GetName() const    &#123;        return name;    &#125;&#125;;class Website&#123;public:    virtual void Use(const User&amp; user) = 0;&#125;;class ConcreteWebsite : public Website&#123;private:    std::string name;public:    ConcreteWebsite(const std::string&amp; strName) : name(strName) &#123;&#125;    void Use(const User&amp; user)    &#123;        std::cout &lt;&lt; &quot;网站分类：&quot; &lt;&lt; name.c_str()&lt;&lt;&quot;, 用户：&quot;&lt;&lt; user.GetName().c_str() &lt;&lt; std::endl;    &#125;&#125;;class WebsiteFactory&#123;private:    std::map&lt;std::string, std::shared_ptr&lt;Website&gt;&gt; websiteObjs;public:    std::shared_ptr&lt;Website&gt; GetWebSiteCategory(const std::string&amp; strKey)    &#123;        if (websiteObjs.find(strKey) == websiteObjs.end())        &#123;            websiteObjs.insert(std::make_pair(strKey, std::make_shared&lt;ConcreteWebsite&gt;(strKey)));        &#125;        return websiteObjs[strKey];    &#125;    int GetWebsiteCount()    &#123;        return websiteObjs.size();    &#125;&#125;;//*******************************Test***************************int main()&#123;    std::shared_ptr&lt;WebsiteFactory&gt; factory = std::make_shared&lt;WebsiteFactory&gt;();    std::shared_ptr&lt;Website&gt; fx = factory-&gt;GetWebSiteCategory(&quot;产品展示&quot;);    std::shared_ptr&lt;User&gt; xiaocai = std::make_shared&lt;User&gt;(&quot;小菜&quot;);    fx-&gt;Use(*xiaocai);    std::shared_ptr&lt;Website&gt; fy = factory-&gt;GetWebSiteCategory(&quot;产品展示&quot;);    std::shared_ptr&lt;User&gt; daniao = std::make_shared&lt;User&gt;(&quot;大鸟&quot;);    fy-&gt;Use(*daniao);    std::shared_ptr&lt;Website&gt; fl = factory-&gt;GetWebSiteCategory(&quot;博客&quot;);    fl-&gt;Use(*xiaocai);    std::shared_ptr&lt;Website&gt; fm = factory-&gt;GetWebSiteCategory(&quot;博客&quot;);    fl-&gt;Use(*daniao);    std::cout &lt;&lt; &quot;网站对象总数：&quot; &lt;&lt; factory-&gt;GetWebsiteCount() &lt;&lt; std::endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="享元模式与单例模式的区别"><a href="#享元模式与单例模式的区别" class="headerlink" title="享元模式与单例模式的区别"></a>享元模式与单例模式的区别</h2><p>（1）享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。</p><p>（2）享元模式是为了节约内存空间，提升程序性能，而单例模式则主要是出于共享状态的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某些小项目</title>
      <link href="/p/55324.html"/>
      <url>/p/55324.html</url>
      
        <content type="html"><![CDATA[<h2 id="象棋方块"><a href="#象棋方块" class="headerlink" title="象棋方块"></a>象棋方块</h2><p><a href="http://wang-ziminghhh.gitee.io/last-chess-blocks/">http://wang-ziminghhh.gitee.io/last-chess-blocks/</a></p>]]></content>
      
      
      <categories>
          
          <category> 软工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简介</title>
      <link href="/p/4551.html"/>
      <url>/p/4551.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><ul><li>Linux有两种含义<ul><li>一种是Linus编写的操作系统内核</li><li>另一种是广义的操作系统</li></ul></li></ul><p>执行环境</p><ul><li>云主机</li><li>无数据的PC</li><li>虚拟机</li></ul><p>版本</p><ul><li>内核版本<ul><li>主版本号</li><li>次版本号 奇数是开发板，偶数为稳定版</li><li>末版本号</li></ul></li><li>发行版<ul><li>Red Hat Enterprise Linux8</li><li>fedora</li><li>centos</li><li>Debian</li><li>Ubuntu</li></ul></li></ul><h2 id="Linux小技巧"><a href="#Linux小技巧" class="headerlink" title="Linux小技巧"></a>Linux小技巧</h2><p>Linux某些程序的运行，如果想要强制停止它，可以使用快捷键ctrl + c<br>命令输入错误，也可以通过快捷键ctrl + c，退出当前输入，重新输入<br>可以通过快捷键：ctrl + d，退出账户的登录，或者退出某些特定程序的专属页面<br>可以通过history命令，查看历史输入过的命令<br>可以通过：!命令前缀，自动执行上一次匹配前缀的命令<br>可以通过快捷键：ctrl + r，输入内容去匹配历史命令，如果搜索到的内容是你需要的，那么：</p><ul><li>回车键可以直接执行</li><li>键盘左右键，可以得到此命令（不执行）</li></ul><p>光标移动的快捷键</p><ul><li>ctrl + a，跳到命令开头</li><li>ctrl + e，跳到命令结尾</li><li>ctrl + 键盘左键，向左跳一个单词</li><li>ctrl + 键盘右键，向右跳一个单词</li></ul><p>通过快捷键ctrl + l，可以清空终端内容，或通过命令clear得到同样效果</p><h2 id="Linux安装相关设置"><a href="#Linux安装相关设置" class="headerlink" title="Linux安装相关设置"></a>Linux安装相关设置</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00..99)</li><li>%m   月份 (01..12)</li><li>%d   日 (01..31)</li><li>%H   小时 (00..23)</li><li>%M   分钟 (00..59)</li><li>%S   秒 (00..60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220514.png" alt="image-20221027220514640"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220525.png" alt="image-20221027220525625"></p></li><li><p>-d选项日期计算</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220429.png" alt="image-20221027220429831"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220449.png" alt="image-20221027220449312"></p></li></ul></li></ul><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>修改时区为中国时区</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220554.png" alt="image-20221027220554654"></p><h3 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h3><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h3 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h3><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><pre><code class="shell">TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;            # 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot;        # IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot;        # 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot;        # 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot;            # DNS1服务器，和网关一致即可</code></pre></li></ol><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221303.png" alt="image-20221027221303037"></p><h3 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221241.png" alt="image-20221027221241123"></p><h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h3><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221129.png" alt="image-20221027221129782"></p><h3 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221149.png" alt="image-20221027221148964"></p><h3 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221201.png" alt="image-20221027221201079"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221210.png" alt="image-20221027221210518"></p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221340.png" alt="image-20221027221340729"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221354.png" alt="image-20221027221354137"></p><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看磁盘占用</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221413.png" alt="image-20221027221413787"></p><h3 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h3><p>查看CPU、磁盘的相关信息</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221440.png" alt="image-20221027221439990"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221514.png" alt="image-20221027221514237"></p><h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><p>查看网络统计</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221545.png" alt="image-20221027221545822"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>临时设置：export 变量名&#x3D;变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h4 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h4><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h3 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h3><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/p/56214.html"/>
      <url>/p/56214.html</url>
      
        <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p>何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p><p>如何解决：通过一个备忘录类专门存储对象状态。</p><p>关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p>应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p><p>优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p>缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p>使用场景： 1、需要保存&#x2F;恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p><p>注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在有一个简历 Resume 类，如果要批量复制简历对象，有哪些方法呢？</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string sex;    std::string age;public:    Resume() &#123;&#125;;    void SetPersonalInfo(const std::string&amp; name, const std::sting&amp; age)    &#123;        this.name = name;        this.age = age;    &#125;&#125;;int main()&#123;    Resume p1;    p1.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);    Resume p2;    p2.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);&#125;</code></pre><p>上述实现方式非常简单又容易理解，你需要几份简历，就定义几个简历对象。但是，这里有一个很严重的问题：一旦简历内容需要修改，那么所有的简历对象都需要改动。原型模式正是为了解决它而出现的。</p><p>原型模式</p><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string age;    std::string education;public:    Resume()     &#123;        std::cout &lt;&lt; &quot;Construct !&quot; &lt;&lt; std::endl;    &#125;;    Resume(const Resume&amp; resume)    &#123;        this-&gt;name = resume.name;           this-&gt;age = resume.age;        this-&gt;education = resume.education;        std::cout &lt;&lt; &quot;Copy Construct !&quot; &lt;&lt; std::endl;    &#125;    void SetPersonalInfo(const std::string&amp; name, const std::string&amp; age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void SetEducation(const std::string&amp; educatoin)    &#123;        this-&gt;education = educatoin;    &#125;    void PrintResume()    &#123;        std::cout &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age  &lt;&lt; &quot;, &quot; &lt;&lt; education &lt;&lt; std::endl;    &#125;    Resume* Clone()    &#123;        return new Resume(*this);    &#125;&#125;;int main()&#123;    Resume* p1 = new Resume();    p1-&gt;SetPersonalInfo(&quot;Tom&quot;, &quot;25&quot;);    p1-&gt;SetEducation(&quot;master&quot;);    p1-&gt;PrintResume();    Resume* p2 = p1-&gt;Clone();    p2-&gt;SetPersonalInfo(&quot;Jack&quot;, &quot;28&quot;);    p2-&gt;PrintResume();&#125;</code></pre><p>当我们定义了第一个简历对象 p1 时，如果再需要创建一个对象，直接调用 p1 中的克隆 Clone 方法，然后返回一个新的对象 p2. 如果想要定制化简历 p2 时，只需要在 p2 中修改与 p1 差异的地方就可以了。而 Clone 一定要借助于拷贝构造函数才能实现<br>所以，一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，对性能又是大大的提升。</p><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;iostream&gt;using namespace std;//接口class Prototype&#123;public :    Prototype()&#123;&#125;    virtual ~Prototype()&#123;&#125;    virtual Prototype * Clone() = 0;&#125;;//实现class ConcretePrototype : public Prototype&#123;public :    ConcretePrototype():m_counter(0)&#123;&#125;    virtual ~ConcretePrototype()&#123;&#125;    //拷贝构造函数    ConcretePrototype( const ConcretePrototype &amp; rhs)    &#123;        m_counter = rhs .m_counter;    &#125;    //复制自身    virtual ConcretePrototype * Clone()    &#123;        //调用拷贝构造函数        return new ConcretePrototype (*this );    &#125;private :    int m_counter;&#125;;int main(int argc , char **argv)&#123;    //生成对像    ConcretePrototype * conProA = new ConcretePrototype ();    //复制自身    ConcretePrototype * conProB = conProA-&gt;Clone();    delete conProA;    conProA= NULL ;    delete conProB;    conProB= NULL ;    return 0;&#125;</code></pre><p>浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。但我们可能更需要这样的一种需求，把要复制的对象所引用的对象都复制一遍。我们希望是a、b、c三个引用的对象都是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为‘深复制’，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。clone的时候要注意引用拷贝会发生浅拷贝的现象导致多个指针指向同一个内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/p/39447.html"/>
      <url>/p/39447.html</url>
      
        <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式是当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类，主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。<br>在实际开发中，我们经常会遇到这种情况；一个对象有多种状态，在每一个状态下，都会有不同的行为。那么在代码中我们经常是这样实现的。</p><pre><code>typedef enum tagState&#123;    state,    state1,    state2&#125;State;void Action(State actionState)&#123;    if (actionState == state)    &#123;        // DoSomething    &#125;    else if (actionState == state1)    &#123;        // DoSomething    &#125;    else if (actionState == state2)    &#123;        // DoSomething    &#125;    else    &#123;        // DoSomething    &#125;&#125;</code></pre><p>这里和策略模式遇到的问题有所相似，思考一下，如果枚举类型中新增了一个枚举，那么我们则需要重新更改这个类，不符合开闭原则；那么我们如何解决这个问题呢，根据以往经验很自然的我们会想到设置个抽象基类，把枚举抽象出来，把状态变成抽象子类，动态绑定。往往状态只需要一个实例，我们可以使用单例模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>1 #include &lt;iostream&gt;2 using namespace std;3 4 class Context;5 6 class State7 &#123;8 public:9      virtual void Handle(Context *pContext) = 0;10 &#125;;11 12 class ConcreteStateA : public State13 &#123;14 public:15      virtual void Handle(Context *pContext)16      &#123;17           cout&lt;&lt;&quot;I am concretestateA.&quot;&lt;&lt;endl;18      &#125;19 &#125;;20 21 class ConcreteStateB : public State22 &#123;23 public:24      virtual void Handle(Context *pContext)25      &#123;26           cout&lt;&lt;&quot;I am concretestateB.&quot;&lt;&lt;endl;27      &#125;28 &#125;;29 30 class Context31 &#123;32 public:33      Context(State *pState) : m_pState(pState)&#123;&#125;34 35      void Request()36      &#123;37           if (m_pState)38           &#123;39                m_pState-&gt;Handle(this);40           &#125;41      &#125;42 43      void ChangeState(State *pState)44      &#123;45           m_pState = pState;46      &#125;47 48 private:49      State *m_pState;50 &#125;;51 52 int main()53 &#123;54      State *pStateA = new ConcreteStateA();55      State *pStateB = new ConcreteStateB();56      Context *pContext = new Context(pStateA);57      pContext-&gt;Request();58 59      pContext-&gt;ChangeState(pStateB);60      pContext-&gt;Request();61 62      delete pContext;63      delete pStateB;64      delete pStateA;65 &#125;</code></pre><p>例2<br>某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾.如果不用状态模式，会产生大量的if…else语句，代码将很不容易改变,，难以拓展。状态转换隐藏在条件语句中，所以并不明显未来加入的代码可能导致bug。</p><pre><code>    #include&lt;iostream&gt;    using namespace std;    //以下为类的定义部分    class TissueMachine;//类的提前引用    //抽象状态    class State&#123;    public:        virtual void insertQuarter()=0;//“投币”按钮被按下        virtual void ejectQuarter()=0;//“退币”按钮被按下        virtual void turnCrank()=0;//“出纸巾”按钮被按下        virtual void dispense()=0;//正在卖出纸巾    &#125;;        //具体状态    class SoldOutState:public State&#123;//纸巾售完状态    private:        TissueMachine* tissueMachine;    public:        SoldOutState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class NoQuarterState:public State&#123;//没有投币状态    private:        TissueMachine* tissueMachine;    public:        NoQuarterState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class HasQuarterState:public State&#123;//有2元钱（已投币状态）    private:        TissueMachine* tissueMachine;    public:        HasQuarterState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;    class SoldState:public State&#123;//出售纸巾状态    private:        TissueMachine* tissueMachine;    public:        SoldState(TissueMachine *tissueMachine)&#123;            this-&gt;tissueMachine=tissueMachine;        &#125;        void insertQuarter();        void ejectQuarter();        void turnCrank();        void dispense();    &#125;;        //上下文    class TissueMachine&#123;    private:        State *soldOutState,*noQuarterState,*hasQuarterState,*soldState,*state;        int count;//纸巾数    public:        TissueMachine(int numbers)&#123;//构造函数，定义初始状态有纸巾售卖机有多少纸巾            soldOutState=new SoldOutState(this);            noQuarterState=new NoQuarterState(this);            hasQuarterState=new HasQuarterState(this);            soldState=new SoldState(this);            this-&gt;count=numbers;            if (count&gt; 0) &#123;                  this-&gt;state=noQuarterState;//开始为没有投币的状态            &#125;        &#125;;        //开放给主函数调用的方法        void insertQuarter()&#123;            state-&gt;insertQuarter();        &#125;        void ejectQuarter()&#123;            state-&gt;ejectQuarter();        &#125;        void turnCrank()&#123;            state-&gt;turnCrank();            state-&gt;dispense();        &#125;        //数据传递的getter与setter        void setState(State* state)&#123;            this-&gt;state=state;        &#125;        State* getHasQuarterState()&#123;            return hasQuarterState;        &#125;        State* getNoQuarterState()&#123;            return noQuarterState;        &#125;        State* getSoldState()&#123;            return soldState;        &#125;            State* getSoldOutState()&#123;            return soldOutState;        &#125;        int getCount()&#123;            return count;        &#125;;        void setCount(int numbers)&#123;            this-&gt;count=numbers;        &#125;;    &#125;;        //具体状态中各个方法的具体实现。    //纸巾售完状态    void SoldOutState::insertQuarter()&#123;                cout&lt;&lt;&quot;机器无纸巾，已退回硬币！&quot;&lt;&lt;endl;    &#125;    void SoldOutState::ejectQuarter()&#123;        cout&lt;&lt;&quot;自动售货机根本没有硬币！&quot;&lt;&lt;endl;    &#125;    void SoldOutState::turnCrank()&#123;        cout&lt;&lt;&quot;机器无纸巾，请不要操作机器&quot;&lt;&lt;endl;    &#125;    void SoldOutState::dispense()&#123;    &#125;    //没有投币状态    void NoQuarterState::insertQuarter()&#123;                tissueMachine-&gt;setState(tissueMachine-&gt;getHasQuarterState());        cout&lt;&lt;&quot;已投币！&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::ejectQuarter()&#123;        cout&lt;&lt;&quot;自动售货机根本没有硬币！&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::turnCrank()&#123;        cout&lt;&lt;&quot;请投币&quot;&lt;&lt;endl;    &#125;    void NoQuarterState::dispense()&#123;    &#125;    //有2元钱（已投币状态）    void HasQuarterState::insertQuarter()&#123;        cout&lt;&lt;&quot;已投币！请不要重复投币！已退回重复投币！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::ejectQuarter()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());        cout&lt;&lt;&quot;已取币！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::turnCrank()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getSoldState());        cout&lt;&lt;&quot;请等待自动售货机出纸巾！&quot;&lt;&lt;endl;    &#125;    void HasQuarterState::dispense()&#123;    &#125;    //出售纸巾状态    void SoldState::insertQuarter()&#123;        cout&lt;&lt;&quot;请等待自动售货机出纸巾！请不要投币！已退回投币！&quot;&lt;&lt;endl;    &#125;    void SoldState::ejectQuarter()&#123;        tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());        cout&lt;&lt;&quot;请等待自动售货机出纸巾！无法取回已消费的硬币！&quot;&lt;&lt;endl;    &#125;    void SoldState::turnCrank()&#123;        cout&lt;&lt;&quot;请等待自动售货机出纸巾！已响应你的操作！&quot;&lt;&lt;endl;    &#125;    void SoldState::dispense()&#123;//售出纸巾动作        if(tissueMachine-&gt;getCount()&gt;0)&#123;            tissueMachine-&gt;setState(tissueMachine-&gt;getNoQuarterState());            tissueMachine-&gt;setCount(tissueMachine-&gt;getCount()-1);            cout&lt;&lt;&quot;你的纸巾，请拿好！&quot;&lt;&lt;endl;        &#125;        else&#123;            tissueMachine-&gt;setState(tissueMachine-&gt;getSoldOutState());            cout&lt;&lt;&quot;已退回你的硬币！纸巾已卖光，等待进货！&quot;&lt;&lt;endl;        &#125;    &#125;        //主函数    int main()&#123;        TissueMachine *tissueMachine=new TissueMachine(1);        cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;        tissueMachine-&gt;insertQuarter();//投币        tissueMachine-&gt;turnCrank();//取纸巾        cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;//不投币取纸巾测试        tissueMachine-&gt;turnCrank();         cout&lt;&lt;&quot;纸巾数：&quot;&lt;&lt;tissueMachine-&gt;getCount()&lt;&lt;endl;//售完纸巾，投币取纸巾测试        tissueMachine-&gt;insertQuarter();          tissueMachine-&gt;turnCrank();         return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香槟塔</title>
      <link href="/p/52292.html"/>
      <url>/p/52292.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</code></pre><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.00000解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</code></pre><p>示例 2:</p><pre><code>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.50000解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</code></pre><p>示例 3:</p><pre><code>输入: poured = 100000009, query_row = 33, query_glass = 17输出: 1.00000</code></pre><p>提示：</p><pre><code>0 &lt;= poured &lt;= 1090 &lt;= query_glass &lt;= query_row &lt; 100</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>本弱鸡一直在纠结是不是数学问题，暴力的话poured是不是够用，每层减少对应数目，但是最后还是算不出来，最终也没有做出来。贴一个官方题解。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;</code></pre><p>public:<br>    double champagneTower(int poured, int query_row, int query_glass) {<br>        vector<double> row &#x3D; {(double)poured};<br>        for (int i &#x3D; 1; i &lt;&#x3D; query_row; i++) {<br>            vector<double> nextRow(i + 1, 0.0);<br>            for (int j &#x3D; 0; j &lt; row.size(); j++) {<br>                double volume &#x3D; row[j];<br>                if (volume &gt; 1) {<br>                    nextRow[j] +&#x3D; (volume - 1) &#x2F; 2;<br>                    nextRow[j + 1] +&#x3D; (volume - 1) &#x2F; 2;<br>                }<br>            }<br>            row &#x3D; nextRow;<br>        }<br>        return min(1.0, row[query_glass]);<br>    }<br>};</double></double></p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/">https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匹配子序列的单词数</title>
      <link href="/p/39967.html"/>
      <url>/p/39967.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。例如， “ace” 是 “abcde” 的子序列。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>略</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>采用桶的思想，预先将对应字符下一次出现的位置保存下来，避免一次又一次遍历造成的重复时间损失。看大神的做法桶的基础上还可以采用二分查找，奈何本弱鸡不会stl的二分查找，把官方题解粘下来以供学习。以及通过多指针的方式来进行求解，这也是难以想到的方式，同样官方题解粘下来以供学习。</code></pre><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><pre><code>class Solution &#123;public:int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;    vector&lt;int&gt; temp[27];    int len[27];    int ans=0;    int length=s.size();    for(int i=0;i&lt;length;i++)    &#123;        temp[s[i]-&#39;a&#39;].push_back(i);    &#125;    for(auto word:words)    &#123;        for(int i=0;i&lt;27;i++)        &#123;            len[i]=0;        &#125;        int wordlen=word.size();        int curpos=0;        int i=0;        for(;i&lt;wordlen;i++)        &#123;            int pos=word[i]-&#39;a&#39;;            while(len[pos]&lt;temp[pos].size()&amp;&amp;curpos&gt;temp[pos][len[pos]])len[pos]++;            if(len[pos]&lt;temp[pos].size())            &#123;                curpos=temp[pos][len[pos]];                len[pos]++;            &#125;            else            &#123;                break;            &#125;        &#125;        if(i==wordlen)        &#123;            ans++;        &#125;     &#125;    return ans;&#125;</code></pre><p>};</p><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><pre><code>class Solution &#123;public:    int numMatchingSubseq(string s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;vector&lt;int&gt;&gt; pos(26);        for (int i = 0; i &lt; s.size(); ++i) &#123;            pos[s[i] - &#39;a&#39;].push_back(i);        &#125;        int res = words.size();        for (auto &amp;w : words) &#123;            if (w.size() &gt; s.size()) &#123;                --res;                continue;            &#125;            int p = -1;            for (char c : w) &#123;                auto &amp;ps = pos[c - &#39;a&#39;];                auto it = upper_bound(ps.begin(), ps.end(), p);                if (it == ps.end()) &#123;                    --res;                    break;                &#125;                p = *it;            &#125;        &#125;        return res;    &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode.cn/problems/number-of-matching-subsequences/solution/pi-pei-zi-xu-lie-de-dan-ci-shu-by-leetco-vki7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="代码实现3"><a href="#代码实现3" class="headerlink" title="代码实现3"></a>代码实现3</h3><pre><code>class Solution &#123;public:    int numMatchingSubseq(string s, vector&lt;string&gt; &amp;words) &#123;        vector&lt;queue&lt;pair&lt;int, int&gt;&gt;&gt; queues(26);        for (int i = 0; i &lt; words.size(); ++i) &#123;            queues[words[i][0] - &#39;a&#39;].emplace(i, 0);        &#125;        int res = 0;        for (char c : s) &#123;            auto &amp;q = queues[c - &#39;a&#39;];            int size = q.size();            while (size--) &#123;                auto [i, j] = q.front();                q.pop();                ++j;                if (j == words[i].size()) &#123;                    ++res;                &#125; else &#123;                    queues[words[i][j] - &#39;a&#39;].emplace(i, j);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;作者：LeetCode-Solution链接：https://leetcode.cn/problems/number-of-matching-subsequences/solution/pi-pei-zi-xu-lie-de-dan-ci-shu-by-leetco-vki7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防疫大数据</title>
      <link href="/p/43256.html"/>
      <url>/p/43256.html</url>
      
        <content type="html"><![CDATA[<h1 id="防疫大数据"><a href="#防疫大数据" class="headerlink" title="防疫大数据"></a>防疫大数据</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。具体而言，在每天夜里，西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地区的信息，以及当天疫情风险地区的信息。数据中心需要根据这些信息，生成一份存在风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://imgse.com/i/x6kjot"><img src="https://s1.ax1x.com/2022/10/20/x6kjot.png" alt="x6kjot.png"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出到标准输出。<br>输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格分隔的若干整数。其中第一个整数表示当天的日期，接下来的各个整数为按从小到大排序的存在风险的用户列表。</p><p><strong>样例 1 输入</strong></p><pre><code>91 4 10 1 1-1 1 1-1 2 10 2 20 30 3 11 2 21 3 20 00 00 00 00 00 15 4 11 0 1</code></pre><p><strong>样例 1 输出</strong></p><pre><code>0 11 1 32 1 33 1 34 1 35 1 36 1 378</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>无脑做，不知道哪里有问题，只有20分，哭死（）</p><p> <strong>代码实现</strong></p><pre><code>？？？忘保存了！！！</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p><strong>代码实现</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;set&lt;LL&gt; sd[1050], su;struct node&#123;    LL d, u, r;&#125;a;vector&lt;node&gt; v[1050];LL n, ri, mi, d, u, r, pi;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) // i:生成名单这一天    &#123;        cin &gt;&gt; ri &gt;&gt; mi;                for (int j = 0; j &lt; ri; j ++ ) // ri个风险地区        &#123;            cin &gt;&gt; pi;            for (int k = i; k &lt; i + 7; k ++ ) sd[k].insert(pi); // pi地区i ~ i+6天都是风险地区        &#125;                for (int j = 0; j &lt; mi; j ++ ) //         &#123;            cin &gt;&gt; d &gt;&gt; u &gt;&gt; r;            if (d &lt; 0) continue;            if (!sd[d].count(r)) continue; // 到访的地区在到访的那一日不处于风险状态,肯定无风险            v[i].push_back(&#123;d, u, r&#125;); // 存储第i天的漫游数据        &#125;                // 对漫游信息进行判断,从第i-6天开始.因为7天前的用户漫游数据有可能到现在还是风险的        for (int j = max(0, i - 6); j &lt;= i; j ++ )        &#123;            for (int k = 0; k &lt; v[j].size(); k ++ )            &#123;                d = v[j][k].d;                u = v[j][k].u;                r = v[j][k].r;                                // 1.该用户的d要在7日内                // 2.该用户在近7日内到访的地区在到访的那一日处于风险状态                // 3.上述存在风险的地区自到访日(d)至生成名单当日(i)持续处于风险状态                bool flag = 1;                if (d &lt;= i - 7) continue; // 要求1                for (int l = d; l &lt;= i; l ++ ) // 要一直持续到当前i这一天 要求2&amp;3                    flag = flag &amp; sd[l].count(r);                if (flag) su.insert(u);            &#125;        &#125;                cout &lt;&lt; i &lt;&lt; &quot; &quot;;        for (auto it : su) cout &lt;&lt; it &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        su.clear();    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RvalueReference</title>
      <link href="/p/57245.html"/>
      <url>/p/57245.html</url>
      
        <content type="html"><![CDATA[<h1 id="RvalueReference"><a href="#RvalueReference" class="headerlink" title="RvalueReference"></a>RvalueReference</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>解决非必要的拷贝<br>Rvalue references are a new reference type introduced in C++Oxthat help solve the problem of unnecessary copying and enableperfect forwarding. When the right-hand side of an assignment isan rvalue, then the left-hand side object can steal resources fromthe right-hand side object rather than performing a separate allocation, thus enabling move semantics.</p><p>Rvalue 引用是 C++Ox 中引入的一种新的引用类型，有助于解决不必要的复制问题并启用完美转发。当赋值的右侧是右值时，左侧对象可以从右侧对象窃取资源，而不是执行单独的分配，从而实现移动语义。</p><ul><li>Lvalue: 可以出现在左边</li><li>Rvalue: 只能出现在右边</li></ul><p><strong>a+b&#x3D;42编译无法通过</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC.png"><br><strong>标红可以通过编译</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC2.png"><br><strong>标红可以通过编译</strong><br><img src="/p/57245.htm/%E5%B7%A6%E5%80%BC3.png"></p><h2 id="perfect-forwarding"><a href="#perfect-forwarding" class="headerlink" title="perfect forwarding"></a>perfect forwarding</h2><p><img src="/p/57245.htm/perfectForwarding.png"><br><img src="/p/57245.htm/standardForward.png"></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/p/2.html"/>
      <url>/p/2.html</url>
      
        <content type="html"><![CDATA[<p>stoi()，atoi() ，to_string 这三个函数都是对字符串处理的函数，前两者是将字符串转化为十进制 int 类型，最后一个是将十进制类型 int、double 等转化为string，头文件都是：#include<cstring><br>stoi 的参数是 const string* 类型<br>atoi 的参数是 const char* 类型</cstring></p><p>stoi() 会对转化后的数进行检查，判断是否会超出 int 范围，如果超出范围就会报错；<br>atoi() 不会对转化后的数进行检查，超出上界，输出上界，超出下界，输出下界；</p><p>反转数字自动去除前导零</p><pre><code>int countDistinctIntegers(vector&lt;int&gt;&amp; nums) &#123;    map&lt;int,int&gt; m;    for(int x:nums)&#123;      m[x]++;      string s=to_string(x);      reverse(s.begin(),s.end());      m[stoi(s)]++;    &#125;    return m.size();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/p/52608.html"/>
      <url>/p/52608.html</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串求他的最长回文子串</p><h2 id="方法1-暴力法"><a href="#方法1-暴力法" class="headerlink" title="方法1 暴力法"></a>方法1 暴力法</h2><p>略；</p><h2 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2 动态规划"></a>方法2 动态规划</h2><p>给定一个字符串s，设[p,q]是他的一个从p到q的回文字串，那么当p+1&lt;&#x3D;q-1的时候，[p+1，q-1]必定也是s的一个子串；<br>由此我们可以找到动态规划的递推表达式：</p><p>设：</p><pre><code>dp[i][i]=1; //单个字符是回文串dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串</code></pre><p>思考状态转移方程：</p><pre><code>根据头尾字符是否相等，需要分类讨论：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></pre><p>最终代码如下：</p><pre><code>string longestPalindrome(string s) &#123;    int slen=s.size();    vector&lt;vector&lt;bool&gt;&gt; dp(slen, vector&lt;bool&gt;(slen, 0));    int maxlenth = 0;    int left = 0;    int right = 0;    for (int i = slen - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; slen; j++) &#123;            if (s[i] == s[j]) &#123;                if (j - i &lt;= 1) &#123;                    dp[i][j] = true;                &#125;                 else if (dp[i + 1][j - 1]) &#123;                     dp[i][j] = true;                &#125;            &#125;            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxlenth) &#123;                maxlenth = j - i + 1;                left = i;                right = j;            &#125;        &#125;    &#125;    return s.substr(left, maxlenth);&#125;</code></pre><h2 id="方法三-中心拓展法"><a href="#方法三-中心拓展法" class="headerlink" title="方法三 中心拓展法"></a>方法三 中心拓展法</h2><p>我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1)P(i+1,j−1) 扩展到 P(i,j)P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</p><pre><code>class Solution &#123;public:    string longestPalindrome(string s) &#123;        int lans=0;        int length=s.size();        int left=0;        string ans=&quot;&quot;;        for(int i=0;i&lt;length;i++)&#123;            int j=1;            int tans=0;            while(i-j&gt;=0&amp;&amp;i+j&lt;length&amp;&amp;s[i-j]==s[i+j])&#123;                tans++;                j++;            &#125;            if(lans&lt;tans*2+1)&#123;                lans=tans*2+1;                left=i-tans;            &#125;            j=0;            tans=0;            while(i-j&gt;=0&amp;&amp;i+j+1&lt;length&amp;&amp;s[i-j]==s[i+j+1])&#123;                    tans++;                    j++;            &#125;            if(lans&lt;tans&lt;&lt;1)&#123;                lans=tans&lt;&lt;1;                left=i-tans+1;            &#125;            if(lans&gt;(length-i)*2)break;        &#125;        ans=s.substr(left,lans);        return ans;    &#125;&#125;;</code></pre><h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><pre><code>int countSubstrings(string s) &#123;    int n = s.size();    string t = &quot;$#&quot;;    for (const char &amp;c: s) &#123;        t += c;        t += &#39;#&#39;;    &#125;    n = t.size();    t += &#39;!&#39;;    auto f = vector &lt;int&gt; (n);    int iMax = 0, rMax = 0, ans = 0;    for (int i = 1; i &lt; n; ++i) &#123;        // 初始化 f[i]        f[i] = (i &lt;= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;        // 中心拓展        while (t[i + f[i]] == t[i - f[i]]) ++f[i];        // 动态维护 iMax 和 rMax        if (i + f[i] - 1 &gt; rMax) &#123;            iMax = i;            rMax = i + f[i] - 1;        &#125;        // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整        ans += (f[i] / 2);    &#125;    return ans;&#125;</code></pre><p>本题目重点需要说明的是马拉车算法；<br>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。那么我们如何统一奇数对称和偶数对称情况呢？<br>在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。<br><a href="https://imgse.com/i/p9eh1Mt"><img src="https://s1.ax1x.com/2023/04/23/p9eh1Mt.png" alt="处理后的字符串.png"></a></p><p>首先我们用一个数组 P 保存从中心扩展的最大个数。我们用 C 表示回文串的中心，用 R 表示回文串的右边半径坐标，所以 R &#x3D; C + P[ C ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。求 P [ i ] 的时候，如下图。</p><p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。<br><a href="https://imgse.com/i/p9ehrLV"><img src="https://s1.ax1x.com/2023/04/23/p9ehrLV.png" alt="p9ehrLV.png"></a></p><p>但是，利用对称性并不一定能完全得到结果<br><a href="https://imgse.com/i/p9ehzOP"><img src="https://s1.ax1x.com/2023/04/23/p9ehzOP.png" alt="p9ehzOP.png"></a><br>当我们要求 P [ i ] 的时候，P [ mirror ] &#x3D; 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i<br>此外如果，mirror因为碰到边界而截止<br><a href="https://imgse.com/i/p9e44hQ"><img src="https://s1.ax1x.com/2023/04/23/p9e44hQ.png" alt="p9e44hQ.png"></a><br>此时P [ i_mirror ] &#x3D; 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” &#x3D;&#x3D; “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><p>总之，综合思想就是利用对称性降低复杂度，使得我们判断过的部分避免反复计算，总体是时间复杂度大概是2n，即O(n);</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/p/22977.html"/>
      <url>/p/22977.html</url>
      
        <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>日常生活中，我们经常到饭店去吃饭，当然我们要吃什么会给服务员说，服务员再转告给厨师，点菜可以看做一个请求，看它如何用命令模式实现</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//命令的处理者：厨师class Chef&#123;public:    void cook(string name)    &#123;        cout &lt;&lt; &quot;厨师做一道&quot; &lt;&lt; name &lt;&lt; endl;    &#125;&#125;;//命令抽象类：点菜class Command&#123;protected:    Chef* chef_;public:    Command(Chef* chef) :chef_(chef) &#123;&#125;    virtual void excute() = 0;&#125;;命令具体类:牛肉class BeefCmd :public Command&#123;public:    BeefCmd(Chef *chef) :Command(chef) &#123;&#125;    virtual void excute() override    &#123;        chef_-&gt;cook(&quot;青椒炒牛肉&quot;);    &#125;&#125;;//命令具体类:土豆class PotatoCmd :public Command&#123;public:    PotatoCmd(Chef *_chef) :Command(_chef) &#123;&#125;    virtual void excute()    &#123;        chef_-&gt;cook(&quot;青椒炒土豆丝&quot;);    &#125;&#125;;//命令接受者：服务员class Waiter&#123;private:    Command* cmd_;public:    void ReciveCmd(Command* cmd)    &#123;        cmd_ = cmd;    &#125;    void DealCmd()    &#123;        cmd_-&gt;excute();    &#125;&#125;;//饭店场景int main()&#123;    //服务员    Waiter *waiter = new Waiter;    //厨师    Chef *chef = new Chef;    //客人开始点菜    Command *beef = new BeefCmd(chef);    Command *potato = new PotatoCmd(chef);    //下单    waiter-&gt;ReciveCmd(beef);    waiter-&gt;DealCmd();    waiter-&gt;ReciveCmd(potato);    waiter-&gt;DealCmd();    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点</strong></p><ul><li>将调用操作的对象和实现操作的对象进行了解耦。</li><li>具体命令扩展方便。</li></ul><p><strong>缺点</strong></p><ul><li>有几个具体命令就有多少具体类，可能需要大量具体命令类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++编码规范</title>
      <link href="/p/64590.html"/>
      <url>/p/64590.html</url>
      
        <content type="html"><![CDATA[<h1 id="c-编码规则"><a href="#c-编码规则" class="headerlink" title="c++编码规则"></a>c++编码规则</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>文件名全部使用小写字母<br>示例：</p><pre><code>kctlinechartview.h</code></pre><h4 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h4><p>类的命名使用前缀+驼峰命名法。当一个类需要暴露给其它工程使用时，应加上工程约定的前缀，前缀全部使用大写字母。类命名尽量使用完整英文单词，除非是常见的缩写。<br>示例：</p><pre><code>KCTLineChartView</code></pre><p>Com 接口命名在普通前缀前加 I 作为标志。</p><p>示例：IKCTChartView</p><h4 id="其他类型命名"><a href="#其他类型命名" class="headerlink" title="其他类型命名"></a>其他类型命名</h4><p>struct、typedef 与 enum 的命名原则与类相同。enum 成员采用大写字母开头的驼峰写法，且应在命名中体现 enum 名称，具体位置不做强制要求，但同一个 enum 内的命名规则要保持一致。<br>示例：</p><pre><code>enum ActionType&#123;    InsertActionType, DeleteActionType, MoveActionType&#125;;</code></pre><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>变量命名使用小写字母开头的驼峰写法，不加类型信息前缀，命名应使用能表达变量涵义的完整英文单 词。<br>示例:</p><pre><code>int index = 0；KCTLineChartView  *lineChartView = NULL;</code></pre><p>仅允许在 for 单层循环中的 i 和表示坐标的 x、y、z 上使用单字母变量，其他情况下不允许使用。</p><p>非 static 的类成员变量前加上小写字母 m_前缀，static 的类成员变量前加上小写字母 s_前缀，这两种情况下变量名的第一个单词首字母小写，后面单词首字母大写。<br>示例：</p><pre><code>class GoodClass&#123;private:    int m_dataMember;    static int s_staticDataMember;&#125;;</code></pre><h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><p>除构造函数和析构函数外，类成员函数使用小写字母开头的驼峰写法。非类成员函数使用大写字母开头 的驼峰写法。<br>示例：    </p><pre><code>lineChartView-&gt;lineCount();GetObjectCountInDocument();</code></pre><p>名词属性的类成员函数命名分两种情况：若欲获取的信息当成返回值返回，则命名方式为 名词 或 名词+修饰语 的样式。若欲获取的信息通过某个参数返回，则命名方式为 get+名词（+修饰语）的样式。<br>示例：    </p><pre><code>lineChartView-&gt;title();lineChartView-&gt;subViewAtIndex(index);lineChartView-&gt;getSubViews(&amp;outPointer);</code></pre><p>动词属性的类成员函数命名方式为 动词+宾语，若宾语是 this, 应省略。<br>示例：  </p><pre><code>lineChartView-&gt;removeAllSubViews(); lineChartView-&gt;setTitle(L”Hello World”); lineChartView-&gt;initialize();</code></pre><p>形容词属性的类成员函数命名方式为 is&#x2F;has 等修饰语+形容词&#x2F;名词。<br>示例：</p><pre><code>lineChartView-&gt;isVisible(); lineChartView-&gt;hasTitle();</code></pre><p>返回对象指针的函数若内部分配了内存，应使用 copy, create 等关键字把该信息反映在函数名上。</p><p>示例：</p><pre><code>lineChartView-&gt;subViews();     //未重新分配内存 lineChartView-&gt;copySubViews();    //重新分配了内存</code></pre><h4 id="函数命名-1"><a href="#函数命名-1" class="headerlink" title="函数命名"></a>函数命名</h4><p>宏命名</p><p>原则上宏的命名全部大写，如有必要单词间用下划线分隔。如无必要，不把一段代码定义成宏。</p><p>示例：</p><pre><code>#define SOMETHING_USED</code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>关于使用全局变量的注意事项见后文。全局变量前加小写字母 g_ 前缀，static 全局变量前加小写字母 gs_前缀。<br>示例：</p><pre><code>bool g_inFileOpening = false;static bool gs_staticInFileOpening = true;</code></pre><h4 id="名称空间命名"><a href="#名称空间命名" class="headerlink" title="名称空间命名"></a>名称空间命名</h4><p>名称空间使用剪短的全小写英文单词命名。<br>示例：</p><pre><code>namespace chart&#123;    ....&#125;</code></pre><h4 id="不允许使用-My-或自己的姓名作为以上命名的前缀"><a href="#不允许使用-My-或自己的姓名作为以上命名的前缀" class="headerlink" title="不允许使用 My 或自己的姓名作为以上命名的前缀"></a>不允许使用 My 或自己的姓名作为以上命名的前缀</h4><p>例如：</p><p>&#x2F;&#x2F;禁止下列写法。</p><pre><code>Class MyStringProject&#123; public:    ...&#125;</code></pre><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h4 id="头文件包含保护"><a href="#头文件包含保护" class="headerlink" title="头文件包含保护"></a>头文件包含保护</h4><p>在所有头文件中均使用#ifndef + #define + #endif 来避免该文件被重复包含，宏的命名方式为</p><pre><code>PROJECTNAME_FILENAME_H</code></pre><p>示例：</p><p>MyProject 项目有头文件名为 MyHeader.h，则文件头部加上 </p><pre><code>#ifndef      MYPROJECT_MYHEADER_H     #define      MYPROJECT_MYHEADER_H     </code></pre><p>文件末尾加上</p><pre><code>#endif  //     MYPROJECT_MYHEADER_H     </code></pre><h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>当使用一两个前置声明就能编译通过时，不要在头文件里包含另一个头文件。</p><h4 id="头文件包含顺序"><a href="#头文件包含顺序" class="headerlink" title="头文件包含顺序"></a>头文件包含顺序</h4><p>在代码文件里包含多个头文件时，应按照如下顺序将头文件分组，每组之间使用空行隔开：</p><ol><li><p>预编译头文件，通常是 stdafx.h</p></li><li><p>与代码文件同名的头文件</p></li><li><p>系统头文件</p></li><li><p>WPS 内部其他工程头文件</p></li><li><p>本工程其他头文件</p></li></ol><p>示例：</p><p>MyProject 工程中的 MyClass.cpp 实现了声明在 MyClass.h 内的类，此外还用到了 C++ 标准库中的 Vector 容器、ExternalProject 工程中的 ExternalClass.h 和 ExternalUtils.h、MyProject 工程中的 MyFriendClass.h、MyFileIOHelper.h 与 MyStringUtils.h，<br>其包含顺序如下: </p><pre><code>#include &quot;stdafx.h&quot;#include &quot;MyClass.h&quot;#include &lt;vector&gt;#include &quot;ExternalClass.h&quot; #include &quot;ExternalUtils.h&quot;#include &quot;MyFirendClass.h&quot; #include &quot;MyFileIOHelper.h&quot; #include &quot;MyStringUtils.h&quot;</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的所有成员变量必须初始化，只有成员变量没有函数的类，必须定义默认构造函数。</p><p>除非有特殊需求，在类的构造函数中仅进行不涉及具体功能的初始化操作，例如为成员变量赋零。较复杂的初始化操作，应放在一个单独的 init()方法中，由类实例的创建者负责调用。<br>解释：构造函数内难以报告错误，且构造函数中对虚函数的调用不会派发给子类，所以较复杂的初始化操作应在构造完成之后进行。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>若没有明确的将单参构造函数用于隐式类型转换的需求，应使用 explicit 关键字。</p><h4 id="拷贝构造函数、赋值运算符"><a href="#拷贝构造函数、赋值运算符" class="headerlink" title="拷贝构造函数、赋值运算符"></a>拷贝构造函数、赋值运算符</h4><p>若没有明确的对类进行拷贝的需求，应在 private 段中声明拷贝构造函数和赋值运算符。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>只使用 public 继承。</p><p>在语义明确的时候从父类继承具体实现，其他时候从抽象接口继承。若类有虚函数，则析构函数也定义为虚函数。<br>父类中声明为 virtual 的函数，子类声明中要明确标明为 virtual 以及 override。</p><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>尽量避免运算符重载，除非是为了在容器类中使用而必须实现的。</p><h4 id="访问权限声明"><a href="#访问权限声明" class="headerlink" title="访问权限声明"></a>访问权限声明</h4><p>类声明中按 public, protected, private 的顺序声明函数和变量，每个关键字仅占用一段，每一段中的声明顺序为： typedef, enum, Q_OBJECT 及类似声明，嵌套类，常量，构造函数，虚构函数，成员函数，数据成员。</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的定义和友类的定义应放在同一个文件中。</p><h2 id="函数与实现"><a href="#函数与实现" class="headerlink" title="函数与实现"></a>函数与实现</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数排列顺序为输入参数在前，输出参数在后。引用作为输入参数时应配合 const 使用。不使用缺省参数。<br>不允许一个参数即作为传入参数，又作为传出参数。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数不超过 10 行，推荐仅对 1 行的函数进行 inline。不使用循环或 switch…case，不进行递归。在类定义体内实现的函数，不要加 inline 关键字。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>避免使用异常（try…catch）。使用 ATL 和 STL 时，关闭异常或限制异常作用域。</p><h4 id="类型编程"><a href="#类型编程" class="headerlink" title="类型编程"></a>类型编程</h4><p>不使用运行时类型信息。明确使用 static_cast，const_cast 进行类型转换，避免使用 dynamic_cast,小心使用 reinterpret_cast。</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>尽量使用 const、enum、inline 替代 #define。</p><h4 id="类数据成员的引用"><a href="#类数据成员的引用" class="headerlink" title="类数据成员的引用"></a>类数据成员的引用</h4><p>避免成员函数返回指向类成员的指针或引用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>文件头注释应包括 文件名，创建者，创建时间，功能描述 和版权信息。</p><p>示例：</p><pre><code>    // KCTCodingGuideline.h    // 创建者： Tom Cat    // 创建时间： 2013/5/24    // 功能描述： The coding guideline for Chart project in WPS        // Copyright 2013 Kingsoft</code></pre><h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><p>注释使用 &#x2F;&#x2F; 风格，应简洁清晰，不写没必要的注释。代码中不是很简单直观的地方需要增加注释，</p><p>例如：</p><ul><li><p>故意违背编码规范之处。</p></li><li><p>分成多步完成的任务。</p></li><li><p>较复杂的逻辑。</p></li><li><p>和常理不符的代码。</p></li><li><p>比较重要，需要引起注意的地方。</p></li></ul><h4 id="注释语言"><a href="#注释语言" class="headerlink" title="注释语言"></a>注释语言</h4><p>默认注释语言为中文。</p><h4 id="注释中的工程师姓名"><a href="#注释中的工程师姓名" class="headerlink" title="注释中的工程师姓名"></a>注释中的工程师姓名</h4><p>在且仅在两种情形下把姓名加入注释中：</p><ol><li><p>文件头中的创建者信息。</p></li><li><p>做 TODO 注释时。</p></li></ol><p>示例： </p><pre><code> //TODO(Tommy Zhang): 删掉这里的全局变量!</code></pre><h4 id="预处理宏注释"><a href="#预处理宏注释" class="headerlink" title="预处理宏注释"></a>预处理宏注释</h4><p>中间代码段较长的#else 与 #endif 之后用注释标明宏的名字。</p><p>示例：</p><pre><code>    #if TARGET_PLATFORM_WINDOWS    ................        #else //TARGET_PLATFORM_WINDOWS    ................    #endif //TARGET_PLATFORM_WINDOWS</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h4 id="对齐与缩进"><a href="#对齐与缩进" class="headerlink" title="对齐与缩进"></a>对齐与缩进</h4><p>使用 Tab 进行对齐。</p><p>花括号上下对齐，不允许将左花括号放在 if 等语句的末尾：<br>例如：</p><pre><code>    void MyFunction(InputType type)    &#123;        static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;         static const ScopeType scopeType[] =        &#123;            wpsFindScope_MainText, wpsFindScope_Selection, wpsFindScope_HeaderFooters, wpsFindScope_Footnotes, wpsFindScope_Endnotes,            ...            wpsFindScope_Comments        &#125;;                switch (type)        &#123;        case TypeA:            break;        case TypeB:            break;         default:            break;        &#125;        if (...)        &#123;        &#125;        else        &#123;        &#125;        do        &#123;        &#125;        while (...);                for (int i = 0; i &lt; 10; ++ i)        &#123;        &#125;    &#125;</code></pre><p>构造函数初始化列表和多个基类的中每一行逗号放前面，和冒号对齐。</p><p>示例：</p><pre><code>KGroupGrid::KGroupGrid(QWidget *parent)    : QWidget(parent)    , m_scrollBar(Qt::Vertical, this)    , m_headerHeight()    , m_itemSize(80, 64)    , m_showTooltip(false)    , m_flatFrame(true)    , m_showSeperatorLine(true)    , m_scrollBarPolicy(Qt::ScrollBarAsNeeded) #if X_OS_WINDOWS    , m_firstRow(0) #endif&#123;&#125;class KxWppViewPages    : public QStackedWidget        , public KFakeUnknown&lt;IShellPagesGetter&gt;    , public KFakeUnknown&lt;IROShellPages&gt;    , public KxWppViewPagesCoreNotify&#123;&#125;;</code></pre><p>只有一行代码的 if 语句不加花括号。</p><p>示例：</p><pre><code>if (inputType == badType)     DoSomethingBad();if (inputType == badType)     DoSomethingBad();else    DoSomethingElse();</code></pre><p>当 if 语句中某一个分支有一行的以上代码时，if 的所有子句都要加括号。</p><p>示例：</p><pre><code>if (inputType == badType)&#123;    DoSomethingBad();&#125;else&#123;    DoSomethingElse1();     DoSomethingElse2();&#125;</code></pre><p>推荐一行代码不超过 120 个字符。函数参数列表过长时，应换行：返回值类型、左括号应保持与函数名同一行，具体换行的方案有两种：<br>示例：</p><pre><code>HRESULT MyClass::method(ParameterOne param1,                        ParameterTwo param2,                         ParameterThree param3)HRESULT MyClass::method(ParameterOne param1,     ParameterTwo param2, ParameterThree param3)</code></pre><p>函数类型为 const 时，const 关键字与最后一个参数同行<br>示例：</p><pre><code>HRESULT MyClass::constMethod(ParameterOne param1,                            ParameterTwo param2,                            ParameterThree param3) const</code></pre><p>所有预编译宏顶格对齐。</p><p>示例：</p><pre><code>void MyClass::methodWithMacros()&#123;    static int integer1 = 0;    integer1 ++;     if(integer1 &gt;= 10)    &#123;#if PLATFORM_1        integer1 = 1;#else        integer1 = 2;#endif    &#125;&#125;</code></pre><p>分为多行的布尔表达式中 &amp;&amp; 与 || 置于行首。换行应在运算符优先级最低的地方进行，尽可能避免把配对的括号分成两行。<br>当条件比较复杂时，应将高优先级的运算用括号明确标识出来。</p><p>示例：</p><pre><code>if ((valueGood &gt;= somethingGood || otherContion)     &amp;&amp; (valueBad + 1) &lt;= somethingRealyBad)</code></pre><p>命名空间（namespace)内容不缩进</p><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>函数调用的括号前后之间不加空格，参数之间逗号之后加一个空格。</p><p>示例：</p><pre><code>void MyFunction(ParameterOne param1, ParameterTwo param2)</code></pre><p>if、while、for 等关键字与括号之间加一个空格，括号后不加空格。<br>示例：</p><pre><code>if (NULL == thePointer)for (int index = 0; index &lt; maxIntValue; index++)</code></pre><p>使用 Tab 键无法刚好对齐时，使用空格补齐。</p><p>没有参数的函数括号内不加空格。</p><p>二元运算符前后各加一个空格；</p><p>自增减运算符与分号间不加空格，与变量之间也不加空格。</p><p>示例：</p><pre><code>if (inputType1 == goodType &amp;&amp; inputType2 == badType) for (int index == 0; index &lt; MAX_INT; index++)</code></pre><p>引用符号（. -&gt;）前后不加空格。</p><p>示例：</p><pre><code>theSmartPointer-&gt;value();</code></pre><p>地址、引用运算符（*, &amp;）后不加空格；</p><p>示例：</p><pre><code>*integerPointer = 1;</code></pre><p>声明指针类型的*号前加一空格，后边不加空格</p><p>示例：</p><pre><code>MyClass *goodClass;</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>不需要暴露嵌套类作为接口的时候，将嵌套类声明为 private。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量应在将要使用时进行声明，声明的同时初始化。</p><p>示例：</p><pre><code>void SomeMagicalFunction()&#123;    const int magicNumber = 1;    int integer1 = magicNumber;    integer1 ++;    if (integer1 &lt;= 0)         DoSomethingWeird();    float floatingNumer1 = 1.0;    float *floatingPointer = &amp;floatNumber1;    if (floatingPointer == NULL)        HowCouldThisHappen();&#125;</code></pre><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><p>除非特殊情况，不使用 Class 类型的全局变量，不使用 Class 类型的 static 类数据成员。可以用单例模式替代 Class 类型的全局变量。</p><p>全局的字符串变量使用 C 风格的 char，不使用各种字符串类。</p><h4 id="名称空间（namespace）"><a href="#名称空间（namespace）" class="headerlink" title="名称空间（namespace）"></a>名称空间（namespace）</h4><p>允许在 cpp 文件中使用匿名名称空间进行保护，不允许在头文件中使用匿名名称空间。避免使用 using namespace 将一个名称空间中的所有名称全部导入。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h4 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h4><p>使用 typename 关键字声明模板，不使用 class 关键字。</p><h4 id="模板适用范围"><a href="#模板适用范围" class="headerlink" title="模板适用范围"></a>模板适用范围</h4><p>一般情况下仅使用模板来实现容器类或通用算法，如果需要用作其他用途，请增加注释说明必要性。</p><h4 id="模板中的嵌套类"><a href="#模板中的嵌套类" class="headerlink" title="模板中的嵌套类"></a>模板中的嵌套类</h4><p>模板中使用嵌套类时，加上 typename 关键字声明。</p><p>示例：</p><pre><code>template&lt;typename T&gt;void someFunction(const T&amp; container)&#123;    typename T::Iterator iter(container.begin());    iter.next();&#125;</code></pre><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>在模板派生类中调用模板基类函数时，明确在函数调用前声明该函数属于基类。</p><p>示例：</p><pre><code>template&lt;typename T&gt;class DerivedClass::public BaseClass&lt;T&gt;&#123;public:    void doAction()    &#123;        BaseClass&lt;T&gt;::doBaseAction();    &#125;&#125;</code></pre><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="优先使用静态内存"><a href="#优先使用静态内存" class="headerlink" title="优先使用静态内存"></a>优先使用静态内存</h4><p>编译期能够确定的常量数组，应声明为 static。</p><p>示例：</p><pre><code>void func(int type)&#123;    static const int someInt[] = &#123;80, 40, 40, 50, ... 94, 94, 47&#125;;    ......&#125;</code></pre><h4 id="其次为栈内存"><a href="#其次为栈内存" class="headerlink" title="其次为栈内存"></a>其次为栈内存</h4><p>编译期能够确定长度的非常量数组，应使用栈内存。</p><p>示例：</p><pre><code>void func(int type)&#123;    const int length = 1024;    unsigned char buffer[length + 1];     DWORD dwReadSize = length;    while (::ReadFile(hFile, buffer, length, &amp;dwReadSize, NULL))    &#123;        ......        dwReadSize = length;    &#125;&#125;</code></pre><h4 id="使用智能指针和容器管理堆内存"><a href="#使用智能指针和容器管理堆内存" class="headerlink" title="使用智能指针和容器管理堆内存"></a>使用智能指针和容器管理堆内存</h4><p>单个堆对象的生命周期用 std::unique_ptr 来管理。</p><p>连续的内存空间用 std::vector 或 QVector 来分配和管理。</p><p>示例：</p><pre><code>void func(int type)&#123;    std::unque_ptr&lt;CSomeObject&gt; spObject = new CSomeObject();    int bufferLength = getBufferLength(); std::vector&lt;SomeType&gt; vecBuffer(bufferLength);     readBuffer(&amp;vecBuffer[0], bufferLength);&#125;</code></pre><p>字符串用 std::basic_string<T>或 QString 来管理。</T></p><p>示例：</p><pre><code>void func(int type)&#123;    int stringLength = getStringLength();    std::string str; str.resize(stringLength);    readStringInCStyleFunction(&amp;str[0], stringLength);&#125;</code></pre><p>不允许在代码中出现 new[] 和 delete[]的显示调用。</p><p>delete 不应该出现在析构函数或用于清理内存的函数之外的地方出现。</p><p>不允许使用 malloc&#x2F;free 来分配和释放内存。</p><p>十. 跨平台</p><h4 id="Windows-内建类型"><a href="#Windows-内建类型" class="headerlink" title="Windows 内建类型"></a>Windows 内建类型</h4><p>调用 Windows API 时，使用 DWORD、LPCTSTR 等 Windows 类型，其它情况下避免使用，但可以使用 HRESULT。</p><h4 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h4><p>避免使用 Windows 系统 API，只能在限定模块内使用，比如一个封装操作系统 API 的中间层。</p><h4 id="C-扩展库"><a href="#C-扩展库" class="headerlink" title="C++扩展库"></a>C++扩展库</h4><p>不允许使用 Boost 库，除非是已经进入 C++11 标准的部分。</p><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h4><p>可以使用 C++11 新语法中 Visual C++支持的部分，但须遵守如下原则：</p><ol><li><p>不使用 lambda 表达式。</p></li><li><p>仅使用 auto 来简化模板变量的声明，不将基本类型或者表达式返回值赋给 auto 对象。</p></li><li><p>不使用尾部返回类型声明，例如 auto Function() -&gt; int；</p></li><li><p>不使用 Raw String。</p></li><li><p>禁用模版元编程。</p></li><li><p>不允许使用逗号表达式。</p></li></ol><p>不能使用 Visual C++专有语法，例如：</p><ol><li><p>finally、     super、     forceinline 等关键字。</p></li><li><p>省略类静态成员的外部定义。</p></li><li><p>将函数指针 cast 成整型指针。</p></li><li><p>重复包含有 extern 全局变量定义(非声明)的头文件。</p></li><li><p>goto 关键字跨越变量定义。</p></li><li><p>如果有可能，在 Visual Studio 中设置&#x2F;Za 标志关闭 Microsoft Extension to C++。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长字符串链</title>
      <link href="/p/53127.html"/>
      <url>/p/53127.html</url>
      
        <content type="html"><![CDATA[<h1 id="最长字符串链"><a href="#最长字符串链" class="headerlink" title="最长字符串链"></a>最长字符串链</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给出一个单词数组 words ，其中每个单词都由小写英文字母组成。</p><p>如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。</p><p>例如，”abc” 是 “abac” 的 前身 ，而 “cba” 不是 “bcad” 的 前身<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k &#x3D;&#x3D; 1 的 单词链 。</p><p>从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。 </p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>示例 1：</p><pre><code>输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]输出：4解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]</code></pre><p>示例 2:</p><pre><code>输入：words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]输出：5解释：所有的单词都可以放入单词链 [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;].</code></pre><p>示例 3:</p><pre><code>输入：words = [&quot;abcd&quot;,&quot;dbqca&quot;]输出：1解释：字链[&quot;abcd&quot;]是最长的字链之一。[&quot;abcd&quot;，&quot;dbqca&quot;]不是一个有效的单词链，因为字母的顺序被改变了。</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><pre><code>1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 16words[i] 仅由小写英文字母组成。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们将问题分解成几个子问题，我们先来看单词链的判断，单词链相邻单词必然满足长度相差一且长度较长的单词&#x3D;长度短的单词+任意位置插入一个字母，也就是说如果没有插入字母两个字符串是完全相同的，插入一个字母以后，除了那一个位置以外的所有字母都是一一对应的。那么我们可以根据这个对短单词进行遍历，一一与长单词进行对应，如果不相同则跳过这个字母，比对后面的字母，如果跳过次数不等于1，则两个单词不能组成单词链。<br>接下来我们分析题目，需要求最长单词链，我们仔细观察可以发现最长单词链是满足最优子结构性的，例如长度为最大为m的单词组成的最长链必须由单词+最长的单词长度最大为m-1的单词链组成。<br>定义</p><pre><code>dp[i]表示以单词i为结尾的最长的单词链长度</code></pre><p>初始化</p><pre><code>至少一个单词，初始化为1</code></pre><p>计算</p><pre><code>预处理先按照字符串长度升序排列从短到长来计算, 对于当前单词去找序号比它小的 j 情况： 如果相等，则 max(d[i], d[j]+1)</code></pre><p>代码 </p><pre><code>class Solution &#123;    // a是否是b的前身    bool isFor(string&amp; a, string&amp; b) &#123;        int asize=a.size();        int bsize=b.size();        if(bsize - asize== 1) &#123;            int i = 0, j = 0;            while(i &lt; asize &amp;&amp; j &lt; bsize) &#123;                if(a[i] == b[j]) i++;                j++;            &#125;            if(i == asize) return true;        &#125;        return false;    &#125;public:    int longestStrChain(vector&lt;string&gt;&amp; words) &#123;        if(words.size() &lt; 2)            return words.size();                vector&lt;int&gt; dp(words.size(), 1);        int res = 1;                // 按字符串长度递增排序        sort(words.begin(), words.end(),             [](string a, string b) &#123;return a.size() &lt; b.size();&#125;);                for(int i = 0; i &lt; words.size(); i++) &#123;            for(int j = i - 1; j &gt;= 0; j--) &#123;                if(isFor(words[j], words[i])) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-string-chain">https://leetcode.cn/problems/longest-string-chain</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Otherthings</title>
      <link href="/p/4097.html"/>
      <url>/p/4097.html</url>
      
        <content type="html"><![CDATA[<h1 id="Otherthings"><a href="#Otherthings" class="headerlink" title="Otherthings"></a>Otherthings</h1><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><ul><li>noexcept是C++11为了替代 throw()而提出的一个新的关键字</li><li>C++中使用函数异常声明列表来查看函数可能抛出的异常。</li><li>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</li></ul><p>下例就是一个函数异常声明列表，该声明指出 func 可能抛出int和 double 类型的异常。</p><pre><code>void func() throw (int,double);</code></pre><p>但是在实际编程中很少使用这种写法，所以这一特性在 C++11 中被抛弃。另外，如果异常声明列表写成如下形式：</p><pre><code>void func() throw();</code></pre><p>这种写法表示函数 func 不抛出任何异常，而这种写法在 c++11 中被新的关键字 noexcept 异常声明所取代。语法上 noexcept 修饰符有两种形式，一种就是简单地在函数声明后加上 noexcept 关键字。比如：</p><pre><code>void func() noecept;</code></pre><p>另外一种形式则是接受一个常量表达式作为参数，如下所示：</p><pre><code>void func() noexcept(常量表达式);</code></pre><p>常量表达式的结果会被转换成一个 bool 类型的值，该值为 true，表示函数不会抛出异常，反之则可能抛出异常。而不带常量表达式的 noexcept相当于声明了 noexcept(true)，即不会抛出异常。</p><p><strong>以下情形鼓励使用noexcept：</strong></p><ul><li>移动构造函数（move constructor）</li><li>移动分配函数（move assignment）</li><li>析构函数（destructor）</li></ul><p><img src="/p/4097.htm/noexcept.png"></p><p><strong>不是以上情况或者没把握的情况下，不要轻易使用noexception。</strong></p><h2 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h2><p>override关键字作用：<br>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。<br>如果派生类里面想要重载虚函数 就加上关键字override 这样编译器可以辅助检查是不是正确重载，如果没加这个关键字 也没什么严重的error 只是少了编译器检查的安全性。</p><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>C++11的关键字final有两个用途。</p><ul><li>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</li><li>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面。</li></ul><p>具体例子如下所示：</p><pre><code>struct Base&#123;    virtual void foo();&#125;;struct A : Base&#123;    void foo() final; // Base::foo 被覆盖而 A::foo 是最终覆盖函数    void bar() final; // 错误：非虚函数不能被覆盖或是 final&#125;;struct B final : A // struct B 为 final&#123;    void foo() override; // 错误：foo 不能被覆盖，因为它在 A 中是 final&#125;;struct C : B // 错误：B 为 final&#123;&#125;;</code></pre><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>auto，用于通过一个表达式在编译时确定待定义的变量类型，auto 所修饰 的变量必须被初始化，编译器需要通过初始化来确定auto 所代表的类型，即必须要定义变 量。<br>若仅希望得到类型，而不需要（或不能）定义变量的时候应该怎么办呢？ C++11 新增了decltype 关键字，用来在编译时推导出一个表达式的类型。它的语法格式 如下：</p><pre><code>decltype(exp)</code></pre><p>其中，exp 表示一个表达式（expression）</p><p>auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。</p><pre><code>#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;class Base &#123;public:    void func(T&amp; container) &#123;        m_it = container.begin();    &#125;private:    typename T::iterator m_it;  //注意这里&#125;;int main()&#123;    const vector&lt;int&gt; v;    Base&lt;const vector&lt;int&gt;&gt; obj;    obj.func(v);    return 0;&#125;</code></pre><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template Template Parameter</title>
      <link href="/p/6511.html"/>
      <url>/p/6511.html</url>
      
        <content type="html"><![CDATA[<h1 id="Template-Template-Parameter"><a href="#Template-Template-Parameter" class="headerlink" title="Template Template Parameter"></a>Template Template Parameter</h1><p>接Alias Template<br>我们还是想解决这个问题<br><img src="/p/6511.htm/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B01.png"><br>通过模板模板参数，我们可以采用下面这个方法<br><img src="/p/6511.htm/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png"><br>这个程序编译是可以通过的，但是调用的过程中会产生下面的错误<br><img src="/p/6511.htm/%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png"><br>仔细分析报错信息我们会发现<br><img src="/p/6511.htm/vector.png"><br>事实上，容器第二个参数在模板中需要传参<br><img src="/p/6511.htm/%E5%88%AB%E5%90%8D%E8%B0%83%E7%94%A8.png"><br>通过别名调用才是正确的结果，这说明别名的存在有很大作用，需要细细体会</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alias Template</title>
      <link href="/p/45839.html"/>
      <url>/p/45839.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h1><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>传统方法使用关键字 typedef。<br>C++新标准规定了一种新方法，使用关键字 using 进行 别名申明（alias declaration）来定义类型的别名。<br>从使用语法来看 using 比 typedef 更加简洁明了，推荐使用 using 关键字进行别名定义。</p><ul><li>typedef void (*func)(int, int);</li><li>using func&#x3D; void(*) (int,int);</li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><ul><li>using vec &#x3D; std::vector&lt; T,MyAlloc<T> &gt;;</T></li><li>使用#define无法达到同样的效果</li><li>使用typedef也无法达到同样的效果，因为typedef不接受参数，只能提供特化的内容在</li><li>标准 C++，typedef 可定义模板类型一个新的类型名称，但是不能够使用 typedef 来定义模板的别名。举例来说：</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>别名声明可以模板化，但是typedef不可以；</p><pre><code>template&lt;typename T&gt;using MyAllocList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;;MyAllocList&lt;Widget&gt; lw;</code></pre><p>如果使用typedef的话，则很复杂：</p><pre><code>template&lt;typename T&gt;struct MyAllocList &#123;    typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;&#125;;MyAllocList&lt;Widget&gt;::type lw;</code></pre><p>别名的作用难道就是少打几个字嘛？<br><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%951.png" alt="错误案例1"></p><p><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%95.png" alt="错误案例2"></p><p>正确用法<br><img src="/p/45839.htm/%E5%88%AB%E5%90%8D%E6%B5%8B%E8%AF%953.png" alt="错误案例2"></p><p>但是我们并没有成功的传入模板参数T，还是有些遗憾，那么该如何解决呢？<br>后续内容请参考<a href="./TemplateTemplateParameter.md">模板模板参数</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Initialization</title>
      <link href="/p/4260.html"/>
      <url>/p/4260.html</url>
      
        <content type="html"><![CDATA[<h1 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h1><pre><code>int    values[ ] &#123;1, 2, 3&#125;;vector&lt;int&gt; v&#123; 2, 3, 5, 7, 11, 13, 17  &#125;;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变参模板</title>
      <link href="/p/64016.html"/>
      <url>/p/64016.html</url>
      
        <content type="html"><![CDATA[<h1 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h1><h2 id="数量不定的模板参数："><a href="#数量不定的模板参数：" class="headerlink" title="数量不定的模板参数："></a>数量不定的模板参数：</h2><p>Variadic Template是C++11的一个很重要的特性；</p><p>变体现在两个方面：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归调用；</li><li>参数类型：参数个数逐一递减导致参数类型也逐一递减；</li></ul><p>两个注意点</p><ul><li>递归调用</li><li>递归终止：使用重载的办法终止递归调用；</li></ul><p><img src="https://i.imgur.com/PheGO3f.png"></p><h2 id="递归函数方式展开参数包"><a href="#递归函数方式展开参数包" class="headerlink" title="递归函数方式展开参数包"></a>递归函数方式展开参数包</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>以print函数为例，该模板参数将可以把参数不断地递归分解参数，不断递归调用print本身将参数打印出来了，但是最后一个打印完后没有参数了，所以还需要写一个参数为零的print()。 </p><pre><code>void print() &#123;&#125;template&lt;typename T,typename...Types&gt;void print(const T&amp; firstArg, const Types&amp;...args) &#123;    cout &lt;&lt; firstArg &lt;&lt; endl;    printX(args...);&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code>int maximun(int n)&#123;    return n;&#125;template&lt;typename...Args&gt;int maximun(int n,Args...args)&#123;    return std::max(n,maximun(args...));&#125;</code></pre><h2 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h2><pre><code>template &lt;class T&gt;void printarg(T t)&#123;cout &lt;&lt; t &lt;&lt; endl;&#125;template &lt;class ...Args&gt;void expand(Args... args)&#123;int arr[] = &#123;(printarg(args), 0)...&#125;;&#125;expand(1,2,3,4);</code></pre><p>这个例子将分别打印出1,2,3,4四个数字。这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p><pre><code>d = (a = b, c); </code></pre><p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p><p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。我们可以把上面的例子再进一步改进一下，将函数作为参数，就可以支持lambda表达式了，从而可以少写一个递归终止函数了，具体代码如下：</p><pre><code>template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args) &#123;    initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;&#125;expand([](int i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2,3);</code></pre><p>上面的例子将打印出每个参数，这里如果再使用C++14的新特性泛型lambda表达式的话，可以写更泛化的lambda表达式了：</p><pre><code>expand([](auto i)&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;, 1,2.0,”test”);</code></pre><p>主要内容摘自<a href="https://www.cnblogs.com/qicosmos/p/4325949.html">https://www.cnblogs.com/qicosmos/p/4325949.html</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/p/9423.html"/>
      <url>/p/9423.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>六大部件</strong></p><ul><li>分配器</li><li>容器</li><li>迭代器</li><li>算法</li><li>仿函数</li><li>适配器</li></ul><p><img src="/p/9423.htm/Components.png"></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>分为</p><ul><li>Sequence Containers<ul><li>Array</li><li>Vector</li><li>Deque</li><li>List</li><li>Forward-List</li></ul></li><li>Associative Containers<ul><li>Set&#x2F;Multiset</li><li>Map&#x2F;Multimap</li><li>Unordered Set&#x2F;Multiset</li><li>Unordered Map&#x2F;Multimap</li></ul></li></ul><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td></tr><tr><td><code>deque</code></td><td>双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</td></tr></tbody></table><ul><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forwa‘rd_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li><li><p>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</p></li><li><p><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</p></li><li><p>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</p></li><li><p>新标准库的容器比旧版的快得多。</p></li><li><p><code>forward_list</code>没有<code>size</code>操作，对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unique_ptr</title>
      <link href="/p/39842.html"/>
      <url>/p/39842.html</url>
      
        <content type="html"><![CDATA[<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在<memory>头文件，并位于 std 命名空间中。通常我们可以认为std::unique_ptr和原始指针有一样的尺寸，并且对于多数操作（包括解引用），它和原始指针有几乎相同的CPU指令。这意味着你可以在内存和CPU紧张的地方使用它，如果普通的原始指针对你够快够用的话，那么std::unique_ptr几乎也是够用的。因此，要想使用unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</memory></T></p><pre><code>#include &lt;memory&gt;using namespace std;</code></pre><p>unique_ptr是一个只移型别，</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>通过以下  2 种方式，可以创建出空的 unique_ptr 指针：</p><pre><code>std::unique_ptr&lt;int&gt; p1();std::unique_ptr&lt;int&gt; p2(nullptr);</code></pre><p>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</p><pre><code>std::unique_ptr&lt;int&gt; p3(new int);</code></pre><p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</T></p><p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 std::move 来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><p>unique_ptr 独占智能指针类也有一个 reset 方法，函数原型如下：</p><pre><code>void reset( pointer ptr = pointer() ) noexcept;</code></pre><p>使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p><pre><code>int main()&#123;    unique_ptr&lt;int&gt; ptr1(new int(10));    unique_ptr&lt;int&gt; ptr2 = move(ptr1);    ptr1.reset();    ptr2.reset(new int(250));    return 0;&#125;</code></pre><p>ptr1.reset(); 解除对原始内存的管理<br>ptr2.reset(new int(250)); 重新指定智能指针管理的原始内存</p><p>如果想要获取独占智能指针管理的原始地址，可以调用 get () 方法，<br>函数原型如下：</p><pre><code>pointer get() const noexcept;</code></pre><p>函数用法示例</p><pre><code>int main()&#123;    unique_ptr&lt;int&gt; ptr1(new int(10));    unique_ptr&lt;int&gt; ptr2 = move(ptr1);    ptr2.reset(new int(250));    cout &lt;&lt; *ptr2.get() &lt;&lt; endl;    // 得到内存地址中存储的实际数值 250    return 0;&#125;</code></pre><h2 id="unique-ptr的实现"><a href="#unique-ptr的实现" class="headerlink" title="unique_ptr的实现"></a>unique_ptr的实现</h2><pre><code>template&lt;typename T&gt;struct AutoPtr4&#123;    AutoPtr4(T* ptr = nullptr)        : ptr(ptr)    &#123;    &#125;    ~AutoPtr4()    &#123;        if(this-&gt;ptr != nullptr)        &#123;            delete this-&gt;ptr;            this-&gt;ptr = nullptr;        &#125;    &#125;    AutoPtr4(const AutoPtr4&amp; ptr4) = delete; // disable copying    AutoPtr4(AutoPtr4&amp;&amp; ptr4) noexcept // move constructor        : ptr(ptr4)    &#123;        ptr4.ptr = nullptr;    &#125;    AutoPtr4&amp; operator=(const AutoPtr4&amp; ptr4) = delete; // disable copy assignment    AutoPtr4&amp; operator=(AutoPtr4&amp;&amp; ptr4) noexcept // move assignment    &#123;        if(this == &amp;ptr4)        &#123;            return *this;        &#125;        delete this-&gt;ptr;        this-&gt;ptr = ptr4.ptr;        ptr4.ptr = nullptr;        return *this;    &#125;    T&amp; operator*() const    &#123;        return *this-&gt;ptr;    &#125;    T* operator-&gt;() const    &#123;        return this-&gt;ptr;    &#125;    bool isNull() const    &#123;        return this-&gt;ptr == nullptr;    &#125;private:    T* ptr;&#125;;从中可以看到，unique_ptr禁用了拷贝构造和拷贝赋值构造，仅仅实现了移动构造和移动赋值构造，这也就使得它是独占式的。</code></pre><p>从中可以看到，unique_ptr禁用了拷贝构造和拷贝赋值构造，仅仅实现了移动构造和移动赋值构造，这也就使得它是独占式的。</p><h2 id="unique-ptr的基本使用"><a href="#unique-ptr的基本使用" class="headerlink" title="unique_ptr的基本使用"></a>unique_ptr的基本使用</h2><p>下面是一个unique_ptr的例子,此处的res是在栈上的局部变量，在main()结束时会被销毁，它管理的资源也会被释放掉。</p><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt; // for std::unique_ptrstruct Resource&#123;    Resource() &#123; std::cout &lt;&lt; &quot;Resource acquired\n&quot;; &#125;    ~Resource() &#123; std::cout &lt;&lt; &quot;Resource destroyed\n&quot;; &#125;&#125;;int main()&#123;    // allocate a Resource object and have it owned by std::unique_ptr    std::unique_ptr&lt;Resource&gt; res&#123; new Resource() &#125;;    return 0;&#125; // the allocated Resource is destroyed here</code></pre><p>std::unique_ptr实现的是专属所有权语义，其只支持移动，不支持复制，也不能将一个裸指针直接赋值给std::unique_ptr对象，编译器禁止这种隐式转换。默认的std::unique_ptr的析构函数将调用delete完成指针删除操作，当然，如果默认的析构函数不满足要求，我们也可以自定义析构函数，代码实现及运行结果如下：</p><pre><code>class MyTest &#123;public:    //自定义类构造函数    MyTest() &#123;        cout &lt;&lt; &quot;MyTest&quot; &lt;&lt; endl;    &#125;;    //自定义类析构函数    ~MyTest() &#123;        cout &lt;&lt; &quot;~MyTest&quot; &lt;&lt; endl;    &#125;;&#125;;int main()&#123;    &#123;        //std::unique_ptr的自定义析构函数，t可以为MyTest类型及其子类        auto MyDelete = [](MyTest* t) &#123;            cout &lt;&lt; &quot;MyDelete&quot; &lt;&lt; endl;            delete t;        &#125;;        //智能指针初始化        std::unique_ptr&lt;MyTest,decltype(MyDelete)&gt; p(new MyTest, MyDelete);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建器模式</title>
      <link href="/p/39856.html"/>
      <url>/p/39856.html</url>
      
        <content type="html"><![CDATA[<h1 id="构建器模式"><a href="#构建器模式" class="headerlink" title="构建器模式"></a>构建器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造者(构建器)–Builder模式, 是将一个复杂对象的构建与表示相分离,是的同样的构建过程可以有不同的创建表示.<br>将一个复杂的对象分解了多个简单的对象, 然后一步步的构建成.达到了将变与不变相分离, 即组成部分是不变的, 但是是每一部分又可以达到灵活选择.<br>Builder模式隐藏了复杂对象的创建过程, 将复杂对象在创建过程加以抽象, 通过子类基础或重载的方式,动态创建具有符合属性的对象.</p><h2 id="Builder优缺点"><a href="#Builder优缺点" class="headerlink" title="Builder优缺点"></a>Builder优缺点</h2><p><strong>优点</strong></p><ul><li>各个具体的构建器都是相互独立的, 利于系统的扩展</li><li>客户端不必知道具体产品内部的实现</li></ul><p><strong>缺点</strong></p><ul><li>产品组成部分必须要相同, 限制了使用范围</li><li>假如产品内部变化复杂, 会增加更多的建造者类</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>隔离复杂对象的创建和使用，同样的方法不同的执行顺序，从而产生不同事件的结果</li><li>初始化对象时，参数很多或者很多参数都具有默认值</li><li>不适合创建差异化很大的产品类，如果产品内部变化负责时，会导致定义很多建造者来实现变化，增加类的数量，增加了运行成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎</title>
      <link href="/p/62812.html"/>
      <url>/p/62812.html</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:<br><img src="/p/62812.htm/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>行，InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：</p><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/p/62812.htm/InnoDB%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 </p><p><img src="/p/62812.htm/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg"></p><p>接下来介绍一下这四个部分。<br><strong>Buffer Pool</strong></p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。<br>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul><p>在专用服务器上，通常将多达 80 ％的物理内存分配给缓冲池 。<br>参数设置：     </p><pre><code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></pre><p>**Change Buffer **</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：<br><img src="/p/62812.htm/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p><strong>Adaptive Hash Index</strong></p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<br>自适应哈希索引，无需人工干预，是系统根据情况自动完成。<br>参数： <code>adaptive_hash_index</code></p><p><strong>Log Buffer</strong></p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数:</p><pre><code>innodb_log_buffer_size：查看缓冲区大小innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：    0: 每秒将日志写入并刷新到磁盘一次。    1: 日志在每次事务提交时写入并刷新到磁盘，默认值1s。    2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</code></pre><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：<br><img src="/p/62812.htm/image"></p><p><strong>System Tablespace</strong></p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等，8.0后主要存储更改缓冲区的数据)</p><p>参数：<code>innodb_data_file_path</code></p><p>系统表空间，默认的文件名叫 <code>ibdata1</code></p><p><strong>File-Per-Table Tablespaces</strong></p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p><p><strong>General Tablespaces</strong></p><p>通用表空间，需要通过<code>CREATE TABLESPACE</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name;</code></pre><p><strong>Undo Tablespaces</strong></p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（undo_001,undo_002,初始大小16M），用于存储undo log日志。</p><p><strong>Temporary Tablespaces</strong></p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p><strong>Doublewrite Buffer Files</strong></p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><strong>Redo Log</strong></p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：</p><pre><code>ib_logfile0ib_logfile1</code></pre><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><h4 id="线程类型-默认个数-职责"><a href="#线程类型-默认个数-职责" class="headerlink" title="线程类型 默认个数 职责"></a>线程类型 默认个数 职责</h4><p>在InnoDB的后台线程中，分为 4 类，分别是：Master Thread 、IO Thread、Purge Thread、<br>Page Cleaner Thread。</p><p><strong>Master Thread</strong></p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p><strong>IO Thread</strong></p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。<br>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p><pre><code>Read thread 负责读操作Write thread 负责写操作Log thread 负责将日志缓冲区刷新到磁盘Insert buffer thread 负责将写缓冲区内容刷新到磁盘</code></pre><p><strong>Purge Thread</strong></p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><p><strong>Page Cleaner Thread</strong></p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h3><p><strong>事务</strong></p><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>特性</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p>而对于这四大特性，实际上分为两个部分。 </p><ul><li>其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 </li><li>而持久性是通过数据库的锁，加上MVCC来保证的。</li></ul><p>我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：</p><ul><li>重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo logfile）</li></ul><p>前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中<br>的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却<br>没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</p><p><img src="/p/62812.htm/redolog.jpg"></p><p>有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo  log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment<br>回滚段中，内部包含 1024 个undo log segment。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>当前读</strong></p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select …for update、update、insert、delete(排他锁)都是一种当前读。</p><p>?测试：</p><h4 id="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"><a href="#在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内" class="headerlink" title="在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内"></a>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内</h4><p>容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们<br>加排他锁的时候，也是当前读操作。</p><h4 id="2-快照读"><a href="#2-快照读" class="headerlink" title="2). 快照读"></a>2). 快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，<br>不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h4><h4 id="隐藏字段-含义"><a href="#隐藏字段-含义" class="headerlink" title="隐藏字段 含义"></a>隐藏字段 含义</h4><h4 id="DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"><a href="#DB-TRX-ID-最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。" class="headerlink" title="DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。"></a>DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</h4><h4 id="DB-ROLL-PTR"><a href="#DB-ROLL-PTR" class="headerlink" title="DB_ROLL_PTR"></a>DB_ROLL_PTR</h4><p>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版<br>本。<br>DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。<br>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照<br>读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同<br>的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h4 id="3-MVCC"><a href="#3-MVCC" class="headerlink" title="3). MVCC"></a>3). MVCC</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，<br>使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需<br>要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从<br>而来介绍一下MVCC的原理。</p><h3 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h3><h4 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h4><h4 id="当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。-实际上除了"><a href="#当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。-实际上除了" class="headerlink" title="当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了"></a>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了</h4><p>这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><h4 id="而上述的前两个字段是肯定会添加的，-是否添加最后一个字段DB-ROW-ID，得看当前表有没有主键，"><a href="#而上述的前两个字段是肯定会添加的，-是否添加最后一个字段DB-ROW-ID，得看当前表有没有主键，" class="headerlink" title="而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，"></a>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，</h4><h4 id="如果有主键，则不会添加该隐藏字段。"><a href="#如果有主键，则不会添加该隐藏字段。" class="headerlink" title="如果有主键，则不会添加该隐藏字段。"></a>如果有主键，则不会添加该隐藏字段。</h4><h4 id="6-4-2-2-测试"><a href="#6-4-2-2-测试" class="headerlink" title="6.4.2.2 测试"></a>6.4.2.2 测试</h4><p>1). 查看有主键的表 stu</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令:</p><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID<br>隐藏字段。</p><p>1 ibd2sdi stu.ibd</p><p>2). 查看没有主键的表 employee</p><p>建表语句：</p><h4 id="此时，我们再通过以下指令来查看表结构及其其中的字段信息："><a href="#此时，我们再通过以下指令来查看表结构及其其中的字段信息：" class="headerlink" title="此时，我们再通过以下指令来查看表结构及其其中的字段信息："></a>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</h4><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br>额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有<br>指定主键的。</p><p>1 create table employee (id int , name varchar( 10 ));<br>1 ibd2sdi employee.ibd</p><h3 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h3><h4 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即<br>被删除。</p><h4 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h4><h4 id="有一张表原始数据为："><a href="#有一张表原始数据为：" class="headerlink" title="有一张表原始数据为："></a>有一张表原始数据为：</h4><h4 id="DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"><a href="#DB-TRX-ID-代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是" class="headerlink" title="DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是"></a>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是</h4><h4 id="自增的。"><a href="#自增的。" class="headerlink" title="自增的。"></a>自增的。</h4><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><h4 id="然后，有四个并发事务同时在访问这张表。"><a href="#然后，有四个并发事务同时在访问这张表。" class="headerlink" title="然后，有四个并发事务同时在访问这张表。"></a>然后，有四个并发事务同时在访问这张表。</h4><h4 id="A-第一步"><a href="#A-第一步" class="headerlink" title="A. 第一步"></a>A. 第一步</h4><p>当事务 2 执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="B-第二步"><a href="#B-第二步" class="headerlink" title="B.第二步"></a>B.第二步</h4><p>当事务 3 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><h4 id="C-第三步"><a href="#C-第三步" class="headerlink" title="C. 第三步"></a>C. 第三步</h4><p>当事务 4 执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br>录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条<br>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h3 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h3><h4 id="字段-含义"><a href="#字段-含义" class="headerlink" title="字段 含义"></a>字段 含义</h4><p>m_ids 当前活跃的事务ID集合<br>min_trx_id 最小活跃事务ID<br>max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）<br>creator_trx_id ReadView创建者的事务ID</p><h4 id="条件-是否可以访问-说明"><a href="#条件-是否可以访问-说明" class="headerlink" title="条件 是否可以访问 说明"></a>条件 是否可以访问 说明</h4><p>trx_id &#x3D;&#x3D;<br>creator_trx_id 可以访问该版本</p><h4 id="成立，说明数据是当前这个事"><a href="#成立，说明数据是当前这个事" class="headerlink" title="成立，说明数据是当前这个事"></a>成立，说明数据是当前这个事</h4><h4 id="务更改的。"><a href="#务更改的。" class="headerlink" title="务更改的。"></a>务更改的。</h4><p>trx_id &lt; min_trx_id 可以访问该版本 成立，说明数据已经提交了。<br>trx_id &gt; max_trx_id 不可以访问该版本 成立，说明该事务是在<br>ReadView生成后才开启。<br>min_trx_id &lt;&#x3D; trx_id<br>&lt;&#x3D; max_trx_id<br>如果trx_id不在m_ids中，<br>是可以访问该版本的 成立，说明数据已经提交。<br>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务<br>（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><p>不同的隔离级别，生成ReadView的时机不同：</p><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。<br>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p><h3 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h3><h4 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h4><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p><h4 id="我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的"><a href="#我们就来分析事务-5-中，两次快照读读取数据，是如何获取数据的" class="headerlink" title="我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?"></a>我们就来分析事务 5 中，两次快照读读取数据，是如何获取数据的?</h4><p>在事务 5 中，查询了两次id为 30 的记录，由于隔离级别为Read Committed，所以每一次进行快照读<br>都会生成一个ReadView，那么两次生成的ReadView如下。</p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，<br>到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><h4 id="A-先来看第一次快照读具体的读取过程："><a href="#A-先来看第一次快照读具体的读取过程：" class="headerlink" title="A. 先来看第一次快照读具体的读取过程："></a>A. 先来看第一次快照读具体的读取过程：</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的"><a href="#先匹配-这条记录，这条记录对应的" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也<br>不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p><h4 id="再匹配第三条-，这条记"><a href="#再匹配第三条-，这条记" class="headerlink" title="再匹配第三条 ，这条记"></a>再匹配第三条 ，这条记</h4><p>录对应的trx_id为 2 ，也就是将 2 带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照<br>读，返回的数据就是版本链中记录的这条数据。</p><h4 id="B-再来看第二次快照读具体的读取过程"><a href="#B-再来看第二次快照读具体的读取过程" class="headerlink" title="B. 再来看第二次快照读具体的读取过程:"></a>B. 再来看第二次快照读具体的读取过程:</h4><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><h4 id="先匹配-这条记录，这条记录对应的-1"><a href="#先匹配-这条记录，这条记录对应的-1" class="headerlink" title="先匹配 这条记录，这条记录对应的"></a>先匹配 这条记录，这条记录对应的</h4><p>trx_id为 4 ，也就是将 4 带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，<br>都不满足，则继续匹配undo log版本链的下一条。<br>再匹配第二条 ，这条<br>记录对应的trx_id为 3 ，也就是将 3 带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次<br>快照读，返回的数据就是版本链中记录的这条数据。</p><h4 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可<br>重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该<br>ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返<br>回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。<br>而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/p/21631.html"/>
      <url>/p/21631.html</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</code></pre><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br>为什么全库逻辑备份，就需要加全就锁呢？</p><p><strong>A.  我们一起先来分析一下不加全局锁，可能存在的问题。</strong></p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表。</p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。业务中执行插入订单日志操作。</li><li>最后，又备份了tb_orderlog表。</li><li>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</li></ul><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p><strong>B.  再来分析一下加了全局锁后的情况</strong></p><p> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>数据备份</p><pre><code>mysqldump -uroot –p1234 itcast &gt; itcast.sql</code></pre><p>释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。</li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</code></pre><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li>加锁：lock tables 表名... read&#x2F;write。</li><li>释放锁：unlock tables &#x2F; 客户端断开连接 。<br>特点:</li></ul><p>A.  读锁</p><p><img src="/p/21631.htm/%E8%AF%BB%E9%94%81.png"></p><p>B.  写锁<br><img src="/p/21631.htm/%E5%86%99%E9%94%81.png"></p><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。<br>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong><br>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。<br>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)。<br>常见的SQL操作时，所添加的元数据锁：</p><p><img src="/p/21631.htm/%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81.png"></p><p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ &#x2F; SHARED_WRITE），之间是兼容的。</p><p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><pre><code>select object_type,object_schema,object_name,lock_type,lock_duration fromperformance_schema.metadata_locks ;</code></pre><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。<br>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><ul><li>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</li><li>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</li></ul><p>有了意向锁之后 :</p><ul><li>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</li><li>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p><strong>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</strong><br>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><p>A.  意向共享锁与表读锁是兼容的<br>B.  意向排他锁与表读锁、写锁都是互斥的</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在</p><p>InnoDB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3></li></ul><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>两种行锁的兼容情况如下:<br><img src="/p/21631.htm/%E8%A1%8C%E9%94%81%E5%85%BC%E5%AE%B9%E6%83%85%E5%86%B5.png"></p><h4 id="常见的SQL语句，在执行时，所加的行锁如下："><a href="#常见的SQL语句，在执行时，所加的行锁如下：" class="headerlink" title="常见的SQL语句，在执行时，所加的行锁如下："></a>常见的SQL语句，在执行时，所加的行锁如下：</h4><p><img src="/p/21631.htm/%E6%B7%BB%E5%8A%A0%E8%A1%8C%E9%94%81%E7%B1%BB%E5%9E%8B.png"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></pre><h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><p>A. 普通的select语句，执行时，不会加锁。<br>B. select…lock in share mode，加共享锁</p><ul><li>共享锁与共享锁之间兼容。</li><li>共享锁与排他锁之间互斥。</li><li>排它锁与排他锁之间互斥。</li><li>无索引行锁升级为表锁。</li></ul><p>stu表中数据如下:</p><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><strong>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</strong></p><p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。<br>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p><p>分析一下：</p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为 18 的数据，并加上共享锁，我们是只锁定 18 这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个 18 的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值。此时会对 18 加临键锁，并对间隙加锁。</p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：</p><p>[19]</p><p>(19,25]</p><p>(25,+∞]</p><p>所以数据库数据在加锁是，就是将 19 加了行锁， 25 的临键锁（包含 25 及 25 之前的间隙），正无穷的临<br>键锁(正无穷及之前的间隙)。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/p/3892.html"/>
      <url>/p/3892.html</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>在软件组件设计中如果责任划分不清淅，使用继承得到的结果往往随着需求的变化子类急剧膨胀，同时充斥着重复代码，这时候需要划清责任。<br>装饰者模式动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。</p><h2 id="装饰者模式原则"><a href="#装饰者模式原则" class="headerlink" title="装饰者模式原则"></a>装饰者模式原则</h2><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实质编程</li><li>为交互对象的松耦合设计而努力</li><li>对扩展开放，对修改关闭</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥模式</title>
      <link href="/p/27560.html"/>
      <url>/p/27560.html</url>
      
        <content type="html"><![CDATA[<h1 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>桥接模式是─种非常实用的对象结构型设计模式<br>当系统中某个类存在两个独立变化的维护.则可以通过桥接模式将这个维度分离出来,使两者可以独立扩展<br>桥接模式是一种巧妙的方式处理多层继承存在的问题用抽象关联取代了传统的多层继承将类之间的静态继承关系转换为动态的对象组合关系使得系统更加灵活并且易于扩展，同时有效控制了系统中类的个数，将抽象部分和它的实现部分分离，使它们都可以独立的变化。简单粗暴的说，就是抽象对外提供调用的接口；对外隐瞒实现部分，在抽象中引用实现部分，从而实现抽象对实现部分的调用，而抽象中引用的实现部分可以在今后的开发过程中，切换成别的实现部分。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>未使用桥模式：</p><pre><code>/*** 未使用桥模式* 缺点：类的数量暴增*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~Messager()&#123;&#125;&#125;;// 平台实现class PCMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerBase : public Messager&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class PCMessagerPerfect : public PCMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        PCMessagerBase::PlaySound();        //******        PCMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        PCMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerLite : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;class MobileMessagerPerfect : public MobileMessagerBase&#123;public:    virtual void Login(string username, string password)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        MobileMessagerBase::PlaySound();        //******        MobileMessagerBase::WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        MobileMessagerBase::DrawShape();        //......    &#125;&#125;;void onProcess&#123;    Messager* meg = new MobileMessaferPerfect();    //编译时装配&#125;</code></pre><p>上述实例代码针对Messager基类有两个维度的变化，PC和Message，精简和完整版。此时需要将它们分离开来，充分利用组合的方式。将继承变成组合进行解耦重构。</p><pre><code>/*** 使用桥模式*/class Messager&#123;public:    virtual void Login(string username, string password) = 0;    virtual void SendMessage(string message) = 0;    virtual void SendPicture(Image img) = 0;        virtual ~Messager()&#123;&#125;&#125;;class MessagerImp&#123;public:    virtual void PlaySound() = 0;    virtual void DrawShape() = 0;    virtual void WriteText() = 0;    virtual void Connect() = 0;        virtual ~MessagerImp()&#123;&#125;&#125;;// 平台实现class PCMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;class MobileMessagerImp : public MessagerImp&#123;public:    virtual void PlaySound() &#123; //*** &#125;    virtual void DrawShape() &#123; //*** &#125;    virtual void WriteText() &#123; //*** &#125;    virtual void Connect() &#123; //*** &#125;&#125;;// 业务抽象class PCMessagerLite : public Messager&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerLite : public Messager&#123;    MessagerImp *messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;class MessagerPerfect&#123;    MessagerImp* messagerImp;public:    virtual void Login(string username, string password)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;Connect();        //......    &#125;    virtual void SendMessage(string message)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;WriteText();        //......    &#125;    virtual void SendPicture(Image img)&#123;        messagerImp-&gt;PlaySound();        //******        messagerImp-&gt;DrawShape();        //......    &#125;&#125;;void onProgress()&#123;    //运行时装配    MessagerImp* mImp = new MessagerImp();    Messager *m = new Messager();&#125;</code></pre><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>1). Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。<br>2). Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。<br>3). Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于的变化维度，这时可以使用Bridge的扩展模式。</p><p><strong>优缺点</strong></p><ul><li>优点<ul><li>分离抽象接口及其实现部分</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了”单一职责原则(SRP)”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了类的个数</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合”开闭原则(OCP)”.</li></ul></li><li>缺点<ul><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就就要针对抽象层进行设计与编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累</li></ul></li></ul><p><strong>使用场景</strong><br>    如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超过一半的数字</title>
      <link href="/p/61876.html"/>
      <url>/p/61876.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中数字出现的个数</title>
      <link href="/p/34639.html"/>
      <url>/p/34639.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组中数字出现的个数"><a href="#数组中数字出现的个数" class="headerlink" title="数组中数字出现的个数"></a>数组中数字出现的个数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>输入：</p><pre><code>1 2 3 4 4 2</code></pre><p>输出：</p><pre><code>1 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code>这里只想到了如何快速获得一个只出现一次的数字，没有想到分组异或相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ret = 0;        for (int n : nums)            ret ^= n;        int div = 1;        while ((div &amp; ret) == 0)            div &lt;&lt;= 1;        int a = 0, b = 0;        for (int n : nums)            if (div &amp; n)                a ^= n;            else                b ^= n;        return vector&lt;int&gt;&#123;a, b&#125;;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触发器</title>
      <link href="/p/40758.html"/>
      <url>/p/40758.html</url>
      
        <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触 发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。<br>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><h4 id="触发器类型-NEW-和-OLD"><a href="#触发器类型-NEW-和-OLD" class="headerlink" title="触发器类型 NEW 和 OLD"></a>触发器类型 NEW 和 OLD</h4><ul><li>INSERT 型触发器   NEW   表示将要或者已经新增的数据</li><li>UPDATE 型触发器   OLD   表示修改之前的数据 , NEW 表示将要或已经修改后的数据</li><li>DELETE 型触发器   OLD   表示将要或者已经删除的数据</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建</p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGIN    trigger_stmt ;END;</code></pre><p>查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>删除</p><pre><code>DROP TRIGGER [schema_name]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ;<br>创建表结构：</p><pre><code>create table user_logs(    id int( 11 ) not null auto_increment,    operation varchar( 20 ) not null comment &#39;操作类型, insert/update/delete&#39;,    operate_time datetime not null comment &#39;操作时间&#39;,    operate_id int( 11 ) not null comment &#39;操作的ID&#39;,    operate_params varchar( 500 ) comment &#39;操作参数&#39;,    primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>定义插入触发器：</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params)     VALUES(        null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:        id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,        profession=&#39;, NEW.profession)    );end;</code></pre><p>定义更新触发器：</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params)     VALUES(        null, &#39;update&#39;, now(), new.id,        concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession)    );end; </code></pre><p>定义删除触发器：</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegin    insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES    (null, &#39;delete&#39;, now(), old.id,    concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储过程</title>
      <link href="/p/64451.html"/>
      <url>/p/64451.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li><p>封装，复用                  ————-&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p></li><li><p>可以接收参数，也可以返回数据  ————-&gt; 在存储过程中，可以传递参数，也可以接收返回</p></li><li><p>减少网络交互，效率提升       ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol><li><p>创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN    -- SQL语句END ;</code></pre></li><li><p>调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre></li><li><p>查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre></li><li><p>删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre></li></ol><p>命令行中分号会导致错误，需要用delimiter设置结束语句</p><pre><code>delimiter $$</code></pre><p>现在结束语句以$$结束</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p></blockquote><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><blockquote><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p></blockquote><ol><li><p>查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre></li></ol><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION，会话变量。<br>全局变量(GLOBAL): 全局变量针对于所有的会话。<br>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><ol start="2"><li><p>设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre></li></ol><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p><h4 id="演示示例"><a href="#演示示例" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1 ;insert into course(id, name) VALUES ( 6 , &#39;ES&#39;);set global autocommit = 0 ;select @@global.autocommit;</code></pre><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><blockquote><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 &quot;@变量名&quot; 使用就可以。其作用域为当前连接。会话一建立的连接会话二无法使用。</p></blockquote><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ol><li><p>方式一:</p><pre><code> 赋值时，可以使用 = ，也可以使用 := 推荐：= SELECT @var_name := expr [, @var_name := expr] ... ; SELECT 字段名 INTO @var_name FROM 表名;</code></pre></li><li><p>方式二:</p><pre><code> SET @var_name = expr [, @var_name = expr] ... ; SET @var_name := expr [, @var_name := expr] ... ;</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>SELECT @var_name ;</code></pre><h4 id="演示示例-1"><a href="#演示示例-1" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>-- 赋值set @myname = &#39;itcast&#39;;set @myage := 10 ;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><p><strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。</p></blockquote><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><pre><code>select @abc;DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><h4 id="演示示例-2"><a href="#演示示例-2" class="headerlink" title="演示示例:"></a>演示示例:</h4><pre><code>create procedure p2()begin    declare stu_count int default 0 ;    select count(*) into stu_count from student;    select stu_count;end;call p2();</code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>if 用于做条件判断，具体的语法结构为：</p><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p3()begin    declare score int default 58 ;    declare result varchar( 10 );    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;    select result;end;call p3();</code></pre><blockquote><p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。<br>那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？ 答案是肯定的，我们可以通过接下来所讲解的 参数 来解决上述的问题。</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><ul><li>IN 该类参数作为输入，也就是需要调用时传入值</li><li>OUT 该类参数作为输出，也就是该参数可以作为返回值</li><li>INOUT 既可以作为输入参数，也可以作为输出参数</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>根据传入参数score，判定当前分数对应的分数等级，并返回。</p><ul><li>score &gt;&#x3D; 85分，等级为优秀。</li><li>score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><p>代码如下：</p><pre><code>create procedure p4(in score int, out result varchar( 10 ))begin    if score &gt;= 85 then        set result := &#39;优秀&#39;;    elseif score &gt;= 60 then        set result := &#39;及格&#39;;    else        set result := &#39;不及格&#39;;    end if;end;</code></pre><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回 。</p><pre><code>create procedure p5(inout score double)begin    set score := score * 0.5;end;</code></pre><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式： </p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>语法1</strong>：</p><pre><code>CASE case_value    WHEN when_value1 THEN statement_list1    [ WHEN when_value2 THEN statement_list2] ...    [ ELSE statement_list ]END CASE;</code></pre><p>– 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，<br>执行statement_list2， 否则就执行 statement_list</p><p><strong>语法2</strong>：</p><pre><code>CASE    WHEN search_condition1 THEN statement_list1    [WHEN search_condition2 THEN statement_list2] ...    [ELSE statement_list]END CASE;</code></pre><p>– 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list</p><blockquote><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p></blockquote><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p><ul><li>1-3月份，为第一季度</li><li>4-6月份，为第二季度</li><li>7-9月份，为第三季度</li><li>10-12月份，为第四季度</li></ul><p>代码如下：</p><pre><code>create procedure p6(in month int)begin    declare result varchar( 10 );    case        when month &gt;= 1 and month &lt;= 3 then            set result := &#39;第一季度&#39;;        when month &gt;= 4 and month &lt;= 6 then            set result := &#39;第二季度&#39;;        when month &gt;= 7 and month &lt;= 9 then            set result := &#39;第三季度&#39;;        when month &gt;= 10 and month &lt;= 12 then            set result := &#39;第四季度&#39;;        else            set result := &#39;非法参数&#39;;    end case ;    select concat(&#39;您输入的月份为: &#39;,month, &#39;, 所属的季度为: &#39;,result);end;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DO    SQL逻辑...END WHILE;</code></pre><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p>计算从1累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p7(in n int)begin    declare total int default 0 ;    while n&gt; 0 do         set total := total + n;        set n := n - 1 ;    end while;    select total;end;</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEAT    SQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2). 案例"></a>2). 案例</h4><p>计算从 1 累加到n的值，n为传入的参数值。(使用repeat实现)</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</p><pre><code>create procedure p8(in n int)begin    declare total int default 0 ;    repeat        set total := total + n;        set n := n - 1 ;        until n &lt;= 0    end repeat;    select total;end;</code></pre><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p><pre><code>[begin_label:] LOOP    SQL逻辑...END LOOP [end_label];</code></pre><ul><li>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</li><li>LEAVE ：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>计算从 1 累加到n的值，n为传入的参数值。</p><p>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx</p><pre><code>create procedure p9(in n int)begin    declare total int default 0 ;    sum:loop    if n&lt;= 0 then        leave sum;    end if;        set total := total + n;        set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h5 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h5><p>计算从 1 到n之间的偶数累加的值，n为传入的参数值。<br>– A. 定义局部变量, 记录累加之后的值;<br>– B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 —-&gt; leave xx<br>– C. 如果当次累加的数据是奇数, 则直接进入下一次循环. ——–&gt; iterate xx</p><pre><code>create procedure p10(in n int)begin    declare total int default 0 ;    sum:loop        if n&lt;= 0 then            leave sum;        end if;        if n% 2 = 1 then            set n := n - 1 ;            iterate sum;        end if;            set total := total + n;            set n := n - 1 ;    end loop sum;    select total;end;</code></pre><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A.  声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B.  打开游标</p><pre><code>OPEN 游标名称 ;</code></pre><p>C.  获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D.  关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>– 逻辑:<br>– A. 声明游标, 存储查询结果集<br>– B. 准备: 创建表结构<br>– C. 开启游标<br>– D. 获取游标中的记录<br>– E. 插入数据到新表中<br>– F. 关闭游标</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。<br>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。</p><h2 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><pre><code>ECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action    CONTINUE: 继续执行当前程序    EXIT: 终止执行当前程序condition_value    SQLSTATE sqlstate_value: 状态码，如 02000    SQLWARNING: 所有以 01 开头的SQLSTATE代码的简写    NOT FOUND: 所有以 02 开头的SQLSTATE代码的简写    SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><p>我们继续来完成在上一小节提出的这个需求，并解决其中的问题。<br>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>A.  通过SQLSTATE指定具体的状态码</p><pre><code>create procedure p11(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02000 时，将关闭游标u_cursor，并退出    declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>B.  通过SQLSTATE的代码简写方式 NOT FOUND 02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begin    declare uname varchar( 100 );    declare upro varchar( 100 );    declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;    -- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为 02 开头时，将关闭游标u_cursor，并退出    declare exit handler for not found close u_cursor;    drop table if exists tb_user_pro;    create table if not exists tb_user_pro(        id int primary key auto_increment,        DETERMINISTIC：相同的输入参数总是产生相同的结果        name varchar( 100 ),        profession varchar( 100 )    );    open u_cursor;    while true do        fetch u_cursor into uname,upro;        insert into tb_user_pro values (null, uname, upro);    end while;    close u_cursor;end;</code></pre><p>具体的错误状态码，可以参考官方文档：**<a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a> <a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a>**</p><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN    -- SQL语句    RETURN ...;END ;</code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h3 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h3><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegin    declare total int default 0 ;    while n&gt; 0 do        set total := total + n;        set n := n - 1 ;    end while;    return total;end;</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错：</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图</title>
      <link href="/p/3825.html"/>
      <url>/p/3825.html</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><blockquote><p>特点:</p><p>封装，复用 -----------------------&gt; 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p><p>可以接收参数，也可以返回数据 --------&gt; 再存储过程中，可以传递参数，也可以接收返回值。</p><p>减少网络交互，效率提升 -------------&gt; 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></blockquote><h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol><li>简单</li></ol><blockquote><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p></blockquote><ol start="2"><li>安全</li></ol><blockquote><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p></blockquote><ol start="3"><li>数据独立</li></ol><blockquote><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>创建</li><li>查询</li><li>修改</li><li>删除</li></ul><p>– 创建视图</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>– 查看创建视图语句：</p><pre><code>SHOW CREATE VIEW 视图名称;</code></pre><p>– 查看视图数据：</p><pre><code>SELECT * FROM 视图名称 ...... ;方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>– 删除视图</p><pre><code> DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</code></pre><p>– 创建视图</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 查询视图</p><pre><code>show create view stu_v_1;select * from stu_v_1;select * from stu_v_1 where id &lt; 3 ;</code></pre><p>– 修改视图</p><pre><code>create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10 ;alter view stu_v_1 as select id,name from student where id &lt;= 10 ;</code></pre><p>– 删除视图</p><pre><code>drop view if exists stu_v_1;</code></pre><p>执行下面的SQL，我们会发现，id为 6 和 17 的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id为 17 的记录。</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values( 6 ,&#39;Tom&#39;);insert into stu_v_1 values( 17 ,&#39;Tom22&#39;);</code></pre><p>因为我们在创建视图的时候，指定的条件为 id&lt;&#x3D;10, id为 17 的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。<br>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p><h3 id="CASCADED"><a href="#CASCADED" class="headerlink" title="CASCADED"></a>CASCADED</h3><h4 id="级联。"><a href="#级联。" class="headerlink" title="级联。"></a>级联。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><h3 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h3><h4 id="本地。"><a href="#本地。" class="headerlink" title="本地。"></a>本地。</h4><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><blockquote><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p></blockquote><p>A.  聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p><p>B.  DISTINCT</p><p>C.  GROUP BY</p><p>D.  HAVING</p><p>E.  UNION 或者 UNION ALL</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/p/14565.html"/>
      <url>/p/14565.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_20220922195857226500.png" alt="模板方法模式"><br>个人理解大概就是覆盖和隐藏的应用</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用模板方法前</p><pre><code>//程序库开发人员class Library &#123;public:    void Step1() &#123;        //...    &#125;    void Step3() &#123;        //...    &#125;    void Step5() &#123;        //...    &#125;&#125;;//应用程序开发人员class Application &#123;public:    bool Step2() &#123;        //...    &#125;    void Step4() &#123;        //...    &#125;&#125;;int main()&#123;    Library lib;    Application app;    lib.Step1();    if (app.Step2()) &#123;        lib.Step3();    &#125;    for (int i = 0; i &lt; 4; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre><p>使用模板方法后</p><pre><code>//程序库开发人员class Library &#123;public:    //稳定 template method    void Run() &#123;        Step1();        if (Step2()) &#123; //支持变化 ==&gt; 虚函数的多态调用            Step3();        &#125;        for (int i = 0; i &lt; 4; i++) &#123;            Step4(); //支持变化 ==&gt; 虚函数的多态调用        &#125;        Step5();    &#125;    virtual ~Library() &#123; &#125;protected:    void Step1() &#123; //稳定        //.....    &#125;    void Step3() &#123;//稳定        //.....    &#125;    void Step5() &#123; //稳定        //.....    &#125;    virtual bool Step2() = 0;//变化    virtual void Step4() = 0; //变化&#125;;//应用程序开发人员class Application : public Library &#123;protected:    virtual bool Step2() &#123;        //... 子类重写实现    &#125;    virtual void Step4() &#123;        //... 子类重写实现    &#125;&#125;;int main()&#123;    Library* pLib = new Application();    pLib-&gt;Run();    delete pLib;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/p/39554.html"/>
      <url>/p/39554.html</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本两个不兼容的接口之间的桥梁，可以使接口不兼容导致不能一起工作的那些类可以一起工作。它包括类适配器和对象适配器.<br>在GoF的设计模式中，对适配器模式讲了两种类型，</p><ul><li>类适配器模式</li><li>对象适配器模式</li></ul><p>类适配器采用多继承方式，对象适配器采用对适配者Adaptee接口方式。两种方式都能完成Target接口与Adaptee接口对接。</p><p>类适配器模式通过多重继承对一个接口与另一个接口进行匹配，C#、VB.NET、JAVA等语言都不支持多重继承(C++支持)，也就是一个类只有一个父类</p><p>适配器模式主要应用在以下场景：</p><ul><li>新旧接口兼容软件版本升级，部分旧接口还在被使用。需要保留旧的接口，增加新接口，使两者兼容。</li><li>第三方接口的适配在系统功能稳定的情况下，有第三方新的接口需求需要对接。</li><li>统一多个类相同功能的接口例如统一不同类型数据库的访问接口。</li></ul><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="/p/39554.htm/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Usb device connect phone */class CAdapter : public CUsbDisk&#123;public:    CAdapter()    &#123;        mpAdaptee = new CTypeCInterface();    &#125;    ~CAdapter()    &#123;        if (NULL != mpAdaptee) &#123;            delete mpAdaptee;        &#125;    &#125;    void ConnectDevice()    &#123;        if (NULL != mpAdaptee) &#123;            mpAdaptee-&gt;ConnectDevice();        &#125; else &#123;            cout &lt;&lt; &quot;Adapter abnormal. Connect fail!&quot; &lt;&lt; endl;        &#125;    &#125;private:    CTypeCInterface *mpAdaptee;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p> 比如电源适配的，一般家用电都是220V，但是手机充电只需要5V，此时手机充电器就相当于是一个适配器，将220V转成手机充电需要的5V。</p><p>220V电源：</p><pre><code>public class AC220V &#123;    public int output()&#123;        int output = 220;        System.out.println(&quot;输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>需要的5V电源：</p><pre><code>public interface DC5V &#123;    int output();&#125;</code></pre><p>变压器（也就是充电器）：</p><pre><code>public class Transformer implements DC5V&#123;    //包含了220V的属性    private AC220V ac220V ;    public Transformer(AC220V ac220V) &#123;        this.ac220V = ac220V;    &#125;    @Override    public int output() &#123;        int input = ac220V.output();        //经过相应的逻辑转换成需要的5V        int output = input / 44;        System.out.println(&quot;输入&quot;+input+&quot;v,输出&quot;+output+&quot;v&quot;);        return output;    &#125;&#125;</code></pre><p>测试类：</p><pre><code>DC5V dc5V = new Transformer(new AC220V());dc5V.output();</code></pre><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p><img src="/p/39554.htm/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p><ul><li>Target: 客户端期望接口类</li><li>Adaptee: 实际需要的功能类</li><li>Adapter: 将接口类与功能类衔接的适配器类</li><li>Client: 客户端代码</li></ul><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><pre><code>/* Connect Usb port */class CUsbDisk&#123;public:    virtual ~CUsbDisk() &#123;&#125;    virtual void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect usb port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Connect Type-C port */class CTypeCInterface&#123;public:    virtual ~CTypeCInterface() &#123;&#125;    void ConnectDevice()    &#123;        cout &lt;&lt; &quot;Connect Type-C port.&quot; &lt;&lt; endl;    &#125;&#125;;/* Not only connect Usb port, but also connect Type-C port */class CAdapter : public CUsbDisk, public CTypeCInterface&#123;public:    void ConnectDevice()    &#123;        CTypeCInterface::ConnectDevice();    &#125;&#125;;int main(int argc, char *argv[])&#123;    CUsbDisk *theDisk = new CAdapter();    theDisk-&gt;ConnectDevice();    delete theDisk;    return 0;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对比</strong></p><ul><li>在类适配器中，由于适配器是适配者的子类，所以可以在适配器类中重写一些适配者的方法.使得适配器的灵活性更强</li><li>一个对象适配器可以把多个不同的适配者适配到同一个目标即同一个适配器可以把适配者类和它的子类都适配到目标接口</li></ul><p><strong>使用场景</strong></p><ul><li>系统需要使用现有的类，而此类的接口不符合系统的需要</li><li>需要创建一个可复用的类,该类可以与其他不相关的类或不可预见的类系统工作</li></ul><p><strong>优缺点</strong></p><ul><li>优点——可以让任何两个没有关联的类一起运行，提高了类的复用</li><li>缺点——过度使用适配器，会让系统杂乱无章，不利整体进行把握</li></ul><p>适配器模式主要原理: 在于实现客户接口时，关联上已存在的功能接口。一种使用过多继承方式，一种通过类之间依赖的方式，都能实现。<br>为统一多个功能相同的类接口时，类适配器模式是更适合的。比较典型的例子如，MySql和SQLServer等多种类型数据库的访问接口的统一。<br>《Effective C++》曾告诫程序猿们: C++编程不要轻易使用多继承，除非忍不住！<br>另外，文中也有说过。在软件开发初，无第三方需求接口的情况下，不要考虑此模式的使用。往往适配器模式的使用，会让代码看起来像一个补丁，修修补补。<br>「适配器模式」看起来与「外观模式」相似，都是与外部对接。其实有很大不同: 「外观模式」是定义一套新的接口，而「适配器模式」则是运用已有的接口。「外观模式」是在已有复杂的接口上，再封一层简单的接口，方便客户端使用。「适配器模式」则是结合已有的功能，实现或重载已经存在的客户端接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/p/29711.html"/>
      <url>/p/29711.html</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>用建造者模式描述简单的电脑组装，电脑组装是个复杂的过程，它包括显示器、鼠标、键盘、主机（主机又包括cpu、显卡、主板等）、耳机等等，我们不可能自己去组装电脑，我们是将自己的配置需求告诉老板，老板安排技术人员组装电脑，然后将电脑交给我们。通过组装电脑可以看出建造者模式的特点：都是由各个简单的对象（电脑各个部件）组成，各个部件（各种各样的显卡、各种各样的cpu等）都可以灵活选择，但是创建产品的步骤大同小异（技术人员组装电脑的过程）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>具体电脑类：</p><pre><code>class Computer&#123;public:    Computer() = default;    ~Computer() &#123;&#125;;    void show()    &#123;        cout &lt;&lt; &quot;电脑创建出来了&quot;&lt;&lt;endl;        cout &lt;&lt; &quot;组成部分：&quot; &lt;&lt; endl;        for (auto t = vec.cbegin(); t != vec.cend(); t++)        &#123;            cout &lt;&lt; * t &lt;&lt; endl;        &#125;    &#125;    void setDisplayer(string displayer) &#123;         vec.push_back(displayer);     &#125;    void setMouse(string mouse) &#123; vec.push_back(mouse); &#125;    void setKeyBoard(string keyboard) &#123; vec.push_back( keyboard); &#125;    void setHost(string host) &#123; vec.push_back(host); &#125;private:    vector&lt;string &gt; vec;&#125;;</code></pre><p>抽象建造者类：</p><pre><code>class Builder&#123;public:    Builder() = default;    ~Builder() &#123; delete pCo; &#125;    virtual void buildDisplayer(string display) &#123;&#125;;    virtual void buildMouse(string mouse) &#123;&#125;;    virtual void buildKeyBoard(string keyboard) &#123;&#125;;    virtual void buildHost(string host) &#123;&#125;;    Computer * getResult()    &#123;        return pCo;    &#125;protected:    Computer *pCo = new Computer();&#125;;</code></pre><p>具体建造者类（组装电脑的技术人员）：</p><pre><code>class ConcreteBuilder :public Builder&#123;public:    ConcreteBuilder() = default;    ~ConcreteBuilder() &#123;&#125;;    void buildDisplayer(string display)    &#123;        pCo-&gt;setDisplayer(display);    &#125;    void buildMouse(string mouse)    &#123;        pCo-&gt;setMouse(mouse);    &#125;    void buildKeyBoard(string keyboard)    &#123;        pCo-&gt;setKeyBoard(keyboard);    &#125;    void buildHost(string host)    &#123;        pCo-&gt;setHost(host);    &#125;&#125;;</code></pre><p>指挥者（卖电脑的老板）:</p><pre><code>class Director&#123;public:    Director(Builder *pBu) &#123; pBuilder = pBu; &#125;     ~Director() &#123; delete pBuilder; &#125;;    Computer *Construct(string display,string mouse,string keyboard,string host)    &#123;        pBuilder-&gt;buildDisplayer(display);        pBuilder-&gt;buildMouse(mouse);        pBuilder-&gt;buildKeyBoard(keyboard);        pBuilder-&gt;buildHost(host);        return pBuilder-&gt;getResult();    &#125;private:    Builder *pBuilder;&#125;;</code></pre><p>比如说我们找老板买的电脑配置是三星显示器、牧马人鼠标、机械键盘、联想主机：</p><pre><code>int main()&#123;    Builder *pBu = new ConcreteBuilder();    Director *pDi = new Director(pBu);    Computer *pCo = pDi-&gt;Construct(&quot;三星显示器&quot;,&quot;牧马人鼠标&quot;,&quot;机械键盘&quot;,&quot;联想主机&quot;);    pCo-&gt;show();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="创建者模式和工厂模式的对比"><a href="#创建者模式和工厂模式的对比" class="headerlink" title="创建者模式和工厂模式的对比"></a>创建者模式和工厂模式的对比</h2><p>Factory模式中：</p><ul><li>有一个抽象的工厂</li><li>实现一个具体的工厂 - 汽车工厂</li><li>工厂生产的汽车A，得到汽车产品A</li><li>工厂生产汽车B，得到汽车产品B</li><li>实现了购买者和生产线的隔离，强调的是结果</li></ul><p>Builder模式</p><ul><li>引擎工厂生产引擎产品，得到汽车的部件A</li><li>轮胎工厂生产轮子产品，得到汽车部件B</li><li>底盘工厂生产车身产品，得到汽车部件C</li><li>将这些部件放到一起，形成刚好能够组装成一辆汽车的整体</li><li>这样做，目的是为了实现复杂对象生产线和其部件的解耦。强调的是过程</li></ul><p>两者的区别在于以下几种情况：</p><ul><li><p>工厂模式不考虑对象的组装过程，而直接生成一个我想要的对象。</p></li><li><p>Builder模式先一个个的创建对象的每一个部件，再统一组装成一个对象</p></li><li><p>工厂模式所解决的问题是，工厂生产产品</p></li><li><p>而Builder模式解决的是工厂控制产品 生成器组装各个部件的过程，然后从产品生成器中得到产品。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/p/48003.html"/>
      <url>/p/48003.html</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式也称为委托模式。<br>作用： 找一个对象来替我们访问某个对象。<br>意图:  为其他对象提供一种代理以控制对这个对象的访问。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F_20220922190144062739.png" alt="代理模式"></p><h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><p>代理模式的共同优点如下：</p><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li></ol><p>此外，不同类型的代理模式也具有独特的优点，例如：</p><ol><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li><li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</li><li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>租房子模型</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public:    virtual void rentHouse() = 0;&#125;;class Mike :public Person&#123;public:    void rentHouse()    &#123;        cout &lt;&lt; &quot;mike需要租一间房子！&quot; &lt;&lt; endl;    &#125;&#125;;//代理class Intermediary :public Person&#123;public:    Intermediary(Person* person) :m_Person(person) &#123;&#125;public:    void rentHouse()    &#123;        m_Person-&gt;rentHouse();        cout &lt;&lt; &quot;我是中介，我帮你找房子，但是要抽取10%佣金！&quot; &lt;&lt; endl;    &#125;private:    Person* m_Person;&#125;;//场景int main()&#123;    Person* pMike = new Mike;    //找一个中介帮忙租房子    Person* intermediary = new Intermediary(pMike);    intermediary-&gt;rentHouse();    return 0;&#125;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;// 抽象主题类class Subject &#123;public:    virtual ~Subject() &#123;&#125;    virtual void request() = 0;&#125;;// 真实主题类class RealSubject : public Subject &#123;public:    void request() override &#123;        std::cout &lt;&lt; &quot;RealSubject: Handling request.&quot; &lt;&lt; std::endl;    &#125;&#125;;// 代理类class Proxy : public Subject &#123;public:    Proxy(std::string ip, int port) : m_ip(ip), m_port(port), m_subject(nullptr) &#123;&#125;    ~Proxy() &#123; delete m_subject; &#125;    void request() override &#123;        if (!m_subject) &#123;            connect();        &#125;        m_subject-&gt;request();    &#125;private:    std::string m_ip;    int m_port;    RealSubject* m_subject;    void connect() &#123;        std::cout &lt;&lt; &quot;Proxy: Connecting to &quot; &lt;&lt; m_ip &lt;&lt; &quot;:&quot; &lt;&lt; m_port &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;        // 模拟网络连接过程，实例化远程主题对象        m_subject = new RealSubject();    &#125;&#125;;int main() &#123;    // 客户端通过代理对象访问远程主题    Proxy proxy(&quot;127.0.0.1&quot;, 8080);    proxy.request();    return 0;&#125;</code></pre><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><pre><code>#include &lt;iostream&gt;using namespace std;class RefCount    //用于管理对象指针的次数的类&#123;    public:        RefCount():Count(0)&#123;&#125;    public:        void Add()&#123;Count++;&#125;        int Release()&#123;Count--;return Count;&#125;        void Reset()&#123;Count=0;&#125;private:    int Count;&#125;;template &lt;typename T&gt;class SmartPtr&#123;public:    SmartPtr(T* pData) &#123;           //SmartPtr&lt;A&gt; s1(new A(2));        this-&gt;pData = pData;        pRef = new RefCount();     //创建一个管理指针的count对象        pRef-&gt;Add();            //count对象次数加一    &#125;    SmartPtr(const SmartPtr&lt;T&gt;&amp; sp) &#123;    //SmartPtr&lt;A&gt; s2(s1);  以智能指针为入参构造        pData = sp.pData;        pRef = sp.pRef;        pRef-&gt;Add();    &#125;    ~SmartPtr(void)  &#123;        cout&lt;&lt;&quot; ~SmartPtr&quot;&lt;&lt;endl;        if (pRef!=NULL &amp;&amp; pRef-&gt;Release() == 0) &#123; //count对象存在且代理的数量为0            if (pData) &#123;                    delete     pData;                pData = NULL;            &#125;            if (pRef) &#123;                    delete     pRef;                pRef = NULL;            &#125;        &#125;    &#125;     T* operator-&gt;() &#123;        return pData;    &#125;    T* Get() &#123;                         //get方法返回指针对象        T* ptr = NULL;                ptr = pData;        return ptr;    &#125;private:    RefCount* pRef;    T* pData;&#125;;   //还有很多其它对象没有实现class A &#123;    public:            int i;            A(int n):i(n) &#123; &#125;;        void show() &#123;            cout&lt;&lt;&quot;I`m class A&quot;&lt;&lt;endl;        &#125;            ~A() &#123; cout &lt;&lt;&quot;class A destructed&quot; &lt;&lt; endl; &#125;&#125;;template &lt;typename T&gt;void test(SmartPtr&lt;T&gt;&amp; sp) &#123;    SmartPtr&lt;A&gt; s3(sp);    s3-&gt;show();&#125;int main() &#123;    SmartPtr&lt;A&gt; s1(new A(2));   //A对象指针托管给s1    s1-&gt;show();    SmartPtr&lt;A&gt; s2(s1);    s2-&gt;show();    test(s2);    cout&lt;&lt;&quot;before destructed&quot;&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出结果</p><pre><code>I`m class AI`m class AI`m class A~SmartPtrbefore destructed~SmartPtr~SmartPtrclass A destructed</code></pre><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul><li><p>智能指针：智能指针主要通过代理一个对象的时候，会记录引用的次数，当次数为0时释放对象</p><ul><li>智能指针是代理模式的具体应用</li><li>智能指针使用引用计数实现时，就是最好的使用代理模式的例子。</li></ul></li><li><p>保护代理：在对一个对象访问的时候，添加对不同权限的处理逻辑，这个也是交给代理做的</p></li><li><p>远程代理：为网络上的对象创建一个局部对象，所有网络通讯操作交给代理去做，让客户可以会忽略这些被代理的对象是不是远程的</p></li><li><p>虚拟代理：创建开销大的对象时候，比如显示一幅大的图片，我们将这个创建的过程交给代理去完成</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/p/22548.html"/>
      <url>/p/22548.html</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。<br><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F_20220922185016499798.png" alt="原型模式"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在有一个简历 Resume 类，如果要批量复制简历对象，有哪些方法呢？</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string sex;    std::string age;public:    Resume() &#123;&#125;;    void SetPersonalInfo(const std::string&amp; name, const std::sting&amp; age)    &#123;        this.name = name;        this.age = age;    &#125;&#125;;int main()&#123;    Resume p1;    p1.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);    Resume p2;    p2.SetPersonalInfo(&quot;zhangsan&quot;, &quot;25&quot;);&#125;</code></pre><p>上述实现方式非常简单又容易理解，你需要几份简历，就定义几个简历对象。但是，这里有一个很严重的问题：一旦简历内容需要修改，那么所有的简历对象都需要改动。原型模式正是为了解决它而出现的。</p><p>原型模式</p><p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><pre><code>#include &lt;iostream&gt;class Resume &#123;private:    std::string name;    std::string age;    std::string education;public:    Resume()     &#123;        std::cout &lt;&lt; &quot;Construct !&quot; &lt;&lt; std::endl;    &#125;;    Resume(const Resume&amp; resume)    &#123;        this-&gt;name = resume.name;           this-&gt;age = resume.age;        this-&gt;education = resume.education;        std::cout &lt;&lt; &quot;Copy Construct !&quot; &lt;&lt; std::endl;    &#125;    void SetPersonalInfo(const std::string&amp; name, const std::string&amp; age)    &#123;        this-&gt;name = name;        this-&gt;age = age;    &#125;    void SetEducation(const std::string&amp; educatoin)    &#123;        this-&gt;education = educatoin;    &#125;    void PrintResume()    &#123;        std::cout &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age  &lt;&lt; &quot;, &quot; &lt;&lt; education &lt;&lt; std::endl;    &#125;    Resume* Clone()    &#123;        return new Resume(*this);    &#125;&#125;;int main()&#123;    Resume* p1 = new Resume();    p1-&gt;SetPersonalInfo(&quot;Tom&quot;, &quot;25&quot;);    p1-&gt;SetEducation(&quot;master&quot;);    p1-&gt;PrintResume();    Resume* p2 = p1-&gt;Clone();    p2-&gt;SetPersonalInfo(&quot;Jack&quot;, &quot;28&quot;);    p2-&gt;PrintResume();&#125;</code></pre><p>当我们定义了第一个简历对象 p1 时，如果再需要创建一个对象，直接调用 p1 中的克隆 Clone 方法，然后返回一个新的对象 p2. 如果想要定制化简历 p2 时，只需要在 p2 中修改与 p1 差异的地方就可以了。而 Clone 一定要借助于拷贝构造函数才能实现<br>所以，一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，对性能又是大大的提升。</p><p>有同学可能会说，直接调用拷贝构造函数是不是就可以了，何必在外层封装一层 Clone？实际上，这是有本质区别的。</p><p>原型模式实现的是一个Clone 接口，注意是接口，也就是基于多态的 Clone 虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。在继承场景下，Clone 函数可以定义为虚函数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include &lt;iostream&gt;using namespace std;//接口class Prototype&#123;public :    Prototype()&#123;&#125;    virtual ~Prototype()&#123;&#125;    virtual Prototype * Clone() = 0;&#125;;//实现class ConcretePrototype : public Prototype&#123;public :    ConcretePrototype():m_counter(0)&#123;&#125;    virtual ~ConcretePrototype()&#123;&#125;    //拷贝构造函数    ConcretePrototype( const ConcretePrototype &amp; rhs)    &#123;        m_counter = rhs .m_counter;    &#125;    //复制自身    virtual ConcretePrototype * Clone()    &#123;        //调用拷贝构造函数        return new ConcretePrototype (*this );    &#125;private :    int m_counter;&#125;;int main(int argc , char **argv)&#123;    //生成对像    ConcretePrototype * conProA = new ConcretePrototype ();    //复制自身    ConcretePrototype * conProB = conProA-&gt;Clone();    delete conProA;    conProA= NULL ;    delete conProB;    conProB= NULL ;    return 0;&#125;</code></pre><p>浅复制，被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。但我们可能更需要这样的一种需求，把要复制的对象所引用的对象都复制一遍。我们希望是a、b、c三个引用的对象都是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为‘深复制’，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。clone的时候要注意引用拷贝会发生浅拷贝的现象导致多个指针指向同一个内容。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/p/7738.html"/>
      <url>/p/7738.html</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>当一个对象的状态发生改变的时候，如何让依赖他的所有对象得到通知并进行相应的处理。</p><ul><li>稳定点 一对多的依赖关系（一变化 多跟着变化）</li><li>变化点 <ul><li>‘多’增加</li><li>‘多’减少</li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>丈夫下班的时候会告诉孩子和老婆，老公开车要往回走了</p><ul><li>孩子妈收到消息后开始做饭</li><li>孩子收到消息后，就赶紧收起手机，怕挨揍</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>观察者模式的核心思想是 1对多</p><p>传统写法：</p><pre><code>#include &lt;iostream&gt;class Son&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;爸爸回来了，赶紧去写作业&quot;&lt;&lt;std::endl;    &#125;&#125;;class Wife&#123;public:    void DoSomething()&#123;        std::cout&lt;&lt;&quot;老公回来了，去做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();    &#125;private:    Wife wife;    Son son;&#125;;int main()&#123;    Husband husband;    husband.Gohome();    return 0;&#125;</code></pre><p>这样写的不足如下：</p><p>如果关心丈夫的人变多了，比如老妈、老爸 ，这时候我们不得不去修改Husband的类</p><pre><code>class Husband&#123;public:    void Gohome()&#123;        wife.DoSomething();        son.DoSomething();        mom.DoSomething();        ba.DoSomething();    &#125;private:    Wife wife;    Son son;    Mother mom;    Father ba;&#125;;</code></pre><p>人数少的时候，还可以应付，假如关心我的人有1000人，那这时候我们该怎么办</p><p><strong>开始重构，简单观察者模式，面向抽象编程</strong><br>观察者接口</p><pre><code>class ObserverInterface&#123;public:    virtual void dosomething()=0;    virtual ~ObserverInterface()&#123;&#125;&#125;;</code></pre><p>被观察者接口</p><pre><code>class SubjectInterface&#123;public:    virtual void Add(ObserverInterface* obr)=0;    virtual void Remove(ObserverInterface* obr)=0;    virtual void Notify()=0;    virtual ~SubjectInterface()&#123;&#125;&#125;;</code></pre><p>丈夫</p><pre><code>class Husband:public SubjectInterface&#123;public:    void Add(ObserverInterface* obr) override&#123;        observers.push_back(obr);    &#125;    void Remove(ObserverInterface* obr) override&#123;        auto pos=std::find(observers.begin(),observers.end(),obr);        if(pos!=observers.end())&#123;            observers.erase(pos);        &#125;    &#125;    void Notify() override&#123;        for(const auto&amp; obs:observers)&#123;            obs-&gt;dosomething();        &#125;    &#125;private:    std::vector&lt;ObserverInterface*&gt; observers;&#125;;</code></pre><p>孩子妈</p><pre><code>class Wife:public ObserverInterface&#123;public:    void dosomething() override&#123;        std::cout&lt;&lt;&quot;老公快回来了，开始做饭&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>孩子</p><pre><code>class Son:public  ObserverInterface&#123;public:    void dosomething() override &#123;        std::cout&lt;&lt;&quot;爸爸快回来了，不能玩游戏了&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    Husband husband;    ObserverInterface* wife=new Wife;    ObserverInterface* son=new Son;    husband.Add(wife);    husband.Add(son);    //下班了 发消息    husband.Notify();    delete wife;    delete son;&#125;</code></pre><p>这样的好处是：再增加新的观察者，我们就不用修改Husband的类了，只需要添加到vector中就可以<br>不足是：需要自己做内存管理 delete</p><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><p>使用面向对象的抽象，Observer模式使得我们可以独立的改变目标与观察者，从而使二者之间的依赖关系松耦合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化</title>
      <link href="/p/1692.html"/>
      <url>/p/1692.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><strong>普通插入：</strong></p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p><strong>大批量插入：</strong><br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><p>客户端连接服务端时，加上参数 –local-infile（这一行在bash&#x2F;cmd界面输入）</p><pre><code>mysql --local-infile -u root -p</code></pre><p>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p><pre><code>set global local_infile = 1;select @@local_infile;</code></pre><p>执行load指令将准备好的数据，加载到表结构中</p><pre><code>load data local infile &#39;/root/sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></pre><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，默认为0.5，可以自己设置，在创建表或创建索引时指定</p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">详细内容参照黑马程序员数据库相关讲解</a></p><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号<ul><li>UUID:随机字符串（不重复）</li></ul></li><li>业务操作时，避免对主键的修改</li></ul><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为idx_user_pro_age_stat，则句式可以是select … where profession order by age，这样也符合最左前缀法则</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><p>– 此语句耗时很长</p><pre><code>select * from tb_sku limit 9000000, 10;</code></pre><p>– 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</p><pre><code>select id from tb_sku order by id limit 9000000, 10;</code></pre><p>– 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</p><pre><code>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</code></pre><p>– 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</p><pre><code>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</code></pre><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h2 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h2><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br>update student set no &#x3D; ‘123’ where id &#x3D; 1;，这句由于id有主键索引，所以只会锁这一行；<br>update student set no &#x3D; ‘123’ where name &#x3D; ‘test’;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/p/11557.html"/>
      <url>/p/11557.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助 MySQL 高效获取数据的<strong>有序</strong>的<strong>数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p><strong>分类</strong><br>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。<br>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。<br>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。<br>按「字段个数」分类：单列索引、联合索引。</p><p><strong>✅ 优点</strong></p><ul><li>索引能够提高数据检索的效率，降低数据库的IO成本。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，创建唯一索引</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>加速两个表之间的连接，一般是在外键上创建索引</li></ul><p><strong>❌ 缺点</strong></p><ul><li>需要占用物理空间,建立的索引越多需要的空间越大</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2></li></ul><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。<br>每个结点默认分配16KB大小<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>B+Tree非叶子结点不存储data,只存储索引（冗余），可以在同一节点放更多索引，进而缩小树的高度</li><li>叶子结点使用指针连接（B-tree没有），提高区间访问的性能</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><p>所以建议InnoDB必须建主键，并且推荐使用整形的自增主键。否则Mysql需要帮你维护一个rowid，耗费性能，同时整型比较的效率更高，占用内存更小。自增可以保证节点分裂的次数减少。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><p>select * from user where id &#x3D; 10;<br>select * from user where name &#x3D; ‘Arm’;<br>– 备注：id为主键，name字段创建的有索引</p><pre><code>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</code></pre><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><pre><code>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建索引：</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code></pre><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：</p><pre><code>SHOW INDEX FROM table_name;</code></pre><p>删除索引：</p><pre><code>DROP INDEX index_name ON table_name;</code></pre><p>案例：</p><p>– name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</p><pre><code>create index idx_user_name on tb_user(name);</code></pre><p>– phone手机号字段的值非空，且唯一，为该字段创建唯一索引</p><pre><code>create unique index idx_user_phone on tb_user (phone);</code></pre><p>– 为profession, age, status创建联合索引</p><pre><code>create index idx_user_pro_age_stat on tb_user(profession, age, status);</code></pre><p>– 为email建立合适的索引来提升查询效率</p><pre><code>create index idx_user_email on tb_user(email);</code></pre><p>– 删除索引</p><pre><code>drop index idx_user_email on tb_user;</code></pre><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p><pre><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code></pre><p>例：</p><pre><code>show global status like &#39;Com_______&#39;</code></pre><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>开启慢查询日志开关</p><pre><code>slow_query_log=1</code></pre><p>设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</p><pre><code>long_query_time=2</code></pre><p>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：</p><pre><code>show variables like &#39;slow_query_log&#39;;</code></pre><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p><pre><code>SELECT @@have_profiling;</code></pre><p>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：</p><pre><code>SET profiling = 1;</code></pre><p>查看所有语句的耗时：</p><pre><code>show profiles;</code></pre><p>查看指定query_id的SQL语句各个阶段的耗时：</p><pre><code>show profile for query query_id;</code></pre><p>查看指定query_id的SQL语句CPU的使用情况</p><pre><code>show profile cpu for query query_id;</code></pre><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><pre><code>直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</code></pre><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><ol><li>在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) &#x3D; ‘15’;这里对phone进行操作了</li><li>字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone &#x3D; 17799990015;，此处phone的值没有加引号进行了隐式类型转换。</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like ‘%工程’;，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>不使用哪个索引：</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>必须使用哪个索引：</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></pre><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h3 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *当中的* 的使用。</p><p>explain 中 extra 字段含义：</p><ul><li>using index condition：查找使用了索引，但是需要回表查询数据</li><li>using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</li></ul><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name&#x3D;’xxx’;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name&#x3D;’xxx’;</p><p>所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p><strong>面试题</strong><br>一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br>select id, username, password from tb_user where username&#x3D;’itcast’;</p><pre><code>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</code></pre><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：create index idx_xxxx on table_name(columnn(n));<br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><pre><code>select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</code></pre><p>show index 里面的sub_part可以看到接取的长度</p><h3 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h3><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><pre><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code></pre><p>这句只会用到phone索引字段</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储引擎</title>
      <link href="/p/27905.html"/>
      <url>/p/27905.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>MySQL体系结构：</strong></p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><ul><li>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。</li><li>存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。</li><li>默认存储引擎是InnoDB。</li></ul><p>相关操作：</p><p>– 查询建表语句</p><pre><code>show create table account;</code></pre><p>– 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(    ...) ENGINE=INNODB;</code></pre><p>– 查看当前数据库支持的存储引擎</p><pre><code>show engines;</code></pre><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：</p><pre><code>show variables like &#39;innodb_file_per_table&#39;;</code></pre><p>从idb文件提取表结构数据：（在cmd运行）</p><pre><code>ibd2sdi xxx.ibd</code></pre><p>InnoDB 逻辑存储结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Screenshot_20220920_193246_tv.danmaku.bili_20220920193701368683.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/p/62546.html"/>
      <url>/p/62546.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><p>– 1. 查询张三账户余额</p><pre><code>select * from account where name = &#39;张三&#39;;</code></pre><p>– 2. 将张三账户余额-1000</p><pre><code>update account set money = money - 1000 where name = &#39;张三&#39;;</code></pre><p>– 此语句出错后张三钱减少但是李四钱没有增加<br>    模拟sql语句错误</p><p>– 3. 将李四账户余额+1000</p><pre><code>update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p>– 查看事务提交方式</p><pre><code>SELECT @@AUTOCOMMIT;</code></pre><p>– 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</p><pre><code>SET @@AUTOCOMMIT = 0;</code></pre><p>– 提交事务</p><pre><code>COMMIT;</code></pre><p>– 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>– 设置手动提交后上面代码改为：</p><pre><code>select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><p>操作方式二：</p><p>开启事务：</p><pre><code>START TRANSACTION 或 BEGIN TRANSACTION;</code></pre><p>提交事务：</p><pre><code>COMMIT;</code></pre><p>回滚事务：</p><pre><code>ROLLBACK;</code></pre><p>操作实例：</p><pre><code>start transaction;select * from account where name = &#39;张三&#39;;update account set money = money - 1000 where name = &#39;张三&#39;;update account set money = money + 1000 where name = &#39;李四&#39;;commit;</code></pre><h2 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h2><ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h2 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>设置事务隔离级别：</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code></pre><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/p/19503.html"/>
      <url>/p/19503.html</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><p>– 查询员工姓名，及关联的部门的名称<br>1.隐式</p><pre><code>select e.name, d.name from employee as e, dept as d where e.dept = d.id;</code></pre><p>2.显式</p><pre><code>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</code></pre><h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><ul><li><p>左外连接：</p><p>  查询左表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>  相当于查询表1的所有数据，包含表1和表2交集部分数据</p></li><li><p>右外连接：</p><p>  查询右表所有数据，以及两张表交集部分数据<br>  <code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p></li></ul><p>例子：</p><p>左</p><pre><code>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</code></pre><p>右</p><pre><code>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</code></pre><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h2 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h2><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><p>– 查询员工及其所属领导的名字</p><pre><code>select a.name, b.name from employee a, employee b where a.manager = b.id;</code></pre><p>– 没有领导的也查询出来</p><pre><code>select a.name, b.name from employee a left join employee b on a.manager = b.id;</code></pre><h2 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h2><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 则对重复结果进行去重处理</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code></p><p><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><p>– 查询销售部所有员工</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>– 根据销售部部门ID，查询员工信息</p><pre><code>select * from employee where dept = 4;</code></pre><p>– 合并（子查询）</p><pre><code>select * from employee where dept = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>– 查询xxx入职之后的员工信息</p><pre><code>select * from employee where entrydate &gt; (select entrydate from employee where name = &#39;xxx&#39;);</code></pre><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><p>– 查询销售部和市场部的所有员工信息</p><pre><code>select * from employee where dept in (select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;);</code></pre><p>– 查询比财务部所有人工资都高的员工信息</p><pre><code>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#39;财务部&#39;));</code></pre><p>– 查询比研发部任意一人工资高的员工信息</p><pre><code>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#39;研发部&#39;));</code></pre><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><p>– 查询与xxx的薪资及直属领导相同的员工信息</p><pre><code>select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#39;xxx&#39;);</code></pre><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><p>– 查询与xxx1，xxx2的职位和薪资相同的员工</p><pre><code>select * from employee where (job, salary) in (select job, salary from employee where name = &#39;xxx1&#39; or name = &#39;xxx2&#39;);</code></pre><p>– 查询入职日期是2006-01-01之后的员工，及其部门信息</p><pre><code>select e.*, d.* from (select * from employee where entrydate &gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept = d.id;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="/p/35621.html"/>
      <url>/p/35621.html</url>
      
        <content type="html"><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><pre><code class="mysql">create table user(    id int primary key auto_increment,    name varchar(10) not null unique,    age int check(age &gt; 0 and age &lt; 120),    status char(1) default &#39;1&#39;,    gender char(1));</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><pre><code class="mysql">CREATE TABLE 表名(    字段名 字段类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</code></pre><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="删除-x2F-更新行为"><a href="#删除-x2F-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/p/21513.html"/>
      <url>/p/21513.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><p>– 拼接<br><code>SELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);</code><br>– 小写<br><code>SELECT LOWER(&#39;Hello&#39;);</code><br>– 大写<br><code>SELECT UPPER(&#39;Hello&#39;);</code><br>– 左填充<br><code>SELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 右填充<br><code>SELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);</code><br>– 去除空格<br><code>SELECT TRIM(&#39; Hello World &#39;);</code><br>– 切片（起始索引为1）<br><code>SELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);</code></p><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><p>– DATE_ADD</p><pre><code>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</code></pre><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><pre><code>select    name,    (case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)from employee;select    name,    (case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;from employee;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/p/29900.html"/>
      <url>/p/29900.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>数据库分为两类模型</p><ul><li>概念模型&#x2F;信息模型</li><li>物理模型和逻辑模型</li></ul><p>基本概念：实体，属性，码，实体型，实体集</p><h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）定义数据逻辑结构</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><p>数据库语句后面记得加分号！</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>查询所有数据库：</p><pre><code>SHOW DATABASES;</code></pre><p>查询当前数据库：</p><pre><code>SELECT DATABASE();</code></pre><p>创建数据库：</p><pre><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code></pre><p>使用数据库：</p><pre><code>USE 数据库名;</code></pre><p><strong>注意事项</strong>：UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</p><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查询当前数据库所有表：</p><pre><code>SHOW TABLES;</code></pre><p>查询表结构：</p><pre><code>DESC 表名;</code></pre><p>查询指定表的建表语句：</p><pre><code>SHOW CREATE TABLE 表名;</code></pre><p>创建表：</p><pre><code>CREATE TABLE 表名(    字段1 字段1类型 [COMMENT 字段1注释],    字段2 字段2类型 [COMMENT 字段2注释],    字段3 字段3类型 [COMMENT 字段3注释],    ...    字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];最后一个字段后面没有逗号</code></pre><p>添加字段：</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>修改数据类型：</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></pre><p>修改字段名和字段类型：</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></pre><p>例：</p><pre><code>将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>删除字段：</p><pre><code>ALTER TABLE 表名 DROP 字段名;</code></pre><p>修改表名：</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名</code></pre><p>删除表：</p><pre><code>DROP TABLE [IF EXISTS] 表名;</code></pre><p>删除表，并重新创建该表：</p><pre><code>TRUNCATE TABLE 表名;</code></pre><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>添加数据<br>指定字段：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>全部字段：</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>批量添加数据：</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></pre><p><strong>注意事项</strong></p><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li><li>更新和删除数据</li></ul><p>修改数据：</p><pre><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code></pre><p>例：</p><pre><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></pre><p>删除数据：</p><pre><code>DELETE FROM 表名 [ WHERE 条件 ];</code></pre><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p><strong>编写顺序</strong></p><ol><li>SELECT<br> 字段列表</li><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><p><strong>执行顺序</strong></p><ol><li>FROM<br> 表名字段</li><li>WHERE<br> 条件列表</li><li><ul><li>GROUP BY<br> 分组字段列表</li><li>HAVING<br> 分组后的条件列表</li></ul></li><li>SELECT<br> 字段列表</li><li>ORDER BY<br> 排序字段列表</li><li>LIMIT<br> 分页参数</li></ol><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>查询多个字段：</p><pre><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;</code></pre><p>设置别名</p><pre><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></pre><p>去除重复记录：</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><p>转义：</p><pre><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code></pre><p>&#x2F; 之后的_不作为通配符</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></pre><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr><tr><td>例子：</td><td></td></tr></tbody></table><p>– 年龄等于30</p><pre><code>select * from employee where age = 30;</code></pre><p>– 年龄小于30</p><pre><code>select * from employee where age &lt; 30;</code></pre><p>– 小于等于</p><pre><code>select * from employee where age &lt;= 30;</code></pre><p>– 没有身份证</p><pre><code>select * from employee where idcard is null or idcard = &#39;&#39;;</code></pre><p>– 有身份证</p><pre><code>select * from employee where idcard;select * from employee where idcard is not null;</code></pre><p>– 不等于</p><pre><code>select * from employee where age != 30;</code></pre><p>– 年龄在20到30之间</p><pre><code>select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;</code></pre><p>– 下面语句不报错，但查不到任何信息</p><pre><code>select * from employee where age between 30 and 20;</code></pre><p>– 性别为女且年龄小于30</p><pre><code>elect * from employee where age &lt; 30 and gender = &#39;女&#39;;</code></pre><p>– 年龄等于25或30或35</p><pre><code>select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);</code></pre><p>– 姓名为两个字</p><pre><code>select * from employee where name like &#39;__&#39;;</code></pre><p>– 身份证最后为X</p><pre><code>select * from employee where idcard like &#39;%X&#39;;</code></pre><h3 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h3><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：</p><pre><code>SELECT 聚合函数(字段列表) FROM 表名;</code></pre><p>例：</p><pre><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></pre><p>分组查询<br>语法：</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></pre><p><strong>where 和 having 的区别：</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。<br>例子：</li></ul><p>– 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</p><pre><code>select count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性数量</p><pre><code>select gender, count(*) from employee group by gender;</code></pre><p>– 根据性别分组，统计男性和女性的平均年龄</p><pre><code>select gender, avg(age) from employee group by gender;</code></pre><p>– 年龄小于45，并根据工作地址分组</p><pre><code>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</code></pre><p>– 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</code></pre><p><strong>注意事项</strong></p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></pre><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><p>– 根据年龄升序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;</code></pre><p>– 两字段排序，根据年龄升序排序，入职时间降序排序</p><pre><code>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</code></pre><p><strong>注意事项:</strong> 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法：</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></pre><p>例子：</p><p>– 查询第一页数据，展示10条</p><pre><code>SELECT * FROM employee LIMIT 0, 10;</code></pre><p>– 查询第二页</p><pre><code>SELECT * FROM employee LIMIT 10, 10;</code></pre><p>注意事项</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><p><strong>DQL执行顺序</strong><br>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>查询用户：</p><pre><code>USE mysql;SELECT * FROM user;</code></pre><p>创建用户:</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>修改用户密码：</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></pre><p>删除用户：</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>例子：</p><p>– 创建用户test，只能在当前主机localhost访问</p><pre><code>create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</code></pre><p>– 创建用户test，能在任意主机访问</p><pre><code>create user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;test&#39; identified by &#39;123456&#39;;</code></pre><p>– 修改密码</p><pre><code>alter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;</code></pre><p>– 删除用户</p><pre><code>drop user &#39;test&#39;@&#39;localhost&#39;;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>主机名可以使用 % 通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><p>查询权限：</p><pre><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>授予权限：</p><pre><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;`</code></pre><p>撤销权限：</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合算法</title>
      <link href="/p/35802.html"/>
      <url>/p/35802.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h1><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>set_intersection &#x2F;&#x2F; 求两个容器的交集</li><li>set_union &#x2F;&#x2F; 求两个容器的并集</li><li>set_difference &#x2F;&#x2F; 求两个容器的差集</li></ul><h2 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h2><ul><li>求两个容器的交集</li></ul><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的交集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器</li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较小的值给目标容器开辟空间    vTarget.resize(min(v1.size(), v2.size()));    vector&lt;int&gt;::iterator itEnd =    set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器中取小值</li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h2 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h2><h5 id="求两个集合的并集"><a href="#求两个集合的并集" class="headerlink" title="求两个集合的并集"></a>求两个集合的并集</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的并集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器 </li><li>dest 目标容器开始迭代器</li><li>返回目标容器的最后一个元素的迭代器地址</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个容器的和给目标容器开辟空间    vTarget.resize(v1.size() + v2.size());    //返回目标容器的最后一个元素的迭代器地址    vector&lt;int&gt;::iterator itEnd =    set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要两个容器相加</li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h2 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h2><h5 id="求两个集合的差集"><a href="#求两个集合的差集" class="headerlink" title="求两个集合的差集"></a>求两个集合的差集</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>求两个集合的差集</li><li>注意:两个集合必须是有序序列</li><li>beg1 容器 1 开始迭代器 &#x2F;&#x2F; </li><li>end1 容器 1 结束迭代器 &#x2F;&#x2F; </li><li>beg2 容器 2 开始迭代器 &#x2F;&#x2F; </li><li>end2 容器 2 结束迭代器 &#x2F;&#x2F;</li><li>dest 目标容器开始迭代器</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 5 );    &#125;    vector&lt;int&gt; vTarget;    //取两个里面较大的值给目标容器开辟空间    vTarget.resize( max(v1.size() , v2.size()));    //返回目标容器的最后一个元素的迭代器地址    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;    vector&lt;int&gt;::iterator itEnd =    set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());    for_each(vTarget.begin(), itEnd, myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从两个容器取较大值</li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算术生成算法</title>
      <link href="/p/41195.html"/>
      <url>/p/41195.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h1><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric></numeric></li></ul><h5 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h5><ul><li>accumulate &#x2F;&#x2F; 计算容器元素累计总和</li><li>fill &#x2F;&#x2F; 向容器中添加元素</li></ul><h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><h5 id="计算区间内-容器元素累计总和"><a href="#计算区间内-容器元素累计总和" class="headerlink" title="计算区间内 容器元素累计总和"></a>计算区间内 容器元素累计总和</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>accumulate(iterator beg, iterator end, value);</code></pre><ul><li>计算容器元素累计总和</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 起始值</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt;= 100 ; i++) &#123;        v.push_back(i);    &#125;    int total = accumulate(v.begin(), v.end(), 0 );    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：accumulate使用时头文件注意是-numeric，这个算法很实用"><a href="#总结：accumulate使用时头文件注意是-numeric，这个算法很实用" class="headerlink" title="总结：accumulate使用时头文件注意是 numeric，这个算法很实用"></a>总结：accumulate使用时头文件注意是 numeric，这个算法很实用</h5><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><ul><li>向容器中填充指定的元素<h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5>  fill(iterator beg, iterator end, value);</li><li>向容器中填充元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 填充的值</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.resize( 10 );    //填充    fill(v.begin(), v.end(), 100 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用fill可以将容器区间内元素填充为-指定的值"><a href="#总结：利用fill可以将容器区间内元素填充为-指定的值" class="headerlink" title="总结：利用fill可以将容器区间内元素填充为 指定的值"></a>总结：利用fill可以将容器区间内元素填充为 指定的值</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用拷贝和替换算法</title>
      <link href="/p/20982.html"/>
      <url>/p/20982.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h1><ul><li>copy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li>replace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li>replace_if &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li><li>swap &#x2F;&#x2F; 互换两个容器的元素</li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><h5 id="容器内指定范围的元素拷贝到另一容器中"><a href="#容器内指定范围的元素拷贝到另一容器中" class="headerlink" title="容器内指定范围的元素拷贝到另一容器中"></a>容器内指定范围的元素拷贝到另一容器中</h5><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>copy(iterator beg, iterator end, iterator dest);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>dest 目标起始迭代器</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i + 1 );    &#125;    vector&lt;int&gt; v2;    //分配大小    v2.resize(v1.size());    copy(v1.begin(), v1.end(), v2.begin());    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"><a href="#总结：利用copy算法在拷贝时，目标容器记得提前开辟空间" class="headerlink" title="总结：利用copy算法在拷贝时，目标容器记得提前开辟空间"></a>总结：利用copy算法在拷贝时，目标容器记得提前开辟空间</h5><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><h5 id="将容器内指定范围的旧元素修改为新元素"><a href="#将容器内指定范围的旧元素修改为新元素" class="headerlink" title="将容器内指定范围的旧元素修改为新元素"></a>将容器内指定范围的旧元素修改为新元素</h5><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></pre><ul><li>将区间内旧元素 替换成 新元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>oldvalue 旧元素</li><li>newvalue 新元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //将容器中的 20 替换成 2000    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace(v.begin(), v.end(), 20 , 2000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace会替换区间内满足条件的元素"><a href="#总结：replace会替换区间内满足条件的元素" class="headerlink" title="总结：replace会替换区间内满足条件的元素"></a>总结：replace会替换区间内满足条件的元素</h5><h2 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h2><h5 id="将区间内满足条件的元素，替换成指定元素"><a href="#将区间内满足条件的元素，替换成指定元素" class="headerlink" title="将区间内满足条件的元素，替换成指定元素"></a>将区间内满足条件的元素，替换成指定元素</h5><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></pre><ul><li>按条件替换元素，满足条件的替换成指定元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_pred 谓词</li><li>newvalue 替换的新元素</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;class ReplaceGreater30&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 30 ;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 20 );    v.push_back( 40 );    v.push_back( 50 );    v.push_back( 10 );    v.push_back( 20 );    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000 );    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件"><a href="#总结：replace-if按条件查找，可以利用仿函数灵活筛选满足的条件" class="headerlink" title="总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件"></a>总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</h5><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><h5 id="互换两个容器的元素"><a href="#互换两个容器的元素" class="headerlink" title="互换两个容器的元素"></a>互换两个容器的元素</h5><h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>swap(container c1, container c2);</code></pre><ul><li>互换两个容器的元素</li><li>c1容器 1</li><li>c2容器 2</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v1.push_back(i);        v2.push_back(i+ 100 );    &#125;    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    swap(v1, v2);    for_each(v1.begin(), v1.end(), myPrint());    cout &lt;&lt; endl;    for_each(v2.begin(), v2.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：swap交换容器时，注意交换的容器要同种类型"><a href="#总结：swap交换容器时，注意交换的容器要同种类型" class="headerlink" title="总结：swap交换容器时，注意交换的容器要同种类型"></a>总结：swap交换容器时，注意交换的容器要同种类型</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/p/29759.html"/>
      <url>/p/29759.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><h3 id="算法简介："><a href="#算法简介：" class="headerlink" title="算法简介："></a>算法简介：</h3><pre><code>+ sort //对容器内元素进行排序+ random_shuffle //洗牌 指定范围内的元素随机调整次序+ merge // 容器元素合并，并存储到另一容器中+ reverse // 反转指定范围的元素</code></pre><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>sort(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;vector&lt;int&gt; v;v.push_back( 10 );v.push_back( 30 );v.push_back( 50 );v.push_back( 20 );v.push_back( 40 );//sort默认从小到大排序sort(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint);cout &lt;&lt; endl;//从大到小排序sort(v.begin(), v.end(), greater&lt;int&gt;());for_each(v.begin(), v.end(), myPrint);    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>random_shuffle(iterator beg, iterator end);</code></pre><ul><li>指定范围内的元素随机调整次序</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    srand((unsigned int)time(NULL));    vector&lt;int&gt; v;    for(int i = 0 ; i &lt; 10 ;i++)    &#123;        v.push_back(i);    &#125;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    //打乱顺序    random_shuffle(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：random-shuffle洗牌算法比较实用，使用时记得加随机数种子"><a href="#总结：random-shuffle洗牌算法比较实用，使用时记得加随机数种子" class="headerlink" title="总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子"></a>总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</h5><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></pre><ul><li>容器元素合并，并存储到另一容器中</li><li>注意: 两个容器必须是有序的</li><li>beg1 容器 1 开始迭代器 </li><li>end1 容器 1 结束迭代器 </li><li>beg2 容器 2 开始迭代器 </li><li>end2 容器 2 结束迭代器</li></ul><h5 id="dest-目标容器开始迭代器"><a href="#dest-目标容器开始迭代器" class="headerlink" title="dest 目标容器开始迭代器"></a>dest 目标容器开始迭代器</h5><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);        v2.push_back(i + 1 );    &#125;    vector&lt;int&gt; vtarget;    //目标容器需要提前开辟空间    vtarget.resize(v1.size() + v2.size());    //合并 需要两个有序序列    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());    for_each(vtarget.begin(), vtarget.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：merge合并的两个容器必须的有序序列"><a href="#总结：merge合并的两个容器必须的有序序列" class="headerlink" title="总结：merge合并的两个容器必须的有序序列"></a>总结：merge合并的两个容器必须的有序序列</h5><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h5 id="将容器内元素进行反转"><a href="#将容器内元素进行反转" class="headerlink" title="将容器内元素进行反转"></a>将容器内元素进行反转</h5><h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><pre><code>reverse(iterator beg, iterator end);</code></pre><ul><li>反转指定范围的元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 20 );    v.push_back( 40 );    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;    reverse(v.begin(), v.end());    for_each(v.begin(), v.end(), myPrint());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：reverse反转区间内元素，面试题可能涉及到"><a href="#总结：reverse反转区间内元素，面试题可能涉及到" class="headerlink" title="总结：reverse反转区间内元素，面试题可能涉及到"></a>总结：reverse反转区间内元素，面试题可能涉及到</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="/p/31381.html"/>
      <url>/p/31381.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h1><p>算法主要是由头文件algorithm functional numeric组成。</p><ul><li>algorithm是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历、操作、复制、修改等等</li><li>numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li>functional定义了一些模板类,用以声明函数对象。</li></ul><h2 id="遍历算法for-each"><a href="#遍历算法for-each" class="headerlink" title="遍历算法for_each"></a>遍历算法for_each</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>for_each(iterator beg, iterator end, _func);</code></pre><ul><li>遍历算法 遍历容器元素</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val)&#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;//for_each算法基本用法void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //遍历算法    for_each(v.begin(), v.end(), print01);    cout &lt;&lt; endl;    for_each(v.begin(), v.end(), print02());    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握"><a href="#总结：for-each在实际开发中是最常用遍历算法，需要熟练掌握" class="headerlink" title="总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握"></a>总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握</h3><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul><li>搬运容器到另一个容器中</li></ul><h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></pre><ul><li>beg1 源容器开始迭代器</li><li>end1 源容器结束迭代器</li><li>beg2 目标容器开始迭代器</li><li>_func 函数或者函数对象</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public:    int operator()(int val)    &#123;        return val;    &#125;&#125;class MyPrint&#123;public:    void operator()(int val)    &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;vTarget; //目标容器    vTarget.resize(v.size()); // 目标容器需要提前开辟空间    transform(v.begin(), v.end(), vTarget.begin(), TransForm());    for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运"><a href="#总结：-搬运的目标容器必须要提前开辟空间，否则无法正常搬运" class="headerlink" title="总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运"></a>总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</h3><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find(iterator beg, iterator end, value);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    //查找容器中是否有 5 这个元素    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5 );    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;class Person &#123;public:    Person(string name, int age)    this-&gt;m_Name = name;    this-&gt;m_Age = age;&#125;//重载==，否则自定义数据类型无法运行findbool operator==(const Person&amp; p)&#123;    if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)    &#123;        return true;    &#125;    return false;&#125;public:    string m_Name;    int m_Age;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：-利用find可以在容器中找指定的元素，返回值是迭代器"><a href="#总结：-利用find可以在容器中找指定的元素，返回值是迭代器" class="headerlink" title="总结： 利用find可以在容器中找指定的元素，返回值是迭代器"></a>总结： 利用find可以在容器中找指定的元素，返回值是迭代器</h3><h2 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h2><h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>find_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 函数或者谓词（返回bool类型的仿函数）</li></ul><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public:    bool operator()(int val)    &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++) &#123;        v.push_back(i + 1 );    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到大于 5 的数字:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;//自定义数据类型class Person &#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;public:    string m_Name;    int m_Age;&#125;;class Greater20&#123;public:    bool operator()(Person &amp;p)    &#123;        return p.m_Age &gt; 20 ;    &#125;&#125;;void test02() &#123;    vector&lt;Person&gt; v;    //创建数据    Person p1(&quot;aaa&quot;, 10 );    Person p2(&quot;bbb&quot;, 20 );    Person p3(&quot;ccc&quot;, 30 );    Person p4(&quot;ddd&quot;, 40 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());    if (it == v.end())    &#123;        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"><a href="#总结：find-if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略" class="headerlink" title="总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略"></a>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</h3><h2 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h2><h3 id="查找相邻重复元素"><a href="#查找相邻重复元素" class="headerlink" title="查找相邻重复元素"></a>查找相邻重复元素</h3><h3 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>adjacent_find(iterator beg, iterator end);</code></pre><ul><li>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</li><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 5 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 4 );    v.push_back( 3 );    //查找相邻重复元素    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法"><a href="#总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent-find算法" class="headerlink" title="总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法"></a>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</h3><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h2><p>查找指定元素是否存在，返回值是bool类型</p><h3 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>bool binary_search(iterator beg, iterator end, value);</code></pre><ul><li>查找指定的元素，查到 返回true 否则false</li><li>注意: 在无序序列中不可用</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 查找的元素</li></ul><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    //二分查找    bool ret = binary_search(v.begin(), v.end(), 2 );    if (ret)    &#123;        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;    &#125;    else        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"><a href="#总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列" class="headerlink" title="总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列"></a>总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</h3><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><h3 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h3><h3 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count(iterator beg, iterator end, value);</code></pre><ul><li>统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>value 统计的元素</li></ul><h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );       v.push_back( 4 );    v.push_back( 4 );    int num = count(v.begin(), v.end(), 4 );    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    bool operator==(const Person &amp; p)    &#123;        if (this-&gt;m_Age == p.m_Age)        &#123;            return true;        &#125;        else        &#123;            return false;        &#125;    &#125;    string m_Name;    int m_Age;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    Person p(&quot;诸葛亮&quot;, 35 );    int num = count(v.begin(), v.end(), p);    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D"><a href="#总结：-统计自定义数据类型时候，需要配合重载-operator-x3D-x3D" class="headerlink" title="总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;"></a>总结： 统计自定义数据类型时候，需要配合重载 operator&#x3D;&#x3D;</h5><h2 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h2><h3 id="函数原型：-7"><a href="#函数原型：-7" class="headerlink" title="函数原型："></a>函数原型：</h3><pre><code>count_if(iterator beg, iterator end, _Pred);</code></pre><ul><li>按条件统计元素出现次数</li><li>beg 开始迭代器</li><li>end 结束迭代器</li><li>_Pred 谓词</li></ul><h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:    bool operator()(int val)    &#123;        return val &gt;= 4 ;    &#125;&#125;;//内置数据类型void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 1 );    v.push_back( 2 );    v.push_back( 4 );    v.push_back( 5 );    v.push_back( 3 );    v.push_back( 4 );    v.push_back( 4 );    int num = count_if(v.begin(), v.end(), Greater4());    cout &lt;&lt; &quot;大于 4 的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class AgeLess35&#123;public:    bool operator()(const Person &amp;p)    &#123;        return p.m_Age &lt; 35 ;    &#125;&#125;;void test02()&#123;    vector&lt;Person&gt; v;    Person p1(&quot;刘备&quot;, 35 );    Person p2(&quot;关羽&quot;, 35 );    Person p3(&quot;张飞&quot;, 35 );    Person p4(&quot;赵云&quot;, 30 );    Person p5(&quot;曹操&quot;, 25 );    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    v.push_back(p5);    int num = count_if(v.begin(), v.end(), AgeLess35());    cout &lt;&lt; &quot;小于 35 岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h3 id="总结：按值统计用count，按条件统计用count-if"><a href="#总结：按值统计用count，按条件统计用count-if" class="headerlink" title="总结：按值统计用count，按条件统计用count_if"></a>总结：按值统计用count，按条件统计用count_if</h3>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内建函数对象</title>
      <link href="/p/45788.html"/>
      <url>/p/45788.html</url>
      
        <content type="html"><![CDATA[<h1 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h1><ul><li>STL内建了一些函数对象</li><li>头文件 functional<h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3></li><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数<h2 id="算数仿函数"><a href="#算数仿函数" class="headerlink" title="算数仿函数"></a>算数仿函数</h2><h3 id="仿函数原型："><a href="#仿函数原型：" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3></li><li>template<class t> T plus<T> &#x2F;&#x2F;加法仿函数</T></class></li><li>template<class t> T minus<T> &#x2F;&#x2F;减法仿函数</T></class></li><li>template<class t> T multiplies<T> &#x2F;&#x2F;乘法仿函数</T></class></li><li>template<class t> T divides<T> &#x2F;&#x2F;除法仿函数</T></class></li><li>template<class t> T modulus<T> &#x2F;&#x2F;取模仿函数</T></class></li><li>template<class t> T negate<T> &#x2F;&#x2F;取反仿函数<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5>  #include <functional><br>  &#x2F;&#x2F;negate<br>  void test01()<br>  {<br>  negate<int> n;<br>  cout &lt;&lt; n( 50 ) &lt;&lt; endl;<br>  }<br>  &#x2F;&#x2F;plus<br>  void test02()<br>  {<br>  plus<int> p;<br>  cout &lt;&lt; p( 10 , 20 ) &lt;&lt; endl;<br>  }<br>  int main() {<br>  test01();<br>  test02();<br>  system(“pause”);<br>  return 0 ;<br>  }</int></int></functional></T></class></li></ul><h2 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h2><h3 id="仿函数原型：-1"><a href="#仿函数原型：-1" class="headerlink" title="仿函数原型："></a>仿函数原型：</h3><ul><li>template<class t> bool equal_to<T> &#x2F;&#x2F;等于</T></class></li><li>template<class t> bool not_equal_to<T> &#x2F;&#x2F;不等于</T></class></li><li>template<class t> bool greater<T> &#x2F;&#x2F;大于</T></class></li><li>template<class t> bool greater_equal<T> &#x2F;&#x2F;大于等于</T></class></li><li>template<class t> bool less<T> &#x2F;&#x2F;小于</T></class></li><li>template<class t> bool less_equal<T> &#x2F;&#x2F;小于等于</T></class></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:    bool operator()(int v1,int v2)    &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 30 );    v.push_back( 50 );    v.push_back( 40 );    v.push_back( 20 );    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //sort(v.begin(), v.end(), MyCompare());    //STL内建仿函数 大于仿函数    sort(v.begin(), v.end(), greater&lt;int&gt;());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：关系仿函数中最常用的就是greater-lt-gt-大于"><a href="#总结：关系仿函数中最常用的就是greater-lt-gt-大于" class="headerlink" title="总结：关系仿函数中最常用的就是greater&lt;&gt;大于"></a>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</h5><h2 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h2><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><ul><li>template<class t> bool logical_and<T> &#x2F;&#x2F;逻辑与</T></class></li><li>template<class t> bool logical_or<T> &#x2F;&#x2F;逻辑或</T></class></li><li>template<class t> bool logical_not<T> &#x2F;&#x2F;逻辑非</T></class></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;    vector&lt;bool&gt; v;    v.push_back(true);    v.push_back(false);    v.push_back(true);    v.push_back(false);    for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //逻辑非 将v容器搬运到v2中，并执行逻辑非运算    vector&lt;bool&gt; v2;    v2.resize(v.size());    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;());    for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：逻辑仿函数实际应用较少，了解即可"><a href="#总结：逻辑仿函数实际应用较少，了解即可" class="headerlink" title="总结：逻辑仿函数实际应用较少，了解即可"></a>总结：逻辑仿函数实际应用较少，了解即可</h5>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map/multimap</title>
      <link href="/p/37043.html"/>
      <url>/p/37043.html</url>
      
        <content type="html"><![CDATA[<h1 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h1><h2 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h2><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><ul><li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>可以根据key值快速找到value值</li></ul><h4 id="map和multimap区别："><a href="#map和multimap区别：" class="headerlink" title="map和multimap区别："></a>map和multimap区别：</h4><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h2 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数:</p></li><li><p>map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int,int&gt;m; //默认构造    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    printMap(m);    map&lt;int, int&gt;m2(m); //拷贝构造    printMap(m2);    map&lt;int, int&gt;m3;    m3 = m2; //赋值    printMap(m3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h2 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    if (m.empty())    &#123;        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;    &#125;&#125;void test02()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    map&lt;int, int&gt;m2;    m2.insert(pair&lt;int, int&gt;( 4 , 100 ));    m2.insert(pair&lt;int, int&gt;( 5 , 200 ));    m2.insert(pair&lt;int, int&gt;( 6 , 300 ));    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printMap(m);    printMap(m2);    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    m.swap(m2);    printMap(m);    printMap(m2);&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h2><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)    &#123;        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    //插入    map&lt;int, int&gt; m;    //第一种插入方式    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    //第二种插入方式    m.insert(make_pair( 2 , 20 ));    //第三种插入方式    m.insert(map&lt;int, int&gt;::value_type( 3 , 30 ));    //第四种插入方式    m[ 4 ] = 40 ;    printMap(m);    //删除    m.erase(m.begin());    printMap(m);    m.erase( 3 );    printMap(m);    //清空    m.erase(m.begin(),m.end());    m.clear();    printMap(m);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;void test01()&#123;    map&lt;int, int&gt;m;    m.insert(pair&lt;int, int&gt;( 1 , 10 ));    m.insert(pair&lt;int, int&gt;( 2 , 20 ));    m.insert(pair&lt;int, int&gt;( 3 , 30 ));    //查找    map&lt;int, int&gt;::iterator pos = m.find( 3 );    if (pos != m.end())    &#123;        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = m.count( 3 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h2><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;map&gt;class MyCompare &#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    //默认从小到大排序    //利用仿函数实现从大到小排序    map&lt;int, int, MyCompare&gt; m;    m.insert(make_pair( 1 , 10 ));    m.insert(make_pair( 2 , 20 ));    m.insert(make_pair( 3 , 30 ));    m.insert(make_pair( 4 , 40 ));    m.insert(make_pair( 5 , 50 ));    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例-员工分组"></a>案例-员工分组</h3><h4 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h4><p>公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作<br>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发<br>随机给 10 名员工分配部门和工资<br>通过multimap进行信息的插入 key(部门编号) value(员工)<br>分部门显示员工信息</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>创建 10 名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><h5 id="案例代码："><a href="#案例代码：" class="headerlink" title="案例代码："></a>案例代码：</h5><pre><code>#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了 10 个员工（ABCDEFGHIJ）， 10 名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给 10 名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA 0#define MEISHU 1#define YANFA 2class Worker&#123;public:    string m_Name;    int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;    string nameSeed = &quot;ABCDEFGHIJ&quot;;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        Worker worker;        worker.m_Name = &quot;员工&quot;;        worker.m_Name += nameSeed[i];        worker.m_Salary = rand() % 10000 + 10000 ; // 10000 ~ 19999        //将员工放入到容器中        v.push_back(worker);    &#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        //产生随机部门编号        int deptId = rand() % 3 ; // 0 1 2        //将员工插入到分组中        //key部门编号，value具体员工        m.insert(make_pair(deptId, *it));    &#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);    int count = m.count(CEHUA); // 统计具体人数    int index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;    pos = m.find(MEISHU);    count = m.count(MEISHU); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;    pos = m.find(YANFA);    count = m.count(YANFA); // 统计具体人数    index = 0 ;    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)    &#123;    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt;    endl;    &#125;&#125;int main() &#123;    srand((unsigned int)time(NULL));    //1、创建员工    vector&lt;Worker&gt;vWorker;    createWorker(vWorker);    //2、员工分组    multimap&lt;int, Worker&gt;mWorker;    setGroup(vWorker, mWorker);    showWorkerByGourp(mWorker);    ////测试    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)    //&#123;    // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set/multiset</title>
      <link href="/p/22700.html"/>
      <url>/p/22700.html</url>
      
        <content type="html"><![CDATA[<h1 id="set-x2F-multiset-容器"><a href="#set-x2F-multiset-容器" class="headerlink" title="set&#x2F; multiset 容器"></a>set&#x2F; multiset 容器</h1><h2 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>所有元素都会在插入时自动被排序</p><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><p>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</p><h3 id="set和multiset区别："><a href="#set和multiset区别：" class="headerlink" title="set和multiset区别："></a>set和multiset区别：</h3><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h2 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h2><h3 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h3><ul><li><p>set<T> st; &#x2F;&#x2F;默认构造函数：</T></p></li><li><p>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><ul><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;        cout &lt;&lt; endl;    &#125;&#125;//构造和赋值void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //拷贝构造    set&lt;int&gt;s2(s1);    printSet(s2);    //赋值    set&lt;int&gt;s3;    s3 = s2;    printSet(s3);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h2 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    if (s1.empty())    &#123;        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;    &#125;&#125;//交换void test02()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    set&lt;int&gt; s2;    s2.insert( 100 );    s2.insert( 300 );    s2.insert( 200 );    s2.insert( 400 );    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;    printSet(s1);    printSet(s2);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;    s1.swap(s2);    printSet(s1);    printSet(s2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    printSet(s1);    //删除    s1.erase(s1.begin());    printSet(s1);    s1.erase( 30 );    printSet(s1);    //清空    //s1.erase(s1.begin(), s1.end());    s1.clear();    printSet(s1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h2><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;void test01()&#123;    set&lt;int&gt; s1;    //插入    s1.insert( 10 );    s1.insert( 30 );    s1.insert( 20 );    s1.insert( 40 );    //查找    set&lt;int&gt;::iterator pos = s1.find( 30 );    if (pos != s1.end())    &#123;        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;    &#125;    //统计    int num = s1.count( 30 );    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;set&gt;//set和multiset区别void test01()&#123;    set&lt;int&gt; s;    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        pair&lt;type, type&gt; p ( value1, value2 );        pair&lt;type, type&gt; p = make_pair( value1, value2 );        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;    &#125;    ret = s.insert( 10 );    if (ret.second) &#123;        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;    &#125;    //multiset    multiset&lt;int&gt; ms;    ms.insert( 10 );    ms.insert( 10 );    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h2 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h2><h5 id="两种创建方式："><a href="#两种创建方式：" class="headerlink" title="两种创建方式："></a>两种创建方式：</h5><pre><code>#include &lt;string&gt;//对组创建void test01()&#123;    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10 );    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h2><h3 id="示例一-set存放内置数据类型"><a href="#示例一-set存放内置数据类型" class="headerlink" title="示例一 set存放内置数据类型"></a>示例一 set存放内置数据类型</h3><pre><code>#include &lt;set&gt;class MyCompare&#123;public:    bool operator()(int v1, int v2) &#123;        return v1 &gt; v2;    &#125;&#125;;void test01()&#123;    set&lt;int&gt; s1;    s1.insert( 10 );    s1.insert( 40 );    s1.insert( 20 );    s1.insert( 30 );    s1.insert( 50 );    //默认从小到大    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    //指定排序规则    set&lt;int,MyCompare&gt; s2;    s2.insert( 10 );    s2.insert( 40 );    s2.insert( 20 );    s2.insert( 30 );    s2.insert( 50 );    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：利用仿函数可以指定set容器的排序规则"><a href="#总结：利用仿函数可以指定set容器的排序规则" class="headerlink" title="总结：利用仿函数可以指定set容器的排序规则"></a>总结：利用仿函数可以指定set容器的排序规则</h5><h3 id="示例二-set存放自定义数据类型"><a href="#示例二-set存放自定义数据类型" class="headerlink" title="示例二 set存放自定义数据类型"></a>示例二 set存放自定义数据类型</h3><pre><code>#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;class comparePerson&#123;public:    bool operator()(const Person&amp; p1, const Person &amp;p2)    &#123;        //按照年龄进行排序 降序        return p1.m_Age &gt; p2.m_Age;    &#125;&#125;;void test01()&#123;    set&lt;Person, comparePerson&gt; s;    Person p1(&quot;刘备&quot;, 23 );    Person p2(&quot;关羽&quot;, 27 );    Person p3(&quot;张飞&quot;, 25 );    Person p4(&quot;赵云&quot;, 21 );    s.insert(p1);    s.insert(p2);    s.insert(p3);    s.insert(p4);    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)    &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><ul><li>对于自定义数据类型，set必须指定排序规则才可以插入数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/p/39907.html"/>
      <url>/p/39907.html</url>
      
        <content type="html"><![CDATA[<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h2><p>功能：将数据进行链式存储<br>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列结点组成<br>结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域<br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p><p><strong>list的优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点：</strong></p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</T></li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    list&lt;int&gt;L2(L1.begin(),L1.end());    printList(L2);    list&lt;int&gt;L3(L2);    printList(L3);    list&lt;int&gt;L4( 10 , 1000 );    printList(L4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h2><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    printList(L1);    //赋值    list&lt;int&gt;L2;    L2 = L1;    printList(L2);    list&lt;int&gt;L3;    L3.assign(L2.begin(), L2.end());    printList(L3);    list&lt;int&gt;L4;    L4.assign( 10 , 100 );    printList(L4);&#125;//交换void test02()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    list&lt;int&gt;L2;    L2.assign( 10 , 100 );    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);    cout &lt;&lt; endl;    L1.swap(L2);    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;    printList(L1);    printList(L2);&#125;int main() &#123;    //test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h2><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    if (L1.empty())    &#123;        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;    &#125;    //重新指定大小    L1.resize( 10 );    printList(L1);    L1.resize( 2 );    printList(L1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h2><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    &#125;//插入和删除void test01()&#123;    list&lt;int&gt; L;    //尾插    L.push_back( 10 );    L.push_back( 20 );    L.push_back( 30 );    //头插    L.push_front( 100 );    L.push_front( 200 );    L.push_front( 300 );    printList(L);    //尾删    L.pop_back();    printList(L);    //头删    L.pop_front();    printList(L);    //插入    list&lt;int&gt;::iterator it = L.begin();    L.insert(++it, 1000 );    printList(L);    //删除    it = L.begin();    L.erase(++it);    printList(L);    L.push_back( 10000 );    L.push_back( 10000 );    L.push_back( 10000 );    printList(L);    L.remove( 10000 );    printList(L);    //清空    L.clear();    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h2><ul><li><p>front(); &#x2F;&#x2F;返回第一个元素。</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素。</p></li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;//数据存取void test01()&#123;    list&lt;int&gt;L1;    L1.push_back( 10 );    L1.push_back( 20 );    L1.push_back( 30 );    L1.push_back( 40 );    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;    //list容器的迭代器是双向迭代器，不支持随机访问    list&lt;int&gt;::iterator it = L1.begin();    //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：list容器中不可以通过[]或者at方式访问数据</p><ul><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h2 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h2><ul><li><p>reverse(); &#x2F;&#x2F;反转链表</p></li><li><p>sort(); &#x2F;&#x2F;链表排序</p></li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>void printList(const list&lt;int&gt;&amp; L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;    return val1 &gt; val2;&#125;//反转和排序void test01()&#123;    list&lt;int&gt; L;    L.push_back( 90 );    L.push_back( 30 );    L.push_back( 20 );    L.push_back( 70 );    printList(L);    //反转容器的元素    L.reverse();    printList(L);    //排序    L.sort(); //默认的排序规则 从小到大    printList(L);    L.sort(myCompare); //指定规则，从大到小    printList(L);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h3><h4 id="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"><a href="#案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高" class="headerlink" title="案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高"></a>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</h4><h4 id="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"><a href="#排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序" class="headerlink" title="排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序"></a>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</h4><h5 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:    Person(string name, int age , int height) &#123;        m_Name = name;        m_Age = age;        m_Height = height;    &#125;public:    string m_Name; //姓名    int m_Age; //年龄    int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    else    &#123;        return p1.m_Age &lt; p2.m_Age;    &#125;&#125;void test01() &#123;    list&lt;Person&gt; L;    Person p1(&quot;刘备&quot;, 35 , 175 );    Person p2(&quot;曹操&quot;, 45 , 180 );    Person p3(&quot;孙权&quot;, 40 , 170 );    Person p4(&quot;赵云&quot;, 25 , 190 );    Person p5(&quot;张飞&quot;, 35 , 160 );    Person p6(&quot;关羽&quot;, 35 , 200 );    L.push_back(p1);    L.push_back(p2);    L.push_back(p3);    L.push_back(p4);    L.push_back(p5);    L.push_back(p6);    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;    L.sort(ComparePerson); //排序    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age&lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue</title>
      <link href="/p/41872.html"/>
      <url>/p/41872.html</url>
      
        <content type="html"><![CDATA[<h1 id="queue-容器"><a href="#queue-容器" class="headerlink" title="queue 容器"></a>queue 容器</h1><h2 id="queue-基本概念"><a href="#queue-基本概念" class="headerlink" title="queue 基本概念"></a>queue 基本概念</h2><p>概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口<br>创建栈容器 栈容器必须符合先进后出<br>队列容器允许从一端新增元素，从另一端移除元素<br>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><ul><li><p>队列中进数据称为 — 入队 push</p></li><li><p>队列中出数据称为 — 出队 pop</p><h2 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h2></li></ul><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>queue<T> que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</T></p></li><li><p>queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;往队尾添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从队头移除第一个元素</p></li><li><p>back(); &#x2F;&#x2F;返回最后一个元素</p></li><li><p>front(); &#x2F;&#x2F;返回第一个元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:    Person(string name, int age)    &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;    &#125;    string m_Name;    int m_Age;&#125;;void test01() &#123;    //创建队列    queue&lt;Person&gt; q;    //准备数据    Person p1(&quot;唐僧&quot;, 30 );    Person p2(&quot;孙悟空&quot;, 1000 );    Person p3(&quot;猪八戒&quot;, 900 );    Person p4(&quot;沙僧&quot;, 800 );    q.push(p1);    q.push(p2);    q.push(p3);    q.push(p4);    //队列不提供迭代器，更不支持随机访问    while (!q.empty()) &#123;        //输出队头元素        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name        &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name        &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        cout &lt;&lt; endl;        //弹出队头元素        q.pop();    &#125;    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack</title>
      <link href="/p/64038.html"/>
      <url>/p/64038.html</url>
      
        <content type="html"><![CDATA[<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h2 id="stack-基本概念"><a href="#stack-基本概念" class="headerlink" title="stack 基本概念"></a>stack 基本概念</h2><p>概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口.栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><ul><li><p>栈中进入数据称为 — 入栈 push</p></li><li><p>栈中弹出数据称为 — 出栈 pop</p></li></ul><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><ul><li><p>stack<T> stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</T></p></li><li><p>stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数</p></li></ul><h3 id="赋值操作："><a href="#赋值操作：" class="headerlink" title="赋值操作："></a>赋值操作：</h3><ul><li>stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符</li></ul><h3 id="数据存取："><a href="#数据存取：" class="headerlink" title="数据存取："></a>数据存取：</h3><ul><li><p>push(elem); &#x2F;&#x2F;向栈顶添加元素</p></li><li><p>pop(); &#x2F;&#x2F;从栈顶移除第一个元素</p></li><li><p>top(); &#x2F;&#x2F;返回栈顶元素</p></li></ul><h3 id="大小操作："><a href="#大小操作：" class="headerlink" title="大小操作："></a>大小操作：</h3><ul><li><p>empty(); &#x2F;&#x2F;判断堆栈是否为空</p></li><li><p>size(); &#x2F;&#x2F;返回栈的大小</p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;stack&gt;void test01()&#123;    stack&lt;int&gt; s;    //向栈中添加元素，叫做 压栈 入栈    s.push( 10 );    s.push( 20 );    s.push( 30 );    while (!s.empty()) &#123;        //输出栈顶元素        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;        //弹出栈顶元素        s.pop();    &#125;    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque</title>
      <link href="/p/42201.html"/>
      <url>/p/42201.html</url>
      
        <content type="html"><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h2><blockquote><p>双端数组，可以对头端进行插入删除操作</p></blockquote><h3 id="deque与vector区别："><a href="#deque与vector区别：" class="headerlink" title="deque与vector区别："></a>deque与vector区别：</h3><p>1.vector对于头部的插入删除效率低，数据量越大，效率越低deque相对而言，对头部的插入删除速度回比vector快</p><p>2.vector访问元素时的速度会比deque快,这和两者内部实现有关</p><h3 id="deque内部工作原理"><a href="#deque内部工作原理" class="headerlink" title="deque内部工作原理:"></a>deque内部工作原理:</h3><p>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间<br>deque容器的迭代器也是支持随机访问的</p><h2 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h2><ul><li>deque<T> deqT; &#x2F;&#x2F;默认构造形式</T></li><li>deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5>  #include <deque><br>  void printDeque(const deque<int>&amp; d)<br>  {<br>  for (deque<int>::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) {<br>  cout &lt;&lt; *it &lt;&lt; “ “;<br>  }<br>  cout &lt;&lt; endl;<br>  }<br>  &#x2F;&#x2F;deque构造<br>  void test01() {<br>  deque<int> d1; &#x2F;&#x2F;无参构造函数<br>  for (int i &#x3D; 0 ; i &lt; 10 ; i++)<br>  {<br>      d1.push_back(i);<br>  }<br>  printDeque(d1);<br>  deque<int> d2(d1.begin(),d1.end());<br>  printDeque(d2);<br>  deque<int>d3(10, 100);<br>  printDeque(d3);<br>  deque<int>d4 &#x3D; d3;<br>  printDeque(d4);<br>  }<br>  int main() {<br>  test01();<br>  system(“pause”);<br>  return 0;<br>  }</int></int></int></int></int></int></deque></li></ul><p>总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><ul><li><p>deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</p></li><li><p>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p></li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;        deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt;d2;    d2 = d1;    printDeque(d2);    deque&lt;int&gt;d3;    d3.assign(d1.begin(), d1.end());    printDeque(d3);    deque&lt;int&gt;d4;    d4.assign( 10 , 100 );    printDeque(d4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><ul><li>deque.empty(); &#x2F;&#x2F;判断容器是否为空</li><li>deque.size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。<ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;    deque&lt;int&gt; d1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    //判断容器是否为空    if (d1.empty()) &#123;        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;        //统计大小        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;    &#125;    //重新指定大小    d1.resize( 15 , 1 );    printDeque(d1);    d1.resize( 5 );    printDeque(d1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><ul><li><p>两端插入操作：</p><ul><li>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据</li><li>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据</li><li>pop_back(); &#x2F;&#x2F;删除容器最后一个数据</li><li>pop_front(); &#x2F;&#x2F;删除容器第一个数据</li><li>指定位置操作：</li></ul></li><li><p>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p><ul><li>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear(); &#x2F;&#x2F;清空容器的所有数据</li><li>erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul></li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;`    &#125;    cout &lt;&lt; endl;&#125;//两端操作void test01()&#123;    deque&lt;int&gt; d;    //尾插    d.push_back( 10 );    d.push_back( 20 );    //头插    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    //尾删    d.pop_back();    //头删    d.pop_front();    printDeque(d);&#125;//插入void test02()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.insert(d.begin(), 1000 );    printDeque(d);    d.insert(d.begin(), 2 , 10000 );    printDeque(d);    deque&lt;int&gt;d2;    d2.push_back( 1 );    d2.push_back( 2 );    d2.push_back( 3 );    d.insert(d.begin(), d2.begin(), d2.end());    printDeque(d);&#125;//删除void test03()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    d.erase(d.begin());    printDeque(d);    d.erase(d.begin(), d.end());    d.clear();    printDeque(d);&#125;int main() &#123;    test01();    test02();    test03();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//数据存取void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; d.size(); i++) &#123;        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7 deque 排序"></a>3.3.7 deque 排序</h4><h5 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h5><ul><li>sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序</li></ul><h5 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    deque&lt;int&gt; d;    d.push_back( 10 );    d.push_back( 20 );    d.push_front( 100 );    d.push_front( 200 );    printDeque(d);    sort(d.begin(), d.end());    printDeque(d);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/p/54708.html"/>
      <url>/p/54708.html</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector与普通数组区别：</strong><br>1.不同之处在于数组是静态空间，而vector可以动态扩展。</p><pre><code>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</code></pre><p>2.vector容器的迭代器是支持随机访问的迭代器</p><h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><ul><li>vector<T> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</T></li><li>vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li><li>vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。</li></ul><p>总结：vector的多种构造方式没有可比性，灵活使用即可</p><h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><ul><li>vector&amp; operator&#x3D;(const vector &amp;vec);&#x2F;&#x2F;重载等号操作</li><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;    vector&lt;int&gt; v1; //无参构造    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    v2 = v1;    printVector(v2);    vector&lt;int&gt;v3;    v3.assign(v1.begin(), v1.end());    printVector(v3);    vector&lt;int&gt;v4;    v4.assign( 10 , 100 );    printVector(v4);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p><h2 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h2><ul><li><p>empty(); &#x2F;&#x2F;判断容器是否为空</p></li><li><p>capacity(); &#x2F;&#x2F;容器的容量</p></li><li><p>size(); &#x2F;&#x2F;返回容器中元素的个数</p></li><li><p>resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除。</li></ul></li><li><p>resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><ul><li>如果容器变短，则末尾超出容器长度的元素被删除</li></ul></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    if (v1.empty())    &#123;        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;    &#125;    //resize 重新指定大小 ，若指定的更大，默认用 0 填充新位置，可以利用重载版本替换默认填充    v1.resize( 15 , 10 );    printVector(v1);    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除    v1.resize( 5 );    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><ul><li>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</li><li>pop_back(); &#x2F;&#x2F;删除最后一个元素</li><li>insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li>insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li>erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素</li><li>erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li>clear(); &#x2F;&#x2F;删除容器中所有元素</li></ul><p><strong>示例</strong>：</p><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;    vector&lt;int&gt; v1;    //尾插    v1.push_back( 10 );    v1.push_back( 20 );    v1.push_back( 30 );    v1.push_back( 40 );    v1.push_back( 50 );    printVector(v1);    //尾删    v1.pop_back();    printVector(v1);    //插入    v1.insert(v1.begin(), 100 );    printVector(v1);    v1.insert(v1.begin(), 2 , 1000 );    printVector(v1);    //删除    v1.erase(v1.begin());    printVector(v1);    //清空    v1.erase(v1.begin(), v1.end());    v1.clear();    printVector(v1);&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h2><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0 ; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><ul><li>swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换</li></ul><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    for (int i = 10 ; i &gt; 0 ; i--)    &#123;        v2.push_back(i);    &#125;    printVector(v2);    //互换容器    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;    v1.swap(v2);    printVector(v1);    printVector(v2);&#125;void test02()&#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;    v.resize( 3 );    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;//大小变为3    //收缩内存    vector&lt;int&gt;(v).swap(v); //匿名对象下一行自动回收    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;    test01();    test02();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><ul><li>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><pre><code>#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v;    //预留空间    v.reserve( 100000 );    int num = 0 ;    int* p = NULL;    for (int i = 0 ; i &lt; 100000 ; i++) &#123;        v.push_back(i);        if (p != &amp;v[ 0 ]) &#123;            p = &amp;v[ 0 ];            num++;    &#125;&#125;cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/p/58909.html"/>
      <url>/p/58909.html</url>
      
        <content type="html"><![CDATA[<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>srting的本质是一个类，类内部封装了char* 管理这个字符串，是一个char*类型的容器</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>string()</li><li>string(const char*s)</li><li>string(const string&amp;str)</li><li>string(int n,char c)<ul><li>例如string s1(5,’a’);s1初始化为”aaaaa”</li></ul></li></ul><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul><li>string&amp; operator&#x3D;(const char*s)</li><li>string&amp; operator&#x3D;(const string &amp;s)</li><li>string&amp; operator&#x3D;(char c)</li><li>string&amp; assign(const char *s)</li><li>string&amp; assign(const char *s,int n)<ul><li>把字符串s前n个字符赋给当前字符串</li></ul></li><li>string&amp; assign(const string &amp;s)</li><li>string&amp; assign(int n,char c)<h2 id="字符换拼接"><a href="#字符换拼接" class="headerlink" title="字符换拼接"></a>字符换拼接</h2></li><li>string&amp; operator+&#x3D;(const char*str)</li><li>string&amp; operator+&#x3D;(const char c)</li><li>string&amp; operator+&#x3D;(const string &amp;str)</li><li>string&amp; append(const char *s)</li><li>string&amp; append(const char *s,int n)<ul><li>把字符串s前n个字符拼接到当前字符串</li></ul></li><li>string&amp; append(const string &amp;s)</li><li>string&amp; append(const string &amp;s,int pos,int n)<ul><li>字符串s从pos开始的n个字符拼接到当前字符串后面</li></ul></li></ul><h2 id="字符串查找和替换"><a href="#字符串查找和替换" class="headerlink" title="字符串查找和替换"></a>字符串查找和替换</h2><ul><li>int find(const string&amp; str, int pos &#x3D; 0) const;<ul><li>查找str第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos &#x3D; 0) const;<ul><li>查找s第一次出现位置,从pos开始查找</li></ul></li><li>int find(const char* s, int pos, int n) const;<ul><li>从pos位置查找s的前n个字符第一次位置</li></ul></li><li>int find(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c第一次出现位置</li></ul></li><li>int rfind(const string&amp; str, int pos &#x3D; npos) const; <ul><li>查找str最后一次位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos &#x3D; npos) const; <ul><li>查找s最后一次出现位置,从pos开始查找</li></ul></li><li>int rfind(const char* s, int pos, int n) const; <ul><li>从pos查找s的前n个字符最后一次位置</li></ul></li><li>int rfind(const char c, int pos &#x3D; 0) const; <ul><li>查找字符c最后一次出现位置</li></ul></li><li>string&amp; replace(int pos, int n, const string&amp; str);<ul><li>替换从pos开始n个字符替换为字符串str</li></ul></li><li>string&amp; replace(int pos, int n,const char* s);<ul><li>替换从pos开始的n个字符替换为字符串s</li></ul></li></ul><p><strong>查找失败返回-1</strong></p><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>按照ASCLL 码比较</p><ul><li>‘&#x3D;’ 返回0</li><li>‘&gt;’ 返回1</li><li>‘&lt; ‘返回-1</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul><li><p>int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较</p></li><li><p>int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较</p></li></ul><h2 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h2><h3 id="string中单个字符存取方式有两种"><a href="#string中单个字符存取方式有两种" class="headerlink" title="string中单个字符存取方式有两种"></a>string中单个字符存取方式有两种</h3><ul><li>char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符</li><li>char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符</li></ul><p>可以利用size()函数获取string大小进行遍历</p><h3 id="string中字串存取方式"><a href="#string中字串存取方式" class="headerlink" title="string中字串存取方式"></a>string中字串存取方式</h3><ul><li>string substr(int pos &#x3D; 0, int n &#x3D; npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li></ul><p>中文两字节代表一个汉字,所以截取第一个汉字substr(0,2);</p><h2 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h2><ul><li><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串</p></li><li><p>string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c</p></li><li><p>string&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谓词</title>
      <link href="/p/5958.html"/>
      <url>/p/5958.html</url>
      
        <content type="html"><![CDATA[<h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><ul><li>返回bool类型的仿函数称为谓词</li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2></li><li>重载函数调用操作符的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><h2 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h2><ul><li>一个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123;    bool operator()(int val) &#123;        return val &gt; 5 ;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0 ; i &lt; 10 ; i++)    &#123;        v.push_back(i);    &#125;    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;    else &#123;        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre><h2 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h2><ul><li>两个参数的谓词</li></ul><p>示例：</p><pre><code>#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public:    bool operator()(int num1, int num2)    &#123;        return num1 &gt; num2;    &#125;&#125;;void test01()&#123;    vector&lt;int&gt; v;    v.push_back( 10 );    v.push_back( 40 );    v.push_back( 20 );    v.push_back( 30 );    v.push_back( 50 );    sort(v.begin(), v.end());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;    //使用函数对象改变算法策略，排序从大到小    sort(v.begin(), v.end(), MyCompare());    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    test01();    system(&quot;pause&quot;);    return 0 ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/p/46132.html"/>
      <url>/p/46132.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众多设计模式中，单例模式比较常见的一种，该模式需要满足以下两个条件。</p><ul><li>保证一个类只创建一个实例。</li><li>提供对该实例的全局访问点。</li></ul><p>如果系统有类似的实体（有且只有一个，且需要全局访问），那么就可以将其实现为一个单例。</p><p>实际工作中常见的应用举例</p><ul><li>日志类，一个应用往往只对应一个日志实例。</li><li>配置类，应用的配置集中管理，并提供全局访问。</li><li>管理器，比如windows系统的任务管理器就是一个例子，总是只有一个管理器的实例。</li><li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。</li><li>多线程的线程池，数据库</li></ul><h2 id="Lazy-Singleton"><a href="#Lazy-Singleton" class="headerlink" title="Lazy Singleton"></a>Lazy Singleton</h2><p>头文件中</p><pre><code>class Singleton  &#123;public:    static Singleton&amp; Instance()    &#123;        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;        return *instance_;    &#125;private:    Singleton();    ~Singleton();    Singleton(const Singleton&amp;);    Singleton&amp; operator=(const Singleton&amp;);private:    static Singleton* instance_;&#125;;</code></pre><p>实现文件中</p><pre><code>Singleton* Singleton::instance_ = 0;  </code></pre><p>实现中构造函数被声明为私有方法，这样从根本上杜绝外部使用构造函数生成新的实例，同时禁用拷贝函数与赋值操作符（声明为私有但是不提供实现）避免通过拷贝函数或赋值操作生成新实例。<br>提供静态方法Instance()作为实例全局访问点，该方法中先判断有没有现成的实例，如果有直接返回，如果没有则生成新实例并把实例的指针保存到私有的静态属性中。<br>注意，这里Instance()返回的实例的引用而不是指针，如果返回的是指针可能会有被外部调用者delete掉的隐患，所以这里返回引用会更加保险一些。并且直到Instance()被访问，才会生成实例，这种特性被称为延迟初始化（Lazy initialization），这在一些初始化时消耗较大的情况有很大优势。</p><p>Lazy Singleton不是线程安全的，比如现在有线程A和线程B，都通过instance_ &#x3D;&#x3D; NULL的判断，那么线程A和B都会创建新实例。单例模式保证生成唯一实例的规则被打破了。</p><pre><code>instance_ = new Singleton;</code></pre><p>这条语句实际上做了三件事，</p><ul><li>第一件事申请一块内存</li><li>第二件事调用构造函数</li><li>第三件是将该内存地址赋给instance_</li></ul><p>但是不同的编译器表现是不一样的。可能先将该内存地址赋给instance_，然后再调用构造函数。这时线程A恰好申请完成内存，并且将内存地址赋给instance_，但是还没调用构造函数的时候。线程B执行到判断语句，判断instance_此时不为空，则返回该变量，然后调用该对象的函数，但是该对象还没有进行构造，会发生未定义异常。</p><h2 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h2><p>使用local static对象（函数内的static对象）。当第一次访问Instance()方法时才创建实例。</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            static Singleton instance；            return instance；        &#125;    private:        Singleton()；        ~Singleton()；        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);&#125;;</code></pre><p>这里需要注意的是，C++11以后，要求编译器保证内部静态变量的线程安全性，可以不加锁。但C++ 11以前，仍需要加锁。</p><h2 id="双检测锁模式（Double-Checked-Locking-Pattern）"><a href="#双检测锁模式（Double-Checked-Locking-Pattern）" class="headerlink" title="双检测锁模式（Double-Checked Locking Pattern）"></a>双检测锁模式（Double-Checked Locking Pattern）</h2><p>Lazy Singleton的一种线程安全改造是在Instance()中每次判断是否为NULL前加锁，但是加锁是很慢的。<br>而实际上只有第一次实例创建的时候才需要加锁。双检测锁模式被提出来，改造之后大致是这样</p><pre><code>static Singleton&amp; Instance()  &#123;    if (instance_ == NULL)     &#123;        Lock lock; //基于作用域的加锁，超出作用域，自动调用析构函数解锁        if (instance_ == NULL)        &#123;            instance_ = new Singleton;        &#125;    &#125;    return *instance_;&#125;</code></pre><p>既然只需要在第一次初始化的时候加锁，那么在这之前判断一下实例有没有被创建就可以了，所以多在加锁之前多加一层判断，需要判断两次所有叫Double-Checked。理论上问题解决了，但是存在内存读写reorder不安全，编译器优化可能先分配内存，把指针分配给instance_，最后new构造，可能存在线程在分配指针后没有构造的时候就返回*instance_。</p><p>在C++11中有全新的内存模型和原子库，可以很方便的用来实现DCLP。</p><h2 id="c-11-以后版本实现"><a href="#c-11-以后版本实现" class="headerlink" title="c++11 以后版本实现"></a>c++11 以后版本实现</h2><p><img src="/p/46132.htm/c++11%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png"></p><h2 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h2><p>在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，pthread_once是很适合用来实现线程安全单例。</p><pre><code>template&lt;typename T&gt;  class Singleton : boost::noncopyable  &#123;    public:        static T&amp; instance()        &#123;            pthread_once(&amp;ponce_, &amp;Singleton::init);            return *value_;        &#125;        static void init()        &#123;            value_ = new T();        &#125;    private:        static pthread_once_t ponce_;    static T* value_;&#125;;template&lt;typename T&gt;  pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template&lt;typename T&gt;  T* Singleton&lt;T&gt;::value_ = NULL;  </code></pre><p>这里的boost::noncopyable的作用是把构造函数, 赋值函数, 析构函数, 复制构造函数声明为私有或者保护。</p><h2 id="Eager-Singleton"><a href="#Eager-Singleton" class="headerlink" title="Eager Singleton"></a>Eager Singleton</h2><p>这种实现在程序开始(静态属性instance初始化)的时就完成了实例的创建。这正好和上述的Lazy Singleton相反。</p><p>头文件中</p><pre><code>class Singleton  &#123;    public:        static Singleton&amp; Instance()        &#123;            return instance;        &#125;    private:        Singleton();        ~Singleton();        Singleton(const Singleton&amp;);        Singleton&amp; operator=(const Singleton&amp;);    private:        static Singleton instance;&#125;</code></pre><p>实现文件中</p><pre><code>Singleton Singleton::instance;  </code></pre><p>由于在main函数之前初始化，所以没有线程安全的问题，但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 Instance()方法会返回一个未定义的实例。</p><h2 id="内存释放问题"><a href="#内存释放问题" class="headerlink" title="内存释放问题"></a>内存释放问题</h2><h3 id="单独的函数"><a href="#单独的函数" class="headerlink" title="单独的函数"></a>单独的函数</h3><p>不能在析构函数中使用delete instance__，这会导致一直析构和delete操作循环嵌套下去，应该单独生成一个释放内存的函数</p><pre><code>static void delInstance()&#123; // 为了多线程安全，释放操作也要做 double-check    if(m_pInstance != nullptr)     &#123;        std::lock_guard&lt;std::mutex&gt; lck(m_mutex);        if(m_pInstance != nullptr)         &#123;            delete m_pInstance;            m_pInstance = nullptr;        &#125;    &#125;        &#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>我们知道，进程结束时，静态对象的生命周期随之结束，其析构函数会被调用来释放对象。因此，我们可以利用这一特性，在单例类中声明一个内嵌类，该类的析构函数专门用来释放new出来的单例对象，并声明一个该类类型的static对象。<br><img src="/p/46132.htm/%E6%87%92%E6%B1%89%E5%BC%8F%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98.png"></p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>用智能指针来释放new出的内存是一种很省心的，内存释放方式，如OSG中的osg::ref_ptr<class t>(本人接触的第一种智能指针)，UE4中的TSharePtr<class t>。当然，这种方式同样也使用于对单例指针的释放.。不过使用智能指针往往会导致的一个问题就是我们无法去主动控制内存的释放，也不知道它什么时候就被释放掉了。偶尔指针越界也挺让人郁闷的，不过对于初学者来说确实是一种不错的选择。</class></class></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多其他大佬讲解的内容目前还不太明白，只能暂时摘录不懂的地方嵌入blog，未来会对本篇文章进行补充和完善。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>factory模式</title>
      <link href="/p/59316.html"/>
      <url>/p/59316.html</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为简单工厂模式，工厂方法模式和抽象工厂模式。</p><ul><li>简单工厂       Simple Factory</li><li>工厂方法       Factory Method</li><li>抽象工厂       Abstract Factory</li></ul><p><img src="/p/59316.htm/EasyFactoryUML.png"></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>示例：</p><p>步骤 1<br>创建一个接口。</p><pre><code>class Shape&#123;public:    virtual ~Shape()&#123;&#125;    virtual void draw() = 0;&#125;;</code></pre><p>步骤 2<br>创建实现接口的实体类</p><pre><code>class Circle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a circle&quot; &lt;&lt; std::endl;    &#125;&#125;;class Square:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a square&quot; &lt;&lt; std::endl;    &#125;&#125;;class Rectangle:public Shape&#123;public:    void draw() override &#123;        std::cout &lt;&lt;  &quot;draw a rectangle&quot; &lt;&lt; std::endl;    &#125;&#125;;</code></pre><p> 步骤 3<br>创建一个工厂，生成基于给定信息的实体类的对象。</p><pre><code>class ShapeFactory&#123;public:    std::shared_ptr&lt;Shape&gt; getShape(const std::string &amp; shapType)&#123;        if(shapType == &quot;Square&quot;)&#123;            return std::make_shared&lt;Square&gt;();        &#125;        else if(shapType == &quot;Circle&quot;)&#123;            return std::make_shared&lt;Circle&gt;();        &#125;         else if(shapType == &quot;Rectangle&quot;)&#123;            return std::make_shared&lt;Rectangle&gt;();        &#125;        return nullptr;    &#125;&#125;;</code></pre><p>步骤 4<br>使用该工厂，通过传递类型信息来获取实体类的对象。</p><pre><code>ShapeFactory factory;auto shape1 = factory.getShape(&quot;Circle&quot;);shape1-&gt;draw();auto shape2 = factory.getShape(&quot;Square&quot;);shape2-&gt;draw();auto shape3 = factory.getShape(&quot;Rectangle&quot;);shape3-&gt;draw();</code></pre><p>步骤 5<br>验证输出。</p><pre><code>draw a circledraw a squaredraw a rectangle</code></pre><p>特点：用户不需要具体关心实例是怎么创建的，只需要输入标识符就可以得到实例，但这种设计不符合开-闭原则，对修改和扩展都是开放的，增加对象类型和删除对象类型都需要重写这个接口。<br>就是把所有对象的创建都封装在了一个ShapeFactory类的getShape函数中，根据传入的参数，选择产生不同的对象，很明显，getShape这个函数做不到“开-闭”原则，即对原有代码修改关闭，对功能扩展开放，这个函数随着新对象的添加，或者原有对象的删除，都会导致该函数的代码修改，而且有可能影响原来的功能，所以这样的设计不能算完美。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Factory Method工厂方法是标准的OOP设计模式之一，主要解决了上面使用简单工厂遇到的问题。工厂方法为每一种产品提供相应的实例工厂进行对象创建，更符合实际的面向对象设计，比如说不同图形，肯定都有自己的绘图工具，每个图形都有自己的工厂在生产。</p><p>产品类型</p><pre><code>class Product&#123;public:    Product(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductA : public Product&#123;public:    ProductA(string name) :Product(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用老外高通芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class ProductB : public Product&#123;public:    ProductB(string name) :Product(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个使用自研麒麟芯片的手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>工厂基类</p><pre><code>class Factory&#123;public:    virtual Product* createProduct() = 0;&#125;;</code></pre><p>生产小米手机的工厂</p><pre><code>class XiaomiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 小米工厂肯定生产小米手机        return new ProductA(&quot;小米手机&quot;);    &#125;&#125;;</code></pre><p>生产华为手机的工厂</p><pre><code>class HuaweiFactory : public Factory&#123;public:    Product* createProduct()    &#123;        // 华为工厂肯定生产华为手机        return new ProductB(&quot;华为手机&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;Factory&gt; f1(new XiaomiFactory);    unique_ptr&lt;Factory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建产品    unique_ptr&lt;Product&gt; p1(f1-&gt;createProduct());    unique_ptr&lt;Product&gt; p2(f2-&gt;createProduct());    p1-&gt;show();    p2-&gt;show();    return 0;&#125;</code></pre><p>特点：仔细理解上面的工厂方法模式，会发现一个问题，就是每一个实例工厂负责生产一个实例产品，也就是一个产品对应一个工厂，一个工厂对应一个产品，那么小米不仅仅生产手机，还生产耳机，智能手环，智能插座等等相关的小米产品簇，不可能给这每一个产品都创建一个工厂类，那样的话代码中的类就太多了，不好维护，而且也不符合实际情况。<br>所以对于包含产品簇这么一类实体关系的设计，就需要使用Abstract Factory抽象工厂了，你也可以把上面的工厂方法看作只生产一种产品的抽象工厂，本质是相同的。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>经过上面内容的描述，抽象工厂其实就是解决产品簇的产品类设计的。</p><p>产品簇手机类型</p><pre><code>class ProductA&#123;public:    ProductA(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiPhone : public ProductA&#123;public:    XiaomiPhone(string name) :ProductA(name)&#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米手机:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiPhone : public ProductA&#123;public:    HuaweiPhone(string name) :ProductA(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个华为手机:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>产品簇智能手环类型</p><pre><code>class ProductB&#123;public:    ProductB(string name) :_name(name) &#123;&#125;    // 模拟产品对象的一个抽象方法    virtual void show() = 0;protected:    string _name;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class XiaomiCircle : public ProductB&#123;public:    XiaomiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;         cout &lt;&lt; &quot;获取了一个小米智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;     &#125;&#125;;</code></pre><p>产品实体类型定义</p><pre><code>class HuaweiCircle : public ProductB&#123;public:    HuaweiCircle(string name) :ProductB(name) &#123;&#125;    void show() &#123;        cout &lt;&lt; &quot;获取了一个华为智能手环设备:&quot; &lt;&lt; _name &lt;&lt; endl;    &#125;&#125;;</code></pre><p>抽象工厂，创建通过一个产品簇的设备产品</p><pre><code>class AbstractFactory&#123;public:    // 工厂里面创建手机的纯虚函数接口    virtual ProductA* createPhone() = 0;    // 工厂里面创建智能手环的纯虚函数接口    virtual ProductB* createSmartCircle() = 0;&#125;;</code></pre><p>生产小米产品簇的工厂</p><pre><code>class XiaomiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 小米工厂肯定生产小米手机        return new XiaomiPhone(&quot;小米x9&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 小米工厂肯定生产小米智能手环        return new XiaomiCircle(&quot;小米智能手环2代时尚版&quot;);    &#125;&#125;;</code></pre><p>生产华为产品簇的工厂</p><pre><code>class HuaweiFactory : public AbstractFactory&#123;public:    ProductA* createPhone()    &#123;        // 华为工厂肯定生产华为手机        return new HuaweiPhone(&quot;华为荣耀7x&quot;);    &#125;    ProductB* createSmartCircle()    &#123;        // 华为工厂肯定生产华为智能手环        return new HuaweiCircle(&quot;华为智能手环B3青春版&quot;);    &#125;&#125;;</code></pre><p>主函数</p><pre><code>int main()&#123;    // 使用智能指针自动释放堆内存    // 创建具体的工厂    unique_ptr&lt;AbstractFactory&gt; f1(new XiaomiFactory);    unique_ptr&lt;AbstractFactory&gt; f2(new HuaweiFactory);    // 通过工厂方法创建手机产品    unique_ptr&lt;ProductA&gt; p1(f1-&gt;createPhone());    unique_ptr&lt;ProductA&gt; p2(f2-&gt;createPhone());    p1-&gt;show();    p2-&gt;show();    // 通过工厂方法创建智能手环产品    unique_ptr&lt;ProductB&gt; p3(f1-&gt;createSmartCircle());    unique_ptr&lt;ProductB&gt; p4(f2-&gt;createSmartCircle());    p3-&gt;show();    p4-&gt;show();    return 0;&#125;</code></pre><p>可以看到，抽象工厂模式把一个产品簇的产品放在一个工厂类中去创建，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。<br>其实仔细想想，抽象工厂也存在一些问题，比如有的工厂生产某一种产品，但有的工厂它不生产该种产品（可能生产其它的产品），但由于都是从一个抽象工厂继承下来的，所以就会多继承一些无用的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号生成</title>
      <link href="/p/38710.html"/>
      <url>/p/38710.html</url>
      
        <content type="html"><![CDATA[<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1：</p><pre><code>输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p>示例 2：</p><pre><code>输入：n = 1输出：[&quot;()&quot;]</code></pre><p> </p><p>提示：</p><pre><code>1 &lt;= n &lt;= 8</code></pre><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p><strong>本弱鸡的解题思路</strong><br>暴力枚举加剪枝，如果右括号数量比左括号数量多，则进行剪枝，否则依次枚举添加左括号和添加右括号，如果左右括号数量相等，则只能添加左括号。当左括号数目为n，停止添加左括号，只添加右括号。当左右括号数量都为n，将其填入结果vector当中。</p><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt;ans;    vector&lt;string&gt; generateParenthesis(int n) &#123;        dfs(&quot;&quot;,n,n);        return ans;    &#125;    void dfs(string temp,int left,int right)&#123;        if(left==0&amp;&amp;right==0)&#123;            ans.push_back(temp);        &#125;        else&#123;            if(left!=0)&#123;                dfs(temp+&#39;(&#39;,left-1,right);            &#125;            if(left&lt;right)&#123;                dfs(temp+&#39;)&#39;,left,right-1);            &#125;        &#125;    &#125;&#125;;</code></pre><p>不论是时间还是空间花费都比较多<br><strong>执行用时：4 ms, 在所有 C++ 提交中击败了65.31%的用户<br>内存消耗：13.5 MB, 在所有 C++ 提交中击败了35.99%的用户</strong></p><h3 id="dfs（大佬做法）"><a href="#dfs（大佬做法）" class="headerlink" title="dfs（大佬做法）"></a>dfs（大佬做法）</h3><p><strong>代码如下</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        vector&lt;string&gt; res;        func(res, &quot;&quot;, 0, 0, n);        return res;    &#125;        void func(vector&lt;string&gt; &amp;res, string str, int l, int r, int n)&#123;        if(l &gt; n || r &gt; n || r &gt; l) return ;        if(l == n &amp;&amp; r == n) &#123;res.push_back(str); return;&#125;        func(res, str + &#39;(&#39;, l+1, r, n);        func(res, str + &#39;)&#39;, l, r+1, n);        return;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：14.6 MB, 在所有 C++ 提交中击败了22.09%的用户</strong></p><p>不清楚为什么时间效率会差这么多，感觉都要遍历同样多的节点数。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>解题思路</strong><br>可以把一个（）看作最小单位元进行处理，每次在最后一个（后面开始加入（），一直加到末尾，例如：<br>【（）】<br>【（（））】 【（）（）】<br>【（（（））） 】【（（）（））】 【（（））（）】 【（）（）（）】 【（）（（））】<br><strong>……</strong></p><p>10<br>1100 1010<br>111000 110100 110010 101100 101010<br>……</p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if(n == 1) return &#123;&quot;()&quot;&#125;;        vector&lt;string&gt; tmp = generateParenthesis(n - 1);        vector&lt;string&gt; res;        for(int i = 0; i &lt; tmp.size(); i ++)&#123;            int last = tmp[i].size() - 1;            while(tmp[i][last - 1] != &#39;(&#39;) last --;            for(int j = last; j &lt;= tmp[i].size(); j++)&#123;                res.push_back(&quot;&quot; + tmp[i]);                res.back().insert(j, &quot;()&quot;);            &#125;        &#125;                return res;    &#125;&#125;;</code></pre><p><strong>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户<br>内存消耗：7 MB, 在所有 C++ 提交中击败了98.07%的用户</strong></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>作者<a href="https://leetcode.cn/u/yuyu-13/">：yuyu-13</a><br>题解链接：<a href="https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">https://leetcode.cn/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a><br><strong>解题思路</strong></p><p>当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i&#x3D;n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。</p><p>那么，剩下 n-1 组括号有可能在哪呢？</p><p><strong>【这里是重点，请着重理解】</strong></p><p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p><p>既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：</p><p>“(“ + 【i&#x3D;p时所有括号的排列组合】 + “)” + 【i&#x3D;q时所有括号的排列组合】</p><p>其中 p + q &#x3D; n-1，且 p q 均为非负整数。</p><p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p><p><em>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</em></p><p><strong>代码：</strong><br><strong>具体代码如下：</strong>（<strong>时间击败百分之 95，内存击败百分之 99.65）</strong></p><pre><code>class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;        if (n == 0) return &#123;&#125;;        if (n == 1) return &#123; &quot;()&quot; &#125;;        vector&lt;vector&lt;string&gt;&gt; dp(n+1);        dp[0] = &#123; &quot;&quot; &#125;;        dp[1] = &#123; &quot;()&quot; &#125;;        for (int i = 2; i &lt;= n; i++) &#123;            for (int j = 0; j &lt;i; j++) &#123;                for (string p : dp[j])                    for (string q : dp[i - j - 1]) &#123;                        string str = &quot;(&quot; + p + &quot;)&quot; + q;                        dp[i].push_back(str);                    &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/generate-parentheses">https://leetcode.cn/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻宝大作战</title>
      <link href="/p/59129.html"/>
      <url>/p/59129.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p><p>某天，小 P 获得了一张神秘的藏宝图。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br>简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br>地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br>其中 A[i][j]&#x3D;1 表示坐标 (i,j) 处种有一棵树，A[i][j]&#x3D;0 则表示坐标 (i,j) 处没有树。<br>换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p><p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br>并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br>具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br>理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br>对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]&#x3D;B[i][j]。<br>当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p><p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br>请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p><p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]&#x3D;B[0][0]&#x3D;1，表示了宝藏埋藏的位置。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p><p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p><p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p><p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br>需要注意，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p><p><strong>样例 1 输入</strong></p><pre><code>5 100 20 01 12 23 34 40 0 10 1 01 0 0</code></pre><p><strong>样例 1 输出</strong></p><pre><code>3</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>对stl掌握的不好，只能用数组碰运气来做。浪费很多时间，最后只拿了200分，第三题本来可以骗几个用例分数的，，，，，我采用的是记录稀疏矩阵，然后根据横坐标纵坐标排序，最后采用O(n)枚举的暴力做法。代码又臭又长，如下所示（不看也罢）：</p><p> <strong>代码实现</strong></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */struct Zb&#123;    int x;    int y;&#125;zb[1050],cbt[60];int ss[60][60];int cmp(struct Zb a,struct Zb b)&#123;    if(a.x==b.x)&#123;        return a.y&lt;b.y;    &#125;    else return a.x&lt;b.x;    &#125;int main(int argc, char** argv) &#123;    int n,L,s ;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;L,&amp;s);    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;zb[i].x,&amp;zb[i].y);        &#125;        sort(zb,zb+n,cmp);        int t,count=0;        for(int i=s;i&gt;=0;i--)&#123;            for(int j=0;j&lt;=s;j++)&#123;                scanf(&quot;%d&quot;,&amp;ss[i][j]);                if(ss[i][j]==1)&#123;                    cbt[count].y=j;                    cbt[count].x=i;                    count++;                &#125;            &#125;        &#125;        sort(cbt,cbt+count,cmp);        int vcount =0;        for(int i=0;i&lt;n;i++)&#123;            int flag=0;            int k=i+1;            int countzb=0;            if(zb[i].x&gt;L-s||zb[i].y&gt;L-s)flag=1;            while(zb[k].x-zb[i].x&lt;=s&amp;&amp;k&lt;n)&#123;                if(abs(zb[k].x-zb[i].x)&lt;=s&amp;&amp;zb[k].y-zb[i].y&lt;=s&amp;&amp;zb[k].y-zb[i].y&gt;=0)&#123;                    if(ss[abs(zb[k].x-zb[i].x)][abs(zb[k].y-zb[i].y)]!=1)&#123;                        flag=1;                        break;                    &#125;                     countzb++;                &#125;                k++;            &#125;            if(countzb+1!=count)flag=1;            if(flag==0)&#123;                    vcount++;            &#125;        &#125;        printf(&quot;%d&quot;,vcount);     return 0;&#125;</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p>对于较大数据10^9，如果用二维数组vector的话无法开辟那么大空间，换成二维map来存储可以解决较大数据问题。解决好两个图的存储问题之后，接下来就是找到符合要求的可能埋有宝藏地点个数，无非就是两个条件：一是满足藏宝图可以在绿化图某块区域完美对上，二是满足藏宝图在绿化图中不出界。可以利用这两个条件去判断每一个符合条件的绿树点。如果两个条件都满足即有可能此处为藏宝点。<br><strong>代码实现</strong></p><pre><code>#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;cmath&gt;using namespace std;//pair&lt;int ,int&gt;和int对应map&lt;int,map&lt;int,int&gt; &gt;mp;struct node&#123;    int x,y;&#125;point[1001];int g[51][51];//地图int main()&#123;    int n,L,S;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;point[i].x&gt;&gt;point[i].y;        mp[point[i].x][point[i].y]=1;    &#125;    //输入也是一个坑    for(int i=S;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=S;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        int flag=1;        int x=point[i].x,y=point[i].y;        for(int j=0;j&lt;=S;j++)&#123;            for(int k=0;k&lt;=S;k++)&#123;                if(x+S&gt;L||y+S&gt;L||mp[x+j][y+k]!=g[j][k])&#123;                    flag=0;                    break;                &#125;            &#125;            if(!flag) break;        &#125;        if(flag) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;</code></pre><p><a href="https://blog.csdn.net/victory066/article/details/125819918">作者原文</a><br><a href="https://blog.csdn.net/victory066/article/details/125819918">https://blog.csdn.net/victory066/article/details/125819918</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金山训练营第一周</title>
      <link href="/p/23999.html"/>
      <url>/p/23999.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于C-编程的四大分类（结合Effective-C-的理解）"><a href="#关于C-编程的四大分类（结合Effective-C-的理解）" class="headerlink" title="关于C++编程的四大分类（结合Effective C++的理解）"></a>关于C++编程的四大分类（结合Effective C++的理解）</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>​    C++仍然是以C为基础。区块，语句，预处理器，内置数据类型，数组及其指针都来源于C，在大多数的时候，对C++语言的运用往往不过是较为高级的C语言解法</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>​    面向对象是C++语言最重要的特性之一，C++语言相对于C最重要的就是从面向过程的转换为面向对象的编程思维。C with Classes所诉求的部分：classes，封装，继承，多态，虚函数(virtual函数-动态绑定)</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>​    泛型编程。模板是在C++中与面向对象并列的另一大分支——泛型编程。所谓泛型编程，就是不依赖某一具体类型而使代码仍然具有很强适应性的编程范式。而我们所常用的STL则是泛型编程下的一大优秀案例</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>​    STL是一个template程序库，它对容器，迭代器，算法及其函数对象的规约有着极佳的紧密配合与协调</p><h2 id="C-相关基本信息"><a href="#C-相关基本信息" class="headerlink" title="C++相关基本信息"></a>C++相关基本信息</h2><h3 id="1-C-历史讲解"><a href="#1-C-历史讲解" class="headerlink" title="1.C++历史讲解"></a>1.C++历史讲解</h3><h4 id="前言：为什么要学C"><a href="#前言：为什么要学C" class="headerlink" title="前言：为什么要学C++"></a>前言：为什么要学C++</h4><ol><li>C++目前仍然是主要的流行语言之一</li><li>C++贴近OS&#x2F;硬件层，性能上限高</li><li>底层核心模块（OS，编译器，运行环境，大型软件等）通常由C++编写</li><li>应用场景十分广泛，图形引擎，音视频处理，仿真系统，高频交易</li><li>技术上线高（上至其他语言，下至逆向汇编）</li><li>WPS技术大佬基本都是C++出身，转型极快</li></ol><p><a href="https://imgse.com/i/vxifwq"><img src="https://s1.ax1x.com/2022/09/14/vxifwq.png" alt="vxifwq.png"></a></p><p><a href="https://imgse.com/i/vxi5kV"><img src="https://s1.ax1x.com/2022/09/14/vxi5kV.png" alt="vxi5kV.png"></a></p><p><a href="https://imgse.com/i/vxiIYT"><img src="https://s1.ax1x.com/2022/09/14/vxiIYT.png" alt="vxiIYT.png"></a></p><h3 id="2-VS中编译C-的方法"><a href="#2-VS中编译C-的方法" class="headerlink" title="2.VS中编译C++的方法"></a>2.VS中编译C++的方法</h3><p>编译流程：</p><p><a href="https://imgse.com/i/vxirY8"><img src="https://s1.ax1x.com/2022/09/14/vxirY8.png" alt="vxirY8.png"></a></p><h3 id="3-C与C-的区别"><a href="#3-C与C-的区别" class="headerlink" title="3.C与C++的区别"></a>3.C与C++的区别</h3><p>​    C语言作为程序化开发的语言，适合处理较小规模的程序。对于大规模程序，C语言并不合适</p><p>C语言的三个缺陷：</p><ol><li>不太严谨</li><li>名字冲突</li><li>作用域</li></ol><p>而现代C++语言可以看做是三部分组成的：</p><ul><li>低级语言，大部分继承自C语言</li><li>现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统</li><li>标准库（STL），它利用高级特性来提供有用的数据结构和算法</li></ul><p>思想对比</p><ul><li>面向过程——C语言</li><li>面向对象——C++</li><li>函数式编程——Javascript</li></ul><h2 id="C-的基本架构"><a href="#C-的基本架构" class="headerlink" title="C++的基本架构"></a>C++的基本架构</h2><h3 id="1-C-的默认架构"><a href="#1-C-的默认架构" class="headerlink" title="1.C++的默认架构"></a>1.C++的默认架构</h3><p>C++的默认架构一般为：头文件，域名空间，主函数</p><p><a href="https://imgse.com/i/vxiWmn"><img src="https://s1.ax1x.com/2022/09/14/vxiWmn.png" alt="vxiWmn.png"></a></p><h3 id="2-C-的头文件"><a href="#2-C-的头文件" class="headerlink" title="2.C++的头文件"></a>2.C++的头文件</h3><p>在之前所学的C语言中的表头文件为stdio.h，C++也是类似的，老版的C++库中也是类似，调用了iostream.h</p><p>但是，目前在新版的C++库中为了方便书写，已经把.h这样的风格给去掉了</p><p>需要我们注意的是，<strong>每个使用标准库设施的程序都必须包含相关的头文件</strong>，#include指令和头文件名字必须写在同一行中</p><p>通常情况下，#include指令必须出现在所有函数之外，我们<strong>一般将一个程序的所有#include指令都放在源文件的开始位置</strong></p><p>C++语言兼容C语言，标准C++程序库中是不带.h的，若是我们打算使用C语言的函数，可以在C语言的标准库头文件，推荐写法是去掉C语言头文件中的.h文件，在前面加上c，例如</p><pre><code class="C++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;</code></pre><h3 id="3-C-中的域名空间"><a href="#3-C-中的域名空间" class="headerlink" title="3.C++中的域名空间"></a>3.C++中的域名空间</h3><p>在实际大型的项目开发中，由于很多的功能模块，是由不同的人来编写的。因此，可能会出现A编写的函数名和B编写的函数名一样的情况。这样一来，我们的程序就会发生错误，只要我们每个人都定义自己的命名空间，就可以解决这一问题，即使函数重名，只要属于不同的命名空间就不会出现问题</p><p>注：当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突的情况。<strong>多个库将名字放置在全局命名空间中将引发命名空间污染（namespace pollution）</strong></p><p><strong>命名空间（namespace）为了防止名字冲突提供了更加可控的机制</strong>。命名空间分割了全局命名空间，其中的每一个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（及其用户）可以避免全局名字固有的限制</p><h4 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h4><p>一个命名空间的定义包含两部分：首先是关键字namespace ，随后是命名空间的名字，在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类，变量（及其初始化操作），函数（及其定义），模板和其他命名空间</p><pre><code class="C++">// 域名控件编码规范：全部小写namespace demospace &#123;    int x=100;        void output() &#123;        cout&lt;&lt;&quot;This is a namespace example!&quot;&lt;&lt;endl;    &#125;&#125;</code></pre><p>和其他名字一样，<strong>命名空间中的名字也必须在定义它的作用域内保持唯一</strong>。命名空间即可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部</p><p><strong>注：命名空间作用域后面无须分号</strong></p><p><strong>注意事项：</strong></p><ul><li>每个命名空间都是一个作用域</li><li>命名空间可以是不连续的<ul><li>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间，此时，命名空间的组织方式类似于我们管理自定义类和函数的方式</li></ul></li></ul><p>需要我们注意的一点是，在通常情况下，我们不把#include放在命名空间内部，如果我们一旦这么做了，隐含的意思就是把头文件中所有的名字定义成该命名空间的成员</p><p>命名空间中定义的成员可以直接使用名字，而无须前缀；命名空间之外定义的成员必须使用含有前缀的名字</p><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>全局命名空间中定义的名字（即在所有类，函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间中</strong>（global namespace）。全局命名空间以隐式的方式声明，并且在所有程序中都存在</p><p>作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字，如下形式：</p><pre><code>::member_name</code></pre><p>表示全局命名空间中的一个成员</p><h5 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h5><p>嵌套命名空间是指定义在其他命名空间中的命名空间</p><h5 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h5><p>未命名的命名空间（unnamed namespace）所指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁</p><p>注：和其他的命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件</p><p>目前为止，我们所用到的库函数基本上都属于命名空间std，而程序也显式地将这一点表示出来了</p><h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><p>如果我们使用了<strong>using声明</strong>，就可以更为简单地使用命名空间中的成员，即无须使用专门的前缀（形如命名空间::）也能使用所需的名字了</p><p>using声明具有如下的形式：</p><pre><code>using namespace::name;</code></pre><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><pre><code class="C++">#include&lt;iostream&gt;// using声明，当我们使用名字cin时，从命名空间std中获取它using std::cin;int main()&#123;    int i;    cin&gt;&gt;i;    std::cout&lt;&lt;i;    return 0;&#125;</code></pre><p>根据规定，每个using声明引入命名空间中的一个成员</p><h4 id="命名空间的using指示"><a href="#命名空间的using指示" class="headerlink" title="命名空间的using指示"></a>命名空间的using指示</h4><p><strong>using指示</strong>和using声明类似的地方是，我们可以使用命名空间名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的</p><p>using指示以关键字using开始，后面是关键字namespace以及命名空间的名字，例如：</p><pre><code>using namespace std;</code></pre><p>using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用域结束都能使用</p><h4 id="using指示与作用域（总结）"><a href="#using指示与作用域（总结）" class="headerlink" title="using指示与作用域（总结）"></a>using指示与作用域（总结）</h4><p>using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。</p><p>对于using声明来说，我们只是简单地令名字在局部作用域内有效</p><p>对于using指示来说，using指示是令整个命名空间的所有内容都变得有效</p><h3 id="4-C-中的输出函数"><a href="#4-C-中的输出函数" class="headerlink" title="4.C++中的输出函数"></a>4.C++中的输出函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p><a href="https://imgse.com/i/vxib6J"><img src="https://s1.ax1x.com/2022/09/14/vxib6J.png" alt="vxib6J.png"></a></p><p>C和C++语言中没有专门的输入输出语句。C语言中输入和输出由函数来使用，而C++中的输入和输出是通过流的方式来实现的</p><ul><li>标准输入（standard input）：cin</li><li>标准输出（standard output）：cout</li><li>标准出错（standard err）：cerr</li><li>流输出运算符：&lt;&lt;</li><li>流输入运算符：&gt;&gt;</li></ul><h4 id="C-中常用格式控制符"><a href="#C-中常用格式控制符" class="headerlink" title="C++中常用格式控制符"></a>C++中常用格式控制符</h4><ul><li>noshowbase——不生成表示进制的前缀</li><li>showbase ——对整型输出表示进制的前缀</li><li>dec——整型值显示为十进制</li><li>hex——整型值显示为十六进制</li><li>oct——整型值显示为八进制</li><li>fixed——浮点数显示为定点十进制</li><li>scientific——浮点值显示为科学计数法</li><li>setprecision(整数)——设置输出有效数字的个数，不包含小数点</li><li>ends——插入空字符，然后刷新ostream缓冲区</li><li>endl——插入换行，然后刷新ostream缓冲区</li></ul><h2 id="C-中的指针"><a href="#C-中的指针" class="headerlink" title="C++中的指针"></a>C++中的指针</h2><h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><h4 id="1-地址的概念"><a href="#1-地址的概念" class="headerlink" title="1.地址的概念"></a>1.地址的概念</h4><p>​    操作系统以32bit&#x2F;64bit的地址总线为基准，对内存单元以字节为单位进行编号，这个编号我们叫做内存地址</p><p><a href="https://imgse.com/i/vxigyj"><img src="https://s1.ax1x.com/2022/09/14/vxigyj.png" alt="vxigyj.png"></a></p><h4 id="2-基本内存操作"><a href="#2-基本内存操作" class="headerlink" title="2.基本内存操作"></a>2.基本内存操作</h4><ul><li>把数据写到内存中去</li><li>把内存中的数据读取出来</li></ul><h4 id="3-C-中分配内存的方法"><a href="#3-C-中分配内存的方法" class="headerlink" title="3.C++中分配内存的方法"></a>3.C++中分配内存的方法</h4><p>（1）定义变量</p><p>（2）通过malloc函数，动态分配内存</p><p><a href="https://imgse.com/i/vxihT0"><img src="https://s1.ax1x.com/2022/09/14/vxihT0.png" alt="vxihT0.png"></a></p><h4 id="4-C-中对内存读写的方法"><a href="#4-C-中对内存读写的方法" class="headerlink" title="4.C++中对内存读写的方法"></a>4.C++中对内存读写的方法</h4><p>（1）通过内存标识符（即变量名）</p><p>（2）通过内存地址，通过&amp;符号获得内存的首地址</p><p><a href="https://imgse.com/i/vxiHl4"><img src="https://s1.ax1x.com/2022/09/14/vxiHl4.png" alt="vxiHl4.png"></a></p><h4 id="5-C-中的两种变量"><a href="#5-C-中的两种变量" class="headerlink" title="5.C++中的两种变量"></a>5.C++中的两种变量</h4><p>关于变量：</p><p>​    变量提供一个具体的，可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算</p><p>​    对于C++程序员来说，“变量(variable)”和”对象(object)”一般可以互换使用</p><p>（1）普通变量</p><p>定义方法：数据类型    变量名</p><p>（2）指针变量</p><p>定义方法：数据类型*    变量名</p><p><a href="https://imgse.com/i/vxiX01"><img src="https://s1.ax1x.com/2022/09/14/vxiX01.png" alt="vxiX01.png"></a></p><h3 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h3><p>​    前提引入：<strong>复合类型</strong></p><p>复合类型是指基于其他类型定义的类型，以下将将C++语言中的两种复合类型：引用和指针</p><p>一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更为通用的描述是，<strong>一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成</strong></p><h4 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h4><p>拓展：C++11新标准中新增了一种引用：所谓的“右值引用”，指针引用主要用于内置类；</p><p>严格来说，当我们使用术语“引用”时，指的其实是“左值引用”</p><p><strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名</p><p>当我们定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起</p><p>注：引用并非对象，相反的，它只是为了一个已经存在的对象所起的另外一个名字</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针是“指向”另外一种类型的复合类型。指针与引用不同之处在于，指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，且指针无须在定义时赋初值。</p><p>注：在32位的操作系统中，所有的指针变量都是4个字节</p><p><a href="https://imgse.com/i/vxiOmR"><img src="https://s1.ax1x.com/2022/09/14/vxiOmR.png" alt="vxiOmR.png"></a></p><p>指针存放着某个对象的地址，要想获取该地址，需要使用取地址符(操作符&amp;)：</p><pre><code class="c++">int val = 42;int* p = &amp;val; // p存放变量val的地址，或者说p是指向变量val的指针</code></pre><p>需要我们注意的是，引用不是对象，没有实际的地址，所以我们不能定义指向引用的指针</p><p><strong>指针的类型要与它所指向的对象严格匹配</strong>（有例外）</p><h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h5><p>​    指针的值（即地址）应属下列4种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象</li><li>无效指针，也就是上述情况之外的其他值（一般这种情况下，指针被称为野指针）</li></ol><p>注意：试图拷贝或以其他方式访问无效指针的值都将引发错误</p><h4 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h4><p>​    如果指针指向了一个对象(重要前提)，则允许使用<strong>解引用符</strong>(操作符*)来访问对象：</p><pre><code class="C++">int val = 42;int* p =&amp;val; // p存放着变量val的地址，或者说p是指向变量val的指针cout&lt;&lt;*p;    // 由符号*得到指针p所指的对象，输出对应的值42</code></pre><p>对指针解引用会得出所指的对象，因此<strong>如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值</strong></p><p>注：解引用操作仅适用于那些确实指向某个对象的有效指针</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>​    <strong>空指针</strong>（null pointer）不指向任何对象，在试图适用一个指针之前的代码可以首先检查它是否为空</p><pre><code class="C++">int *p1 = nullptr; // 等价于int *p1 = 0;int *p2 = 0;        // 直接将p2初始化为字面常量0// 需要首先#include&lt;cstdlib&gt;int *p3 = NULL;    // 等价于int *p3 = 0;</code></pre><p>得到空指针最直接的办法就是字面值nullptr来初始化指针，这也是C++11新标准引入的一种方法。</p><p>nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型</p><p>在之前的程序中还会用到一个名为NULL的预处理变量来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0</p><p><strong>拓展</strong>：（1）NULL为预处理变量（2）预处理器是运行于编译过程之前的一段程序（3）预处理变量不属于命名空间std，它由预处理器负责</p><p>当用到一个预处理变量时，预处理器会自动地将它们替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的</p><p><strong>在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL</strong></p><p><strong>指针使用建议：初始化所有指针</strong></p><h4 id="关于CPU的两种存储模式"><a href="#关于CPU的两种存储模式" class="headerlink" title="关于CPU的两种存储模式"></a>关于CPU的两种存储模式</h4><p>大端模式：高地址存储数据的低位，低地址存储数据的高位</p><p>小端模式：低地址存储数据的低位，高地址存储数据的高位</p><p><a href="https://imgse.com/i/vxisfS"><img src="https://s1.ax1x.com/2022/09/14/vxisfS.png" alt="vxisfS.png"></a></p><h4 id="C语言中数据类型决定指针变量的寻址范围"><a href="#C语言中数据类型决定指针变量的寻址范围" class="headerlink" title="C语言中数据类型决定指针变量的寻址范围"></a>C语言中数据类型决定指针变量的寻址范围</h4><p>​    通过不同的数据类型指针变量，对同一块内存进行操作的时候，一次读取数据的字节数不一样</p><pre><code class="C++">int* p1; // 一次操作4个字节short* p2; // 一次操作2个字节char* p3; // 一次操作1个字节</code></pre><p>指针变量在移动的时候，每次移动的大小为指向对象数据类型的大小</p><h3 id="一级指针和字符串"><a href="#一级指针和字符串" class="headerlink" title="一级指针和字符串"></a>一级指针和字符串</h3><p>示例：</p><pre><code class="c++">char buf[100] = &quot;WPS&quot;;char* s = &quot;WPS&quot;;buf[0] = &#39;X&#39;; // 正确s[0] = &#39;X&#39;;   // 错误</code></pre><p>结论：</p><ol><li>定义数组保存字符串的时候，字符串保存在栈区，栈区的内存有读写权限</li><li>定义指针保存字符串的时候，指针保存的是字符串的首地址。字符串存放到常量区，常量区是系统单独分配的一块内存，在这个区域字符串只能进行读操作，不能进行写操作</li></ol><p><a href="https://imgse.com/i/vxi6Sg"><img src="https://s1.ax1x.com/2022/09/14/vxi6Sg.png" alt="vxi6Sg.png"></a></p><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p>函数中使用指针的场景：</p><ol><li>当需要存储的数据内存过大（结构体或者数组），传递指针可以节省内存空间，从而减少所需的拷贝时间：</li></ol><p>例如输出数组的信息：</p><p><a href="https://imgse.com/i/vxi7pF"><img src="https://s1.ax1x.com/2022/09/14/vxi7pF.png" alt="vxi7pF.png"></a></p><p>2.需要在函数内计算某个数据，在函数内出参</p><p>例如基本的计算：</p><p><a href="https://imgse.com/i/vxiqX9"><img src="https://s1.ax1x.com/2022/09/14/vxiqX9.png" alt="vxiqX9.png"></a></p><h2 id="C-新语法"><a href="#C-新语法" class="headerlink" title="C++新语法"></a>C++新语法</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载函数（overload）——同一作用域内几个函数名字相同但形参列表不同</p><p>注：main函数不能重载</p><p>对于重载函数来说，它们应该在形参数量或形参类型上有所不同，<strong>不允许两个函数除了返回类型外其他所有要素都相同</strong></p><pre><code class="C++">int lookup(const Account&amp;);bool lookup(const Account&amp;); // 错误：与上一个函数相比只有返回类型不同</code></pre><p><strong>函数重载规则：</strong></p><ul><li>函数名称必须相同</li><li>参数列表必须不同（个数不同，或类型不同，参数排列顺序不同等）</li><li>函数返回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为函数的重载</li></ul><h4 id="判断两个形参的类型是否"><a href="#判断两个形参的类型是否" class="headerlink" title="判断两个形参的类型是否"></a>判断两个形参的类型是否</h4><p>有时候两个形参列表看起来不一样，但实际上是相同的：</p><pre><code class="C++">// 每对声明的是同一函数int lookup(const string &amp;message);int lookup(const string&amp;); // 省略了形参的名字typedef double dou;int lookup(const double&amp;);int lookup(const dou&amp;);       // 二者类型相同</code></pre><h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>​    一个拥有顶层const的形参无法和另一个没有顶层const的形参区别开来：</p><pre><code class="c++">int lookup（string);int lookup(const string); // 重复声明</code></pre><p>另一方面，<strong>如果形参是某种类型的指针或引用，则通过区别其指向的是常量对象还剩非常量对象可以实现函数重载，此时的const是底层的：</strong></p><pre><code class="C++">// 对于接收引用或指针的函数来说，对象是常量还是非常量对应的形参不同// 定义了4个独立的重载函数int lookup(string&amp;); // 函数作用于string的引用int lookup(const string&amp;); // 新函数，作用于常量引用int lookup(string*); // 新函数，作用于指向string的指针int lookup(const string*); // 新函数，作用于指向常量的指针</code></pre><p>注：当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</p><h4 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h4><p>​    定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配</strong>是指一个过程，在这个过程中我们把函数调用于一组重载函数中的某一关联起来，函数匹配也叫<strong>重载确定</strong>。编译器首先将调用的实参于重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数</p><p>​    当调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参<strong>最佳匹配</strong>的函数并生成调用该函数的代码</li><li>找不到任何一个函数与调用实参匹配，此时编译器发出<strong>无匹配</strong>的错误信息</li><li>有多于一个函数可以匹配，但每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong></li></ul><h3 id="栈堆内存分配"><a href="#栈堆内存分配" class="headerlink" title="栈堆内存分配"></a>栈堆内存分配</h3><h4 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h4><p>​    申请内存：void* malloc(unsigned size);</p><p>​    释放内存：void free();</p><p><a href="https://imgse.com/i/vxi2Os"><img src="https://s1.ax1x.com/2022/09/14/vxi2Os.png" alt="vxi2Os.png"></a></p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>​    new&#x2F;delete，是一个C++中堆区内存分配的运算符</p><p>​    new——向堆申请空间</p><p>​    delete——释放堆区的空间</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p><a href="https://imgse.com/i/vxiofU"><img src="https://s1.ax1x.com/2022/09/14/vxiofU.md.png" alt="vxiofU.md.png"></a></p><h5 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h5><ol><li>malloc&#x2F;free是C语言中提供的库函数，new&#x2F;delete是C++中的运算符</li><li>malloc可以在堆区分配空间，但是返回值是void*指针，使用要强制转换；而new&#x2F;delete使用的时候，系统的调度资源少一些。直接通过指针连接回收</li><li>new&#x2F;delete申请对象空间的时候，会调用对象的构造函数和析构函数，而malloc不会调用</li></ol><p>示例代码：</p><p><a href="https://imgse.com/i/vxiclQ"><img src="https://s1.ax1x.com/2022/09/14/vxiclQ.png" alt="vxiclQ.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/p/59828.html"/>
      <url>/p/59828.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: [10,2]输出: &quot;102&quot;</code></pre><p>示例 2:</p><pre><code>输入: [3,30,34,5,9]输出: &quot;3033459&quot;</code></pre><p> </p><p>提示:</p><pre><code>0 &lt; nums.length &lt;= 100</code></pre><p>说明:</p><pre><code>输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>这里的神来之笔是return a+b&lt;b+a这个操作，巧妙的对数组进行排列。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    string minNumber(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;string&gt;snum;        string res;        for(auto num:nums)&#123;            snum.push_back(to_string(num));        &#125;        sort(snum.begin(),snum.end(),cmp);        for(auto s:snum)&#123;            res+=s;        &#125;        return res;    &#125;    static bool cmp(const string&amp;a,const string b)&#123;        return a+b&lt;b+a;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同构字符串</title>
      <link href="/p/20114.html"/>
      <url>/p/20114.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给定两个字符串 s 和 t ，判断它们是否是同构的。如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入：s = &quot;egg&quot;, t = &quot;add&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;foo&quot;, t = &quot;bar&quot;输出：false</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;paper&quot;, t = &quot;title&quot;输出：true</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 5 * 104t.length == s.lengths 和 t 由任意有效的 ASCII 字符组成</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>创建两个桶数组，然后分别存放该字符出现的位置，如果产生冲突就返回false。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/isomorphic-strings">https://leetcode.cn/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组游戏</title>
      <link href="/p/64084.html"/>
      <url>/p/64084.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。小猫咪表示“我太难了”你能帮帮它么?</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>输入说明：</p><pre><code>会有多组询问首先输入一个数字t (1&lt;=t&lt;=10)接下来有t组数据每组数据里，首先会有一个数n，表示接下来这个数列的长度为n然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><p>输出描述:</p><pre><code>对于每一个提问，请依次输出最多可以选取多少个数</code></pre><p>备注:</p><pre><code>每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题目相对比较简单，注意从左到右依次取，并且取的过程中sum一直非负，而不是最后sum非负，<br>思路:</p><pre><code>从左到右依次遍历，遇到正数或者零直接选，遇到负数则分两种情况，情况1:选了之后sum &gt;= 0，那么直接选。情况2︰选了之后sum &lt; ，那么从已经选择的负数中置换出一个最小的。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main() &#123;    int t;cin &gt; t;    while(t--)&#123;        int n;        while (cin &gt;&gt;n) &#123;            vector&lt;int&gt; nums(n);            for(auto &amp;e : nums) cin &gt;&gt; e;            LL sum = e, cnt = e;            priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;            for(auto &amp;e : nums)&#123;                if(e &gt;= e) &#123;//遥到正数直接选                    sum += e;                    cnt+t;                &#125;                else &#123;                    if(sum + e &gt;= e)&#123;//情况                        sum += e;                        pq.push(e);cnt++;                    &#125;                    else &#123; //情况                        pq. push(e);                        sum += e;                        sum -= pq.top();                        pq. pop();                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; cnt &lt;&lt; endl;    &#125;    return e;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/p/63859.html"/>
      <url>/p/63859.html</url>
      
        <content type="html"><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>全排列 一般把1~ n 这 n 个整数按某个顺序摆放的结果称为这 n 个整数的一个排列，而全排列指这 n 个整数能形成的所有排列。<br>例如对1、2、3这三个整数来说，(1,2,3)、(1,3,2)、(2,1,3)、(2,3,1 、(3,1,2)、(3,2, I ）就是1<del>3的全排列。<br>从递归的角度去考虑，如果把问题描述成“输出1</del> n 这 n 个整数的全排列”，那么它就可以被分为若干个子问题：“输出以1开头的全排列”“输出以2开头的全排列”…“输出以 n 开头的全排列”。于是不妨设定一个数组 P ，用来存放当前的排列；再设定一个散列数组 hash Table ，其中 hashTable [ x ］当整数 x 已经在数组 P 中时为 true 。<br>现在按顺序往 P 的第1位到第 n 位中填入数字。不妨假设当前已经填好了 P [1]~ P [ index -1]，正准备填 P [ index ]。显然需要枚举1~ n ，如果当前枚举的数字 x 还没有在 P [1]~ P [ index -1］中（即 hashTable [ x ]&#x3D; false )，那么就把它填入 P [ index ]，同时将 hashTable [ x ］置为 true ,然后去处理 P 的第 Tndex +1位（即进行递归）；而当递归完成时，再将 hashTable [ x ］还原为 false ,以便让 P [ index ］填下一个数字。<br>当 index 达到 n +1时，说明 P 的第1~ n 位都已经填好了，此时可以把数组 P 输出，表示生成了一个排列，然后直接 return 即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    # include &lt; cstdio &gt;    const int maxn =1l;    //P为当前排列， hashTable 记录整数 x 是否已经在 P 中     int n , P [maxn], hashTable[maxn]=&#123;false&#125;;    //当前处理排列的第 index 号位    void generateP ( int index )&#123;        if ( index = n +1)&#123;//递归边界，已经处理完排列的1~ n 位            for ( int i = 1 ; i &lt;= n ; i ++)&#123;                printf (&quot;%d&quot;, P [ i ]);//输出当前排列            &#125;            printf (&quot;\n &quot;);            return ;        &#125;        for ( int ×=1;×&lt;= n ;×++)&#123;//枚举1~ n ，试图将×填入 P [ index ]            if ( hashTable [ x ]== false )&#123;//如果×不在P[0]~P [index-1］中             P [ index ]= X ;//令 P 的第 index 位为×，即把×加入当前排列             hashTable [ x ]= true ;//记 x 已在 P 中            generateP ( index +1);//处理排列的第 index +1号位            hashTable [ x ]= false ;//已处理完 P [ index ］为×的子问题，还原状态            &#125;        &#125;    &#125;    int main ()&#123;        n =3;//欲输出1~3的全排列        generateP (1);//从 P [1］开始填         return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期差值</title>
      <link href="/p/1868.html"/>
      <url>/p/1868.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>求出两个日期之间的相差的天数，相邻日期算两天</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>示例 1:    输入: 20200111         20200112    输出: 2 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一道比较简单的题，只要月份天数闰年平年，注重细节就好了，记录这道题仅仅是熟悉一个思路比较清晰的方法。</p><p>不妨假设第一个日期早于第二个日期（否则交换即可)。<br>这种求日期之间相差天数的题目有一个很直接的思路，即令日期不断加1天，直到第一个日期等于第二个日期为止，即可统计出答案。具体处理时，如果当加了一天之后天数d等于当前月份m所拥有的天数加1，那么就令月份m加1、同时置天数d为1号（即把日期变为下一个月的1号);如果此时月份m变为了13，那么就令年份y加1、同时置月份m为1月（即把日期变为下一年的1月)。<br>为了方便直接取出每个月的天数，不妨给定一个二维数组int month[13][2]，用来存放每个月的天数，其中第二维为0时表示平年，为1时表示闰年。<br>注意:如果想要加快速度，只需要先把第一个日期的年份不断加1，直到与第二个日期的年份相差1为止，期间根据平年或是闰年来累加365天或者366天即可。之后再进行不断令天数加1的操作。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #include &lt;cstdio&gt;    int month[13][2] =&#123; //平年和闰年的每个月的天数    &#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,    &#123;31, 31&#125;,&#123;31,31&#125;, &#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;    &#125;    bool isLeap(int year) &#123;//判断是否是闰年        return (year % 4== 0 &amp;&amp; year % 100 = 0) &amp;&amp;(year % 400== 0);    &#125;    int main() &#123;        int timel, yl,ml,dl;        int time2, y2,m2,d2;        while(scanf( &quot;%d%d&quot;,&amp;timel,&amp;time2) !=EOF)&#123;            if(time1 &gt;time2)&#123; 1/第一个日期晚于第二个日期,则交换                int temp=timel;                timel = time2;                time2 = temp;            &#125;            y1 = time1 / 10000, ml = time1 % 10000 / 100,d1 = timel % 100;            y2 = time2 / 10000, m2 = time2 % 10000 / 100,d2 = time2 % 100;            int ans =1;//记录结果            //第一个日期没有达到第二个日期时进行循环            //即!((y1 == y2) &amp;&amp; (ml == m2) &amp;&amp;(d1 == d2))            while(yl&lt; y2 || ml&lt; m2 || d1&lt;d2)&#123;                d1++;//天数加1                if(d1 == month [m1] [isLeap(y1)] +1)&#123;//满当月天数                    m1++;//日期变为下个月的1号                    dl =1;                &#125;                if(m1 ==13) &#123; //月份满12个月                    y1++;//日期变为下一年的1月m1=1;                &#125;                ans++;//累计            &#125;        &#125;    return 0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="/p/61401.html"/>
      <url>/p/61401.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一-暴力法"><a href="#一-暴力法" class="headerlink" title="一 暴力法"></a>一 暴力法</h4><pre><code>—略—</code></pre><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><pre><code>其实这道题很明显就满足最优子结构性，如果想用最少的硬币兑换money，这对硬币的子集的总金额所需硬币数一定是最少的，否则用更少的硬币替换这个子集的硬币，则总money所需硬币数一定比原来少。现在的问题是如何获得状态方程。假设硬币的金额有m1,m2...mx,需要兑换的总金额为money，金额为money的硬币数存在f[money]中，那么f[money]一定可以由f[money-m1]+1,f[money-m2]+1...f[money-mx]+1中的一个或者多个组成，上面已经说明最优子结构，这样，我们只需要找f[money-m1],f[money-m2]...f[money-mx]中的最小值。问题不断分解，分解到f[m1],f[m2]...f[mx]这些确定值上面（都为1）。按照这个思路，我们反向进行迭代最终就可以求得f[money];    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int Max = amount + 1;        vector&lt;int&gt; dp(amount + 1, Max);        dp[0] = 0;        for (int i = 1; i &lt;= amount; ++i) &#123;            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;                if (coins[j] &lt;= i) &#123;                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &gt; amount ? -1 : dp[amount];    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/">https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/p/58639.html"/>
      <url>/p/58639.html</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，常常拥有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有的原因而无法和任务的整体结构同时实现。<br>我们希望能够在稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义了一组同类型的算法，在不同的类中封装起来，每种算法可以根据当前场景相互替换，从而使算法的变化独立于使用它们的客户端（即算法的调用者）</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>小王同学的爷爷老王刚开始使用电脑，看着电脑里的各种格式.txt、docx、jpg，瞬间眼花缭乱，身为c++程序员出身的小王，立马拍着胸脯说要给爷爷写个程序，通过程序去自动的打开各种格式文件<br>小王打开电脑，三下五除二就把程序写好了</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG&#125;;class filemanager&#123;    public:    void opentxtfile()&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;    void opendocxfile()&#123;        std::cout&lt;&lt;&quot;word is opened&quot;&lt;&lt;std::endl;    &#125;    void openjpgfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;    void openpngfile()&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;int main()&#123;    FILETYPE openfiletype=FILETYPE::TXT;    filemanager file;    switch (openfiletype)&#123;    case FILETYPE::TXT:        file.opentxtfile();        break;    case FILETYPE::DOCX:        file.opendocxfile();        break;    case FILETYPE::JPG:        file.openjpgfile();        break;    case FILETYPE::PNG:        file.openpngfile();        break;        default:        break;    &#125; &#125;</code></pre><p>爷爷选择了一个txt文件，文件就打开了，爷爷笑靥如花，小王仰起了骄傲的头~<br>过了两天，爷爷给小王打电话，说.avi的视频文件打不开<br>于是小王不得不修改了枚举类</p><pre><code>enum class FILETYPE&#123;    TXT,    DOCX,    JPG,    PNG,    avi&#125;;</code></pre><p>然后又修改了switch case</p><pre><code>case FILETYPE::avi:        file.openavifile();        break;</code></pre><p>随着增加格式越来越多.xlsx .mp3 .mp4 …. switch case 越来越长，而且每次修改的地方较多，一不小心会引起其他bug，小王终于受不了了，买了一本设计模式的书~</p><p>初步优化，小王使用策略模式：<br>抽出open接口</p><pre><code>class openinterface&#123;    public:    virtual void open()=0;    virtual ~openinterface()&#123;&#125;&#125;;</code></pre><p>定义各种文件的实现</p><pre><code>//txt fileclass textfile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;txt is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;//jpg fileclass jgpfile:public openinterface&#123;public:    void open() override&#123;        std::cout&lt;&lt;&quot;jpg is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>引入管理类</p><pre><code>class openfilemanager&#123;public:    openfilemanager(openinterface* pOpen)&#123;        _pOpen=pOpen;    &#125;    void openfile()&#123;        _pOpen-&gt;open();    &#125;    ~openfilemanager()&#123;        if(_pOpen) delete _pOpen;    &#125;private:    openinterface* _pOpen;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    FILETYPE currentfiletype=FILETYPE::TXT;    if(currentfiletype==FILETYPE::TXT;)&#123;        openfilemanager* pmanager=new openfilemanager(new textfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    if(currentfiletype==FILETYPE::JPG)&#123;        openfilemanager* pmanager=new openfilemanager(new jgpfile);        pmanager-&gt;openfile();        delete pmanager;    &#125;    return 0;&#125;</code></pre><p>通过这一步的优化，程序可维护性好了，再增加新功能不会对旧功能产生影响，这就是策略模式~但是 switch case 并没有减少，而且枚举也存在，小王还是不满意</p><p>针对这个例子：<br>修改openfilemanager， 增加个map，程序启动的时候加载到内存里</p><pre><code>class openfilemanager&#123;public:    void add(std::string key,openinterface* pFile)&#123;        _filemap.insert(std::make_pair(key,pFile));    &#125;    void openfile(std::string filetype)&#123;        _filemap[filetype]-&gt;open();    &#125;    ~openfilemanager()&#123;        for(auto iter=_filemap.begin();iter!=_filemap.end();iter++)&#123;            delete iter-&gt;second;        &#125;    &#125;private:    std::unordered_map&lt;std::string,openinterface*&gt; _filemap;&#125;;</code></pre><p>main函数</p><pre><code>int main()&#123;    //init    openfilemanager filemanager;    filemanager.add(&quot;txt&quot;,new textfile);    filemanager.add(&quot;jpg&quot;,new jgpfile);    //open file    filemanager.openfile(&quot;txt&quot;);    return 0;&#125;</code></pre><p>爷爷又来电话，说想打开.pdf文件，小王剑指如飞，增加了如下类</p><pre><code>class pdffile:public openinterface&#123;    public:    void open() override&#123;        std::cout&lt;&lt;&quot;pdf is opened&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><p>初始化的时候增加pdf</p><pre><code>openfilemanager filemanager;     filemanager.add(&quot;txt&quot;,new textfile);     filemanager.add(&quot;jpg&quot;,new jgpfile);filemanager.add(&quot;pdf&quot;,new pdffile);</code></pre><p>小王没一会功夫就把程序交给了爷爷，嘿嘿一笑，深藏功与名</p><h2 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h2><p>Strategt类，定义所有支持的算法的公共接口</p><pre><code>class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;</code></pre><p>ConcreteStrategy 封装了具体的算法或行为，继承Strategy</p><pre><code>class ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;</code></pre><p>Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用</p><pre><code>class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;</code></pre><p>整份代码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define free_ptr(p) if(p) delete p; p = nullptr;//Strategt类，定义所有支持的算法的公共接口class Strategy &#123;public:    virtual ~Strategy() &#123;&#125;;    virtual void AlgorithmInterface() = 0;&#125;;//ConcreteStrategy 封装了具体的算法或行为，继承Strategyclass ConcreteStrategyA : public Strategy&#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法A实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyB : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法B实现&quot; &lt;&lt; endl;    &#125;&#125;;class ConcreteStrategyC : public Strategy &#123;    void AlgorithmInterface() &#123;        cout &lt;&lt; &quot;算法C实现&quot; &lt;&lt; endl;    &#125;&#125;;//Context,用一个ConcreteStrategy来配置,维护一个对Strategy的引用class Context &#123;public:    Context(Strategy* strategy) : m_strategy(strategy) &#123;&#125;;    ~Context() &#123; free_ptr(m_strategy); &#125;    void AlgorithmInterface() &#123;        m_strategy-&gt;AlgorithmInterface();    &#125;;private:    Strategy* m_strategy;&#125;;int main() &#123;    Strategy* concreteStrategyA = new ConcreteStrategyA();    Strategy* concreteStrategyB = new ConcreteStrategyB();    Strategy* concreteStrategyC = new ConcreteStrategyC();    concreteStrategyA-&gt;AlgorithmInterface();    concreteStrategyB-&gt;AlgorithmInterface();    concreteStrategyC-&gt;AlgorithmInterface();    free_ptr(concreteStrategyA);    free_ptr(concreteStrategyB);    free_ptr(concreteStrategyC);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/p/47718.html"/>
      <url>/p/47718.html</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况发⽣。使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域时，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。</p><p><strong>注意！！！智能指针没有从根本上解决了c++内存安全的问题</strong></p><h2 id="常⽤接⼝"><a href="#常⽤接⼝" class="headerlink" title="常⽤接⼝"></a>常⽤接⼝</h2><pre><code>T* get();T&amp; operator*(); T* operator-&gt;();T&amp; operator=(const T&amp; val);T* release();void reset (T* ptr = nullptr);</code></pre><ul><li>T 是模板参数, 也就是传⼊的类型；</li><li>get() ⽤来获取 <strong>auto_ptr</strong> 封装在内部的指针, 也就是获取原⽣指针；</li><li>operator() 重载 , operator-&gt;() 重载了-&gt;, operator&#x3D;()重载了&#x3D;；</li><li>realease() 将 <strong>auto_ptr</strong> 封装在内部的指针置为 nullptr, 但并不会破坏指针所指向的内容, 函数返回的是内部指针置空之前的值；</li><li>直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值,  则将内部指针初始化为该值 (否则将其设置为nullptr；<h2 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h2></li></ul><p><strong>1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</strong></p><pre><code>auto_ptr&lt;std::string&gt; p1 (new string (&quot;hello&quot;));auto_ptr&lt;std::string&gt; p2;p2 = p1; //auto_ptr 不会报错.</code></pre><p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 <strong>auto_ptr</strong> 的缺点是：存在潜在的内存崩溃问题！</p><p><strong>2、unique_ptr（替换 <strong>auto_ptr</strong> ）</strong><br><strong>unique_ptr</strong> 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。<br>采⽤所有权模式，还是上⾯那个例⼦</p><pre><code>unique_ptr&lt;string&gt; p3 (new string (auto));unique_ptr&lt;string&gt; p4;p4 = p3;//此时会报错</code></pre><p>编译器认为 p4&#x3D;p3 ⾮法，避免了 p3 不再指向有效数据的问题。因此，<strong>unique_ptr</strong> ⽐ <strong>auto_ptr</strong> 更安全。</p><p><strong>3、shared_ptr（共享型，强引⽤）</strong><br><strong>shared_ptr</strong>实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。<br>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊<strong>auto_ptr</strong>, <strong>unique_ptr</strong>,<strong>weak_ptr</strong> 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。<br><strong>shared_ptr</strong> 是为了解决 <strong>auto_ptr</strong> 在对象所有权上的局限性 (<strong>auto_ptr</strong> 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。</p><p><strong>4、weak_ptr（弱引⽤）</strong><br><strong>weak_ptr</strong> 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 <strong>shared_ptr</strong> 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 <strong>shared_ptr</strong>。<br><strong>weak_ptr</strong> 只是提供了对管理对象的⼀个访问⼿段。<strong>weak_ptr</strong> 设计的⽬的是为配合 <strong>shared_ptr</strong> ⽽引⼊的⼀种智能指针来协助 <strong>shared_ptr</strong> ⼯作，它只可以从⼀个 <strong>shared_ptr</strong> 或另⼀个 <strong>weak_ptr</strong> 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。<br><strong>weak_ptr</strong> 是⽤来解决 <strong>shared_ptr</strong> 相互引⽤时的死锁问题，如果说两个 <strong>shared_ptr</strong> 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数， 和 <strong>shared_ptr</strong> 之间可以相互转化，<strong>shared_ptr</strong> 可以直接赋值给它，它可以通过调⽤ lock 函数来获得 <strong>shared_ptr</strong>。<br>当两个智能指针都是 <strong>shared_ptr</strong> 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为<strong>weak_ptr</strong>就可以。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>具体请查看<a href="https://whl963854.github.io/p/39842.html">unique_ptr</a>;</p><h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nullptr</title>
      <link href="/p/1199.html"/>
      <url>/p/1199.html</url>
      
        <content type="html"><![CDATA[<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。在某种意义上来说，传统 C++ 会把 NULL、 0 视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。<br>C++ 不允许直接将 void * 隐式转 换到其他类型，但如果NULL 被定义为 ((void*)0)，那么当编译 char *ch &#x3D; NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导致了 C++ 中重载特性 会发⽣混乱，考虑：<br>    void func(int);<br>    void func(char *);<br>对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL) 这个语句将 会去调⽤ func(int)，从⽽导致代码违反直观。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr 出现的⽬的是为了替代 NULL。<br>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。C++11 引⼊了 nullptr 关键字，专⻔⽤来区分空指针、0.值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：<br>int * a1 &#x3D; nullptr;<br>char * a2 &#x3D; nullptr;<br>double * a3 &#x3D; nullptr;<br>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。<br>当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前k个高频词</title>
      <link href="/p/49651.html"/>
      <url>/p/49651.html</url>
      
        <content type="html"><![CDATA[<h1 id="前k个高频词"><a href="#前k个高频词" class="headerlink" title="前k个高频词"></a>前k个高频词</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><pre><code> 给你一个整数数组nums和一个整数k ，请你返回其中出现频率前k高的元素。 你可以按任意顺序返回答案。 </code></pre><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</code></pre><p>注意：</p><pre><code>求前 k 大，用小根堆，求前 k 小，用大根堆。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>方法一：桶+快排</strong></p><p>思路与算法：<br>本弱鸡的思路是先用桶把每个数字出现的次数记录下来，然后通过快排按照桶的大小将高频词前k排序出来。</p><p>代码略</p><p>复杂度分析</p><p><strong>时间复杂度：</strong>O(NlogN)，其中 N 为数组的长度。我们首先遍历原数组，并使用桶记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，取出不为0的数组范围O(N),然后采取快排取出前n大数组，总复杂度 O(NlogN)。<br><strong>空间复杂度</strong> 随着数据范围改变而改变</p><p><strong>方法二：堆</strong></p><p>思路与算法：<br>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。</p><p>最简单的做法是给「出现次数数组」排序。但由于可能有 O(N) 个不同的出现次数（其中 N 为原数组长度），故总的算法复杂度会达到 O(NlogN)，不满足题目的要求。</p><p>在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：</p><p>如果堆的元素个数小于 k，就可以直接插入堆中。<br>如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。<br>遍历完成后，堆中的元素就代表了「出现次数数组」中前 kk 大的值。</p><pre><code>class Solution &#123;public:    static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) &#123;        return m.second &gt; n.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v : nums) &#123;            occurrences[v]++;        &#125;        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp);        for (auto&amp; [num, count] : occurrences) &#123;            if (q.size() == k) &#123;                if (q.top().second &lt; count) &#123;                    q.pop();                    q.emplace(num, count);                &#125;            &#125; else &#123;                q.emplace(num, count);            &#125;        &#125;        vector&lt;int&gt; ret;        while (!q.empty()) &#123;            ret.emplace_back(q.top().first);            q.pop();        &#125;        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：</strong>O(Nlogk)，其中 N 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(logk) 的时间，共需 O(Nlogk) 的时间。二者之和为 O(Nlogk)。<br><strong>空间复杂度：</strong>O(N)。哈希表的大小为 O(N)，而堆的大小为 O(k)，共计为 O(N)。</p><p><strong>方法三：快排</strong></p><p>我们可以使用基于快速排序的方法，求出「出现次数数组」的前 k 大的值。<br>在对数组 arr[l…r] 做快速排序的过程中，我们首先将数组划分为两个部分 arr[i…q−1] 与 arr[q+1…j]，并使得 arr[i…q−1] 中的每一个值都不超过 arr[q]，且arr[q+1…j] 中的每一个值都大于 arr[q]。<br>于是，我们根据 k 与左侧子数组 arr[i…q−1] 的长度（为 q-iq−i）的大小关系：<br>如果k≤q−i，则数组 arr[l…r]前k大的值，就等于子数组arr[i…q−1]前k大的值。<br>否则，数组 arr[l…r] 前 k 大的值，就等于左侧子数组全部元素，加上右侧子数组 arr[q+1…j] 中前 k−(q−i) 大的值。<br>原版的快速排序算法的平均时间复杂度为O(NlogN)。我们的算法中，每次只需在其中的一个分支递归即可，因此算法的平均时间复杂度降为 O(N)O(N)。</p><pre><code>class Solution &#123;public:    void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) &#123;        int picked = rand() % (end - start + 1) + start;        swap(v[picked], v[start]);        int pivot = v[start].second;        int index = start;        for (int i = start + 1; i &lt;= end; i++) &#123;            if (v[i].second &gt;= pivot) &#123;                swap(v[index + 1], v[i]);                index++;            &#125;        &#125;        swap(v[start], v[index]);        if (k &lt;= index - start) &#123;            qsort(v, start, index - 1, ret, k);        &#125; else &#123;            for (int i = start; i &lt;= index; i++) &#123;                ret.push_back(v[i].first);            &#125;            if (k &gt; index - start + 1) &#123;                qsort(v, index + 1, end, ret, k - (index - start + 1));            &#125;        &#125;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int, int&gt; occurrences;        for (auto&amp; v: nums) &#123;            occurrences[v]++;        &#125;        vector&lt;pair&lt;int, int&gt;&gt; values;        for (auto&amp; kv: occurrences) &#123;            values.push_back(kv);        &#125;        vector&lt;int&gt; ret;        qsort(values, 0, values.size() - 1, ret, k);        return ret;    &#125;&#125;;</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：O(N^2)</strong><br>设处理长度为N的数组的时间复杂度为f(N)。由于处理的过程包括一次遍历和一次子分支的递归，最好情况下，有 f(N)&#x3D;O(N)+f(N&#x2F;2)，根据主定理，能够得到f(N)&#x3D;O(N)。<br>最坏情况下，每次取的中枢数组的元素都位于数组的两端，时间复杂度退化为O(N^2)。但由于我们在每次递归的开始会先随机选取中枢元素，故出现最坏情况的概率很低。<br><em>平均情况下，时间复杂度为 O(N)。</em><br><strong>空间复杂度：O(N)</strong><br>哈希表的大小为O(N)，用于排序的数组的大小也为 O(N)，快速排序的空间复杂度最好情况为 O(logN)，最坏情况为 O(N)。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/p/50254.html"/>
      <url>/p/50254.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p><strong>行为型模式（Behavioral Pattern）：</strong>关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。<br>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><p><strong>创建型模式（Creational Pattern）：</strong>对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。<br>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><p><strong>结构型模式（Structural Pattern）：</strong>关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。<br>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><h2 id="面向对象的设计模式"><a href="#面向对象的设计模式" class="headerlink" title="面向对象的设计模式"></a>面向对象的设计模式</h2><p><strong>底层思维</strong>：如何把握机器底层从微观理解对象构造</p><ul><li>语言构造</li><li>编译转换</li><li>内存模型</li><li>运行时机制</li></ul><p><strong>抽象思维</strong>：如何将我们周围的世界抽象为程序代码</p><ul><li>面向对象</li><li>组件封装</li><li>设计模式</li><li>构架模式</li></ul><p><strong>三大面向对象机制</strong></p><ul><li>封装 隐藏内部实现</li><li>继承 复用现有代码</li><li>多态 改写对象行为</li></ul><h3 id="如何解决软件工程的复杂性？"><a href="#如何解决软件工程的复杂性？" class="headerlink" title="如何解决软件工程的复杂性？"></a>如何解决软件工程的复杂性？</h3><p><strong>分解</strong>：分而治之，将大问题分解成多个小问题<br><strong>抽象</strong>：忽视对象非本质细节，去处理和泛化和理想化的对象模型</p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><strong>依赖倒置原则(DIP)</strong></p><ul><li>高层模块（稳定）不应该依赖于低层模块（变化），二者应该都依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>开放封闭原则(OCP)</strong></p><ul><li>对拓展开放，对更改封闭</li><li>类模块应该是可以拓展的，但是不可修改</li></ul><p><strong>单一职责原则(SRP)</strong></p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p><strong>Liskov替换原则(LSP)</strong></p><ul><li>子类必须能够替代他们的基类(is-A)</li><li>继承表达类型抽象</li></ul><p><strong>接口隔离原则(ISP)</strong></p><ul><li>不应该强迫客户程序依赖他们不用的方法</li><li>接口应该小而完备</li></ul><p><strong>优先使用对象组合，而不是类继承</strong></p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p><strong>封装变化点</strong></p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><p><strong>针对接口编程，而不是针对实现编程</strong></p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需或者对象的具体类型，只需获取对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现”高内聚，松耦合”的类型设计方案</li></ul><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><ul><li><code>+</code> –&gt; public</li><li><code>-</code> –&gt; private</li><li><code>#</code> –&gt; protected</li><li>静态成员，下划线表示</li><li>纯虚函数，斜体</li></ul><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><ul><li>Assocation (knows a)<ul><li>一个对象知道另一个对象的存在，该对象持有另一个对象的指针或者引用。</li></ul></li><li>Dependency (uses a)<ul><li>当类Y与类X彼此独立，而类Y是类X成员函数的一个参数，或者X中成员函数的一个局部变量。</li></ul></li><li>Composition (has a)<ul><li>一个类是另一个类的集合或者容器，但被包含的类与容器本身并不具备相同的生命期</li></ul></li><li>Aggregation (has a)<ul><li>组合（composition）是聚合（Aggregation）的增强版。组合和聚合的根本不同在于类与其所持有元素的是否具有相同的生命期，要求必须相同是一种组合关系。</li></ul></li><li>Inheritance (is a)<ul><li>类间的继承关系表达的是一种derived class B is a base class A。</li></ul></li><li>Class template<ul><li>类模板意味着泛型类。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/p/14283.html"/>
      <url>/p/14283.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    示例 1:        输入: s = &quot;abcabcbb&quot;        输出: 3         解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。    示例 2:        输入: s = &quot;bbbbb&quot;        输出: 1        解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。    示例 3:        输入: s = &quot;pwwkew&quot;        输出: 3        解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。             请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    采用双指针的做法，通过一个桶记录字符是否出现过以及出现的位置，在O(n)的时间内解决问题</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/p/967.html"/>
      <url>/p/967.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入: head = [1,2,3,4,5]输出: [5,4,3,2,1]</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    有迭代和递归两种做法</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>迭代做法</strong></p><pre><code>class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode prev = nullptr;        ListNode curr = head;        while (curr != null) &#123;            ListNode next = curr.next;            curr.next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;</code></pre><p><strong>递归做法</strong></p><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (head == NULL || head-&gt;next == NULL) &#123;            return head;        &#125;        ListNode* ret = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return ret;    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/p/37489.html"/>
      <url>/p/37489.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法及其时间和空间复杂度"><a href="#十大排序算法及其时间和空间复杂度" class="headerlink" title="十大排序算法及其时间和空间复杂度"></a>十大排序算法及其时间和空间复杂度</h1><p><img src="/p/37489.htm/TenSort.png" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>算法描述：</p><ul><li>⽐较相邻的元素。如果第⼀个⽐第⼆个⼤，就交换它们两个；</li><li>对每⼀对相邻元素作同样的⼯作，从开始第⼀对到结尾的最后⼀对，这样在最后的元素应该会是最⼤的数；</li><li>针对所有的元素重复以上的步骤，除了最后⼀个；</li><li>重复步骤 1~3，直到排序完成。</li></ul><p>代码如下：</p><pre><code>void BubbleSort(std::vector&lt;int&gt; &amp;nums, int n)&#123;     if (n &lt;= 1) return;    bool is_swap;    for (int i = 1; i &lt; n; ++i)    &#123;         //设定⼀个标记，若为false，则表示此次循环没有进⾏交换，也就是待排序列已经有序，排序已经完成。        is_swap = false;        for (int j = 1; j &lt; n - i + 1; ++j)         &#123;             if (nums[j] &lt; nums[j-1])            &#123;                //表示有数据交换                std::swap(nums[j], nums[j-1]); is_swap = true;            &#125;        &#125;        //没有数据交换，提前退出        if (!is_swap) break;    &#125;&#125;</code></pre><p>冒泡排序空间复杂度为O(1)，是⼀种原地排序算法。<br>冒泡排序的最好情况时间复杂度O(n)、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>冒泡排序是一种稳定的排序算法。</p><h2 id="插⼊排序"><a href="#插⼊排序" class="headerlink" title="插⼊排序"></a>插⼊排序</h2><p>算法描述：分为已排序和未排序的区间，初始已排序区间只有⼀个元素–就是数组第⼀个；遍历未排序的每⼀个元素在已排序区间⾥找到合适的位置插⼊并保证数据⼀直有序。</p><p>代码如下：</p><pre><code>void InsertSort(std::vector&lt;int&gt; &amp;nums,int n) &#123;     if (n &lt;= 1) return;    for(int i = 0; i &lt; n; ++i) &#123;        for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums [j-1]; --j) &#123;            std::swap(nums[j],nums[j-1]);        &#125;    &#125;&#125;</code></pre><p>插入排序空间复杂度为O(1)，是⼀种原地排序算法。<br>插入排序的最好情况时间复杂度 O(n)、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>插入排序是一种稳定的排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最⼩的元素，将其放到已排序区间的末尾。</p><pre><code>void SelectSort(std::vector&lt;int&gt; &amp;nums, int n) &#123;     if (n &lt;= 1) return;    int mid;    for (int i = 0; i &lt; n - 1; ++i)    &#123;         mid = i;        for (int j = i + 1; j &lt; n; ++j) &#123;             if (nums[j] &lt; nums[mid])             &#123;                mid = j;            &#125;        &#125;        std::swap(nums[mid],nums[i]);    &#125;&#125;</code></pre><p>选择排序空间复杂度为O(1)，是⼀种原地排序算法。<br>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。<br>选择排序是一种不稳定的排序算法。</p><p><strong>【时间,空间复杂度&#x2F;是否稳定？】</strong></p><p>那选择排序是稳定的排序算法吗？答案是否定的，选择排序是⼀种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最⼩值，并和前⾯的元素交换位置，这样破坏了稳定性.<br>【思考】冒泡排序和插⼊排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插⼊排序要⽐冒泡排序更受欢迎呢？<br>【思路】冒泡排序不管怎么优化，元素交换的次数是⼀个固定值，是原始数据的逆序度。插⼊排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，⽽插⼊排序只需要 1 个。把执⾏⼀个赋值语句的时间粗略地计为单位时间，处理相同规模的数，插⼊排序⽐冒泡排序减少三倍的单位时间！</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><strong>算法描述：</strong><br>先找到⼀个枢纽；在原来的元素⾥根据这个枢纽划分;⽐这个枢纽⼩的元素排前⾯；⽐这个枢纽⼤的元素排后⾯；两部分数据依次递归排序下去直到最终有序。</p><p>代码如下：</p><pre><code>void QuickSort(std::vector&lt;int&gt; &amp;nums,int l,int r)&#123;     if (l + 1 &gt;= r) return;    int first = l, last = r - 1 ,key = nums[first];     while (first &lt; last)    &#123;        while (first &lt; last &amp;&amp; nums[last] &gt;= key) last--;//右指针 从右向左扫描 将⼩于piv的放        到左边        nums[first] = nums[last];        while (first &lt; last &amp;&amp; nums[first] &lt;= key) first++;//左指针 从左向右扫描 将⼤于piv的        放到右边        nums[last] = nums[first];    &#125;    nums[first] = key;//更新piv    quick_sort(nums, l, first);//递归排序 //以L为中间值，分左右两部分递归调⽤    quick_sort(nums, first + 1, r);&#125;</code></pre><p>非递归算法：</p><pre><code>//划分算法int Partition( int a[], int low, int high )&#123;    //假设每次都以第一个元素作为枢轴值，进行一趟划分：    int pivot = a[low];        while( low&lt;high )    &#123;        while( low&lt;high &amp;&amp; a[high]&gt;=pivot )        --high;        a[low] = a[high];  //停下来做交换         while( low&lt;high &amp;&amp; a[low]&lt;=pivot )        ++low;        a[high] = a[low];  //停下来做交换     &#125;        a[low] = pivot;  //pivot的最终落点     return low;&#125;//非递归快排void QuickSort(int a[], int left, int right)&#123;    //手动利用栈来存储每次分块快排的起始点    //栈非空时循环获取中轴入栈    stack&lt;int&gt; s;    if( left&lt;right )    &#123;        int boundary = Partition(a,left,right);                if( boundary-1&gt;left ) //确保左分区存在         &#123;            //将左分区端点入栈             s.push(left);            s.push(boundary-1);        &#125;        if( boundary+1&lt;right ) //确保右分区存在         &#123;            s.push(boundary+1);            s.push(right);        &#125;                while( !s.empty() )        &#123;            //得到某分区的左右边界             int r = s.top();            s.pop();              int l = s.top();            s.pop();                        boundary = Partition(a,l,r);            if( boundary-1&gt;l ) //确保左分区存在             &#123;                 //将左分区端点入栈                 s.push(l);                s.push(boundary-1);            &#125;            if( boundary+1&lt;r ) //确保右分区存在             &#123;                s.push(boundary+1);                s.push(r);            &#125;        &#125;    &#125;&#125;</code></pre><p>快速排序空间复杂度为O(1)，是⼀种原地排序算法。<br>快速排序的最好情况时间复杂度 O(nlogn)、最坏情况 O(n^n)平均情况时间复杂度都为 O(nlogn)。<br>快速排序是一种不稳定的排序算法。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法描述：归并排序是⼀个稳定的排序算法，归并排序的时间复杂度任何情况下都是    O(nlogn)，归并排序不是原地排序算法<br>⽤两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第⼀个元素。⽐较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;&#x3D;A[j]，我们就把 A[i] 放⼊到临时数组 tmp，并且 i 后移⼀位，否则将 A[j] 放⼊到数组 tmp，j 后移⼀位。</p><p>代码如下：<br>    void mergeCount(int a[],int L,int mid,int R)<br>    {<br>        int *tmp &#x3D; new int[L+mid+R];<br>        int i&#x3D;L;<br>        int j&#x3D;mid+1; int k&#x3D;0;<br>        while( i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;R )<br>        {<br>            if(a[i] &lt; a[j])<br>                tmp[k++] &#x3D; a[i++];<br>            else<br>                tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F;判断哪个⼦数组中有剩余的数据<br>        while( i&lt;&#x3D;mid )<br>        {<br>            tmp[k++] &#x3D; a[i++];<br>        }<br>        while( j&lt;&#x3D;R)<br>        {<br>            tmp[k++] &#x3D; a[j++];<br>        }<br>        &#x2F;&#x2F; 将 tmp 中的数组拷⻉回 A[p…r]<br>        for(int p&#x3D;0; p&lt;k; ++p){<br>            a[L+p] &#x3D; tmp[p]; delete tmp;<br>        }<br>    }<br>    void mergeSort(int a[],int L,int R) {<br>        &#x2F;&#x2F;递归终⽌条件 分治递归<br>        &#x2F;&#x2F; 将 A[L…m] 和 A[m+1…R] 合并为 A[L…R]<br>        if( L&gt;&#x3D;R ) { return; } int mid &#x3D; L + (R - L)&#x2F;2; mergeSort(a,L,mid); mergeSort(a,mid+1,R); mergeCount(a,L,mid,R);<br>    }</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>算法描述：利⽤堆这种数据结构所设计的⼀种排序算法。堆积是⼀个近似完全⼆叉树的结构，并同时满⾜堆积的性质：即⼦结点的键值或索引总是⼩于（或者⼤于）它的⽗节点。堆排序可以⽤到上⼀次的排序结果，所以不像其他⼀般的排序⽅法⼀样，每次都要进⾏n-1次的⽐较，复杂度为O(nlogn)。<br>算法步骤：<br>1、利⽤给定数组创建⼀个堆H[0..n-1]（我们这⾥使⽤最⼩堆），输出堆顶元素<br>2、以最后⼀个元素代替堆顶，调整成堆，输出堆顶元素<br>3、把堆的尺⼨缩⼩ 1<br>4、重复步骤 2，直到堆的尺⼨为 1<br>建堆：将数组原地建成⼀个堆，不借助额外的空间，采⽤从上往下的堆化（对于完全⼆叉树来说，下标是 n&#x2F;2+1到n的节点都是叶⼦节点，不需要堆化）。<br>排序：”删除堆顶元素“：当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后在通过堆化的⽅法，将剩下的n-1个元素重新构建成堆，堆化完成之后，在取堆顶的元素，放到下标为 n-1 的位置，⼀直重复这个过程，直到最后 堆中只剩下标 1 的⼀个元素。<br>优点：O(nlogn)，原地排序，最⼤的特点：每个节点的值⼤于等于(或⼩于等于)其⼦树节点缺点：相⽐于快排，堆排序数据访问的⽅式没有快排友好；数据的交换次数要多于快排。<br>    void HeapSort(int a[], int n)<br>    {<br>        for(int i&#x3D;n&#x2F;2; i&gt;&#x3D;1; –i)<br>        {<br>            Heapify(a, n, i);<br>        }<br>        int k &#x3D; n;<br>        while( k &gt; 1)<br>        {<br>            swap(a[1],a[k]);<br>            –k;<br>            Heapify(a,k,1);<br>        }<br>    }</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>算法描述：将数组分到有限数量的桶⾥。每个桶再个别排序（有可能再使⽤别的排序算法或是以递归⽅式继续使⽤ 桶排序进⾏排序）。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>扩展：如果在⾯试中有⾯试官要求你写⼀个   O(n)   时间复杂度的排序算法，可不要傻乎乎的说这不可能！虽然前⾯基于⽐较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要 满⾜⼀定的范围的整数，⽽且计数排序需要⽐较多的辅助空间。<br>算法描述：其基本思想是，⽤待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序 序列。<br>假设有 8 个考⽣，分数在 0 到 5 分之间。这 8 个考⽣的成绩我们放在⼀个数组 A[8]中，它们分别是：2，5，3， 0，2，3，0，3。<br>考⽣的成绩从 0 到 5 分，我们使⽤⼤⼩为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考<br>⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到       C[6]的值。</p><p>这是我们的数组，从图中可以看出，分数为 3 分的考⽣有 3 个，⼩于 3 分的考⽣有 4 个，所以，成绩为 3 分的考<br>⽣在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。<br>那我们如何快速计算出，每个分数的考⽣在有序数组中对应的存储位置呢？<br>我们对 C[6] 数组顺序求和，C[6]存储的数据就变成了下⾯这样⼦。C[k]⾥存储⼩于等于分数 k 的考⽣个数。</p><p>我们从后到前依次扫描数组 A。⽐如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到⽬前为⽌，包括⾃⼰在内，分数⼩于等于 3 的考⽣有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中<br>下标为 6 的位置）。当 3 放⼊到数组 R 中后，⼩于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。<br>以此类推，当我们扫描到第 2 个分数为 3 的考⽣的时候，就会把它放⼊数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从⼩到⼤有序排列的了。<br>注意：计数排序只能⽤在数据范围不⼤的场景中，如果数据范围 k ⽐要排序的数据 n ⼤很多，就不适合⽤计数排序了。⽽且，计数排序只能给⾮负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对⼤⼩的情况下，   转化为⾮负整数。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独⽴的“位”来⽐较，⽽且位之间有递进的关系，    如果 a 数据的⾼位⽐ b 数据⼤，那剩下的低位就不⽤⽐较了。除此之外，每⼀位的数据范围不能太⼤，要可以⽤线性排序算法来排序，否则，基数排序的时间复杂度就⽆法做到 O(n) 了。<br>基数排序相当于通过循环进⾏了多次桶排序。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>算法描述：通过将⽐较的全部元素分为⼏个区域来提升插⼊排序的性能。这样可以让⼀个元素可以⼀次性地朝最终 位置前进⼀⼤步。然后算法再取越来越⼩的步⻓进⾏排序，算法的最后⼀步就是普通的插⼊排序，但是到了这步， 需排序的数据⼏乎是已排好的了。</p><pre><code>template&lt;typename T&gt;void shell_sort(T array[], int length) &#123;    int h = 1;    while (h &lt; length / 3) &#123;        h = 3 * h + 1;    &#125;    while (h &gt;= 1) &#123;        for (int i = h; i &lt; length; i++) &#123;            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;                std::swap(array[j], array[j - h]);            &#125;        &#125;        h = h / 3;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链接编译联编</title>
      <link href="/p/43574.html"/>
      <url>/p/43574.html</url>
      
        <content type="html"><![CDATA[<h2 id="链接编译联编"><a href="#链接编译联编" class="headerlink" title="链接编译联编"></a>链接编译联编</h2><h3 id="1-动态编译与静态编译"><a href="#1-动态编译与静态编译" class="headerlink" title="1.动态编译与静态编译"></a>1.动态编译与静态编译</h3><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；</p><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库， 则⽤动态编译的可执⾏⽂件就不能运⾏。</p><h3 id="2-动态链接和静态链接区别"><a href="#2-动态链接和静态链接区别" class="headerlink" title="2.动态链接和静态链接区别"></a>2.动态链接和静态链接区别</h3><p><strong>静态连接库</strong>就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；<br><strong>动态链接</strong>就是把调⽤的函数所在⽂件模块(DLL)和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候 再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。</p><p><strong>静态连接库</strong>与<strong>动态链接库</strong>都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib中的指令都全部被直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。<br><strong>静态连接库</strong>和<strong>动态链接库</strong>的另外⼀个区别在于静态链接库中不能再<br>包含其他的动态链接库或者静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。<br><strong>动态库</strong>就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对lib⽂件中同⼀个函数的调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。</p><h3 id="3-动态联编与静态联编"><a href="#3-动态联编与静态联编" class="headerlink" title="3.动态联编与静态联编"></a>3.动态联编与静态联编</h3><p>在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编和动态联编；<br><strong>静态联编</strong>是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成⼜称为早期联编。要实现静态 联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束 定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差。<br><strong>动态联编</strong>是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数 的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象 类型将做出不同的编译结果。C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类 的指针变量名-&gt;虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）</p><h4 id="实现动态联编三个条件："><a href="#实现动态联编三个条件：" class="headerlink" title="实现动态联编三个条件："></a>实现动态联编三个条件：</h4><p>1.必须把动态联编的⾏为定义为类的虚函数；<br>2.类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；<br>3.必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； </p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用方法</title>
      <link href="/p/5226.html"/>
      <url>/p/5226.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><p align="center"><font color="#ff00ff">Git</font></p></h1><h3 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h3><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，<br>将文档的状态作为更新记录保存起来，也可以在任何时间点，<br>将更新记录恢复回来。</p><h3 id="1-2-查看Git的版本"><a href="#1-2-查看Git的版本" class="headerlink" title="1.2 查看Git的版本"></a>1.2 查看Git的版本</h3><pre><code>    git --verson</code></pre><h3 id="1-3-Git-基本工作流程"><a href="#1-3-Git-基本工作流程" class="headerlink" title="1.3 Git 基本工作流程"></a>1.3 Git 基本工作流程</h3><p><strong>工作区</strong> 就是你在电脑里能看到的目录。<br><strong>暂存区</strong> 英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件<br>        （.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。<br><strong>版本库</strong> 工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p><h3 id="1-4-Git-使用前配置"><a href="#1-4-Git-使用前配置" class="headerlink" title="1.4 Git 使用前配置"></a>1.4 Git 使用前配置</h3><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：git config –global user.name “提交人姓名” # (对当前系统用户有效)</li><li>配置提交人姓名：git config –global user.email  “提交人邮箱” # (对当前系统用户有效)<br>作用：识别开发人员，与登陆github的账户无关</li><li>查看git配置信息：git config –list</li></ol><p>注意</p><ol><li>如果要对配置信息进行修改，重复上述命令即可。</li><li>配置只需要执行一次。</li></ol><h3 id="1-5-常用提交步骤"><a href="#1-5-常用提交步骤" class="headerlink" title="1.5 常用提交步骤"></a>1.5 常用提交步骤</h3><ol><li><p>git init  # 初始化git仓库</p></li><li><p>git status  # 查看文件状态</p></li><li><p>git add 文件列表 # 追踪文件</p></li><li><p>git commit -m  “提交信息”  # 向仓库中提交代码(全部文件)<br>vs： git commit -m “提交信息”  文件  # 提交某个文件</p></li><li><p>git log # 显示所有提交记录<br>git log –pretty&#x3D;oneline   # 一行显示版本信息</p></li></ol><p>补充：</p><pre><code>    # 会显示所有关于这个id以及之前的修改记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac     # 加上-1参数表示我们只想看到一行记录    git log lfa380b5O2a0Ob82bfc8d84c5ab5el5b8fbf7dac -1 </code></pre><p>而如果想要查看这条提交记录具体修改了什么内容，可以在命令中加入p参数，命令如下:</p><pre><code>    git log Ifa380b502a00b82bfc8d84c5ab5el5b8fbf7dac -1 -p</code></pre><ol start="6"><li><p>git reset  –hard 版本id  # 回退版本</p></li><li><p>git reflog   # 查看所有版本信息</p></li><li><p>git diff  # 表示未使用add命令时的修改</p></li></ol><p>这样可以查看到所有文件的更改内容，<br>如果你只想查看MainActivity.java这个文件的更改内容，可以使用如下命令：</p><pre><code>    git diff app/src/main/java/com/example/providertest/MainActivity.java</code></pre><p>vs：git log 表示最近的改变，git reflog可以看到所有的改变<br>如果文件未被跟踪,即没有使用git add这个命令时,文件为红色,如果使用这个命令,则文件变为绿色。<br>这里涉及到一个知识点，git的本地三个区域+远程仓库<br><a href="https://imgse.com/i/ppf2YPP"><img src="https://s1.ax1x.com/2023/04/02/ppf2YPP.png" alt="ppf2YPP.png"></a></p><p><code>Workspace：</code>工作区，就是你平时存放项目代码的地方;</p><p><code>Index / Stage：</code>暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息,一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）;</p><p><code>Repository：</code>仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本;</p><p><code>Remote：</code>远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换;</p><ul><li>git add 是将代码从工作区加入到暂存区</li><li>git commit 是将代码从暂存区递交到本地仓库</li><li>git push则是由本地推送到远程仓库</li></ul><h3 id="1-6-远程仓库-Github"><a href="#1-6-远程仓库-Github" class="headerlink" title="1.6 远程仓库(Github)"></a>1.6 远程仓库(Github)</h3><p>新添加远程仓库</p><pre><code>    git remote add [shortname] [url]</code></pre><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p><pre><code>    git remote</code></pre><p>提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><pre><code>    git fetch</code></pre><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><p>git merg</p><p>删除远程仓库<br>删除远程仓库你可以使用命令：</p><pre><code>    git remote rm [别名]</code></pre><h3 id="1-7-创建分支"><a href="#1-7-创建分支" class="headerlink" title="1.7 创建分支"></a>1.7 创建分支</h3><p>多人协作完成一个项目的时候，不同的人需要完成不同的功能，这时候就需要创建分支。</p><pre><code># 列出所有本地分支git branch # 列出所有远程分支git branch -r # 新建一个分支，但依然停留在当前分支git branch [branchname] # 新建一个分支，并切换到该分支git checkout -b [branchname]# 切换到主分支$ git checkout master    # 合并指定分支到当前分支$ git merge [branchname] # 删除分支$ git branch -d [branchname] # 删除远程分支$ git push origin --delete [branchname]$ git branch -dr [remote/branch]</code></pre><h3 id="1-8-标签"><a href="#1-8-标签" class="headerlink" title="1.8 标签"></a>1.8 标签</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。<br>Git有commit，为什么还要引入tag？<br>“请把上周一的那个版本打包发布，commit号是6a5819e…”<br>“一串乱七八糟的数字不好找！”<br>如果换一个办法：<br>“请把上周一的那个版本打包发布，版本号是v1.2”<br>“好的，按照tag v1.2查找commit就行！”<br>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><ul><li>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</tagname></li><li>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</tagname></li><li>命令git tag可以查看所有标签。</li><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs&#x2F;tags&#x2F;<tagname>可以删除一个远程标签。</tagname></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码风格规定</title>
      <link href="/p/41521.html"/>
      <url>/p/41521.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码风格规定"><a href="#代码风格规定" class="headerlink" title="代码风格规定"></a>代码风格规定</h2><hr><h4 id="单个标识符的命名风格有以下几种"><a href="#单个标识符的命名风格有以下几种" class="headerlink" title="单个标识符的命名风格有以下几种:"></a>单个标识符的命名风格有以下几种:</h4><p><strong>驼峰</strong>:每个单词第一个字母大写，其余小写: VariableName.<br>又可进一步细分为<strong>大驼峰</strong>(VariableName) 和<strong>小驼峰</strong>(variableName)</p><p><strong>内核</strong>:所有字母都小写，用下划线连接: variable name<br>C++的标准库源码都使用该命名方式</p><p><strong>匈牙利</strong>:以大驼峰为基础，给每个变量加上特定前缀表示其类型: iVariableName<br>匈牙利命名法存在可读性、可维护性方面的问题，已被现代编程实践所抛弃。</p><p><strong>全大写加下划线</strong>:所有字母都大写，用下划线连接: VARIABLE NAME<br>一般只用于常量和宏的命名.</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><hr><p>当今业界主流的排版风格:</p><ul><li>函数、类型、复合语句内部缩进一层</li><li>缩进使用空格而不是制表符</li><li>if&#x2F;for&#x2F;while&#x2F;switch和括号之间留一个空格</li><li>双目运算符两边留空格,逗号、分号后面留空格</li><li>圆括号内侧不空格</li><li>函数定义之间空行</li><li>注释符号(&#x2F;&#x2F;) 和内容之间留一个空格</li></ul><h2 id="代码的组织"><a href="#代码的组织" class="headerlink" title="代码的组织"></a>代码的组织</h2><hr><ul><li>程序必须为阅读它的人而编写，只是顺便用于机器执行。</li><li>短小的函数总是更简洁、容易阅读的。</li><li>功能单一的函数更容易被复用，简洁明了的代码更容易维护。</li><li>函数行数(建议不超过40行)</li><li>文件行数(建议不超过500行)</li><li>函数圈复杂度(建议不超过10)</li><li>函数内缩进嵌套层次(建议不超过4层)</li><li>架构度量(上帝类、模块耦合程度… .</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda、资源管理与杂项</title>
      <link href="/p/46257.html"/>
      <url>/p/46257.html</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h4 id="1-Lambda捕获列表"><a href="#1-Lambda捕获列表" class="headerlink" title="1.Lambda捕获列表"></a>1.Lambda捕获列表</h4><pre><code class="cpp">   class MyClass &#123;          public:    void Foo()    &#123;        // 虽然看起来是按值捕获，但对        // data的修改会改变成员变量的值        auto Lambda = [=]()) &#123; data++; &#125;;        Lambda();     private:        int data = 0;    &#125;&#125;;</code></pre><p>正确做法：</p><pre><code class="cpp">    class MyClass &#123;    public:        void Foo()        &#123;            auto Lambda =[data = this-&gt; data]0 mutable &#123;                data+ +;            &#125;;            //...            Lambda0;            //....        &#125;    private:        int data = 0;&#125;;</code></pre><p>避免使用默认捕获模式。如果捕获this,需要明确写出。</p><h4 id="2-Lambda捕获局部变量"><a href="#2-Lambda捕获局部变量" class="headerlink" title="2.Lambda捕获局部变量"></a>2.Lambda捕获局部变量</h4><pre><code class="cpp">    例：        auto GetFunc()        &#123;            int thresh = 10;            // GetFunc返回后，局部变量被释放            return [&amp;thresh](int x)&#123; returnx &lt; thresh; &#125;;        &#125;        int main()        &#123;            vector&lt;int&gt; v&#123;0, 1, 3, 5&#125;;            // find if内部访问已被释放的变量导致未定义行为            auto it = find ifv.begin0. v.end0, GetFuncQ);            return 0;        &#125;</code></pre><p>当lambda对象会传递到函数外部的时候，避免按引用捕获局部变</p><h4 id="3-new的失败场景"><a href="#3-new的失败场景" class="headerlink" title="3.new的失败场景"></a>3.new的失败场景</h4><pre><code class="cpp">    auto p = new int[1024*1024];    if (p == nullptr) &#123;        //内存不足的处理    &#125;</code></pre><p>实际上，new操作符不会返回空指针，这是个错误的写法<br>正确写法1：</p><pre><code class="cpp">    try &#123;        auto p = new int[1024 * 1024];    &#125;     catch (std::bad alloc) &#123;        // .内存不足的处理    &#125;</code></pre><p>正确写法2：</p><pre><code class="cpp">    auto p = new(nothrow) int[1024 * 1024];    if (p == nullptr) &#123;        // .内存不足的处理    &#125;</code></pre><p>当需要处理new失败场景时，捕获std:bad _alloc异常或者使用new(nothrow)并判断空指针。</p><h4 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4.智能指针"></a>4.智能指针</h4><pre><code class="cpp">        void Func(shared. _ptr &lt;MyClass&gt; X,shared. ptr&lt;MyClass&gt; y)    &#123;        // ..    &#125;    int main()    &#123;        // 类型被重复写两次        unique_ ptr &lt;MyClass&gt; a(new MyClass);        // 在被智能指针接管前可能发生泄漏        Func(shared ptr&lt;MyClass&gt; (new MyClass),shared ptr&lt;MyClas&gt; (new MyClass));        return 0;    &#125;        </code></pre><p>正确做法：</p><pre><code class="cpp">    void Func(shared ptr &lt;MyClass&gt; x,shared_ ptr &lt;MyClass&gt; y)    &#123;        //....    &#125;    int main()    &#123;         auto a = make_ unique &lt;MyClass&gt;();        //....        Func(make_ shared &lt;MyClass&gt;(), make_ shared&lt;MyClass&gt;());        return 0;    &#125;</code></pre><p>使用std::make_ unique而不是new创建unique_ ptr<br>使用std::make shared而不是new创建shared_ptr</p><h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        for (auto it = numbers.begin(); it != numbers.end();++it) &#123;            if(*it == num) &#123;                // 删除该元素后，迭代器不再指向原有元素                // ++后迭代器指向的不是下一个元素                numbers.erase(it);            &#125;        &#125;    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>正确做法：</p><pre><code class="cpp">    void EraseNumber(vector &lt;int&gt; &amp; numbers, int num)    &#123;        numbers.erase(std:remove(numbers. begin(), numbers.end(), num),numbers.end);    &#125;    int main()    &#123;        vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;        EraseNumber(v, 3);        return 0;    &#125;</code></pre><p>使用有效的迭代器，尤其注意在遍历的同时给容器增删元素时</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与函数</title>
      <link href="/p/29637.html"/>
      <url>/p/29637.html</url>
      
        <content type="html"><![CDATA[<h2 id="类与函数"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold, int&amp; count)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return SUCCESS;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>函数的输出没有意义，恒为SUCCESS<br>可以将返回值更改为return count;</p><pre><code class="cpp">    constexpr int SUCCESS = 0;    constexpr int FAIL = 0;    int CountPassed(vector &lt;int&gt; scores, int threshhold)    &#123;        count = 0;        for (int score : scores) &#123;            if (score &gt;= threshhold) &#123;                count++;            &#125;        &#125;        return count;    &#125;    int main()&#123;        int count;        int ret = CountPassed(&#123;59, 60, 80&#125;, 60, count);         if (ret == SUCCESS) &#123;             return 0;        &#125;    &#125;</code></pre><p>这样输入输出更简洁，设计函数时， 优先使用返回值而不是输出参数。</p><h4 id="2-避免使用宏"><a href="#2-避免使用宏" class="headerlink" title="2.避免使用宏"></a>2.避免使用宏</h4><pre><code class="cpp">    例：        #define SQUARE(a)a*a        #define MAX(a, b) ((a) &lt; (b))? (b) : (a)        int main()        &#123;            intx = SQUARE(1 + 2);// 宏扩展为1+2*1+2,结果为4            unsigned int a = 1;            int y = SQUARE(a++); //a自增多次            a=1;            int b=-1;            cout &lt;&lt; MAX(a, b); //不同参数类型无法检查会导致错误结果            return 0;        &#125;</code></pre><p>可以使用函数替代宏函数</p><pre><code class="cpp">    inline int Square(int a) &#123; returna* a; &#125;    inline int Max(int a, int b)    &#123;        returna&lt;b?b:a;    &#125;    int main()    &#123;        int x = Square(1 + 2);        unsigned int a= 1;        int y = Square(a++);        int b= -1;        cout &lt;&lt; Max(a, b);        return 0;    &#125;</code></pre><p>宏有类型检查、非预期副作用、运算优先级等方面的缺点,应当尽可能用函数、inline函数、 模板函数代替宏。<br>如果不得不使用宏， 则必须在定义宏时使用完备的括号。</p><h4 id="3-类和成员初始化"><a href="#3-类和成员初始化" class="headerlink" title="3.类和成员初始化"></a>3.类和成员初始化</h4><pre><code class="cpp">    class Message &#123;    public:                Message()&#123;&#125;//所有成员都没有初始化        Message(int id, int len) : msglD(id), msgLength(len) &#123;&#125;//msgBuffer指针没有初始化     private:        unsigned int msglD;        unsigned int msgLength;        unsigned char* msgBuffer;    &#125;    int main()    &#123;        Message a;//随机值        Message b(1, 2);//可能访问野指针        return 0;     &#125;</code></pre><p>禁止使用未经初始化的变量作为右值<br>类的所有构造函数都要保证所有成贸被正确初始化<br>优先使用初始化列表或者类内初始化来初始化成员</p><h4 id="4-虚函数重写规则"><a href="#4-虚函数重写规则" class="headerlink" title="4.虚函数重写规则"></a>4.虚函数重写规则</h4><pre><code class="cpp">    例：        class Base &#123;        public:            virtual void mf1() const;            virtual void mf2(int x);            virtual void mf3() &amp;;             void mf4() const;        &#125;;        class Derived : public Base &#123;        public:            virtual void mf1();//没有const            virtual void mf2(unsigned int x);//参数不匹配，重载            virtual void mf3() &amp;&amp;;//this是右值引用，基类是左值引用            void mf4() const;//mf4并没有用virtual修饰        &#125;;    以上函数都没有成功的重载，并且编译器不会发生告警</code></pre><p>C++ 11新增的override可以有效的避免这种编码错误<br>override必须是继承而来的虚函数，否则编译不过<br>在重写虚函数时使用override或者final关键字<br>final不允许子类继续重写虚函数</p><h4 id="5-禁止在构造函数析构函数中调用虚函数"><a href="#5-禁止在构造函数析构函数中调用虚函数" class="headerlink" title="5.禁止在构造函数析构函数中调用虚函数"></a>5.禁止在构造函数析构函数中调用虚函数</h4><pre><code class="cpp">    class Base &#123;    public:        //构造函数中调用虚函数，此时虚表还没有初始化完成        //不会调用到子类的虚函数        Base()&#123; Log(); &#125;;        //调用纯虚函数会产生未定义行为        virtual void Log() = 0;    &#125;;    class Sub : public Base &#123;    public:        virtualvoid Log()&#123;... &#125;;    &#125;</code></pre><p>禁止在构造函数和析构函数中调用虚函数,产生未定义行为或者达不到多态的目的</p><h4 id="6-内存操作函数"><a href="#6-内存操作函数" class="headerlink" title="6.内存操作函数"></a>6.内存操作函数</h4><pre><code class="cpp">    class Point &#123;    public:        virtual ~Point(); //Point对象包含虚表指针    private:        int X;        int y;    &#125;    int main()&#123;        Point a;        memset(&amp;a, 0, sizeof(a));//memset操作会破坏对象的虚表指针        return 0;    &#125;;</code></pre><p>禁止使用memcpy. memset等内存操作函数初始化非POD对象</p><h6 id="POD对象："><a href="#POD对象：" class="headerlink" title="POD对象："></a>POD对象：</h6><p>在C++中，我们把传统的C风格的struct叫做POD（Plain Old Data）对象。<br>一般来说，POD对象应该满足如下特性。</p><p>对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，<br>如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，<br>再将其复制回对象，那么该对象的值与原始值一样。</p><p>对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，<br>如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。</p><p>简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，<br>只要其二进制内容在，就能还原出正确无误的POD对象。<br>对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。</p><h4 id="7-析构函数"><a href="#7-析构函数" class="headerlink" title="7.析构函数"></a>7.析构函数</h4><pre><code class="cpp">    class Base &#123;    public:        virtual const char* Name() const        &#123;            return &quot;Base&quot;;         &#125;    &#125;;    class Sub : public Base &#123;    public:        Sub() : numbers(new int[1000]) &#123;&#125;         ~Sub() &#123; delete[] numbers; &#125;        virtual const char* Name() const        &#123;        return &quot;Sub&quot;;        &#125;    private:        int* numbers;    &#125;;    int main(int argc, char* argsQ)    &#123;        Base* b = new Sub();        delete b;        return 0;     &#125;</code></pre><p>基类没有定义虚析构函数，所以main函数中并没有析构子类数据成员，造成内存泄露<br>基类的析构函数应当声明为虚函数</p><h4 id="8-虚函数的缺省参数"><a href="#8-虚函数的缺省参数" class="headerlink" title="8.虚函数的缺省参数"></a>8.虚函数的缺省参数</h4><pre><code class="cpp">    class Base&#123;    public:         virtual void Display(const std:string&amp; text = &quot;Base!&quot;)&#123;            std:.cout &lt;&lt; text &lt;&lt; std::endl;        &#125;        virtual ~ Base()&#123;&#125;    &#125;;    class Sub : public Base &#123;    public:        virtual void Display(const stl:string&amp; text = &quot;Sub!&quot;)        &#123;            std:cout &lt;&lt; text &lt;&lt; std:.endl;        &#125;        virtual ~Sub()&#123;&#125;     &#125;;    int main(        Base* base = new Sub();        Sub* sub = new Sub();        // ..        base-&gt; Display();         sub-&gt; Display();        delete base;         delete sub;        return 0;    &#125;;</code></pre><p>调用的函数是运行时决定的，但缺省参数是编译时决定的，导致使用”Base!” 参数调用Sub<br>类的Display<br>禁止子类的虚函数定义与基类不同的缺省参数</p><h4 id="9-void"><a href="#9-void" class="headerlink" title="9.void*"></a>9.void*</h4><pre><code class="cpp">    class BaseA &#123;    public:        virtual void FunA();         virtual ~BaseA();    &#125;;    class BaseB &#123;    public:        virtual void FunB();        virtual ~ BaseB();    &#125;;    class Sub : public BaseA, public BaseB &#123;    public:        virtual void FunA();         virtual void FunB();        virtual ~Sub();    &#125;;    int main()    &#123;        BaseA* pa = new Sub();        void* pv = pa;        BaseB* pb = (BaseB*)pv;        // ..        delete pb;        return 0;    &#125;;        //  正确做法    //  int main()    //  &#123;    //      BaseA* pa = new Sub();    //      BaseB* pb = dynamic cast&lt;BaseB*&gt; (pa);    //      return 0;    //  &#125;</code></pre><p>BaseA和BaseB的指针虽然指向同一个对象，但它们应该有不同的地址值。<br>如果使用void<em>转换，则使BaseA</em>和BaseB<em>为相同地址，产生未定义行为<br>void</em>丢失了对象的类型信息，失去了编译时的类型检查能力，应避免使用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
            <tag> 编码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式与变量</title>
      <link href="/p/39885.html"/>
      <url>/p/39885.html</url>
      
        <content type="html"><![CDATA[<h2 id="表达式与变量"><a href="#表达式与变量" class="headerlink" title="表达式与变量"></a>表达式与变量</h2><h4 id="1-避免全局变量-出现初始化顺序依赖"><a href="#1-避免全局变量-出现初始化顺序依赖" class="headerlink" title="1.避免全局变量 出现初始化顺序依赖"></a>1.避免全局变量 出现初始化顺序依赖</h4><h6 id="a-cpp"><a href="#a-cpp" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int g_GlobalX=1;</code></pre><h6 id="b-cpp"><a href="#b-cpp" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int g_GlobalX;    int g_GlobalY=1+g_GlobalX;    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>这里由于全局变量初始化顺序不确定导致结果不唯一。<br>如果先初始化g_GlobalX那么g_GlobalY为2，否则为1。<br>那么该如何解决这个问题呢，下面有一种解决办法：</p><h6 id="a-cpp-1"><a href="#a-cpp-1" class="headerlink" title="a.cpp"></a>a.cpp</h6><pre><code class="cpp">    int GetX()&#123;        static int g_GlobalX=1;        return g_GlobalX;    &#125;</code></pre><h6 id="b-cpp-1"><a href="#b-cpp-1" class="headerlink" title="b.cpp"></a>b.cpp</h6><pre><code class="cpp">    extern int GetX();    int g_GlobalY=1+GetX();    int main()&#123;        cout&lt;&lt;g_GlobalY;        return 0;    &#125;</code></pre><p>函数中静态变量一定会在第一次调用函数时初始化<br>这也就解决了全局变量初始化顺序的问题</p><h4 id="2-函数名是函数的地址"><a href="#2-函数名是函数的地址" class="headerlink" title="2.函数名是函数的地址"></a>2.函数名是函数的地址</h4><pre><code class="cpp">    例：        bool isFriday()&#123;            return true;        &#125;        int main()&#123;            if(isFriday)&#123;                cout&lt;&lt;&quot;yes&quot;;            &#125;            else&#123;                cout&lt;&lt;&quot;no&quot;;            &#125;            return 0;        &#125;</code></pre><p>这个的结果恒为真，因为调用函数没有加上（），函数名是地址恒不为0;</p><h4 id="3-switch每个case都要有break"><a href="#3-switch每个case都要有break" class="headerlink" title="3.switch每个case都要有break"></a>3.switch每个case都要有break</h4><pre><code class="cpp">    通常情况下case之后都要有break    但是如果需要滑入下一个分支，必须明确注释或者使用c++17的[[fallthrough]]</code></pre><h4 id="4-和–"><a href="#4-和–" class="headerlink" title="4.++和–"></a>4.++和–</h4><pre><code class="cpp">    例：        int i=0;        int x=0;        int b[10];        x=b[i]+i++;        func(i++,i);    </code></pre><p>同一个表达式中的i，使用的是自增之前的值还是之后的无法确定，存在隐患<br>含有变量自增或者自减的表达式中禁止再次使用该变量.</p><h4 id="5-避免过大的栈上变量"><a href="#5-避免过大的栈上变量" class="headerlink" title="5.避免过大的栈上变量"></a>5.避免过大的栈上变量</h4><pre><code class="cpp">    class Vector&#123;        public :        int value[10000];    &#125;    Vector Decrement(Vector input)&#123;        Vector output;        for(int i=0;i&lt;10000;i++)&#123;            output.value[i]=input.value[i]+100;        &#125;        return output;    &#125;</code></pre><p>当局部变量大小超过1k时就需要审视其合理性<br>较大的函数类型作为函数参数时，应使用引用或者const引用</p><h4 id="6-使用引用代替指针"><a href="#6-使用引用代替指针" class="headerlink" title="6.使用引用代替指针"></a>6.使用引用代替指针</h4><pre><code class="cpp">    void Caculate(int input, char* op, int* output)    &#123;        if (op == nullptr) &#123;            *output = input;        &#125;         else if (strcmp(op, &quot;add&quot;) == 0) &#123;            *output = input + 10;        &#125;         else if (strcmp(op, &quot;subtract&quot;) == 0) &#123;            *output = input - 10;        &#125;    &#125;</code></pre><p>单个对象不允许为空，建议用引用int&amp;<br>但如果传入的是一串对象(数组)，则应当用指针或者封装的类型<br>引用不为空，而且指向的对象不会变化。应当优先使用引用取代指针。</p><h4 id="7-不修改变量、函数采用const修饰"><a href="#7-不修改变量、函数采用const修饰" class="headerlink" title="7.不修改变量、函数采用const修饰"></a>7.不修改变量、函数采用const修饰</h4><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>这里两个成员函数都不修改形参或者是this，所以应采用const修饰</p><pre><code class="cpp">    class MyValue &#123;    public:     // .其他成员和接口        int GetValue()const &#123; return value; &#125;        bool IsEqual(MyValue&amp; other)const        &#123;            return value == other.value;        &#125;    private:        int value;    &#125;;</code></pre><p>定义接口时，将不修改的类型声明为const,可以让使用者知晓哪些对象不会被修改。<br> 编码时如不惧将对象修改了，，能够在编译时就发现问题而不是等到运行时debug.</p><h4 id="8-数组作为参数"><a href="#8-数组作为参数" class="headerlink" title="8.数组作为参数"></a>8.数组作为参数</h4><pre><code class="cpp">    int CountLength(char str[])//int CountLength(char str[10])    &#123;        for (inti = 0;i &lt; sizeof(str) / sizeof(char); ++i) &#123;            if(str[] == &#39;\0&#39;) &#123;            return i;            &#125;        &#125;        return sizeof(str);    &#125;</code></pre><p>这里str是一个指针，sizeof(str)返回的是指针的大小，而不是数组的大小<br>不要将指针作为sizeof的参数来获取指向内容的长度。<br>不要对函数的数组参数使用sizeof</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全编码与未定义行为</title>
      <link href="/p/22884.html"/>
      <url>/p/22884.html</url>
      
        <content type="html"><![CDATA[<h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><h4 id="1-不要使用越界的指针或者数组下标"><a href="#1-不要使用越界的指针或者数组下标" class="headerlink" title="1.不要使用越界的指针或者数组下标"></a>1.不要使用越界的指针或者数组下标</h4><pre><code class="cpp">    例：        int a[4];        for(int i=0;i&lt;=4;i++)&#123;            a[i]=i;        &#125;    缓冲区溢出在CWE漏洞库中排名第二  </code></pre><h4 id="2-避免任何可能产生未定义行为的代码"><a href="#2-避免任何可能产生未定义行为的代码" class="headerlink" title="2.避免任何可能产生未定义行为的代码"></a>2.避免任何可能产生未定义行为的代码</h4><pre><code class="cpp">    例：        char *Getstring(bool choice)&#123;            char str[6];            if(choice)&#123;                strcpy(str,&quot;true&quot;);            &#125;            else&#123;                strcpy(str,&quot;false&quot;);            &#125;            return str;        &#125;    因为局部变量保存在栈中，随着函数返回，栈内内容可能会被释放或者被覆盖。</code></pre><h4 id="3-确保整数运算不溢出"><a href="#3-确保整数运算不溢出" class="headerlink" title="3.确保整数运算不溢出"></a>3.确保整数运算不溢出</h4><pre><code class="cpp">    例：        int32_t Average(int32_t x,int32_t y)&#123;            return (x+y)/2;        &#125;    可能发生int溢出，超出int表示范围，导致结果异常        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int64_t&gt; (x+y)/2;        &#125;    这是一个错误的更正,已经发生溢出才进行类型转换。        int32_t Average(int32_t x,int32_t y)&#123;            return static_cast&lt;int32_t&gt;((static_cast&lt;int64_t&gt;(x)+y)/2);        &#125;    运算时编译器会自动将y进行类型转换为int64_t</code></pre><h4 id="4-char用来表示数值时明确有符号还是无符号"><a href="#4-char用来表示数值时明确有符号还是无符号" class="headerlink" title="4.char用来表示数值时明确有符号还是无符号"></a>4.char用来表示数值时明确有符号还是无符号</h4><pre><code class="cpp">    例：        char a=-100;        unsigned int b=a;        标准并没有规定char类型是否是有符号数，可能导致不同编译器产生不同结果</code></pre><h4 id="5-避免混用有符号和无符号数"><a href="#5-避免混用有符号和无符号数" class="headerlink" title="5.避免混用有符号和无符号数"></a>5.避免混用有符号和无符号数</h4><pre><code class="cpp">    例：        int  a=-1;        unsigned b=1;        cout&lt;&lt;(b&gt;a);    结果是false，因为编译器将有符号转换为了无符号数，所以-1是无符号int最大的正数</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为可信课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>define、const、typedef、inline</title>
      <link href="/p/397.html"/>
      <url>/p/397.html</url>
      
        <content type="html"><![CDATA[<h2 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h2><h3 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h3><p><strong>const</strong> 定义的常量是变量带类型，⽽  定义的只是个常数不带类型；<br><strong>#define</strong>只在预处理阶段起作⽤，简单的⽂本替换，⽽ <strong>const</strong> 在编译、<br>链接过程中起作⽤；<br><strong>#define</strong>   只是简单的字符串替换没有类型检查。⽽<strong>const</strong>是有数据类型的，<br>是要进⾏判断的，可以避免⼀些低级错误；<br><strong>#define</strong> 预处理后，占⽤代码段空间，<strong>const</strong> 占⽤数据段空间；<br><strong>const</strong>m 不能重定义，⽽**#define** 可以通过#undef取消某个符号<br>的定义，进⾏重定义；<br><strong>define</strong>   独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。</p><h3 id="define-和别名-typedef-的区别"><a href="#define-和别名-typedef-的区别" class="headerlink" title="define  和别名 typedef 的区别"></a><strong>define</strong>  和别名 typedef 的区别</h3><h5 id="执⾏时间不同"><a href="#执⾏时间不同" class="headerlink" title="执⾏时间不同"></a>执⾏时间不同</h5><p><strong>typedef</strong> 在编译阶段有效，<strong>typedef</strong> 有类型检查的功能；**#define**是宏定义，发⽣在预处理阶段，不进⾏类型检查；</p><h5 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h5><p><strong>typedef</strong> ⽤来定义类型的别名，定义与平台⽆关的数据类型，<br>与   <strong>struct</strong>   的结合使⽤等。<br><strong>#define</strong>   不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p><h5 id="作⽤域不同"><a href="#作⽤域不同" class="headerlink" title="作⽤域不同"></a>作⽤域不同</h5><p><strong>#define</strong> 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。<br>⽽ typedef 有⾃⼰的作⽤域。</p><h3 id="define-与-inline-的区别"><a href="#define-与-inline-的区别" class="headerlink" title="define 与 inline 的区别"></a>define 与 inline 的区别</h3><p> #define是关键字，inline是函数；<br>宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；<br>inline 函数有类型检查，相⽐宏定义⽐较安全；</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>非零段划分</title>
      <link href="/p/40034.html"/>
      <url>/p/40034.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,…,Aj 是一个非零段     当且仅当以下条件同时满足：    ·1≤i≤j≤n；    ·对于任意的整数 k，若 i≤k≤j，则 Ak＞0；    ·i=1 或 Ai-1=0；    ·j=n 或 Aj+1=0。    下面展示了几个简单的例子：    ·A = [3,1,2,0,0,2,0,4,5,0,2]中的4个非零段依次为[3, 1, 2],[2],[4, 5]和[2]；    ·A = [2, 3, 1, 4, 5] 仅有 1 个非零段；    ·A = [0, 0, 0] 则不含非零段（即非零段个数为 0）。    现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。    试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，    可取 p = 1，即不对 A 做任何修改。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入格式    从标准输入读入数据。    输入的第一行包含一个正整数 n。    输入的第二行包含 n 个用空格分隔的自然数 A1, A2, … , An。    输出格式    输出到标准输出。    仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组cnt[]，cnt[i] 表示海平面下降到i时，岛屿数量的变化。差分法是最简洁的解题程序。数组元素d[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中为后缀和）中找出最大值就是所要的结果。程序代码中，STL算法函数unique()用来去除相邻重复的元素。语句“a[0] = a[n + 1] = 0;”用来设置边界值，起辅助计算作用，可以简化程序代码。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* CCF202109-2 非零段划分 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000;const int M = 10000;int a[N + 2], d[M + 1];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    a[0] = a[n + 1] = 0;    n = unique(a, a + n + 2) - a - 1;    memset(d, 0, sizeof d);    for (int i = 1; i &lt; n; i++)        if (a[i - 1] &lt; a[i] &amp;&amp; a[i] &gt; a[i + 1]) d[a[i]]++;        else if (a[i - 1] &gt; a[i] &amp;&amp; a[i] &lt;a[i + 1]) d[a[i]]--;    int ans = 0, sum = 0;   // 差分前缀和即为答案    for (int i = M; i &gt;= 1; i--)        sum += d[i], ans = max(ans, sum);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;&#125;</code></pre><p>来源：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">https://blog.csdn.net/tigerisland45/article/details/120598581</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/p/9616.html"/>
      <url>/p/9616.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。在每一天，你可能会决定购买      或出售股票。你在任何时候最多只能持有一股股票。你也可以购买它，然后在同一天出售。返回你能获      得的最大利润。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: prices = [7,1,5,3,6,4]    输出: 7    解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5的时候卖出,       这笔交易所能获得利润 = 5-1 = 4 。    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6） 的时候卖出,       这笔交易所能获得利润 = 6-3 = 3 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，动态规划"><a href="#一，动态规划" class="headerlink" title="一，动态规划"></a>一，动态规划</h4><pre><code>    考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。    定义状态 dp[i][0] 表示第i天交易完后手里没有股票的最大利润，dp[i][1] 表示第i天交易完后手里      持有一支股票的最大利润（i 从 0 开始）。    考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有      股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将      其卖出，并获得prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：                dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])    再来考虑dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即      dp[i−1][1]，或者前一天结束时还没有股票，即dp[i−1][0]，这时候我们要将其买入，并减少prices[i]      的收益。可以列出如下的转移方程：                dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125;    对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 0dp[0][0]=0，dp[0][1]=−prices[0]。    因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收      益，因此这时候 dp[n−1][0]的收益必然是大于dp[n−1][1] 的，最后的答案即为dp[n−1][0]。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n = prices.size();        int dp[n][2];        dp[0][0] = 0, dp[0][1] = -prices[0];        for (int i = 1; i &lt; n; ++i) &#123;            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);        &#125;        return dp[n - 1][0];    &#125;&#125;;</code></pre><h4 id="二，（贪心算法）本弱鸡的解法"><a href="#二，（贪心算法）本弱鸡的解法" class="headerlink" title="二，（贪心算法）本弱鸡的解法"></a>二，（贪心算法）本弱鸡的解法</h4><pre><code>    因为可以不限制购买，所以只要是顺序对就把他加入。同时要注意的是，连续的顺序对，比如&#123;1，2，3，4&#125;，      实际购买情况是第一天买入第四天卖出，做题顺序不等于实际购买顺序。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int sum=0;        for(int i=1;i&lt;prices.size();i++)&#123;            if(prices[i]&gt;prices[i-1])sum+=prices[i]-prices[i-1];        &#125;        return sum;    &#125;    &#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票1</title>
      <link href="/p/9615.html"/>
      <url>/p/9615.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。    设计一个算法来计算你所能获取的最大利润。    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入：[7,1,5,3,6,4]    输出：5    解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一，暴力法"><a href="#一，暴力法" class="headerlink" title="一，暴力法"></a>一，暴力法</h4><pre><code>—略—</code></pre><h4 id="二，一次遍历"><a href="#二，一次遍历" class="headerlink" title="二，一次遍历"></a>二，一次遍历</h4><pre><code>    如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，      我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么，      我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。因此，我们只需要遍历价格数组      一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖      出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                //不能超过n的值，并不是所有节点都有十个子节点                step += min((long long)n + 1, last) - first;                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><h4 id="三，本弱鸡的解法"><a href="#三，本弱鸡的解法" class="headerlink" title="三，本弱鸡的解法"></a>三，本弱鸡的解法</h4><pre><code>    最近算法课刚刚学习了最大子数组和，所以本弱鸡依葫芦画瓢，从最后一项向前遍历，每一项都等于      减去前一项以后的值。这样就将某两点的最大差值问题变成了该数组之间的最大子数组和问题。注意，      计算子数组和时忽略掉第零项。</code></pre><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><pre><code>class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        for(int i=prices.size()-1;i&gt;0;i--)&#123;            prices[i]=prices[i]-prices[i-1];        &#125;        int sum=0,maxProfit=0;        for(int i=1;i&lt;prices.size();i++)&#123;            sum+=prices[i];            if(sum&gt;maxProfit)maxProfit=sum;            if(sum&lt;0)sum=0;        &#125;        return maxProfit;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典序的第k大数字</title>
      <link href="/p/3457.html"/>
      <url>/p/3457.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。  </code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入: n = 13, k = 2    输出: 10    解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    这里的字典树其实就是一个十叉树，我们只需要构建一个十叉树，然后进行先序遍历就好了。但是      仔细想一下，n的范围一旦很大，对于空间的开销是难以想象的。所以我们要根据十叉树的思想，来      模拟遍历。根据十叉树的性质，每一层中的个数十上一层树的十倍，比如1000~9999就是100~999的      十倍，那么以100~199为前缀的第四层结点个数等于第三层节点个数。也就是说如果从某一棵树第n层      的节点总和大于k的话，那么第k大的元数必定在n-1层。根据这个性质，我们从1为根节点的子树开始      遍历，如果第一层中的结点数大于k，那么第k大的数在第一棵子树上，否则在剩下子树中。遍历下去，      直到找到结果。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>long long int min(long long int a,long long int b)&#123;    return a&gt;b?b:a;    &#125;int findKthNumber(int n, int k)&#123;        int cur = 1;        --k;//初始化为cur = 1，k需要自减1        while (k &gt; 0) &#123;            long long step = 0, first = cur, last = cur + 1;            //统计这棵子树下所有节点数（step）            while (first &lt;= n) &#123;                step += min((long long)n + 1, last) - first;//不能超过n的值，并不是所有节点都有十个子节点                first *= 10;                last *= 10;            &#125;            if (step &lt;= k) &#123;//不在子树中                ++cur;                k -= step;            &#125;             else &#123;//在子树中，进入子树                cur *= 10;                --k;             &#125;        &#125;        return cur;&#125;</code></pre><p>来源：力扣（LeetCode）<br>    链接：<a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order</a><br>    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Easy Strings Merging</title>
      <link href="/p/47143.html"/>
      <url>/p/47143.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><pre><code>给定 nn 个 01 串，每次你可以从某个串开头移除一个字符并把它加入一个新串 SS 的末尾。最大化 SS 中相邻两个字符相同的对数。(P8001)</code></pre><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><pre><code>第一行一个正整数 nn 表示串的个数。接下来 nn 行，每行一个 01 字符串。</code></pre><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><pre><code>一行一个整数表示答案。</code></pre><h5 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h5><pre><code>    输入 ：                                  输出：9    3    0011    0110    1100</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    暴力模拟！！！！！！！！！！用的c语言，没有用String类，只能拿到75分。暂未解决空间溢出问题。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #pragma warning(disable:4996)    #include&lt;stdio.h&gt;    #include&lt;string.h&gt;    char a[10001][10001];    int b[1001];    int c[1001];    int check[1001];    int main() &#123;        int sum1 = 0, sum2 = 0,flag=0;        int n, i, temp;        scanf(&quot;%d&quot;, &amp;n);        temp = n;        for (i = 0; i &lt; n; i++) &#123;            scanf(&quot;%s&quot;, a[i]);            c[i] = strlen(a[i]);        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (!check[i]&amp;&amp;b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum1--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++,sum1++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum1--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        temp = n;        for (i = 0; i &lt; n; i++) &#123;            b[i] = 0;            check[i] = 0;        &#125;        while (temp) &#123;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;1&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if(flag)sum2--;            flag = 0;            if (b[i] == c[i])temp--;            for (i = 0; i &lt; n; i++) &#123;                while (b[i] &lt; c[i] &amp;&amp; a[i][b[i]] == &#39;0&#39;)flag=1,b[i]++, sum2++;                if (b[i] == c[i])check[i] = 1;            &#125;            if (flag)sum2--;            flag = 0;            temp = n;            for (i = 0; i &lt; n; i++) &#123;                if (check[i] == 1)temp--;            &#125;        &#125;        if (sum1 &gt; sum2)printf(&quot;%d&quot;, sum1);        else printf(&quot;%d&quot;, sum2);        return 0;    &#125;                                                                                 </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><pre><code>    暂时无</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>779 第k个语法符号</title>
      <link href="/p/65488.html"/>
      <url>/p/65488.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><pre><code>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）例子:输入: N = 1, K = 1输出: 0输入: N = 2, K = 1输出: 0输入: N = 2, K = 2输出: 1输入: N = 4, K = 5输出: 1解释:第一行: 0第二行: 01第三行: 0110第四行: 01101001来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/k-th-symbol-in-grammar</code></pre><h3 id="本弱鸡解法"><a href="#本弱鸡解法" class="headerlink" title="本弱鸡解法"></a>本弱鸡解法</h3><pre><code class="bash">    可以将第n个数字串平均分两部分，前半部分和第n-1数字串相同，后半部分则是第n-1数字串按位取反    那么我们可以判断k的位置，从而不断缩小数字串的长度，最终到第一个字符串；</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    int kthGrammar(int n, int k)&#123;    int sign=1;    while(1)&#123;        if(k&lt;=(1&lt;&lt;(n-1)))&#123;            n--;        &#125;        if(n&amp;&amp;k&gt;(1&lt;&lt;(n-1)))&#123;            k=k-(1&lt;&lt;(n-1));            sign*=-1;        &#125;        if(k==1)&#123;            return sign&gt;0?0:1;        &#125;    &#125;&#125;                                                                                      </code></pre><h3 id="大佬做法"><a href="#大佬做法" class="headerlink" title="大佬做法"></a>大佬做法</h3><p>经过观察发现这道题的解其实就是对K-1进行了一个奇偶校验，因此连N这个参数都用不着，O(1)时间空间复杂度求解</p><pre><code>    int kthGrammar(int N, unsigned int K) &#123;        K -= 1;        K ^= K &gt;&gt; 1;        K ^= K &gt;&gt; 2;        K = (K &amp; 0x11111111U) * 0x11111111U;        return (K &gt;&gt; 28) &amp; 1;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/p/16107.html"/>
      <url>/p/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
