<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-21T08:17:01.407Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分库分表</title>
    <link href="http://example.com/p/a3a0c28e.html"/>
    <id>http://example.com/p/a3a0c28e.html</id>
    <published>2023-07-21T06:12:33.035Z</published>
    <updated>2023-07-21T08:17:01.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><strong>【分库】</strong></p><p>分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就可能会成为瓶颈，因为数据库的连接数是有限的，虽然可以调整，但是也不是无限调整的。当你的数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</p><p>常见的分库方式有：单库单表 -&gt; 单库多表 -&gt; 多库多表</p><p><strong>【分表】</strong></p><p>分表，就是将一个表结构分为多个表，分表后，可以存在于同一个库里，也可以放到不同的库。分表其实主要解决的是数据量大的问题。</p><p>常见的分表方式：</p><ul><li>纵向分表：根据数据的活跃度进行拆分，也就是按照字段使用活跃度来拆分。</li><li>横向分表：把大的表结构，横向切割为同样结构的不同表，也就是同样的表按照某个业务规则复制很多个。</li></ul><p><strong>分库分表根本不是一件事，而是三件事。分别是”只分库不分表”、”只分表不分库”、以及”既分库又分表”。</strong></p><h2 id="为什么需要考虑分库分表呢"><a href="#为什么需要考虑分库分表呢" class="headerlink" title="为什么需要考虑分库分表呢"></a>为什么需要考虑分库分表呢</h2><p>不管是分库还是分表都是因为单个空间内存储数据过多，导致性能下降无法满足正常业务需要。拆分后减小单个个体的负担，缩短操作时间，提高性能满足业务需要。数据库出现性能瓶颈，对外表现有几个方面：</p><ul><li>大量请求阻塞<ul><li>在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。</li></ul></li><li>SQL 操作变慢<ul><li>如果数据库中存在一张上亿数据量的表，一条 SQL 没有命中索引会全表扫描，这个查询耗时会非常久。</li></ul></li><li>存储出现问题<ul><li>业务量剧增，单库数据量越来越大，给存储造成巨大压力。</li></ul></li></ul><p><strong>IO 瓶颈</strong><br>第一种：磁盘读 IO 瓶颈。</p><p>由于热点数据太多，数据库缓存完全放不下，查询时会产生大量的磁盘 IO，查询速度会比较慢，这样会导致产生大量活跃连接，最终可能会发展成无连接可用的后果。</p><p>可以采用一主多从，读写分离的方案，用多个从库分摊查询流量。或者采用分库+水平分表(把一张表的数据拆成多张表来存放，比如订单表可以按 user_id 来拆分)的方案。</p><p>第二种：磁盘写 IO 瓶颈。</p><p>由于数据库写入频繁，会产生频繁的磁盘写入 IO 操作，频繁的磁盘 IO 操作导致产生大量活跃连接，最终同样会发展成无连接可用的后果。</p><p>这时只能采用分库方案，用多个库来分摊写入压力。再加上水平分表的策略，分表后，单表存储的数据量会更小，插入数据时索引查找和更新的成本会更低，插入速度自然会更快。</p><p><strong>CPU 瓶颈</strong></p><p>SQL 问题：如果 SQL 中包含 join，group by，order by，非索引字段条件查询等增加 CPU 运算的操作，会对 CPU 产生明显的压力。</p><p>这时可以考虑 SQL 优化，创建适当的索引，也可以把一些计算量大的SQL逻辑放到应用中处理。</p><p>单表数据量太大：由于单张表数据量过大，比如超过一亿，查询时遍历树的层次太深或者扫描的行太多，SQL 效率会很低，也会非常消耗 CPU。这时可以根据业务场景水平分表。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>随着业务快速发展，数据库中的数据量猛增，所有的数据限制在一台服务器，「数据库物理机本身的CPU、内存、网络IO、磁盘等都会成为性能瓶颈」，此时我们可以按照业务的划分，将不同的表放在不同的服务器中，分散流量，减轻单个数据库的压力，提高系统的性能。</p><p><strong>「垂直分库优点」</strong></p><ul><li>专库专用，业务层面解耦</li><li>能够针对不同业务的数据进行分级管理、维护、监控、扩展</li><li>在一定程度上提升了IO、数据库连接数、降低单机硬件资源的瓶颈<br><strong>「垂直分库缺点」</strong></li><li>事务一致性的问题</li><li>多表连接查询困难</li></ul><p><strong>场景</strong>：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>当我们的一行数据过大时，数据页存储的数据行就会减少，也就是说跨数据页查询的概率就会增加，因此垂直分表就是将一个表拆分到多个表，避免出现数据库跨页存储的问题，从而提升查效率。</p><p><strong>「垂直分表拆分原则」</strong></p><ul><li>将热点字段和不常用的字段区分，放在不同的表中</li><li>将text，blob等大字段拆分出来放在附表中</li><li>将组合查询的列放在一张表中<br><strong>「垂直分表优点」</strong></li><li>减少锁竞争，查询不同字段数据互不影响</li><li>可实现冷热分离的数据表设计</li><li>可以使得行数据变小，一个数据页能存放更多的数据，最大限度利用数据页缓存，减少查询的 I&#x2F;O 次 数<br><strong>「垂直分表缺点」</strong></li><li>事务一致性的问题</li><li>多表连接查询困难</li><li>无法解决单表数据量过大</li></ul><p><strong>场景：</strong>系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>垂直分库是将不同业务表分别放在了不同数据库中以此减轻单个数据库的性能瓶颈，但是如果某个核心业务的并发非常高，比如订单库，双十一下单的并发非常高，单个的订单库仍然存在单个订单数据库性能瓶颈问题，因此我们可以对数据进行分片，将单个订单库进行拆分成多个库，以此提高数据库总体性能。水平分库的本质也是分表，是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</p><p><strong>水平分库优点」</strong></p><ul><li>解决单个库高并发的性能瓶颈</li><li>切分的表的结构相同，应用层改造较少，只需要增加路由规则即可</li><li>提高了系统的稳定性和负载能力。<br><strong>「水平分库缺点」</strong></li><li>分片事务的一致性难以解决</li><li>数据扩容的难度和维护量极大</li></ul><p><strong>场景：</strong>系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>当我们的业务量猛增，单表数据达数千万甚至上亿的时候，查询效率会降低，此时我们考虑将数据表按照一定的规则将表中的记录进行分片，存储在不同的表中，以此提高查询效率。<br>水平分表的本质是数据分片，将不同的数据按照一定的规则（ hash取模&#x2F;range范围）将数据存储在不同的表中，以此减少单表的数据量，提高查询效率</p><p><strong>「水平分表优点」</strong></p><ul><li>解决单表数据量大，查询性能下降的问题</li><li>可实现多表连接查询<br><strong>「水平分表缺点」</strong></li><li>引发排序、分页、函数计算等问题</li><li>数据扩容的难度和维护量极大。</li></ul><p><strong>场景</strong>：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</p><h2 id="数据切分"><a href="#数据切分" class="headerlink" title="数据切分"></a>数据切分</h2><p>当设计中按照业务逻辑实现了分库或者分表，我们在开发过程中怎样将不同的数据存放到指定的库或者表中。要想做到数据的水平切分，在每一个表中都要有相冗余字符作为切分依据和标记字段，通常的应用中我们选用id作为区分字段，基于此就有如下三种分库或者分表的方式和规则：（当然还可以有其他的方式）</p><h3 id="号段分区"><a href="#号段分区" class="headerlink" title="号段分区"></a>号段分区</h3><p>id为1～1000的对应DB1，1001～2000的对应DB2，以此类推；</p><p>优点：可部分迁移</p><p>缺点：数据分布不均</p><h3 id="hash取模分区"><a href="#hash取模分区" class="headerlink" title="hash取模分区"></a>hash取模分区</h3><p>对id进行hash（或者如果id是数值型的话直接使用id 的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对id的hash值进行取模运算，也就是id%4,这样的话每次运算就有四种可能：结果为1的时候对应DB1；结果为2的时候对应DB2；结果为3的时候对应DB3；结果为0的时候对应DB4。这样一来就非常均匀的将数据分配到4个DB中。</p><p>优点：数据分布均匀</p><p>缺点：数据迁移的时候麻烦，不能按照机器性能分摊数据，如果需要扩容二次分表，表的总数量发生变化时，就需要重新计算hash值，就需要涉及到数据迁移了。</p><p>为了解决扩容的问题，我们可以采用一致性哈希的方式来做分表。</p><h3 id="在认证库中保存数据库配置"><a href="#在认证库中保存数据库配置" class="headerlink" title="在认证库中保存数据库配置"></a>在认证库中保存数据库配置</h3><p>就是建立一个DB，这个DB单独保存id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作。</p><p>优点：灵活性强，一对一关系</p><p>缺点：每次查询之前都要多一次查询，性能大打折扣</p><h2 id="分库分表引发什么问题"><a href="#分库分表引发什么问题" class="headerlink" title="分库分表引发什么问题"></a>分库分表引发什么问题</h2><p>分库分表之后，虽然能够解决数据库的性能问题，但是也带来了一系列的其他问题：</p><p>事务问题<br>跨库关联问题<br>排序、分页、函数计算问题<br>分布式ID问题<br>多数据源问题</p><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><h3 id="跨库关联问题"><a href="#跨库关联问题" class="headerlink" title="跨库关联问题"></a>跨库关联问题</h3><p>在单库单表中，我们经常使用JOIN来进行多表查询，但是经过分库分表后多个表可能存在于多个数据库中，无法直接使用join进行联表查询，但是联表查询是非常常见的，所以针对这种情况有以下几种解决方式</p><h4 id="字段冗余"><a href="#字段冗余" class="headerlink" title="字段冗余"></a>字段冗余</h4><p>利用空间换时间，为了性能而避免join查询，将查询字段冗余。<br>例如：订单表保存userId时候，也将用户名称性别等需要查询的字段冗余保存一份，这样查询订单详情时就不需要再去查询用户表了。</p><h4 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h4><p>在系统模块中，对于一些依赖的数据表，在每个数据库都保存一份，避免跨库join查询。</p><h4 id="ER-表（绑定表）"><a href="#ER-表（绑定表）" class="headerlink" title="ER 表（绑定表）"></a>ER 表（绑定表）</h4><p>先确定各个业务表的关联关系，将那些存在关联关系的表记录存放在同一个分片上，避免跨分片join问题</p><h4 id="系统层组装"><a href="#系统层组装" class="headerlink" title="系统层组装"></a>系统层组装</h4><p>在系统层面，分多次查询，将获得到的数据通过代码进行字段拼装</p><h3 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h3><p>分库分表之后，数据分散，在跨节点进行count,order by,group by,limit 以及聚合函数的时候需要特殊处理，可以采用分片的方式：先在每个分片上执行相应的函数，得到结果后在应用程序端进行合并，得到最终结果。</p><h3 id="分布式ID问题"><a href="#分布式ID问题" class="headerlink" title="分布式ID问题"></a>分布式ID问题</h3><p>分库分表之后，我们不能再依赖数据库自增主键了，分表以后每个表都可以自增，会导致ID 重复或者混乱的问题，因此我们需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p><ul><li>UUID</li><li>基于数据库自增单独维护一张 ID表</li><li>号段模式</li><li>Redis</li><li>雪花算法（Snowflake）</li><li>美团Leaf</li><li>滴滴Tinyid</li></ul><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>好处就是本地生成，不要基于数据库；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><h3 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h3><p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p>适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>实例1生成的ID从1000开始，到1999结束。<br>实例2生成的ID从2000开始，到2999结束。<br>实例3生成的ID从3000开始，到3999结束。<br>实例4生成的ID从4000开始，到4999结束。<br>如果第一个实例的ID已经用到1999了怎么办?那就生成一个新的起始值：实例1生成的ID从5000开始，到5999结束。实例2生成的ID从6000开始，到6999结束。实例3生成的ID从7000开始，到7999结束。实例4生成的ID从8000开始，到8999结束。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法也是比较常用的一种分布式ID的生成方式，它具有全局唯一、递增、高可用的特点。</p><p>雪花算法生成的主键主要由 4 部分组成，1bit符号位、41bit时间戳位、10bit工作进程位以及 12bit 序列号位。</p><p>时间戳占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p><p>工作进程位占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p><p>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p><p>所以，一个雪花算法可以在同一毫秒内最多可以生成1024 X 4096 &#x3D; 4194304个唯一的ID</p><h4 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h4><p>这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。</p><p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="多数据源问题"><a href="#多数据源问题" class="headerlink" title="多数据源问题"></a>多数据源问题</h3><p>多数据源主要针对分库，既然数据库变成了多个，那什么时候查询那个库必然是一个必须要解决的问题，一般的解决方式有：「应用程序适配和代理层适配」。一般我们都会使用比较成熟的中间件来处理。</p><h2 id="如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>如何设计才可以让系统从未分库分表动态切换到分库分表上？</h2><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个导数的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>验证一下，ok了，完美，大家伸个懒腰，看看看凌晨 4 点钟的夜景，打个滴滴回家吧。</p><p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看凌晨 4 点的风景。</p><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p><p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p><p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p><p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p><p>现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</p><h2 id="如何设计可以动态扩容缩容的分库分表方案"><a href="#如何设计可以动态扩容缩容的分库分表方案" class="headerlink" title="如何设计可以动态扩容缩容的分库分表方案"></a>如何设计可以动态扩容缩容的分库分表方案</h2><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1小时数据就导完了。这没有问题。</p><p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载32 * 1000 &#x3D; 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 &#x3D; 48000 的写并发，接近 5万&#x2F;s 的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128个库，256个库，512个库。</p><p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>每秒的 5 万写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>一个实践是利用 32 * 32 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><p>+———+——–+——–+<br>| orderId | 库编号 | 表编号 |<br>+———+——–+——–+<br>|   259   |   3    |   8    |<br>|   1189  |   5    |   5    |<br>|   352   |   0    |   11   |<br>|   4593  |   17   |   15   |<br>+———+——–+——–+</p><p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表。</p><p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>这里对步骤做一个总结：</p><ul><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 &#x3D; 库，orderId &#x2F; 32 模 32 &#x3D; 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;【分库】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就</summary>
      
    
    
    
    <category term="Database" scheme="http://example.com/categories/Database/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>concepts</title>
    <link href="http://example.com/p/7082d49f.html"/>
    <id>http://example.com/p/7082d49f.html</id>
    <published>2023-07-20T13:46:19.620Z</published>
    <updated>2023-07-20T14:12:34.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h1><p>我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义half 对于 int 和 string 有不同的作用：</p><pre><code>int half(int n)&#123;    return n / 2;&#125;string half(string s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>除了 int，我们还有差不多的 short、long 等类型，甚至还有 boost::multiprecision::cpp_int；除了 string，我们也还有 wstring、u16string、u32string 等等。上面的每个函数，实际上都适用于一族类型，而不是单个类型。重载在这方面并帮不了什么忙</p><p>C++ 的概念就是用来解决这个问题的。对于上面的例子，我们只需要事先定义了 Integer和 String 的概念），我们就可以写出下面这样的代码：</p><pre><code>template &lt;Integer N&gt;N half(N n)&#123;    return n / 2;&#125;template &lt;String S&gt;S half(S s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>从概念上讲，上面这种形式的含义和下面的代码实质相同（以上面的第一个函数为例）</p><pre><code>template &lt;typename N&gt;requires Integer&lt;N&gt;N half(N n)&#123;    return n / 2;&#125;</code></pre><p>这个 half 是一个函数模板，有一个模板参数，启用这个模板的前提条件是这个参数满足 Integer 这个约束。</p><h2 id="基本的-Concepts"><a href="#基本的-Concepts" class="headerlink" title="基本的 Concepts"></a>基本的 Concepts</h2><p><img src="https://s1.ax1x.com/2023/07/20/pCHyjiT.png" alt="pCHyjiT.png"></p><p>我们从下往上看一下：</p><ul><li>move_constructible：可移动构造</li><li>swappable：可交换</li><li>movable：可移动构造、可交换，合在一起就是可移动了</li><li>copy_constructible：可拷贝构造</li><li>copyable：可拷贝构造、可移动，合在一起就是可拷贝了</li><li>default_initializable：可默认初始化（名字不叫 default_constructible 是因为目前的 type traits 中有 is_default_constructible，且意义和default_initializable 有点微妙的区别；</li><li>semiregular：可复制、可默认初始化，合在一起就是半正则了</li><li>equality_comparable：可相等比较，即对象之间可以使用 &#x3D;&#x3D; 运算符</li><li>regular：半正则、可相等比较，合在一起就是正则了</li></ul><ol><li><code>move_constructible</code>（可移动构造）：类型可以通过移动构造函数从另一个对象获得资源，而不会进行深拷贝。通常用于支持资源所有权的转移。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MyClass &#123;public:    // Move constructor    MyClass(MyClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::move_constructible&lt;MyClass&gt;::value, &quot;MyClass must be move constructible&quot;);</code></pre><ol start="2"><li><code>swappable</code>（可交换）：类型的对象可以通过 <code>std::swap</code> 进行交换，即可以互相交换其内部状态或资源。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class SwappableClass &#123;public:    // Implement the swap function to enable swapping of objects    void swap(SwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::swappable&lt;SwappableClass&gt;, &quot;SwappableClass must be swappable&quot;);</code></pre><ol start="3"><li><code>movable</code>（可移动构造、可交换）：类型既支持移动构造（<code>move_constructible</code>）又支持交换（<code>swappable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MovableAndSwappableClass &#123;public:    // Move constructor    MovableAndSwappableClass(MovableAndSwappableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;    // Implement the swap function to enable swapping of objects    void swap(MovableAndSwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::movable&lt;MovableAndSwappableClass&gt;, &quot;MovableAndSwappableClass must be movable&quot;);</code></pre><ol start="4"><li><code>copy_constructible</code>（可拷贝构造）：类型可以通过拷贝构造函数从另一个对象创建一个副本。</li></ol><p>示例：</p><pre><code class="cpp">class CopyConstructibleClass &#123;public:    // Copy constructor    CopyConstructibleClass(const CopyConstructibleClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::copy_constructible&lt;CopyConstructibleClass&gt;, &quot;CopyConstructibleClass must be copy constructible&quot;);</code></pre><ol start="5"><li><code>copyable</code>（可拷贝构造、可移动）：类型既支持拷贝构造（<code>copy_constructible</code>）又支持移动构造（<code>move_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class CopyableAndMovableClass &#123;public:    // Copy constructor    CopyableAndMovableClass(const CopyableAndMovableClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;    // Move constructor    CopyableAndMovableClass(CopyableAndMovableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::copyable&lt;CopyableAndMovableClass&gt;, &quot;CopyableAndMovableClass must be copyable&quot;);</code></pre><ol start="6"><li><code>default_initializable</code>（可默认初始化）：类型可以通过默认构造函数进行初始化，而不需要提供任何参数。</li></ol><p>示例：</p><pre><code class="cpp">class DefaultInitializableClass &#123;public:    // Default constructor    DefaultInitializableClass() &#123;        // Initialize internal state/resources here    &#125;&#125;;static_assert(std::default_initializable&lt;DefaultInitializableClass&gt;, &quot;DefaultInitializableClass must be default initializable&quot;);</code></pre><ol start="7"><li><code>semiregular</code>（可复制、可默认初始化）：类型既支持默认初始化（<code>default_initializable</code>）又支持拷贝构造（<code>copy_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class SemiregularClass &#123;public:    // Default constructor    SemiregularClass() &#123;        // Initialize internal state/resources here    &#125;    // Copy constructor    SemiregularClass(const SemiregularClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::semiregular&lt;SemiregularClass&gt;, &quot;SemiregularClass must be semiregular&quot;);</code></pre><ol start="8"><li><code>equality_comparable</code>（可相等比较）：类型的对象可以使用 <code>==</code> 运算符进行相等比较。</li></ol><p>示例：</p><pre><code class="cpp">class EqualityComparableClass &#123;public:    // Implement the equality operator (==)    bool operator==(const EqualityComparableClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::equality_comparable&lt;EqualityComparableClass&gt;, &quot;EqualityComparableClass must be equality comparable&quot;);</code></pre><ol start="9"><li><code>regular</code>（半正则、可相等比较）：类型既支持可相等比较（<code>equality_comparable</code>）又支持默认初始化（<code>default_initializable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class RegularClass &#123;public:    // Default constructor    RegularClass() &#123;        // Initialize internal state/resources here    &#125;    // Implement the equality operator (==)    bool operator==(const RegularClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::regular&lt;RegularClass&gt;, &quot;RegularClass must be regular&quot;);</code></pre><p>上述匹配的行为都是在编译期完成的，因此concept其实是zero-cost的。 </p><pre><code>// 任意类型都能匹配成功的约束，因此mul只要支持乘法运算符的类型都可以匹配成功。template &lt;always_satisfied T&gt;T mul(T a, T b) &#123;    return a * b;&#125;// 整型才能匹配add函数的Ttemplate &lt;integral T&gt;T add(T a, T b) &#123;    return a + b;&#125;// 有符号整型才能匹配subtract函数的Ttemplate &lt;signed_integral T&gt;T subtract(T a, T b) &#123;    return a - b;&#125;int main() &#123;    mul(1, 2); // 匹配成功, T =&gt; int    mul(1.0f, 2.0f);  // 匹配成功，T =&gt; float    add(1, -2);  // 匹配成功, T =&gt; int    add(1.0f, 2.0f); // 匹配失败, T =&gt; float，而T必须是整型    subtract(1U, 2U); // 匹配失败，T =&gt; unsigned int,而T必须是有符号整型    subtract(1, 2); // 匹配成功, T =&gt; int&#125;</code></pre><p>简单总结就是 有3种方式，另外再加上与auto关键字的一些结合方式。</p><pre><code>// 约束函数模板方法1template &lt;my_concept T&gt;void f(T v);// 约束函数模板方法2template &lt;typename T&gt;requires my_concept&lt;T&gt;void f(T v);// 约束函数模板方法3template &lt;typename T&gt;void f(T v) requires my_concept&lt;T&gt;;// 直接约束C++14的auto的函数参数void f(my_concept auto v);// 约束模板的auto参数template &lt;my_concept auto v&gt;void g();// 约束auto变量my_concept auto foo = ...;</code></pre><p>Concept当然也可以用在lambda函数上，使用方法跟上面一样，也有同样数量的花式用法</p><pre><code>// 约束lambda函数的方法1auto f = []&lt;my_concept T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法2auto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法3auto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; &#123;// ...&#125;;// auto函数参数约束auto f = [](my_concept auto v) &#123;// ...&#125;;// auto模板参数约束auto g = []&lt;my_concept auto v&gt; () &#123;// ...&#125;;</code></pre><p>requires关键字的其他用法<br>requires关键字不仅能用在concept的使用上，也可以用在定义中。 例如</p><p>&#x2F;&#x2F; requires用在使用concept时<br>template <typename t><br>  requires my_concept<T><br>void f(T);</T></typename></p><p>&#x2F;&#x2F; requires用在concept的定义，它表达了类型T的参数f，必须符合大括号内的模式，也就是能被调用。<br>&#x2F;&#x2F; 也就是它是一个函数或者一个重载了operator()的类型<br>template <typename t><br>concept callable &#x3D; requires (T f) { f(); }; </typename></p><p>template <typename t><br>  requires requires (T x) { x + x; } &#x2F;&#x2F; <code>requires</code> 同时使用在concept的定义和使用上<br>T add(T a, T b) {<br>  return a + b;<br>}<br>requires的语法看起来很复杂，初看会觉得很乱，没有啥规律或者总结性的东西。我这边个人理解大概是这样：</typename></p><p>&#x2F;&#x2F; 这种也就是，requires后面接的是一个正在被eval的concept，这也就是用在上面的concept的使用中。<br>requires evaled-concept</p><p>&#x2F;&#x2F; 本质上，concept在evaluate时，也就会是一个编译期返回结果为bool的表达式。这种其实等价于上面那种。<br>requires expression</p><p>&#x2F;&#x2F; 例如 下面这种就是requires后直接接个bool表达式了<br>template <typename t><br>requires std::is_integral_v<T><br>T add(T a, T b) {<br>    return a + b;<br>}<br>我这边认为，requires后接的东西本质上是一个表达式。当然，</T></typename></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concepts&quot;&gt;&lt;a href=&quot;#concepts&quot; class=&quot;headerlink&quot; title=&quot;concepts&quot;&gt;&lt;/a&gt;concepts&lt;/h1&gt;&lt;p&gt;我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义half </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp20" scheme="http://example.com/tags/cpp20/"/>
    
  </entry>
  
  <entry>
    <title>本地套接字</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-19T14:54:49.693Z</published>
    <updated>2023-07-19T15:04:01.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h1><p>本地套接字是 IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是进程间通信的常用方法，但因为本地套接字开发便捷，接受度高，所以普遍适用于在同一台主机上进程间通信的各种场景.</p><p>现在最火的云计算技术是什么？无疑是 Kubernetes 和 Docker。在 Kubernetes 和 Docker 的技术体系中，有很多优秀的设计，比如 Kubernetes 的 CRI（Container Runtime Interface），其思想是将 Kubernetes 的主要逻辑和 Container Runtime 的实现解耦。</p><p>为了实现和容器运行时的解耦，kubelet 设计了基于本地套接字的客户端 - 服务器 GRPC 调用。<br>Docker 其实也是大量使用了本地套接字技术来构建的。</p><h2 id="本地套接字概述"><a href="#本地套接字概述" class="headerlink" title="本地套接字概述"></a>本地套接字概述</h2><p>本地套接字一般也叫做 UNIX 域套接字，最新的规范已经改叫本地套接字。在前面的 TCP&#x2F;UDP 例子中，我们经常使用 127.0.0.1 完成客户端进程和服务器端进程同时在本机上的通信，那么，这里的本地套接字又是什么呢？</p><p>本地套接字是一种特殊类型的套接字，和 TCP&#x2F;UDP 套接字不同。TCP&#x2F;UDP 即使在本地地址通信，也要走系统网络协议栈，而本地套接字，严格意义上说提供了一种单主机跨进程间调用的手段，减少了协议栈实现的复杂度，效率比 TCP&#x2F;UDP 套接字都要高许多。类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等。<br>比如 X Window 实现，如果发现是本地连接，就会走本地套接字，工作效率非常高。</p><h2 id="本地字节流套接字"><a href="#本地字节流套接字" class="headerlink" title="本地字节流套接字"></a>本地字节流套接字</h2><p>这是一个字节流类型的本地套接字服务器端例子。在这个例子中，服务器程序打开本地套接字后，接收客户端发送来的字节流，并往客户端回送了新的字节流。</p><pre><code class="cpp">#include  &quot;lib/common.h&quot; int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamserver &lt;local_path&gt;&quot;);    &#125;     int listenfd, connfd;    socklen_t clilen;    struct sockaddr_un cliaddr, servaddr;     listenfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (listenfd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;     char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);     if (bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;     if (listen(listenfd, LISTENQ) &lt; 0) &#123;        error(1, errno, &quot;listen failed&quot;);    &#125;     clilen = sizeof(cliaddr);    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0) &#123;        if (errno == EINTR)            error(1, errno, &quot;accept failed&quot;);        /* back to for() */        else            error(1, errno, &quot;accept failed&quot;);    &#125;     char buf[BUFFER_SIZE];     while (1) &#123;        bzero(buf, sizeof(buf));        if (read(connfd, buf, BUFFER_SIZE) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s&quot;, buf);         char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, buf);         int nbytes = sizeof(send_line);         if (write(connfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);    &#125;     close(listenfd);    close(connfd);     exit(0); &#125;</code></pre><p>第 12～15 行非常关键，这里创建的套接字类型，注意是 AF_LOCAL，并且使用字节流格式。TCP 的类型是 AF_INET 和字节流类型；UDP 的类型是 AF_INET 和数据报类型。 AF_UNIX 也是可以的，基本上可以认为和 AF_LOCAL 是等价的。<br>第 17～21 行创建了一个本地地址，这里的本地地址和 IPv4、IPv6 地址可以对应，数据类型为 sockaddr_un，这个数据类型中的 sun_family 需要填写为 AF_LOCAL，最为关键的是需要对 sun_path 设置一个本地文件路径。我们这里还做了一个 unlink 操作，以便把存在的文件删除掉，这样可以保持幂等性。<br>第 23～29 行，分别执行 bind 和 listen 操作，这样就监听在一个本地文件路径标识的套接字上，这和普通的 TCP 服务端程序没什么区别。<br>第 41～56 行，使用 read 和 write 函数从套接字中按照字节流的方式读取和发送数据。</p><p>这个本地文件，必须是一个“文件”，不能是一个“目录”。如果文件不存在，后面 bind 操作时会自动创建这个文件。</p><p>下面我们再看一下客户端程序。</p><pre><code class="cpp">#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un servaddr;    sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, argv[1]);    if (connect(sockfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;connect failed&quot;);    &#125;    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int nbytes = sizeof(send_line);        if (write(sockfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);        if (read(sockfd, recv_line, MAXLINE) == 0)            error(1, errno, &quot;server terminated prematurely&quot;);        fputs(recv_line, stdout);    &#125;    exit(0);&#125;</code></pre><p>11～14 行创建了一个本地套接字，和前面服务器端程序一样，用的也是字节流类型 SOCK_STREAM。<br>16～18 行初始化目标服务器端的地址。我们知道在 TCP 编程中，使用的是服务器的 IP 地址和端口作为目标，在本地套接字中则使用文件路径作为目标标识，sun_path 这个字段标识的是目标文件路径，所以这里需要对 sun_path 进行初始化。<br>20 行和 TCP 客户端一样，发起对目标套接字的 connect 调用，不过由于是本地套接字，并不会有三次握手。<br>28～38 行从标准输入中读取字符串，向服务器端发送，之后将服务器端传输过来的字符打印到标准输出上。</p><p>本地字节流套接字和 TCP 服务器端、客户端编程最大的差异就是套接字类型的不同。本地字节流套接字识别服务器不再通过 IP 地址和端口，而是通过本地文件。</p><h2 id="只启动客户端"><a href="#只启动客户端" class="headerlink" title="只启动客户端"></a>只启动客户端</h2><p>第一个场景中，我们只启动客户端程序：</p><pre><code>$ ./unixstreamclient /tmp/unixstream.sockconnect failed: No such file or directory (2)</code></pre><p>由于没有启动服务器端，没有一个本地套接字在 &#x2F;tmp&#x2F;unixstream.sock 这个文件上监听，客户端直接报错，提示我们没有文件存在。</p><h2 id="服务器端监听在无权限的文件路径上"><a href="#服务器端监听在无权限的文件路径上" class="headerlink" title="服务器端监听在无权限的文件路径上"></a>服务器端监听在无权限的文件路径上</h2><p>在 Linux 下，执行任何应用程序都有应用属主的概念。在这里，我们让服务器端程序的应用属主没有 &#x2F;var&#x2F;lib&#x2F; 目录的权限，然后试着启动一下这个服务器程序 ：</p><pre><code>$ ./unixstreamserver /var/lib/unixstream.sockbind failed: Permission denied (13)</code></pre><p>这个结果告诉我们启动服务器端程序的用户，必须对本地监听路径有权限。<br>试一下 root 用户启动该程序：</p><pre><code>sudo ./unixstreamserver /var/lib/unixstream.sock(阻塞运行中)</code></pre><p>打开另外一个 shell，我们看到 &#x2F;var&#x2F;lib 下创建了一个本地文件，大小为 0，而且文件的最后结尾有一个（&#x3D;）号。其实这就是 bind 的时候自动创建出来的文件。</p><pre><code>$ ls -al /var/lib/unixstream.sockrwxr-xr-x 1 root root 0 Jul 15 12:41 /var/lib/unixstream.sock=</code></pre><p>如果我们使用 netstat 命令查看 UNIX 域套接字，就会发现 unixstreamserver 这个进程，监听在 &#x2F;var&#x2F;lib&#x2F;unixstream.sock 这个文件路径上。</p><h2 id="服务器-客户端应答"><a href="#服务器-客户端应答" class="headerlink" title="服务器 - 客户端应答"></a>服务器 - 客户端应答</h2><p>现在，我们让服务器和客户端都正常启动，并且客户端依次发送字符：</p><pre><code>$./unixstreamserver /tmp/unixstream.sockReceive: g1Receive: g2Receive: g3client quit</code></pre><p>服务器端陆续收到客户端发送的字节，同时，客户端也收到了服务器端的应答；最后，当我们使用 Ctrol+C，让客户端程序退出时，服务器端也正常退出。</p><pre><code>$./unixstreamclient /tmp/unixstream.sockg1Hi, g1g2Hi, g2g3Hi, g3^C</code></pre><h2 id="本地数据报套接字"><a href="#本地数据报套接字" class="headerlink" title="本地数据报套接字"></a>本地数据报套接字</h2><p>我们再来看下在本地套接字上使用数据报的服务器端例子：</p><pre><code>#include  &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataserver &lt;local_path&gt;&quot;);    &#125;    int socket_fd;    socket_fd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (socket_fd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;    struct sockaddr_un servaddr;    char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);    if (bind(socket_fd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    char buf[BUFFER_SIZE];    struct sockaddr_un client_addr;    socklen_t client_len = sizeof(client_addr);    while (1) &#123;        bzero(buf, sizeof(buf));        if (recvfrom(socket_fd, buf, BUFFER_SIZE, 0, (struct sockadd *) &amp;client_addr, &amp;client_len) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s \n&quot;, buf);        char send_line[MAXLINE];        bzero(send_line, MAXLINE);        sprintf(send_line, &quot;Hi, %s&quot;, buf);        size_t nbytes = strlen(send_line);        printf(&quot;now sending: %s \n&quot;, send_line);        if (sendto(socket_fd, send_line, nbytes, 0, (struct sockadd *) &amp;client_addr, client_len) != nbytes)            error(1, errno, &quot;sendto error&quot;);    &#125;    close(socket_fd);    exit(0);&#125;</code></pre><p>本地数据报套接字和前面的字节流本地套接字有以下几点不同：</p><p>这里创建的套接字类型，注意是 AF_LOCAL，协议类型为 SOCK_DGRAM。<br>bind 到本地地址之后，没有再调用 listen 和 accept，这其实和 UDP 的性质一样。<br>使用 recvfrom 和 sendto 来进行数据报的收发，不再是 read 和 send</p><p>然后我们再看一下客户端的例子：</p><pre><code>#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un client_addr, server_addr;    sockfd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;client_addr, sizeof(client_addr));        /* bind an address for us */    client_addr.sun_family = AF_LOCAL;    strcpy(client_addr.sun_path, tmpnam(NULL));    if (bind(sockfd, (struct sockaddr *) &amp;client_addr, sizeof(client_addr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sun_family = AF_LOCAL;    strcpy(server_addr.sun_path, argv[1]);    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        size_t nbytes = strlen(send_line);        printf(&quot;now sending %s \n&quot;, send_line);        if (sendto(sockfd, send_line, nbytes, 0, (struct sockaddr *) &amp;server_addr, sizeof(server_addr)) != nbytes)            error(1, errno, &quot;sendto error&quot;);        int n = recvfrom(sockfd, recv_line, MAXLINE, 0, NULL, NULL);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>这个程序和 UDP 网络编程的例子基本是一致的，我们可以把它当做是用本地文件替换了 IP 地址和端口的 UDP 程序，不过，这里还是有一个非常大的不同的。</p><p>这个不同点是本地套接字 bind 到本地一个路径上，然而 UDP 客户端程序是不需要这么做的。本地数据报套接字这么做的原因是，它需要指定一个本地路径，以便在服务器端回包时，可以正确地找到地址；而在 UDP 客户端程序里，数据是可以通过 UDP 包的本地地址和端口来匹配的。</p><p>下面这段代码就展示了服务器端和客户端通过数据报应答的场景：</p><pre><code>./unixdataserver /tmp/unixdata.sockReceive: g1now sending: Hi, g1Receive: g2now sending: Hi, g2Receive: g3now sending: Hi, g3</code></pre><p>我们可以看到，服务器端陆续收到客户端发送的数据报，同时，客户端也收到了服务器端的应答。</p><pre><code>$ ./unixdataclient /tmp/unixdata.sockg1now sending g1Hi, g1g2now sending g2Hi, g2g3now sending g3Hi, g3^C</code></pre><p>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议。<br>本地套接字的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报套接字实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地套接字&quot;&gt;&lt;a href=&quot;#本地套接字&quot; class=&quot;headerlink&quot; title=&quot;本地套接字&quot;&gt;&lt;/a&gt;本地套接字&lt;/h1&gt;&lt;p&gt;本地套接字是 IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>UDP</title>
    <link href="http://example.com/p/6a48eebc.html"/>
    <id>http://example.com/p/6a48eebc.html</id>
    <published>2023-07-19T14:43:53.003Z</published>
    <updated>2023-07-19T14:53:59.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>TCP 是一个面向连接的协议，TCP 在 IP 报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定的上下文中工作的。</p><p>而 UDP 则不同，UDP 没有这样一个确定的上下文，它是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。我们可以简单地理解为，在 IP 报文的基础上，UDP 增加的能力有限。<br>UDP 不保证报文的有效传递，不保证报文的有序，也就是说使用 UDP 的时候，我们需要做好丢包、重传、报文组装等工作。</p><p><img src="https://s1.ax1x.com/2023/07/19/pC7BS54.png" alt="pC7BS54.png"></p><p>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 recvfrom 函数等待客户端的报文发送；客户端创建套接字之后，调用 sendto 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程。<br>recvfrom 和 sendto 是 UDP 用来接收和发送报文的两个主要函数：</p><pre><code>#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,const struct sockaddr *to, socklen_t *addrlen); </code></pre><p>先来看一下 recvfrom 函数。</p><ul><li><p>sockfd、buff 和 nbytes 是前三个参数。sockfd 是本地创建的套接字描述符，buff 指向本地的缓存，nbytes 表示最大接收数据字节。第四个参数 flags 是和 I&#x2F;O 相关的参数，这里我们还用不到，设置为 0。</p></li><li><p>后面两个参数 from 和 addrlen，实际上是返回对端发送方的地址和端口等信息，这和 TCP 非常不一样，TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息。另外 UDP 报文每次接收都会获取对端的信息，也就是说报文和报文之间是没有上下文的。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>接下来看一下 sendto 函数。</p><ul><li><p>sendto 函数中的前三个参数为 sockfd、buff 和 nbytes。sockfd 是本地创建的套接字描述符，buff 指向发送的缓存，nbytes 表示发送字节数。第四个参数 flags 依旧设置为 0。</p></li><li><p>后面两个参数 to 和 addrlen，表示发送的对端地址和端口等信息。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>TCP 的发送和接收每次都是在一个上下文中，类似这样的过程：</p><p>A 连接上: 接收→发送→接收→发送→…<br>B 连接上: 接收→发送→接收→发送→ …</p><p>而 UDP 的每次接收和发送都是一个独立的上下文，类似这样：</p><p>接收 A→发送 A→接收 B→发送 B →接收 C→发送 C→ …</p><h2 id="UDP-服务端例子"><a href="#UDP-服务端例子" class="headerlink" title="UDP 服务端例子"></a>UDP 服务端例子</h2><p>先来看一个 UDP 服务器端的例子：</p><pre><code>#include &quot;lib/common.h&quot;static int count;static void recvfrom_int(int signo) &#123;    printf(&quot;\nreceived %d datagrams\n&quot;, count);    exit(0);&#125;int main(int argc, char **argv) &#123;    int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);    bind(socket_fd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));    socklen_t client_len;    char message[MAXLINE];    count = 0;    signal(SIGINT, recvfrom_int);//信号    struct sockaddr_in client_addr;    client_len = sizeof(client_addr);    for (;;) &#123;        int n = recvfrom(socket_fd, message, MAXLINE, 0, (struct sockaddr *) &amp;client_addr, &amp;client_len);        message[n] = 0;        printf(&quot;received %d bytes: %s\n&quot;, n, message);        char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, message);        sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;client_addr, client_len);        count++;    &#125;&#125;</code></pre><p>首先创建一个套接字，这里的套接字类型是“SOCK_DGRAM”，表示的是 UDP 数据报。<br>绑定数据报套接字到本地的一个端口上。<br>为该服务器创建了一个信号处理函数，以便在响应“Ctrl+C”退出时，打印出收到的报文总数。<br>通过调用 recvfrom 函数获取客户端发送的报文，之后我们对收到的报文进行重新改造，加上“Hi”的前缀，再通过 sendto 函数发送给客户端对端。</p><h2 id="UDP-客户端例子"><a href="#UDP-客户端例子" class="headerlink" title="UDP 客户端例子"></a>UDP 客户端例子</h2><p>接下来我们再来构建一个对应的 UDP 客户端。在这个例子中，从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上。</p><pre><code>#include &quot;lib/common.h&quot;# define    MAXLINE     4096int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: udpclient &lt;IPaddress&gt;&quot;);    &#125;        int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    struct sockaddr *reply_addr;    reply_addr = malloc(server_len);    char send_line[MAXLINE], recv_line[MAXLINE + 1];    socklen_t len;    int n;    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        printf(&quot;now sending %s\n&quot;, send_line);        size_t rt = sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;server_addr, server_len);        if (rt &lt; 0) &#123;            error(1, errno, &quot;send failed &quot;);        &#125;        printf(&quot;send bytes: %zu \n&quot;, rt);        len = 0;        n = recvfrom(socket_fd, recv_line, MAXLINE, 0, reply_addr, &amp;len);        if (n &lt; 0)            error(1, errno, &quot;recvfrom failed&quot;);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>创建一个类型为“SOCK_DGRAM”的套接字。<br>初始化目标服务器的地址和端口。<br>从标准输入中读取的字符进行处理后，调用 sendto 函数发送给目标服务器端，然后再次调用 recvfrom 函数接收目标服务器发送过来的新报文，并将其打印到标准输出上。</p><h2 id="UDP-的三种运行场景"><a href="#UDP-的三种运行场景" class="headerlink" title="UDP 的三种运行场景"></a>UDP 的三种运行场景</h2><h3 id="只运行客户端"><a href="#只运行客户端" class="headerlink" title="只运行客户端"></a>只运行客户端</h3><p>如果我们只运行客户端，程序会一直阻塞在 recvfrom 上。</p><pre><code>$ ./udpclient 127.0.0.11now sending g1send bytes: 2&lt; 阻塞在这里 &gt;</code></pre><p>如果不开启服务端，TCP 客户端的 connect 函数会直接返回“Connection refused”报错信息。而在 UDP 程序里，则会一直阻塞在这里。</p><h3 id="先开启服务端，再开启客户端"><a href="#先开启服务端，再开启客户端" class="headerlink" title="先开启服务端，再开启客户端"></a>先开启服务端，再开启客户端</h3><p>我们先开启服务端在端口侦听，然后再开启客户端</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2$./udpclient 127.0.0.1g1now sending g1send bytes: 2Hi, g1g2now sending g2send bytes: 2Hi, g2</code></pre><h3 id="开启服务端，再一次开启两个客户端"><a href="#开启服务端，再一次开启两个客户端" class="headerlink" title="开启服务端，再一次开启两个客户端"></a>开启服务端，再一次开启两个客户端</h3><p>这个实验中，在服务端开启之后，依次开启两个客户端，并发送报文。</p><p>服务端：</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4</code></pre><p>两个客户端发送的报文，依次都被服务端收到，并且客户端也可以收到服务端处理之后的报文。<br>如果我们此时把服务器端进程杀死，就可以看到信号函数在进程退出之前，打印出服务器端接收到的报文个数。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams</code></pre><p>我们再重启服务器端进程，并使用客户端 1 和客户端 2 继续发送新的报文，我们可以看到和 TCP 非常不同的结果。<br>TCP 断联之后必须重新连接才可以发送报文信息。但是 UDP 报文的”无连接“的特点，可以在 UDP 服务器重启之后，继续进行报文的发送，这就是 UDP 报文“无上下文”的最好说明。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams$ ./udpserverreceived 2 bytes: g5received 2 bytes: g6</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3g5now sending g5send bytes: 2Hi, g5</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4g6now sending g6send bytes: 2Hi, g6</code></pre><p>UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。<br>UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;p&gt;TCP 是一个面向连接的协议，TCP 在 IP 报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手</title>
    <link href="http://example.com/p/3d85440b.html"/>
    <id>http://example.com/p/3d85440b.html</id>
    <published>2023-07-19T13:36:07.963Z</published>
    <updated>2023-07-19T14:39:22.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>先从服务器端开始。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>创建一个可用的套接字要使用下面的函数：</p><pre><code>int socket(int domain, int type, int protocol)</code></pre><p>domain 就是指 PF_INET、PF_INET6 以及 PF_LOCAL 等，表示什么样的套接字。</p><p>type 可用的值是：</p><ul><li>SOCK_STREAM: 表示的是字节流，对应 TCP；</li><li>SOCK_DGRAM： 表示的是数据报，对应 UDP；</li><li>SOCK_RAW: 表示的是原始套接字。</li></ul><p>参数 protocol 原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。protocol 目前一般写成 0 即可。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>创建出来的套接字如果需要被别人使用，就需要调用 bind 函数把套接字和套接字地址绑定</p><pre><code>bind(int fd, sockaddr * addr, socklen_t len)</code></pre><p>bind 函数后面的第二个参数是通用地址格式sockaddr * addr。这里有一个地方值得注意，那就是虽然接收的是通用地址格式，实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式。bind 函数会根据 len 字段判断传入的参数 addr 该怎么解析，len 字段表示的就是传入的地址长度，它是一个可变值。<br>对于使用者来说，每次需要将 IPv4、IPv6 或者本地套接字格式转化为通用套接字格式，就像下面的 IPv4 套接字地址格式的例子一样：</p><pre><code>struct sockaddr_in name;bind (sock, (struct sockaddr *) &amp;name, sizeof (name)</code></pre><p>对于实现者来说，可根据该地址结构的前两个字节判断出是哪种地址。为了处理长度可变的结构，需要读取函数里的第三个参数，也就是 len 字段，这样就可以对地址进行解析和判断了。</p><p>设置 bind 的时候，对地址和端口可以有多种处理方式。我们可以把地址设置成本机的 IP 地址，这相当告诉操作系统内核，仅仅对目标 IP 是本机 IP 地址的 IP 包进行处理。但是这样写的程序在部署时有一个问题，我们编写应用程序时并不清楚自己的应用程序将会被部署到哪台机器上。这个时候，可以利用通配地址的能力帮助我们解决这个问题。比如一台机器有两块网卡，IP 地址分别是 202.61.22.55 和 192.168.1.11，那么向这两个 IP 请求的请求包都会被我们编写的应用程序处理。<br>对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置；对于 IPv6 的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置。</p><pre><code>struct sockaddr_in name;name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4 通配地址 */</code></pre><p>除了地址，还有端口。如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核来处理，操作系统内核会根据一定的算法选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用。<br>一般来说，服务器端的程序一定要绑定到一个众所周知的端口上。服务器端的 IP 地址和端口数据，相当于打电话拨号时需要知道的对方号码，如果没有电话号码，就没有办法和对方建立连接。</p><pre><code>include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int make_socket (uint16_t port)&#123;    int sock;    struct sockaddr_in name;        /* 创建字节流类型的 IPV4 socket. */    sock = socket (PF_INET, SOCK_STREAM, 0);    if (sock &lt; 0)    &#123;        perror (&quot;socket&quot;);        exit (EXIT_FAILURE);    &#125;        /* 绑定到 port 和 ip. */    name.sin_family = AF_INET; /* IPV4 */    name.sin_port = htons (port);  /* 指定端口 */    name.sin_addr.s_addr = htonl (INADDR_ANY); /* 通配地址 */    /* 把 IPV4 地址转换成通用地址格式，同时传递长度 */    if (bind (sock, (struct sockaddr *) &amp;name, sizeof (name)) &lt; 0)    &#123;        perror (&quot;bind&quot;);        exit (EXIT_FAILURE);    &#125;            return sock&#125;</code></pre><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 connect 函数，后面会讲到）。通过 listen 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：“我这个套接字是用来等待用户请求的。”当然，操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。<br>listen 函数的原型是这样的：</p><pre><code>int listen (int socketfd, int backlog)</code></pre><p>第一个参数 socketfd 为套接字描述符，第二个参数 backlog，官方的解释为未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目。这个参数越大，并发数目理论上也会越大。但是参数过大也会占用过多的系统资源，一些系统，比如 Linux 并不允许对这个参数进行改变。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这个时候操作系统内核需要把这个事件通知到应用程序，并让应用程序感知到这个连接。<br>accept 这个函数的作用就是连接建立之后，操作系统内核和应用程序之间的桥梁。它的原型是：</p><pre><code>int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)</code></pre><p>第一个参数 listensockfd 是套接字，可以叫它为 listen 套接字，因为这就是前面通过 bind，listen 一系列操作而得到的套接字。函数的返回值有两个部分，第一个部分 cliadd 是通过指针方式获取的客户端的地址，addrlen 告诉我们地址的大小；另一个部分是函数的返回值，这个返回值是一个全新的描述字，代表了与客户端的连接。<br>第一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><p>一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>第一步还是和服务端一样，要建立一个套接字，方法和前面是一样的。</p><p>不一样的是客户端需要调用 connect 向服务端发起请求。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>客户端和服务器端的连接建立，是通过 connect 函数完成的。这是 connect 的构建函数：</p><pre><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code></pre><p>函数的第一个参数 sockfd 是连接套接字，通过前面讲述的 socket 函数创建。第二个、第三个参数 servaddr 和 addrlen 分别代表指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的 IP 地址和端口号。</p><p>客户在调用函数 connect 前不必非得调用 bind 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口。</p><p>如果是 TCP 套接字，那么调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：</p><ul><li>三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。</li><li>客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。产生 RST 的三个条件是：目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；TCP 想取消一个已有连接；TCP 接收到一个根本不存在的连接上的分节。</li><li>客户发出的 SYN 包在网络上引起了”destination unreachable”，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。</li></ul><h2 id="TCP三次握手-1"><a href="#TCP三次握手-1" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们先看一下最初的过程，服务器端通过 socket，bind 和 listen 完成了被动套接字的准备工作，被动的意思就是等着别人来连接，然后调用 accept，就会阻塞在这里，等待客户端的连接来临；客户端通过调用 socket 和 connect 函数之后，也会阻塞。接下来的事情是由操作系统内核完成的，更具体一点的说，是操作系统内核网络协议栈在工作。<br>下面是具体的过程：</p><ul><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，客户端进入 SYNC_SENT 状态；</li><li>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 k，服务器端进入 SYNC_RCVD 状态；</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ul><p>这样就连接成功了</p><h2 id="发送和接受"><a href="#发送和接受" class="headerlink" title="发送和接受"></a>发送和接受</h2><p>连接建立的根本目的是为了数据的收发，首先我们先来看一下发送数据。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>发送数据时常用的有三个函数，分别是 write、send 和 sendmsg。</p><pre><code>size_t write (int socketfd, const void *buffer, size_t size)size_t send (int socketfd, const void *buffer, size_t size, int flags)size_t sendmsg(int sockfd, const struct msghdr *msg, int flags)</code></pre><p>第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。<br>如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。<br>如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。</p><p>既然套接字描述符是一种特殊的描述符，那么在套接字描述符上调用 write 函数，应该和在普通文件描述符上调用 write 函数的行为是一致的，都是通过描述符句柄写入指定的数据。</p><p>乍一看，两者的表现形式是一样，内在的区别还是很不一样的。</p><p>对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。<br>对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的。</p><h3 id="发送缓冲区"><a href="#发送缓冲区" class="headerlink" title="发送缓冲区"></a>发送缓冲区</h3><p>当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。</p><p>这里有几种情况：</p><ul><li><p>第一种情况很简单，操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，那么皆大欢喜，我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小。</p></li><li><p>第二种情况是，操作系统内核的发送缓冲区是够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，操作系统内核并不会返回，也不会报错，而是应用程序被阻塞，也就是说应用程序在 write 函数调用处停留，不直接返回。大部分 UNIX 系统的做法是一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回。</p></li></ul><p>发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据。至于什么时候发送到对端的接收缓冲区，或者更进一步说，什么时候被对方应用程序缓冲所接收，对我们而言完全都是透明的。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>套接字描述本身和本地文件描述符并无区别，在 UNIX 的世界里万物都是文件，这就意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。这些函数包括 read 和 write 交换数据的函数。</p><p>先从最简单的 read 函数开始看起，这个函数的原型如下：</p><pre><code>size_t read (int socketfd, void *buffer, size_t size)</code></pre><p>read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；</p><p>这里是最多读取 size 个字节。如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取。</p><pre><code>/* 从 socketfd 描述字中读取 &quot;size&quot; 个字节. */ssize_t readn(int fd, void *vptr, size_t size)&#123;    size_t  nleft;    ssize_t nread;    char    *ptr;    ptr = vptr;    nleft = size;        while (nleft &gt; 0) &#123;        if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;            if (errno == EINTR)                nread = 0;      /* 这里需要再次调用 read */            else                return(-1);        &#125; else if (nread == 0)            break;              /* EOF(End of File) 表示套接字关闭 */        nleft -= nread;        ptr   += nread;    &#125;    return(n - nleft);      /* 返回的是实际读取的字节数 */&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP三次握手&quot;&gt;&lt;a href=&quot;#TCP三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP三次握手&quot;&gt;&lt;/a&gt;TCP三次握手&lt;/h1&gt;&lt;p&gt;先从服务器端开始。&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;h</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-07-18T01:46:59.601Z</published>
    <updated>2023-07-18T01:47:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>在 MySQL 中，表的行格式是指表中存储的行数据在磁盘上的存储方式。MySQL 支持多种行格式，不同的行格式有不同的特点和适用场景。在函数中，我们使用 switch 语句根据传入的 enum 值来确定对应的行格式，并返回相应的字符串。</p><p>以下是对应关系的解释：</p><ul><li>ast.RowFormatDefault：表示默认行格式，没有显式指定行格式时使用的默认值。</li><li>ast.RowFormatFixed：表示固定行格式，适用于具有固定长度的行数据。</li><li>ast.RowFormatCompact：表示紧凑行格式，适用于大部分情况下的行数据。</li><li>ast.RowFormatCompressed：表示压缩行格式，适用于对数据进行压缩以减少存储空间的情况。</li><li>ast.RowFormatDynamic：表示动态行格式，适用于具有可变长度的行数据。</li><li>ast.RowFormatRedundant：表示冗余行格式，适用于具有较大数据行的情况。</li></ul><p>如果传入的 enum 值没有对应的行格式，函数将返回空字符串 “”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 MySQL 中，表的行格式是指表中存储的行数据在磁盘上的存储方式。MySQL 支持多种行格式，不同的行格式有不同的特点和适用场景。在函数中，我们使用 switch 语句根据传入的 enum 值来确定对应的行格式，并返回相应的字符串。&lt;/p&gt;
&lt;p&gt;以下是对应关系的解释：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字面量</title>
    <link href="http://example.com/p/ddc66992.html"/>
    <id>http://example.com/p/ddc66992.html</id>
    <published>2023-07-17T13:28:22.979Z</published>
    <updated>2023-07-17T13:38:29.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。</p><pre><code>#include &lt;chrono&gt;#include &lt;complex&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;i * i = &quot; &lt;&lt; 1i * 1i &lt;&lt; endl;    cout &lt;&lt; &quot;Waiting for 500ms&quot; &lt;&lt; endl;    this_thread::sleep_for(500ms);    cout &lt;&lt; &quot;Hello world&quot;s.substr(0, 5) &lt;&lt; endl;&#125;</code></pre><p>输出结果为：</p><pre><code>i * i = (-1,0)Waiting for 500msHello</code></pre><p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 basic_string 字面量的后缀。<br>上面使用了 using namespace std，这会同时引入std 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p><pre><code>std::literals::complex_literalsstd::literals::chrono_literalsstd::literals::string_literals</code></pre><p>在产品项目中，一般不会（也不应该）全局使用 using namespace std<br>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 _打头。比如，假如我们有下面的长度类：</p><pre><code>struct length &#123;    double value;    enum unit &#123;        metre,        kilometre,        millimetre,        centimetre,        inch,        foot,        yard,        mile,    &#125;;    static constexpr double factors[] =        &#123;1.0, 1000.0, 1e-3,        1e-2, 0.0254, 0.3048,        0.9144, 1609.344&#125;;    explicit length(double v, unit u = metre) &#123;        value = v * factors[u];    &#125;&#125;;length operator+(length lhs, length rhs) &#123;    return length(lhs.value + rhs.value);&#125;// 可能有其他运算符</code></pre><p>我们可以手写 length(1.0, length::metre) 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p><pre><code> 1.0_m + 10.0_cm</code></pre><p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p><pre><code>length operator&quot;&quot; _m(long double v)&#123;    return length(v, length::metre);&#125;length operator&quot;&quot; _cm(long double v)&#123;    return length(v, length::centimetre);&#125;</code></pre><h2 id="二进制字面量"><a href="#二进制字面量" class="headerlink" title="二进制字面量"></a>二进制字面量</h2><p>我们知道c++有16进制，8进制，10进制表示方法，但是没有二进制<br>从 C++14 开始，我们对于二进制也有了直接的字面量：</p><pre><code>unsigned mask = 0b111000000;</code></pre><p>这在需要比特级操作等场合还是非常有用的。<br>遗憾的是， I&#x2F;O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p><pre><code>#include &lt;bitset&gt;cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;</code></pre><p>输出结果是：</p><pre><code>111000000</code></pre><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。C++14 开始，允许在数字型字面量中任意添加 ‘ 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。比如说：</p><ul><li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li><li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li><li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li><li>二进制数字使用三位的分隔，对应文件系统的权限分组</li></ul><p>一些例子如下：</p><pre><code>unsigned mask = 0b111&#39;000&#39;000;long r_earth_equatorial = 6&#39;378&#39;137;double pi = 3.14159&#39;26535&#39;89793;const unsigned magic = 0x44&#39;42&#39;47&#39;4E;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字面量&quot;&gt;&lt;a href=&quot;#字面量&quot; class=&quot;headerlink&quot; title=&quot;字面量&quot;&gt;&lt;/a&gt;字面量&lt;/h1&gt;&lt;p&gt;C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>torm框架学习</title>
    <link href="http://example.com/p/14433829.html"/>
    <id>http://example.com/p/14433829.html</id>
    <published>2023-07-17T08:48:12.186Z</published>
    <updated>2023-07-17T08:52:51.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="torm"><a href="#torm" class="headerlink" title="torm"></a>torm</h1><p>TORM（Type-safe ORM）是一个强大的 Go 语言 ORM 库，具有以下特性</p><ul><li>精细化查询、插入、更新字段控制</li><li>类型安全</li><li><ul><li>软删除支持</li></ul></li><li>Id、创建、更新字段自动填充</li><li>分库分表支持</li><li>读写分离支持</li><li>使用 Hook 机制灵活拓展如 Prometheus 上报，自动加解密等</li><li>快，相比其他 ORM 框架性能损耗更少</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;torm&quot;&gt;&lt;a href=&quot;#torm&quot; class=&quot;headerlink&quot; title=&quot;torm&quot;&gt;&lt;/a&gt;torm&lt;/h1&gt;&lt;p&gt;TORM（Type-safe ORM）是一个强大的 Go 语言 ORM 库，具有以下特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精细化查</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/1f4ac2fb.html"/>
    <id>http://example.com/p/1f4ac2fb.html</id>
    <published>2023-07-16T09:10:58.637Z</published>
    <updated>2023-07-16T09:28:00.041Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-栈categories-算法与数据结构"><a href="#title-栈categories-算法与数据结构" class="headerlink" title="title: 栈categories: 算法与数据结构"></a>title: 栈<br>categories: 算法与数据结构</h2><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20,155,232,844,224,682,496.</p><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><pre><code>class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;stk;        map&lt;char,char&gt;table;        table.insert(&#123;&#39;(&#39;,&#39;)&#39;&#125;);        table.insert(&#123;&#39;[&#39;,&#39;]&#39;&#125;);        table.insert(&#123;&#39;&#123;&#39;,&#39;&#125;&#39;&#125;);        for(auto c:s)        &#123;            if(c==&#39;(&#39;||c==&#39;[&#39;||c==&#39;&#123;&#39;)            &#123;                stk.push(c);            &#125;            else            &#123;                if(stk.size()&amp;&amp;table[stk.top()]==c)                &#123;                    stk.pop();                &#125;                else&#123;                    return false;                &#125;            &#125;        &#125;        if(stk.size())return false;        return true;    &#125;&#125;;</code></pre><p>坑点有很多，比如每次pop需要注意栈非空，匹配结束如果栈有值则失败，思路想的时候很好代码实现总是遗漏要点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-栈categories-算法与数据结构&quot;&gt;&lt;a href=&quot;#title-栈categories-算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;title: 栈categories: 算法与数据结构&quot;&gt;&lt;/a&gt;titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/p/2362a8ea.html"/>
    <id>http://example.com/p/2362a8ea.html</id>
    <published>2023-07-16T07:09:58.247Z</published>
    <updated>2023-07-17T01:14:11.115Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr) &#123;            ListNode* next = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;;</code></pre><h2 id="判断环形链表"><a href="#判断环形链表" class="headerlink" title="判断环形链表"></a>判断环形链表</h2><pre><code>class Solution &#123;public:    bool hasCycle(ListNode* head) &#123;        ListNode* slow = head;        ListNode* fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if (fast == slow) &#123;    // 如果快慢指针相遇                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><pre><code>class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead = new ListNode(-1);        ListNode* prev = preHead;        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;            if (l1-&gt;val &lt; l2-&gt;val) &#123;                prev-&gt;next = l1;                l1 = l1-&gt;next;            &#125; else &#123;                prev-&gt;next = l2;                l2 = l2-&gt;next;            &#125;            prev = prev-&gt;next;        &#125;        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev-&gt;next = l1 == nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;</code></pre><h2 id="删除倒数节点"><a href="#删除倒数节点" class="headerlink" title="删除倒数节点"></a>删除倒数节点</h2><pre><code>class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        auto first=head;        auto second=first;        for(int i=0;i&lt;n;i++)&#123;            second=second-&gt;next;        &#125;        if(second==nullptr)return head-&gt;next;        second=second-&gt;next;        while(second!=nullptr)        &#123;            first=first-&gt;next;            second=second-&gt;next;        &#125;        auto temp=first-&gt;next;        first-&gt;next=temp-&gt;next;        delete temp;        return head;    &#125;&#125;;</code></pre><h2 id="返回中点"><a href="#返回中点" class="headerlink" title="返回中点"></a>返回中点</h2><pre><code>class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        auto slow=head;        auto fast=head;        while(fast&amp;&amp;fast-&gt;next)        &#123;            slow=slow-&gt;next;            fast=fast-&gt;next-&gt;next;        &#125;        return slow;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;单链表反转&lt;/li&gt;
&lt;li&gt;链表中环的检测&lt;/li&gt;
&lt;li&gt;两个有序的链表合并&lt;/li&gt;
&lt;li&gt;删除链表倒数第 </summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly与Rust实践</title>
    <link href="http://example.com/p/13592136.html"/>
    <id>http://example.com/p/13592136.html</id>
    <published>2023-07-13T13:57:09.666Z</published>
    <updated>2023-07-14T02:17:14.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly与Rust实践"><a href="#WebAssembly与Rust实践" class="headerlink" title="WebAssembly与Rust实践"></a>WebAssembly与Rust实践</h1><div class="row">    <embed src="../../../pdf/WebAssembly与Rust实践.pdf" width="100%" height="550" type="application/pdf"></div><p>注：pdf为本人编写，不需要用图床比较方便，用图太多实在不想整理到博客了，下面内容不全，真心求教大佬们有没有什么魔法可以markdown粘贴图片绑定图床自动生成链接。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Rust编程语言和WebAssembly（Wasm）都是由Mozilla推动的前沿技术，并且它们在许多方面相互补充。<strong>Rust正致力于成为WebAssembly的首选编程语言</strong>。<br>Rust语言的最大特色之一是在保证系统性能的同时提供内存安全性。通过其所有权系统、借用检查器和生命周期规则，Rust可以在编译时捕获内存安全错误，避免了许多常见的内存错误，如空指针引用、数据竞争等。这使得Rust成为开发高性能、安全和可靠系统级软件的理想选择。<br>WebAssembly是一种可移植的低级字节码格式，可以在Web环境中运行。它的目标是在不同平台和语言之间提供统一的执行环境，并以接近原生的性能运行代码。WebAssembly允许以高效且安全的方式在Web浏览器中执行性能敏感的任务，同时保持与底层平台的兼容性。<br>Rust语言在与WebAssembly的结合方面有很多优势。Rust从诞生之初就考虑到与C语言的兼容性，使得使用Rust编写的代码可以直接与C语言的二进制接口（ABI）进行交互。这使得Rust成为编写WebAssembly模块的理想语言之一。Rust的Cargo包管理工具也为构建、打包和发布WebAssembly模块提供了便利。通过使用Rust和WebAssembly，开发人员可以借助Rust语言的安全性和性能优势，同时利用WebAssembly的跨平台和高性能特性，构建出功能强大、高效且安全的Web应用程序、浏览器扩展、游戏和其他Web平台的应用。</p><h2 id="安装WebAssembly开发环境"><a href="#安装WebAssembly开发环境" class="headerlink" title="安装WebAssembly开发环境"></a>安装WebAssembly开发环境</h2><p>Rust是目前WebAssembly生态中支持力度最强的一种语言。开源社区中不仅有Rust语言开发的WebAssembly虚拟机，还有基于WebAssembly模块的管理工具。<br>Rust语言默认安装的是生成本地应用的开发环境，因此WebAssembly开发环境需要单独安装。<br>首先查看有哪些环境可以安装：</p><pre><code> rustup target list | grep wasm</code></pre><p>运行结果如下所示：<br>• rustup target add wasm32-wasi：<br>    ◦ 这个指令将把wasm32-wasi目标加入到Rust工具链中。wasm32-wasi是用于WebAssembly系统接口(WASI)的目标，WASI是一种与操作系统无关的WebAssembly运行环境，允许在不同平台上运行WebAssembly模块。<br>• rustup target add wasm32-unknown-emscripten：<br>    ◦ 为了将 wasm32-unknown-emscripten 目标添加到 Rust 工具链，需要运行以下命令。wasm32-unknown-emscripten 是 Emscripten 工具链提供的一个目标，它能够将 Rust 代码编译为适用于浏览器环境的 WebAssembly 模块。<br>• rustup target add wasm32-unknown-unknown：<br>    ◦ 此命令将在 Rust 工具链中添加 wasm32-unknown-unknown 目标。wasm32-unknown-unknown 目标是一个通用的 WebAssembly 目标，适用于在不特定于操作系统或运行时环境的情况下构建 WebAssembly 模块。</p><p>了解环境之后，我们可以通过以下命令安装：</p><pre><code>rustup target add wasm32-wasirustup target add wasm32-unknown-emscriptenrustup target add wasm32-unknown-unknown</code></pre><p>为了方便测试和运行WebAssembly模块，还需要安装wasmer虚拟机环境。使用Scoop：</p><pre><code>scoop install wasmer</code></pre><p>安装成功之后，输入以下命令查看wasmer版本信息：</p><pre><code>wasmer -h</code></pre><h2 id="将Rust编译为wasm"><a href="#将Rust编译为wasm" class="headerlink" title="将Rust编译为wasm"></a>将Rust编译为wasm</h2><p>我们仍然使用刚才的入门测试程序，打印你好，世界！<br>然后，在编译时指定目标为wasm32-wasi：</p><pre><code>cargo build --target=wasm32-wasi</code></pre><p>在src同级目录下面，target&#x2F;wasm32-wasi&#x2F;debug&#x2F;内已经生成了对应的hello.wasm文件。<br>最后，通过wasmer工具运行该程序文件</p><pre><code>wasmer run target/wasm32-wasi/debug/hello.wasm</code></pre><p>可以看到程序正常输出</p><h2 id="导入和导出函数"><a href="#导入和导出函数" class="headerlink" title="导入和导出函数"></a>导入和导出函数</h2><h3 id="导出main-函数"><a href="#导出main-函数" class="headerlink" title="导出main()函数"></a>导出main()函数</h3><p>当在 Rust 中构建 WebAssembly 模块时，导入和导出函数是实现与宿主环境进行交互的关键部分。通过导入函数，可以在 Rust 模块中调用宿主环境中提供的功能，而通过导出函数，可以将 Rust 函数暴露给宿主环境使用。<br>上面测试时编译目标为wasm32-wasi，因此程序只能在宿主支持的WASI虚拟机环境运行。现在，我们设置编译目标为wasm32-unknown-unknown（即纯WebAssembly环境），然后查看其导出的函数。<br>输入以下命令重新构建：</p><pre><code>cargo build --target wasm32-unknown-unknown</code></pre><p>默认生成.&#x2F;target&#x2F;wasm32-unknown-unknown&#x2F;debug&#x2F;hello.wasm</p><p>可以看到我们已经导出了main函数。</p><p>我们还可以在Node.js环境，通过console.dir()调试函数查看导出的内容，在wasm对应目录下创建hello.js文件：</p><pre><code>const fs = require(&#39;fs&#39;);//readFileSync文件读取会阻塞代码的执行，直到读取完成const buf = fs.readFileSync(&#39;./hello.wasm&#39;);WebAssembly.instantiate(new Uint8Array(buf)).then(function(result) &#123;    console.dir(result.instance.exports);&#125;);</code></pre><p>运行代码，得到以下输出:</p><p>这说明普通的应用程序默认导出了main()函数。</p><h3 id="导入宿主打印函数"><a href="#导入宿主打印函数" class="headerlink" title="导入宿主打印函数"></a>导入宿主打印函数</h3><p>WebAssembly是一个与宿主环境隔离的虚拟机，因此WebAssembly模块不能直接访问宿主环境的控制台或文件系统等资源。为了在WebAssembly模块中输出信息，需要通过与宿主环境的交互来完成输出操作。<br>我们假定Node.js宿主环境提供了一个console_log()函数，用于输出一个整数值：</p><pre><code>function console_log(x) &#123;    console.log(x);&#125;</code></pre><p>这样就可以通过console_log()函数输出信息了。src&#x2F;main.rs内容修改如下：</p><pre><code>extern &quot;C&quot; &#123;    fn console_log(a: i32);&#125;fn main() &#123;    unsafe &#123;        console_log(42);    &#125;&#125;</code></pre><p>其中，紧跟extern “C”后的大括弧内是宿主导入函数声明，它们都是以C语言ABI规范导入。由于外部函数的实现是由宿主环境提供的，而不是由Rust代码控制的，因此我们无法保证这些函数的安全性和正确性。为此，我们需要将调用外部函数的代码放在unsafe语句块中，这样编译器就会知道该代码可能存在不安全操作，并需要我们自行确保其正确性和安全性。<br>对应Node.js环境的启动代码如下</p><pre><code>const fs = require(&#39;fs&#39;);const buf = fs.readFileSync(&#39;./hello.wasm&#39;);function console_log(x) &#123; console.log(x); &#125;WebAssembly.instantiate(new Uint8Array(buf), &#123;    env: &#123; &quot;console_log&quot;: console_log &#125;&#125;).then(function(result) &#123;    result.instance.exports.main();&#125;);</code></pre><h1 id="TODO-更新"><a href="#TODO-更新" class="headerlink" title="TODO 更新"></a>TODO 更新</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly与Rust实践&quot;&gt;&lt;a href=&quot;#WebAssembly与Rust实践&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly与Rust实践&quot;&gt;&lt;/a&gt;WebAssembly与Rust实践&lt;/h1&gt;

	&lt;div c</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="实习" scheme="http://example.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="WebAssembly" scheme="http://example.com/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>Rust简单入门</title>
    <link href="http://example.com/p/3b2bd29.html"/>
    <id>http://example.com/p/3b2bd29.html</id>
    <published>2023-07-13T12:10:03.572Z</published>
    <updated>2023-07-17T03:51:09.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust简单入门"><a href="#Rust简单入门" class="headerlink" title="Rust简单入门"></a>Rust简单入门</h1><p>Rust的特点<br>• 零开销抽象<br>• 没有gc<br>• 内存模型没有高度封装<br>• 语法干净正交，没有C++那么繁琐。<br>• 安全性。Rust语法引入所有权和生命期概念，在编译期就能检查出一部分内存管理错误，这是rust的一个杀手锏的特性。<br>• 现代语言特性。语言特性吸收了现代语言的大量优秀特性，支持多范式。</p><h2 id="Rust环境安装"><a href="#Rust环境安装" class="headerlink" title="Rust环境安装"></a>Rust环境安装</h2><h3 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h3><p>访问Rust语言官方网站的安装地址<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br>先下载rustup安装程序再安装,安装的所有工具在~&#x2F;.cargo&#x2F;bin目录下，我们需要将该目录添加到PATH环境变量。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOJrF.png" alt="pChOJrF.png"></p><p>打开安装程序后，我们会发现需要依赖的windowsAPI库，我们采用下载vs installer的方式获取对应库。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOUa9.png" alt="pChOUa9.png"></p><p>安装vs install以后重新打开rustup安装程序，选择默认安装。<br>安装完成后，我们需要将~&#x2F;.cargo&#x2F;bin目录添加到PATH环境变量。<br>我们可以通过以下方式查看rustup、rustc和cargo工具的版本信息：</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOwP1.png" alt="pChOwP1.png"></p><p>其中，rustup是Rust工具的管理工具，rustc是Rust程序编译器，cargo是Rust工程的管理工具</p><h3 id="Rust程序测试"><a href="#Rust程序测试" class="headerlink" title="Rust程序测试"></a>Rust程序测试</h3><p>我们从“你好，世界”这个例子开始测试。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChO08x.md.png" alt="pChO08x.md.png"></p><p>其中，fn是关键字，表示定义一个函数，定义的函数的名字是main。main()函数的参数在小括弧中列出（这里的main()函数没有参数），函数体位于大括弧内。这里main()函数体中只有一个语句，就是用println!宏输出一个字符串并换行。</p><h3 id="Cargo管理工程"><a href="#Cargo管理工程" class="headerlink" title="Cargo管理工程"></a>Cargo管理工程</h3><p>Rust 编程语言引以为傲的一个重要特性是其工程管理工具 Cargo。Cargo 是 Rust 官方提供的构建系统和包管理器，被广泛认可为行业标杆。、<br>以下是 Cargo 的一些主要特性和优势：<br>• 依赖管理：Cargo 提供了强大的依赖管理功能。通过 Cargo.toml 文件，可以定义项目的依赖项和版本约束，能够轻松地引入、更新和管理外部库。<br>• 构建系统：Cargo 提供了一个集成的构建系统，使得构建、编译和测试 Rust 项目变得简单而高效。它自动处理依赖关系、编译顺序和编译标志等，开发者只需要专注于编写代码而不必手动管理构建过程。<br>• 项目管理：Cargo 提供了一组命令行工具，用于创建、初始化和管理 Rust 项目。通过简单的命令，您可以创建新项目、生成文档、运行测试、发布软件包等，提高开发者的效率和工作流程。<br>• 社区集成：Cargo 和 Rust 社区紧密结合，通过 Cargo 可以方便地共享、发布和发现 Rust 库和工具。Cargo 提供了 Cargo Crates 网站<a href="https://crates.io/">https://crates.io</a> Rust 生态系统中集中管理和发布库的中央仓库。<br>• 多工作区支持：Cargo 允许在单个项目中管理多个工作区，每个工作区可以拥有自己的依赖关系和构建配置。这对于大型项目或拥有多个模块的项目特别有用，可以更好地组织和管理代码。<br>工程一般以目录的方式组织，因此我们先创建一个空的目录（目录的名字自由选择），其中包含一个Cargo.toml文件。</p><pre><code>[package]name = &quot;hello&quot;version = &quot;0.1.0&quot;</code></pre><p>Cargo.toml是一种TOML格式的工程文件（TOML格式和ini格式类似，但是其功能更加强大）。其中，[package]部分包含工程的基本信息：name字段表示工程的名字，version字段表示工程的版本。<br>然后，创建一个src目录，在目录中创建一个main.rs文件：</p><pre><code>fn main() &#123;    println!(&quot;你好，世界&quot;);&#125;</code></pre><p>Cargo工具默认以src&#x2F;main.rs为程序的入口文件，因此只需要输入<br>cargo run就可以编译并运行程序了</p><p><img src="https://s1.ax1x.com/2023/07/13/pChXhTJ.png" alt="pChXhTJ.png"></p><p>Cargo底层依然是调用rustc编译器工具。但是，Cargo不仅可以管理可执行程序和库，还可以对其他第三方库的依赖进行管理，同时支持自定义的构建脚本。<br>cargo-generate是一个开发人员工具，通过利用预先存在的 git 存储库作为模板，帮助开发者快速启动和运行新的 Rust 项目。</p><pre><code>cargo install cargo-generate</code></pre><h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><p>Rust还提供了本地文档用于帮助学习和了解Rust。<br>我们可以在终端运行：</p><pre><code>rustup doc</code></pre><p>打开文档。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChj9pt.png" alt="pChj9pt.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust简单入门&quot;&gt;&lt;a href=&quot;#Rust简单入门&quot; class=&quot;headerlink&quot; title=&quot;Rust简单入门&quot;&gt;&lt;/a&gt;Rust简单入门&lt;/h1&gt;&lt;p&gt;Rust的特点&lt;br&gt;• 零开销抽象&lt;br&gt;• 没有gc&lt;br&gt;• 内存模型没有高度封装&lt;b</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly跨语言调用</title>
    <link href="http://example.com/p/bf55081a.html"/>
    <id>http://example.com/p/bf55081a.html</id>
    <published>2023-07-13T11:58:12.167Z</published>
    <updated>2023-07-14T01:13:51.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly跨语言调用"><a href="#WebAssembly跨语言调用" class="headerlink" title="WebAssembly跨语言调用"></a>WebAssembly跨语言调用</h1><p>WebAssembly (Wasm) 可以在多种编程语言之间进行跨语言调用。它提供了一种标准化的接口，使得不同语言的代码可以相互调用和交互。<br>选择一种编程语言（例如 Rust、C++、Go 等）编写Wasm 模块。使用相应的编译器或工具链将代码编译为 Wasm 模块文件。然后导入 Wasm 模块到目标语言：在目标语言的代码中，使用相应的 Wasm 运行时库或框架来导入和执行 Wasm 模块。不同的语言可能有不同的 Wasm 运行时库可用，例如wasmer、wasmtime 等。</p><h2 id="Go和Rust调用实例"><a href="#Go和Rust调用实例" class="headerlink" title="Go和Rust调用实例"></a>Go和Rust调用实例</h2><h3 id="被调用方Rust"><a href="#被调用方Rust" class="headerlink" title="被调用方Rust"></a>被调用方Rust</h3><p>首先我们需要将被编译的程序编译成wasm文件<br>这里我们用go程序调用rust程序<br>用cargo init  add创建一个rust文件，更改add.rs</p><pre><code>fn main()&#123;&#125;#[no_mangle]pub extern &quot;C&quot; fn sum(x: i32, y: i32) -&gt; i32 &#123;    x + y&#125;</code></pre><p>将该文件编译为wasm</p><pre><code>cargo build --target wasm32-unknown-unknown --release</code></pre><p>现在被调用者我们已经处理完了，下面我们编写调用方代码。</p><h3 id="调用方Go"><a href="#调用方Go" class="headerlink" title="调用方Go"></a>调用方Go</h3><p>这里我们参照<a href="https://github.com/wasmerio/wasmer-go%E9%87%87%E7%94%A8wasmer%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">https://github.com/wasmerio/wasmer-go采用wasmer库进行处理</a><br>需要注意的是目前该库并不支持windows，需要在linux环境下使用</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOkgf.png" alt="pChOkgf.png"></p><p>创建相应go文件调用生成的wasm文件</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;    wasmer &quot;github.com/wasmerio/wasmer-go/wasmer&quot;)func main() &#123;    // 换成生成add.wasm的路径    wasmBytes, _ := ioutil.ReadFile(&quot;add/target/wasm32-unknown-unknown/release/add.wasm&quot;)    // Create an Engine    engine := wasmer.NewEngine()    // Create a Store    store := wasmer.NewStore(engine)    // Let&#39;s compile the module.    module, err := wasmer.NewModule(store, wasmBytes)    if err != nil &#123;        fmt.Println(&quot;Failed to compile module:&quot;, err)    &#125;    // Create an empty import object.    importObject := wasmer.NewImportObject()    // Let&#39;s instantiate the WebAssembly module.    instance, err := wasmer.NewInstance(module, importObject)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to instantiate the module:&quot;, err))    &#125;    // Now let&#39;s execute the `sum` function.    sum, err := instance.Exports.GetFunction(&quot;sum&quot;)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to get the `add_one` function:&quot;, err))    &#125;    result, err := sum(1, 2)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to call the `add_one` function:&quot;, err))    &#125;    fmt.Println(&quot;Results of `sum`:&quot;, result)&#125;</code></pre><p>注意：<br>• 12行需要换成生成add.wasm的相对&#x2F;绝对路径<br>• 需要拉取对应仓库<br>• 更多具体api参照<a href="https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer">https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer</a></p><p>之后我们直接运行程序，可以看到跨语言调用成功</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOuUs.png" alt="pChOuUs.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly跨语言调用&quot;&gt;&lt;a href=&quot;#WebAssembly跨语言调用&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly跨语言调用&quot;&gt;&lt;/a&gt;WebAssembly跨语言调用&lt;/h1&gt;&lt;p&gt;WebAssembly (W</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>C++进程优雅退出</title>
    <link href="http://example.com/p/53dbe2a2.html"/>
    <id>http://example.com/p/53dbe2a2.html</id>
    <published>2023-07-13T10:05:38.797Z</published>
    <updated>2023-07-13T10:09:58.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-进程的优雅退出"><a href="#C-进程的优雅退出" class="headerlink" title="C++进程的优雅退出"></a>C++进程的优雅退出</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="通过原子变量"><a href="#通过原子变量" class="headerlink" title="通过原子变量"></a>通过原子变量</h3><p>原子变量是线程安全的，我们可以通过atomic变量控制线程开始结束</p><pre><code>#include &lt;csignal&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;// 用于确定关闭状态的全局布尔变量std::atomic&lt;bool&gt; shutdownFlag(false);// 信号处理函数void signalHandler(int signal) &#123;    // 也可以使用 switch/case 进行控制    if (signal == SIGINT) &#123;        std::cout &lt;&lt; &quot;收到 SIGINT 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125; else if (signal == SIGTERM) &#123;        std::cout &lt;&lt; &quot;收到 SIGTERM 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125;    shutdownFlag = true;&#125;int main() &#123;    // 设置 SIGINT 和 SIGTERM 的信号处理函数    std::signal(SIGINT, signalHandler);    std::signal(SIGTERM, signalHandler);    // 服务器的主循环    while (!shutdownFlag) &#123;        // 在此处处理连接        std::this_thread::sleep_for(std::chrono::seconds(1));        std::cout &lt;&lt; &quot;服务器正在运行...&quot; &lt;&lt; std::endl;    &#125;    // 启动优雅关闭过程    std::cout &lt;&lt; &quot;正在启动优雅关闭...&quot; &lt;&lt; std::endl;        // 在这里可以进行清理操作，例如：    // 逐个关闭仍在进行中的连接，    // 保存数据，    // 正确关闭套接字等        std::cout &lt;&lt; &quot;优雅关闭完成。程序正在退出。&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>在上述例子中，我们捕获了SIGINT和SIGTERM信号，并根据这些信号进行了相应的处理。<br>SIGINT信号通常由用户在终端中按下中断键（如CTRL+C）时发送。它是一种用户主动发出的中断信号，用于通知程序终止执行。通过捕获SIGINT信号并设置相应的处理逻辑，我们可以在收到该信号时执行特定的操作，例如优雅地关闭服务器或执行其他清理任务。<br>而SIGTERM信号通常由操作系统或其他程序发送，用于请求程序正常终止。这种信号可能是远程管理工具、容器编排系统或其他管理机制发送的。与SIGINT信号类似，通过捕获SIGTERM信号并设置相应的处理逻辑，我们可以实现平滑关闭的过程，让程序有机会完成一些清理操作，确保数据的完整性和一致性。<br>通过设置信号处理函数来捕获这两个信号，并在接收到信号时设置原子变量shutdownFlag为true，以触发服务器的优雅关闭过程。这样可以在接收到这些信号时执行一些特定的操作，例如向用户发送关闭通知、保存数据、关闭连接等。</p><h3 id="休眠线程以及条件变量"><a href="#休眠线程以及条件变量" class="headerlink" title="休眠线程以及条件变量"></a>休眠线程以及条件变量</h3><p>但是如果线程大部分时间都在休眠怎么办？ 比如某一个线程仅偶尔执行一些工作，其间有长时间的睡眠。 如果终止信号到达，睡眠必须立即中断。 此外，如果向应用程序发送SIGTERM，并且应用程序没有在超时时间内终止，那么应用程序将被强行kill。<br>对于这个问题解决方式就是使用条件变量condition_variable::wait()，让线程休眠，直到经过特定时间跨度或满足条件。常用的方式就是使用条件变量，使用std::condition_variable::notify_one和std::condition_variable::notify_all 可以将线程从睡眠中唤醒，std::condition_variable的成员函数notify_one()与notify_all()是用来唤醒阻塞在wait（）的线程。假如有多个线程调用condition_variable::wait()陷入休眠之后。condition_variable的实现中有一个等待队列来保存堵塞在它之上的线程。当其他线程调用notify_one()时，只唤醒等待队列中的第一个线程；其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()才会唤醒。如果是调用notify_all()：会唤醒所有等待队列中阻塞的线程，但是存在锁争用，只有一个线程能够获得锁。队列中的其他线程，会不断尝试获得锁，当第一个唤醒的线程释放锁之后，剩余的线程就能获得锁继续执行。<br>但是notify_{one,all} 不是信号安全的，因此不能在信号处理程序中使用。所以signal handlers are out</p><blockquote><p>信号就像硬件中断一样，会打断正在执行的指令序列。信号处理函数无法判断捕获到信号的时候，进程在何处运行。如果信号处理函数中的操作与打断的函数的操作相同，而且这个操作中有静态数据结构等，当信号处理函数返回的时候（当然这里讨论的是信号处理函数可以返回），恢复原先的执行序列，可能会导致信号处理函数中的操作覆盖了之前正常操作中的数据。</p></blockquote><h3 id="采用sigwait"><a href="#采用sigwait" class="headerlink" title="采用sigwait"></a>采用sigwait</h3><p>sigwait()函数是一个POSIX函数，它允许线程挂起其执行，直到在给定的信号集中指定的某个信号成为待处理信号。该函数接受信号（从待处理信号列表中删除它），并将信号编号存储在sig变量中。<br>通过使用sigwait或sigwaitinfo，多线程应用程序可以在启动时阻塞所有信号，并有一个专用线程等待信号。这样，我们可以利用所有可用的同步原语。</p><pre><code>#include &lt;signal.h&gt;int sigwait(const sigset_t *set, int *sig);</code></pre><p>• set参数是指向信号集的指针，信号集是表示一组信号的数据结构。<br>• sig参数是一个指向整数的指针，成功完成函数后，接收到的信号编号将存储在其中。<br>以下是sigwait()的示例用法：</p><pre><code>#include &lt;condition_variable&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;signal.h&gt;int main()&#123;    // 阻塞当前线程和后续生成的线程中的信号    sigset_t sigset;    sigemptyset(&amp;sigset);    sigaddset(&amp;sigset, SIGINT);    sigaddset(&amp;sigset, SIGTERM);    pthread_sigmask(SIG_BLOCK, &amp;sigset, nullptr);    std::atomic&lt;bool&gt; shutdown_requested(false);    std::mutex cv_mutex;    std::condition_variable cv;    // 信号处理函数，在收到信号时设置shutdown_requested为true，    // 并通过条件变量cv通知其他等待的线程。    auto signal_handler = [&amp;shutdown_requested, &amp;cv, &amp;sigset]() &#123;        int signum = 0;        // 等待信号的到达：        sigwait(&amp;sigset, &amp;signum);        shutdown_requested.store(true);        // 通知所有等待的工作线程检查其断言：        cv.notify_all();        return signum;    &#125;;    // 将信号处理函数放在一个独立的线程中运行。    auto ft_signal_handler = std::async(std::launch::async, signal_handler);    auto worker = [&amp;shutdown_requested, &amp;cv_mutex, &amp;cv]() &#123;        while( shutdown_requested.load() == false )        &#123;        std::unique_lock lock(cv_mutex);        cv.wait_for(            lock,            // 最多等待一小时            std::chrono::hours(1),            // 当条件变量被唤醒并且断言为true时，停止等待：            [&amp;shutdown_requested]() &#123; return shutdown_requested.load(); &#125;);        &#125;        return shutdown_requested.load();    &#125;;    // 生成一组工作线程    std::vector&lt;std::future&lt;bool&gt;&gt; workers;    for( int i = 0; i &lt; 10; ++i )        workers.push_back(std::async(std::launch::async, worker));    std::cout &lt;&lt; &quot;等待SIGTERM或SIGINT信号（按下[CTRL]+[c]）...\n&quot;;    // 等待信号处理函数完成    int signal = ft_signal_handler.get();    std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signal &lt;&lt; &quot;\n&quot;;    // 等待工作线程    for( auto&amp; future : workers )        std::cout &lt;&lt; &quot;工作线程观察到关机请求: &quot;                &lt;&lt; std::boolalpha                &lt;&lt; future.get()                &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;正常关机\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2><p>Signal Wrangler  是一个小型的仅需要包含标头的库，更加方便管理信号。<br>Dependencies<br>• C++17<br>• Clang or GCC<br>• linux<br>• pthread<br>• cmake (recommended, but optional)<br>• Catch2 for testing</p><pre><code>#include &lt;sgnl/AtomicCondition.h&gt;#include &lt;sgnl/SignalHandler.h&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;thread&gt;void Worker(const sgnl::AtomicCondition&lt;bool&gt;&amp; exit_condition)&#123;    auto predicate = [&amp;exit_condition]() &#123;        return exit_condition.get();    &#125;;    while (true)    &#123;        exit_condition.wait_for(std::chrono::minutes(1), predicate);        if (exit_condition.get())        return;        /* ... 执行工作 ... */    &#125;&#125;int main()&#123;    sgnl::AtomicCondition&lt;bool&gt; exit_condition(false);    auto handler = [&amp;exit_condition](int signum) &#123;        std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signum &lt;&lt; &quot;\n&quot;;        if (signum == SIGTERM || signum == SIGINT)        &#123;        exit_condition.set(true);        // 唤醒所有等待的线程        exit_condition.notify_all();        // 停止等待信号        return true;        &#125;        // 继续等待信号        return false;    &#125;;    // 阻塞当前线程中的信号。    // 后续生成的线程将继承信号屏蔽。    sgnl::SignalHandler signal_handler(&#123;SIGINT, SIGTERM, SIGUSR1&#125;);    std::future&lt;int&gt; ft_sig_handler =        std::async(            std::launch::async,            &amp;sgnl::SignalHandler::sigwait_handler,            &amp;signal_handler,            std::ref(handler));    std::vector&lt;std::future&lt;void&gt;&gt; futures;    for (int i = 0; i &lt; 10; ++i)        futures.push_back(            std::async(                std::launch::async,                Worker,                std::ref(exit_condition)));    // 发送 SIGUSR1 信号    std::this_thread::sleep_for(std::chrono::milliseconds(100));    kill(0, SIGUSR1);    // 发送 SIGTERM 信号    kill(0, SIGTERM);    std::this_thread::sleep_for(std::chrono::milliseconds(100));    for (auto&amp; future : futures)        future.wait();    int last_signal = ft_sig_handler.get();    std::cout &lt;&lt; &quot;退出（收到信号 &quot; &lt;&lt; last_signal &lt;&lt; &quot;）\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h2><p>C++20实现优雅退出的一个方式是通过<a href="https://whl963854.github.io/p/324821f5.html">jthread</a>来进行实现C++20 jthread通过这种方式我们不用像传统做法定义一个变量进行控制，线程本身就可以控制子线程的运行以及停止。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void task()&#123;    while (true)    &#123;        // 执行任务        std::cout &lt;&lt; &quot;Performing task...\n&quot;;        std::this_thread::sleep_for(std::chrono::seconds(1));        // 检查是否收到停止请求        if (std::jthread::stop_requested())        &#123;            std::cout &lt;&lt; &quot;Stop requested. Exiting...\n&quot;;            break;        &#125;    &#125;&#125;int main()&#123;    std::jthread thread(task);    // 等待一段时间或等待某个条件满足    std::this_thread::sleep_for(std::chrono::seconds(5));    // 请求停止子线程    thread.request_stop();    // 继续等待一段时间，确保子线程完成当前任务    std::this_thread::sleep_for(std::chrono::seconds(2));    // std::jthread的析构函数会自动调用join()，等待子线程执行完毕    // 主线程退出，整个进程结束    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-进程的优雅退出&quot;&gt;&lt;a href=&quot;#C-进程的优雅退出&quot; class=&quot;headerlink&quot; title=&quot;C++进程的优雅退出&quot;&gt;&lt;/a&gt;C++进程的优雅退出&lt;/h1&gt;&lt;h2 id=&quot;C-11&quot;&gt;&lt;a href=&quot;#C-11&quot; class=&quot;header</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Go进程的优雅退出</title>
    <link href="http://example.com/p/d080713b.html"/>
    <id>http://example.com/p/d080713b.html</id>
    <published>2023-07-13T09:47:07.554Z</published>
    <updated>2023-07-13T10:04:57.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go进程的优雅退出"><a href="#Go进程的优雅退出" class="headerlink" title="Go进程的优雅退出"></a>Go进程的优雅退出</h1><h2 id="退出的反面模式"><a href="#退出的反面模式" class="headerlink" title="退出的反面模式"></a>退出的反面模式</h2><p>反面模式（anti-pattern）是指在实践中明显出现但又低效或是有待优化的设计模式。在进程退出过程中如果直接退出会导致资源无法及时释放，关闭打开的连接以及完成正在进行的请求和处理等方面问题。如果是无GC的语言可能还会出现内存泄漏等问题。</p><h3 id="Block-artificially"><a href="#Block-artificially" class="headerlink" title="Block artificially"></a>Block artificially</h3><p>第一个反面模式是在主 goroutine中使用无限循环来阻塞程序的执行，但是退出的时候并不等待任何东西。收到信号就退出，以下是一个这种反模式的简单实现示例：</p><pre><code>package mainfunc KeepProcessAlive() &#123;    var ch chan int    &lt;-ch&#125;func main() &#123;    ...    KeepProcessAlive()&#125;</code></pre><p>当ch收到数据解除阻塞，主进程也随之运行结束，没有对资源进行释放。</p><h3 id="os-Exit"><a href="#os-Exit" class="headerlink" title="os.Exit()"></a>os.Exit()</h3><p>第二种反面模式就是在其他 go 协程仍在运行的时候就调用os.Exit(1)，这本质上等于 SIGKILL，没有机会关闭打开的连接以及完成正在进行的请求和处理。</p><pre><code>go func() &#123;        &lt;-ch                os.Exit(1)&#125;()go func () &#123;    for ... &#123;    &#125;&#125;()</code></pre><p>当func收到数据之后立刻调用os.Exit()终止进程，也没有任何关闭打开的连接以及完成正在进行的请求和处理的行为。<br>以上两种行为都是十分不可取的，也可以说他们的退出不是“优雅”的。</p><h2 id="在Go中优雅退出"><a href="#在Go中优雅退出" class="headerlink" title="在Go中优雅退出"></a>在Go中优雅退出</h2><p>为了正常关闭服务，需要了解两件事：</p><ul><li>如何等待所有正在运行的go例程退出</li><li>如何将终止信号传播到多个 goroutine<br>Go 提供了实现上面两点要求所需的所有工具，可以很方便的让我们优雅退出进程。</li></ul><h3 id="等待-go-routine-完成"><a href="#等待-go-routine-完成" class="headerlink" title="等待 go-routine 完成"></a>等待 go-routine 完成</h3><p>Go 提供了足够的方法来控制并发。让我们看看等待go-routine有哪些方法。</p><h4 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h4><p>最简单的解决方案，使用通道原语。</p><ol><li>我们创建一个空的结构通道make(chan struct{}, 1)（空结构不需要内存）。</li><li>每个子 goroutine完成后都应该发布到通道（defer在这里很有用）。</li><li>父 goroutine应该从通道消耗与预期 goroutine 一样多的次数。</li></ol><p>下面来看一个例子：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    wait := make(chan struct&#123;&#125;, 2)    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第一个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第二个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    // 等待两个 goroutine 完成    &lt;-wait    &lt;-wait&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    // 捕捉操作系统中断信号（如 Ctrl+C）    signals := make(chan os.Signal, 1)    signal.Notify(signals, os.Interrupt, syscall.SIGTERM)    go func() &#123;        &lt;-signals        fmt.Println(&quot;接收到中断信号&quot;)        cancel() // 取消上下文    &#125;()    run(ctx)    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.goCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loop接收到中断信号第一个 goroutine 停止循环第二个 goroutine 停止循环Main done</code></pre><p><strong>注：这在等待单个 go  routine 时非常有用。</strong></p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>通道在有多个 goroutine的情况下解决方案可能不太优雅。sync.WaitGroup是一个标准库包，这是更惯用的实现上述目标的方式。WaitGroup 是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题。</p><p>Go 标准库中的 WaitGroup 提供了三个方法</p><ul><li>func (wg *WaitGroup) Add(delta int)用来设置 WaitGroup 的计数值；</li><li>func (wg *WaitGroup) Done()用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li><li>func (wg *WaitGroup) Wait()调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><p>使用 WaitGroup 的时候，一定要等所有的 Add 方法调用之后再调用 Wait，否则就可能导致 panic 或者不期望的结果。</p><p>下面是一个示例。</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h4 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h4><p>sync&#x2F;errgroup包有一种更好的方法实现上面的功能。</p><ul><li>两个errgroup的方法.Wait和.Go相对于WaitGroup更具可读性并且更易于维护。</li><li>此外，errgroup会进行错误传播并取消上下文，以便在发生错误时终止其他 goroutine</li></ul><p>下面来看示例：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;golang.org/x/sync/errgroup&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    g, gCtx := errgroup.WithContext(ctx)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;)    err := g.Wait()    if err != nil &#123;        fmt.Println(&quot;Error group:&quot;, err)    &#125;    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h3 id="控制进程终止"><a href="#控制进程终止" class="headerlink" title="控制进程终止"></a>控制进程终止</h3><p>上面我们已经弄清楚如何正确地传达进程的状态并等待它们，但是我们很多时候并不能一直等待进程运行结束，还需要实现对程序的终止的控制,将终止信号传播到多个 goroutine。<br>我们从一个非常简单的“Hello in a loop”示例开始：</p><pre><code>func main() &#123;    for &#123;        time.Sleep(1 * time.Second)        fmt.Println(&quot;Hello in a loop&quot;)    &#125;&#125;</code></pre><h4 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h4><p>通过信号量可以监听到系统发出的关停，程序意外关闭、退出、重启等，可以记录相关信息和退出前的操作。所以我们需要监听操作系统信号自主控制信号对应的事件：</p><pre><code>exit := make(chan os.Signal, 1) signal.Notify(exit, os.Interrupt, syscall.SIGTERM)</code></pre><p>• 我们需要使用 os.Interrupt 通过 Ctrl+C（即 SIGINT）正常关闭<br>• syscall.SIGTERM是常用的终止信号，也是docker容器的默认信号（可以修改） ， kubernetes也使用该信号。</p><p>注：信号具体功能如下所示：</p><table><thead><tr><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>SIGHUP</td><td>当终端断开时，将发送该信号给终端控制进程。SIGHUP 信号还可用于守护进程。</td></tr><tr><td>SIGINT</td><td>当用户键入终端中断字符（如：Ctrl + C），终端驱动程序将发送该信号给前台进程组。默认行为是终止进程。</td></tr><tr><td>SIGQUIT</td><td>当用户键入终端退出字符（如：Ctrl + \），该信号将发送给前台进程组。默认情况下，该信号终止进程，并生成可用于调试的核心转储文件。</td></tr><tr><td>SIGILL</td><td>进程试图非法执行机器语言指令，系统将向该进程发送该信号。</td></tr><tr><td>SIGTRAP</td><td>用于实现断点调试功能以及 strace 命令所执行的系统调用跟踪功能。</td></tr><tr><td>SIGABRT</td><td>当进程调用 abort 函数时，系统向该进程发送该信号。默认情况下，该信号会终止进程，并生成核心转储文件。</td></tr><tr><td>SIGBUS</td><td>总线错误，表示发生了某种内存访问错误。当使用 mmap() 创建的内存映射时，如果试图访问的地址超出了底层内存映射文件的结尾，会产生该错误。</td></tr><tr><td>SIGFPE</td><td>在发生致命的算术运算错误时发出。包括浮点运算错误、溢出以及除数为0等其他算术错误。</td></tr><tr><td>SIGKILL</td><td>必杀信号，处理器程序无法阻塞、忽略或捕获，总能杀死进程（僵尸进程除外）。</td></tr><tr><td>SIGUSR1</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGSEGV</td><td>试图访问未分配给自己的内存，或试图往没有写权限的内存地址写入数据。</td></tr><tr><td>SIGUSR2</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGPIPE</td><td>当进程向管道、FIFO 或套接字写入信息时，如果没有相应的读进程，系统将产生该信号（管道破裂）。</td></tr><tr><td>SIGALRM</td><td>经调用 alarm() 或 setitimer() 设置的实时定时器一旦到期，内核将产生该信号。</td></tr><tr><td>SIGTERM</td><td>用来终止进程的标准信号，也是 kill 和 killall 命令所发送的默认信号。建议首先尝试使用该信号来终止进程，而将 SIGKILL 作为最后手段。</td></tr><tr><td>SIGCHLD</td><td>当父进程的某个子进程退出时，内核将向父进程发送该信号。</td></tr><tr><td>SIGCONT</td><td>该信号发送给已停止的进程，使其恢复运行。</td></tr><tr><td>SIGSTOP</td><td>进程收到该信号将停止运行，处理器程序无法将其阻塞、忽略或捕获，总能停止进程。</td></tr><tr><td>SIGTSTP</td><td>作业控制的停止信号，当用户在键盘输入挂起字符（如：Ctrl + Z）时，将发送该信号给前台进程组，使其停止运行。</td></tr><tr><td>SIGTTIN</td><td>在作业控制 shell 下运行时，若后台进程组试图对终端进行 read() 操作，终端驱动程序则将发送该信号。该信号默认将停止进程。</td></tr><tr><td>SIGTTOU</td><td>类似于 SIGTTIN，但在写终端（或修改终端模式）时收到。</td></tr><tr><td>SIGURG</td><td>系统发送该信号给一个进程，表示套接字上存在带外（紧急）数据。</td></tr><tr><td>SIGXCPU</td><td>当进程的 CPU 时间超出对应的资源限制时，将发送此信号给进程。</td></tr><tr><td>SIGXFSZ</td><td>如果进程试图增大文件而突破对进程文件大小的资源限制时，将发送该信号给进程。</td></tr><tr><td>SIGVTALRM</td><td>虚拟时钟信号，类似于 SIGALRM，但计算的是该进程占用的 CPU 时间。</td></tr><tr><td>SIGPROF</td><td>类似于 SIGALRM 和 SIGVTALRM，但包括该进程用的 CPU 时间以及系统调用的时间。</td></tr><tr><td>SIGWINCH</td><td>窗口大小改变时发出该信号。</td></tr><tr><td>SIGIO</td><td>文件描述符准备就绪，可以开始进行输入&#x2F;输出操作。</td></tr><tr><td>SIGPWR</td><td>电源故障信号。</td></tr><tr><td>SIGSYS</td><td>如果进程发起的系统调用有误，将产生该信号。</td></tr></tbody></table><p>监听 SIGINT 和 SIGKILL 信号</p><blockquote><p>ctrl+c 产生了一个 SIGINT（中断信号）。<br>kill 9 发送一个 SIGKILL 信号 终止进程的信号来结束进程。</p></blockquote><h4 id="中断循环"><a href="#中断循环" class="headerlink" title="中断循环"></a>中断循环</h4><p>现在我们有了捕获信号的方法，现在我们需要找到一种中断循环的方法。</p><h5 id="非阻塞通道选择"><a href="#非阻塞通道选择" class="headerlink" title="非阻塞通道选择"></a>非阻塞通道选择</h5><p>select 语句允许在多个通道操作中选择可用的操作进行处理。当 select 语句执行时，它会等待其中一个 case 条件满足，并执行相应的操作。<br>下面是一个简单的 hello for 循环：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    c := make(chan os.Signal, 1) // 我们需要保留缓冲区大小为1，以确保通道不会被阻塞    signal.Notify(c, os.Interrupt, syscall.SIGTERM)    for &#123;        select &#123;        case &lt;-c:            fmt.Println(&quot;打破循环&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;循环中的Hello&quot;)        &#125;    &#125;&#125;</code></pre><p>通过这种方式，程序可以同时监听操作系统信号和定时器事件，根据不同的事件类型执行相应的操作。</p><pre><code>$ go run main.go循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello打破循环</code></pre><p>当接收到信号时，程序会退出循环并终止运行；而在每次定时器超时后，程序会打印出 “循环中的Hello”。这样，程序可以在接收到信号或每秒定时打印信息的情况下进行灵活的处理。</p><h5 id="使用Context来实现"><a href="#使用Context来实现" class="headerlink" title="使用Context来实现"></a>使用Context来实现</h5><p>Context（上下文）是Go语言中一个非常有用的接口，应该在所有阻塞函数中使用和传播。它可以实现取消操作在整个程序中的传播。<br>在直接或间接用于外部依赖项的每个方法或函数中，context.Context作为第一个参数是一个良好的做法。https :&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;context</p><h6 id="Channel共享问题"><a href="#Channel共享问题" class="headerlink" title="Channel共享问题"></a>Channel共享问题</h6><p>让我们看看上下文属性如何在更复杂的情况下提供帮助。<br>使用通道并行运行多个循环（反例）：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    exit := make(chan os.Signal, 1)    signal.Notify(exit, os.Interrupt, syscall.SIGTERM)    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: hello&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: ciao&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>该代码中使用了两个 goroutine，每个 goroutine 都使用 select 语句监听操作系统信号和定时器事件。exit 通道被多个 goroutine 共享，并且每个 goroutine 都在监听 exit 通道。当其中一个 goroutine 接收到终止信号时，其他 goroutine 也会接收到信号，但只有一个 goroutine 会打印相应的消息并退出。其他 goroutine 则会继续运行并打印定时器事件的消息。<br>这会导致一个问题：wg.Wait() 语句将一直等待直到所有 goroutine 完成，但只有一个 goroutine 会接收到终止信号并退出，而另一个 goroutine 则会一直运行下去。<br>对于广播通知的需求，可以使用context包来完成。context包提供了一种在多个goroutine之间传递取消信号的机制。</p><h6 id="使用-Context-终止"><a href="#使用-Context-终止" class="headerlink" title="使用 Context 终止"></a>使用 Context 终止</h6><p>让我们尝试通过引入context.WithCancel来解决这个问题</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        exit := make(chan os.Signal, 1)        signal.Notify(exit, os.Interrupt, syscall.SIGTERM)        cancel()    &#125;()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>当调用返回的取消函数或关闭父上下文的 Done 通道时，返回的上下文的 Done 通道将关闭。所有通过该上下文创建的 goroutine 中的 select 语句中的 &lt;-ctx.Done() 分支会被触发，也就是收到一个已关闭的通道。</p><pre><code>PS D:\workplace\gopath\src\wps\context_stop&gt;  go run .\main.goBreak the loopBreak the loopMain done</code></pre><p>这种行为实现了上下文的广播特性，在所有使用相同上下文的 goroutine 中，无论是直接调用取消函数还是关闭 Done 通道，都会导致所有的 &lt;-ctx.Done() 分支被执行。<br>这种广播机制使得可以在多个 goroutine 之间同时传递取消信号，而不仅仅限于单个 goroutine。通过这种方式，可以实现一次性取消多个相关 goroutine 的执行。</p><h6 id="NotifyContext"><a href="#NotifyContext" class="headerlink" title="NotifyContext"></a>NotifyContext</h6><p>在 go 1.16 中，信号包中引入了一个新的有用方法，singal.NotifyContext：</p><pre><code>func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)</code></pre><p>创建一个新的上下文并监听指定的操作系统信号。当收到这些信号之一时，上下文将被取消，触发相关的操作。<br>使用 NotifyContext 可以将上面的示例简化为：</p><pre><code>func main() &#123;    ctx, stop := context.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)    defer stop()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>将信号通过ctx进行监听，利用ctx就可以控制协程结束。</p><pre><code>PS D:\workplace\gopath\src\wps\notify_context&gt; go run .\main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h2 id="优雅的方法"><a href="#优雅的方法" class="headerlink" title="优雅的方法"></a>优雅的方法</h2><p>到目前为止，我们已经看到了几种优雅地终止一段长时间运行的代码的技术。</p><h3 id="使用-ctx-进行阻止"><a href="#使用-ctx-进行阻止" class="headerlink" title="使用 ctx 进行阻止"></a>使用 ctx 进行阻止</h3><p>这是最常见的方法，也更容易理解和实施。<br>• 调用一个方法<br>• 传递一个上下文<br>• 如果发生错误或上下文被取消&#x2F;超时，它将返回。</p><pre><code>// 调用:err := srv.Run(ctx, ...)// 实现func (srv *Service) Run(ctx context.Context, ...) error &#123;    // ...    // ...    for &#123;        // ...        select &#123;        case &lt;-ctx.Done():            // 根据业务逻辑需求，决定是否返回上下文错误            return ctx.Err()        &#125;    &#125;    // 如果不需要返回其他错误，可以直接返回 nil    return nil&#125;</code></pre><h3 id="Setup-x2F-Shutdown"><a href="#Setup-x2F-Shutdown" class="headerlink" title="Setup&#x2F;Shutdown"></a>Setup&#x2F;Shutdown</h3><p>在某些情况下，使用阻塞方式的ctx代码不是最合适的方法，特别是希望控制何时执行.Shutdown()方法时。不过，需要注意确保调用.Shutdown()以优雅地关闭服务器，避免资源泄漏的情况发生。</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>服务依赖数据库才能正常工作，我们需要确保服务不再运行后才执行db的关闭操作。通过在defer中调用db.Shutdown()，我们确保它在g.Wait返回后运行。</p><pre><code>// calling:func () &#123;    err := db.Setup() // will not block    defer db.Shutdown()    svc := Service&#123;        DB: db    &#125;    g.Run(...        svc.Run(ctx, ...)    )    g.Wait()&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优雅退出是指在进程终止前给予进程清理剩余请求的时间，等待子协程&#x2F;线程完成当前任务后再发起进程退出，以确保不会丢失任何数据。相比于暴力退出，优雅退出可以对未完成的任务和数据进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go进程的优雅退出&quot;&gt;&lt;a href=&quot;#Go进程的优雅退出&quot; class=&quot;headerlink&quot; title=&quot;Go进程的优雅退出&quot;&gt;&lt;/a&gt;Go进程的优雅退出&lt;/h1&gt;&lt;h2 id=&quot;退出的反面模式&quot;&gt;&lt;a href=&quot;#退出的反面模式&quot; class=&quot;he</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>进程通信</title>
    <link href="http://example.com/p/53ad465c.html"/>
    <id>http://example.com/p/53ad465c.html</id>
    <published>2023-07-13T09:47:07.553Z</published>
    <updated>2023-07-13T10:09:58.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>如果我们希望在本进程fork出一个子进程，可以使用os.StartProcess方法，它会fork出一个子进程后返回这个子进程的pid。</p><pre><code>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) &#123;    testlog.Open(name)    return startProcess(name, argv, attr)&#125;</code></pre><p>但是我们一般不这么做，因为 os.StartProcess 是一个比较底层的接口，一般是提供给go内部其他的方法去使用的。我们可以使用os.Command方法创建一个命令，并调用cmd.Start()方法运行命令，Start()方法内部其实就是调用的os.StartProcess()方法去fork一个子进程。</p><p>我们先来看Command方法，该方法返回一个*Cmd类型</p><pre><code>func Command(name string, arg ...string) *Cmd</code></pre><p>Cmd定义如下</p><pre><code>type Cmd struct &#123;        // Path is the path of the command to run.        //        // This is the only field that must be set to a non-zero        // value. If Path is relative, it is evaluated relative        // to Dir.        Path string        // Args holds command line arguments, including the command as Args[0].        // If the Args field is empty or nil, Run uses &#123;Path&#125;.        //        // In typical use, both Path and Args are set by calling Command.        Args []string        // Env specifies the environment of the process.        // Each entry is of the form &quot;key=value&quot;.        // If Env is nil, the new process uses the current process&#39;s        // environment.        // If Env contains duplicate environment keys, only the last        // value in the slice for each duplicate key is used.        Env []string        // Dir specifies the working directory of the command.        // If Dir is the empty string, Run runs the command in the        // calling process&#39;s current directory.        Dir string        // Stdin specifies the process&#39;s standard input.        // If Stdin is nil, the process reads from the null device (os.DevNull).        // If Stdin is an *os.File, the process&#39;s standard input is connected        // directly to that file.        // Otherwise, during the execution of the command a separate        // goroutine reads from Stdin and delivers that data to the command        // over a pipe. In this case, Wait does not complete until the goroutine        // stops copying, either because it has reached the end of Stdin        // (EOF or a read error) or because writing to the pipe returned an error.        Stdin io.Reader        // Stdout and Stderr specify the process&#39;s standard output and error.        //        // If either is nil, Run connects the corresponding file descriptor        // to the null device (os.DevNull).        //        // If Stdout and Stderr are the same writer, and have a type that can be compared with ==,        // at most one goroutine at a time will call Write.        Stdout io.Writer        Stderr io.Writer        // ExtraFiles specifies additional open files to be inherited by the        // new process. It does not include standard input, standard output, or        // standard error. If non-nil, entry i becomes file descriptor 3+i.        ExtraFiles []*os.File        // SysProcAttr holds optional, operating system-specific attributes.        // Run passes it to os.StartProcess as the os.ProcAttr&#39;s Sys field.        SysProcAttr *syscall.SysProcAttr        // Process is the underlying process, once started.        Process *os.Process        // ProcessState contains information about an exited process,        // available after a call to Wait or Run.        ProcessState *os.ProcessState        // contains filtered or unexported fields&#125;</code></pre><p>然后利用cmd调用Start函数，</p><pre><code>func (c *Cmd) Start() error</code></pre><p>Start开始执行以后并不阻塞。如果Start函数返回成功，则c.Process字段将被设置相关内容。在成功调用开始之后，必须调用Wait方法释放关联的系统资源。</p><p>这样，通过上述标准库提供的函数，我们就可以<strong>创建子进程</strong>了，下面我们来看一下如何进行<strong>进程间通信</strong>。</p><h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>操作系统信号（signal，以下简称信号）是IPC中唯一一种异步的通信方法，它的本质是用软件来模拟硬件的中断机制。信号用来通知某个进程有某个事件发生了。<br>每一个信号都有一个以“SIG”为前缀的名字，例如SIGINT、SIGQUIT以及SIGKILL等。在操作系统内部，这些信号都由正整数表示，这些正整数称为信号编号。在Linux的命令行终端下，我们可以使用kill  -l命令来查看当前系统所支持的信号</p><p>接口类型os.Signal 的声明如下：</p><pre><code>type Signal interface &#123;    String() string    Signal() // 与其他 Stringers 区分开来&#125;</code></pre><p>实现了os.Signal接口的类型就是1种信号量，或者说只要实现了Signal和String方法的类型就是1种信号量。比如像syscall.Signal类型，它的底层类型是int，但是它实现了os.Signal接口类型，因此syscall.Signal就是信号量类型（其下有多种信号量，每一个整型数字代表1中信号）。<br>os.Signal的Signal()的实现是一个空方法，syscall.Signal的Singal()是一个空方法，其他实现os.Signal的类型其Signal()也是空方法。Signal()方法的作用仅仅是为了标识这个实现了该方法的类型是一个信号量类型而已。<br>我们可以通过os.Signal的Signal()代码包os&#x2F;signal中的Notify 函数对信号进行接收</p><pre><code>func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</code></pre><p>这个函数需要传入一个channel，signal.Notify方法内部做的事就是接收到来自操作系统进程的信号并将这个信号发送给这个channel。 只有第二参sig中规定的信号量才会发送到chan中，其他信号量不会（而是执行系统默认操作）。然后在用户程序中异步的从这个channel接收信号就可以捕获来自操作系统发送的信号。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>下面是一个Notify调用示例：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>运行结果如下，可以看到我们已经对信号捕获成功：</p><pre><code>$ go run main.goStart running^CReceive signal from the operating system: interrupt^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^Z[2]+  Stopped                 go run main.go</code></pre><p>上面我们已经能够对信号进行捕获，现在想从主进程将信号传递到子进程。Cmd保存了子进程的信息，我们查看Cmd结构，可以找到Process(*os.Process)字段有一个Signal函数。</p><pre><code>type Process struct &#123;        Pid int        // contains filtered or unexported fields&#125;func (p *Process) Signal(sig Signal) error</code></pre><p>该函数的作用就是像进程发送信号，如果发送失败则会返回错误，我们可以通过Cmd对象获取对应的Process，然后调用该进程的signal函数像该子进程发送所需要的信号。<br>现在我们已经能够从父进程向子进程发送信号，下面我们创建一个子进程写一个示例，创建main.go文件：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;time&quot;)func main() &#123;    // 创建一个用于执行外部命令的 *exec.Cmd 对象    cmd := exec.Command(&quot;./child&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr        // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;启动子进程出错: &quot;+err.Error())        return    &#125;    // 等待一段时间，然后发送信号    time.Sleep(time.Millisecond * 500)    err = cmd.Process.Signal(os.Interrupt)    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;发送信号出错: &quot;+err.Error())        return    &#125;    // 等待子进程结束    err = cmd.Wait()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;等待子进程结束出错: &quot;+err.Error())    &#125;    return&#125;</code></pre><p>该函数通过 exec 包启动了一个子进程，并在一段时间后向子进程发送中断信号。子进程存储在child.go当中，我们直接运行child.go的编译的可执行文件。下面是子进程一个简单实现：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;)func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    fmt.Println(&quot;started&quot;)    &lt;-stop    fmt.Println(&quot;stopped&quot;)&#125;</code></pre><p>运行结果如下所示：</p><pre><code>$ go run main.gostartedstopped</code></pre><p>可以看到我们已经成功将信号传入了子函数当中。<br>结合Go进程的优雅退出(待附链接，金山文档容易链接失效，等待更新到博客再更新)<br>我们可以创建graceful_shutdown.go：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;time&quot;)func grace() &#123;    fmt.Println(&quot;处理剩余资源&quot;)    time.Sleep(2 * time.Second)&#125;func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    for &#123;        select &#123;        case &lt;-stop:            fmt.Println(&quot;收到父进程信号&quot;)            grace()            fmt.Println(&quot;子进程退出&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;子进程运行&quot;)        &#125;    &#125;&#125;</code></pre><p>模拟主进程收到信号传递给子进程的过程，我们将main.go文件也进行改写</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;os/signal&quot;    &quot;time&quot;)func main() &#123;    cmd := exec.Command(&quot;./grace_shutdown&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr    // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;Start: &quot;+err.Error())        return    &#125;    // 创建一个接收信号的通道    sigChannel := make(chan os.Signal, 1)    // 监听中断信号    signal.Notify(sigChannel, os.Interrupt)    for &#123;        select &#123;        case &lt;-sigChannel:            fmt.Println(&quot;父进程收到系统信号&quot;)            // 发送信号给子进程            err = cmd.Process.Signal(os.Interrupt)            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Signal: &quot;+err.Error())                return            &#125;            // 等待子进程结束            err = cmd.Wait()            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Wait: &quot;+err.Error())            &#125;            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;wait...&quot;)        &#125;    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.gowait...子进程运行wait...子进程运行wait...子进程运行^C父进程收到系统信号收到父进程信号处理剩余资源子进程退出</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程通信&quot;&gt;&lt;a href=&quot;#进程通信&quot; class=&quot;headerlink&quot; title=&quot;进程通信&quot;&gt;&lt;/a&gt;进程通信&lt;/h1&gt;&lt;h2 id=&quot;进程的创建&quot;&gt;&lt;a href=&quot;#进程的创建&quot; class=&quot;headerlink&quot; title=&quot;进程的创建&quot;&gt;</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>防疫大数据</title>
    <link href="http://example.com/p/43256.html"/>
    <id>http://example.com/p/43256.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防疫大数据"><a href="#防疫大数据" class="headerlink" title="防疫大数据"></a>防疫大数据</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。具体而言，在每天夜里，西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地区的信息，以及当天疫情风险地区的信息。数据中心需要根据这些信息，生成一份存在风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://imgse.com/i/x6kjot"><img src="https://s1.ax1x.com/2022/10/20/x6kjot.png" alt="x6kjot.png"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出到标准输出。<br>输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格分隔的若干整数。其中第一个整数表示当天的日期，接下来的各个整数为按从小到大排序的存在风险的用户列表。</p><p><strong>样例 1 输入</strong></p><pre><code>91 4 10 1 1-1 1 1-1 2 10 2 20 30 3 11 2 21 3 20 00 00 00 00 00 15 4 11 0 1</code></pre><p><strong>样例 1 输出</strong></p><pre><code>0 11 1 32 1 33 1 34 1 35 1 36 1 378</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>无脑做，不知道哪里有问题，只有20分，哭死（）</p><p> <strong>代码实现</strong></p><pre><code>？？？忘保存了！！！</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p><strong>代码实现</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;set&lt;LL&gt; sd[1050], su;struct node&#123;    LL d, u, r;&#125;a;vector&lt;node&gt; v[1050];LL n, ri, mi, d, u, r, pi;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) // i:生成名单这一天    &#123;        cin &gt;&gt; ri &gt;&gt; mi;                for (int j = 0; j &lt; ri; j ++ ) // ri个风险地区        &#123;            cin &gt;&gt; pi;            for (int k = i; k &lt; i + 7; k ++ ) sd[k].insert(pi); // pi地区i ~ i+6天都是风险地区        &#125;                for (int j = 0; j &lt; mi; j ++ ) //         &#123;            cin &gt;&gt; d &gt;&gt; u &gt;&gt; r;            if (d &lt; 0) continue;            if (!sd[d].count(r)) continue; // 到访的地区在到访的那一日不处于风险状态,肯定无风险            v[i].push_back(&#123;d, u, r&#125;); // 存储第i天的漫游数据        &#125;                // 对漫游信息进行判断,从第i-6天开始.因为7天前的用户漫游数据有可能到现在还是风险的        for (int j = max(0, i - 6); j &lt;= i; j ++ )        &#123;            for (int k = 0; k &lt; v[j].size(); k ++ )            &#123;                d = v[j][k].d;                u = v[j][k].u;                r = v[j][k].r;                                // 1.该用户的d要在7日内                // 2.该用户在近7日内到访的地区在到访的那一日处于风险状态                // 3.上述存在风险的地区自到访日(d)至生成名单当日(i)持续处于风险状态                bool flag = 1;                if (d &lt;= i - 7) continue; // 要求1                for (int l = d; l &lt;= i; l ++ ) // 要一直持续到当前i这一天 要求2&amp;3                    flag = flag &amp; sd[l].count(r);                if (flag) su.insert(u);            &#125;        &#125;                cout &lt;&lt; i &lt;&lt; &quot; &quot;;        for (auto it : su) cout &lt;&lt; it &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        su.clear();    &#125;        return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防疫大数据&quot;&gt;&lt;a href=&quot;#防疫大数据&quot; class=&quot;headerlink&quot; title=&quot;防疫大数据&quot;&gt;&lt;/a&gt;防疫大数据&lt;/h1&gt;&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>寻宝大作战</title>
    <link href="http://example.com/p/59129.html"/>
    <id>http://example.com/p/59129.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p><p>某天，小 P 获得了一张神秘的藏宝图。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br>简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br>地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br>其中 A[i][j]&#x3D;1 表示坐标 (i,j) 处种有一棵树，A[i][j]&#x3D;0 则表示坐标 (i,j) 处没有树。<br>换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p><p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br>并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br>具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br>理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br>对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]&#x3D;B[i][j]。<br>当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p><p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br>请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p><p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]&#x3D;B[0][0]&#x3D;1，表示了宝藏埋藏的位置。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p><p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p><p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p><p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br>需要注意，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p><p><strong>样例 1 输入</strong></p><pre><code>5 100 20 01 12 23 34 40 0 10 1 01 0 0</code></pre><p><strong>样例 1 输出</strong></p><pre><code>3</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>对stl掌握的不好，只能用数组碰运气来做。浪费很多时间，最后只拿了200分，第三题本来可以骗几个用例分数的，，，，，我采用的是记录稀疏矩阵，然后根据横坐标纵坐标排序，最后采用O(n)枚举的暴力做法。代码又臭又长，如下所示（不看也罢）：</p><p> <strong>代码实现</strong></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */struct Zb&#123;    int x;    int y;&#125;zb[1050],cbt[60];int ss[60][60];int cmp(struct Zb a,struct Zb b)&#123;    if(a.x==b.x)&#123;        return a.y&lt;b.y;    &#125;    else return a.x&lt;b.x;    &#125;int main(int argc, char** argv) &#123;    int n,L,s ;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;L,&amp;s);    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;zb[i].x,&amp;zb[i].y);    &#125;        sort(zb,zb+n,cmp);        int t,count=0;        for(int i=s;i&gt;=0;i--)&#123;            for(int j=0;j&lt;=s;j++)&#123;                scanf(&quot;%d&quot;,&amp;ss[i][j]);                if(ss[i][j]==1)&#123;                    cbt[count].y=j;                    cbt[count].x=i;                    count++;                &#125;            &#125;        &#125;        sort(cbt,cbt+count,cmp);        int vcount =0;        for(int i=0;i&lt;n;i++)&#123;            int flag=0;            int k=i+1;            int countzb=0;            if(zb[i].x&gt;L-s||zb[i].y&gt;L-s)flag=1;            while(zb[k].x-zb[i].x&lt;=s&amp;&amp;k&lt;n)&#123;                if(abs(zb[k].x-zb[i].x)&lt;=s&amp;&amp;zb[k].y-zb[i].y&lt;=s&amp;&amp;zb[k].y-zb[i].y&gt;=0)&#123;                    if(ss[abs(zb[k].x-zb[i].x)][abs(zb[k].y-zb[i].y)]!=1)&#123;                        flag=1;                        break;                    &#125;                     countzb++;                &#125;                k++;            &#125;            if(countzb+1!=count)flag=1;            if(flag==0)&#123;                    vcount++;            &#125;        &#125;        printf(&quot;%d&quot;,vcount);     return 0;&#125;</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p>对于较大数据10^9，如果用二维数组vector的话无法开辟那么大空间，换成二维map来存储可以解决较大数据问题。解决好两个图的存储问题之后，接下来就是找到符合要求的可能埋有宝藏地点个数，无非就是两个条件：一是满足藏宝图可以在绿化图某块区域完美对上，二是满足藏宝图在绿化图中不出界。可以利用这两个条件去判断每一个符合条件的绿树点。如果两个条件都满足即有可能此处为藏宝点。<br><strong>代码实现</strong></p><pre><code>#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;cmath&gt;using namespace std;//pair&lt;int ,int&gt;和int对应map&lt;int,map&lt;int,int&gt; &gt;mp;struct node&#123;    int x,y;&#125;point[1001];int g[51][51];//地图int main()&#123;    int n,L,S;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;point[i].x&gt;&gt;point[i].y;        mp[point[i].x][point[i].y]=1;    &#125;    //输入也是一个坑    for(int i=S;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=S;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        int flag=1;        int x=point[i].x,y=point[i].y;        for(int j=0;j&lt;=S;j++)&#123;            for(int k=0;k&lt;=S;k++)&#123;                if(x+S&gt;L||y+S&gt;L||mp[x+j][y+k]!=g[j][k])&#123;                    flag=0;                    break;                &#125;            &#125;            if(!flag) break;        &#125;        if(flag) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;</code></pre><p><a href="https://blog.csdn.net/victory066/article/details/125819918">作者原文</a><br><a href="https://blog.csdn.net/victory066/article/details/125819918">https://blog.csdn.net/victory066/article/details/125819918</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;h3 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>非零段划分</title>
    <link href="http://example.com/p/40034.html"/>
    <id>http://example.com/p/40034.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,…,Aj 是一个非零段     当且仅当以下条件同时满足：    ·1≤i≤j≤n；    ·对于任意的整数 k，若 i≤k≤j，则 Ak＞0；    ·i=1 或 Ai-1=0；    ·j=n 或 Aj+1=0。    下面展示了几个简单的例子：    ·A = [3,1,2,0,0,2,0,4,5,0,2]中的4个非零段依次为[3, 1, 2],[2],[4, 5]和[2]；    ·A = [2, 3, 1, 4, 5] 仅有 1 个非零段；    ·A = [0, 0, 0] 则不含非零段（即非零段个数为 0）。    现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。    试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，    可取 p = 1，即不对 A 做任何修改。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入格式    从标准输入读入数据。    输入的第一行包含一个正整数 n。    输入的第二行包含 n 个用空格分隔的自然数 A1, A2, … , An。    输出格式    输出到标准输出。    仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组cnt[]，cnt[i] 表示海平面下降到i时，岛屿数量的变化。差分法是最简洁的解题程序。数组元素d[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中为后缀和）中找出最大值就是所要的结果。程序代码中，STL算法函数unique()用来去除相邻重复的元素。语句“a[0] = a[n + 1] = 0;”用来设置边界值，起辅助计算作用，可以简化程序代码。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* CCF202109-2 非零段划分 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000;const int M = 10000;int a[N + 2], d[M + 1];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    a[0] = a[n + 1] = 0;    n = unique(a, a + n + 2) - a - 1;    memset(d, 0, sizeof d);    for (int i = 1; i &lt; n; i++)        if (a[i - 1] &lt; a[i] &amp;&amp; a[i] &gt; a[i + 1]) d[a[i]]++;        else if (a[i - 1] &gt; a[i] &amp;&amp; a[i] &lt;a[i + 1]) d[a[i]]--;    int ans = 0, sum = 0;   // 差分前缀和即为答案    for (int i = M; i &gt;= 1; i--)        sum += d[i], ans = max(ans, sum);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;&#125;</code></pre><p>来源：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">https://blog.csdn.net/tigerisland45/article/details/120598581</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>数组中数字出现的个数</title>
    <link href="http://example.com/p/34639.html"/>
    <id>http://example.com/p/34639.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组中数字出现的个数"><a href="#数组中数字出现的个数" class="headerlink" title="数组中数字出现的个数"></a>数组中数字出现的个数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>输入：</p><pre><code>1 2 3 4 4 2</code></pre><p>输出：</p><pre><code>1 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code>这里只想到了如何快速获得一个只出现一次的数字，没有想到分组异或相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ret = 0;        for (int n : nums)            ret ^= n;        int div = 1;        while ((div &amp; ret) == 0)            div &lt;&lt;= 1;        int a = 0, b = 0;        for (int n : nums)            if (div &amp; n)                a ^= n;            else                b ^= n;        return vector&lt;int&gt;&#123;a, b&#125;;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组中数字出现的个数&quot;&gt;&lt;a href=&quot;#数组中数字出现的个数&quot; class=&quot;headerlink&quot; title=&quot;数组中数字出现的个数&quot;&gt;&lt;/a&gt;数组中数字出现的个数&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;head</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
