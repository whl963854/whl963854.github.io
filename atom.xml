<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-07T15:55:56.149Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手机拍摄</title>
    <link href="http://example.com/p/4dca9730.html"/>
    <id>http://example.com/p/4dca9730.html</id>
    <published>2024-10-01T05:20:42.801Z</published>
    <updated>2024-11-07T15:55:56.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手机拍摄"><a href="#手机拍摄" class="headerlink" title="手机拍摄"></a>手机拍摄</h1><p>在手机厂商们不断地努力下，面对绝大部分场景，我们只需轻轻触碰快门按钮，即可获得一张成像质量不错的照片。按快门这个动作非常简单，但是我们很多时候追求的并不仅仅是看起来清楚的照片，我们需要一张高质量、具有一定美感和故事的照片。照片不仅用作自己欣赏，更是我们表达自我的方式。虽然手机的相机操作界面看上去很简洁，但里面仍然提供了不少的功能，例如画幅选择、连拍、曝光、对焦、变焦、锁焦、闪光灯等等。</p><h2 id="拍摄前准备工作"><a href="#拍摄前准备工作" class="headerlink" title="拍摄前准备工作"></a>拍摄前准备工作</h2><p><strong>后期永远是去完善一张照片，而不是拯救一张照片</strong></p><h3 id="打开辅助线"><a href="#打开辅助线" class="headerlink" title="打开辅助线"></a>打开辅助线</h3><p>构图辅助线，通常是在取景框内提供九宫格线条以方便我们拍摄构图时进行参考。这个功能默认是关闭的，建议打开且保持长期开启状态。</p><p><img src="https://s21.ax1x.com/2024/10/01/pA3QTYT.png"></p><p>辅助线对于我们拍摄时的构图参考非常有帮助，像横平竖直、三分法、黄金分割点、对称构图等都会用到辅助线。我们先来通过辅助线看看几张例图。</p><p><img src="https://s21.ax1x.com/2024/10/01/pA3Q7fU.png"></p><p>借助辅助线，这张照片将画面里的河流、房屋、天空三部分主要内容合理分配。</p><h3 id="使用默认拍摄比例"><a href="#使用默认拍摄比例" class="headerlink" title="使用默认拍摄比例"></a>使用默认拍摄比例</h3><p>在相机拍摄界面，我们可以选择当前取景器的画面比例，通常有 1:1、4:3、16:9 等可选择。在前期拍摄时，最好都使用默认的比例。在手机上，默认比例是 4:3，这是与相机传感器比例对应的。</p><p><img src="https://s21.ax1x.com/2024/10/01/pA3QbpF.png"></p><p>这是一张用手机 4:3 默认比例拍摄的照片，照片里标明了同等条件下如果使用 1:1、16:9 比例拍摄会得到的画面区域，只要是非 4:3 比例拍摄的照片，画面信息都会比 4:3 比例拍摄的照片少。这是因为那些非默认比例拍摄的照片，都是通过在默认比例基础上裁剪得来的。</p><h2 id="构图规则"><a href="#构图规则" class="headerlink" title="构图规则"></a>构图规则</h2><h3 id="横平竖直与适当倾斜"><a href="#横平竖直与适当倾斜" class="headerlink" title="横平竖直与适当倾斜"></a><strong>横平竖直与适当倾斜</strong></h3><p>我们可以依据具体画面内容和拍摄角度的不同来做调整。你可以思考这张照片具体是需要横平与竖直两个要素都具备，还是只侧重其中一个要素。要时刻记得，<strong>横平竖直目的是还原我们肉眼所见的真实角度</strong>。做到整体观感是横平竖直的即可。我们需要<strong>先保证画面边缘是绝对水平的状态。</strong>因为边缘部分有画框的线条来对比参考，容易被一眼看出来问题。</p><p>但是，横平竖直并不是绝对的。在我们面对一些特定内容的时候，适当倾斜，或者取舍横平竖直，可以得到更好的照片。</p><p>仰视和俯视等一些特殊角度，现实场景里本来也并非横平竖直的，自然表现出来就好，用不着刻意纠正。</p><p>横平竖直还是适当倾斜，这是我们拍摄前需要思考的第一个问题。你的照片可以不是横平竖直的，但你必须明确你倾斜拍摄的目的是什么，一定要拒绝不加思考直接抬手咔嚓的动作。</p><h3 id="三分法-amp-黄金分割点"><a href="#三分法-amp-黄金分割点" class="headerlink" title="三分法 &amp; 黄金分割点"></a><strong>三分法</strong> <strong>&amp;</strong> <strong>黄金分割点</strong></h3><p>三分法 &amp; 黄金分割点是两种非常好用，而且简单易上手的构图方法。三分法是通过 4 条线把画面横竖方向等分，而这 4 条线所形成的 4 个相交点是黄金分割点。黄金比例大约是 0.618，简单的 2&#x2F;3 接近这个数字。通常我们可以利用三分来布置画面比例，然后用黄金分割点来放置主体。通过遵循黄金比例来分配画面内容的这种方法，可以轻松使得照片结构看起来清晰明了。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAyADSA.png"></p><p>这张照片从水平方向进行三分，天空和建筑的比例大概为 1: 2。画面</p><p>主要内容分为三部分：河道、天空、两边古建筑，它们各自占据画面大致 1&#x2F;3 的内容。</p><h3 id="对称构图"><a href="#对称构图" class="headerlink" title="对称构图"></a><strong>对称构图</strong></h3><p><img src="C:/Users/22537/AppData/Roaming/Typora/typora-user-images/image-20241107233248306.png" alt="image-20241107233248306"></p><p>列车站通常也是对称设计的建筑，这张照片以列车站的时钟为中心对称构图。</p><p><img src="C:/Users/22537/AppData/Roaming/Typora/typora-user-images/image-20241107233331722.png" alt="image-20241107233331722"></p><p>除了场景里本身存在的对称外，我们也可以自己去发现创造对称场景，最常见的方式是利用镜面，这里的镜面可以是玻璃、水面等等。拍摄此类照片时，需要把手机的镜头尽可能靠近镜面。例如水面拍摄时，就要将手机的顶部靠近水面。这种视角是我们日常肉眼不会观察到的。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy697n.png" alt="image-20241107234126427"></p><p>由于近大远小的关系，我们并不一定需要很大面积的镜面，才能拍摄镜面对称的画面。有时候一滩积水甚至自己往地面倒一点水就可以了。</p><h3 id="重复元素"><a href="#重复元素" class="headerlink" title="重复元素"></a><strong>重复元素</strong></h3><p>严格意义上来说，重复元素并非一种构图方式，而是我们拍摄时观察场景的一种思考方向。我们通过寻找和提取场景里的重复元素，来引导画面看点，增加照片美感。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6it0.png" alt="image-20241107234426398"></p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6FhV.png" alt="image-20241107234453049"></p><h3 id="视觉引导线"><a href="#视觉引导线" class="headerlink" title="视觉引导线"></a><strong>视觉引导线</strong></h3><p>视觉引导线指的是通过创造一些具有引导线的信息，来引导帮助看图者找到主体。当你希望画面主题需要隐晦展示而非直白展示，或者当画面主体不易被发现时，我们便可以借助视觉引导线的帮助。任何你认为可以帮助看图者理解画面意图的信息，都可以成为视觉引导线，例如指向主体的线条、人物视线、某个符号等等。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6ApT.png" alt="image-20241107234625788"></p><p>通过渔船行驶过后产生的浪花，引导视觉往画面的顶部看，可以隐约看见远处的跨海大桥。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6E1U.png" alt="image-20241107234646043"></p><p>利用人物视线的引导，将画面远处右前方的人物内容引导出来。这张照片里左右两处内容都是主体，他们在这张图里牵连着，忧伤与欢乐同在.</p><h3 id="合适内容对应合适比例"><a href="#合适内容对应合适比例" class="headerlink" title="合适内容对应合适比例"></a><strong>合适内容对应合适比例</strong></h3><p>画幅比例，是每次处理照片时都会面临的问题。画幅比例的选择取决于两个方面：照片内容和你个人喜好。</p><p>举例来说：当你希望照片在竖屏设备上看起来更好时，选择长比例更为合适；当你希望照片营造一些电影感的氛围时，选择接近电影画幅的宽比例更为合适；有些照片由于是一组系列作品，它们可能采用某个相同的比例更合适；有些人可能会偏爱某一种画幅比例，无论拍摄什么样的照片，都使用相同的比例。针对不同画面内容采用不同的画幅比例，是更合理的一种做法。一般情况下在选择比例时建议用常见的固定比例（ 1: 1、3: 2、4: 3、16: 9 … ），而非自由比例。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6WEn.png" alt="image-20241107235145930"></p><p>由于希望体现出大海的广度，这张图很自然地选择了一个宽图比例。</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6cuQ.png" alt="image-20241107235044563"></p><p>选择了一个宽图比例，去尽可能展示我想展示的全部内容，包括天空与建筑的占比、右边的路灯、人群的位置等</p><p><img src="https://s21.ax1x.com/2024/11/07/pAy6gBj.png" alt="image-20241107235113149"></p><p>这张照片选择长图比例，可以提升灯笼在画面里的重要性。同时内容本身也是往前（河道）和上下（楼房和建筑）展开的，并没有像大海那样往两边展开，于是长图的比例更为合适。</p><h3 id="框架式构图"><a href="#框架式构图" class="headerlink" title="框架式构图"></a><strong>框架式构图</strong></h3><p>框架式构图，是利用一些前景来进行构图。例如窗户、门、镜子或者场景里形成的某处缝隙等。通过框架式构图，主体得以被引导和强调。一些好的框架会形成不错的美感，或者帮助遮挡场景里的不必要信息。</p><p><img src="C:/Users/22537/AppData/Roaming/Typora/typora-user-images/image-20241107235512547.png" alt="image-20241107235512547"></p><p>这是最简单的一张框架式构图，利用窗户来完成构图，窗外为次要内容，主要内容放在窗内即可.</p><p><img src="C:/Users/22537/AppData/Roaming/Typora/typora-user-images/image-20241107235423476.png" alt="image-20241107235423476"></p><p>海边垂钓的这张照片，利用椰树林间的缝隙形成框架，主体则是缝隙里的钓鱼者。</p><h3 id="二次构图"><a href="#二次构图" class="headerlink" title="二次构图"></a><strong>二次构图</strong></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手机拍摄&quot;&gt;&lt;a href=&quot;#手机拍摄&quot; class=&quot;headerlink&quot; title=&quot;手机拍摄&quot;&gt;&lt;/a&gt;手机拍摄&lt;/h1&gt;&lt;p&gt;在手机厂商们不断地努力下，面对绝大部分场景，我们只需轻轻触碰快门按钮，即可获得一张成像质量不错的照片。按快门这个动作非常简单</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>谁动了我的奶酪</title>
    <link href="http://example.com/p/40998eb9.html"/>
    <id>http://example.com/p/40998eb9.html</id>
    <published>2024-09-16T01:39:39.952Z</published>
    <updated>2024-09-16T02:03:51.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谁动了我的奶酪"><a href="#谁动了我的奶酪" class="headerlink" title="谁动了我的奶酪"></a>谁动了我的奶酪</h1><p>他们总会不断地拿走奶酪</p><blockquote><p>变化总是会发生</p></blockquote><p>时刻做好失去奶酪的准备</p><blockquote><p>预测变化</p></blockquote><p>经常嗅一嗅奶酪，这样你才能知道它是否新鲜</p><blockquote><p>密切关注变化</p></blockquote><p>越快放弃旧的奶酪，你就可以越早享受新的奶酪</p><blockquote><p>迅速适应变化</p></blockquote><p>随着奶酪的变化而变化</p><blockquote><p>变化</p></blockquote><p>尽情享受探险的过程和新奶酪的美味</p><blockquote><p>享受变化</p></blockquote><p>记住：他们总会不断地拿走你的奶酪</p><blockquote><p>迅速做好改变的准备，享受其中的乐趣</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;谁动了我的奶酪&quot;&gt;&lt;a href=&quot;#谁动了我的奶酪&quot; class=&quot;headerlink&quot; title=&quot;谁动了我的奶酪&quot;&gt;&lt;/a&gt;谁动了我的奶酪&lt;/h1&gt;&lt;p&gt;他们总会不断地拿走奶酪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变化总是会发生&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>职业素养</title>
    <link href="http://example.com/p/40680c84.html"/>
    <id>http://example.com/p/40680c84.html</id>
    <published>2024-08-21T15:04:09.478Z</published>
    <updated>2024-09-16T02:03:51.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="职业素养"><a href="#职业素养" class="headerlink" title="职业素养"></a>职业素养</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>从两个维度去给工作划分类型，一个维度是工作本身的性质，另一个维度从合作角度出发，然后根据这些工作的重要与否安排优先级。</p><p>怎么整理优先级呢？<br>首先把所有的事情列出来，然后对每件事情问自己两个问题：<br>1）不做这个会怎么样？<br>2）做了这个能怎么样？<br>在工作中，事情的优先级的判断标准是让公司收益，老板满意，同事认可</p><h4 id="基于工作性质安排优先级"><a href="#基于工作性质安排优先级" class="headerlink" title="基于工作性质安排优先级"></a>基于工作性质安排优先级</h4><p>工作划分为<strong>公司发展计划</strong>、<strong>安全相关的事情</strong>和<strong>生产上的事情</strong>。<br>每个公司都有自己的发展计划，并给这些计划划定不同的权重，以指导协调公司内有限的资源。每年公司高层都会制定当年的发展目标，然后以此为依据，制定不同的发展项目，再根据项目，一层层地将项目分解为各个部门的子项目等等。每个部门，以顶级项目的优先级为参考，安排自己的资源，以达到公司的发展目标。我们需要了解公司的发展方向和重点项目。一般来说，公司的发展目标和与之相关的各个项目的优先级都会对内公开，公司也鼓励所有员工都熟悉这些内容。当和这个项目相关的工作安排到自己手里的时候，一定要给予这种工作足够的优先级。<br>首先要遵守安全部门的安全规范和检查，这就好像进入工地要戴安全帽，是没得商量的。<br>安全部门有时候还会发布紧急安全升级等要求。我们一定要把这个当作优先级最高的任务，不要有任何的犹豫或轻视。站在我们程序员的角度想一下，一旦出了安全问题，如果是因为自己执行不到位，这个责任肯定是要自己承担的，即使后期再怎么弥补，也无济于事。<br>如果生产出了问题，那么作为 DevOps 的程序员，要第一时间放下手头的事情，冲上去搞。理清问题之后，马上开始行动。生产上的问题都是火烧眉毛。火烧眉毛的时候，你会等着别人给你送水，还是自己想尽一切办法找水呢？当然是自己找水了。如果需要别人配合，马上联系相关的人或者其经理。</p><h4 id="基于合作安排优先级"><a href="#基于合作安排优先级" class="headerlink" title="基于合作安排优先级"></a>基于合作安排优先级</h4><p>在日常工作中，我们有很多任务都是经理下达的。经理往往掌握着更多的信息，也更能判断一件事情的优先级。现在一般都是敏捷开发，经理会给每个 story 排优先级。在给任务排优先级的事情上，程序员可以提建议，也可以和经理讨论，但是一定要<strong>以经理的决定为准</strong>。还有一些<strong>经理临时安排的事情</strong>，这种事情有时候更急一些，可能也不用耗费很长时间。所以这种事情也要先做。</p><p>如果一个事情<strong>需要别的部门配合</strong>，那么优先做。比如申请资源，和自己的上游讨论需求等等。这样一方面可以让别人尽早开始工作，另一方面也可以尽早交换信息，避免日后翻车。<br>如果事情没有太明显的轻重缓急，那么换位思考，与人为善，优先做那些<strong>阻塞了别人工作的事</strong>情。有些事情是来自组内的，有些来自组间合作。良好的合作关系就是这样一点点打磨出来的。<br>尽量做到把阶段性成果给需求方</p><h3 id="邮件沟通"><a href="#邮件沟通" class="headerlink" title="邮件沟通"></a>邮件沟通</h3><p>“邮件不是用来沟通的，它是用来撕扯和甩锅的。”<br>邮件不只是一个沟通的渠道，而是一个正式的，签合同的渠道。现在很多公司也在积极的使用更高效的工具代替邮件的功能，但是本质是一样的。</p><h4 id="邮件的特性"><a href="#邮件的特性" class="headerlink" title="邮件的特性"></a>邮件的特性</h4><ol><li>异步交流：邮件是一种异步交流的方式，双方有足够的时间准备邮件内容。</li><li>无法修改：邮件内容无法修改，这是邮件可靠的基石。</li><li>方便扩散：邮件有邮件组，可以很方便地把相关人员加进来，并且保留邮件历史记录。</li></ol><h4 id="邮件是不成文的合同"><a href="#邮件是不成文的合同" class="headerlink" title="邮件是不成文的合同"></a>邮件是不成文的合同</h4><ol><li>确认功能</li><li>证据链</li><li>沟通协调</li><li>防止遗忘</li><li>技术升级和Bug修复（广而告之）</li></ol><p>我们要<strong>定期看邮件</strong>。<br>回复或发送一封邮件的时候，<strong>看清收件人</strong>有哪些，再决定自己该说什么。<br>首先要学会<strong>抄送老板</strong>。如果想催促进度，就抄上对方的老板。如果觉得自己搞不定，记得抄上自己的老板。<br>其次要<strong>用好邮件组</strong>，该加人的时候加人，比如某个组的邮件列表，某个部门的邮件列表等。做到应通知，尽通知。避免只通知某个组的某个人，以免这个人对邮件中的事情有误解或者漏掉了信息。<br>如果你的邮件收件人比较多，那就记得<strong>多检查一下邮件内容和标题</strong>。</p><p>如果是和自己相关的会，开完会之后一定要记得发一封<strong>会议纪要</strong>，给所有参会人员。会议纪要可以总结这个会上得出的共识，列出下一步可以采取的行动，保证这个会上得出的成果不会被遗忘或者被误解。</p><h3 id="多交流"><a href="#多交流" class="headerlink" title="多交流"></a>多交流</h3><p>短期来看，少参加一个会，少和人聊两句业务，少被人打断几次，从一个星期的维度看，可能工作确实完成得更快了，加班更少了。<br>但是从长期发展来看，缺少交流的程序员，很难发展为公司的骨干，升职加薪可能都会被排在后面。我们的工作，真的不止眼前的程序。在做事情的时候，优秀的交流能力是必须的。如果你能够展示自己在交流能力上的优势，组内外的同事也更愿意和你合作，经理也会优先考虑让你承担更多的责任，对自己的发展有很大的好处。<br>交流的好处可以从两个方面来说，一个是输入，一个是输出。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>在一个公司里实现成长，就要时刻保持自己获取信息。如果能够重视平时的交流，交流的时候多主动思考，慢慢地，自己收获的关于公司和行业的信息也就越来越多，没准还就能够找到新的突破点，抓住新的机会。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>交流不一定要是非常正视的形式。我们可以闲聊，趁着吃饭或者散步的时间，主动和组内同事，和自己的经理，和自己上下游的关键联系人交流自己的想法以及正在自己做的事情，然后也从对方那里获取相应的信息。<br>不要让自己做一个小透明，做的事情要让别人知道。同时，也知道别人在做什么，别人遇到了什么问题。别人的问题，就是你潜在的机会。</p><h4 id="交流技巧"><a href="#交流技巧" class="headerlink" title="交流技巧"></a>交流技巧</h4><p>换位思考，注意受众<br>人和人之间交流最重要的一点就是换位思考。站在对方的角度理解自己表述的内容，看看能否被正确地接纳和吸收。程序员是一种专业性很强的工种。很多专业技能相关的内容，可能会让非专业人士摸不着头脑。大到一个公司，一个部门，小到一个组，一个项目，都可能有很多专有名词，专用词汇，需要很强的背景知识。<br>们在交流的时候，首先要进行快速的角色转换，找到对方和自己认知的“最大公约数”，英文叫做“on the same page”。然后对于交流中需要补充的知识做简单的介绍，比如系统特点，专有名词的介绍等等，避免受众一路带着问号听你说，最后对话变成了“鸡同鸭讲”。<br>简单来说，既要让对方听明白，也要让对方听到自己应该听的。交流不是应付差事，说完拉倒，也不要只顾自己说。</p><p>交流要带有足够的信息<br>用数据说话，数据出处要清晰；推理条理要清晰，事情的来龙去脉要清晰。</p><blockquote><p>这一条规则适用于所有场合。日常中普通的交流也是，如果带着明确的目的，那么就要先说出自己的结论和想法；如果是写邮件和文档，内容翔实的一个副作用是难免冗长。这时候应该注意，先把结论抛出来，再写细节。如果是 PPT 类的演讲，也是先抛出结论和成果，再去涉及详细的内容。这样不仅可以让对方马上抓到重点，而且还可以让对方在有疑问的时候，可以带着疑问去阅读后续的细节。</p></blockquote><h3 id="主观能动性"><a href="#主观能动性" class="headerlink" title="主观能动性"></a>主观能动性</h3><p>很多时候，只要我们勤勤恳恳，认真负责地做好老大交代的任务，就算是一个合格甚至优秀的员工了。但是程序员这份工作，如果只是做到这一点，最多算是合格。由于软件开发的特殊性，一个任务完成的界限是非常模糊的，而且会根据具体的情况而变化。那么这时候，就要求程序员发挥自己的主观能动性，才能把事情做成，能够交付，而不仅仅字面意义上的“完成工作”。<br>做着职位工作，即为公司打工的思维；<br>想着本质进步，是成稀缺人才的方式。</p><h4 id="交付思维"><a href="#交付思维" class="headerlink" title="交付思维"></a>交付思维</h4><p>发挥主观能动性，究其核心：站在用户的角度，交付用户想要的东西。也就是说，不能止步于用户的需求。程序员作为冲在第一线的人，对细节的掌握是最多的。我们需要依靠这些细节，结合用户的需求，理解用户需求背后真正想要的东西，然后努力向这个目标发展。做得好的标准，就是理解用户没说出来的需求，能够为用户着想，交付用户想要的东西。</p><h4 id="注意时间"><a href="#注意时间" class="headerlink" title="注意时间"></a>注意时间</h4><p>发挥主观能动性的一个代价，就是会用掉更多的时间。这方面一定要注意。比起功能的完美，在规定的时间内实现基本功能，才是优先级更高的事情。假如你突然对一件事情有了想法，但是时间来不及，或者不确定是不是对用户有价值，那么可以及时和用户交流。如果用户觉得这个细节确实很重要，即使延期也值得做，那么大家可以商量新的时间线。如果用户觉得可有可无，或者可以放在后续迭代来做，那么就专心做好需求里描述好的功能。<br>程序员在发挥主观能动性的时候，也难免会“夹带私货”。比如说，自己想用个什么新技术，试试不同的做法。这时候也要注意时间。用户可能一时无法理解新东西给自己带来的好处，但是用户肯定知道项目无法按时完工的坏处。所以在“夹带私货”的时候，一定要保证自己对项目的进度有所把控，不要因为自己的私欲让整个项目无法完成。<br>让听得见炮声的人决策。程序员就是那个拿着作战目标，冲在一线，能够听得到炮声的人。</p><h3 id="责任的边界"><a href="#责任的边界" class="headerlink" title="责任的边界"></a>责任的边界</h3><p>在现代社会，责任一般是和钱挂钩的</p><h4 id="对自己的基本能力负责"><a href="#对自己的基本能力负责" class="headerlink" title="对自己的基本能力负责"></a>对自己的基本能力负责</h4><h2 id="职业选择"><a href="#职业选择" class="headerlink" title="职业选择"></a>职业选择</h2><h3 id="管理者关系"><a href="#管理者关系" class="headerlink" title="管理者关系"></a>管理者关系</h3><p>职场两大幸事就是跟对人，做对事。在一个值得跟的经理下面，做有价值的事情。一般来说，只要跟的人非常好，那么做的事情一般也是可以接受的。但反过来，如果跟的人实在是不行，那么如果有更好的机会，可以考虑求变。</p><h4 id="认同彼此的价值观和人格"><a href="#认同彼此的价值观和人格" class="headerlink" title="认同彼此的价值观和人格"></a>认同彼此的价值观和人格</h4><p>值得跟的人还有一个很重要的特性，就是有担当，勇于承担责任。经理作为管理者，有权利支配所有人去做事情，甚至开除办事不力的人，但是同样的，他也要对手下的人做的事情负责。组里的成员如果工作没做好，出了问题，那么经理应该承担起责任，做“背锅侠”，同时制定相应的策略，避免问题再次发生。如果一个经理出了事情就拿手下的人开整，那么这不算一个值得跟的经理。</p><h4 id="定期和你交流"><a href="#定期和你交流" class="headerlink" title="定期和你交流"></a>定期和你交流</h4><p>这里说的交流，指的不是经理居高临下地在上面讲话，你在下面拿着小本本一边记录一边点头；也不是安排工作时的交谈，而是和你交流你工作中遇到的问题，对组里做的事情的看法，未来想要发展的方向，自己的兴趣，甚至平时生活工作中的琐碎事情等等。同时，他也会和你聊他眼中的组里的发展方向，事情的优先级，可能的机会等等。更重要的是，他会根据你这段时间的工作，指出好和不好的地方。好的地方给予肯定，不好的地方也要指出根本原因，并给你进一步发展的建议。这种沟通有个名字叫做一对一会议（one-on-one meeting），是由经理发起的，和手下人定期一对一交流的会议。这种会议的作用，就是让经理和手下坐在一起，把平时不方便说的话都说了，能够放开沟通，增进彼此理解，是上下级关系的润滑剂。<br>在这种沟通中，你能了解自己工作的意义，看清“诗和远方”；也能把自己对问题的认识和看法跟经理讲一讲，让彼此的认知能够同步；还能够对自己进行一个非正式的“绩效考核”，对自己的工作成果有一个阶段性的认识。</p><h4 id="可以互相讨论甚至争论"><a href="#可以互相讨论甚至争论" class="headerlink" title="可以互相讨论甚至争论"></a>可以互相讨论甚至争论</h4><p>和经理讨论问题，在我看来也是很重要的。经理要有足够的心胸，愿意和自己的手下讨论问题，听取大家的意见。能够在和下属讨论问题的时候，平等的交流甚至争论。尤其是在一组人一起讨论问题的时候，经理要有能力引导讨论，指出讨论的方向。</p><h4 id="资源和利益的分配"><a href="#资源和利益的分配" class="headerlink" title="资源和利益的分配"></a>资源和利益的分配</h4><p>首先是新技术、新方向的学习机会。作为程序员，我们的工作领域就是不断变化的，一直都<br>有新的方向，新的技术。<br>当然，组里可能还有各种大大小小各种各样的机会，比如新的项目、新的客户、新的平台、<br>技术培训等。这都是经理可以掌握的资源。如何合理公平地分配这些资源，就很考验经理的<br>素质了。<br>从经理的角度来讲，肯定愿意组内有更高的产出。如果你和经理交流的时候明确表达过自己<br>的兴趣和下一步希望发展的方向，但是真有了这种尝试的时候却没有考虑你，那么不妨开诚<br>布公地和经理聊聊。经理可能觉得你现在的工作更重要，也可能觉得你现在火候不够，也可<br>能觉得你平时工作不够踏实，新的机会给你对别人不公平。</p><p>第二点就是时间了。每个人的工作时间可以说是经理掌握的最有价值的资源了。培养人才和<br>为公司创造价值这俩目标，都需要用到组员的工作时间。当两者冲突的时候，如果经理愿意<br>出于培养人才的目的，安排一部分时间让你成长，那么可以说是一种非常明显的培养你的信<br>号了。而且经理愿意这么做，更重要的原因是他愿意相信付出的这些培养人才的时间，后续<br>可以获得更多的回报，能够为公司创造更多的价值</p><h4 id="能够争取到利益并公平分配"><a href="#能够争取到利益并公平分配" class="headerlink" title="能够争取到利益并公平分配"></a>能够争取到利益并公平分配</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;职业素养&quot;&gt;&lt;a href=&quot;#职业素养&quot; class=&quot;headerlink&quot; title=&quot;职业素养&quot;&gt;&lt;/a&gt;职业素养&lt;/h2&gt;&lt;h3 id=&quot;优先级&quot;&gt;&lt;a href=&quot;#优先级&quot; class=&quot;headerlink&quot; title=&quot;优先级&quot;&gt;&lt;/a&gt;优先</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp三种编程范式</title>
    <link href="http://example.com/p/f08fc2eb.html"/>
    <id>http://example.com/p/f08fc2eb.html</id>
    <published>2024-08-07T15:31:05.332Z</published>
    <updated>2024-09-16T10:34:15.227Z</updated>
    
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>开发者测试</title>
    <link href="http://example.com/p/74032a66.html"/>
    <id>http://example.com/p/74032a66.html</id>
    <published>2024-08-07T15:20:42.091Z</published>
    <updated>2024-09-16T10:31:32.931Z</updated>
    
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>英语学习</title>
    <link href="http://example.com/p/3f43dc72.html"/>
    <id>http://example.com/p/3f43dc72.html</id>
    <published>2024-05-02T07:28:40.206Z</published>
    <updated>2024-09-27T13:18:21.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h1><p>多数人在用学习“知识”的方法来学习英语，可英语实际上是一种特殊的“技能”，而非“知识”。语言，从本质上讲是一种技能，一种需要通过反复模仿和刻意练习才能娴熟使用的工具。传统的英语教学“把语言这项技能当成知识来教”这一点，或许是我们英语学习路上最大的一个坑了。</p><p>学习英语有三个关键要素：语音、语法和词汇。</p><p><strong>第一，语音靠模仿。</strong><br>寻找有音频和文字的语言材料，熟读文字并仔细听几遍音频后，自己逐段朗读，无论语音还是语调，都要尽量模仿得和原声一模一样。朗读的同时用手机或录音笔把自己的声音录下来，供自己回放，和原音频比较差别。</p><p><strong>第二，语法靠阅读。</strong><br>所谓“语法”，就是“遣词”和“造句”之法。“语法”学习的首要目的，就是读懂句子，解决“所有词都认识，还是读不懂一句话”的问题。了解基本词类：主要是名词（数、格、性）和动词（时态、被动语态、助动词和情态动词，非限定动词、虚拟语气等），穿插代词、副词和形容词。读懂和会写简单句：结合文章介绍基本句型，通过例句讲解搭配、断句、主谓一致等问题，搞清楚句子的成分，慢慢能自己读懂句子，并模仿出清晰准确的句子。读懂从句，学会写复合句：逐步熟悉名词从句、定语从句、状语从句，融会贯通强调句、虚拟语气、倒装结构、直接和间接引语等语言现象。</p><p><strong>第三，词汇靠积累。</strong><br>词汇需要在生动活泼的文章和例句中去领悟，没有上下文、不了解词汇用法的单词记忆是非常低效的。</p><p>《刻意练习》里面写到，所谓“刻意练习”，不是睡觉前戴上耳机听五分钟英语催眠的那种练习，也不是在地铁里有一搭没一搭听一段或者看一篇文章那种练习，而是有目的的专门训练。练习时需要专注，需要有教练指导，需要有及时的反馈系统，需要离开“舒适区”去挑战自己的极限，当然也需要长时间的训练。</p><h2 id="背景知识对于理解文章究竟有多重要"><a href="#背景知识对于理解文章究竟有多重要" class="headerlink" title="背景知识对于理解文章究竟有多重要"></a>背景知识对于理解文章究竟有多重要</h2><p>我们常说，一个好的文章标题往往有“画龙点睛”的效果，所以作者常常会绞尽脑汁想一个好标题来吸引读者的关注。作为读者，我们也要善于抓住这个特点，从标题的关键词中来了解一些背景知识，窥测作者想要表达的重心，以此来预判文章的内容。</p><p>宋朝诗人陆游晚年时曾对其子谈及写诗经验时强调，“汝果欲学诗，工夫在诗外”（《剑南诗稿》），说的就是这个道理。这和任正非经常要求华为高层要有“宽文化背景”，要“大杂烩”，要善于“用一杯咖啡吸收宇宙能量”，其实都是一样的意思。因此，我们学英语绝非学习语言本身，在兴趣和好奇心的驱使下，广泛涉猎五花八门的百科知识，然后通过相同话题的外语“平行文本（parallel text）”的阅读或视听，来进行语言学习，是事半功倍的好方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;英语学习&quot;&gt;&lt;a href=&quot;#英语学习&quot; class=&quot;headerlink&quot; title=&quot;英语学习&quot;&gt;&lt;/a&gt;英语学习&lt;/h1&gt;&lt;p&gt;多数人在用学习“知识”的方法来学习英语，可英语实际上是一种特殊的“技能”，而非“知识”。语言，从本质上讲是一种技能，一种需要</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>边缘计算</title>
    <link href="http://example.com/p/7beec643.html"/>
    <id>http://example.com/p/7beec643.html</id>
    <published>2024-03-02T06:25:21.070Z</published>
    <updated>2024-07-10T02:27:46.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h1><p>说到“边缘”二字，跟“中央”的意思相反，暗含着“等级低”，“不重要”，“靠边站”的意味。既然如此，大搞“中央计算”就行了，还研究什么“边缘计算”？其实，在信息网络中，“中央”和“边缘”的地位跟我们直观的认知是相反的。中央存在的价值，就是更好地为边缘服务。<br>边缘计算最常用的比喻就是章鱼的神经系统。它的大脑作为中央节点只处理40%的信息，主要负责总体协同，剩余的60%的信息则由8条触手（相当于边缘节点）就近处理。</p><h2 id="算力网络"><a href="#算力网络" class="headerlink" title="算力网络"></a>算力网络</h2><p>数据经济的发展将推动海量数据产生，数据处理需要云、边、端协同的强大算力和广泛覆盖的网络连接。算力网络就是一种在云、边、端之间按需分配和灵活调度计算资源、存储资源以及网络资源的新型信息基础设施。</p><ul><li>云：指的是云计算的数据中心。云计算是一种基于网络“云”的超级计算模式，在远程的数据中心里，成千上万台计算机和服务器联结成一片计算云。各行各业、个人，都通过网络接入云计算数据中心，按自己的需求进行数据存储和数据计算。云计算按部署类型可以分为公有云、私有云（如通信云）和混合云，不同的云对应的是不同的用户群体。</li><li>边：指的是多接入边缘计算，边缘算力的形式也可以是“云”，即所谓的区域云、边缘云。</li><li>网：云端和边缘，以及边缘和用户之间的网络，默默无闻但非常重要的底层工作者。</li><li>端：也就是终端，是云，边，网服务的对象，包含手机，平板，电视等一切可以联网的设备，其位置在网络的最外围，是各种数据的消费者，也成了内容的生产者（如短视频，直播等）。</li></ul><p>因为算力出现云、边、端三级算力架构的泛在演进趋势，算力的分布将不再集中在数据中心，而是广泛地分布在边缘或者端侧的任何位置。如果所有的这些算力节点之间，没有通过网络互连，这些算力资源是没有办法被共享、被调度、被使用、被协同的。实现云、边、端算力的高效调度，需要算力网络。算力网络就是一种根据业务需求，在云、边、端之间按需分配和灵活调度计算资源、存储资源以及网络资源的新型信息基础设施。算力网络的本质是一种算力资源服务<br>算力网络就像是一台“超级计算机”，先汇集了全网的算力，再用“脑”把数据合理地分配到“超级计算机”的每个计算单元中。算力网络的目标很明确，让用户在调用成百上千公里以外的计算资源时的体验与调用隔壁工作站的资源没什么区别。所以，对于算力网络来说，一张具有超大带宽、超低时延、海量连接、多业务承载的高品质网络是关键。</p><p>算力网络曾经出现CAN（算力感知网络，Computing-aware Network）、CFN（算力网络，Computing First Network or Computing Force Network）、CFN（计算优先网络，Computing First Network）、CPN（算力网络，Computing Power Network）等类似的不同叫法。</p><h2 id="MEC"><a href="#MEC" class="headerlink" title="MEC"></a>MEC</h2><p>在移动网络下的边缘计算，也就理所当然地被称作“移动边缘计算（Mobile Edge Computing）”，缩写作MEC。2014年，欧洲电信标准协会（ETSI）正式定义了MEC的基本概念并成立了MEC规范工作组，开始启动相关标准化工作。2016年，ETSI把MEC的概念扩展为Muti-access Edge Computing，意为“多接入边缘计算”，并将移动蜂窝网络中的边缘计算应用推广至像Wi-Fi这样的其他无线接入方式。<br>目前，MEC已经发展演进为5G移动通信系统的重要技术之一。要理解MEC，首先需要了解MEC中涉及到的4个基本概念：云，边，网，端。</p><p>如果还用章鱼来比喻的话，“云”就像大脑，“边”就像触手，“网”就像连接大脑和触手的肌肉，“端”则就是章鱼要捕获的食物。云边网端协同，构成了MEC系统的有机体，让信息更快更好地得以流动。</p><p>在MEC的支持下，云端算力下沉，终端算力上移，从而在边缘计算节点形成兼顾时延，成本和算力的汇聚点，这就是MEC存在的核心价值。</p><h2 id="Dyncast"><a href="#Dyncast" class="headerlink" title="Dyncast"></a>Dyncast</h2><p>当前的边缘计算部署还存在以下问题：</p><p>无法感知服务的算力资源信息；<br>相对静态的边缘节点选择，例如，选择最近的节点或者服务资源最多的节点等；<br>网络和算力分离，例如，我们将一个服务分配到最近的边缘节点，但是此时网络发生了拥塞，导致服务产生延时。如果在分配之初就能将网络路径的问题考虑进来，就可以分配到稍远且能满足需求的边缘节点上。<br>一种基于 Dyncast（Dynamic Anycast）的架构被提出使得任务能够被调度到 “最佳” 的边缘服务节点，这种架构在调度任务的时候会同时考虑网络状态和算力资源。</p><h2 id="ns-3"><a href="#ns-3" class="headerlink" title="ns-3"></a>ns-3</h2><h3 id="ns3对网络组件的抽象节点-Node"><a href="#ns3对网络组件的抽象节点-Node" class="headerlink" title="ns3对网络组件的抽象节点:Node"></a>ns3对网络组件的抽象节点:Node</h3><p>ns-3将基本的计算设备抽象为Node(具体表现为C++的Node类)<br>Node类提供了很多方法来模拟计算设备在计算机网络中的行为。<br>Node的概念对应于host,end system…<br>把Node看成一台计算机，需要向计算机内添加软硬件功能部件:应用程序，协议栈，计算机外设等。</p><h3 id="应用程序-Application"><a href="#应用程序-Application" class="headerlink" title="应用程序:Application"></a>应用程序:Application</h3><p>应用程序Application是运行在Node内部的用户软件。<br>ns-3中有很多Application类的子类:</p><ul><li>UdbEchoClientApplication</li><li>UdbEchoServerApplication</li></ul><h3 id="信道-Channel"><a href="#信道-Channel" class="headerlink" title="信道:Channel"></a>信道:Channel</h3><p>信道Channel:数据传输的通道，有线、无线….</p><ul><li>现实世界:网卡&lt;——&gt;双绞线</li><li>模拟世界:Node &lt;——&gt; Channel</li></ul><blockquote><p>the basic communication subnetwork abstraction is called the channel and is  represented in C++ by the class Channel</p></blockquote><p>Channel类提供相应的方法来管理通信子网对象，将节点连接到通信子网中。</p><ul><li>A Channel specialization may model something as simple as a wire.</li><li>The specializedjChannel can also model things as complicated as a large Ethernet switch,以太网交换机</li><li>or three-dimensional space full of obstructions in the case of wireless networks.无线网络中充满障碍的三维空间。</li></ul><p>常见的Channel:</p><ul><li>CsmaChannel:可以建模实现csma(carrier sense multiple access)的通信子网</li><li>PointToPointChannel</li><li>wifichannel</li></ul><h3 id="网络设备-Net-Device"><a href="#网络设备-Net-Device" class="headerlink" title="网络设备:Net Device"></a>网络设备:Net Device</h3><p>ns-3中net device抽象包括两个部分:</p><ul><li>software driver:设备驱动程序</li><li>simulated hardware:仿真硬件</li></ul><p>net device被安装到Node中，使当前Node能够和其他Node构建网络(借助Channel)<br>Just as in a real computer, a Node may be connected to more than one Channel via multiple NetDevices.</p><h3 id="拓扑辅助类-Topology-Helpers"><a href="#拓扑辅助类-Topology-Helpers" class="headerlink" title="拓扑辅助类:Topology Helpers"></a>拓扑辅助类:Topology Helpers</h3><p>为什么需要Helpers类?<br>核心:简化网络拓扑配置，将那些机械的重复性的配置操作用Helper实现!</p><pre><code>In a large simulated network you will need to arrange many connections betweenNodes, NetDevices and ChannelsSince connecting NetDevices to Nodes,NetDevices to Channels, assigning IP addresses, etc., are such commontasks in ns-3, we provide what we call topology helpers to make this as easy as possible.For example, it may take    many distinct ns-3 core operations to create a NetDevice, add a MAC address, install that net device on a Node,configure the node&#39;s protocol stack, and then connect the NetDevice to a Channel.Even more operations would berequired to connect multiple devices onto multipoint channels and then to connect individual networks together intointernetworks.We provide topology helper objects that combine those many distinct operations into an easy to usemodel for your convenience.</code></pre><p>Helpers示例(在官方文档的类索引中搜索He1per ):</p><ul><li>PointToPointHelper</li><li>lnternetStackHelper</li><li>lpv4AddressHelper </li><li>UdpEchoServerHelper</li><li>UdpEchoClientHelper</li></ul><h2 id="相关类总结"><a href="#相关类总结" class="headerlink" title="相关类总结"></a>相关类总结</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><a href="https://www.nsnam.org/docs/release/3.33/doxygen/classns3">https://www.nsnam.org/docs/release/3.33/doxygen/classns3</a> 1 1 node.html#detailsThis class holds together:<br>. a list of NetDevice objects which represent the network interfaces of this node which are connected to other Nodeinstances through Channel instances.<br>·a list of Application objects which represent the userspace traffic generation applications which interact with the Nodethrough the Socket API.<br> a node ld: a unique per-node identifier.<br>o a system ld: a unique ld used for parallel simulations.Every Node created is added to the NodeList automatically.NodeContainer<br>https:l&#x2F;<a href="http://www.nsnam.org/docs/release/3.33/doxygen/classns3">www.nsnam.org/docs/release/3.33/doxygen/classns3</a> 1 1 node container.htmIl#detailskeep track of a set of node pointers.<br>cu<br>Typically ns-3 helpers operate on more than one node at a time.For example a device helper may want to install devices ona large number of similar nodes. The helper Install methods usually take a NodeContainer as a parameter. NodeContainershold the multiple Ptr<Node> which are used to refer to the nodes.<br>Definition at line 38 of file node-container.h.</Node></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;边缘计算&quot;&gt;&lt;a href=&quot;#边缘计算&quot; class=&quot;headerlink&quot; title=&quot;边缘计算&quot;&gt;&lt;/a&gt;边缘计算&lt;/h1&gt;&lt;p&gt;说到“边缘”二字，跟“中央”的意思相反，暗含着“等级低”，“不重要”，“靠边站”的意味。既然如此，大搞“中央计算”就行了，还</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>人性的弱点</title>
    <link href="http://example.com/p/109e75d5.html"/>
    <id>http://example.com/p/109e75d5.html</id>
    <published>2024-02-21T06:20:11.539Z</published>
    <updated>2024-07-10T02:27:46.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成功的捷径"><a href="#成功的捷径" class="headerlink" title="成功的捷径"></a>成功的捷径</h1><p>你所面临的最大困难可能是如何与人打交道，尤其当你是一位商人时更是如此。当然，如果你是一位家庭 主妇、建筑师或工程师，同样也是如此。几年前由卡内基基金会赞助的一项调查研究，显示了一个最为重要的事实——后来被卡内基技术研究院所做的其他研究证实的事实。这些调查表明，即使在工程技术工作方面，一个人所获得的高额薪水中，大概只有 15% 是因为他的技术知识，而大约 85% 则是因为他的为人处世技巧，也就是他的个人品质和领导才能。经过多年的观察发现，工程师得到报酬最高的，通常不是那些工程学知识最多的人。例如，我们可以以正常的薪水雇用工程、会计、建筑或其他专业方面的技术人才。但是既有技术知识，又善于表达自己内心思想，同时又具备领导才能和激发他人热情的人，往往能获得更高的收入。<br>洛克菲勒在事业达到巅峰的时候，曾这样说：「与人打交道的能力也是一种可以购买的商品，这正如同糖和咖啡一样。我愿意付出比世界上其他任何东西都要高的代价来购买这种能力。」<br>「和我们所应该取得的成就相比，」哈佛大学著名教授威廉·詹姆斯曾这样说道，「我们不过是半醒着。现在我们只利用了我们身心资源的一小部分。从广义上来说，人类生活在自身潜能远远没有开发的狭小天地中。人类具有各种潜能，但却不曾开发和利用。」<br>普林斯顿大学前任校长希本博士也说道：「教育才是应对生活中各种问题的有效手段。」如果你读了本文之后，还感到难以应对生活中的各种情况，那么我认为这本书至少对你来说是完全失败的，因为斯宾塞曾说「教育的伟大目的，不是知识，而是行动」。</p><h1 id="人际交往的基本技巧"><a href="#人际交往的基本技巧" class="headerlink" title="人际交往的基本技巧"></a>人际交往的基本技巧</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;成功的捷径&quot;&gt;&lt;a href=&quot;#成功的捷径&quot; class=&quot;headerlink&quot; title=&quot;成功的捷径&quot;&gt;&lt;/a&gt;成功的捷径&lt;/h1&gt;&lt;p&gt;你所面临的最大困难可能是如何与人打交道，尤其当你是一位商人时更是如此。当然，如果你是一位家庭 主妇、建筑师或工程师，</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>怎么让别人喜欢你</title>
    <link href="http://example.com/p/b31106bd.html"/>
    <id>http://example.com/p/b31106bd.html</id>
    <published>2024-01-25T03:39:45.485Z</published>
    <updated>2024-09-27T13:18:18.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么让别人喜欢你"><a href="#怎么让别人喜欢你" class="headerlink" title="怎么让别人喜欢你"></a>怎么让别人喜欢你</h1><p>● 不要批评、责怪或抱怨。<br>● 献出你真实、诚恳的赞赏。<br>● 引起别人的渴望。</p><h2 id="不要批评、指责或抱怨"><a href="#不要批评、指责或抱怨" class="headerlink" title="不要批评、指责或抱怨"></a>不要批评、指责或抱怨</h2><p><strong>批评就像家鸽，总会飞回来的</strong>。我们想矫正或谴责的人，也会为自己辩护而反过来谴责我们。如果你以后想激起别人对你十年乃至一生的怨恨，只要对他批评得刻薄一些就可以了。<br>已故的华纳梅格这样说过：「三十年前我就明白，责备别人是件愚蠢的事。我不抱怨上帝没有均匀分配智能，可是对克制自己的缺陷，我感到非常吃力。」<br>华纳梅格很早就悟出了这一点，可是我在这古老的世界上却盲目行走了二十多年还没有领悟。一百次中有九十九次，不管事情错到怎样的程度，都没有人会为此自我批评。批评没有任何作用，只会让人提高警惕并竭力为自己辩护。批评也是危险的，它会伤害人的自尊，甚至激起那个人的反抗。<br>在德国，军队里的士兵们在发生冲突后，不准立即申诉，而要怀着满腔怨气去睡觉，直到这股怨气消失，否则会受到处罚。在我们日常生活中，这个规矩似乎也很必要——就像唠叨埋怨的父母、喋喋不休的妻子、斥责怒骂的老板，以及其他一些吹毛求疵、令人讨厌的人。<br>从上千页的历史书中，你可以找出很多很多「批评无效」的例子。罗斯福和塔夫脱总统那著名的争论，分裂了共和党，令威尔逊入主白宫，使他在世界大战中留下了勇敢、光荣的一页，并且改变了历史趋势。</p><pre><code>1908 年，西奥多·罗斯福离开白宫时，他使塔夫脱做了总统，自己则去非洲狩猎狮子。而在他回来时，争执就此发生。他指责塔夫脱守旧，组织勃尔摩斯党，想要自己连任第三任总统。这个举动几乎毁灭了共和党，就在那次选举中，塔夫脱领导下的共和党只获得佛蒙特和犹他两州的选票——这是共和党历史上最大的一次失败。罗斯福责备塔夫脱，可是塔夫脱有没有自我批评？当然没有。塔夫脱两眼含泪说：「我不知道自己哪里做得不对。」究竟是谁的错？我不知道，也不关心。不过我要指出的是，罗斯福的批评并没有让塔夫脱意识到自己的错误，却让他为自己竭力辩护，含泪反复说：「我不知道自己哪里做得不对。」</code></pre><p><strong>批评就像家鸽，总会飞回来的</strong>。我们应该知道，我们想矫正或谴责的人，也会为自己辩护而反过来谴责我们。即使像塔夫脱那样温和的人，也只会这样说：「我不知道自己哪里做得不对。」</p><p>1865 年 4 月 15 日，那个星期六的早晨，林肯奄奄一息地躺在福特戏院对面一家简陋的公寓中。他瘦高的身体斜躺在床上，床的上面挂着一幅罗莎波南名画《马市》的复制品，一盏煤油灯闪着昏暗惨淡的光。林肯即将去世的时候，陆军部长斯坦顿说：「躺在那里的是世界上最完美的元首。」<br>林肯也曾批评过别人？不错，还在印第安纳州鸽溪谷时，年轻的林肯不但会批评，还会写信作诗去讥笑别人。他把写好的东西扔到当事人肯定能捡到的路上，其中一封信甚至引起了别人对他的终身厌恶。林肯在伊利诺伊州挂牌做了律师后，还在报纸上公开发表文章攻击对手，但是这样的事他只做了一次。<br>1842 年秋，林肯在春田的报纸上发表一封匿名信，讥笑爱尔兰政客西尔兹自大好斗，使全镇的人都哄然大笑。敏感自傲的西尔兹被这件事激怒，在查出是林肯写的这封信后，跳上马便去找林肯决斗。<br>林肯平生不喜欢打架，更反对决斗，但此时为了面子却不能退缩。西尔兹让他自己挑选武器，林肯臂长，便选用了马队用的大刀，而且以前他曾和一位西点学校毕业生学习过刀战。<br>到了指定日期，他和西尔兹在密西西比河的河滩上准备一决生死。这场决斗直到最后一分钟才被双方助斗者阻止。<br>那次经历对林肯来讲，是最惊心动魄的一次，对他以后的处世方式是个极其宝贵的教训。此后，林肯再也不写信凌辱他人，再也不讥笑他人，甚至几乎从不为任何事而批评任何人。<br>内战期间，林肯屡次任命新将领统率波多马克军团，可是每次都遭遇惨痛失败，这曾使林肯怀着失望而沉重的心情，独自一人在屋子里踱步。全国几乎半数人都在指责这些不能胜任的将军，只有林肯保持着一贯的平和——他最喜欢的一条格言是：「不要评议人，免得为人所评议。」<br>当林肯的妻子和别人批评南方人时，林肯总是这样说：「不要批评他们，我们在相同情形下也会和他们一样。」</p><p>但是，林肯是有机会批评的，我们看下面这个例证：</p><p>1863 年 7 月初，盖茨堡战役打响了，到 7 月 4 日晚，南方军队在罗伯特·李的指挥下开始后撤。当时全国雨水泛滥，当李带领败军到达波多马克河时，被面前暴涨的河水阻挡，而乘胜追来的联军就在后面。李和他的军队一时间进退维谷，无处脱身。<br>林肯知道这是个天赐良机，只要一举歼灭李的军队，便可立即结束战争。林肯满怀希望命令格兰特不要召开军事会议，要立即发起进攻。林肯先发电报，然后又派出特使要格兰特马上采取行动。<br>可这位将军是怎么处理的呢？格兰特采取了跟林肯命令完全相反的行动。他违反命令召开军事会议不算，还迟疑不决地延宕下去。格兰特在复电中利用各种借口拒绝进攻李的军队。<br>最后河水退却，李带领军队顺利逃过波多马克河。<br>「格兰特为什么要这么做？」林肯知道这件事后勃然大怒，对着儿子罗伯特大声说，「老天爷，这是什么意思？敌军已在我们掌握之中，唾手可得，彼时无论谁都能带兵击败他们，如果是我自己去，早已经把他捉住了。」<br>沉痛失望之余，林肯提笔向格兰特写了封信——在林肯一生中的这段时间，他在为人处世方面极端保守，用字非常谨慎，所以 1863 年的这封出自林肯之手的信，该是他最严厉的斥责了。这封信是这样的：</p><pre><code>「亲爱的将军：我想你可能领会不出由于李的逃脱而引起的不幸是多么严重。那时他被我们轻易掌握，如果能将他及时捕获，再加上我们最近获得的其他胜利，当下便可以结束这场战争。可是照现在的情形来推断，战事将会无限期地延长下去。上星期一你没有顺利攻击李的军队，以后你又哪里会有这样的机会？我没有期待你现在会取得多大成功，因为你已经放过了黄金般的机会，这使我感到无比沉痛。」</code></pre><p>事实上，格兰特却始终没有看到这封信，因为林肯根本没有寄出去。信是在林肯去世后从他遗留的文件中发现的。猜想林肯在写完信后，望着窗外喃喃自语：</p><pre><code>「且慢，也许我不该这样匆忙。在宁静的白宫里向格兰特命令进攻是轻而易举的，可如果我也在盖茨堡看到遍地血腥、听到战场上的哀号和呻吟，如果我也和格兰特一样懦弱，也许我也不会急于向李的军队进攻。木已成舟，事情已经无法挽回，这封信不过是发泄一时不快，而格兰特也会为自己辩解。那时，他会谴责我、反感我，并且这也会损害他作为司令官的威信，甚至会迫使他辞职。」</code></pre><p>林肯从痛苦的经验中知道，尖锐的批评与斥责是永远不会有效果的。<br>西奥多·罗斯福总统曾说，他在总统任期中遇到棘手的问题时，会靠在座椅上仰起头，朝墙上林肯的巨幅画像看去，然后问自己：「如果林肯处在眼前的情形，他会怎么做，怎样解决这个问题？」</p><p>你希望你所认识的人改变、进步吗？当然，如果可以的话最好不过了。可为什么不从你自身开始调整呢？自私地说，<strong>改进自己比改进别人获益更多</strong>。鲍宁曾说：「当一个人与自己争论、激辩时，他在很多方面已是不寻常的。」如果你想激起别人对你的怨恨，让他痛恨你十年甚至一生，那么只要批评他刻薄一些就可以了。<strong>请记住，我们所要应付的人，不是理论的动物，而是感情的动物。</strong></p><p>批评是通向危险的导火线，一种能引爆「自尊」这个火药库的导火线。这种爆炸，有时会置人于死地。人们的批评和一条不准带兵到法国的禁令使胡特将军几乎缩短了寿命；苛刻的批评使敏锐的英国作家托马斯·哈代永远放弃写小说。富兰克林年轻时并不比别人伶俐，可是后来待人处世却极有手腕和技巧，甚至担任美国驻法大使。他的成功秘诀就是「不说任何人的不好」，并且「说我所知道的每一个人的好处」。即使愚蠢的人也会批评、斥责和抱怨，同时多数时间也是愚蠢的人才会这样做。但若要宽恕、理解别人，则需要在人格、克己方面下工夫了。<br>托马斯·卡莱尔曾说：「一个伟大的人，以如何对待卑微者来显示自己的伟大。」正如强森博士所说：「在末日之前，上帝还不打算审判人！」<br>因此，不要批评、责怪或抱怨。</p><h2 id="坦诚、直率地赞赏他人"><a href="#坦诚、直率地赞赏他人" class="headerlink" title="坦诚、直率地赞赏他人"></a>坦诚、直率地赞赏他人</h2><p>能让人自愿去做任何一件事的办法，就是真诚地赞赏他人。多研究别人的优点，忘掉恭维、谄媚的话语，给人以由衷、诚恳的赞赏。<br>世间只有一个办法能让人自愿去做任何一件你希望他做的事。那办法是什么，你是否静下心来想过？确实，只有这个办法才行得通，除此以外再也没有其他方法。那就是把你需要的给你。<br>当然，你可以拿一支左轮手枪对着一个人的胸膛，他自会乖乖地把手表给你。你也可以用恫吓解雇的方法命令下属做事，甚至鞭打或恫吓让一个孩子做你要他做的事。但这些粗笨的方法都会引起不良反应。<br>20 世纪维也纳最享盛誉的心理学家弗洛伊德认为，<strong>人们所做的事都来源于两种动机，即性冲动和成为伟人的欲望</strong>。美国著名哲学家杜威教授的见解稍有不同，他说人类天性中最深切的冲动，是「<strong>成为重要人物的欲望</strong>」。<br>你需要的也许并不多，可有些你会不容拒绝地不懈追求。每个正常的成年人，差不多都想要这些：一、健康和生命的保障；二、食物的供给；三、充足的睡眠；四、金钱和金钱所能买到的一切；五、生命的后顾；六、性生活的满足；七、子女的健全；八、自重感。所有这些几乎都可以满足，可是其中有一种欲望跨越了食物、睡眠等，既深切又难以满足，那就是弗洛伊德所说的「成为伟人的欲望」，也就是上面那句「成为重要人物的欲望」。<br>林肯有封信的开头就说：「每个人都喜欢被恭维。」威利·詹姆斯也说过：「人类天性中最深的本质，就是渴求被人重视。」注意那并不是「希望」「欲望」或者「渴望」，而是说「渴求」，被别人重视。这是人类痛苦而亟待解决的别样「饥饿」，如果能真正满足人们的这种渴求，就可以掌握他们。<br>假如我们的祖先没有追求自重感的强烈冲动，我们就不会有文化流传，也就和其他动物没什么区别了。自重感的欲望曾激起一个贫困的杂货店店员发奋读书——他没有受过良好的教育，但在自重感的驱使下，他从堆满杂货的大木桶中找出了五毛钱，买来法律书籍刻苦研读。你也许听说过这个店员，他叫林肯。<br>同样是自重感的欲望，激发狄更斯写出不朽名著，令华伦完成他的伟大设计，让洛克菲勒积攒了一辈子都花不完的钱。这个欲望能让富翁花费巨资建造豪宅；能让你穿上最新潮流的服装，驾驶最豪华的轿车，谈论你那聪明伶俐的孩子。可也就是这种欲望，让许多青少年沦为了盗匪。纽约警察总监马罗南曾提起过这样一件事，许多年轻罪犯盲目追求虚荣，他们在被捕后的第一个要求就是要看那些把他们写成英雄的小报，并为自己的照片能跟科学家、政治家、影视明星同样占去许多版面而高兴，至于进受刑室坐电椅，则好像是另外一回事。<br>洛克菲勒在中国北京投资建造现代医院，照顾许多他不曾见面也永远不会见面的贫民，由此获得他的自重感。反之，狄林克以抢银行、杀人来满足自己的欲望，直到被警方逮捕，逃入农舍里的他仍自豪地大声叫道：「我是狄林克！我不会杀害你，但我是狄林克！」对他来说，「人民公敌」就是一项「荣誉」。<br>历史上有许多趣事，都源于名人对自重感的追求。拒绝第三次连任的华盛顿，并不拒绝被称为至高无上的美国总统；哥伦布向皇家请求授予海洋上将和印度总督的头衔；女皇凯瑟琳从不拆阅没有「女皇陛下」称呼的信件；而林肯夫人在白宫也当了一回「母老虎」，她向格兰特夫人吼道：「在我没请你之前，你怎敢坐在我面前！」1928 年，伯德将军去南极探险时得到了一些百万富翁的资助，但要满足他们的附带条件，即用他们的名字命名那些冰山。维克多·雨果希望把巴黎改为他的名字，就连莎士比亚也想获得徽章为自己的名字增辉。有时人们故意装病来获得别人的同情和注意，变相满足自重感。麦金莱夫人就强迫她丈夫，放下作为美国总统而要处理的许多国家重要事务，几个小时地依偎在自己床边，直到她睡着，由此获得自重感。此外，她还坚持要麦金莱陪她一起看牙医，目的是她医牙疼痛时被丈夫注意。有一次麦金莱因和国务卿海·约翰有约，不得不留她一个人在牙医处，这位夫人便大发脾气。</p><p>一些专家宣称，为了在幻境中得到现实世界中得不到的自重感，人甚至会发疯。有许多别的疾病会伤害脑细胞，从而导致癫狂。事实上，约有半数以上的精神病可以归源于这类的病因。可是，另外那一半患者呢？那令人惶恐的半数，患者的脑细胞却没有任何病态——在这一类患者去世后，通过解剖，在最高性能的显微镜下发现，其脑细胞组织完全跟我们一样健全。许多精神病人，在疯癫中找到了现实世界所无法获得的自重感。</p><pre><code>一个女患者遭遇了婚姻的悲剧，她向往爱情、孩子和一定的社会地位及声望，可是现实却没有满足她的幻想。她丈夫不爱她，甚至不愿跟她一起用餐，还强迫她服侍自己在楼上房间吃饭。她没有孩子，没有社会地位，终于精神错乱。现在，在她的幻想中已和她丈夫离婚，并恢复了少女时的姓名。她现在相信自己已嫁给一位英国贵族，因此坚持要人家称她是史密斯夫人。当然，孩子在她的幻想中也有了。她每次会对去为她诊病的医生说她前一晚生了一个孩子。</code></pre><p>整体说来，精神失常的人似乎比你我都更快乐。既然疯狂能带来快乐，那么为什么不呢？神精病人已经解决了他们曾经的问题。他们现在可以轻而易举地签张百万元的支票给你，或者给你一封介绍信去见一位名人。在幻境中，他们找到了期望已久的自重感。如果人们对自重感真能迫切渴望到精神失常的地步，那么，试想在他尚未疯狂前就给他真诚的赞扬，会产生怎样的奇迹……</p><p>施瓦布又说：「在我一生的阅历和阅人中，无论谁，不管他如何伟大、地位如何崇高，无不是赞许比批评更能成就其伟大事业。」真诚的赞赏也是洛克菲勒待人成功的一条秘诀。当他的伙伴贝德福德在南美搞砸了一桩买卖而使公司亏损一百万时，洛克菲勒没有任何批评或指责。他知道贝德福德已尽了最大努力，何况这件事已经结束了，所以他真诚地恭贺贝德福德，说他幸而保住了百分之六十的投资。洛克菲勒说：「这已经不错了，我们不可能每件事都能称心如意。」</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么让别人喜欢你&quot;&gt;&lt;a href=&quot;#怎么让别人喜欢你&quot; class=&quot;headerlink&quot; title=&quot;怎么让别人喜欢你&quot;&gt;&lt;/a&gt;怎么让别人喜欢你&lt;/h1&gt;&lt;p&gt;● 不要批评、责怪或抱怨。&lt;br&gt;● 献出你真实、诚恳的赞赏。&lt;br&gt;● 引起别人的渴望。&lt;</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>经典话术</title>
    <link href="http://example.com/p/2524b632.html"/>
    <id>http://example.com/p/2524b632.html</id>
    <published>2024-01-24T12:33:55.988Z</published>
    <updated>2024-10-01T05:21:05.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典话术"><a href="#经典话术" class="headerlink" title="经典话术"></a>经典话术</h1><h2 id="终结尬聊！巧用「诡辩」，成为一个幽默的人"><a href="#终结尬聊！巧用「诡辩」，成为一个幽默的人" class="headerlink" title="终结尬聊！巧用「诡辩」，成为一个幽默的人"></a>终结尬聊！巧用「诡辩」，成为一个幽默的人</h2><pre><code>在年次公司聚餐，上门口碰见新部门经理，同行和的打趣说：经理怎么不学开车啊，还打出租车在路上跑一跑呢！ 经理下车拍他肩膀一下，反问：我不在路上路一跑，我还在天上飞啊？！ </code></pre><p>你是不是觉得经理很幽默?我也觉得他很幽默，但这种幽默其实是不合逻辑的，是经理从「偷换」了概念。同事提问的点在于「为什么不开车」，他却抓住了「路上跑」这个点，巧妙地把话题转移到「不路上跑还天上飞吗?」如果他当时回答:嗨，今天尾号限行，我也不想打车，那这段对话顿时索然无味了。</p><h2 id="让你升职加薪比别的快和-SCQA-模型"><a href="#让你升职加薪比别的快和-SCQA-模型" class="headerlink" title="让你升职加薪比别的快和 SCQA 模型"></a>让你升职加薪比别的快和 SCQA 模型</h2><p>这个模型其实就是一个「结构化表达」模型，它包含4个层次:<br>S (Situation)情景——由大家都熟悉的情景、事实引入。<br>C (Complication)冲突——实际情况往往和我们的要求有冲突。<br>Q (Question)疑问——怎么办?<br>A (Answer)回答——我们的解决方案是?<br>想讲一个好故事，SCQA个都不能少，但学长觉得，这个模型最适合普通人利用的，还是在和上级领导的对话当中。比如和老板汇报工作，最招白眼的说法就是:老板我们的产品卖不出去了。只有结果，说原因了么?给解决方案了么?啥都没有，给你个白眼都多的。</p><p>利用SCQA模型，就可以把这件事描述成:</p><pre><code>老板，最近隔壁改变了新品的上市时间(阐述背景)，我们的新品正好和他们的撞上了，销售额预期会下滑20%(和要求有冲突)，我们准备联系线上的销售渠道（怎么办），把一部分线下销售放到线上，结合电商活动能把营业额追回来，还可以增强网络影响力(解决方案)。</code></pre><p>SCQA 模型有头有尾、有前因有后果，最方便老板理解和做决策。长期锻炼这种沟通话术，老板肯定会认为你是一个条理清晰、逻辑思维能力强的好苗子!</p><h2 id="让对方服从你意识的神奇提问法"><a href="#让对方服从你意识的神奇提问法" class="headerlink" title="让对方服从你意识的神奇提问法"></a>让对方服从你意识的神奇提问法</h2><p>如果你去商场，看见一家咖啡厅想进去坐坐，店员问:您好，您想喝雪顶咖啡还是手冲咖啡?那么你大概率会首先考虑他的提议。<br>还有，女朋友想吃炸鸡，但你还在犹豫，这时女朋友问你:吃原味的炸鸡还是韩式辣酱的?这时你的脑子就会不听使唤的已经在两个口味中做选择了。<br>封闭式提问，本身就已经带有了预设的答案。比如女朋友就要吃炸鸡，你的选择权只能选口味。<br>带有预设的提问，就像已经画好了圈，无论对方回答什么，都是你想要的答案。<br>是非题让人思考「Yes or no」;选择题让人思考「Which one is better」，相当于先帮对方回答了「Yes」。<br>这个话术其实还涉及了心理学知识，有引导回答的作用，FBI经常用它来测谎，比如:</p><pre><code>警察:你妻子身亡时身旁的那辆红色车是谁的?犯人:我不清楚，那辆卡车我从没见到过。警察:我好像没说那是辆卡车。</code></pre><h2 id="可以用50年的自我介绍公式"><a href="#可以用50年的自我介绍公式" class="headerlink" title="可以用50年的自我介绍公式"></a>可以用50年的自我介绍公式</h2><p>自我介绍这件事很难吗?不难，但好多人也不会。<br>不信我让你现在做一个自我介绍，你会怎么讲?<br>「你好，我叫XXX，毕业于XXX学校，在XXX就职。。。。。。」<br>相信大多数人的自我介绍都是这样:沉闷、毫无生气，像人口普查。<br>今天学长给你分享一个巨好用的自我介绍公式，只要学会了，练会了，什么场合都能做出一个漂亮让人印象深刻的自我介绍。<br>自我介绍结构组成&#x3D;①我是谁+②跟你有什么关系+③对你有什么用<br>这么说可能太抽象了，我随便编一个面试自我介绍你听听:</p><pre><code>你好，我叫XXX，从事电商运营工作。(我是谁)我了解过贵公司信息，贵公司的主打产品都是服装品类，我之前也是运营服装品类店铺的，很对口(和你有什么关系)如果有幸能加入贵公司，我会利用之前的经验，为贵公司的店铺创造更多的引流和转化，创造更多的业绩（对你有什么用）</code></pre><h2 id="用「基础模型」，1秒抓住对方注意力"><a href="#用「基础模型」，1秒抓住对方注意力" class="headerlink" title="用「基础模型」，1秒抓住对方注意力"></a>用「基础模型」，1秒抓住对方注意力</h2><p>注意力是极其有限的资源，想要让别人认真听自己说话、迅速理解自己的意思，就要掌握「基础模型」。<br>什么是「基础模型」呢?我们对一个陌生事物的认识，始于「大致归类」，而非「精准描述」。</p><pre><code>向同事讲解策划思路，可以说:这次的活动类似大家熟知的XXXX活动，主要的差异在于XXXXX。</code></pre><p>人偏向自己熟悉的事物，在灌输新观念前，想想别人已经有哪些「旧观念」，更容易让大家「秒懂」你的意思。</p><h2 id="掌握WIIFM原则，谁都愿意帮你"><a href="#掌握WIIFM原则，谁都愿意帮你" class="headerlink" title="掌握WIIFM原则，谁都愿意帮你"></a>掌握WIIFM原则，谁都愿意帮你</h2><p>前段时间华为的一个员工火了，他叫陈盈霖。这个华为云的销售，用一封看似「毫无目的」的邮件，说服罗振宇把合作多年的服务商阿里云，换成了华为云。<br>陈盈霖在短短百字的邮件中主要说了4件事:</p><pre><code>①我们为得到的企业知识服务谨慎挑选了一个客户，只要得到愿意，500万的订单立马可以签约。②这个合作，和是否选择华为云合作一点关系都没有，请罗振宇不要有压力。③华为云的总裁和副总裁，一直都是得到的用户，他们非常关心得到和华为云的合作进展。④我们华为云做事，不是要赚客户的钱，而是要帮客户赚钱。</code></pre><p>罗振宇坦言，看完这封邮件，所有的顾虑都一扫而空，好像只有签约这一条路了。</p><p>陈盈霖的成功，就有WIIFM原则(What’s ln lt For Me 的缩写)，指「这关我什么事?」，这个原则的关键在于，如果你能看出对方需要什么，帮他解决，那么你也会得到他的帮助。<br>「处于困境的人，往往只关心自己的问题，但是，解决问题的途径通常在于，你如何解决别人的问题。」<br>当时罗振宇完全愿意与阿里云继续合作，但因为华为云的销售抓住了得到需要企业级客户的点，帮助得到解决了他们的问题，那得到也就愿意帮助这名销售，解决「业绩」难题。</p><h2 id="用「亏欠话术」维系长久关系"><a href="#用「亏欠话术」维系长久关系" class="headerlink" title="用「亏欠话术」维系长久关系"></a>用「亏欠话术」维系长久关系</h2><p>有时候帮了别人一个大忙，对方千恩万谢，我越说「没事，别放在心上」，他就越是诚惶诚恐。其实比起使劲安慰:「真的没事，没关系的」。更好的说法是:「客气什么，下次我有事还要麻烦你呢。」<br>受了别人的恩惠，只能道谢无以为报，会让对方感觉欠了人情或者低人一等。用「下次我也要麻烦你」回应对方的道谢，摆在同等互惠的位置，可以减轻对方的愧疚感和压力。<br>而且世事难料，万一真的有事需要他帮忙，也能更自然的提出了「你看，我就说我以后肯定要麻烦到你吧」。<br>「我们要相互亏欠，不然凭何想念」</p><h2 id="自嘲」的关键，只有3个字"><a href="#自嘲」的关键，只有3个字" class="headerlink" title="自嘲」的关键，只有3个字"></a>自嘲」的关键，只有3个字</h2><p>会自嘲的人，一般更受欢迎。因为这种特殊的幽默感能让对方感受到「优越感」，从而拉近心理距离。<br>是…..而且……<br>「是」，就是承认对方的意思，不管说什么，我先承认你说的是对的，这部分很重要。<br>「而且」，就是接着他的话往下说，比他说的还狠还过分，夸张、曲解、诡辩都可以。</p><pre><code>比如七大姑八大姨问你:怎么现在还没有女朋友啊?你就可以说:是啊，别说女朋友了，在大城市有个朋友都难。朋友八卦:换了新公司,工资翻倍了吧?你就可以说:可不么，从5块变10块，吃方便面终于肯加根肠了。</code></pre><h2 id="RIDE说服原则-说到别人心坎里"><a href="#RIDE说服原则-说到别人心坎里" class="headerlink" title="RIDE说服原则,说到别人心坎里"></a>RIDE说服原则,说到别人心坎里</h2><p>一个人有了决定,想改变它就变得不容易，这时RIDE技巧就能派上用场:</p><ul><li>R( risk)风险:不采纳你的建议会带来什么风险。(人在失去时比获得时更敏感)。</li><li>I ( interest)利益:接受你的建议会带来什么利益（之前降低了心理阈值,现在重新提高)。</li><li>D(differences）差异:你的建议和其他人有什么不同(人人都喜欢独特的东西)。</li><li>E (effect)影响:抛出一个负面缺点(太完美的东西反而不真实,有小缺点更可信)。</li></ul><p>比如劝朋友不要轻易离职:</p><pre><code>(R风险)∶你现在走了，新公司offer也没下来，万一芝麻西瓜都丢了怎么办?(I利益)︰如果你现在稳住,和经理谈一谈，以你之前的表现，没准会给你加薪。(D差异)︰那家公司的业务没有现在的老东家成熟。(E影响)︰也就是晋升慢点，但其他方面都比新公司要好,离你家还近。</code></pre><h2 id="10、一枚硬币，制服对方的优柔寡断"><a href="#10、一枚硬币，制服对方的优柔寡断" class="headerlink" title="10、一枚硬币，制服对方的优柔寡断"></a>10、一枚硬币，制服对方的优柔寡断</h2><p>有些问题单凭自己很难决断，这时就想找别人替自己「做决定」。<br>但建议他选A的时候，他说B的好处,建议选B的时候，他说A其实也不错。<br>这种时候如果你说:「这个问题我来给你好好分析分析，分别列出A和B的优缺点……」_他肯定没耐心听。<br>不如就说:「哎呀真是难题，要不我们抛硬币决定吧!人头就选A,反面就选B!」<br>因为犹豫不决优柔寡断的人，不是没有「决断力」，而是没有「自我说服」。<br>害怕后悔，才会纠结。硬币抛出的那一刻,他的心里就已经有答案了。</p><h2 id="用「万能模板」写最「与众不同」的祝福语"><a href="#用「万能模板」写最「与众不同」的祝福语" class="headerlink" title="用「万能模板」写最「与众不同」的祝福语"></a>用「万能模板」写最「与众不同」的祝福语</h2><p>祝福语结构&#x3D;感+动+你<br>这个结构其实很简单，拆开你瞬间就懂了。<br>感（(感受):今年我们交往过程中你带给我的美好感受。<br>动(行动):祝福对象在这一年中的某个行为。<br>你（(影响)∶对方对你产生的影响或帮助。<br>比如:李总,过节好。今年在您身边受益良多(感)，记得年初时您约我小酌几杯(动)，正是那次对话解开了我一直以来对于职业发展的困惑（你)。祝您新年开春大吉，阖家幸福!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典话术&quot;&gt;&lt;a href=&quot;#经典话术&quot; class=&quot;headerlink&quot; title=&quot;经典话术&quot;&gt;&lt;/a&gt;经典话术&lt;/h1&gt;&lt;h2 id=&quot;终结尬聊！巧用「诡辩」，成为一个幽默的人&quot;&gt;&lt;a href=&quot;#终结尬聊！巧用「诡辩」，成为一个幽默的人&quot; cla</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://example.com/p/4e328d4b.html"/>
    <id>http://example.com/p/4e328d4b.html</id>
    <published>2024-01-22T06:08:21.205Z</published>
    <updated>2024-01-24T14:09:01.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何选择一个有前景的职业方向"><a href="#如何选择一个有前景的职业方向" class="headerlink" title="如何选择一个有前景的职业方向"></a>如何选择一个有前景的职业方向</h1><p>这几年来，一谈到个人发展，所有人都在说“选择大于努力”。在我看来，这句话虽然有一定道理，但也有很强的误导性。对于一个人的职场发展来说，有三件事同样重要，缺一不可，那就是“选择”、“坚持”和“努力”。</p><h2 id="从长期来看，一个好的职业方向是什么样的？"><a href="#从长期来看，一个好的职业方向是什么样的？" class="headerlink" title="从长期来看，一个好的职业方向是什么样的？"></a>从长期来看，一个好的职业方向是什么样的？</h2><p>最近这五年人工智能大热，算法工程师这一职位的薪资水平也水涨船高。于是，大量的在校生转向机器学习的方向，而已经工作三五年的研发工程师们宁愿从零开始，也要投身算法岗的竞争之中。那么，如此火热的算法工程师职位，算是一个好的职业方向吗？<br>一个职业方向好不好，可以从两个维度来判断：从长期来说，要看它的“高度”和“容量”；从短期来说，要看它的“供需关系”。<br>“高度”指的是这个职业方向上最牛的那批程序员能达到的职场高度，也就是我们常说的“职场天花板”。刚才我们说的算法工程师，只从年收入来说，国内可以达到 200 万人民币，美国可以达到 60 万美元（再往上属于凤毛麟角，不具备统计意义）。对于普通人来说，显然是足够高的天花板了。同理，C++ 或者 Java 后端，Android 或者 iOS 的移动端，这些职业方向都具备很高的天花板，而且具备长期的稳定性，未来五年应该都不会有衰落的趋势。所以毫无疑问，它们都是高度足够高并且稳定，值得你去长期耕耘的领域。相对而言，测试工程师、传统的硬件工程师，以及技术栈较老的前端工程师，这些方向的天花板就明显低很多。选择了这些方向，即使你再努力，也很有可能在收入和影响力方面比不上选择前面几个方向的同行。这也就是大家常说的“选择大于努力”。<br>第二个要素“容量”，指的是这个职业方向能够容纳的从业者的数量。上面提到的算法、后端、移动端等方向，它们的从业者容量都是非常大的，这就代表着整个相关行业是繁荣的，跳槽和选择的机会非常多，我们就容易把握住行业中新的发展机会。 但有些方向就差一些，比如前几年非常火的 Scala 工程师。虽然这个方向的收入天花板很高，但这几年的行业容量是稳中有降的。再比如算法岗中的一些方向，比如计算机视觉、语音识别，虽然个别岗位的高度也很高，但整个行业的容量和相关明星企业的兴衰有着密切的联系，波动非常大。从稳定性来说，这些方向就远比不上搜索、广告和推荐领域的算法岗。<br>总之，一个好的职业方向，一定是高度很高，容量很大且稳定的方向。如果你是应届生，或者刚工作几年的初级工程师，一定要好好审视一下自己目前的方向。如果当前的领域“高度”有限，“容量”也很低，长期来看你的职业道路就存在较大的风险。这种情况下，在职业生涯的早期换到一个有前景的赛道，就是非常值得去做的一件事。</p><h2 id="识时务者为俊杰：短期的供需关系同样重要"><a href="#识时务者为俊杰：短期的供需关系同样重要" class="headerlink" title="识时务者为俊杰：短期的供需关系同样重要"></a>识时务者为俊杰：短期的供需关系同样重要</h2><p>在看准了一些有长远发展前景的方向之后，这些方向的短期人才供需关系同样是影响我们选择的重要因素。《三国志》中有一句话“识时务者，在乎俊杰”，就是说要看清楚当前这个时代的趋势，才能成为出色的人物。对于我们程序员来说，在选择职场方向的时候，同样要做到认清趋势，认清自己，避免死磕，这样才能做出最适合自己发展的决定</p><h2 id="选择后的坚持才是影响你收入的第一要素"><a href="#选择后的坚持才是影响你收入的第一要素" class="headerlink" title="选择后的坚持才是影响你收入的第一要素"></a>选择后的坚持才是影响你收入的第一要素</h2><p>在程序员的职业发展过程中，选择固然重要，但真正影响你收入的是选择后的“坚持”和“努力”。选择好的方向可以给你很大的发展空间，但达到预期高度就要靠你长期的积累了。<br>我一直很反对“单纯面向钱编程”的做法：算法岗收入多，就刷大量相关课程，恶补机器学习；Java 方向火，赚得多，就报培训班，参加集训营……这样做的人，也许可以靠短期的突击准备获得一个还不错的初级职位，但他们永远都只能在金字塔的底端徘徊，殊不知，金字塔的顶端才有最精彩的风景。<br>当前互联网行业已经进入了存量竞争的时代。只要面试稍微高端一点的职位，就要面对非常激烈的竞争。现在，再也不是那个推导一下逻辑回归就能面上算法岗，背一下面试“八股文”就能面上研发岗的时代了。所以“选择”后的“坚持”和“努力”就非常重要了。只要你当前所处领域的高度和容量是足够的，就要尽量沿着已有的方向往高处攀爬，这样你才能够持续积累专业领域的财富。</p><h2 id="什么时候选择转方向，如何转？"><a href="#什么时候选择转方向，如何转？" class="headerlink" title="什么时候选择转方向，如何转？"></a>什么时候选择转方向，如何转？</h2><p>在两种情况下，你可以坚定地选择新的职业方向。<br>第一种是你对自己的毅力和决心非常有信心，清楚自己一定会在新方向坚持下来。对于这样的同学，我举双手支持你选择新的道路，因为你是一定会在新的方向上成功的。是国内某 211 硕士毕业，做广告系统的非算法研发工作，但非常希望转做机器学习工程师。为此，他工作之余坚持学习英语，准备各类申请材料，最终申请到了 CMU 的相关硕士项目，现在在 Facebook 做机器学习工程师。<br>如果有这样的恒心和执行力，年龄、背景都不是关键问题，你一定会在新方向上成功。<br>第二种，自己所在的方向已经进入了长期的下行通道。<br>如果你发现，自己所处的职业方向已经处在了长期的下行通道上，就应该立刻为离开这个方向做准备。一个典型的例子是从 2013 年开始的去 IOE 大潮。IOE 指的是 IBM 的小型机、Oracle 数据库和 EMC 存储设备。这三项基础设施曾经长期占据着中国互联网、金融、通信公司的核心位置，有大量高薪从业者。但是随着去 IOE 成为国家战略，我们就应该清楚，无论是从容量还是高度上说，这个方向都不会再现往日的辉煌了。这个时候，转方向就是 IOE 从业者们最应该做的事情。类似的例子还有很多，比如曾经红极一时的 Flash 应用相关的工程师，塞班等非Android、iOS 的移动端工程师，传统的 J2EE 工程师等等。在新的技术潮流的冲击下，和“坚持”原来的方向相比，果断转换到更广阔的赛道显然是一个更为明智的选择。</p><p>在转方向的过程中，我到底要具体做些什么呢？我觉得可以分为三大步骤。<br>第一，下决心。按照我们刚才说的原则，从“短期”和“长期”两个维度，确定你未来希望从事的方向。这里我要强调的是，你的决定一定要建立在充分的分析决策之上；而且，一旦做出这个决定，就不要轻易改变。你要清楚，开弓没有回头箭，在接下来至少一年的准备时间里，不要做任何的摇摆，所有的工作、学习行为都要围绕着转方向这个目标。<br>第二，定目标。在确定自己的目标方向后，至少提前一年去看目标职位的 JD（JobDescription），列清我们的具体目标。你需要进行细致的规划，包括需要掌握的工具，需要了解的领域知识，需要准备的面试题等等。然后根据这些具体目标，有的放矢地去扫清转方向过程中的障碍。<br>第三，攒经验。你当前的工作、学习行为，都应该围绕着新的目标进行调整。比如你现在从事后端岗位，想转到推荐算法岗，那么可以看看现在公司内部有没有推荐系统相关的后端岗位，先跳到相关方向上来。再比如你是一名应届生，想从数学方向转到软件工程师方向，那么就应该马上着手去积攒项目经验，寻找相关的实习岗位。总之，要千方百计地向你的目标岗位靠近</p><h1 id="大公司VS小公司，怎样选择更有前途？"><a href="#大公司VS小公司，怎样选择更有前途？" class="headerlink" title="大公司VS小公司，怎样选择更有前途？"></a>大公司VS小公司，怎样选择更有前途？</h1><h2 id="用财富管理的思路去管理你的职业生涯"><a href="#用财富管理的思路去管理你的职业生涯" class="headerlink" title="用财富管理的思路去管理你的职业生涯"></a>用财富管理的思路去管理你的职业生涯</h2><p>我们上班到底是为了什么？有的同学说了，我上班就是为了挣钱，哪个公司给的钱多，我就去哪。还有的同学说了，我上班就是要发挥更大的影响力，哪个公司出名，能让我影响到更多用户，我就去哪。他们的回答都没错。《史记》中不也说，“天下熙熙，皆为利来；天下攘攘，皆为利往”吗？作为普通人的我们，上班当然是为名为利，为了养家糊口。但这里我要说的是，名利也分短期利益和长期利益，挣钱也分挣快钱和挣慢钱。<br>小 C 是一名刚毕业的 985 学校硕士生。他可以去一家一线互联网公司做研发，年薪 30 万；也可以去一家特别缺人的中小型公司的相同岗位，年薪 40 万。如果你是小 C，你会如何选择呢？如果我们优化的是最近一年的收益，那么毫无疑问，肯定是选择去小公司拿高薪了。但如果我们考虑的是整个职业生涯的收益，大公司的履历就更有价值了。因为在大公司的技术积累本身就是一笔财富，不仅可以产生短期的收入，还能够产生复利。<br>你可能想问我：职场中的复利是怎么产生的？让我们先回到刚才的例子。假设小 C 选择了大公司，三年之后，成长为了一名高级工程师，不仅薪水逐年增长，而且积累了可观的技术财富。如果小 C 此时跳槽到中小公司，已经能做一名独当一面的技术组长了，很有可能拿到 60 万甚至更高的年薪。这就是职场财富的“复利价值”。<br>而中小公司的经验就没有这么强的财富效应了。假设小 C 选择了初始年薪更高的小公司，三年之后同样成为了高级工程师。这时小 C 如果想要换公司，要么继续横跳到其他中小公司，要么降级去大公司，可能年收入还不如在原来小公司的时候。</p><p>要想避开大公司激烈的竞争、艰难的升级道路，只有一条“快车道”可走：让你所在的中小公司成长为大公司或者明星公司。虽然互联网的发展在日趋稳定，但是和其他传统行业相比，我们的机会还是多太多了。举个例子，2020 年 9 月，硅谷云数据仓库公司 Snowflake 上市，在 2018 年加入的硕士应届生获得的期权价值居然达到了 1400 万美元。如果说这些应届生们的经历还存在很大的运气成分，说服力没那么强，那我们不如看下国内新一线公司的崛起过程，这可以更好地说明与公司一同成长的重要性。字节、快手、美团这些公司迅速发展壮大的同时，他们的员工也获得了巨大的成长机会。Hulu 的众多前同事加入字节、快手之后，不管是股票收益还是带团队的能力，都有了质的飞跃。</p><p>就像我们常说的那样，“富贵险中求”，加入中小公司就意味着较高的风险，但这些风险并不是难以避免的。如果你想尝试加入中小公司，我有三个建议，可以帮助你有效规避潜在的风险：</p><p>尽量去 B 轮之后，已经有稳定商业模式的中小公司。如果不是核心创始人，最好不要加入初创公司，成功的概率过低。<br>即使去中小公司，也要寻求不低于业界平均水平的薪资。你要清楚，一个靠谱创业公司的融资额，一定可以支撑起团队较高的薪资水平。如今，砸锅卖铁搞创业的时代已经过去了，如果现在还有公司只卖情怀不给钱，那只能说明这个公司本身就有问题。<br>尽量去细分领域的头部中小公司，这样还可以保持技术上的先进性。有很多细分领域的“隐形独角兽”，其实有着比大公司还先进的技术栈。这样小而美的团队，毫无疑问是值得加入的。</p><h2 id="缺啥补啥，高端玩家看重的是职场体验"><a href="#缺啥补啥，高端玩家看重的是职场体验" class="headerlink" title="缺啥补啥，高端玩家看重的是职场体验"></a>缺啥补啥，高端玩家看重的是职场体验</h2><p>最上面的通道 1，我称为“大公司升级打怪”路线，适合名校背景，从小优秀到大的学霸们去尝试。在大公司积累一定的技术财富之后，无论是继续在大公司“升级打怪”，还是去小公司寻求更全面的发展，追求超额的公司发展收益，都是可行的。<br>中间的通道 2，我称为“小公司曲线救国”路线。这条路线适合刚开始由于教育背景等问题，没办法加入大公司的同学。如果你有一个大公司梦，那么不妨先加入相关行业的小公司积攒经验，再寻求合适的时机跳槽到大公司。需要注意的是，如果你选择这条道路，那么就不要在小公司花费过多的时间去升职，因为小公司的职级一般不被大公司完全认可。你更应该做的，是提升自己的能力，把小公司当作一个积攒领域经验的机会就好。<br>最下面的通道 3，我称为“小公司协同成长”路线。这条路线适用于愿意与公司一同发展的同学。如果你认定这家公司是有前景的，是值得你付出的，那么这条路线也许会产生超额的收益。但需要注意的是，选择这条道路的同学一定要时刻关注公司的发展状况，如果发现公司的发展赶不上你的预期，实现不了你当初的目标，那么可以随时切换到通道 2，及时止损。</p><h1 id="如何正确处理公司的期权、股权？"><a href="#如何正确处理公司的期权、股权？" class="headerlink" title="如何正确处理公司的期权、股权？"></a>如何正确处理公司的期权、股权？</h1><h2 id="到底什么是期权和股权？"><a href="#到底什么是期权和股权？" class="headerlink" title="到底什么是期权和股权？"></a>到底什么是期权和股权？</h2><p>首先，我们要搞清楚到底什么是“股权激励”。从目的上说，“股权激励”是公司的拥有者为了激励员工，让员工更有参与感和主人翁意识，把一部分公司股份授权给员工的奖励方式。从形式上来说，“股权激励”一般分为两种，一种是直接授予“股权”，一种是授予“期权”。<br>股权的概念很好理解，它指的是股东对公司享有的包括人身和财产权益的一种综合性权利。通俗点说，拿到股权后你就是公司的股东了，就获得了以股东身份参与公司的分红、投票等经营和管理活动的权利。<br>大部分上市公司对员工的股权激励，基本都是以直接授予 RSU（受限股票单元）的形式实现的。这里提到的 RSU，除了只能在规定的时间点卖出外，跟股民们从交易所买入的股票是一样的。但是，那些处于创业阶段，还未上市的公司，往往会用授予期权的方式来激励员工。<br>和直接授予股权比起来，授予期权有什么区别呢？<br>两种方式的区别在于，“期权”并不是实实在在的股权，获得期权的员工不享受股权附带的任何权利。期权仅仅是一种合约，这个合约赋予持有人在某一特定时间段以固定价格购进或售出一种资产的权利。你行使这个权利的行为，叫做“行权”。<br>通俗点说，期权规定了一个购买股权的价格，你可以在某一时间段内用这个价格购买到股权。比如说，公司授予你了 1000 股期权，行权价格是每股 10 块，行权的时限是从授权日起的四年之内。那么，你就可以在未来四年内，花 10×1000&#x3D;1 万块 把这些期权变成股权。所以，期权操作的重点是，你需要花钱来行权。这意味着什么呢？一般来说，公司期权的价格是跟公司当前的估值挂钩的。如果公司的估值不涨，你手里的期权有意义吗？没有。因为你花 1 万块钱买到的股权还是只值 1 万块，没有得到任何收益。但是，假设你们团队士气高涨，商业模式对路，四年后公司的估值翻了十倍，成功在港股上市。这个时候你行不行权呢？当然要行权了。你花 1 万块钱兑现了 1000 股股权，这1000 股股权值 100×1000&#x3D;10 万块，你这一下就赚了 9 万块。<br>这就是公司使用期权激励的意义：它给了你跟公司一起成长的动力。如果公司估值不涨，你手里的期权就没有意义；如果公司以远高于你行权价的股价上市，你的期权将收到丰厚的回报。所以，在谈 offer 的时候，如果你要入职的公司有股权激励，一定要搞清楚公司授予你的是股权还是期权。如果是期权，还要弄清楚行权价是多少。如果行权价过高，一定要评估一下这样的期权还有没有意义。这是避免踩坑的最基本操作。</p><h2 id="在职业规划中，如何更合理地追求股权收益？"><a href="#在职业规划中，如何更合理地追求股权收益？" class="headerlink" title="在职业规划中，如何更合理地追求股权收益？"></a>在职业规划中，如何更合理地追求股权收益？</h2><p>有三个建议：<br>第一，一定要在具备了一定的技术财富后，再去追求股权的收益。<br>或者反过来说，不建议你在职业生涯早期过多考虑股权的影响，而忽视了你积累技术财富的机会。因为在职业生涯早期，你的职场价值是非常低的，既没有太多选择公司的资历，也没有跟公司讨价还价的资本。<br>我给你举个例子：五年前刚毕业的小 A 看到了某头条的机会，以应届生的身份加入，但这时候的小 A 根本拿不到什么股权。因为只有达到资深工程师以上的级别，才能够拿到足够可观的股数。所以，刚毕业的小 A 最应该做的，是完成初期的技术财富积累，才能在五年后的今天把握住这些机会。<br>第二，如果你不是职场高端玩家，尽量不要尝试加入初创公司。<br>这时候你可能会说了：小 A 还是没赶上合适的时机，如果他在更早的时候加入某头条，成为头 100 个员工，那不是早就财富自由了？我想告诉你的是，这种做法的风险更大，不建议普通人尝试。我也参与了 2009 年到 2013年的移动互联网创业大潮，因此清楚地知道，那时的某头条不只一次曾处在死亡的边缘。<br>这个公司能活到现在，并且发展壮大，还让你看到那么多员工实现了财富自由，幸存者偏差是一个非常重要的因素。<br>一定要清楚，初创企业是只适合高端玩家的“玩法”。如果你在行业内已经是个老兵了，不仅基本解决了个人和家庭的生存问题，还有了足够的技术财富和人脉财富，这时候就是你创业的好机会。反之，如果你现在只是个行业新人，除了精力旺盛什么都没有，就不应该用你积累财富的黄金时间去冒险。我知道，总有 1% 的人会成为幸运儿，但我们更可能是那 99% 的普通人。<br>第三，不要忽视上市公司的股权升值机会。<br>很多同学都有这样的认知：想靠股权提升个人财富，只能去创业公司。其实这是一个非常大的误区。事实上，上市公司可能是风险更小，收益也不低的选择。腾讯、小米，甚至是苹果这样的巨无霸，都有过股价 1 年翻倍，3 年翻 5 倍的时段。特别是最近 3 年，由于美股大盘的强劲，股价翻 10 倍的上市公司也并不罕见。所以，如果你对一个行业很熟悉，可以先充分利用自己的行业知识，做好业内上市公司的调研。然后，通过加入一家上市公司来“炒股”。这显然是一个既能积攒大公司技术财富，又能从公司股权中获得收益的好机会。</p><h2 id="我们要规避哪些期权和股权上的陷阱？"><a href="#我们要规避哪些期权和股权上的陷阱？" class="headerlink" title="我们要规避哪些期权和股权上的陷阱？"></a>我们要规避哪些期权和股权上的陷阱？</h2><p>在处理股权时，一方面我们应该慎重地选择公司，尽量让自己未来的收益最大化；另一方面，也要牢记“防人之心不可无”，尽量去规避股权协议上的陷阱。</p><p>对于小公司，我们首先要考虑的是股权协议的合法性问题。不合规的股权协议带来的后续纠纷，甚至最后到了对簿公堂的地步。为了防止类似的情况发生在你身上，当你决定加入一家初创公司时，一定要避开这几个“陷阱”：</p><ul><li>仅以口头形式承诺期权，缺少书面的授权方案；</li><li>在正式 offer 中不写明期权数量和授权细节；</li><li>在你加入公司后，以各种理由不签署或者推迟签署书面的期权授予协议，不执行当初约定的授权方案。</li></ul><p>只要上面的事情发生任何一项，就可以证明这家初创公司一定是一家不诚信的公司。即使某一次你侥幸避开了“坑”，也一定还有更多劳神费心的问题在等着你。对此，唯一的建议就是尽早止损。你要做的是仔细地辨别，加入一家能够让你积累财富的公司，而不是在这些毫无价值的事情上浪费精力。<br>事实上，即使有书面的期权协议，某些初创公司仍然可以用一些复杂的持股方式把你“绕晕”。这就是我建议你谨慎选择加入初创公司的原因。如果你是一个职场新人，除非遇到一家真心实意吸引人才的初创公司，那我不建议你选择创业这条道路。这时候对你来说最重要的，是踏踏实实地积累技术财富。</p><p>如果你选择的是大公司，又是另一种情况了。一般来说，上市公司，或者融资到 C 轮之后的独角兽公司不会存在诚信的问题。那么我们应该关注什么呢？这种情况下，我们应该结合自身的规划，重点关注股权授予的细节。举个例子来说，某一线互联网公司的授权计划是这样的：股票分四年授予，分别是第一年底 0%，第二年底 50%，第三年底 25%，第四年底 25%。但是，这家公司的工作压力非常大，两年内的离职率是 70%。这时候，你就要做一个选择了：是加入后的两年内全身心投入在工作上，还是干脆不加入？<br>如果下定决心加入，你就得铆足了劲，尽全力取得成功，不要在两年内出局。但是，如果你接下来的两年内，有一些和全身心工作相冲突的人生规划，比如结婚生子、照顾老人，那么我建议你还是干脆不要加入。我们都知道鱼和熊掌不可兼得的道理，如果贸然加入，很可能会二者皆失。<br>再举一个例子：有些 C 轮之后的公司，期权价格已经非常高了，升值空间就很小。比如某智能设备的厂商，2015 年估值就高达 450 亿美元，但三年后它上市时并没有增值，那么它当初的期权价值就非常低。当然，很多公司上市前就会直接发放无买入成本的 RSU 来吸引人才，这样的公司当然是更值得加入的。综合来说，加入一家大公司时，应该重点关注它的授权细节和这家公司的成长性，这样才能让自己的股权财富有更好的增值空间</p><h2 id="拿到股权后应该怎么处理？"><a href="#拿到股权后应该怎么处理？" class="headerlink" title="拿到股权后应该怎么处理？"></a>拿到股权后应该怎么处理？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何选择一个有前景的职业方向&quot;&gt;&lt;a href=&quot;#如何选择一个有前景的职业方向&quot; class=&quot;headerlink&quot; title=&quot;如何选择一个有前景的职业方向&quot;&gt;&lt;/a&gt;如何选择一个有前景的职业方向&lt;/h1&gt;&lt;p&gt;这几年来，一谈到个人发展，所有人都在说“选择</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>财富课</title>
    <link href="http://example.com/p/54a91907.html"/>
    <id>http://example.com/p/54a91907.html</id>
    <published>2024-01-21T10:55:16.051Z</published>
    <updated>2024-01-24T14:09:01.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="财富课"><a href="#财富课" class="headerlink" title="财富课"></a>财富课</h1><p>英文中有个词叫“low hanging fruit”，字面意思是“挂得很低的、容易摘的果实”，含义是那些容易实现的目标。我相信，一个真正的聪明人，应该学会用更少的精力去摘到那些生活中的 low hanging fruit。和解决你工作中那些极端刁难人的问题相比，进行有效的财富管理就是“容易摘的果子”。<br>投资的过程，就是从一次次的投资行为中提炼规则，形成交易系统，然后根据反馈不断进行调整的过程。<br>我们程序员总是讲，“Talk is cheap，show me the code”。其实投资理财也是一样的，大道理我们都知道，但在实战中能不能应用好却是另外一回事。努力做一个更好的、普通的自己吧。接受和理解自己的“普通”是前提，我们中的 99.9% 都不会是投资天才，只有以一个普通人的姿态去面对财富管理这件事情，才能够扎扎实实地积累自己的财富，而不是搭建一个由自负和运气组成的空中楼阁。财富管理是一个漫长的过程，也是一件要陪伴你一生的事情。</p><h2 id="如何建立和维护“个人发展”和“投资理财”这两座高塔？"><a href="#如何建立和维护“个人发展”和“投资理财”这两座高塔？" class="headerlink" title="如何建立和维护“个人发展”和“投资理财”这两座高塔？"></a>如何建立和维护“个人发展”和“投资理财”这两座高塔？</h2><p>对于我们普通人来说，我们这一生主要会面对四个课题，分别是“基本生存”“个人发展”“投资理财”“人生兴趣”。其中，“基本生存”是地，“人生兴趣”是天，在这天地之间，“个人发展”和“投资理财”就是支撑起天地的两座高塔。我在开头提到的财富双塔框架，就是指由“个人发展”塔和“投资理财”塔组成的稳固的财富结构。<br>财富的定义远远不限于金钱，而是任何有价值，能产生收入的东西，《富爸爸，穷爸爸》中，把一个人的财富归为了下面几大类：</p><ul><li>不需本人到场就可以正常运作的业务；</li><li>股票；</li><li>债券；</li><li>能够产生收入的房地产；</li><li>版税，如音乐、图书、专利等；</li><li>其他任何有价值、可产生收入，或者有增值潜力，并且有很好销路的东西，比如艺术品。</li></ul><p>人生在世，最重要的事情不是打工赚工资，而是积累真正的财富。想清楚这个，你才能实现从“打工者思维”到“财富管理者思维”的转变，才有可能真正走上“财富自由”的道路。</p><p>“个人发展”这座塔，总体上是一个人的外向能力，或者说社会性能力的体现。一方面，在职业发展的过程中，你必须和他人充分协作，互相影响。就算我们是程序员，在做到中后期之后，也会有大量需要外向能力的工作，比如项目管理、协调沟通、架构设计等等。另一方面，个人发展过程中积累的资源，无论是人脉资源还是技术积累，都需要大量的交流、协作来获得、维护。<br>而“投资理财”这座塔，本质上是一个人内向能力的体现。从某种意义上来说，理财的过程也是修身的过程，是一个静下心来认识自己，跟自己和解的过程。只有达到了一种平静的、真实的状态，你才能是一个好的投资者。<br>对自己的认知，尤其是对自己能力边界和风险承受能力的清晰认知，是比找到一个顶级投资策略，或抢手的投资标的更关键的事。所以，在进行投资的时候，我们不应该把所有的精力都用在研究技术指标和投资策略上，而是应该把其中的一多半投入到认识自己上，思考自己有哪些优势和不足，想清楚自己要的是什么，并且不断地思考更新。<br>个人发展需要外向型能力，投资理财需要内向型能力，所以从能力范畴上讲，个人发展和投资理财是完美互补的。而从财富管理的角度来说，它们又是互相支撑，互相加速的。“个人发展”能带来稳定的现金流，“投资理财”则把现金流放大，让我们能进入更健康的财富状态；有了更健康的财富状态作为后盾，我们就能以更好的心态投入到个人提升当中，进而带来更充足的现金流，这就形成了一个良性的循环体系。我们每个人都应该试着让自己的财富飞轮转起来，而不是卡在一边，只关注自己的工作，或者职业发展上完全放弃，把希望都寄托在投资理财上。财富飞轮的两边缺一不可，而且，你的财富飞轮越早转起来越好。<br>你开始理财的时候越年轻，你的试错成本就越小；而且，投资心态和投资技巧是需要一定的锻炼来提升的，你开始得越早，今后受益的时间就越长。在投资理财的路上，你必须“做时间的朋友”，做那些能够让你长期获益的事情。自信和淡定的投资心态，往往是投资行为中最重要的。在德州扑克的牌桌上，有一句很有名的话：“当你不知道牌桌上谁是鱼的时候，你就是那条鱼。”这句话在投资领域也同样适用：当你不知道谁是市场中的韭菜的时候，毫无疑问，你就是韭菜。<br>时间分配原则：第一，绝不混淆工作时间和财富管理的时间，做坚决的隔离，防止精力分散；第二，跟时间做朋友，保持每天的短时间投入和累计的长时间投入；第三，坚决固定自己进行财富管理的时间，没有重大的工作和个人意外事件，雷打不动地在财富管理的时间做财富管理的事情。时间既不是省出来的，也不是挤出来的，时间是你提前隔离出来的。</p><h2 id="个人发展塔"><a href="#个人发展塔" class="headerlink" title="个人发展塔"></a>个人发展塔</h2><p>相比于投资理财，“个人发展”带来的自身价值的增长，才是我们应该首先关注的财富增长极。而且，如果你有很强的个人发展规划能力，自身价值增长带来的收益绝对不会比投资理财低。<br>提到个人价值，这里还有一个常见的误区，就是把“个人价值”狭隘地理解为“职场价值”。这样的理解，不仅会导致我们错失很多个人发展的机会，而且本质上也造成了职场“内卷”现象。这一点也很好理解，当所有人都认为个人价值仅仅体现在工作中的时候，大家就会把全部的注意力和精力都集中到非常窄的空间中，怎么可能不“卷”起来呢？<br>要想让自己的价值得到充分的发展，首先我们应该清楚自己有哪些个人价值。在我看来，一个“社会人”的价值，应该由三个同心圆组成。它们由内而外依次是“职场价值”“专业延伸价值”和“家庭与人生价值”。接下来，我们看看它们具体都指什么。<br>首先是最核心的“职场价值”，也可以把它称为“专业能力价值”。它是我们在这个社会的立身之本，是让我们拿到人生第一桶金的一技之长。我们程序员见面时，最喜欢聊的话题就是哪个公司发展好，应该怎么提升自己的技术级，如何跳槽，如何谈 offer 等等，这些本质上都是为了提升我们的职场价值。<br>和“职场价值”密切相连的是“专业延伸价值”。顾名思义，它是由我们的专业能力延伸出来的个人价值。举例子来说，我们加入一家创业公司，公司给我们的期权是延伸价值；我们在自己的专业领域达到一定的高度之后，申请的专利、写出的 Paper、编著的技术书是延伸价值；我们通过技术博客、业界交流积攒起来的影响力是延伸价值；我们通过带团队、做架构逐渐沉淀下来的人脉和技术资源当然也是延伸价值。我们在做好本职工作之外，需要时刻去提升自己的“专业延伸价值”，因为积攒下来的个人价值才是你自己的财富。<br>最外圈是“家庭与人生价值”。我们一定要清楚，这才是我们工作奋斗的终极意义。长期高强度加班，因此忽视自己乃至于整个家庭的身心健康和幸福感，这种做法绝对是本末倒置的。你的人生兴趣和家庭幸福才是双塔要支撑的天，这是双塔存在的意义。</p><h3 id="外包消耗型工作，积累财富型资源"><a href="#外包消耗型工作，积累财富型资源" class="headerlink" title="外包消耗型工作，积累财富型资源"></a>外包消耗型工作，积累财富型资源</h3><p>人的精力确实是有限的，但我们应该关注人生中最重要的那些事情。而践行这个道理的关键点，就在于我们要始终“外包消耗型的工作，积累财富型的资源”。比如，某互联网企业的总监，聘请了专业司机来负责家庭的所有出行工作，节省了大量打车、接机、接送孩子上学的时间；某教授外租自己距离稍远的房子，专门换租到离学校很近，可以步行上班的公寓，就是为了节省每天 1 小时的通勤时间。</p><h2 id="如何建立稳固的投资理财结构"><a href="#如何建立稳固的投资理财结构" class="headerlink" title="如何建立稳固的投资理财结构"></a>如何建立稳固的投资理财结构</h2><p>如果说“个人发展塔”是我们财富的第一桶金，是产生现金流的基石，那么“投资理财塔”就是我们财富的“聚宝盆”和“放大器”。在我的观念中，有两件事情是值得做一辈子的，一是在自己的专业方向上精益求精，二是持续提高自己投资理财的能力。只有这样，我们才能让自己的家庭财富，以及它带来的幸福感最大化。</p><p>想造一座金字塔，我们第一步要干什么？肯定是去找造塔的材料。在一座理财金字塔中，最基本的砖块就是一个个独立的“投资标的”。这里出现了一个专业词汇“标的”，我们今后还会多次用到它。它指的就是我们投资理财过程中的投资目标，比如股市中一支具体的股票，房地产市场中的一套商品房。接下来，从整体上介绍下所有的投资标的。我们用四个类别就能概括所有具体的投资标的了。具体有这四大类：</p><ul><li>固收类投资标的</li><li>股票类投资标的</li><li>实物类投资标的</li><li>新兴投资标的</li></ul><p>固收类投资标的，指的是预期收益率固定，或者波动较小的投资标的。最典型的就是国债、企业债等各类债券。此外，还有一些保险、银行理财产品。它们的特点就是风险相对较小，收益率相对较低但稳定。<br>股票类投资标的，指的是 A 股、美股、港股等各大证券市场的股票。这是我们普通投资者讨论最多的投资标的，你身边应该也有不少人期望通过“炒股”来实现财富自由，它的特点你肯定也比较清楚了，就是波动大、收益高、风险高。<br>实物类投资标的，最典型的代表就是房产。买房是我们每个人都绕不开的话题，也是和家庭、人生密切相关的重大投资。所以，房产往往是对我们普通人来说最重要的实物类投资标的。广义来说，实物类投资标的还包括原油、铁矿石等大宗商品，以及黄金白银、艺术收藏等等。这一类投资标的，总体特点是投资金额较大，流动性较差。<br>最后一类是新兴投资标的。当前最典型的新兴投资标的就是数字货币。由于数字货币这个概念本身就源于技术圈，相关的区块链、GPU 挖矿等话题又是程序员们非常感兴趣的领域，所以数字货币的投资在程序员圈也非常火热。它的特点是未来不确定性强，收益和波动都极大。</p><p>这四大类投资标的还可以具体往下细分：每一类投资标的都有内部子类，每一个子类中又有很多具体的投资标的。这样，就可以组成一个从大类到小类，由高层级到低层级排列的投资标的金字塔。</p><p>我们在对家庭资产进行配置时，往往就是遵循这种金字塔式的配置方法：</p><p>首先，在自己的理财观，也就是顶层投资逻辑的指导下，先做家庭资产的顶层配置，确定上述四大类投资标的的配置比例。然后，根据对每类资产的了解程度，做资产项内部的进一步优化；最后，落实到每一次具体的投资操作上。</p><p><img src="https://s11.ax1x.com/2024/01/21/pFV0E5j.md.png" alt="pFV0E5j.md.png"></p><p>要尽可能地熟悉全部四大类投资标的的特点，然后根据自己的兴趣和擅长的领域，有针对性地深入研究具体的投资标的。<br>如果你想让你的系统性能很优秀，就要统筹设计系统中的各个模块。只要缺少了一个模块，就可能影响整个系统的稳定性和运行效率。但是，一个人不可能成为所有模块的专家，所以我们只要能在统筹全局的同时，深入一个或几个点，就足够了。</p><p>要熟悉四大类投资标的，听上去还是一个艰巨的任务，别害怕，只要使用下面三个方法，就不难掌握各个大类标的的基本投资方法：<br>方法一：趁早开始。<br>我在第一讲中就提到过，要让自己的财富飞轮早点转起来，越早越好。熟悉各个投资标的也是一样，你熟悉得越早，就可以越早享受它带来的好处。<br>方法二：设置观察仓。<br>设置观察仓，就是指把少量的、无关痛痒的钱投入到你想要了解的投资标的上。这部分钱会自然而然地吸引你的注意力，让你去观察这个标的的风险和收益特性，在做到知己知彼后，你就可以再做进一步的投资。这个方法我自己屡试不爽，既能快速熟悉不同标的的特点，又不用承受太大的投资损失。所以，我建议你在进入任何一个新的投资领域时，都先采用这个方法，快速学习的同时又不会伤筋动骨。<br>方法三：结合兴趣，有重点地学习。<br>这一点前面也提到了。我鼓励你去多了解各类投资标的的特性，并不是要你了解所有细分的投资标的，事实上也没有人可以做到这一点。你要做的，是结合自己的兴趣，进行有重点的学习。</p><p>深度的钻研，应该在广度的 low hanging fruit 都已摘完的前提下进行。这一点，对平衡我们的时间投入和投资回报来说非常重要。</p><h3 id="资产配置的经典组合"><a href="#资产配置的经典组合" class="headerlink" title="资产配置的经典组合"></a>资产配置的经典组合</h3><p>“鸡蛋不能放在一个篮子里”。这句话听上去简单，却是现代投资组合理论的核心思想。<br>现代投资组合理论是由诺贝尔经济学奖获得者马科维茨在 1952 年提出的，它的影响力一直持续至今。可以说，这个理论是我们构建一个稳健的资产配置体系的基石。如果说不同类别的投资标的，是构成我们投资理财塔的材料，那现在我们已经收集了足够的“砖块”，可以运用合理的资产配置方式，给我们的“投资理财塔”打地基了。即使我们一点理财知识都不知道，只要把这个地基打好，就能获得非常理想的投资收益。<br>“永久组合”是 1973 年由美国专业投资人哈利·布朗提出的。顾名思义，他提出这个组合的初衷就是让投资人只要“永远”保持这个组合比例，就能获得不错的稳定收益。<br>这个组合非常简单，用一句话就能说清楚它的配置方案，即“25% 美国标普 500 指数基金，25% 的美国十年期国债指数基金，25% 的黄金指数基金，25% 货币基金”。<br>当然，中国市场的具体投资标的肯定是不同的，把这个方案套用到中国市场就是“25% 沪深 300 指数基金，25% 的五年期中国国债，25% 的黄金指数基金，25% 货币基金”。</p><h3 id="如何做到“资产再平衡”？"><a href="#如何做到“资产再平衡”？" class="headerlink" title="如何做到“资产再平衡”？"></a>如何做到“资产再平衡”？</h3><p>这里的资产不仅限于我们的投资闲钱，还应该把自己的房产，甚至是包括父母、配偶在内的整个家庭的资产都考虑进来。如果这个大家庭的资产严重偏向某一单项资产，那么就存在资产配置失衡的问题，你的“投资理财塔”就是不稳固的。</p><p>由于中国人安土重迁的观念，家庭资产严重偏向房产这其实是中国家庭普遍存在的现象。这样的严重失衡状态，可能会带来两个后果：</p><ul><li>单一资产的风险敞口过大。房地产市场的波动将严重影响整个家庭的资产价值。</li><li>房产占用了过多的资金，这会导致我丧失其他领域的很多投资机会。通俗地称为miss value。</li></ul><p>把自己小家庭的收入，以及我父母的收入，全部配置到了股票类和固收类资产上去。在这个基础上，考虑到自己的风险偏好，我把自己的收入全部配置到了股票类资产上，父母的收入，则以 40% 和 60% 的比例配置到股票类和固收类资产中去。<br>其次，我直接进行了投资大类的置换。我对中国房地产的基本判断是，认为中国房地产市场将进入一个长期稳定，房价只可能出现小幅上升的阶段。于是，我在 2018 年卖掉了一套小的投资房，把还完房贷后的剩余资金以接近永久组合的比例投资到了其他投资大类中。<br>问题的关键就在于，你是否有资产配置的概念，以及切实执行资产配置理念的行动力。如果你从来没有认认真真地梳理过自己的家庭资产情况，那么你的“投资理财塔”一定是根基不稳、风雨飘摇的。</p><h3 id="有哪些收益稳健的经典资产配置组合"><a href="#有哪些收益稳健的经典资产配置组合" class="headerlink" title="有哪些收益稳健的经典资产配置组合"></a>有哪些收益稳健的经典资产配置组合</h3><p>“股债组合”是指主要投资于“股票”和“债券”这两类资产的资产配置组合。其中，60&#x2F;40 股债配置组合，即 60% 股票和 40% 债券的组合最为经典，它大约在50 年前就开始在美国流行，成为当时各投资顾问机构推荐给投资者的标准组合。<br>股债组合中，股票部分是这个组合产生长期收益的核心驱动力，而加入适当比例的债券资产，将显著降低组合整体的波动水平，让投资者承担的风险大幅减少。海外市场最著名的股债混合组合，就是我们刚刚提到的 60&#x2F;40 股债组合。在国内，因为股票的波动率相对偏高，而债券的波动率相对偏低，所以我们针对国内投资标的的特点，调整为 40&#x2F;60 股债组合，即 40% 的股票和 60% 的债券。</p><p>有没有更加量化的指标来直接表示收益率和风险呢？当然是有的。两个指标，年化收益和最大回撤。年化收益很好理解，就是考察期上按复利计算的年均收益。最大回撤，指的是净值曲线中最大一次下跌的幅度，它是衡量一个投资标的风险特性的最重要指标。<br>还有一个指标叫“夏普率”，它是通过年化收益减去无风险收益率后，再除以年化波动得来的，描述了承担单位波动能够换取的超额收益，专业投资者一般用它来直接衡量一个投资标的的好坏。简单的 40&#x2F;60 股债配置组合，长期年化收益有 8.2%，已经接近纯股票 10.9% 的年化收益水平了。同时，它的最大回撤从纯股票的 72.3% 大幅降低到 34.1%。<br>72.3% 的最大回撤是什么概念呢？如果你对自己的风险偏好没有明确的认知，只要问自己这样一个问题就够了：如果自己的资产下跌 7 成，晚上还能不能睡好觉？如果你觉得自己会像大多数人那样寝食难安，那 3 成最大回撤的股债组合肯定就更适合你。</p><h3 id="风险更加可控的“风险平价组合”"><a href="#风险更加可控的“风险平价组合”" class="headerlink" title="风险更加可控的“风险平价组合”"></a>风险更加可控的“风险平价组合”</h3><p>风险平价组合是由波士顿磐安资产管理公司的钱恩平博士提出的，这个组合的设计思路，是让每类资产对组合整体风险的影响大致相等。拿上面讲到的 40&#x2F;60 股债组合来说，股票资产对这个组合整体风险的影响远远大于债券，这就让这个组合的风险跟股票过于强相关了，不利于通过分散风险来增强整个组合的稳定性。要避免这个问题，就要调整资产配比，让股票和债券对股债组合的风险贡献一致。这就是风险平价组合的基本思想。<br>第一步，罗列出一系列你想要投资的资产类别。<br>第二步，计算这些资产类别指数的历史波动率，也就是年度收益的波动水平。<br>第三步，用这些波动率的倒数作为权重来构建组合。<br>代表股票资产的沪深 300 指数，长期波动率大致是 20%；代表债券资产的上证 5 年国债指数，波动率大致是 2%。它们波动率的倒数比值大致是 1:10，这样就得出了我们构建组合的权重。</p><p>接下来我们看一个回测实例。回测是对一种投资策略在历史数据上的复盘，相当于用历史数据检验策略的实战效果，在量化策略的研发中是一种最常用的手段，类似于软件开发的测试环节。我们大致按照 10% 股票和 90% 债券的权重，在 2005 年初开始建仓这组股债风险平价组合，之后每季度再平衡一次，也就是按照当时的资产价格重新把股债的比例调整到 1:9。我们可以得到如下的回测结果：</p><p><img src="https://s11.ax1x.com/2024/01/21/pFVBiS1.md.png" alt="pFVBiS1.md.png"></p><p>风险平价组合与前面的股债组合相比，最大回撤大幅下降，只有 6%。当然，作为降低风险的代价，它的年化收益也下降到了 5.3%。但如果你能坚持这样的投资组合，保持收益率的稳定，长期的复利也能够显著提升你 15 年后的财富水平。风险平价组合的背后逻辑是分散风险，让组合整体的收益来源多样化，这样就能够相对安全地穿越各种不利的市场情况。当然，加入越多的投资标的，组合的风险就越分散，组合整体的收益就越稳定，这是需要一定的调研和计算能力的。</p><h3 id="“永久组合”"><a href="#“永久组合”" class="headerlink" title="“永久组合”"></a>“永久组合”</h3><p>要设计这样一个组合，它包含的所有投资标的都应该具有长期的生命力，不能说 5 年、10年之后就从市场上消失了。而且，组合权重的确定应该非常简单，不需要做什么数据统计或者信息搜集工作，这样才能“永久”。于是，上世纪 80 年代，美国的专业投资人哈利·布朗就提出了永久组合，它以相等的权<br>重，配置于四类非常常规并且“永久”的资产：25% 的股票、25% 的国债、25% 的黄金和 25% 的现金。股票和国债，我们在介绍股债组合的时候都熟悉了，新加入的黄金则是一把对抗通货膨胀的“利器”，而现金可以最大程度上削弱风险，并留出流动资金。<br>这里还是用沪深 300 指数代表股票资产，上证 5 年国债指数代表债券资产，黄金资产则用黄金期货指数来代表，现金资产呢，我们使用货币基金。按这四种资产各 25% 的权重在2005 年初建仓，之后每季度再平衡一次，得到如下的回测结果：<br>永久组合的长期年化收益达到了 7.6%，而且相比股债组合的 34.1%，最大回撤降低到了 27.3%。更重要的是，永久组合的稳定性已经在超长历史跨度中，得到了反复的验证。由于美国金融市场的稳定性更好，永久组合在长达 45 年跨度中的表现是，收益率 8.15%，最大回撤仅 12.42%，这充分证明了它稳定性和持久性的特点。</p><h3 id="标的丰富、业绩卓越的“耶鲁组合”"><a href="#标的丰富、业绩卓越的“耶鲁组合”" class="headerlink" title="标的丰富、业绩卓越的“耶鲁组合”"></a>标的丰富、业绩卓越的“耶鲁组合”</h3><p>“耶鲁组合”在机构投资者中非常出名，它是由美国耶鲁大学捐赠基金会管理的，负责人是大卫·史文森。在他管理该基金的三十五年间，基金规模从 13 亿美元增长至 312 亿美元，获得了远高于市场平均水平的长期收益。对于我们普通人来说，耶鲁组合似乎很难复制，因为像对冲基金、股权、风投等资产，普通人很难接触到，也很难进行鉴别。但也不必望洋兴叹，我们仍然可以在力所能及的范围内复制它的基本思想：尽量扩充和优化自己的资产类别，增加收益来源。</p><p>引入美股资产。因为相比 A 股，美股在更长的时间区间内有更加稳健的表现；将代表 A 股大盘指数的沪深 300 指数基金替换为主动股票型基金。主动股票型基金主要由更加专业的基金经理管理。因为 A 股现阶段散户比例仍然较大，因此专业投资者凭借信息和技术优势，有更丰厚的超额收益空间。</p><h2 id="支点投资法"><a href="#支点投资法" class="headerlink" title="支点投资法"></a>支点投资法</h2><p>合理的资产配置是我们“投资理财塔”的基石。只要你有足够的定力，就可以通过简单的资产配置策略，享受长期稳定的收益。但有的同学可能会说：“我觉得永久组合 6.8% 的年化收益还是太低了。我想通过投资来赚到足够的钱，实现我财富自由的梦想。”长期稳定的 6.8% 的年化收益其实是一个非常优秀的收益率，而能够不受诱惑，十几年如一日地坚持永久组合的配置，本身就是一件极难做到的事情。至于“财富自由”，我想只有在合理的资产配置基础上，依照非常严密的逻辑来进行主动投资，并长期进行投资实战训练，才有可能实现这个目标。除此之外的任何“暴富”想法都是不切实际的。</p><h3 id="投资公理：投资是讲逻辑的"><a href="#投资公理：投资是讲逻辑的" class="headerlink" title="投资公理：投资是讲逻辑的"></a>投资公理：投资是讲逻辑的</h3><p>要想进行主动投资，就必须依照非常严密的投资逻辑。这就涉及到投资中的一个本质问题：我们所有投资行为的出发点到底是什么？<br>有的同学说：我最近投资比特币赚了不少钱，因为我一直跟着一个币圈大佬，他怎么投，我就怎么投。那么这位同学的出发点就是“跟投大牛”。<br>有的同学说：我最近又买了很多茅台的股票，因为我看茅台已经从最高点跌下来不少了，价格足够便宜。那这位同学的出发点是“抄底”。<br>还有同学说：我最近又买了不少 A 股的指数基金，因为我看 A 股大盘又开始上涨了。那他的出发点就是“追涨”。<br>这些同学的出发点都对不对呢？对，也不对。说对，是因为他们都能给自己的投资找到一个理由；说不对，是因为他们找到的理由都太过片面：一没有严格的数据和丰富的经验支撑，二没有严密的投资逻辑指导后续的投资行为。<br>其中，第二点是更加重要的。投资行为的出发点有且只有一个，那就是“严谨的投资逻辑”。你可以把这句<br>话看作投资领域的公理。</p><h3 id="个人情绪是所有投资者的“公敌”"><a href="#个人情绪是所有投资者的“公敌”" class="headerlink" title="个人情绪是所有投资者的“公敌”"></a>个人情绪是所有投资者的“公敌”</h3><p>在哲学领域，有一个非常重要的概念叫 EGO，即“自我”或“自我意识”。如果说按照严谨的逻辑进行投资是投资者必须遵循的公理，那么包含着大量个人情绪的 EGO 就是投资者的公敌。具体来说，在投资中个人情绪会有什么样的消极影响呢？也许你没有太直观的感受，那我就举个例子。普通投资者常常会有和下面类似的投资行为。<br>2020 年下半年的时候，无论国内还是国外，关于新能源的投资都非常火热。特斯拉、蔚来汽车、理想汽车，它们的涨幅都在 10 倍以上。于是，很多人坐不住了，有人眼红，有人兴奋，有人后悔。在种种个人情绪的驱使下，大部分人都顾不上太多，想的只是一定要赶上新能源这趟车，于是纷纷打开券商 APP，抓紧下单买入。你的投资动机就已经注定了这笔投资是毫无价值的。赚钱了，只会驱使你在错误的路上越走越远，直到下一次亏钱；亏钱了，带给你实打实的损失，让你怀疑否定自己。我把这些由人类 EGO 触发的投资叫作“无效投资”。<br>2021 年上半年，以比特币为代表的数字货币经历了一波急速上涨并大幅回调的行情。2021 年 1 月，我的一位同事在比特币 30000 美元附近的点位入场，他的本意是趁着上涨趋势赚一波“快钱”，然后快速退场。这个出发点其实没有问题，跟着大趋势走，短线操作一波离场就好。但到了 3 月份，比特币上涨到 60000 美元附近时，他却推翻了自己的投资逻辑，转而去看好比特币的长期发展。他说，随着越来越多企业用比特币支付，比特币将迎来真正的牛市，所以选择继续加仓比特币。还是那句话，我们先不管这样的投资能不能赚到钱，先看背后的投资动机。这样随意改变自己投资逻辑的行为，只可能有一个结果，那就是毫无逻辑的止盈和止损。也就是说，投资者根本不知道自己为什么赚到钱，或者亏了钱。我把这样的投资者称为“神经错乱”的投资者。<br>不管是由人类 EGO 触发的“无效投资”，还是随意改变投资逻辑的“神经错乱”行为，它们对于财富管理来说都毫无意义。甚至，这些行为都称不上是一次“主动出击”，顶多算是拿自己的钱扔了一回骰子，玩了一把还挺刺激的游戏。</p><p>所谓“支点投资法”，就是要先为你所有的投资行为寻找一个逻辑支点，之后随着时间的推移，不断去验证这个支点还存不存在。一旦这个支点消失，就要毅然决然地选择结束这次投资行为。<br>支点投资法主要分为三个阶段，分别是“建仓阶段”“验证阶段”和“退出阶段”。<br>“建仓阶段”的主要任务是寻找这次投资行为的逻辑支点，然后根据这个支点，触发相应的投资行为。<br>“验证阶段”则是要不断验证你的投资支点，如果支点的逻辑还成立，就持续持有当前投资标的；如果支撑投资支点的条件已经不存在了，那么就证明当初的投资行为已经没有支撑了，就要进入投资的退出阶段。<br>最后的“退出阶段”，需要的是你坚定的执行力，不管该次投资是盈利，还是亏损，只要投资支点不存在了，都应该坚定不移地退出。退出时如果你处于盈利状态，就是“止盈退出”，这次投资行为就是成功的。而如果处于亏损状态，就是“止损退出”，这次投资行为虽然失败了，但由于你清楚地知道亏损的理由是什么，这次投资过程就成为了提升投资水平的宝贵经验。</p><pre><code>大家都知道，新冠疫情的爆发对全球航空业的打击是致命的。从图中的股价走势可以看到，在美国新冠疫情于 2020 年 3 月全面爆发后，以“美国航空”（AAL）为代表的航空股从 28 块直接跌到了最低时的 10 块左右。之后由于美联储疯狂印钱，股价短暂回升，但仍未走出低谷。时间到了 2021 年元旦前后，这时候我捕捉到了一个很适合作为投资支点的机会，那就是辉瑞、摩德纳，以及国内的国药等新冠疫苗陆续通过了临床三期测试，可能会在短期内上市。要知道这时候美国的疫情正处于最顶峰的时候，航空业也处于最低谷。那么随着疫苗的上市，疫情减弱，航空股能否重回疫情前的价格呢？我当时的判断是这样的：如果疫苗成功阻击疫情，那么航空股必然会有相应的反弹；如果疫苗效果不好，情况也不会比现在更糟，投资的损失也不会过大。那么基于这样的投资支点，我在 2021 年的元旦前后以 17.1 的价格买入美国航空。时间来到 2021 年 6 月，美国疫苗覆盖率已经超过 60%，疫苗的效果也非常好，新增患者大幅下降，加州甚至已经宣布从 6 月 15 日开始，重启所有商业活动。因此，航空股的股价也像我当初估计的那样大幅上涨。但是要注意的是，到现在为止，当初的投资支点已经消失了，因为美国航空的股价已经恢复到接近疫情前的价格，美国疫情的最糟糕时刻也已经过去，能够支撑航空股价格修复的支点已经不存在了。所以，我在 2021 年 6 月 3 日以 24.5 的价格卖出该支股票，这半年的收益率为 43.3%。</code></pre><h3 id="止盈和止损的本质是什么？"><a href="#止盈和止损的本质是什么？" class="headerlink" title="止盈和止损的本质是什么？"></a>止盈和止损的本质是什么？</h3><p>有了支点投资法的框架，我们就可以在这个基础上，很好地回答一个投资领域的关键问题：到底如何做止盈和止损？如果你认识不清这个问题，就永远无法真正把钱赚到自己的口袋里。因为你即使在一次两次投资中侥幸赚到了钱，也会因为没有合理的止盈止损体系，在未来的投资中凭实力把钱亏回去。<br>那么“止盈”和“止损”的本质到底是什么呢？表面看起来，这是投资中两种截然不同的结局，但它们其实在本质上是统一的。因为无论是“止盈”还是“止损”，都在做同一件事，就是“退出”。而“退出”的原因，有且只有一个，那就是你当初那个投资支点的崩塌。从三个不同的角度，用三句话来“翻译翻译”什么叫作“投资支点的崩塌”。</p><ol><li>为了进行一次主动投资，你首先要做的肯定是做出一个投资假设，来指导你的投资行为。在投资行为发生后，如果最初的这个投资假设已经不成立了，那么就应该选择退出，不管是止盈还是止损。</li><li>在投资行为发生之前，你一定要有一个投资理由，或者说理论支撑。当这个支撑不存在的时候，就应该止盈或者止损。</li><li>我们在投资开始时，其实总会为我们的投资找寻一个支点，你之后所有的行为都是建立在这个支点之上的。当这个支点消失的时候，你难道不应该退出重来吗？</li></ol><p>显然，这三句话说的都是一回事，重要的事情说三遍。</p><h2 id="摆正心态，知己知彼"><a href="#摆正心态，知己知彼" class="headerlink" title="摆正心态，知己知彼"></a>摆正心态，知己知彼</h2><p>自信和淡定的投资心态，往往是投资过程中最重要的。那我们应该怎么摆正心态呢？我觉得完全可以用一个词来概括，那就是“知己知彼”，也就是对自己、投资标的和交易对手都有清晰的认知，只有这样才能避免成为被收割的“韭菜”。<br>事实上，投资者被割韭菜，往往不是因为“技不如人”，而在于无法接受自己只是一个普通人。巴菲特的老师格雷厄姆，曾不只一次地向普通投资者们推荐购买“指数基金”，建议他们不要做各种“花式”的主动投资。这是因为，绝大多数的普通投资者都不具备高超的投资技巧和过人的天赋，被动地配置指数基金，往往就是保持财富与市场一同增值的最好办法。如果你过分自信地主动瞎操作，反而很可能被别有用心的人割韭菜。<br>所以，我们绝大多数人在投资前，都应该对自己说三句话：</p><ul><li>这辈子我不可能只靠投资就实现财富自由；</li><li>我不可能是那个万中无一的幸运儿，刚开始投资就能稳定盈利；</li><li>如果我在投资的时候随意操作，不讲投资逻辑，就算一时靠运气挣到了钱，也早晚会被亏光。</li></ul><p>只要你清楚了这三点，我相信就算你什么都不做，只靠着合理的资产配置被动投资，就能超过市场上50% 的投资。如果你不满足于此，准备尝试主动投资来赚取更多收益，那“知己知彼”这一点对你来说就更为重要了。而要做到“知己”，就要跳出那些常见的投资误区，想清楚自己作为一名普通投资者的优势，摆正心态。</p><h3 id="误区一：加入多个炒股群，盲从“炒股专家”或电视炒股节目的意见"><a href="#误区一：加入多个炒股群，盲从“炒股专家”或电视炒股节目的意见" class="headerlink" title="误区一：加入多个炒股群，盲从“炒股专家”或电视炒股节目的意见"></a>误区一：加入多个炒股群，盲从“炒股专家”或电视炒股节目的意见</h3><p>很多个人投资者喜欢听同事、专家的意见，加入很多炒股群、理财群，期望获取一些独家的信息和技巧。我们且不论这些意见到底有没有用，先从上一讲介绍的“支点投资法”出发，分析一下“听专家意见投资”的弊端。在你跟随某位专家投资的时候，其实是默认这个专家的意见就是你的“投资支点”。也许这位专家的意见是对的，但是支点投资法要求你不断验证这个投资支点还存不存在，你不清楚专家作出这个决策时的内在逻辑，又如何去作出验证呢？而且，在支点投资法中，退出的条件是支点的崩塌。思考一下，你是听专家意见买入的，那么这位专家能够如此认真负责，专门通知你要退出了吗？<br>退一步说，我们就假设这位专家确实很厉害，你买入和卖出都是跟他操作的，这就意味着你投资的唯一支点就是这位专家的意见。他管得了你一次投资，他能管你一辈子吗？他能时时刻刻地、毫无保留地把他所有的投资决策都分享给你吗？这显然是不现实的。<br>其实管理自己的个人财富，就像锻炼身体、抚养子女、学习知识一样，是人一生中最重要的体验之一，只可能通过你自己的思考和经验的积累来完成。任何依赖他人的想法，都是幼稚和不可持续的。对于专家的意见，我们应该持一种“拿来主义”的态度，重要的是吸收消化，转化成你自己做决策的能力。只有这样，你才能成为独立成熟的个人投资者。</p><h3 id="误区二：盲目自大，频繁短期操作"><a href="#误区二：盲目自大，频繁短期操作" class="headerlink" title="误区二：盲目自大，频繁短期操作"></a>误区二：盲目自大，频繁短期操作</h3><p>在投资的初期，大部分人都有盲目自大的心态。刚炒股的时候，运气比较好，赚了一些钱，就认为自己非常厉害，天赋异禀，不再是一个普普通通的人了。在这种心态下，开始进行频繁的短期操作，不操作就觉得手痒痒，感觉不这样就体现不出我的聪明才智。结果亏的底朝天。<br>一般来说，市场上做中高频交易并且能够盈利的人，几乎都是专业投资者：有依托强大投研团队的基金经理；有每天至少花 4 小时交易、5 小时复盘的私募交易员；还有全体成员都是名校毕业，国内外投资经验都异常丰富的量化投资团队。而我们作为一个普通投资者，把自己放在他们的对立面，真的有胜算吗？<br>两种可以靠频繁短线操作盈利的方式：一是通过高频交易模型，利用大数据、强大的算力、低延迟的交易系统以及交易所的返点实现；二是只交易自己特别熟悉的几只股票，并且有大量交易经验和超出常人的投资天赋。有一句话说得好：“不要拿自己的业余爱好挑战别人的专业。”更何况在投资领域，这里的“别人”往往就是这个世界上最聪明的一群人。要记住，我们仅仅是普通投资者，不要主动把自己扮成韭菜，送到别人的“镰刀”下。</p><h3 id="误区三：谨小慎微，只敢把钱放银行存定期"><a href="#误区三：谨小慎微，只敢把钱放银行存定期" class="headerlink" title="误区三：谨小慎微，只敢把钱放银行存定期"></a>误区三：谨小慎微，只敢把钱放银行存定期</h3><p>和过度自信、频繁操作的投资者相比，有的同学会陷入另一个极端：曾经因为炒股或者投P2P 亏过钱，就“一朝被蛇咬，十年怕井绳”，什么投资都不敢做了。其实，这样的行为同样是韭菜行为，只不过收割你的不是那些专业投资者，而是通货膨胀，是上涨的房价，是你错过的一个又一个投资机会。<br>一个人的财富永远都是相对的，别人的财富都按照 7% 的速度增长，而你的财富放在银行，按照 3% 的速度增长，这本身就是一种财富的缩水。举个例子：十年前，用 100 万能在北京海淀区买一套一居室，这十年中你把 100 万放在银行，现在成了 140 万，却只能在海淀区买一个厕所了。<br>我们建立财富双塔结构，是希望让你的财富飞轮越转越快，不是让你的财富越来越缩水的。把你的钱置换成优质的财富资源，再通过科学的方法进行主动配置，才能够实现财富的保值和增值。</p><p>和专业投资者相比，普通投资者的优势在哪？</p><h3 id="优势一：长钱优势"><a href="#优势一：长钱优势" class="headerlink" title="优势一：长钱优势"></a>优势一：长钱优势</h3><p>个人投资者最大的优势就是长钱优势。这里的“长钱”，指的是可以长期不被挪动，只用于投资的资金。机构投资者使用的资金都是代理人的，而代理人在遇到较大的回撤时，对机构投资者的信任就会崩塌，产生大量的赎回行为。<br>表面上看机构投资者的优势非常突出，其实他们也有很多的无奈。尽管机构投资者有来自顶级名校的团队成员，有丰富的投资经验，有体量大的资金，有取之不尽的投研资源，但是他们最大的无奈就是他们的钱不是长钱。一方面，什么时候卖出更多是由他们的客户决定的；另一方面，机构投资者还背负着巨大的短期业绩压力。所以，一些收益最丰厚的长期投资机会，机构投资者就只能忍痛舍弃。<br>相比而言，普通投资者的资金是自己的，如何投资全凭自己控制，是真正的长钱。理解了这一点，你就会意识到：在长期投资这条赛道上，机构投资者是有先天缺陷的。这就是普通投资者在长期投资这条赛道上“克敌制胜”的客观基础。<br>利用长钱优势，你可以在底部逐步买入一个被低估的投资标的，并耐心地长期持有。而世界上一流的投资机会，往往都需要长期的持有，只有具备真知灼见的个人投资者才有可能好好把握它。这是专业的机构投资者无法比拟的优势。</p><h3 id="优势二：专业信息优势"><a href="#优势二：专业信息优势" class="headerlink" title="优势二：专业信息优势"></a>优势二：专业信息优势</h3><p>对个人投资者而言，除了长期投资的机会，还有一些特殊赛道的机会，如果把握住了，是真有可能改变你的人生的。这种机遇只会出现在你最熟悉的，有认知优势的细分领域。这种对某个细分领域的认知优势，称之为个人投资者的“专业信息优势”。<br>专业信息优势主要来自于我们长期从事的行业。因为是业内人士，所以有着领先于市场的认知，即使遇到自己解答不了的问题，也有可利用的资源去进一步求证。最关键的是，我们对自己所在的行业的判断更有信心，这样才能在长期投资中坚守信念。<br>举一个最简单的例子：一位在特斯拉或者蔚来汽车上班的程序员，对于新能源汽车领域的认识，一定远远高于其他投资者，甚至高于专业的投资机构。这时，利用自己的专业知识，在法律允许的范围内，去投资领域内的关联公司股票，就是一种利用专业信息优势进行投资的理性行为。<br>关于利用专业信息优势进行投资的具体实例，我们会在后续的课程中深入讨论。在这里你只需要明白一点：弄清楚你对哪些领域的专业认知超过他人，然后利用这个信息优势投资。在你的专业赛道上获得成功的概率要远远高于其他的投资赛道。</p><h3 id="优势三：程序员优势"><a href="#优势三：程序员优势" class="headerlink" title="优势三：程序员优势"></a>优势三：程序员优势</h3><p>最后一个优势，它完全属于我们程序员群体，我把它叫做“程序员优势”。毫不夸张地说，程序员是当今世界不断进步的推动者。借助于先进的工具和硬件设备，不断累积的商业大数据以及先进的算法模型，程序员们极大地改变了很多传统行业的运转效率。每一个传统行业被互联网赋能之后，都会发生翻天覆地的变化。<br>而投资，就是一项高度依赖信息的活动，需要持续地搜集和分析信息，不同的投资机构之间，PK 的就是信息搜集和分析的能力，而这两方面的能力都可以被先进的工具极大地赋能。熟悉这些先进工具的程序员们，必定拥有着领先于时代的优势。<br>在这里，作为一名程序员的你可能会有疑问：专业投资机构那么有钱，聘用一些优秀的程序员去提高它们团体数据分析、算法开发的能力不就行了，我们个人程序员还会有什么优势呢？<br>其实不用这么悲观。大型投资机构的高管，他们一般是传统投资出身，并不熟悉现在互联网最先进的工具，以及很多最新的机器学习的知识。而一个人对于自己不熟悉的领域，有着本能的不信任，这样的不信任甚至是刻在公司基因中的。所以我可以自信地说，当时代发生变革的时候，推动社会进步的力量更可能来自于初创企业，甚至是程序员个人。清楚了这一点，我们就应该知道：如果能够在投资过程中，发挥我们程序员的工具优势、模型优势，来构建一些量化的交易算法或者系统，是完全有可能在投资的过程中胜出的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;财富课&quot;&gt;&lt;a href=&quot;#财富课&quot; class=&quot;headerlink&quot; title=&quot;财富课&quot;&gt;&lt;/a&gt;财富课&lt;/h1&gt;&lt;p&gt;英文中有个词叫“low hanging fruit”，字面意思是“挂得很低的、容易摘的果实”，含义是那些容易实现的目标。我相信，一个</summary>
      
    
    
    
    <category term="own" scheme="http://example.com/categories/own/"/>
    
    
  </entry>
  
  <entry>
    <title>陈硕网络编程</title>
    <link href="http://example.com/p/f5437bc6.html"/>
    <id>http://example.com/p/f5437bc6.html</id>
    <published>2024-01-21T02:22:25.649Z</published>
    <updated>2024-01-22T09:22:50.251Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程存在以下问题：</p><ul><li>TCP通信中存在不完整数据的接收问题。</li><li>和业务代码冗余。</li><li>在使用TCP时，难以准确确定消息的边界。</li><li>尝试向对等方发送C结构可能导致问题。<ul><li>修改全局对齐设置可能引发第三方库的core dump。</li></ul></li><li>存在TCP自连接问题，即本地主机之间的连接出现异常。</li><li>在非阻塞网络编程中遇到了其他许多问题。</li></ul><h1 id="简单非并发"><a href="#简单非并发" class="headerlink" title="简单非并发"></a>简单非并发</h1><ol><li>TTCP（Throughput Test of TCP）： 一个经典的TCP性能测试工具。</li><li>Round-trip（往返时间）： 用于测量两个主机之间的时钟误差。</li><li>Netcat（nc）： 一种瑞士军刀般的网络工具，可执行多种网络操作。</li><li>Slow sink&#x2F;source(慢接收&#x2F;发送)： 模拟数据接收或发送速度较慢的问题，可能导致性能下降。</li></ol><h2 id="TTCP"><a href="#TTCP" class="headerlink" title="TTCP"></a>TTCP</h2><h1 id="并发非阻塞"><a href="#并发非阻塞" class="headerlink" title="并发非阻塞"></a>并发非阻塞</h1><ol><li><p>.SOCKS代理服务器： 一个实现SOCKS协议的代理服务器，用于在网络上转发请求。</p><ol><li>中继两个TCP连接： 在两个TCP连接之间进行中继，将数据从一个连接传递到另一个连接。</li></ol></li><li><p>数独求解器： 一个用于解决数独谜题的程序。、</p><ol><li>许多服务适用于请求-响应模型：提到许多服务可以在请求-响应模型中进行处理。</li></ol></li><li><p>简单的memcached： 描述了一个简单的内存缓存服务，可能是在处理请求时进行缓存操作。</p></li><li><p>向多个TCP对等体广播： 描述了将信息同时发送到多个TCP连接的情况</p><ol><li>如何处理慢接收者： 提出了一个问题，即如何应对数据接收速度较慢的情况。</li></ol></li></ol><h1 id="多台机器（machines）的数据处理"><a href="#多台机器（machines）的数据处理" class="headerlink" title="多台机器（machines）的数据处理"></a>多台机器（machines）的数据处理</h1><ul><li><p>N皇后 一种并行处理的模式</p></li><li><p>跨机器的数字中位数： 在多台机器上计算一组数字的中位数。</p></li><li><p>频繁查询： 处理频繁查询的任务，可能涉及到对大量查询进行高效处理。</p></li><li><p>分布式排序： 使用多台机器进行分布式排序，将大量数据分散到不同机器上进行排序。</p></li></ul><h1 id="前沿方面"><a href="#前沿方面" class="headerlink" title="前沿方面"></a>前沿方面</h1><ul><li>RPC </li><li>负载均衡</li><li>服务系统容量管理</li><li>延迟</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程存在以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP通信中存在不完整数据的接收问题。&lt;/li&gt;
&lt;li&gt;和业务代码冗余。&lt;/li&gt;
&lt;li&gt;在使用TCP时，难以准确确定消息的边界。&lt;/li&gt;
&lt;li&gt;尝试向对等方发送C结构可能导致问题。&lt;ul&gt;
&lt;li&gt;修改全局对齐设置</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="陈硕" scheme="http://example.com/tags/%E9%99%88%E7%A1%95/"/>
    
  </entry>
  
  <entry>
    <title>连接无效</title>
    <link href="http://example.com/p/9039d1e3.html"/>
    <id>http://example.com/p/9039d1e3.html</id>
    <published>2024-01-10T15:31:19.453Z</published>
    <updated>2024-01-22T09:22:50.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连接无效"><a href="#连接无效" class="headerlink" title="连接无效"></a>连接无效</h1><p>在很多情况下，连接的一端需要一直感知连接的状态，如果连接无效了，应用程序可能需要报错，或者重新发起连接等。保持对连接有效性的检测，是我们在实战中必须要注意的一个点。</p><h2 id="TCP-Keep-Alive-选项"><a href="#TCP-Keep-Alive-选项" class="headerlink" title="TCP Keep-Alive 选项"></a>TCP Keep-Alive 选项</h2><p>在没有数据读写的“静默”的连接上，是没有办法发现 TCP 连接是有效还是无效的。比如客户端突然崩溃，服务器端可能在几天内都维护着一个无用的 TCP 连接。那么有没有办法开启类似的“轮询”机制，让 TCP 告诉我们，连接是不是“活着”的呢？，这就是 TCP 保持活跃机制所要解决的问题。实际上，TCP 有一个保持活跃的机制叫做Keep-Alive。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。<br>上述的可定义变量，分别被称为保活时间、保活时间间隔和保活探测次数。在 Linux 系统中，这些变量分别对应 sysctl 变量net.ipv4.tcp_keepalive_time、net.ipv4.tcp_keepalive_intvl、 net.ipv4.tcp_keepalve_probes，默认设置是 7200 秒（2小时）、75 秒和 9 次探测。<br>如果开启了 TCP 保活，需要考虑以下几种情况：<br>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。<br>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。<br>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该TCP 连接已经死亡。<br>TCP 保活机制默认是关闭的，当我们选择打开时，可以分别在连接的两个方向上开启，也可以单独在一个方向上开启。如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；而开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接。<br>为什么 TCP 不提供一个频率很好的保活机制呢？早期的网络带宽非常有限，如果提供一个频率很高的保活机制，对有限的带宽是一个比较严重的浪费。</p><h2 id="应用层探活"><a href="#应用层探活" class="headerlink" title="应用层探活"></a>应用层探活</h2><p>如果使用 TCP 自身的 keep-Alive 机制，在 Linux 系统中，最少需要经过 2 小时 11 分 15秒才可以发现一个“死亡”连接。这个时间是怎么计算出来的呢？其实是通过 2 小时，加上 75 秒乘以 9 的总和。实际上，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。<br>所以，必须在应用程序这一层来寻找更好的解决方案。<br>我们可以通过在应用程序中模拟 TCP Keep-Alive 机制，来完成在应用层的连接探活。我们可以设计一个 PING-PONG 的机制，需要保活的一方，比如客户端，在保活时间达到后，发起对连接的 PING 操作，如果服务器端对 PING 操作有回应，则重新设置保活时间，否则对探测次数进行计数，如果最终探测次数达到了保活探测次数预先设置的值之后，则认为连接已经无效。<br>这里有两个比较关键的点：<br>第一个是需要使用定时器，这可以通过使用 I&#x2F;O 复用自身的机制来实现；第二个是需要设计一个 PING-PONG 的协议。下面我们尝试来完成这样的一个设计。</p><h2 id="消息格式设计"><a href="#消息格式设计" class="headerlink" title="消息格式设计"></a>消息格式设计</h2><p>我们的程序是客户端来发起保活，为此定义了一个消息对象。你可以在文稿中看到这个消息<br>对象，这个消息对象是一个结构体，前 4 个字节标识了消息类型，为了简单，这里设计了M<br>SG_PING、MSG_PONG、MSG_TYPE 1和MSG_TYPE 2四种消息类型。</p><pre><code>1 typedef struct &#123;2 u_int32_t type;3 char data[1024];4 &#125; messageObject;56 #define MSG_PING 17 #define MSG_PONG 28 #define MSG_TYPE1 119 #define MSG_TYPE2 21</code></pre><h2 id="客户端程序设计"><a href="#客户端程序设计" class="headerlink" title="客户端程序设计"></a>客户端程序设计</h2><p>客户端完全模拟 TCP Keep-Alive 的机制，在保活时间达到后，探活次数增加 1，同时向服务器端发送 PING 格式的消息，此后以预设的保活时间间隔，不断地向服务器端发送 PING格式的消息。如果能收到服务器端的应答，则结束保活，将保活时间置为 0。这里我们使用 select I&#x2F;O 复用函数自带的定时器。</p><pre><code>#include &quot;lib/common.h&quot;#include &quot;message_objecte.h&quot; // 假设这是消息对象的头文件#define MAXLINE 4096#define KEEP_ALIVE_TIME 10#define KEEP_ALIVE_INTERVAL 3#define KEEP_ALIVE_PROBETIMES 3int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;);    &#125;    int socket_fd;    socket_fd = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len);    if (connect_rt &lt; 0) &#123;        error(1, errno, &quot;connect failed &quot;);    &#125;    char recv_line[MAXLINE + 1];    int n;    fd_set readmask;    fd_set allreads;    struct timeval tv;    int heartbeats = 0;    tv.tv_sec = KEEP_ALIVE_TIME;    tv.tv_usec = 0;    messageObject messageObject; // 假设这是消息对象的实例    FD_ZERO(&amp;allreads);    FD_SET(socket_fd, &amp;allreads);    for (;;) &#123;        readmask = allreads;        int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, &amp;tv);        if (rc &lt; 0) &#123;            error(1, errno, &quot;select failed&quot;);        &#125;        if (rc == 0) &#123;            // 超时，发送心跳消息            if (++heartbeats &gt; KEEP_ALIVE_PROBETIMES) &#123;                error(1, 0, &quot;connection dead\n&quot;);            &#125;            printf(&quot;sending heartbeat #%d\n&quot;, heartbeats);            messageObject.type = htonl(MSG_PING);            rc = send(socket_fd, (char *) &amp;messageObject, sizeof(messageObject), 0);            if (rc &lt; 0) &#123;                error(1, errno, &quot;send failure&quot;);            &#125;            tv.tv_sec = KEEP_ALIVE_INTERVAL;            continue;        &#125;        if (FD_ISSET(socket_fd, &amp;readmask)) &#123;            // 接收服务器消息，判断心跳            n = read(socket_fd, recv_line, MAXLINE);            if (n &lt; 0) &#123;                error(1, errno, &quot;read error&quot;);            &#125; else if (n == 0) &#123;                error(1, 0, &quot;server terminated \n&quot;);            &#125;            printf(&quot;received heartbeat, reset heartbeats to 0 \n&quot;);            heartbeats = 0;            tv.tv_sec = KEEP_ALIVE_TIME;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="服务器端程序设计"><a href="#服务器端程序设计" class="headerlink" title="服务器端程序设计"></a>服务器端程序设计</h2><p>服务器端的程序接受一个参数，这个参数设置的比较大，可以模拟连接没有响应的情况。服务器端程序在接收到客户端发送来的各种消息后，进行处理，其中如果发现是 PING 类型的消息，在休眠一段时间后回复一个 PONG 消息，告诉客户端：”嗯，我还活着。“当然，如果这个休眠时间很长的话，那么客户端就无法快速知道服务器端是否存活，这是我们模拟连接无响应的一个手段而已，实际情况下，应该是系统崩溃，或者网络异常。</p><pre><code>#include &quot;lib/common.h&quot;#include &quot;message_objecte.h&quot; // 假设这是消息对象的头文件#define MAXLINE 4096#define KEEP_ALIVE_TIME 10#define KEEP_ALIVE_INTERVAL 3#define KEEP_ALIVE_PROBETIMES 3int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;);    &#125;    int socket_fd;    socket_fd = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len);    if (connect_rt &lt; 0) &#123;        error(1, errno, &quot;connect failed &quot;);    &#125;    char recv_line[MAXLINE + 1];    int n;    fd_set readmask;    fd_set allreads;    struct timeval tv;    int heartbeats = 0;    tv.tv_sec = KEEP_ALIVE_TIME;    tv.tv_usec = 0;    messageObject messageObject; // 假设这是消息对象的实例    FD_ZERO(&amp;allreads);    FD_SET(socket_fd, &amp;allreads);    for (;;) &#123;        readmask = allreads;        int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, &amp;tv);        if (rc &lt; 0) &#123;            error(1, errno, &quot;select failed&quot;);        &#125;        if (rc == 0) &#123;            // 超时，发送心跳消息            if (++heartbeats &gt; KEEP_ALIVE_PROBETIMES) &#123;                error(1, 0, &quot;connection dead\n&quot;);            &#125;            printf(&quot;sending heartbeat #%d\n&quot;, heartbeats);            messageObject.type = htonl(MSG_PING);            rc = send(socket_fd, (char *) &amp;messageObject, sizeof(messageObject), 0);            if (rc &lt; 0) &#123;                error(1, errno, &quot;send failure&quot;);            &#125;            tv.tv_sec = KEEP_ALIVE_INTERVAL;            continue;        &#125;        if (FD_ISSET(socket_fd, &amp;readmask)) &#123;            // 接收服务器消息，判断心跳            n = read(socket_fd, recv_line, MAXLINE);            if (n &lt; 0) &#123;                error(1, errno, &quot;read error&quot;);            &#125; else if (n == 0) &#123;                error(1, 0, &quot;server terminated \n&quot;);            &#125;            printf(&quot;received heartbeat, reset heartbeats to 0 \n&quot;);            heartbeats = 0;            tv.tv_sec = KEEP_ALIVE_TIME;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>基于上面的程序设计，让我们分别做两个不同的实验：<br>第一次实验，服务器端休眠时间为 60 秒。<br>我们看到，客户端在发送了三次心跳检测报文 PING 报文后，判断出连接无效，直接退出了。之所以造成这样的结果，是因为在这段时间内没有接收到来自服务器端的任何 PONG报文。当然，实际工作的程序，可能需要不一样的处理，比如重新发起连接。</p><p>1 $.&#x2F;pingclient 127.0.0.1<br>2 sending heartbeat #1<br>3 sending heartbeat #2<br>4 sending heartbeat #3<br>5 connection dead</p><p>1 $.&#x2F;pingserver 60<br>2 received 1028 bytes<br>3 received 1028 bytes</p><p>第二次实验，我们让服务器端休眠时间为 5 秒。<br>我们看到，由于这一次服务器端在心跳检测过程中，及时地进行了响应，客户端一直都会认为连接是正常的。</p><pre><code>1 $./pingclient 127.0.0.12 sending heartbeat #13 sending heartbeat #24 received heartbeat, make heartbeats to 05 received heartbeat, make heartbeats to 06 sending heartbeat #17 sending heartbeat #28 received heartbeat, make heartbeats to 09 received heartbeat, make heartbeats to 01 $./pingserver 52 received 1028 bytes3 received 1028 bytes4 received 1028 bytes5 received 1028 bytes</code></pre><p>到虽然 TCP 没有提供系统的保活能力，让应用程序可以方便地感知连接的存活，但是，我们可以在应用程序里灵活地建立这种机制。一般来说，这种机制的建立依赖于系统定时器，以及恰当的应用层报文协议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;连接无效&quot;&gt;&lt;a href=&quot;#连接无效&quot; class=&quot;headerlink&quot; title=&quot;连接无效&quot;&gt;&lt;/a&gt;连接无效&lt;/h1&gt;&lt;p&gt;在很多情况下，连接的一端需要一直感知连接的状态，如果连接无效了，应用程序可能需要报错，或者重新发起连接等。保持对连接有效性的</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>优雅地关闭还是粗暴地关闭</title>
    <link href="http://example.com/p/85cb9c0c.html"/>
    <id>http://example.com/p/85cb9c0c.html</id>
    <published>2024-01-10T14:15:01.931Z</published>
    <updated>2024-01-22T09:22:50.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优雅地关闭还是粗暴地关闭"><a href="#优雅地关闭还是粗暴地关闭" class="headerlink" title="优雅地关闭还是粗暴地关闭"></a>优雅地关闭还是粗暴地关闭</h1><p>TCP 的四次挥手，其中发起连接关闭的一方会有一段时间处于TIME_WAIT 状态。那么究竟如何来发起连接关闭呢？一个 TCP 连接需要经过三次握手进入数据传输阶段，最后来到连接关闭阶段。在最后的连接关闭阶段，我们需要重点关注的是“半连接”状态。因为 TCP 是双向的，这里说的方向，指的是数据流的写入 - 读出的方向。比如客户端到服务器端的方向，指的是客户端通过套接字接口，向服务器端发送 TCP 报文；而服务器端到客户端方向则是另一个传输方向。在绝大数情况下，TCP 连接都是先关闭一个方向，此时另外一个方向还是可以正常进行数据传输。</p><p>客户端主动发起连接的中断，将自己到服务器端的数据流方向关闭，此时，客户端不再往服务器端写入数据，服务器端读完客户端数据后就不会再有新的报文到达。但这并不意味着，TCP 连接已经完全关闭，很有可能的是，服务器端正在对客户端的最后报文进行处理，比如去访问数据库，存入一些数据；或者是计算出某个客户端需要的值，当完成这些操作之后，服务器端把结果通过套接字写给客户端，我们说这个套接字的状态此时是“半关闭”的。最后，服务器端才有条不紊地关闭剩下的半个连接，结束这一段 TCP 连接的使命。<br>这里描述的，是服务器端“优雅”地关闭了连接。如果服务器端处理不好，就会导致最后的关闭过程是“粗暴”的，达不到我们上面描述的“优雅”关闭的目标，形成的后果，很可能是服务器端处理完的信息没办法正常传送给客户端，破坏了用户侧的使用场景。</p><h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><p>首先，我们来看最常见的 close 函数：</p><pre><code>int close(int sockfd)</code></pre><p>这个函数很简单，对已连接的套接字执行 close 操作就可以，若成功则为 0，若出错则为-1. 这个函数会对套接字引用计数减一，一旦发现套接字引用计数到 0，就会对套接字进行彻底释放，并且会关闭TCP 两个方向的数据流。套接字引用计数是什么意思呢？因为套接字可以被多个进程共享，你可以理解为我们给每个套接字都设置了一个积分，如果我们通过 fork 的方式产生子进程，套接字就会积分 +1，如果我们调用一次 close 函数，套接字积分就会 -1。这就是套接字引用计数的含义。</p><p>close 函数具体是如何关闭两个方向的数据流呢？<br>在输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常。在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN报文，接下来如果再对该套接字进行写操作会返回异常。<br>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文，告诉对端：“Hi, 我已经关闭了，别再给我发数据了。”<br>我们会发现，close 函数并不能帮助我们关闭连接的一个方向，那么如何在需要的时候关闭一个方向呢？幸运的是，设计 TCP 协议的人帮我们想好了解决方案，这就是 shutdown 函数。</p><h2 id="shutdown-函数"><a href="#shutdown-函数" class="headerlink" title="shutdown 函数"></a>shutdown 函数</h2><p>shutdown 函数的原型是这样的：</p><pre><code>int shutdown(int sockfd, int howto)</code></pre><p>对已连接的套接字执行 shutdown 操作，若成功则为 0，若出错则为 -1。howto 是这个函数的设置选项，它的设置有三个主要选项：<br>SHUT_RD(0)：关闭连接的“读”这个方向，对该套接字进行读操作直接返回 EOF。从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。<br>SHUT_WR(1)：关闭连接的“写”这个方向，这就是常被称为”半关闭“的连接。此时，不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端。应用程序如果对该套接字进行写操作会报错。<br>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向。</p><p>讲到这里，不知道你是不是有和我当初一样的困惑，使用 SHUT_RDWR 来调用 shutdown不是和 close 基本一样吗，都是关闭连接的读和写两个方向。</p><p>其实，这两个还是有差别的。<br>第一个差别：close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源。<br>第二个差别：close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响。<br>第三个差别：close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文，这在我们打算关闭连接通知对端的时候，是非常重要的。</p><h2 id="close-和-shutdown-的差别"><a href="#close-和-shutdown-的差别" class="headerlink" title="close 和 shutdown 的差别"></a>close 和 shutdown 的差别</h2><p>下面，我们通过构建一组客户端和服务器程序，来进行 close 和 shutdown 的实验。客户端程序，从标准输入不断接收用户输入，把输入的字符串通过套接字发送给服务器端，同时，将服务器端的应答显示到标准输出上。<br>如果用户输入了“close”，则会调用 close 函数关闭连接，休眠一段时间，等待服务器端处理后退出；如果用户输入了“shutdown”，调用 shutdown 函数关闭连接的写方向，注意我们不会直接退出，而是会继续等待服务器端的应答，直到服务器端完成自己的操作，在另一个方向上完成关闭。使用select 使得我们可以同时完成对连接套接字和</p><pre><code>#include &quot;lib/common.h&quot;#define MAXLINE 4096int main(int argc, char **argv) &#123;    // 检查命令行参数    if (argc != 2) &#123;        error(1, 0, &quot;usage: graceclient &lt;IPaddress&gt;&quot;);    &#125;    // 创建套接字并初始化服务器地址结构    int socket_fd;    socket_fd = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    // 连接到服务器    int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len);    if (connect_rt &lt; 0) &#123;        error(1, errno, &quot;connect failed &quot;);    &#125;    char send_line[MAXLINE], recv_line[MAXLINE + 1];    int n;    fd_set readmask, allreads;    // 初始化文件描述符集合    FD_ZERO(&amp;allreads);    FD_SET(0, &amp;allreads);      // 标准输入    FD_SET(socket_fd, &amp;allreads);  // 服务器套接字    for (;;) &#123;        readmask = allreads;        // 使用select函数监视文件描述符的可读状态        int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, NULL);        if (rc &lt;= 0)            error(1, errno, &quot;select failed&quot;);        // 如果服务器套接字可读，读取数据并输出到标准输出        if (FD_ISSET(socket_fd, &amp;readmask)) &#123;            n = read(socket_fd, recv_line, MAXLINE);            if (n &lt; 0) &#123;                error(1, errno, &quot;read error&quot;);            &#125; else if (n == 0) &#123;                error(1, 0, &quot;server terminated \n&quot;);            &#125;            recv_line[n] = 0;            fputs(recv_line, stdout);            fputs(&quot;\n&quot;, stdout);        &#125;        // 如果标准输入可读，从标准输入读取数据并发送给服务器        if (FD_ISSET(0, &amp;readmask)) &#123;            if (fgets(send_line, MAXLINE, stdin) != NULL) &#123;                if (strncmp(send_line, &quot;shutdown&quot;, 8) == 0) &#123;                    // 处理&quot;shutdown&quot;命令                    FD_CLR(0, &amp;allreads);                    if (shutdown(socket_fd, 1)) &#123;                        error(1, errno, &quot;shutdown failed&quot;);                    &#125;                &#125; else if (strncmp(send_line, &quot;close&quot;, 5) == 0) &#123;                    // 处理&quot;close&quot;命令                    FD_CLR(0, &amp;allreads);                    if (close(socket_fd)) &#123;                        error(1, errno, &quot;close failed&quot;);                    &#125;                    sleep(6);                    exit(0);                &#125; else &#123;                    // 发送数据给服务器                    int i = strlen(send_line);                    if (send_line[i - 1] == &#39;\n&#39;) &#123;                        send_line[i - 1] = 0;                    &#125;                    printf(&quot;now sending %s\n&quot;, send_line);                    size_t rt = write(socket_fd, send_line, strlen(send_line));                    if (rt &lt; 0) &#123;                        error(1, errno, &quot;write failed &quot;);                    &#125;                    printf(&quot;send bytes: %zu \n&quot;, rt);                &#125;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><p>服务器端程序稍微简单一点，连接建立之后，打印出接收的字节，并重新格式化后，发送给客户端。服务器端程序有一点需要注意，那就是对 SIGPIPE 这个信号的处理。</p><pre><code>#include &quot;lib/common.h&quot;static int count;// SIGINT信号处理函数static void sig_int(int signo) &#123;    printf(&quot;\nreceived %d datagrams\n&quot;, count);    exit(0);&#125;int main(int argc, char **argv) &#123;    int listenfd;    listenfd = socket(AF_INET, SOCK_STREAM, 0);    // 服务器地址初始化    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);    // 绑定套接字到服务器地址    int rt1 = bind(listenfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));    if (rt1 &lt; 0) &#123;        error(1, errno, &quot;bind failed &quot;);    &#125;    // 监听套接字    int rt2 = listen(listenfd, LISTENQ);    if (rt2 &lt; 0) &#123;        error(1, errno, &quot;listen failed &quot;);    &#125;    // 注册信号处理函数    signal(SIGINT, sig_int);    signal(SIGPIPE, SIG_IGN);    int connfd;    struct sockaddr_in client_addr;    socklen_t client_len = sizeof(client_addr);    // 接受客户端连接    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;client_addr, &amp;client_len)) &lt; 0)         error(1, errno, &quot;accept failed &quot;);    char message[MAXLINE];    count = 0;    for (;;) &#123;        // 从客户端读取数据        int n = read(connfd, message, MAXLINE);        if (n &lt; 0) &#123;            error(1, errno, &quot;error read&quot;);        &#125; else if (n == 0) &#123;            error(1, 0, &quot;client closed \n&quot;);        &#125;        message[n] = 0;        printf(&quot;received %d bytes: %s\n&quot;, n, message);        count++;        // 构造回复消息        char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, message);        // 模拟耗时操作，睡眠5秒        sleep(5);        // 发送回复消息给客户端        int write_nc = send(connfd, send_line, strlen(send_line), 0);        printf(&quot;send bytes: %d \n&quot;, write_nc);        if (write_nc &lt; 0) &#123;            error(1, errno, &quot;error write&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><p>我们启动服务器，再启动客户端，依次在标准输入上输入 data1、data2 和 close，观察一段时间后我们看到：</p><pre><code>$./graceclient 127.0.0.12 data13 now sending data14 send bytes:55 data26 now sending data27 send bytes:58 Hi,data19 close1 $./graceserver2 received 5 bytes: data13 send bytes: 94 received 5 bytes: data25 send bytes: 96 client closed  </code></pre><p>客户端依次发送了 data1 和 data2，服务器端也正常接收到 data1 和 data2。在客户端close 掉整个连接之后，服务器端接收到 SIGPIPE 信号，直接退出。客户端并没有收到服务器端的应答数据。<br>下面放了一张图，这张图详细解释了客户端和服务器端交互的时序图。因为客户端调用close 函数关闭了整个连接，当服务器端发送的“Hi, data1”分组到底时，客户端给回送一个 RST 分组；服务器端再次尝试发送“Hi, data2”第二个应答分组时，系统内核通知SIGPIPE 信号。这是因为，在 RST 的套接字进行写操作，会直接触发 SIGPIPE 信号。</p><p><img src="https://s11.ax1x.com/2024/01/10/pF9EziF.png" alt="pF9EziF.png"></p><p>我们可以像这样注册一个信号处理函数，对 SIGPIPE 信号进行处理，避免程序莫名退出：</p><pre><code>static void sig_pipe(int signo) &#123;printf(&quot;\nreceived %d datagrams\n&quot;, count);exit(0);&#125;signal(SIGINT, sig_pipe);</code></pre><p>接下来，再次启动服务器，再启动客户端，依次在标准输入上输入 data1、data2 和shutdown 函数，观察一段时间后我们看到：</p><pre><code>$./graceclient 127.0.0.12 data13 now sending data14 send bytes:55 data26 now sending data27 send bytes:58 shutdown9 Hi, data110 Hi，data211 server terminated1 $./graceserver2 received 5 bytes: data13 send bytes: 94 received 5 bytes: data25 send bytes: 96 client closed </code></pre><p>和前面的结果不同，服务器端输出了 data1、data2；客户端也输出了“Hi,data1”和“Hi,data2”，客户端和服务器端各自完成了自己的工作后，正常退出。我们再看下客户端和服务器端交互的时序图。因为客户端调用 shutdown 函数只是关闭连接的一个方向，服务器端到客户端的这个方向还可以继续进行数据的发送和接收，所以“Hi,data1”和“Hi,data2”都可以正常传送；当服务器端读到 EOF 时，立即向客户端<br>发送了 FIN 报文，客户端在 read 函数中感知了 EOF，也进行了正常退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优雅地关闭还是粗暴地关闭&quot;&gt;&lt;a href=&quot;#优雅地关闭还是粗暴地关闭&quot; class=&quot;headerlink&quot; title=&quot;优雅地关闭还是粗暴地关闭&quot;&gt;&lt;/a&gt;优雅地关闭还是粗暴地关闭&lt;/h1&gt;&lt;p&gt;TCP 的四次挥手，其中发起连接关闭的一方会有一段时间处于T</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TIME_WAIT</title>
    <link href="http://example.com/p/5550bb23.html"/>
    <id>http://example.com/p/5550bb23.html</id>
    <published>2024-01-10T09:30:38.601Z</published>
    <updated>2024-01-22T09:22:50.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h1><p>tcp连接 那里有部分该内容</p><h2 id="TIME-WAIT-发生的场景"><a href="#TIME-WAIT-发生的场景" class="headerlink" title="TIME_WAIT 发生的场景"></a>TIME_WAIT 发生的场景</h2><p>TCP 连接终止时，主机 1 先发送 FIN 报文，主机 2 进入 CLOSE_WAIT 状态，并发送一个ACK 应答，同时，主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文。主机 1 在接收到 FIN 报文后发送 ACK 应答，此时主机 1 进入TIME_WAIT 状态。<br>主机 1 在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximumsegment lifetime）的两倍，一般称之为 2MSL。和大多数 BSD 派生的系统一样，Linux系统里有一个硬编码的字段，名称为TCP_TIMEWAIT_LEN，其值为 60 秒。也就是说，Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。</p><pre><code>#define TCP_TIMEWAIT_LEN (60*HZ)</code></pre><p>过了这个时间之后，主机 1 就进入 CLOSED 状态。只有发起连接终止的一方会进入 TIME_WAIT 状态。</p><h2 id="TIME-WAIT-的作用"><a href="#TIME-WAIT-的作用" class="headerlink" title="TIME_WAIT 的作用"></a>TIME_WAIT 的作用</h2><p>为什么不直接进入 CLOSED 状态，而要停留在 TIME_WAIT 这个状态？</p><p>首先，这样做是为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。TCP 在设计的时候，做了充分的容错性设计，比如，TCP 假设报文会出错，需要重传。在这里，如果图中主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文。如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。现在主机 1 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态。</p><p>第二个理由和连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失。我们知道，在网络中，经常会发生报文经过一段时间才能到达目的地的情况，产生的原因是多种多样的，如路由器重启，链路突然出现故障等。如果迷走报文到达时，发现 TCP 连接四元组（源 IP，源端口，目的 IP，目的端口）所代表的连接不复存在，那么很简单，这个报文自然丢弃。我们考虑这样一个场景，在原连接中断后，又重新创建了一个原连接的“化身”，说是化身其实是因为这个连接和原先的连接四元组完全相同，如果迷失报文经过一段时间也到达，那么这个报文会被误认为是连接“化身”的一个 TCP 分节，这样就会对 TCP 通信产生影响。</p><p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的。2MSL 的时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的；如果在TIME_WAIT 时间内，因为主机 1 的 ACK 没有传输到主机2，主机 1 又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时。道理很简单，因为2MSL 的时间，目的是为了让旧连接的所有报文都能自然消亡，现在主机 1 重新发送了 ACK 报文，自然需要重新计时，以便防止这个 ACK 报文对新可能的连接化身造成干扰。</p><h2 id="TIME-WAIT-的危害"><a href="#TIME-WAIT-的危害" class="headerlink" title="TIME_WAIT 的危害"></a>TIME_WAIT 的危害</h2><p>过多的 TIME_WAIT 的主要危害有两种。<br>第一是内存资源占用，这个目前看来不是太严重，基本可以忽略。<br>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接。这个也是我们在一开始讲到的那个例子</p><h2 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h2><p>在高并发的情况下，如果我们想对 TIME_WAIT 做一些优化，该如何办呢？</p><h3 id="net-ipv4-tcp-max-tw-buckets"><a href="#net-ipv4-tcp-max-tw-buckets" class="headerlink" title="net.ipv4.tcp_max_tw_buckets"></a>net.ipv4.tcp_max_tw_buckets</h3><p>一个暴力的方法是通过 sysctl 命令，将系统值调小。这个值默认为 18000，当系统中处于TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p><h3 id="调低-TCP-TIMEWAIT-LEN，重新编译系统"><a href="#调低-TCP-TIMEWAIT-LEN，重新编译系统" class="headerlink" title="调低 TCP_TIMEWAIT_LEN，重新编译系统"></a>调低 TCP_TIMEWAIT_LEN，重新编译系统</h3><p>这个方法是一个不错的方法，缺点是需要“一点”内核方面的知识，能够重新编译内核。我想这个不是大多数人能接受的方式</p><h3 id="SO-LINGER-的设置"><a href="#SO-LINGER-的设置" class="headerlink" title="SO_LINGER 的设置"></a>SO_LINGER 的设置</h3><p>英文单词“linger”的意思为停留，我们可以通过设置套接字选项，来设置调用 close 或者shutdown 关闭连接时的行为。</p><pre><code>int setsockopt(int sockfd, int level, int optname, const void *optval,socklen_t optlen);struct linger &#123;    int l_onoff; /* 0=off, nonzero=on */    int l_linger; /* linger time, POSIX specifies units as seconds */&#125;</code></pre><p>设置 linger 参数有几种可能：</p><p>如果l_onoff为 0，那么关闭本选项。l_linger的值被忽略，这对应了默认行为，close 或 shutdown 立即返回。如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去。<br>如果l_onoff为非 0， 且l_linger值也为 0，那么调用 close 后，会立该发送一个RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在recv()调用上时，接受到RST 时，会立刻得到一个“connet reset by peer”的异常。</p><pre><code>struct linger so_linger;so_linger.l_onoff = 1;so_linger.l_linger = 0;setsockopt(s,SOL_SOCKET,SO_LINGER, &amp;so_linger,sizeof(so_linger));</code></pre><p>如果l_onoff为非 0， 且l_linger的值也非 0，那么调用 close 后，调用 close 的线程就将阻塞，直到数据被发送出去，或者设置的l_linger计时时间到。</p><p>第二种可能为跨越 TIME_WAIT 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><h3 id="net-ipv4-tcp-tw-reuse：更安全的设置"><a href="#net-ipv4-tcp-tw-reuse：更安全的设置" class="headerlink" title="net.ipv4.tcp_tw_reuse：更安全的设置"></a>net.ipv4.tcp_tw_reuse：更安全的设置</h3><p>那么 Linux 有没有提供更安全的选择呢？当然有。这就是net.ipv4.tcp_tw_reuse选项。<br>Linux 系统对于net.ipv4.tcp_tw_reuse的解释:从协议角度理解如果是安全可控的，可以复用处于TIME_WAIT 的套接字为新的连接所用。<br>那么什么是协议角度理解的安全可控呢？主要有两点：</p><ol><li>只适用于连接发起方（C&#x2F;S 模型中的客户端）；</li><li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用</li></ol><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_time stamps&#x3D;1（默认即为 1）<br>要知道，TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TIME-WAIT&quot;&gt;&lt;a href=&quot;#TIME-WAIT&quot; class=&quot;headerlink&quot; title=&quot;TIME_WAIT&quot;&gt;&lt;/a&gt;TIME_WAIT&lt;/h1&gt;&lt;p&gt;tcp连接 那里有部分该内容&lt;/p&gt;
&lt;h2 id=&quot;TIME-WAIT-发生的场景</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>select</title>
    <link href="http://example.com/p/c5176eb2.html"/>
    <id>http://example.com/p/c5176eb2.html</id>
    <published>2024-01-10T09:16:12.539Z</published>
    <updated>2024-01-10T09:18:20.206Z</updated>
    
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/p/f6491cfb.html"/>
    <id>http://example.com/p/f6491cfb.html</id>
    <published>2024-01-10T08:45:41.535Z</published>
    <updated>2024-01-22T09:22:50.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程模型"><a href="#网络编程模型" class="headerlink" title="网络编程模型"></a>网络编程模型</h2><h3 id="客户端-服务器网络编程模型"><a href="#客户端-服务器网络编程模型" class="headerlink" title="客户端 - 服务器网络编程模型"></a>客户端 - 服务器网络编程模型</h3><p>在谈论网络编程时，我们首先需要建立一个概念，也就是“客户端 - 服务器”。拿我们常用的网络购物来说，我们在手机上的每次操作，都是作为客户端向服务器发送请求，并收到响应的例子。</p><ol><li>当一个客户端需要服务时，比如网络购物下单，它会向服务器端发送一个请求。注意，这个请求是按照双方约定的格式来发送的，以便保证服务器端是可以理解的；</li><li>服务器端收到这个请求后，会根据双方约定的格式解释它，并且以合适的方式进行操作，比如调用数据库操作来创建一个购物单；</li><li>服务器端完成处理请求之后，会给客户端发送一个响应，比如向客户端发送购物单的实际付款额，然后等待客户端的下一步操作；</li><li>客户端收到响应并进行处理，比如在手机终端上显示该购物单的实际付款额，并且让用户选择付款方式。</li></ol><p>在网络编程中，具体到客户端 - 服务器模型时，我们经常会考虑是使用 TCP 还是 UDP，其实它们二者的区别也很简单：TCP 中连接是谁发起的，在 UDP 中报文是谁发送的。在TCP 通信中，建立连接是一个非常重要的环节。区别出客户端和服务器，本质上是因为二者编程模型是不同的。<br>服务器端需要在一开始就监听在一个众所周知的端口上，等待客户端发送请求，一旦有客户端连接建立，服务器端就会消耗一定的计算机资源为它服务，服务器端是需要同时为成千上万的客户端服务的。如何保证服务器端在数据量巨大的客户端访问时依然能维持效率和稳定，这也是我们讲述高性能网络编程的目的。<br>客户端相对来说更为简单，它向服务器端的监听端口发起连接请求，连接建立之后，通过连接通路和服务器端进行通信。<br>无论是客户端，还是服务器端，它们运行的单位都是进程（process），而不是机器。一个客户端，比如我们的手机终端，同一个时刻可以建立多个到不同服务器的连接，比如同时打游戏，上知乎，逛天猫；而服务器端更是可能在一台机器上部署运行了多个服务，比如同时开启了 SSH 服务和 HTTP 服务。</p><h4 id="IP-和端口"><a href="#IP-和端口" class="headerlink" title="IP 和端口"></a>IP 和端口</h4><p>在网络世界里，同样也需要地址的概念。在 TCP&#x2F;IP 协议栈中，IP 用来表示网络世界的地址。在一台计算机上是可以同时存在多个连接的，那么如何区分出不同的连接呢？这里就必须提到端口这个概念。我们拿住酒店举例子，酒店的地址是唯一的，每间房间的号码是不同的，类似的，计算机的 IP 地址是唯一的，每个连接的端口号是不同的。端口号是一个 16 位的整数，最多为 65536。当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为临时端口；然而，前面也提到过，服务器端的端口通常是一个众所周知的端口。一个连接可以通过客户端 - 服务器端的 IP 和端口唯一确定，这叫做套接字对，按照下面的四元组表示：</p><pre><code>（clientaddr:clientport, serveraddr: serverport)</code></pre><h4 id="保留网段"><a href="#保留网段" class="headerlink" title="保留网段"></a>保留网段</h4><p>一个比较常见的现象是，我们所在的单位或者组织，普遍会使用诸如 10.0.x.x 或者192.168.x.x 这样的 IP 地址，你可能会纳闷，这样的 IP 到底代表了什么呢？不同的组织使用同样的 IP 会不会导致冲突呢背后的原因是这样的，国际标准组织在 IPv4 地址空间里面，专门划出了一些网段，这些网段不会用做公网上的 IP，而是仅仅保留做内部使用，我们把这些地址称作保留网段。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>在网络 IP 划分的时候，我们需要区分两个概念。<br>第一是网络（network）的概念，直观点说，它表示的是这组 IP 共同的部分，比如在192.168.1.1<del>192.168.1.255 这个区间里，它们共同的部分是 192.168.1.0。<br>第二是主机（host）的概念，它表示的是这组 IP 不同的部分，上面的例子中 1</del>255 就是不同的那些部分，表示有 255 个可用的不同 IP。<br>例如 IPv4 地址，192.0.2.12，我们可以说前面三个 bytes 是子网，最后一个 byte 是host，或者换个方式，我们能说 host 为 8 位，子网掩码为192.0.2.0&#x2F;24（255.255.255.0）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络编程模型&quot;&gt;&lt;a href=&quot;#网络编程模型&quot; class=&quot;headerlink&quot; title=&quot;网络编程模型&quot;&gt;&lt;/a&gt;网络编程模型&lt;/h2&gt;&lt;h3 id=&quot;客户端-服务器网络编程模型&quot;&gt;&lt;a href=&quot;#客户端-服务器网络编程模型&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>后端存储</title>
    <link href="http://example.com/p/5af0150b.html"/>
    <id>http://example.com/p/5af0150b.html</id>
    <published>2024-01-09T12:10:47.936Z</published>
    <updated>2024-01-22T09:22:50.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电商系统"><a href="#电商系统" class="headerlink" title="电商系统"></a>电商系统</h1><h2 id="订单系统"><a href="#订单系统" class="headerlink" title="订单系统"></a>订单系统</h2><p>订单系统是整个电商系统中最重要的一个子系统，订单数据也就是电商企业最重要的数据资产。今天这节课，一个合格的订单系统，最基本的要求是什么？数据不能错。一个购物流程，从下单开始、支付、发货，直到收货，这么长的一个流程中，每一个环节，都少不了更新订单数据，每一次更新操作又需要同时更新好几张表。这些操作可能被随机分布到很多台服务器上执行，服务器有可能故障，网络有可能出问题。<br>在这么复杂的情况下，保证订单数据一笔都不能错，是不是很难？实际上，只要掌握了方法，其实并不难。<br>首先，你的代码必须是正确没 Bug 的，如果说是因为代码 Bug 导致的数据错误，那谁也救不了你。<br>然后，你要会正确地使用数据库的事务。比如，你在创建订单的时候，同时要在订单表和订单商品表中插入数据，那这些插入数据的 INSERT 必须在一个数据库事务中执行，数据库的事务可以确保：执行这些 INSERT 语句，要么一起都成功，要么一起都失败。<br>但是，还有一些情况下会引起数据错误。任何一个电商，它的订单系统的功能都是独一无二的，基于它的业务，有非常多的功能，并且都很复杂。我们在讨论订单系统的存储问题时，必须得化繁为简，只聚焦那些最核心的、共通的业务和功能上，并且以这个为基础来讨论存储技术问题。</p><h3 id="订单系统的核心功能和数据"><a href="#订单系统的核心功能和数据" class="headerlink" title="订单系统的核心功能和数据"></a>订单系统的核心功能和数据</h3><p>订单系统必备的功能，它包含但远远不限于：</p><ol><li>创建订单；</li><li>随着购物流程更新订单状态；</li><li>查询订单，包括用订单数据生成各种报表。<br>为了支撑这些必备功能，在数据库中，我们至少需要有这样几张表：</li><li>订单主表：也叫订单表，保存订单的基本信息。</li><li>订单商品表：保存订单中的商品信息。</li><li>订单支付表：保存订单的支付和退款信息。</li><li>订单优惠表：保存订单使用的所有优惠信息。<br>这几个表之间的关系是这样的：订单主表和后面的几个子表都是一对多的关系，关联的外键就是订单主表的主键，也就是订单号。绝大部分订单系统它的核心功能和数据结构都是这样的。</li></ol><h3 id="如何避免重复下单？"><a href="#如何避免重复下单？" class="headerlink" title="如何避免重复下单？"></a>如何避免重复下单？</h3><p>一个订单系统，提供创建订单的 HTTP 接口，用户在浏览器页面上点击“提交订单”按钮的时候，浏览器就会给订单系统发一个创建订单的请求，订单系统的后端服务，在收到请求之后，往数据库的订单表插入一条订单数据，创建订单成功。假如说，用户点击“创建订单”的按钮时手一抖，点了两下，浏览器发了两个 HTTP 请求，结果是什么？创建了两条一模一样的订单。这样肯定不行，需要做防重。有的同学会说，前端页面上应该防止用户重复提交表单，你说的没错。但是，网络错误会导致重传，很多 RPC 框架、网关都会有自动重试机制，所以对于订单服务来说，重复请求这个事儿，你是没办法完全避免的。<br>解决办法是，让你的订单服务具备幂等性。什么是幂等呢？一个幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，一个幂等的方法，使用同样的参数，对它进行调用多次和调用一次，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变。一个幂等的创建订单服务，无论创建订单的请求发送多少次，正确的结果是，数据库只有一条新创建的订单记录。在插入订单数据之前，先查询一下订单表里面有没有重复的订单，行不行？不太行，因为你<br>很难用 SQL 的条件来定义“重复的订单”，订单用户一样、商品一样、价格一样，就认为是重复订单么？不一定，万一用户就是连续下了两个一模一样的订单呢？所以这个方法说起来容易，实际上很难实现。<br>很多电商解决这个问题的思路是这样的。在数据库的最佳实践中有一条就是，数据库的每个表都要有主键，绝大部分数据表都遵循这个最佳实践。一般来说，我们在往数据库插入一条记录的时候，都不提供主键，由数据库在插入的同时自动生成一个主键。这样重复的请求就会导致插入重复数据。我们知道，表的主键自带唯一约束，如果我们在一条 INSERT 语句中提供了主键，并且这个主键的值在表中已经存在，那这条 INSERT 会执行失败，数据也不会被写入表中。我们可以利用数据库的这种“主键唯一约束”特性，在插入数据的时候带上主键，来解决创建订单服务的幂等性问题。具体的做法是这样的，我们给订单系统增加一个“生成订单号”的服务，这个服务没有参数，返回值就是一个新的、全局唯一的订单号。在用户进入创建订单的页面时，前端页面先调用这个生成订单号服务得到一个订单号，在用户提交订单的时候，在创建订单的请求中带着这个订单号。这个订单号也是我们订单表的主键，这样，无论是用户手抖，还是各种情况导致的重试，这些重复请求中带的都是同一个订单号。订单服务在订单表中插入数据的时候，执行的这些重复 INSERT 语句中的主键，也都是同一个订单号。数据库的唯一约束就可以保证，只有一次 INSERT 语句是执行成功的，这样就实现了创建订单服务幂等性。还有一点需要注意的是，如果是因为重复订单导致插入订单表失败，订单服务不要把这个错误返回给前端页面。否则，就有可能出现这样的情况：用户点击创建订单按钮后，页面提示创建订单失败，而实际上订单却创建成功了。正确的做法是，遇到这种情况，订单服务直接返回订单创建成功就可以了。</p><h3 id="如何解决-ABA-问题？"><a href="#如何解决-ABA-问题？" class="headerlink" title="如何解决 ABA 问题？"></a>如何解决 ABA 问题？</h3><p>订单系统各种更新订单的服务一样也要具备幂等性。这些更新订单服务，比如说支付、发货等等这些步骤中的更新订单操作，最终落到订单库上，都是对订单主表的 UPDATE 操作。数据库的更新操作，本身就具备天然的幂等性，比如说，你把订单状态，从未支付更新成已支付，执行一次和重复执行多次，订单状态都是已支付，不用我们做任何额外的逻辑，这就是天然幂等。<br>在并发环境下，你需要注意 ABA 问题。什么是 ABA 问题呢？比如说，订单支付之后，小二要发货，发货<br>完成后要填个快递单号。假设说，小二填了一个单号 666，刚填完，发现填错了，赶紧再修改成 888。对订单服务来说，这就是 2 个更新订单的请求。正常情况下，订单中的快递单号会先更新成 666，再更新成 888，这是没问题的。那不正常情况呢？666 请求到了，单号更新成 666，然后 888 请求到了，单号又更新成 888，但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了，这数据显然就错了。这就是非常有名的 ABA 问题。<br>ABA 问题怎么解决？这里给你提供一个比较通用的解决方法。给你的订单主表增加一列，列名可以叫 version，也即是“版本号”的意思。每次查询订单的时候，版本号需要随着订单数据返回给页面。页面在更新数据的请求中，需要把这个版本号作为更新请求的参数，再带回给订单更新服务。订单服务在更新数据的时候，需要比较订单当前数据的版本号，是否和消息中的版本号一致，如果不一致就拒绝更新数据。如果版本号一致，还需要再更新数据的同时，把版本号+1。“比较版本号、更新数据和版本号 +1”，这个过程必须在同一个事务里面执行。<br>具体的 SQL 可以这样来写：</p><pre><code>UPDATE orders set tracking_number = 666, version = version + 1WHERE version = 8;</code></pre><p>在这条 SQL 的 WHERE 条件中，version 的值需要页面在更新的时候通过请求传进来。<br>通过这个版本号，就可以保证，从我打开这条订单记录开始，一直到我更新这条订单记录成功，这个期间没有其他人修改过这条订单数据。因为，如果有其他人修改过，数据库中的版本号就会改变，那我的更新操作就不会执行成功。我只能重新查询新版本的订单数据，然后再尝试更新。有了这个版本号，再回头看一下我们上面那个 ABA 问题的例子，会出现什么结果？可能出现两种情况：</p><ol><li>第一种情况，把运单号更新为 666 的操作成功了，更新为 888 的请求带着旧版本号，那就会更新失败，页面提示用户更新 888 失败。</li><li>第二种情况，666 更新成功后，888 带着新的版本号，888 更新成功。这时候即使重试的 666 请求再来，因为它和上一条 666 请求带着相同的版本号，上一条请求更新成功后，这个版本号已经变了，所以重试请求的更新必然失败。</li></ol><h2 id="流量大、数据多的商品详情页系统该如何设计"><a href="#流量大、数据多的商品详情页系统该如何设计" class="headerlink" title="流量大、数据多的商品详情页系统该如何设计"></a>流量大、数据多的商品详情页系统该如何设计</h2><p>电商的商品系统主要功能就是增删改查商品信息，没有很复杂的业务逻辑，支撑的主要页面就是商品详情页（下文简称：商详）。不过，设计这个系统的存储，仍然需要着重考虑两个方面的问题。</p><p>第一，要考虑高并发的问题。不管是什么电商系统，商详页一定是整个系统中 DAU（日均访问次数）最高的页面之一。这个也不难理解，用户购物么，看商详了不一定买，买之前一定会看好多商详货比三家，所以商详的浏览次数要远比系统的其他页面高。如果说，在设计存储的时候，没有考虑到高并发的问题，大促的时候，支撑商详页的商品系统必然是第一个被流量冲垮的系统。<br>第二，要考虑的是商品数据规模的问题。商详页的数据规模，总结六个字叫：数量多，重量大。先说为什么数量多，国内一线的电商，SKU（直译为：库存单元，在电商行业，你可以直接理解为“商品”）的数量大约在几亿到几十亿这个量级。当然实际上并没有这么多种商品，这里面有很多原因，比如同一个商品它有不同版本型号，再比如，商家为了促销需要，可能会反复上下架同一个商品或者给同一个商品配不同的马甲，这都导致了 SKU 数量爆炸。再说这个“重量大”，你可以打开一个电商商详页看一下，从上一直拉到底，你看看有多长？十屏以内的商详页那都叫短的，并且这里面不光有大量的文字，还有大量的图片和视频，甚至还有 AR&#x2F;VR 的玩法在里面，所以说，每个商详页都是个“大胖子”。<br>支持商品系统的存储，要保存这么多的“大胖子”，还要支撑高并发，任务艰巨。</p><h3 id="商品系统需要保存哪些数据"><a href="#商品系统需要保存哪些数据" class="headerlink" title="商品系统需要保存哪些数据"></a>商品系统需要保存哪些数据</h3><p>商品系统中，需要维护各种关键信息以支持商品的生命周期和交易过程。首先，商品信息是核心，包括商品名称、描述、编号、分类、品牌、价格、库存等。供应商和客户信息也是重要的组成部分，其中包括相关的联系信息和唯一标识。交易信息则记录了销售订单、购买订单、交易时间、金额、付款和发货状态。库存信息跟踪了商品的出入库记录、库存变动日志和预警信息。价格和促销信息包括商品定价、折扣和促销活动。用户权限和登录信息确保系统的安全性，包括用户账号、权限角色和登录历史。系统还需保存日志信息、图片和多媒体文件、地理信息（如果适用）以及评价和反馈。最后，配置和设置项包含了系统配置和通知设置，以适应不同的业务需求。这些数据的维护和管理是构建一个高效、安全且用户友好的商品系统的基础。<br>这么多内容怎么存？能不能像保存订单数据那样，设计一张商品表，把这些数据一股脑儿都放进去？一张表存不下就再加几张子表，这样行不行？你还真别说不行，现在这些电商大厂，在它们发展的早期就是这么干的。现在那么复杂的分布式存储架构，都是一点儿一点儿逐步演进过来的。这么做的好处，就是糙快猛，简单可靠而且容易实现，但是，撑不了多少数据量，也撑不了多少并发。如果说，你要低成本快速构建一个小规模电商，这么做还真就是一个挺合理的选择。<br>当然，规模再大一点儿就不能这么干了。不能用数据库，那应该选择哪种存储系统来保存这么复杂的商品数据呢？任何一种存储都是没办法满足的，解决的思路是分而治之，我们可以把商品系统需要存储的数据按照特点，分成商品基本信息、商品参数、图片视频和商品介绍几个部分来分别存储。</p><h3 id="商品基本信息该如何存储？"><a href="#商品基本信息该如何存储？" class="headerlink" title="商品基本信息该如何存储？"></a>商品基本信息该如何存储？</h3><p>商品的基本信息，它包括商品的主副标题、价格、颜色等一些商品最基本、主要的属性。这些属性都是固定的，不太可能会因为需求或者不同的商品而变化，而且，这部分数据也不会太大。所以，建议数据库中建一张表来保存商品的基本信息。<br>然后，还需要在数据库前面，加一个缓存，帮助数据抵挡绝大部分的读请求。这个缓存，你可以使用 Redis，也可以用 Memcached，这两种存储系统都是基于内存的 KV 存储，都能解决问题。处理商品信息的读请求时，先去缓存查找，如果找到就直接返回缓存中的数据。如果在缓存中没找到，再去查数据库，把从数据库中查到的商品信息返回给页面，顺便把数据在缓存里也放一份。更新商品信息的时候，在更新数据库的同时，也要把缓存中的数据给删除掉。不然就有可能出现这种情况：数据库中的数据变了，而缓存中的数据没变，商详页上看到的还是旧数据。这种缓存更新的策略，称为 Cache Aside，是最简单实用的一种缓存更新策略，适用范围也最广泛。如果你要缓存数据，没有什么特殊的情况，首先就应该考虑使用这个策略。除了 Cache Aside 以外，还有 Read&#x2F;Write Through、Write Behind 等几种策略，分别适用于不同的情况，后面的课程中我会专门来讲。<br>设计商品基本信息表的时候，有一点需要提醒你的是，一定要记得保留商品数据的每一个历史版本。因为商品数据是随时变化的，但是订单中关联的商品数据，必须是下单那个时刻的商品数据，这一点很重要。你可以为每一个历史版本的商品数据保存一个快照，可以创建一个历史表保存到 MySQL 中，也可以保存到一些 KV 存储中。</p><h3 id="使用-MongoDB-保存商品参数"><a href="#使用-MongoDB-保存商品参数" class="headerlink" title="使用 MongoDB 保存商品参数"></a>使用 MongoDB 保存商品参数</h3><p>我们再来分析商品参数，参数就是商品的特征。比如说，电脑的内存大小、手机的屏幕尺寸、酒的度数、口红的色号等等。和商品的基本属性一样，都是结构化的数据。但麻烦的是，不同类型的商品，它的参数是完全不一样的.如果我们设计一个商品参数表，那这个表的字段就会太多了，并且每增加一个品类的商品，这个表就要加字段，这个方案行不通。既然一个表不能解决问题，那就每个类别分别建一张表。比如说，建一个电脑参数表，里面的字段有 CPU 型号、内存大小、显卡型号、硬盘大小等等；再建一个酒类参数表，里面的字段有酒精度数、香型、产地等等。如果说，品类比较少，在 100 个以内，用几十张表分别保存不同品类的商品参数，这样做也是可以的。但是，有没有更好的方法呢？大多数数据库，都要求数据表要有一个固定的结构。但有一种数据库，没有这个要求。特别适合保存像“商品参数”这种，属性不固定的数据，这个数据库就是 MongoDB。<br>MongoDB 是一个面向文档存储的 NoSQL 数据库，在 MongoDB 中，表、行、列对应的概念分别是：collection、document、field，其实都是一回事儿，为了便于你理解，在这里我们不咬文嚼字，还是用“表、行、列”来说明。MongoDB 最大的特点就是，它的“表结构”是不需要事先定义的，其实，在MongoDB<br>中根本没有表结构。由于没有表结构，它支持你把任意数据都放在同一张表里，你甚至可以在一张表里保存商品数据、订单数据、物流信息等这些结构完全不同的数据。并且，还能支持按照数据的某个字段进行查询。它是怎么做到的呢？MongoDB 中的每一行数据，在存储层就是简单地被转化成 BSON 格式后存起来，这个 BSON 就是一种更紧凑的 JSON。所以，即使在同一张表里面，它每一行数据的结构都可以是不一样的。当然，这样的灵活性也是有代价的，MongoDB 不支持 SQL，多表联查和复杂事务比较孱弱，不太适合存储一般的数据。但是，对于商品参数信息，数据量大、数据结构不统一，这些 MongoDB 都可以很好的满足。我们也不需要事务和多表联查，MongoDB 简直就是为了保存商品参数量身定制的一样</p><h3 id="使用对象存储保存图片和视频"><a href="#使用对象存储保存图片和视频" class="headerlink" title="使用对象存储保存图片和视频"></a>使用对象存储保存图片和视频</h3><p>图片和视频由于占用存储空间比较大，一般的存储方式都是，在数据库中只保存图片视频的ID 或者URL，实际的图片视频以文件的方式单独存储.现在图片和视频存储技术已经非常成熟了，首选的方式就是保存在对象存储（Object Storage）中。各大云厂商都提供对象存储服务，比如国内的七牛云、AWS 的 S3 等等，也有开源的对象存储产品，比如 MinIO，可以私有化部署。虽然每个产品的 API 都不一<br>样，但功能大同小异。对象存储可以简单理解为一个无限容量的大文件 KV 存储，它的存储单位是对象，其实就是文件，可以是一张图片，一个视频，也可以是其他任何文件。每个对象都有一个唯一的 key，利用这个 key 就可以随时访问对应的对象。基本的功能就是写入、访问和删除对象。<br>云服务厂商的对象存储大多都提供了客户端 API，可以在 Web 页面或者 App 中直接访问而不用通过后端服务来中转。这样，App 和页面在上传图片视频的时候，直接保存到对象存储中，然后把对应 key 保存在商品系统中就可以了。访问图片视频的时候，真正的图片和视频文件也不需要经过商品系统的后端服务，页面直接通过对象存储提供的 URL 来访问，又省事儿又节约带宽。而且，几乎所有的对象存储云服<br>务都自带 CDN（Content Delivery Network）加速服务，响应时间比直接请求业务的服务器更短。国内的很多云厂商的对象存储对图片和视频，都做了非常多的针对性优化。最有用的是，缩放图片和视频转码，你只要把图片和视频丢到对象存储中，就可以随时获得任意尺寸大小的图片，视频也会自动转码成各种格式和码率的版本，适配各种 App 和场景。我只能说，谁用谁知道，真香！</p><h2 id="将商品介绍静态化"><a href="#将商品介绍静态化" class="headerlink" title="将商品介绍静态化"></a>将商品介绍静态化</h2><p>商品介绍在商详页中占得比重是最大的，包含了大量的带格式文字、图片和视频。其中图片和视频自然要存放在对象存储里面，商品介绍的文本，一般都是随着商详页一起静态化，保存在 HTML 文件中。<br>什么是静态化呢？静态化是相对于动态页面来说的。一般我们部署到 Tomcat 中的 Web 系统，返回的都是动态页面，也就是在 Web 请求时，动态生成的。比如说商详页，一个Web 请求过来，带着 SKUID，Tomcat 中的商详页模块，再去访问各种数据库、调用后端服务，动态把这个商详页拼出来，返回给浏览器。不过，现在基本上没有系统会这么干了，你想，对于每个 SKU 的商详页，你每次动态生成的页面内容不是完全一样的么？生成这么多次，不仅浪费服务器资源，速度还慢，关键问题是，Tomcat 能能抗的并发量和 Nginx 完全不是一个数量级的。商详页的绝大部分内容都是商品介绍，它是不怎么变的。那不如就把这个页面事先生成好，保存成一个静态的 HTML，访问商详页的时候，直接返回这个 HTML。这就是静态化。商详页静态化之后，不仅仅是可以节省服务器资源，还可以利用 CDN 加速，把商详页放到离用户最近的 CDN 服务器上，让商详页访问更快。至于商品价格、促销信息等这些需要频繁变动的信息，不能静态化到页面中，可以在前端页面使用 AJAX 请求商品系统动态获取。这样就兼顾了静态化带来的优势，也能解决商品价格等信息需要实时更新的问题。</p><p><img src="https://s11.ax1x.com/2024/01/10/pF9EziF.png" alt="pF9EziF.png"></p><p>图中实线表示每访问一次商详页，需要真正传输的数据，虚线表示当商详页数据发生变化的时候才需要进行一次数据传输。用户打开一个 SKU 的商详页时，首先去 CDN 获取商详页的 HTML，然后访问商品系统获取价格等频繁变化的信息，这些信息从 Redis 缓存中获取。图片和视频信息，也是从对象存储的 CDN 中获取。分析一下效果，数据量最大的图片、视频和商品介绍都是从离用户最近的 CDN 服务商获取的，速度快，节约带宽。真正打到商品系统的请求，就是价格这些需要动态获取的商品信息，一般做一次 Redis 查询就可以了，基本不会有流量打到 MySQL 中,这样一个商品系统的存储的架构，把大部分请求都转移到了又便宜速度又快的 CDN 服务器上，可以用很少量的服务器和带宽资源，抗住大量的并发请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电商系统&quot;&gt;&lt;a href=&quot;#电商系统&quot; class=&quot;headerlink&quot; title=&quot;电商系统&quot;&gt;&lt;/a&gt;电商系统&lt;/h1&gt;&lt;h2 id=&quot;订单系统&quot;&gt;&lt;a href=&quot;#订单系统&quot; class=&quot;headerlink&quot; title=&quot;订单系统&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/p/53d0684b.html"/>
    <id>http://example.com/p/53d0684b.html</id>
    <published>2024-01-07T13:31:49.911Z</published>
    <updated>2024-01-08T08:36:01.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><h2 id="x86-架构"><a href="#x86-架构" class="headerlink" title="x86 架构"></a>x86 架构</h2><p>对于一个计算机来讲，最核心的就是CPU（Central Processing Unit，中央处理器）。这是这台计算机的大脑，所有的设备都围绕它展开。对于公司来说，CPU 是真正干活的，将来执行项目都要靠它。CPU 和其他设备连接，要靠一种叫作总线（Bus）的东西，其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。在这些设备中，最重要的是内存（Memory）。因为单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。CPU 本身没办法保存这么多中间结果，这就要依赖内存了。当然总线上还有一些其他设备，例如显卡会连接显示器、磁盘控制器会连接硬盘、USB 控制器会连接键盘和鼠标等等。<br>CPU 和内存是完成计算任务的核心组件，所以这里我们重点介绍一下CPU 和内存是如何配合工作的。CPU 其实也不是单纯的一块，它包括三个部分，运算单元、数据单元和控制单元。<br>运算单元只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。<br>运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了数据单元。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。<br>有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是控制单元。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统初始化&quot;&gt;&lt;a href=&quot;#系统初始化&quot; class=&quot;headerlink&quot; title=&quot;系统初始化&quot;&gt;&lt;/a&gt;系统初始化&lt;/h1&gt;&lt;h2 id=&quot;x86-架构&quot;&gt;&lt;a href=&quot;#x86-架构&quot; class=&quot;headerlink&quot; title=&quot;x</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>
