<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-07T14:57:14.818Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-08-07T14:57:09.536Z</published>
    <updated>2023-08-07T14:57:14.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣56，合并区间"><a href="#力扣56，合并区间" class="headerlink" title="力扣56，合并区间"></a>力扣56，合并区间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣56，合并区间&quot;&gt;&lt;a href=&quot;#力扣56，合并区间&quot; class=&quot;headerlink&quot; title=&quot;力扣56，合并区间&quot;&gt;&lt;/a&gt;力扣56，合并区间&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VLD</title>
    <link href="http://example.com/p/ba0d0e90.html"/>
    <id>http://example.com/p/ba0d0e90.html</id>
    <published>2023-08-07T13:53:22.202Z</published>
    <updated>2023-08-07T13:56:44.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p>金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。</p><h2 id="Valgrind-的介绍"><a href="#Valgrind-的介绍" class="headerlink" title="Valgrind 的介绍"></a>Valgrind 的介绍</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><pre><code>$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2$ bzip2 -d valgrind-3.13.0.tar.bz2$ tar -xf valgrind-3.13.0.tar$ cd valgrind-3.13.0$ ./configure &amp;&amp; make$ sudo make install</code></pre><p>检测内存泄漏</p><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><pre><code>#include &lt;stdlib.h&gt;int main()&#123;    int *array = malloc(sizeof(int));    return 0;&#125;</code></pre><p>编译程序时，需要加上-g选项：</p><pre><code>$ gcc -g -o main_c main.c</code></pre><p>使用 Valgrind 检测内存使用情况：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full  ./main_c==31416== Memcheck, a memory error detector==31416== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31416== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31416== Command: ./main_c==31416====31416====31416== HEAP SUMMARY:==31416==     in use at exit: 4 bytes in 1 blocks==31416==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated==31416====31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)==31416====31416== LEAK SUMMARY:==31416==    definitely lost: 4 bytes in 1 blocks==31416==    indirectly lost: 0 bytes in 0 blocks==31416==      possibly lost: 0 bytes in 0 blocks==31416==    still reachable: 0 bytes in 0 blocks==31416==         suppressed: 0 bytes in 0 blocks==31416====31416== For counts of detected and suppressed errors, rerun with: -v==31416== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>先看看输出信息中的HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees表示程序释放了 0 次内存，4 bytes allocated表示分配了 4 个字节的内存。<br>另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是main.c文件的第 5 行：</p><pre><code>==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)</code></pre><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><p>#include <string><br>int main()<br>{<br>    auto ptr &#x3D; new std::string(“Hello, World!”);<br>    delete ptr;<br>    return 0;<br>}</string></p><p>使用 Valgrind 分析这段程序：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp==31438== Memcheck, a memory error detector==31438== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31438== Command: ./main_cpp==31438====31438====31438== HEAP SUMMARY:==31438==     in use at exit: 72,704 bytes in 1 blocks==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated==31438====31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)==31438==    by 0x40105FA: call_init (dl-init.c:30)==31438==    by 0x40105FA: _dl_init (dl-init.c:120)==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)==31438====31438== LEAK SUMMARY:==31438==    definitely lost: 0 bytes in 0 blocks==31438==    indirectly lost: 0 bytes in 0 blocks==31438==      possibly lost: 0 bytes in 0 blocks==31438==    still reachable: 72,704 bytes in 1 blocks==31438==         suppressed: 0 bytes in 0 blocks==31438====31438== For counts of detected and suppressed errors, rerun with: -v==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从HEAP SUMMARY可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？<br>实际上这是由于 C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏，例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。</p><p>检测越界访问<br>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><pre><code>#include &lt;vector&gt;#include &lt;iostream&gt;int main()&#123;    std::vector&lt;int&gt; v(10, 0);    std::cout &lt;&lt; v[10] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31523== Memcheck, a memory error detector==31523== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31523== Command: ./main_cpp==31523====31523== Invalid read of size 4==31523==    at 0x400AD7: main (main.cpp:7)==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#39;d==31523==    at 0x4C2E216: operator new(unsigned long) (vg_replace_malloc.c:334)==31523==    by 0x4010D3: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)==31523==    by 0x401040: std::allocator_traits&lt;std::allocator&lt;int&gt; &gt;::allocate(std::allocator&lt;int&gt;&amp;, unsigned long) (alloc_traits.h:491)==31523==    by 0x400F91: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:170)==31523==    by 0x400E7E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_create_storage(unsigned long) (stl_vector.h:185)==31523==    by 0x400D1E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:136)==31523==    by 0x400C11: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector(unsigned long, int const&amp;, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:291)==31523==    by 0x400AB9: main (main.cpp:6)</code></pre><p>Invalid read of size 4表示越界读取 4 个字节，这个操作出现在main.cpp文件的第 7 行。另外可以看到，vector分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><p>检测未初始化的内存<br>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><pre><code>#include &lt;iostream&gt;int main()&#123;    int x;    if (x == 0)    &#123;        std::cout &lt;&lt; &quot;X is zero&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 检测这个程序：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31554== Memcheck, a memory error detector==31554== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31554== Command: ./main_cpp==31554====31554== Conditional jump or move depends on uninitialised value(s)==31554==    at 0x400852: main (main.cpp:6)</code></pre><p>　　<br>输出中提示了main.cpp文件的第 6 行访问了未初始化的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VLD&quot;&gt;&lt;a href=&quot;#VLD&quot; class=&quot;headerlink&quot; title=&quot;VLD&quot;&gt;&lt;/a&gt;VLD&lt;/h1&gt;&lt;p&gt;金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。&lt;/p&gt;
&lt;h2 id=&quot;Valgrind-的介绍&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/p/54e1373e.html"/>
    <id>http://example.com/p/54e1373e.html</id>
    <published>2023-08-06T14:59:02.859Z</published>
    <updated>2023-08-07T15:26:18.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL相关问题，事务，索引，索引的优化，用过没"><a href="#MySQL相关问题，事务，索引，索引的优化，用过没" class="headerlink" title="MySQL相关问题，事务，索引，索引的优化，用过没"></a>MySQL相关问题，事务，索引，索引的优化，用过没</h2><h2 id="数据库的水平划分和垂直划分"><a href="#数据库的水平划分和垂直划分" class="headerlink" title="数据库的水平划分和垂直划分"></a>数据库的水平划分和垂直划分</h2><h2 id="数据库ACID的概念，事务是怎么保证的"><a href="#数据库ACID的概念，事务是怎么保证的" class="headerlink" title="数据库ACID的概念，事务是怎么保证的"></a>数据库ACID的概念，事务是怎么保证的</h2><h2 id="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"><a href="#介绍一下mysql的常见的存储引擎，以及它们的区别是什么？" class="headerlink" title="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"></a>介绍一下mysql的常见的存储引擎，以及它们的区别是什么？</h2><h2 id="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"><a href="#介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）" class="headerlink" title="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"></a>介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）</h2><h2 id="mysql底层为什么用的是b-树？"><a href="#mysql底层为什么用的是b-树？" class="headerlink" title="mysql底层为什么用的是b+树？"></a>mysql底层为什么用的是b+树？</h2><h2 id="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"><a href="#介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？" class="headerlink" title="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"></a>介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？</h2><h2 id="MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。"><a href="#MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。" class="headerlink" title="MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。"></a>MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。</h2><h2 id="MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"><a href="#MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。" class="headerlink" title="MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"></a>MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。</h2><h2 id="MySQL的LRU和普通的LRU算法有何区别？"><a href="#MySQL的LRU和普通的LRU算法有何区别？" class="headerlink" title="MySQL的LRU和普通的LRU算法有何区别？"></a>MySQL的LRU和普通的LRU算法有何区别？</h2><h2 id="介绍MySQL三大日志redo-log-undo-log-bin-log。"><a href="#介绍MySQL三大日志redo-log-undo-log-bin-log。" class="headerlink" title="介绍MySQL三大日志redo log,undo log,bin log。"></a>介绍MySQL三大日志redo log,undo log,bin log。</h2><h2 id="写一个LRU缓存。"><a href="#写一个LRU缓存。" class="headerlink" title="写一个LRU缓存。"></a>写一个LRU缓存。</h2><h2 id="查询优化器有哪些优化"><a href="#查询优化器有哪些优化" class="headerlink" title="查询优化器有哪些优化"></a>查询优化器有哪些优化</h2><h2 id="InnoDB里面有哪些线程"><a href="#InnoDB里面有哪些线程" class="headerlink" title="InnoDB里面有哪些线程"></a>InnoDB里面有哪些线程</h2><h2 id="为什么使用B-树做索引，而不是B树或者哈希"><a href="#为什么使用B-树做索引，而不是B树或者哈希" class="headerlink" title="为什么使用B+树做索引，而不是B树或者哈希"></a>为什么使用B+树做索引，而不是B树或者哈希</h2><h2 id="了解Trie树吗"><a href="#了解Trie树吗" class="headerlink" title="了解Trie树吗"></a>了解Trie树吗</h2><h2 id="MySQL缓存介绍一下，有哪些优化"><a href="#MySQL缓存介绍一下，有哪些优化" class="headerlink" title="MySQL缓存介绍一下，有哪些优化"></a>MySQL缓存介绍一下，有哪些优化</h2><h2 id="为什么使用索引、说一下你对索引的理解？"><a href="#为什么使用索引、说一下你对索引的理解？" class="headerlink" title="为什么使用索引、说一下你对索引的理解？"></a>为什么使用索引、说一下你对索引的理解？</h2><h2 id="事务的性质有哪些，具体概念以及实现"><a href="#事务的性质有哪些，具体概念以及实现" class="headerlink" title="事务的性质有哪些，具体概念以及实现"></a>事务的性质有哪些，具体概念以及实现</h2><h2 id="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"><a href="#也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等" class="headerlink" title="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"></a>也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;a href=&quot;#MySQL相关问题，事务，索引，索引的优化，用过没&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;/a&gt;MySQL相关问题，事</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计网</title>
    <link href="http://example.com/p/bdbd2d9.html"/>
    <id>http://example.com/p/bdbd2d9.html</id>
    <published>2023-08-06T14:58:38.217Z</published>
    <updated>2023-08-07T15:25:59.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h2><h2 id="tcp四次挥手第二次和第三次不能合并吗"><a href="#tcp四次挥手第二次和第三次不能合并吗" class="headerlink" title="tcp四次挥手第二次和第三次不能合并吗"></a>tcp四次挥手第二次和第三次不能合并吗</h2><h2 id="osi七层网络模型，每层有的协议"><a href="#osi七层网络模型，每层有的协议" class="headerlink" title="osi七层网络模型，每层有的协议"></a>osi七层网络模型，每层有的协议</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="ssl四次挥手"><a href="#ssl四次挥手" class="headerlink" title="ssl四次挥手"></a>ssl四次挥手</h2><h2 id="计算机网络的理解大概是什么样的？说下TCP的三次握手"><a href="#计算机网络的理解大概是什么样的？说下TCP的三次握手" class="headerlink" title="计算机网络的理解大概是什么样的？说下TCP的三次握手"></a>计算机网络的理解大概是什么样的？说下TCP的三次握手</h2><h2 id="SSL的四次握手知道不？"><a href="#SSL的四次握手知道不？" class="headerlink" title="SSL的四次握手知道不？"></a>SSL的四次握手知道不？</h2><h2 id="tcp三次握手过程、是否熟悉TLS协议"><a href="#tcp三次握手过程、是否熟悉TLS协议" class="headerlink" title="tcp三次握手过程、是否熟悉TLS协议"></a>tcp三次握手过程、是否熟悉TLS协议</h2><h2 id="介绍一下使用tcp进行通信的时候socket的使用过程"><a href="#介绍一下使用tcp进行通信的时候socket的使用过程" class="headerlink" title="介绍一下使用tcp进行通信的时候socket的使用过程"></a>介绍一下使用tcp进行通信的时候socket的使用过程</h2><h2 id="网络模型、介绍一下每一层的作用？"><a href="#网络模型、介绍一下每一层的作用？" class="headerlink" title="网络模型、介绍一下每一层的作用？"></a>网络模型、介绍一下每一层的作用？</h2><h2 id="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"><a href="#这个也是从上面引申的，流量控制和拥塞控制怎么实现的？" class="headerlink" title="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"></a>这个也是从上面引申的，流量控制和拥塞控制怎么实现的？</h2><h2 id="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"><a href="#具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。" class="headerlink" title="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"></a>具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。</h2><h2 id="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"><a href="#如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）" class="headerlink" title="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"></a>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）</h2><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><h2 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h2><h2 id="如何使用UDP设计一个可靠的传输协议（知识盲区）"><a href="#如何使用UDP设计一个可靠的传输协议（知识盲区）" class="headerlink" title="如何使用UDP设计一个可靠的传输协议（知识盲区）"></a>如何使用UDP设计一个可靠的传输协议（知识盲区）</h2><h2 id="一条SQL语句的执行流程"><a href="#一条SQL语句的执行流程" class="headerlink" title="一条SQL语句的执行流程"></a>一条SQL语句的执行流程</h2><h2 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h2><h2 id="为什么要用epoll"><a href="#为什么要用epoll" class="headerlink" title="为什么要用epoll"></a>为什么要用epoll</h2><h2 id="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"><a href="#reactor和proactor的好处和坏处。为什么要用reactor而不用proactor" class="headerlink" title="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"></a>reactor和proactor的好处和坏处。为什么要用reactor而不用proactor</h2><h2 id="能详细讲一下有限状态机怎么解析http报文吗"><a href="#能详细讲一下有限状态机怎么解析http报文吗" class="headerlink" title="能详细讲一下有限状态机怎么解析http报文吗"></a>能详细讲一下有限状态机怎么解析http报文吗</h2><h2 id="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"><a href="#小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题" class="headerlink" title="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"></a>小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题</h2><h2 id="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"><a href="#如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆" class="headerlink" title="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"></a>如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆</h2><h2 id="socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）"><a href="#socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）" class="headerlink" title="socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）"></a>socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）</h2><h2 id="这个时候会绑定端口吗？"><a href="#这个时候会绑定端口吗？" class="headerlink" title="这个时候会绑定端口吗？"></a>这个时候会绑定端口吗？</h2><h2 id="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"><a href="#后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）" class="headerlink" title="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"></a>后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）</h2><h2 id="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"><a href="#第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？" class="headerlink" title="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"></a>第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？</h2><h2 id="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"><a href="#第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？" class="headerlink" title="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"></a>第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？</h2><h2 id="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"><a href="#TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？" class="headerlink" title="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"></a>TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？</h2><h2 id="tcp-x2F-ip五层模型"><a href="#tcp-x2F-ip五层模型" class="headerlink" title="tcp&#x2F;ip五层模型"></a>tcp&#x2F;ip五层模型</h2><h2 id="dns服务器用的是什么协议。"><a href="#dns服务器用的是什么协议。" class="headerlink" title="dns服务器用的是什么协议。"></a>dns服务器用的是什么协议。</h2><h2 id="ping命令-用的是什么协议。在哪一层。"><a href="#ping命令-用的是什么协议。在哪一层。" class="headerlink" title="ping命令 用的是什么协议。在哪一层。"></a>ping命令 用的是什么协议。在哪一层。</h2><h2 id="tcp拥塞控制实现。"><a href="#tcp拥塞控制实现。" class="headerlink" title="tcp拥塞控制实现。"></a>tcp拥塞控制实现。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h1&gt;&lt;h2 id=&quot;tcp和udp的区别&quot;&gt;&lt;a href=&quot;#tcp和udp的区别&quot; class=&quot;headerlink&quot; title=&quot;tcp和u</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>继承构造函数</title>
    <link href="http://example.com/p/4d123864.html"/>
    <id>http://example.com/p/4d123864.html</id>
    <published>2023-08-06T14:20:41.355Z</published>
    <updated>2023-08-06T14:29:45.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h1><p>继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    using Base::Base;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>在 C++11 以前，你就必须在 Derived 里再写一份同参数列表的构造函数，将参数转发给基类。</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y)    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>如果基类有很多重载的构造函数的话，每个重载版本都要在子类重写一下，这是违反代码复用原则的！更要命的是，如果基类构造函数重构了，而子类忘记跟着改的话，就容易 BOOM</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, double y) : x(x), y(y) // 基类 api 改了    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y) // 子类这里忘改了    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4.5); // 定义变量的时候参考了基类 api 手册    // 你就等着调 bug 调到猝死吧&#125;</code></pre><p>using Base::基类方法名的这个语法是 C++98 就有的，不是 C++11 里才加的全新玩意。</p><pre><code>#include &lt;iostream&gt;class Base&#123;    protected:        void print() const        &#123;            std::cout &lt;&lt; 2333 &lt;&lt; std::endl;        &#125;&#125;;class Derived: public Base&#123;    public:        using Base::print;        // 如果不加这句声明，        // 则 print 方法在 Derived 类中就仍是 protected 的        // main 中无法调用&#125;;int main()&#123;    Derived d;    d.print();&#125;</code></pre><p>如上例所示，这种语法可以改变方法的访问控制域，比如将基类的保护方法公开出来，当然也可以将基类的公开方法在子类中变更为私有。再强调一下，这个是 C++98 中就有的语法。只不过 98 里不能 using 父类::构造函数（构造函数在某种意义上也是类的方法对吧，所以 11 补上了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承构造函数&quot;&gt;&lt;a href=&quot;#继承构造函数&quot; class=&quot;headerlink&quot; title=&quot;继承构造函数&quot;&gt;&lt;/a&gt;继承构造函数&lt;/h1&gt;&lt;p&gt;继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数&lt;/p&gt;
&lt;pre&gt;&lt;co</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="c++11" scheme="http://example.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/p/d04bd5bc.html"/>
    <id>http://example.com/p/d04bd5bc.html</id>
    <published>2023-08-06T13:10:20.145Z</published>
    <updated>2023-08-07T15:25:35.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="多线程接触过吗？控制线程访问共享资源有哪些锁？"><a href="#多线程接触过吗？控制线程访问共享资源有哪些锁？" class="headerlink" title="多线程接触过吗？控制线程访问共享资源有哪些锁？"></a>多线程接触过吗？控制线程访问共享资源有哪些锁？</h2><h2 id="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"><a href="#介绍一下互斥锁（中间穿插了一点项目的实现细节问题）" class="headerlink" title="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"></a>介绍一下互斥锁（中间穿插了一点项目的实现细节问题）</h2><h2 id="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"><a href="#用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？" class="headerlink" title="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"></a>用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？</h2><h2 id="操作系统是怎么进行内存管理的？"><a href="#操作系统是怎么进行内存管理的？" class="headerlink" title="操作系统是怎么进行内存管理的？"></a>操作系统是怎么进行内存管理的？</h2><h2 id="程序的状态有哪些？"><a href="#程序的状态有哪些？" class="headerlink" title="程序的状态有哪些？"></a>程序的状态有哪些？</h2><h2 id="详细介绍一下每个状态是怎样转换的？"><a href="#详细介绍一下每个状态是怎样转换的？" class="headerlink" title="详细介绍一下每个状态是怎样转换的？"></a>详细介绍一下每个状态是怎样转换的？</h2><h2 id="你知道的进程调度算法有哪些？详细介绍一下？"><a href="#你知道的进程调度算法有哪些？详细介绍一下？" class="headerlink" title="你知道的进程调度算法有哪些？详细介绍一下？"></a>你知道的进程调度算法有哪些？详细介绍一下？</h2><h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><h2 id="多进程fork后不同进程会共享哪些资源"><a href="#多进程fork后不同进程会共享哪些资源" class="headerlink" title="多进程fork后不同进程会共享哪些资源"></a>多进程fork后不同进程会共享哪些资源</h2><h2 id="多线程里线程的同步方式有哪些"><a href="#多线程里线程的同步方式有哪些" class="headerlink" title="多线程里线程的同步方式有哪些"></a>多线程里线程的同步方式有哪些</h2><h2 id="select怎么用。底层原理"><a href="#select怎么用。底层原理" class="headerlink" title="select怎么用。底层原理"></a>select怎么用。底层原理</h2><h2 id="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"><a href="#select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。" class="headerlink" title="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"></a>select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。</h2><h2 id="epoll-底层为什么用红黑树不用hash"><a href="#epoll-底层为什么用红黑树不用hash" class="headerlink" title="epoll 底层为什么用红黑树不用hash"></a>epoll 底层为什么用红黑树不用hash</h2><h2 id="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"><a href="#了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别" class="headerlink" title="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"></a>了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别</h2><h2 id="介绍一下epoll的两种实现方式"><a href="#介绍一下epoll的两种实现方式" class="headerlink" title="介绍一下epoll的两种实现方式"></a>介绍一下epoll的两种实现方式</h2><h2 id="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"><a href="#磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？" class="headerlink" title="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"></a>磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？</h2><h2 id="有了解epoll的底层数据结构吗？介绍一下"><a href="#有了解epoll的底层数据结构吗？介绍一下" class="headerlink" title="有了解epoll的底层数据结构吗？介绍一下"></a>有了解epoll的底层数据结构吗？介绍一下</h2><h2 id="如何限制一个进程能够使用的线程等资源"><a href="#如何限制一个进程能够使用的线程等资源" class="headerlink" title="如何限制一个进程能够使用的线程等资源"></a>如何限制一个进程能够使用的线程等资源</h2><p>ulimit -u 4096</p><p>这属于软限制，是可以改变的。也就是说在我的机器上最多可以有4096个进程，但是我可以通过改变这个参数的值来修改对于进程数量的软限制，比如说用下面的命令将软限制改到5120。</p><p>ulimit -u 5120</p><h2 id="了解过stdexec吗（NVIDIA的异步编程高性能库）"><a href="#了解过stdexec吗（NVIDIA的异步编程高性能库）" class="headerlink" title="了解过stdexec吗（NVIDIA的异步编程高性能库）"></a>了解过stdexec吗（NVIDIA的异步编程高性能库）</h2><p>没有</p><h2 id="使用过perf吗"><a href="#使用过perf吗" class="headerlink" title="使用过perf吗"></a>使用过perf吗</h2><p>没有</p><h2 id="怎么查看tlb命中率"><a href="#怎么查看tlb命中率" class="headerlink" title="怎么查看tlb命中率"></a>怎么查看tlb命中率</h2><h2 id="如何查看进程的线程数"><a href="#如何查看进程的线程数" class="headerlink" title="如何查看进程的线程数"></a>如何查看进程的线程数</h2><p>使用top命令，具体用法是 top -H</p><pre><code>    加上这个选项，top的每一行就不是显示一个进程，而是一个线程。</code></pre><p>使用ps命令，具体用法是 ps -xH</p><pre><code>    这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。</code></pre><p> 使用ps命令，具体用法是 ps -mq PID</p><pre><code>    这样可以看到指定的进程产生的线程数目。</code></pre><h2 id="如何查看进程打开的文件有哪些"><a href="#如何查看进程打开的文件有哪些" class="headerlink" title="如何查看进程打开的文件有哪些"></a>如何查看进程打开的文件有哪些</h2><p>1.列出所有打开的文件:</p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><ol start="2"><li>查看谁正在使用某个文件</li></ol><p>lsof   &#x2F;filepath&#x2F;file</p><p>3.递归查看某个目录的文件信息</p><p>lsof +D &#x2F;filepath&#x2F;filepath2&#x2F;</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><ol start="4"><li>比使用+D选项，遍历查看某个目录的所有文件信息 的方法</li></ol><p>lsof | grep ‘&#x2F;filepath&#x2F;filepath2&#x2F;’</p><ol start="5"><li>列出某个用户打开的文件信息</li></ol><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><ol start="6"><li>列出某个程序所打开的文件信息</li></ol><p>lsof -c mysql</p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p><ol start="7"><li>列出多个程序多打开的文件信息</li></ol><p>lsof -c mysql -c apache</p><ol start="8"><li>列出某个用户以及某个程序所打开的文件信息</li></ol><p>lsof -u test -c mysql</p><ol start="9"><li>列出除了某个用户外的被打开的文件信息</li></ol><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><ol start="10"><li>通过某个进程号显示该进行打开的文件</li></ol><p>lsof -p 1</p><ol start="11"><li>列出多个进程号对应的文件信息</li></ol><p>lsof -p 123,456,789</p><ol start="12"><li>列出除了某个进程号，其他进程号所打开的文件信息</li></ol><p>lsof -p ^1</p><p>13 . 列出所有的网络连接</p><p>lsof -i</p><ol start="14"><li>列出所有tcp 网络连接信息</li></ol><p>lsof  -i tcp</p><ol start="15"><li>列出所有udp网络连接信息</li></ol><p>lsof  -i udp</p><ol start="16"><li>列出谁在使用某个端口</li></ol><p>lsof -i :3306</p><ol start="17"><li>列出谁在使用某个特定的udp端口</li></ol><p>lsof -i udp:55</p><p>特定的tcp端口</p><p>lsof -i tcp:80</p><ol start="18"><li>列出某个用户的所有活跃的网络端口</li></ol><p>lsof  -a -u test -i</p><ol start="19"><li>列出所有网络文件系统</li></ol><p>lsof -N</p><p>20.域名socket文件</p><p>lsof -u</p><p>21.某个用户组所打开的文件信息</p><p>lsof -g 5555</p><ol start="22"><li>根据文件描述列出对应的文件信息</li></ol><p>lsof -d description(like 2)</p><ol start="23"><li>根据文件描述范围列出文件信息</li></ol><p>lsof -d 2-3</p><h2 id="产生死锁的条件以及怎么解决死锁问题"><a href="#产生死锁的条件以及怎么解决死锁问题" class="headerlink" title="产生死锁的条件以及怎么解决死锁问题"></a>产生死锁的条件以及怎么解决死锁问题</h2><h2 id="Linux大概学到什么程度？"><a href="#Linux大概学到什么程度？" class="headerlink" title="Linux大概学到什么程度？"></a>Linux大概学到什么程度？</h2><h2 id="线程怎么创建，什么语言"><a href="#线程怎么创建，什么语言" class="headerlink" title="线程怎么创建，什么语言"></a>线程怎么创建，什么语言</h2><h2 id="线程的基本状态有哪几个？"><a href="#线程的基本状态有哪几个？" class="headerlink" title="线程的基本状态有哪几个？"></a>线程的基本状态有哪几个？</h2><h2 id="多线程的使用的好处是什么"><a href="#多线程的使用的好处是什么" class="headerlink" title="多线程的使用的好处是什么"></a>多线程的使用的好处是什么</h2><h2 id="多线程会竞争资源出现死锁的状态，死锁怎么解决？"><a href="#多线程会竞争资源出现死锁的状态，死锁怎么解决？" class="headerlink" title="多线程会竞争资源出现死锁的状态，死锁怎么解决？"></a>多线程会竞争资源出现死锁的状态，死锁怎么解决？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;多线程接触过吗？控制线程访问共享资源有哪些锁？&quot;&gt;&lt;a href=&quot;#多线程接触过吗？控制线程访问共享资源有哪些锁</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp面向对象</title>
    <link href="http://example.com/p/87fdbf5e.html"/>
    <id>http://example.com/p/87fdbf5e.html</id>
    <published>2023-08-06T09:30:39.389Z</published>
    <updated>2023-08-06T09:49:23.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp面向对象"><a href="#cpp面向对象" class="headerlink" title="cpp面向对象"></a>cpp面向对象</h1><p>面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装可以隐藏实现细节，使得代码模块化；封装将一些属性和相关方法封装在一个对象中，对数据的访问只能通过已定义的界面。对外隐藏内部具体实现细节。内部实现，外界不需要关心，外界只需要根据“内部提供的接口”去使用就可以。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><ul><li>保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）</li><li>隐藏方法（实现）细节，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</li><li>封装可以使对象拥有完整的属性和方法（类中的函数）</li><li>外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p><p>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>多态的构成条件</p><ul><li>必须通过基类的指针或者引用调用虚函数<ul><li>虚函数：在类的普通成员函数前加上virtual关键字+</li></ul></li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp面向对象&quot;&gt;&lt;a href=&quot;#cpp面向对象&quot; class=&quot;headerlink&quot; title=&quot;cpp面向对象&quot;&gt;&lt;/a&gt;cpp面向对象&lt;/h1&gt;&lt;p&gt;面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp内存管理</title>
    <link href="http://example.com/p/ee3dbaf8.html"/>
    <id>http://example.com/p/ee3dbaf8.html</id>
    <published>2023-08-06T08:45:54.616Z</published>
    <updated>2023-08-06T11:12:00.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp内存管理"><a href="#cpp内存管理" class="headerlink" title="cpp内存管理"></a>cpp内存管理</h1><p><img src="https://s1.ax1x.com/2023/08/06/pPA4Y7T.png" alt="pPA4Y7T.png"></p><p>栈：又叫堆栈，主要存放非静态局部变量、函数参数、返回值等等，栈是向下增长的；</p><p>BSS（Block started by symbol)：存放未初始化的全局和静态变量。</p><p>堆：用于程序运行时动态内存分配，堆是可以上增长的；</p><p>数据段：存储全局数据和静态数据，常量数据（如字符串常量）。</p><p>代码段：存储可执行的代码与只读常量；</p><p>当全局&#x2F;静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。</p><pre><code>int x;int z = 5;void func()&#123;    static int y;&#125;int main()&#123;    return 0;&#125;</code></pre><p>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p><p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p><p>而对于已经初始化了的全局&#x2F;静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p><h2 id="堆和栈的主要区别"><a href="#堆和栈的主要区别" class="headerlink" title="堆和栈的主要区别"></a>堆和栈的主要区别</h2><p>有以下几点：</p><ul><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ul><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="让一个对象只在栈（堆）上分配内存"><a href="#让一个对象只在栈（堆）上分配内存" class="headerlink" title="让一个对象只在栈（堆）上分配内存"></a>让一个对象只在栈（堆）上分配内存</h2><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<br>虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。<br>将operator new()设为私有即可禁止对象被new在堆上。</p><pre><code>class A  &#123;  private:      void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的      void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  public:      A()&#123;&#125;      ~A()&#123;&#125;  &#125;;</code></pre><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><p>就是不能静态建立类对象, 即不能直接调用类的构造函数。<br>首先要知道， 当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</p><pre><code>class A&#123;public:    A()&#123;&#125;    void destroy()&#123;delete this;&#125;private:    ~A()&#123;&#125;&#125;</code></pre><p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</p><p>存在问题：<br>1.无法解决继承问题：为了实现多态， 析构函数通常要设为virtual， 因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。<br>2. new和destroy的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp内存管理&quot;&gt;&lt;a href=&quot;#cpp内存管理&quot; class=&quot;headerlink&quot; title=&quot;cpp内存管理&quot;&gt;&lt;/a&gt;cpp内存管理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/06/pPA4Y7T.p</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp</title>
    <link href="http://example.com/p/caeaa4a1.html"/>
    <id>http://example.com/p/caeaa4a1.html</id>
    <published>2023-08-06T07:08:25.455Z</published>
    <updated>2023-08-07T14:54:20.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h1><p><a href="https://www.dotcpp.com/course/808">https://www.dotcpp.com/course/808</a></p><h2 id="c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗"><a href="#c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗" class="headerlink" title="c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗"></a>c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗</h2><p>封装、继承、多态</p><h2 id="c-面向对象编程讲一下"><a href="#c-面向对象编程讲一下" class="headerlink" title="c++面向对象编程讲一下"></a>c++面向对象编程讲一下</h2><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><h2 id="多态和继承在什么情况下使用"><a href="#多态和继承在什么情况下使用" class="headerlink" title="多态和继承在什么情况下使用"></a>多态和继承在什么情况下使用</h2><h2 id="除了多态和继承还有什么面向对象方法"><a href="#除了多态和继承还有什么面向对象方法" class="headerlink" title="除了多态和继承还有什么面向对象方法"></a>除了多态和继承还有什么面向对象方法</h2><h2 id="能再仔细介绍一下c-的多态吗"><a href="#能再仔细介绍一下c-的多态吗" class="headerlink" title="能再仔细介绍一下c++的多态吗"></a>能再仔细介绍一下c++的多态吗</h2><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h2 id="多态是怎么调用派生类重写的方法的"><a href="#多态是怎么调用派生类重写的方法的" class="headerlink" title="多态是怎么调用派生类重写的方法的"></a>多态是怎么调用派生类重写的方法的</h2><h2 id="实现String-的普通和拷贝构造、赋值重载和析构函数"><a href="#实现String-的普通和拷贝构造、赋值重载和析构函数" class="headerlink" title="实现String 的普通和拷贝构造、赋值重载和析构函数"></a>实现String 的普通和拷贝构造、赋值重载和析构函数</h2><pre><code>#pragma warning(disable:4996)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyString &#123;public:    // 默认构造函数    MyString(const char* str = NULL);    // 复制构造函数    MyString(const MyString&amp; str);    // 移动构造函数    MyString(MyString&amp;&amp; str)noexcept;    // 析构函数    ~MyString();    // 字符串连接    MyString operator+(const MyString&amp; str);    // 拷贝赋值    MyString&amp; operator=(const MyString&amp; str);    //移动赋值    MyString&amp; operator=(MyString&amp;&amp; str);    // 字符串赋值    MyString&amp; operator=(const char* str);    // 判断是否字符串相等    bool operator==(const MyString&amp; str);    // 获取字符串长度    int length();    // 求子字符串[start,start+n-1]    MyString substr(int start, int n);    // 重载输出    friend ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str);private:    char* m_data;    int m_size;&#125;;// 构造函数MyString::MyString(const char* str)&#123;    if (str == nullptr)    &#123;        m_data = new char[1];        m_data[0] = &#39;\0&#39;;        m_size = 0;    &#125;    else    &#123;        m_size = strlen(str);        m_data = new char[m_size + 1];        strcpy(m_data, str);    &#125;&#125;// 复制构造函数MyString::MyString(const MyString&amp; str)&#123;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);&#125;// 析构函数MyString::~MyString()&#123;    delete[] m_data;&#125;// 字符串连接MyString MyString::operator+(const MyString&amp; str)&#123;    MyString newStr;    //释放原有空间    delete[] newStr.m_data;    newStr.m_size = m_size + str.m_size;    newStr.m_data = new char[newStr.m_size + 1];    strcpy(newStr.m_data, m_data);    strcpy(newStr.m_data + m_size, str.m_data);    return newStr;&#125;// 字符串赋值MyString&amp; MyString::operator=(const MyString&amp; str)&#123;    if (m_data == str.m_data)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);    return *this;&#125;MyString&amp; MyString::operator=(MyString&amp;&amp; str)&#123;    if (str.m_data == m_data)    &#123;        return *this;    &#125;    delete m_data;    m_data = str.m_data;    m_size = str.m_size;    str.m_data = nullptr;    str.m_size = 0;&#125;// 字符串赋值MyString&amp; MyString::operator=(const char* str)&#123;    if (m_data == str)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = strlen(str);    m_data = new char[m_size + 1];    strcpy(m_data, str);    return *this;&#125;// 判断是否字符串相等bool MyString::operator==(const MyString&amp; str)&#123;    return strcmp(m_data, str.m_data) == 0;&#125;// 获取字符串长度int MyString::length()&#123;    return m_size;&#125;// 求子字符串[start,start+n-1]MyString MyString::substr(int start, int n)&#123;    MyString newStr;    // 释放原有内存    delete[] newStr.m_data;    // 重新申请内存    newStr.m_data = new char[n + 1];    for (int i = 0;i &lt; n;++i)    &#123;        newStr.m_data[i] = m_data[start + i];    &#125;    newStr.m_data[n] = &#39;\0&#39;;    newStr.m_size = n;    return newStr;&#125;MyString::MyString(MyString&amp;&amp; str) noexcept&#123;    m_data = str.m_data;    str.m_data = nullptr;    m_size = str.m_size;    str.m_size = 0;&#125;// 重载输出ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str)&#123;    o &lt;&lt; str.m_data;    return o;&#125;</code></pre><h2 id="有了new是不是可以就不用malloc了？"><a href="#有了new是不是可以就不用malloc了？" class="headerlink" title="有了new是不是可以就不用malloc了？"></a>有了new是不是可以就不用malloc了？</h2><p>比如内存池，在这个基础上可以利用placement new<br>c 没有new  </p><h2 id="malloc是如何跟物理地址关联上的？"><a href="#malloc是如何跟物理地址关联上的？" class="headerlink" title="malloc是如何跟物理地址关联上的？"></a>malloc是如何跟物理地址关联上的？</h2><p>malloc申请内存返回的是虚拟地址而不是物理地址，而且，返回的这个虚拟地址是没有map映射到物理内存中的，只有当程序(进程)用到访问了这个地址的时候，</p><p>内核才响应“缺页异常”，才回去映射一块物理地址。</p><p>关于malloc(0) 能申请成功是肯定的，它返回的是虚拟地址(对应的物理地址还不确定的)，在你没用到这块地址空间的时候，它不会再物理上开辟内存。</p><p>在你用到malloc(0)返回的地址时，因为参数为0，缺页异常不会为你的进程空间申请额外内存。所以这个指针应该是不能用的。</p><h2 id="new-x2F-delete-malloc-x2F-free-区别"><a href="#new-x2F-delete-malloc-x2F-free-区别" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free 区别"></a>new&#x2F;delete  malloc&#x2F;free 区别</h2><ol><li>运算符库函数</li><li>构造函数析构函数</li><li>可以重载</li><li>手动计算大小，自动计算大小</li><li>类型安全</li></ol><h2 id="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"><a href="#讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常" class="headerlink" title="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"></a>讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常</h2><p>调用malloc+构造函数<br>nothrow指定<br>bad——alloc</p><h2 id="malloc线程安全吗，多线程malloc系统怎么设计"><a href="#malloc线程安全吗，多线程malloc系统怎么设计" class="headerlink" title="malloc线程安全吗，多线程malloc系统怎么设计"></a>malloc线程安全吗，多线程malloc系统怎么设计</h2><p>在多线程环境下，使用 malloc() 和 free() 函数需要特别注意，因为这两个函数都会涉及到内存的分配和释放，容易引起多线程竞争问题，可能会导致内存泄漏或程序崩溃。</p><p>为了避免这些问题，需要采取以下措施：</p><p>确保线程安全：多个线程同时使用 malloc() 或 free() 时可能会导致内存竞争。为了确保线程安全，可以使用线程安全的内存分配器，例如 tcmalloc 或 jemalloc，或者使用互斥锁来保护内存分配和释放的操作。</p><p>避免内存泄漏：如果在分配内存后忘记释放，将会导致内存泄漏。在多线程环境中，内存泄漏问题可能会更加复杂，因为在一个线程中分配的内存可能需要在另一个线程中释放。为了避免内存泄漏，应该在适当的时候调用 free() 函数来释放已经不再使用的内存。</p><p>避免悬挂指针问题：在多线程环境中，如果一个线程释放了某个内存块，而另一个线程仍然在使用这个内存块，就可能导致悬挂指针问题。为了避免这个问题，应该在释放内存块之前确保没有其他线程在使用该内存块，可以使用同步机制来解决这个问题。</p><p>总之，在多线程环境中，使用 malloc() 和 free() 函数需要特别小心，需要采取适当的措施来确保线程安全和避免内存泄漏和悬挂指针问题。</p><h2 id="C-内存分布。什么样的数据在栈区，什么样的在堆区。"><a href="#C-内存分布。什么样的数据在栈区，什么样的在堆区。" class="headerlink" title="C++内存分布。什么样的数据在栈区，什么样的在堆区。"></a>C++内存分布。什么样的数据在栈区，什么样的在堆区。</h2><p>局部栈区，全局堆区</p><h2 id="C-内存管理（RAII啥的）"><a href="#C-内存管理（RAII啥的）" class="headerlink" title="C++内存管理（RAII啥的）"></a>C++内存管理（RAII啥的）</h2><p>资源获取即初始化。使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><h2 id="sizeof一个空的结构体，返回什么"><a href="#sizeof一个空的结构体，返回什么" class="headerlink" title="sizeof一个空的结构体，返回什么"></a>sizeof一个空的结构体，返回什么</h2><p>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><h2 id="问了c-文件编译过程"><a href="#问了c-文件编译过程" class="headerlink" title="问了c++文件编译过程"></a>问了c++文件编译过程</h2><p>预编译  cpp<br>汇编    i<br>编译    s<br>链接    o</p><h2 id="静态链接动态链接区别"><a href="#静态链接动态链接区别" class="headerlink" title="静态链接动态链接区别"></a>静态链接动态链接区别</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="动态链接库具体怎样操作链接的"><a href="#动态链接库具体怎样操作链接的" class="headerlink" title="动态链接库具体怎样操作链接的"></a>动态链接库具体怎样操作链接的</h2><p>重定位   忘了待更新</p><h2 id="c-学的好的是哪块-具体说"><a href="#c-学的好的是哪块-具体说" class="headerlink" title="c++学的好的是哪块 具体说"></a>c++学的好的是哪块 具体说</h2><p>学得最好的是没有</p><h2 id="野指针和内存泄漏是什么，如何避免？"><a href="#野指针和内存泄漏是什么，如何避免？" class="headerlink" title="野指针和内存泄漏是什么，如何避免？"></a>野指针和内存泄漏是什么，如何避免？</h2><p>内存泄漏：①访问已经释放的内存</p><pre><code>②访问没有权限的内存</code></pre><p>野指针：指向内存被释放的内存或者没有访问权限的内存的指针。<br>野指针”的成因主要有3种：<br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><h2 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h2><p>智能指针</p><h2 id="内存泄漏怎样应对"><a href="#内存泄漏怎样应对" class="headerlink" title="内存泄漏怎样应对"></a>内存泄漏怎样应对</h2><p>智能指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><h2 id="讲一下智能指针"><a href="#讲一下智能指针" class="headerlink" title="讲一下智能指针"></a>讲一下智能指针</h2><h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="讲讲智能指针"><a href="#讲讲智能指针" class="headerlink" title="讲讲智能指针"></a>讲讲智能指针</h2><h2 id="c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用"><a href="#c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用" class="headerlink" title="c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用"></a>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用</h2><h2 id="shared-ptr循环引用怎么解决"><a href="#shared-ptr循环引用怎么解决" class="headerlink" title="shared_ptr循环引用怎么解决"></a>shared_ptr循环引用怎么解决</h2><p>weak_ptr</p><h2 id="make-shared和shared-ptr"><a href="#make-shared和shared-ptr" class="headerlink" title="make_shared和shared_ptr"></a>make_shared和shared_ptr</h2><p>std::shared_ptr构造函数会执行两次内存申请，而std::make_shared则执行一次。<br>std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr<A> p2(new A)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared<A>()则是只执行一次内存申请，将数据和控制块的申请放到一起。</A></A></p><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>考虑下面一段代码：</p><pre><code>void f(std::shared_ptr&lt;Lhs&gt; &amp;lhs, std::shared_ptr&lt;Rhs&gt; &amp;rhs)&#123;...&#125;...f(std::shared_ptr&lt;Lhs&gt;(new Lhs()),std::shared_ptr&lt;Rhs&gt;(new Rhs()));</code></pre><p>因为C++允许参数在计算的时候打乱顺序，因此一个可能的顺序如下:</p><pre><code>new Lhs()new Rhs()std::shared_ptrstd::shared_ptr</code></pre><p>此时假设第2步出现异常，则在第一步申请的内存将没处释放了，上面产生内存泄露的本质是当申请数据指针后，没有马上传给std::shared_ptr，因此一个可能的解决办法是：</p><pre><code>auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs());auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs());f(lhs, rhs);</code></pre><p>当然更好的方法是：</p><pre><code>f(std::make_shared&lt;Lhs&gt;(),    std::make_shared&lt;Rhs&gt;());</code></pre><p>make_shared的缺点<br>因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。</p><p>什么是weak_ptr？<br>weak_ptr是用来指向shared_ptr，用来判断shared_ptr指向的数据内存是否还存在了（通过方法lock），下面是一段示例代码：</p><pre><code>#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;struct A&#123;    int _i;    A(): _i(int())&#123;&#125;    A(int i): _i(i)&#123;&#125;&#125;;int main()&#123;    shared_ptr&lt;A&gt; sharedPtr(new A(2));    weak_ptr&lt;A&gt; weakPtr = sharedPtr;    sharedPtr.reset(new A(3)); // reset，weakPtr指向的失效了。    cout &lt;&lt; weakPtr.use_count() &lt;&lt;endl;&#125;</code></pre><p>通过lock（）来判断是否存在了，lock（）相当于</p><pre><code>expired（）？shared_ptr&lt;element_type&gt;() ： shared_ptr&lt;element_type&gt;(*this)</code></pre><p>当不存在的时候，会返回一个空的shared_ptr，weak_ptr在指向shared_ptr的时候，并不会增加ref count，因此weak_ptr主要有两个用途：</p><ul><li>用来记录对象是否存在了</li><li>用来解决shared_ptr环形依赖问题</li></ul><h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a>map和set</h2><p>底层红黑树，剩下不会了</p><h2 id="迭代器作用-迭代器和指针的区别"><a href="#迭代器作用-迭代器和指针的区别" class="headerlink" title="迭代器作用 迭代器和指针的区别"></a>迭代器作用 迭代器和指针的区别</h2><p><a href="https://whl963854.github.io/p/2cf69f40.html">https://whl963854.github.io/p/2cf69f40.html</a></p><h2 id="析构函数作用"><a href="#析构函数作用" class="headerlink" title="析构函数作用"></a>析构函数作用</h2><p>完成一些清理工作，比如：释放内存等。</p><h2 id="static关键字在C-中有什么作用？"><a href="#static关键字在C-中有什么作用？" class="headerlink" title="static关键字在C++中有什么作用？"></a>static关键字在C++中有什么作用？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰的类的数据成员怎么初始化的？"><a href="#static修饰的类的数据成员怎么初始化的？" class="headerlink" title="static修饰的类的数据成员怎么初始化的？"></a>static修饰的类的数据成员怎么初始化的？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"><a href="#static修饰类的成员函数，这个成员函数使用起来有哪些限制？" class="headerlink" title="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"></a>static修饰类的成员函数，这个成员函数使用起来有哪些限制？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="知道哪些c-中的关键字，然后讲了static"><a href="#知道哪些c-中的关键字，然后讲了static" class="headerlink" title="知道哪些c++中的关键字，然后讲了static"></a>知道哪些c++中的关键字，然后讲了static</h2><h2 id="static变量存储在哪，和局部变量存储位置有什么区别"><a href="#static变量存储在哪，和局部变量存储位置有什么区别" class="headerlink" title="static变量存储在哪，和局部变量存储位置有什么区别?"></a>static变量存储在哪，和局部变量存储位置有什么区别?</h2><h2 id="C-你觉得最特别于其他语言的点是什么"><a href="#C-你觉得最特别于其他语言的点是什么" class="headerlink" title="C++你觉得最特别于其他语言的点是什么"></a>C++你觉得最特别于其他语言的点是什么</h2><h2 id="java，python，c-垃圾回收怎么实现的"><a href="#java，python，c-垃圾回收怎么实现的" class="headerlink" title="java，python，c++垃圾回收怎么实现的"></a>java，python，c++垃圾回收怎么实现的</h2><h2 id="指针和引用的区别，左值右值，右值引用"><a href="#指针和引用的区别，左值右值，右值引用" class="headerlink" title="指针和引用的区别，左值右值，右值引用"></a>指针和引用的区别，左值右值，右值引用</h2><p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>可以有const指针，但是没有const引用；<br>指针可以有多级，但是引用只能是一级<br>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或–</p><p>引用在汇编层面会被c++编译器当做const指针来进行操作</p><h2 id="说说对指针和引用的理解"><a href="#说说对指针和引用的理解" class="headerlink" title="说说对指针和引用的理解"></a>说说对指针和引用的理解</h2><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="堆和栈的区别。什么情况下会往堆里放"><a href="#堆和栈的区别。什么情况下会往堆里放" class="headerlink" title="堆和栈的区别。什么情况下会往堆里放"></a>堆和栈的区别。什么情况下会往堆里放</h2><p>new<br>malloc</p><h2 id="堆区都是手动释放？"><a href="#堆区都是手动释放？" class="headerlink" title="堆区都是手动释放？"></a>堆区都是手动释放？</h2><p>答：也不一定，主要看使用方法。如果使用的函数是malloc，new之类，就需要手动释放，不然会造成内存泄漏。但是如果我们使用智能指针，智能指针会自动释放内存，因为智能指针基于类自动调用析构函数实现了内存的自动释放</p><h2 id="C-哪些运算符不能重载？"><a href="#C-哪些运算符不能重载？" class="headerlink" title="C++哪些运算符不能重载？"></a>C++哪些运算符不能重载？</h2><p>答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p><p>以下运算符不能被重载：.、.*、::、? :、sizeof。<br>重载运算符()、[]、-&gt;、或者赋值运算符&#x3D;时，只能将它们重载为成员函数，不能重载为全局函数。</p><h2 id="char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别"><a href="#char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别" class="headerlink" title="char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别"></a>char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别</h2><p>4  3 size</p><h2 id="C-11的特性有没有"><a href="#C-11的特性有没有" class="headerlink" title="C++11的特性有没有"></a>C++11的特性有没有</h2><p>初始化列表 使用 {} 可以方便地初始化数组、结构体、类等对象<br>智能指针 引入了 std::unique_ptr、std::shared_ptr 等智能指针，方便地进行动态内存管理<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式 可以在函数内部定义匿名函数，从而方便地实现函数对象。<br>字符串字面量<br>auto 自动类型推导：使用关键字 auto 可以让编译器自动推导变量的类型。<br>枚举类<br>完美转发<br>移动语义 使用 &amp;&amp; 可以表示右值引用，引入了移动构造函数和移动赋值运算符，可以减少不必要的拷贝。<br>constexptr<br>静态断言 使用关键字 static_assert 可以在编译时检查一个表达式是否为 true<br>新的容器和算法：引入了 std::array、std::forward_list、std::unordered_map、std::move 等新特性，增强了容器和算法库的功能。</p><h2 id="聊一聊你理解的移动构造函数？"><a href="#聊一聊你理解的移动构造函数？" class="headerlink" title="聊一聊你理解的移动构造函数？"></a>聊一聊你理解的移动构造函数？</h2><p>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。</p><h2 id="那c-有哪些构造函数呢？"><a href="#那c-有哪些构造函数呢？" class="headerlink" title="那c++有哪些构造函数呢？"></a>那c++有哪些构造函数呢？</h2><p>答：默认构造函数，有参构造函数，拷贝构造函数，移动构造函数。<br>委托构造函数<br>继承构造函数</p><h2 id="介绍一下map容器？"><a href="#介绍一下map容器？" class="headerlink" title="介绍一下map容器？"></a>介绍一下map容器？</h2><p>答：map支持kv键值对的查找，底层基于红黑树，查询和插入的时间复杂度都是logn。因为底层基于红黑树，map的key是有序的，所以map容器为我们提供了一些有序的api，比如对key的二分查找(lower_bound）。与此同时，我们还有unoredered_map,这个容器是哈希表，查询和插入的时间复杂度是O(1)，但是如果遇上哈希冲突，复杂度可能退化到O(n)。这个容器的key是无序的。unordered_map的使用的常数时间是要比map快一到两倍。</p><h2 id="讲一讲const关键字。"><a href="#讲一讲const关键字。" class="headerlink" title="讲一讲const关键字。"></a>讲一讲const关键字。</h2><p>答：const关键字在C++11之前，具有只读和常量两个语义。在C++11，引入constexpr关键字之后，const语义固定在了只读，constexpr固定为常量，但总而言之，这个两个关键字核心的语义是，指向的内容不可更改。<br>const 关键字用于指定变量或对象的值是不可修改的。它可以用于修饰变量、函数参数、函数返回值和成员函数等。 constexpr 关键字用于指定表达式在编译时就能够被计算出结果，从而产生一个编译期常量。它可以用于修饰变量、函数、类和模板等。constexpr 的作用是在编译时进行计算，从而提高程序的性能。</p><h2 id="那const指向地址呢？"><a href="#那const指向地址呢？" class="headerlink" title="那const指向地址呢？"></a>那const指向地址呢？</h2><p>答：const指向的地址值不可更改，但是地址对应的内容是可更改的。</p><h2 id="const关键字修饰类的对象使用起来有什么限制？"><a href="#const关键字修饰类的对象使用起来有什么限制？" class="headerlink" title="const关键字修饰类的对象使用起来有什么限制？"></a>const关键字修饰类的对象使用起来有什么限制？</h2><p><a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="const关键字修饰类的对象有什么办法改变内部数据？"><a href="#const关键字修饰类的对象有什么办法改变内部数据？" class="headerlink" title="const关键字修饰类的对象有什么办法改变内部数据？"></a>const关键字修饰类的对象有什么办法改变内部数据？</h2><p>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="虚函数是什么，重载和重写的关系。"><a href="#虚函数是什么，重载和重写的关系。" class="headerlink" title="虚函数是什么，重载和重写的关系。"></a>虚函数是什么，重载和重写的关系。</h2><p>答：虚函数涉及到C++的多态。当、在基类中声明一个虚函数，在派生类中重写该函数，可以实现动态绑定。在运行时，程序会根据具体对象的类型调用相应的函数。重写要求函数签名完全一致，即函数名，函数变量和返回值完全一致，但是函数体可以不同。重写是运行时多态，也就是动态多态。重载是函数名相同，返回值和函数参数可以不同，重载是编译时多态，即静态多态。</p><h2 id="讲讲你理解的虚基类。"><a href="#讲讲你理解的虚基类。" class="headerlink" title="讲讲你理解的虚基类。"></a>讲讲你理解的虚基类。</h2><p>答：C++的虚基类类似Java的抽象类，是不可以实例化的。【这里回答错了】</p><p>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。虚基类是可以被实例化的。</p><h2 id="C-多态虚函数实现原理。虚函数表里面有哪些东西？"><a href="#C-多态虚函数实现原理。虚函数表里面有哪些东西？" class="headerlink" title="C++多态虚函数实现原理。虚函数表里面有哪些东西？"></a>C++多态虚函数实现原理。虚函数表里面有哪些东西？</h2><h2 id="虚函数和静态函数-虚表"><a href="#虚函数和静态函数-虚表" class="headerlink" title="虚函数和静态函数 虚表"></a>虚函数和静态函数 虚表</h2><h2 id="cpp编译生成二进制文件过程"><a href="#cpp编译生成二进制文件过程" class="headerlink" title=".cpp编译生成二进制文件过程"></a>.cpp编译生成二进制文件过程</h2><p><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><h2 id="C-从源程序到可执行程序的过程"><a href="#C-从源程序到可执行程序的过程" class="headerlink" title="C++从源程序到可执行程序的过程"></a>C++从源程序到可执行程序的过程</h2><h2 id="动态链接和静态链接区别。"><a href="#动态链接和静态链接区别。" class="headerlink" title="动态链接和静态链接区别。"></a>动态链接和静态链接区别。</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="如何优化一个c-程序-局部性"><a href="#如何优化一个c-程序-局部性" class="headerlink" title="如何优化一个c++程序,局部性"></a>如何优化一个c++程序,局部性</h2><p>时间局部性<br>空间局部性</p><h2 id="左值，右值，万能引用，完美转发"><a href="#左值，右值，万能引用，完美转发" class="headerlink" title="左值，右值，万能引用，完美转发"></a>左值，右值，万能引用，完美转发</h2><p><a href="https://whl963854.github.io/p/64657.html">https://whl963854.github.io/p/64657.html</a><br><a href="https://whl963854.github.io/p/3763.html">https://whl963854.github.io/p/3763.html</a><br><a href="https://whl963854.github.io/p/50074.html">https://whl963854.github.io/p/50074.html</a></p><h2 id="STL基本容器用过哪些"><a href="#STL基本容器用过哪些" class="headerlink" title="STL基本容器用过哪些"></a>STL基本容器用过哪些</h2><p>vector<br>string<br>stack<br>queue<br>set<br>map</p><h2 id="能说一下内存泄漏发生的情景吗"><a href="#能说一下内存泄漏发生的情景吗" class="headerlink" title="能说一下内存泄漏发生的情景吗"></a>能说一下内存泄漏发生的情景吗</h2><p>忘了释放内存资源</p><h2 id="size-of是在编译期还是在运行期确定"><a href="#size-of是在编译期还是在运行期确定" class="headerlink" title="size_of是在编译期还是在运行期确定"></a>size_of是在编译期还是在运行期确定</h2><p>sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。</p><h2 id="C-如何调整内存对齐值"><a href="#C-如何调整内存对齐值" class="headerlink" title="C++ 如何调整内存对齐值"></a>C++ 如何调整内存对齐值</h2><p>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</p><h2 id="主机大小端序"><a href="#主机大小端序" class="headerlink" title="主机大小端序"></a>主机大小端序</h2><p>C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的x86处理器是小端模式（Little Endian）。Java编写的程序则唯一采用Big Endian方式来存储数据。</p><h3 id="C-Coroutine"><a href="#C-Coroutine" class="headerlink" title="C++ Coroutine"></a>C++ Coroutine</h3><h2 id="C-虚函数-gt-构造函数能否是虚函数，析构函数"><a href="#C-虚函数-gt-构造函数能否是虚函数，析构函数" class="headerlink" title="C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数"></a>C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数</h2><p>构造不可以<br>析构可</p><h2 id="构造函数能否是虚函数？"><a href="#构造函数能否是虚函数？" class="headerlink" title="构造函数能否是虚函数？"></a>构造函数能否是虚函数？</h2><p>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。</p><p>虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。</p><p>vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。</p><p>如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。</p><p>因此，构造函数不可以是虚函数。</p><h2 id="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"><a href="#多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？" class="headerlink" title="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"></a>多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？</h2><p>使用多线程和使用多进程的选择取决于您的应用程序的需求。</p><p>多线程：在同一个进程中创建多个线程，多个线程共享进程的内存空间，因此它们可以很容易地共享数据，而且通信成本更低。因此，如果您的应用程序需要在单个进程内部并行执行不同任务，并且需要共享大量数据，则多线程是一个很好的选择。</p><p>多进程：当您的应用程序需要在不同的进程之间并行执行任务时，您可以使用多进程。不同进程之间的通信通常比同一进程中的通信慢，但它们拥有完全独立的内存空间，因此不存在内存访问冲突的问题。</p><p>总的来说，多线程适用于在单个进程中并行执行任务，并且需要共享大量数据的情况，而多进程适用于在不同进程中并行执行任务的情况。</p><h2 id="你这个项目是多线程的，那用多进程可不可以实现？"><a href="#你这个项目是多线程的，那用多进程可不可以实现？" class="headerlink" title="你这个项目是多线程的，那用多进程可不可以实现？"></a>你这个项目是多线程的，那用多进程可不可以实现？</h2><h2 id="项目相关介绍一下"><a href="#项目相关介绍一下" class="headerlink" title="项目相关介绍一下"></a>项目相关介绍一下</h2><h2 id="进程和线程的区别。"><a href="#进程和线程的区别。" class="headerlink" title="进程和线程的区别。"></a>进程和线程的区别。</h2><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="为什么要用多线程。多进程可以吗（webserver的）"><a href="#为什么要用多线程。多进程可以吗（webserver的）" class="headerlink" title="为什么要用多线程。多进程可以吗（webserver的）"></a>为什么要用多线程。多进程可以吗（webserver的）</h2><h2 id="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"><a href="#了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？" class="headerlink" title="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"></a>了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？</h2><h2 id="线程池中的队列知道吗？队列是无限大的还是有限的"><a href="#线程池中的队列知道吗？队列是无限大的还是有限的" class="headerlink" title="线程池中的队列知道吗？队列是无限大的还是有限的"></a>线程池中的队列知道吗？队列是无限大的还是有限的</h2><h2 id="介绍一下线程的几种状态。"><a href="#介绍一下线程的几种状态。" class="headerlink" title="介绍一下线程的几种状态。"></a>介绍一下线程的几种状态。</h2><h2 id="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"><a href="#一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？" class="headerlink" title="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"></a>一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？</h2><h2 id="了解线程池吗？大概介绍一下"><a href="#了解线程池吗？大概介绍一下" class="headerlink" title="了解线程池吗？大概介绍一下"></a>了解线程池吗？大概介绍一下</h2><h2 id="多线程会发生什么问题？线程同步有哪些手段？"><a href="#多线程会发生什么问题？线程同步有哪些手段？" class="headerlink" title="多线程会发生什么问题？线程同步有哪些手段？"></a>多线程会发生什么问题？线程同步有哪些手段？</h2><h2 id="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"><a href="#什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？" class="headerlink" title="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"></a>什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？</h2><h2 id="说说对设计模式的理解"><a href="#说说对设计模式的理解" class="headerlink" title="说说对设计模式的理解"></a>说说对设计模式的理解</h2><h2 id="了解设计模式吗？介绍一下单例模式"><a href="#了解设计模式吗？介绍一下单例模式" class="headerlink" title="了解设计模式吗？介绍一下单例模式"></a>了解设计模式吗？介绍一下单例模式</h2><h2 id="了解的设计模式"><a href="#了解的设计模式" class="headerlink" title="了解的设计模式"></a>了解的设计模式</h2><p>单例<br>组件</p><h2 id="手撕一个设计模式"><a href="#手撕一个设计模式" class="headerlink" title="手撕一个设计模式"></a>手撕一个设计模式</h2><h2 id="手写一个单例模式"><a href="#手写一个单例模式" class="headerlink" title="手写一个单例模式"></a>手写一个单例模式</h2><h2 id="设计模式几大原则"><a href="#设计模式几大原则" class="headerlink" title="设计模式几大原则"></a>设计模式几大原则</h2><h2 id="手撕单例模式（懒汉模式）"><a href="#手撕单例模式（懒汉模式）" class="headerlink" title="手撕单例模式（懒汉模式）"></a>手撕单例模式（懒汉模式）</h2><h2 id="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"><a href="#情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统" class="headerlink" title="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"></a>情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统</h2><h2 id="模板元编程（简历上写了，但答的不好）"><a href="#模板元编程（简历上写了，但答的不好）" class="headerlink" title="模板元编程（简历上写了，但答的不好）"></a>模板元编程（简历上写了，但答的不好）</h2><h2 id="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"><a href="#编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的" class="headerlink" title="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"></a>编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的</h2><h2 id="怎么debug，怎么看内存泄漏。"><a href="#怎么debug，怎么看内存泄漏。" class="headerlink" title="怎么debug，怎么看内存泄漏。"></a>怎么debug，怎么看内存泄漏。</h2><h2 id="介绍一下条件变量"><a href="#介绍一下条件变量" class="headerlink" title="介绍一下条件变量"></a>介绍一下条件变量</h2><h2 id="一个对象-x3D-另一个对象会发生什么（赋值构造函数）"><a href="#一个对象-x3D-另一个对象会发生什么（赋值构造函数）" class="headerlink" title="一个对象&#x3D;另一个对象会发生什么（赋值构造函数）"></a>一个对象&#x3D;另一个对象会发生什么（赋值构造函数）</h2><h2 id="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"><a href="#如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）" class="headerlink" title="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"></a>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）</h2><h2 id="py修饰器"><a href="#py修饰器" class="headerlink" title="py修饰器"></a>py修饰器</h2><h2 id="函数重载的机制。重载是在编译期还是在运行期确定"><a href="#函数重载的机制。重载是在编译期还是在运行期确定" class="headerlink" title="函数重载的机制。重载是在编译期还是在运行期确定"></a>函数重载的机制。重载是在编译期还是在运行期确定</h2><h2 id="hash表数据很大。rehash的代价很高，怎么办"><a href="#hash表数据很大。rehash的代价很高，怎么办" class="headerlink" title="hash表数据很大。rehash的代价很高，怎么办"></a>hash表数据很大。rehash的代价很高，怎么办</h2><p>为字典的备用哈希表分配空间：</p><p>如果执行的是扩展操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)*2 的 2n（2 的 n 次方幂）</p><p>如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)的 2n</p><p>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始（为-1 时表示没有进行 rehash）。</p><p>rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当一次 rehash 工作完成之后，程序将 rehashidx 属性的值+1。同时在 serverCron 中调用 rehash 相关函数，在 1ms 的时间内，进行 rehash 处理，每次仅处理少量的转移任务(100 个元素)。</p><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为-1，表示 rehash 操作已完成。</p><h2 id="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"><a href="#最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。" class="headerlink" title="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"></a>最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。</h2><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h2 id="二叉树应用场景-底层结构"><a href="#二叉树应用场景-底层结构" class="headerlink" title="二叉树应用场景 底层结构"></a>二叉树应用场景 底层结构</h2><h2 id="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"><a href="#说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的" class="headerlink" title="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"></a>说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的</h2><h2 id="了解哪些算法，说一点———–我说了排序"><a href="#了解哪些算法，说一点———–我说了排序" class="headerlink" title="了解哪些算法，说一点———–我说了排序"></a>了解哪些算法，说一点———–我说了排序</h2><h2 id="介绍下快速排序的过程"><a href="#介绍下快速排序的过程" class="headerlink" title="介绍下快速排序的过程"></a>介绍下快速排序的过程</h2><h2 id="栈和队列的区别，在实际应用中的场景"><a href="#栈和队列的区别，在实际应用中的场景" class="headerlink" title="栈和队列的区别，在实际应用中的场景"></a>栈和队列的区别，在实际应用中的场景</h2><p>队列</p><p>队列是一种先进先出的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；<br>打印机：当多个任务分配给打印机时，为了防止冲突，创建一个队列，把任务入队，按先入先出的原则处理任务；<br>远程服务器：当多个用户要访问远程服务端的文件时，也用到队列，满足先来先服务的原则；<br>队列理论：用来计算 预测用户在队中的等待时间，队的长度等等问题；<br>常用于处理任务请求队列，例如在操作系统内部处理进程队列、在网络传输协议中处理数据包队列等。</p><p>栈</p><p>栈是一种后进先出的数据结构，也就是说最新添加的项最早被移出；它是一种运算受限的线性表，只能在栈顶进行插入和删除操作。向一个栈插入新元素叫入栈（进栈），就是把新元素放入到栈顶的上面，成为新的栈顶；从一个栈删除元素叫出栈，就是把栈顶的元素删除掉，相邻的成为新栈顶。</p><p>用于符号的匹配：在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。<br>用于计算代数式：如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题；先要把代数式构造成 6 4 8 * + 的形式；逐个读取数据，当读到数字时，把数字入栈；读到运算符时，弹出栈中的两个元素进行运算并把结果压入栈中；<br>构造表达式：比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。（先规定优先级，加减的优先级最低，左括号优先级最高）<br>用于函数调用：因为CPU一次只能执行一个命令，而寄存器也是公用的，当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()。能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。target() 函数执行结束就取栈顶的返回地址继续执行 current()。</p><h2 id="手撕二分查找。"><a href="#手撕二分查找。" class="headerlink" title="手撕二分查找。"></a>手撕二分查找。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp&quot;&gt;&lt;a href=&quot;#cpp&quot; class=&quot;headerlink&quot; title=&quot;cpp&quot;&gt;&lt;/a&gt;cpp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.dotcpp.com/course/808&quot;&gt;https://www.dotcpp.com</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>招商银行</title>
    <link href="http://example.com/p/26e6c52c.html"/>
    <id>http://example.com/p/26e6c52c.html</id>
    <published>2023-08-05T13:45:29.932Z</published>
    <updated>2023-08-06T07:09:39.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"><a href="#介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别" class="headerlink" title="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"></a>介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别</h3><h3 id="Innodb的事务和锁机制"><a href="#Innodb的事务和锁机制" class="headerlink" title="Innodb的事务和锁机制"></a>Innodb的事务和锁机制</h3><h3 id="Mysql如何保证事务的一致性，MVCC与锁介绍"><a href="#Mysql如何保证事务的一致性，MVCC与锁介绍" class="headerlink" title="Mysql如何保证事务的一致性，MVCC与锁介绍"></a>Mysql如何保证事务的一致性，MVCC与锁介绍</h3><h3 id="Innodb和Myisam的索引机制和存储结构"><a href="#Innodb和Myisam的索引机制和存储结构" class="headerlink" title="Innodb和Myisam的索引机制和存储结构"></a>Innodb和Myisam的索引机制和存储结构</h3><h3 id="Mysql的各种日志，以及介绍用途"><a href="#Mysql的各种日志，以及介绍用途" class="headerlink" title="Mysql的各种日志，以及介绍用途"></a>Mysql的各种日志，以及介绍用途</h3><h3 id="何时使用索引，什么时候索引会失效"><a href="#何时使用索引，什么时候索引会失效" class="headerlink" title="何时使用索引，什么时候索引会失效"></a>何时使用索引，什么时候索引会失效</h3><h3 id="单表访问用到的索引"><a href="#单表访问用到的索引" class="headerlink" title="单表访问用到的索引"></a>单表访问用到的索引</h3><h3 id="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"><a href="#查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析" class="headerlink" title="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"></a>查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析</h3><h3 id="如何解决sql注入"><a href="#如何解决sql注入" class="headerlink" title="如何解决sql注入"></a>如何解决sql注入</h3><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="你还有什么我没看到的优点，可以说一说（我是懵的）"><a href="#你还有什么我没看到的优点，可以说一说（我是懵的）" class="headerlink" title="你还有什么我没看到的优点，可以说一说（我是懵的）"></a>你还有什么我没看到的优点，可以说一说（我是懵的）</h3><h3 id="对工科有什么看法？？？"><a href="#对工科有什么看法？？？" class="headerlink" title="对工科有什么看法？？？"></a>对工科有什么看法？？？</h3><h3 id="开始问项目经验，项目经历-——————-出乎意料"><a href="#开始问项目经验，项目经历-——————-出乎意料" class="headerlink" title="开始问项目经验，项目经历 ——————- 出乎意料"></a>开始问项目经验，项目经历 ——————- 出乎意料</h3><h3 id="项目中怎么做的，遇到最大的问题是什么？你有什么突破"><a href="#项目中怎么做的，遇到最大的问题是什么？你有什么突破" class="headerlink" title="项目中怎么做的，遇到最大的问题是什么？你有什么突破"></a>项目中怎么做的，遇到最大的问题是什么？你有什么突破</h3><h3 id="如果不把他当成hr-会怎么描述这个项目？"><a href="#如果不把他当成hr-会怎么描述这个项目？" class="headerlink" title="如果不把他当成hr, 会怎么描述这个项目？"></a>如果不把他当成hr, 会怎么描述这个项目？</h3><h3 id="这个项目在实际中是怎么使用的？"><a href="#这个项目在实际中是怎么使用的？" class="headerlink" title="这个项目在实际中是怎么使用的？"></a>这个项目在实际中是怎么使用的？</h3><h3 id="去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？"><a href="#去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？" class="headerlink" title="去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？"></a>去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？</h3><h3 id="最有成就感的事情？"><a href="#最有成就感的事情？" class="headerlink" title="最有成就感的事情？"></a>最有成就感的事情？</h3><h3 id="对自己的优缺点评价？"><a href="#对自己的优缺点评价？" class="headerlink" title="对自己的优缺点评价？"></a>对自己的优缺点评价？</h3><h3 id="转Java愿意吗？"><a href="#转Java愿意吗？" class="headerlink" title="转Java愿意吗？"></a>转Java愿意吗？</h3><h3 id="对其他编程语言的看法？"><a href="#对其他编程语言的看法？" class="headerlink" title="对其他编程语言的看法？"></a>对其他编程语言的看法？</h3><h3 id="工作地倾向？"><a href="#工作地倾向？" class="headerlink" title="工作地倾向？"></a>工作地倾向？</h3><h3 id="目前投的其他岗位是什么情况？"><a href="#目前投的其他岗位是什么情况？" class="headerlink" title="目前投的其他岗位是什么情况？"></a>目前投的其他岗位是什么情况？</h3><h3 id="你有什么问题"><a href="#你有什么问题" class="headerlink" title="你有什么问题"></a>你有什么问题</h3><h3 id="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"><a href="#我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。" class="headerlink" title="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"></a>我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。</h3><h3 id="项目过程中遇到的问题"><a href="#项目过程中遇到的问题" class="headerlink" title="项目过程中遇到的问题"></a>项目过程中遇到的问题</h3><h3 id="最近学了什么、学习方法是什么"><a href="#最近学了什么、学习方法是什么" class="headerlink" title="最近学了什么、学习方法是什么"></a>最近学了什么、学习方法是什么</h3><h3 id="对新入手的项目有没有什么学习技巧"><a href="#对新入手的项目有没有什么学习技巧" class="headerlink" title="对新入手的项目有没有什么学习技巧"></a>对新入手的项目有没有什么学习技巧</h3><h3 id="家庭情况"><a href="#家庭情况" class="headerlink" title="家庭情况"></a>家庭情况</h3><h3 id="base地的问题"><a href="#base地的问题" class="headerlink" title="base地的问题"></a>base地的问题</h3><h3 id="对加班的看法、最大能接受的加班强度"><a href="#对加班的看法、最大能接受的加班强度" class="headerlink" title="对加班的看法、最大能接受的加班强度"></a>对加班的看法、最大能接受的加班强度</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;招商银行&quot;&gt;&lt;a href=&quot;#招商银行&quot; class=&quot;headerlink&quot; title=&quot;招商银行&quot;&gt;&lt;/a&gt;招商银行&lt;/h1&gt;&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQ</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++新特性</title>
    <link href="http://example.com/p/a70da3b7.html"/>
    <id>http://example.com/p/a70da3b7.html</id>
    <published>2023-08-04T07:51:59.656Z</published>
    <updated>2023-08-05T07:03:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="C-11-中的新特性"><a href="#C-11-中的新特性" class="headerlink" title="C++11 中的新特性"></a>C++11 中的新特性</h2><p>C++11 引入了许多新特性，包括自动类型推导、lambda 表达式、右值引用等。下面介绍其中的一些重要特性。</p><h3 id="自动类型推导（Type-Inference）"><a href="#自动类型推导（Type-Inference）" class="headerlink" title="自动类型推导（Type Inference）"></a>自动类型推导（Type Inference）</h3><p>C++11 中引入了 auto 关键字，它可以用于自动推导变量的类型。例如：</p><pre><code>auto i = 10; // 推导为 intauto name = &quot;John&quot;; // 推导为 const char*自动类型推导使得代码更加简洁，并且可以避免显式指定类型的麻烦。</code></pre><p>auto只能推导类型，推导出来的类型不能用来定义对象，decltype解决了这点，推导类型后可以用来定义对象。</p><pre><code>#include&lt;cstring&gt;int main()&#123;    int i = 10;    auto p = &amp;i;    decltype(p) pi;//int*    pi = &amp;i;    cout &lt;&lt; *pi &lt;&lt; endl;//10    return 0;&#125;</code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种用于定义匿名函数的语法。它可以在需要函数对象的地方使用，并且可以捕获上下文中的变量。例如：</p><pre><code>auto sum = [](int a, int b) &#123;    return a + b;&#125;;int result = sum(5, 3); // 调用 lambda 表达式</code></pre><p>Lambda 表达式提供了一种简洁的方式来定义和使用函数对象，特别是在需要传递函数作为参数的情况下。</p><h3 id="右值引用（Rvalue-References）"><a href="#右值引用（Rvalue-References）" class="headerlink" title="右值引用（Rvalue References）"></a>右值引用（Rvalue References）</h3><p>C++11 引入了右值引用，它允许我们绑定到临时对象（右值），并且可以实现移动语义和完美转发。右值引用由双引号 &amp;&amp; 表示。</p><h4 id="什么是左值和右值："><a href="#什么是左值和右值：" class="headerlink" title="什么是左值和右值："></a>什么是左值和右值：</h4><p>• 一般来说，位于&#x3D; 前的表达式为左值；存储在内存中、有明确存储地址（可取地址）的数据；<br>• 右值是指可以提供数据值的数据（不可取地址）。</p><pre><code>int&amp;&amp; rvalue = 42; // 绑定到右值 42</code></pre><h4 id="右值引用的主要作用和意义如下："><a href="#右值引用的主要作用和意义如下：" class="headerlink" title="右值引用的主要作用和意义如下："></a>右值引用的主要作用和意义如下：</h4><p>移动语义：右值引用可以用于实现移动语义，即将一个对象的资源所有权从一个对象转移给另一个对象，而不需要进行深拷贝或浅拷贝。例如：</p><pre><code>class MyString &#123;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_) &#123;        other.data_ = nullptr;        other.size_ = 0;    &#125;private:    char* data_;    size_t size_;&#125;;MyString str1(&quot;Hello&quot;);      // 创建一个 MyString 对象MyString str2(std::move(str1));  // 将 str1 转移给 str2</code></pre><p>在上述代码中，MyString 类定义了一个移动构造函数，用于将一个右值引用转移给一个新对象。在创建 str2 对象时，使用 std::move 函数将 str1 转移给 str2，从而避免了不必要的深拷贝和内存分配操作，提高了程序的性能和效率。</p><p>完美转发：右值引用可以用于实现完美转发，即在函数调用时将参数按照原样转发给其他函数，从而避免了不必要的复制和拷贝操作。例如：</p><pre><code>template&lt;typename T&gt;void process(T&amp;&amp; arg) &#123;    other_func(std::forward&lt;T&gt;(arg));  // 将 arg 按照原样转发给 other_func&#125;</code></pre><p>在上述代码中，process 函数接受一个右值引用参数 arg，并使用 std::forward 函数将 arg 按照原样转发给 other_func 函数，从而避免了不必要的复制和拷贝操作，提高了程序的性能和效率。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><pre><code>for (decl : expr) &#123;    // 循环体&#125;</code></pre><p>decl表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中.<br>expr是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。<br>基于范围的 for 循环遍历容器，示例代码如下：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123;    vector&lt;int&gt; t&#123; 1,2,3,4,5,6 &#125;;    for (const auto&amp; value : t) &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="C-14-中的新特性"><a href="#C-14-中的新特性" class="headerlink" title="C++14 中的新特性"></a>C++14 中的新特性</h2><p>C++14 对 C++11 进行了一些改进，并引入了一些新特性，例如变长模板参数、二进制字面量等。</p><h3 id="变长模板参数（Variadic-Templates）"><a href="#变长模板参数（Variadic-Templates）" class="headerlink" title="变长模板参数（Variadic Templates）"></a>变长模板参数（Variadic Templates）</h3><p>C++14 允许定义可变数量的模板参数，这被称为变长模板参数。通过使用省略号 …，可以在模板参数列表中指定任意数量的参数。例如：</p><pre><code>template &lt;typename... Args&gt;void print(Args... args) &#123;    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);&#125;print(1, &quot;hello&quot;, 3.14); // 输出: 1 hello 3.14</code></pre><p>变长模板参数提供了更大的灵活性，可以处理不同数量和类型的参数。   </p><h3 id="二进制字面量（Binary-Literals）"><a href="#二进制字面量（Binary-Literals）" class="headerlink" title="二进制字面量（Binary Literals）"></a>二进制字面量（Binary Literals）</h3><p>C++14 允许使用二进制字面量来表示二进制数值。使用前缀 0b 或 0B，后跟一串二进制数字。例如：</p><pre><code>int binary = 0b1010; // 二进制数值 10</code></pre><p>二进制字面量提供了一种直观和简洁的方式来表示和使用二进制数值。</p><h2 id="C-17-中的新特性"><a href="#C-17-中的新特性" class="headerlink" title="C++17 中的新特性"></a>C++17 中的新特性</h2><p>C++17 引入了一些有用的新特性，包括结构化绑定、折叠表达式、文件系统库等。</p><h3 id="结构化绑定（Structured-Bindings）"><a href="#结构化绑定（Structured-Bindings）" class="headerlink" title="结构化绑定（Structured Bindings）"></a>结构化绑定（Structured Bindings）</h3><p>结构化绑定允许将元组或其他复杂类型的成员解包并绑定到独立的变量中。这样可以方便地访问和操作复杂类型的成员。例如：</p><pre><code>std::pair&lt;int, std::string&gt; person&#123; 25, &quot;John&quot; &#125;;auto [age, name] = person;std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Name: &quot; &lt;&lt; name; // 输出: Age: 25, Name: John</code></pre><p>结构化绑定简化了处理复杂类型的过程，使代码更加简洁易读。</p><h3 id="折叠表达式（Fold-Expressions）"><a href="#折叠表达式（Fold-Expressions）" class="headerlink" title="折叠表达式（Fold Expressions）"></a>折叠表达式（Fold Expressions）</h3><p>折叠表达式是一种用于处理可变数量参数包的语法。它允许在模板展开过程中对参数包进行操作。例如：</p><pre><code>template &lt;typename... Args&gt;bool allTrue(Args... args) &#123;    return (true &amp;&amp; ... &amp;&amp; args);&#125;bool result = allTrue(true, true, false); // 返回 false</code></pre><p>折叠表达式提供了一种简洁的方式来处理参数包，可以在编译时对参数进行组合和计算。</p><h3 id="文件系统库（Filesystem-Library）"><a href="#文件系统库（Filesystem-Library）" class="headerlink" title="文件系统库（Filesystem Library）"></a>文件系统库（Filesystem Library）</h3><p>C++传统文件操作需要使用std::ifstream 和 std::ofstream 类：分别表示输入文件流和输出文件流，可以用于读写文件内容。例如:</p><pre><code>#include &lt;fstream&gt;#include &lt;iostream&gt;int main() &#123;    std::ifstream input_file(&quot;input.txt&quot;);  // 打开输入文件    if (!input_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open input file.\n&quot;;        return 1;    &#125;    std::ofstream output_file(&quot;output.txt&quot;);  // 打开输出文件    if (!output_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open output file.\n&quot;;        return 1;    &#125;    int num;    while (input_file &gt;&gt; num) &#123;  // 从输入文件中读取数字        output_file &lt;&lt; num * 2 &lt;&lt; &#39;\n&#39;;  // 将每个数字乘以 2 并写入输出文件    &#125;    input_file.close();   // 关闭输入文件    output_file.close();  // 关闭输出文件    return 0;&#125;</code></pre><p>C++17 引入了标准文件系统库，用于处理文件和目录的操作。该库提供了一组类和函数，用于创建、删除、移动、遍历文件和目录等操作。例如：</p><pre><code>#include &lt;filesystem&gt;namespace fs = std::filesystem;int main() &#123;    fs::path dir_path = &quot;dir&quot;;   // 定义目录路径    fs::create_directory(dir_path);  // 创建目录    fs::path file_path = dir_path / &quot;file.txt&quot;;  // 定义文件路径    fs::ofstream file(file_path);   // 打开文件    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file.\n&quot;;        return 1;    &#125;    file &lt;&lt; &quot;Hello, world!\n&quot;;  // 写入文件内容    file.close();  // 关闭文件    fs::remove(file_path);     // 删除文件    fs::remove(dir_path);      // 删除目录    return 0;&#125;</code></pre><p>文件系统库简化了文件和目录操作的实现，使得操作更加方便和可移植。</p><h2 id="C-20-中的新特性"><a href="#C-20-中的新特性" class="headerlink" title="C++20 中的新特性"></a>C++20 中的新特性</h2><p>C++20 引入了一系列新特性，包括概念、协程、三路比较运算符等。</p><h3 id="概念（Concepts）"><a href="#概念（Concepts）" class="headerlink" title="概念（Concepts）"></a>概念（Concepts）</h3><p>概念是 C++20 中的一项重要特性，用于对模板的类型参数进行约束。概念允许我们对类型进行条件检查，从而限制模板的实例化。例如：</p><pre><code>template &lt;typename T&gt;concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;template &lt;Arithmetic T&gt;T square(T value) &#123;    return value * value;&#125;int result = square(5); // 正确，T 为算术类型std::string str = &quot;hello&quot;;// 错误，T 不是算术类型int result = square(str);</code></pre><p>概念提供了一种声明式的方式来定义模板参数的约束条件，使代码更具表达力和安全性。</p><h3 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h3><p>C++20 引入了协程支持，使得异步编程更加简洁和可读。协程允许函数在执行期间暂停和恢复，以便于异步任务的处理。例如</p><pre><code>#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Generator &#123;    struct promise_type &#123;        int current_value;        auto get_return_object() &#123;            return Generator&#123; std::coroutine_handle&lt;promise_type&gt;::from_promise(*this) &#125;;        &#125;        auto initial_suspend() &#123;            return std::suspend_always&#123;&#125;;        &#125;        auto final_suspend() noexcept &#123;            return std::suspend_always&#123;&#125;;        &#125;        void return_void() &#123;&#125;        auto yield_value(int value) &#123;            current_value = value;            return std::suspend_always&#123;&#125;;        &#125;        void unhandled_exception() &#123;            std::terminate();        &#125;    &#125;;    std::coroutine_handle&lt;promise_type&gt; coroutine;    bool move_next() &#123;        coroutine.resume();        return !coroutine.done();    &#125;    int current_value() &#123;        return coroutine.promise().current_value;    &#125;&#125;;Generator generate() &#123;    co_yield 1;    co_yield 2;    co_yield 3;&#125;int main() &#123;    Generator generator = generate();    while (generator.move_next()) &#123;        std::cout &lt;&lt; generator.current_value() &lt;&lt; &quot; &quot;;    &#125;    // 输出: 1 2 3    return 0;&#125;</code></pre><p>协程提供了一种简洁的方式来编写异步代码，提高了代码的可读性和可维护性。</p><h3 id="三路比较运算符（Three-Way-Comparison）"><a href="#三路比较运算符（Three-Way-Comparison）" class="headerlink" title="三路比较运算符（Three-Way Comparison）"></a>三路比较运算符（Three-Way Comparison）</h3><p>C++20 引入了三路比较运算符（&lt;&#x3D;&gt;），用于比较对象的大小关系。它返回一个可比较的结果，可以是小于、等于或大于。例如：</p><pre><code>struct Person &#123;    std::string name;    int age;    auto operator&lt;=&gt;(const Person&amp; other) const = default;//auto表示函数的返回类型将由编译器自动推导.在这里，返回类型将会是一个 std::strong_ordering 类型，这是 C++20 引入的一种枚举类型，用于表示强制排序关系。//= default：这个关键字表示使用默认实现，即使用编译器自动生成的代码来实现这个成员函数。在这里，编译器会自动生成一个使用 spaceship 运算符比较对象的代码。&#125;;Person john&#123;&quot;John&quot;, 25&#125;;Person alice&#123;&quot;Alice&quot;, 30&#125;;if (john &lt; alice) &#123;    std::cout &lt;&lt; &quot;John is younger than Alice.&quot;;&#125; else if (john &gt; alice) &#123;    std::cout &lt;&lt; &quot;John is older than Alice.&quot;;&#125; else &#123;    std::cout &lt;&lt; &quot;John and Alice have the same age.&quot;;&#125;</code></pre><p>三路比较运算符简化了比较操作的实现，提供了一种统一和直观的比较语法。</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-新特性&quot;&gt;&lt;a href=&quot;#C-新特性&quot; class=&quot;headerlink&quot; title=&quot;C++新特性&quot;&gt;&lt;/a&gt;C++新特性&lt;/h1&gt;&lt;h2 id=&quot;C-11-中的新特性&quot;&gt;&lt;a href=&quot;#C-11-中的新特性&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/p/2f57a694.html"/>
    <id>http://example.com/p/2f57a694.html</id>
    <published>2023-08-04T07:15:38.713Z</published>
    <updated>2023-08-04T10:00:36.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式是一种以字符串匹配为核心的强大的文本处理工具。通过一系列特殊字符和限定条件，正则表达式可以精确地描述一个文本片段的特征，从而达到将匹配的文本内容从整体文本中筛选出来的目的。它的核心功能就是在文本中查找符合指定规律的模式，这种模式可以是字符、字符组合或者字符范围，正则表达式就是定义这些规律的方式和规则。</p><h2 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h2><ul><li>字符匹配：<ul><li>普通字符：正则表达式中的普通字符表示自身，例如 a 匹配字符 “a”。</li><li>字符类：使用方括号 [ ] 来匹配一组字符中的任意一个字符，例如 [abc] 匹配字符 “a”、”b” 或 “c”。</li><li>转义字符：使用反斜杠 \ 来转义特殊字符，例如 . 匹配字符 “.”。</li></ul></li><li>重复匹配：<ul><li><em>：匹配前一个元素零次或多次，例如 a</em> 匹配零个或多个字符 “a”。</li><li>+：匹配前一个元素一次或多次，例如 a+ 匹配一个或多个字符 “a”。</li><li>?：匹配前一个元素零次或一次，例如 a? 匹配零个或一个字符 “a”。</li><li>{n}：匹配前一个元素恰好 n 次，例如 a{3} 匹配恰好三个字符 “a”。</li><li>{n,}：匹配前一个元素至少 n 次，例如 a{3,} 匹配至少三个字符 “a”。</li><li>{n,m}：匹配前一个元素至少 n 次，最多 m 次，例如 a{3,5} 匹配三到五个字符 “a”。</li></ul></li><li>特殊字符：<ul><li>.：匹配任意字符，除了换行符。</li><li>^：匹配输入字符串的开始位置。</li><li>$：匹配输入字符串的结束位置。</li><li>\b：匹配单词边界。</li><li>\d：匹配任意数字。</li><li>\w：匹配任意字母、数字或下划线。</li><li>\s：匹配任意空白字符。</li></ul></li><li>分组和捕获：<ul><li>()：用于分组，并且可以捕获分组的内容用于后续引用。</li></ul></li><li>选择符：<ul><li>|：用于在多个模式之间进行选择，例如 a|b 匹配字符 “a” 或 “b”。<br>这只是正则表达式的基本语法，还有更多高级的用法和特性。不同编程语言和工具对正则表达式的支持和语法也可能有所差异.</li></ul></li></ul><h2 id="C-和Qt-正则表达式的实现方法"><a href="#C-和Qt-正则表达式的实现方法" class="headerlink" title="C++ 和Qt 正则表达式的实现方法"></a>C++ 和Qt 正则表达式的实现方法</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>可以使用标准库中的正则表达式库 regex 来实现正则表达式的功能。以下是使用C++标准库的方法：<br>包含头文件：</p><pre><code>#include &lt;regex&gt;  </code></pre><p>创建正则表达式对象：</p><pre><code>std::regex regexObj(&quot;pattern&quot;);  //这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>std::string str = &quot;input string&quot;;  std::smatch match;  bool isMatch = std::regex_search(str, match, regexObj);  </code></pre><p>这里的 str 是你要匹配的字符串。match 是一个 std::smatch 对象,可以通过索引来访问匹配的子字符串,用于存储匹配结果。regex_search 函数用于搜索字符串中的第一个匹配项。</p><p>遍历匹配结果：</p><pre><code>for (size_t i = 0; i &lt; match.size(); ++i) &#123;      std::cout &lt;&lt; match[i] &lt;&lt; std::endl;  &#125;  </code></pre><h3 id="在Qt中"><a href="#在Qt中" class="headerlink" title="在Qt中"></a>在Qt中</h3><p>Qt提供了自己的正则表达式类 QRegularExpression 来处理正则表达式。以下是使用Qt的方法：<br>包含头文件：</p><pre><code>#include &lt;QRegularExpression&gt;  2. 创建正则表达式对象：QRegularExpression regexObj(&quot;pattern&quot;);  这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>QString str = &quot;input string&quot;;  QRegularExpressionMatch match = regexObj.match(str);  //这里的 str 是你要匹配的字符串。match 是一个 QRegularExpressionMatch 对象，用于存储匹配结果。match 对象提供了一组方法来访问匹配的子字符串。</code></pre><p>遍历匹配结果：</p><pre><code>while (match.hasMatch()) &#123;      QString matchedStr = match.captured();      // 处理匹配的子字符串      match = regexObj.match(str, match.capturedEnd());  &#125;  </code></pre><p>通过调用 captured 方法可以获取匹配的子字符串。capturedEnd 方法返回上一个匹配结束的位置，用于在字符串中继续搜索下一个匹配项。</p><h2 id="正则表达式的应用案例"><a href="#正则表达式的应用案例" class="headerlink" title="正则表达式的应用案例"></a>正则表达式的应用案例</h2><h3 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h3><p>以下是一个使用 Qt 的正则表达式实现文本匹配的示例：<br>    #include <QRegularExpression><br>    #include <QDebug>  </QDebug></QRegularExpression></p><pre><code>int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched word: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。该正则表达式会匹配由小写字母组成的单词,输出结果是整句话中的每个单词。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>以下是一个使用 Qt 的正则表达式实现字符串替换的示例：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QString replacedStr = str.replace(regex, &quot;REPLACED&quot;);      qDebug() &lt;&lt; &quot;Replaced string: &quot; &lt;&lt; replacedStr;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。然后，使用 replace 函数将匹配到的单词替换为 “REPLACED”。<br>输出结果会显示替换后的字符串：</p><pre><code>Replaced string: &quot;The REPLACED REPLACED REPLACED jumps over the REPLACED REPLACED.&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来实现字符串替换。</p><h3 id="提取字符串中的邮箱地址"><a href="#提取字符串中的邮箱地址" class="headerlink" title="提取字符串中的邮箱地址"></a>提取字符串中的邮箱地址</h3><p>下面使用 Qt 的正则表达式的实例，它演示了如何使用正则表达式来验证和提取字符串中的邮箱地址：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;My email is john.doe@example.com and another email is jane@example.com&quot;;      QRegularExpression regex(&quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched email: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>使用了一个正则表达式来匹配邮箱地址的模式。正则表达式 \b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b 匹配标准的邮箱地址格式。<br>输出结果会显示匹配到的邮箱地址：</p><pre><code>Matched email:  &quot;john.doe@example.com&quot;  Matched email:  &quot;jane@example.com&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来验证和提取字符串中的邮箱地址。</p><h2 id="正则表达式的扩展和优化"><a href="#正则表达式的扩展和优化" class="headerlink" title="正则表达式的扩展和优化"></a>正则表达式的扩展和优化</h2><h3 id="使用正则表达式的进阶技巧"><a href="#使用正则表达式的进阶技巧" class="headerlink" title="使用正则表达式的进阶技巧"></a>使用正则表达式的进阶技巧</h3><p>在Qt中，使用正则表达式进行一些进阶技巧的操作，可以增强正则表达式的功能和灵活性。以下是一些常见的Qt正则表达式的进阶技巧：</p><h4 id="捕获组（Capturing-Group）"><a href="#捕获组（Capturing-Group）" class="headerlink" title="捕获组（Capturing Group）"></a>捕获组（Capturing Group）</h4><p>使用括号将正则表达式的一部分括起来，可以将这部分内容作为一个捕获组。捕获组可以通过indexIn()函数的捕获组索引或capturedTexts()函数的捕获组名来获得匹配的子字符串。<br>QString input &#x3D; “Hello World”;<br>QRegExp regex(“Hello (\w+)”);  </p><p>if (regex.indexIn(input) !&#x3D; -1) {<br>    QString match &#x3D; regex.cap(0); &#x2F;&#x2F; 整个匹配的字符串<br>    QString capturingGroup &#x3D; regex.cap(1); &#x2F;&#x2F; 捕获组中的内容<br>}  </p><h4 id="替换（Replacement）："><a href="#替换（Replacement）：" class="headerlink" title="替换（Replacement）："></a>替换（Replacement）：</h4><p>使用QRegExp类的replace()函数可以进行替换操作，将匹配的部分替换为指定的内容。</p><pre><code>QString input = &quot;Hello, Alice!&quot;;  QRegExp regex(&quot;Alice&quot;);  QString replaced = input.replace(regex, &quot;Bob&quot;);  qDebug() &lt;&lt; &quot;Replaced: &quot; &lt;&lt; replaced; // Hello, Bob!  </code></pre><h4 id="最短匹配（Non-greedy）"><a href="#最短匹配（Non-greedy）" class="headerlink" title="最短匹配（Non-greedy）"></a>最短匹配（Non-greedy）</h4><p>使用问号（?）可以使量词变为最短匹配，即尽可能少地匹配字符。</p><pre><code>QString input = &quot;Hello &lt;b&gt;World&lt;/b&gt;!&quot;;  QRegExp regex(&quot;&lt;.*?&gt;&quot;);  int pos = regex.indexIn(input);  if (pos != -1) &#123;      QString match = regex.cap(0); // &lt;b&gt;  &#125;  </code></pre><h4 id="全局匹配（Global-Match）："><a href="#全局匹配（Global-Match）：" class="headerlink" title="全局匹配（Global Match）："></a>全局匹配（Global Match）：</h4><p>使用globalMatch()函数可以进行全局匹配，找到输入字符串中的所有匹配项。</p><pre><code>QString input = &quot;Hello, Alice! How are you, Alice?&quot;;  QRegExp regex(&quot;Alice&quot;);  QRegExpIterator iter(input, regex);  while (iter.hasNext()) &#123;      iter.next();      QString match = iter.value(); // Alice  &#125;  </code></pre><p>这些是一些Qt中正则表达式的进阶技巧，可以根据具体需求进行使用。</p><h3 id="利用正则表达式的编译器和解释器"><a href="#利用正则表达式的编译器和解释器" class="headerlink" title="利用正则表达式的编译器和解释器"></a>利用正则表达式的编译器和解释器</h3><p>在Qt中，有两个主要的正则表达式引擎：QRegExp和QRegularExpression。</p><h4 id="QRegExp"><a href="#QRegExp" class="headerlink" title="QRegExp"></a>QRegExp</h4><p>QRegExp是Qt早期版本中使用的正则表达式引擎。它基于C++标准库中的正则表达式功能，并在其基础上添加了一些Qt特定的扩展。QRegExp是一个解释器，它在运行时解释和匹配正则表达式。尽管QRegExp功能强大，但它不是完全兼容于Perl正则表达式语法，并且在处理大型文本时可能存在性能问题。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegExp regex(&quot;Hello (\\w+)&quot;);  if (regex.indexIn(input) != -1) &#123;      QString match = regex.cap(0); // 整个匹配的字符串      QString capturingGroup = regex.cap(1); // 捕获组中的内容  &#125;  </code></pre><h4 id="QRegularExpression"><a href="#QRegularExpression" class="headerlink" title="QRegularExpression"></a>QRegularExpression</h4><p>从Qt 5开始，引入了QRegularExpression作为新的正则表达式引擎。QRegularExpression是一个编译器，它在使用正则表达式之前将其编译成一个内部表示形式，这样可以提高效率。它也支持Perl正则表达式语法的大部分功能，并且在性能方面更优于QRegExp。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegularExpression regex(&quot;Hello (\\w+)&quot;);  QRegularExpressionMatch match = regex.match(input);  if (match.hasMatch()) &#123;      QString captured = match.captured(0); // 整个匹配的字符串      QString capturingGroup = match.captured(1); // 捕获组中的内容  &#125;  </code></pre><p>无论是QRegExp还是QRegularExpression，都可以用于正则表达式的匹配、搜索和替换等操作，但在新的代码中推荐使用QRegularExpression，以获得更好的性能和更强大的功能。</p><h4 id="正则表达式的插件和辅助工具"><a href="#正则表达式的插件和辅助工具" class="headerlink" title="正则表达式的插件和辅助工具"></a>正则表达式的插件和辅助工具</h4><p>有一些独立的正则表达式插件和辅助工具可用于不同的开发环境和编辑器。以下是一些常见的正则表达式插件和辅助工具：</p><ol><li>RegexBuddy：这是一个强大的独立工具，用于创建、调试和测试正则表达式。它提供了一个直观的界面，可以可视化地构建和编辑正则表达式，并提供实时的匹配结果和错误提示。</li><li>RegExpert：这是一个在线的正则表达式调试器和测试工具，可以帮助您验证和调试正则表达式。它提供了一个交互式界面，可以实时检查输入文本的匹配结果，并显示匹配的子字符串和捕获组。</li><li>regex101：这是一个在线的正则表达式测试和学习平台，提供了一个交互式界面，可以输入正则表达式和测试文本，并实时显示匹配结果、捕获组和匹配的解释。</li><li>RegExr：这是一个基于Web的正则表达式工具，提供了一个交互式界面，可以可视化地构建和测试正则表达式。它还提供了实时的匹配结果和错误提示，以及一个正则表达式库和示例。<br>这些正则表达式插件和辅助工具可以帮助您更方便地创建、调试和测试正则表达式，提高开发效率和准确性。</li></ol><h2 id="正则表达式的陷阱和注意事项"><a href="#正则表达式的陷阱和注意事项" class="headerlink" title="正则表达式的陷阱和注意事项"></a>正则表达式的陷阱和注意事项</h2><p>在使用正则表达式时，有一些常见的陷阱和注意事项需要注意。以下是一些常见的陷阱和注意事项：</p><ul><li>贪婪匹配：默认情况下，正则表达式是贪婪匹配的，即它会尽可能多地匹配字符。如果您想要最短匹配，可以使用非贪婪量词（如*?，+?，??）或限定符的最小化形式。</li><li>转义字符：在正则表达式中，某些字符具有特殊含义，如点号（.）、星号（<em>）、加号（+）、问号（?）等。如果需要匹配这些特殊字符本身，需要使用反斜杠进行转义（如.、</em>、+、?）。</li><li>转义序列：正则表达式中有一些特殊的转义序列，如\d表示任意一个数字字符，\w表示任意一个字母、数字或下划线字符。这些转义序列可以用于简化正则表达式的编写。</li><li>字符边界：在正则表达式中，\b表示单词边界，即单词字符和非单词字符之间的位置。但请注意，\b在C++字符串中也是转义字符，所以需要使用双反斜杠（\b）来匹配单词边界。</li><li>捕获组编号：在一些正则表达式引擎中，捕获组的编号是从1开始的，而不是从0开始。因此，在访问捕获组时需要注意编号的对应关系。</li><li>性能问题：某些复杂的正则表达式可能会导致性能问题，特别是在处理大型文本时。尽量避免使用过于复杂的正则表达式，可以考虑将其拆分为多个简单的正则表达式。</li><li>Unicode支持：如果需要处理Unicode字符，确保使用支持Unicode的正则表达式引擎，并使用相应的Unicode转义序列和属性。</li><li>测试和验证：在编写正则表达式之前，建议使用测试工具或在线正则表达式测试平台来验证和调试您的正则表达式，以确保其正确性和预期的匹配结果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>database/sql</title>
    <link href="http://example.com/p/cacc0385.html"/>
    <id>http://example.com/p/cacc0385.html</id>
    <published>2023-08-03T01:17:25.682Z</published>
    <updated>2023-08-03T03:37:59.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-database-x2F-sql-在-Go-中进行数据库操作的简介"><a href="#使用-database-x2F-sql-在-Go-中进行数据库操作的简介" class="headerlink" title="使用 database&#x2F;sql 在 Go 中进行数据库操作的简介"></a>使用 database&#x2F;sql 在 Go 中进行数据库操作的简介</h1><p>公司需要用到database&#x2F;sql，在 Go 中使用 SQL 或类似 SQL 的数据库的惯用方法是通过 database&#x2F;sql 包。它为面向行的数据库提供了一个轻量级接口。看完以后觉得和JDBC差不多。英语无障碍可以参照<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sql.DB</code> 并不是直接的数据库连接，它是数据库的抽象接口，它也不映射到任何特定数据库软件的“数据库”或“模式”概念。数据库可能像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。。它负责打开和关闭数据库连接，并管理连接池。正在使用的连接会被标记为繁忙，用完后会返回连接池等待下次使用。如果没有将连接释放回连接池，可能导致过多连接，从而耗尽系统资源。sql.DB不是数据库连接。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>要连接数据库，我们首先需要导入相应的驱动，具体取决于我们使用的数据库。例如，我们考虑使用 MySQL：</p><pre><code class="go">import (    &quot;database/sql&quot;    _ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123;    db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)    if err != nil &#123;        log.Fatal(err)    &#125;    defer db.Close()&#125;</code></pre><p><code>sql.Open()</code> 函数的第一个参数是驱动名称，第二个参数是连接数据库的信息。我们可以立即使用 <code>Ping()</code> 方法验证连接。</p><pre><code class="go">err = db.Ping()if err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>需要注意的是，<code>sql.DB</code> 被设计为长连接。频繁地进行 <code>Open()</code> 和 <code>Close()</code> 操作是不推荐的。最佳实践是为每个不同的数据存储创建一个 <code>DB</code> 对象，并保持这些对象的打开状态。如果需要短连接，请将 <code>DB</code> 对象作为参数传递给函数，而不是在函数中打开和关闭连接。</p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>如果方法涉及查询并返回多行结果，我们可以使用 <code>Query()</code>。对于其他操作，例如 INSERT、UPDATE 和 DELETE，我们使用 <code>Exec()</code>。</p><pre><code class="go">var (    id   int    name string)rows, err := db.Query(&quot;SELECT id, name FROM users WHERE id = ?&quot;, 1)if err != nil &#123;    log.Fatal(err)&#125;defer rows.Close()for rows.Next() &#123;    err := rows.Scan(&amp;id, &amp;name)    if err != nil &#123;        log.Fatal(err)    &#125;    log.Println(id, name)&#125;err = rows.Err()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><p>在迭代行时务必检查错误，并使用 <code>rows.Close()</code> 关闭结果集以释放底层连接。</p><p>对于单行查询，我们可以使用 <code>QueryRow()</code>：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    log.Fatal(err)&#125;fmt.Println(name)</code></pre><h2 id="修改数据和事务"><a href="#修改数据和事务" class="headerlink" title="修改数据和事务"></a>修改数据和事务</h2><p>对于 INSERT、UPDATE 和 DELETE 操作，我们使用预编译语句和 <code>Exec()</code>：<br>预处理执行过程：</p><ul><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ul><p>为什么要预处理？</p><ul><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ul><pre><code class="go">stmt, err := db.Prepare(&quot;INSERT INTO users (name) VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;res, err := stmt.Exec(&quot;Dolly&quot;)if err != nil &#123;    log.Fatal(err)&#125;lastId, err := res.LastInsertId()if err != nil &#123;    log.Fatal(err)&#125;rowCnt, err := res.RowsAffected()if err != nil &#123;    log.Fatal(err)&#125;log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)</code></pre><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。<br>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><p>要执行事务，我们使用 <code>Begin()</code>、<code>Commit()</code> 和 <code>Rollback()</code>：</p><pre><code class="go">tx, err := db.Begin()if err != nil &#123;    log.Fatal(err)&#125;defer tx.Rollback()stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;defer stmt.Close()for i := 0; i &lt; 10; i++ &#123;    _, err = stmt.Exec(i)    if err != nil &#123;        log.Fatal(err)    &#125;&#125;err = tx.Commit()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在与数据库交互时，适当处理错误非常重要。例如，在迭代 <code>Rows</code> 时检查错误并关闭结果集：</p><pre><code class="go">for rows.Next() &#123;    // ...&#125;if err = rows.Err(); err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>如果在迭代所有行之前退出循环，必须手动关闭结果集并处理错误：</p><pre><code class="go">for rows.Next() &#123;    // ...    break&#125;if err = rows.Close(); err != nil &#123;    log.Println(err)&#125;</code></pre><p>对于单行查询，需要单独处理 <code>ErrNoRows</code> 错误：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    if err == sql.ErrNoRows &#123;        // 处理没有找到行的情况    &#125; else &#123;        log.Fatal(err)    &#125;&#125;fmt.Println(name)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot;&gt;&lt;a href=&quot;#使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot; class=&quot;headerlink&quot; title=&quot;使用 database&amp;#x2F;sql</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>七层协议</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-31T14:30:47.327Z</published>
    <updated>2023-07-31T14:41:15.404Z</updated>
    
    <content type="html"><![CDATA[<p>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线<br>数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）<br>传输层：TCP（T&#x2F;TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS&#x2F;SSL<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP&#x2F;2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP</p><h2 id="TCP和UDP的-区别"><a href="#TCP和UDP的-区别" class="headerlink" title="TCP和UDP的 区别"></a>TCP和UDP的 区别</h2><p>TCP是面向有连接型，UDP是面向无连接型；<br>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；<br>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；<br>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线&lt;br&gt;数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）&lt;br&gt;网络层：IP、ICMP、AR</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://example.com/p/36b011d7.html"/>
    <id>http://example.com/p/36b011d7.html</id>
    <published>2023-07-27T14:53:47.358Z</published>
    <updated>2023-07-31T14:52:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP：80端口<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><p>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议的主要特点可概括如下：<br>1、支持客户&#x2F;服务器模式。支持基本认证和安全认证。<br>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。<br>5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。<br>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p><p>一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。一般http中存在如下问题：</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h4 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h4><p>减少重定向请求次数；<br>合并请求；<br>延迟发送请求；</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。<br>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。<br>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递<br>如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了，直接通过代理服务器重新请求，而不是客户端重新请求，更进一步，如果代理服务器缓存了重定向网站可以直接向服务端发送请求。</p><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP&#x2F;1.1 管道模式是默认不使用的，所以讨论 HTTP&#x2F;1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。<br>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。</p><p>按需获取的方式，来减少第一时间的 HTTP 请求次数。请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><p>头部压缩<br>二进制格式<br>并发传输<br>服务器主动推送资源</p><h4 id="头部压缩（Header-Compression）"><a href="#头部压缩（Header-Compression）" class="headerlink" title="头部压缩（Header Compression）"></a>头部压缩（Header Compression）</h4><p>http1.x的头带有大量信息，而且每次都要重复发送。http&#x2F;2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p><p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><p>需要注意的是，http 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p><p>http&#x2F;2使用的是专门为首部压缩而设计的HPACK②算法。<br>用header字段表里的索引代替实际的header。</p><p>http&#x2F;2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>http2.0之所以能够突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p><p>在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><h4 id="多路复用-Multiplexing-x2F-连接共享"><a href="#多路复用-Multiplexing-x2F-连接共享" class="headerlink" title="多路复用 (Multiplexing) &#x2F; 连接共享"></a>多路复用 (Multiplexing) &#x2F; 连接共享</h4><p>在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，http&#x2F;2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><h4 id="服务端推送（Server-Push）"><a href="#服务端推送（Server-Push）" class="headerlink" title="服务端推送（Server Push）"></a>服务端推送（Server Push）</h4><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。<br>服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h4 id="http2-0性能瓶颈"><a href="#http2-0性能瓶颈" class="headerlink" title="http2.0性能瓶颈"></a>http2.0性能瓶颈</h4><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。、</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</p><ul><li>HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；</li><li>HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；</li><li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li></ul><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h4 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h4><p>TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>TCP实现高并发有3个弊端：</p><ul><li>实现成本高。TCP是由操作系统内核实现的，如果通过多线程实现并发，并发线程数不能太多，否则线程间切换成本会以指数级上升；如果通过异步、非阻塞socket实现并发，开发效率又太低；</li><li>每个TCP连接与TLS会话都叠加了2-3个RTT的建链成本；</li><li>TCP连接有一个防止出现拥塞的慢启动流程，它会对每个TCP连接都产生减速效果。</li></ul><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="https://s1.ax1x.com/2023/07/30/pPpTX1P.png" alt="小林code"></p><h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。https端口：443</p><p>前面我们知道一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被<strong>窃听截取</strong>。</li><li>数据的完整性未校验，容易被<strong>篡改</strong></li><li>没有验证对方身份，存在<strong>冒充</strong>危险</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了HTTP的风险：</p><ul><li>数据保密性：保证数据内容在传输的过程中不会被第三方查看,交互信息无法被窃取。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</li><li>数据完整性：及时发现被第三方篡改的传输内容,无法篡改通信内容，篡改了就不能正常显示。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</li><li>身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</li></ul><p>对应采取了以下三种做法：</p><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了<strong>窃听</strong>的风险。</li><li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了<strong>冒充</strong>的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。<br>采用「混合加密」的方式的原因：</li><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个哈希值，然后同内容一起传输给对方。<br>对方收到后，先是对内容也计算出一个哈希值，然后跟发送方发送的哈希值做一个比较，如果哈希值相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证秘钥本身就是货真价实的公开密钥；</p><p>那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：</p><p>一个是公钥，这个是可以公开给所有人的；<br>一个是私钥，这个必须由本人管理，不可泄露。<br>这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。<br>流程的不同，意味着目的也不相同：</p><p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<br>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。<br>所以非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。<br>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>前面我们知道：<br>可以通过哈希算法来保证消息的完整性；<br>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？我伪造一个网站然后发给你公钥，按照前面流程我是知道私钥的，因为公钥是我伪造的，前面流程只能验证公钥和私钥匹配的，并不能解决身份冒充的问题。为了解决这个问题，可以使用由数字证书认证机构（CA）和其他相关机构颁发的公开秘钥证书。<br>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程：</li><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><ul><li>服务器拥有自己的私钥与公钥。</li><li>服务器将公钥交给CA认证机构，请求给予一份数字证书。</li><li>CA认证机构生成数字证书，并颁发给服务器。</li><li>服务器将带有公钥信息的数字证书发给客户端。</li><li>进入客户端生成对称密钥再进行对接的过程。</li></ul><h3 id="HTTPS的通信步骤"><a href="#HTTPS的通信步骤" class="headerlink" title="HTTPS的通信步骤"></a>HTTPS的通信步骤</h3><p>SSL&#x2F;TLS 协议基本流程：</p><p>客户端向服务器索要并验证服务器的公钥。<br>双方协商生产「会话秘钥」。<br>双方采用「会话秘钥」进行加密通信。<br>TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法</p><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ul><li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ul><p>客户端回应，客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li><p>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p></li><li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li><li><p>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="https://s1.ax1x.com/2023/07/30/pPp6EZV.png" alt="pPp6EZV.png"></p></li></ul><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改、确保数据的完整性。<br>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但他大幅度增加了中间人攻击的成本。</p><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>慢，HTTPS未经任何优化的情况下要比HTTP慢几百毫秒以上，特别在移动端可能要慢500毫秒以上，关于HTTPS慢和如何优化已经是一个非常系统和复杂的话题。<br>贵，特别在计算性能和服务器成本方面。HTTPS要额外计算，要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。<br>大量的计算.SSL的每一个字节都涉及到较为复杂的计算。即使是clientHello，也需要在握手完成时做校验。<br>TLS协议的封装和解析。HTTPS所有数据都是按照TLS record格式进行封装和解析的。<br>协议的网络交互。从TLS的握手过程可以看出，即使不需要进行任何计算，TLS的握手也需要至少1个RTT（round trip time)以上的网络交互。RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。<br>HTTPS降低用户访问速度（需多次握手）。<br>网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）。<br>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https 访问过程需要加解密）。</p><h3 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h3><p>1）HSTS重定向技术：将http自动转换为https，减少301重定向。<br>2）TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据。直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT<br>3）会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了。<br>4）OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询。<br>5）完全前向加密PFS：使用更牛逼复杂的秘钥算法。</p><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><ol><li>DHCP 请求报文，目的端口67源端口68的UTP报文，广播地址255.255.255.255，源地址0.0.0.0</li><li>DHCP的IP数据报被放置在以太网帧当中以太网帧具有FF:FF:FF:FF:FF:FF进行广播。</li><li>当DHCP服务器收到后，通过CIDR分配IP</li><li>DNS 域名解析发送UDP报文段获取域名IP</li><li>不知道网关路由器mac地址，ARP广播报文查询</li><li>获取mac地址后发送DNS解析帧通过RIP，OSPF，或者IS-IS或者域间协议BGP将报文请求，获取ip</li><li>获取ip后tcp三次握手</li><li>http协议</li></ol><p>在浏览器输入网址后，首先要经过<strong>域名解析</strong>。通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p>为了查找DNS记录，浏览器会检查四个缓存。<br>第一，检查浏览器缓存。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。<br>第二，浏览器检查操作系统缓存。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。<br>第三，检查路由器缓存。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。<br>第四，检查ISP缓存。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。<br>如果请求的URL不在缓存中，ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）<br>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈，生成HTTP 请求信息，<strong>封装成一个 HTTP 数据包。</strong><br>HTTP 底层是依赖 TCP&#x2F;IP 协议实现的，所以在底层数据传输时，会将 HTTP 请求包进一步<strong>封装成 TCP 数据包。</strong><br>打开⼀个socket与⽬标IP地址，端⼝<strong>建⽴TCP链接</strong>，三次握⼿如下：</p><ul><li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端口</li><li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li><li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z<br>TCP链接建⽴后浏览器<strong>向 web 服务器发送一个 HTTP 请求</strong><br>服务器端拿到了客户端的请求参数之后，会进行相应的业务处理，处理完成之后，再将处理的结果返回给客户端。返回的流程和发送的流程类似，先将结果封装成 HTTP 数据包</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https&quot;&gt;&lt;a href=&quot;#http和https&quot; class=&quot;headerlink&quot; title=&quot;http和https&quot;&gt;&lt;/a&gt;http和https&lt;/h1&gt;&lt;h2 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>new/delete  malloc/free</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-26T14:33:36.535Z</published>
    <updated>2023-08-05T06:29:47.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-x2F-delete-malloc-x2F-free"><a href="#new-x2F-delete-malloc-x2F-free" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free"></a>new&#x2F;delete  malloc&#x2F;free</h1><h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><p>new操作针对数据类型的处理，分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要构造函数的类型）"><a href="#简单数据类型（-包括基本数据类型和不需要构造函数的类型）" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要构造函数的类型）"></a>简单数据类型（ 包括基本数据类型和不需要构造函数的类型）</h3><p>代码实例：</p><pre><code>int* p = new int;</code></pre><p>汇编码如下：</p><pre><code>int* p = new int;    00E54C44  push        4      00E54C46  call        operator new (0E51384h)      00E54C4B  add         esp,4  </code></pre><p>分析：传入4byte的参数后调用operator new。其源码如下：</p><pre><code>void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123;           // try to allocate size bytes    void *p;    while ((p = malloc(size)) == 0)    &#123;        if (_callnewh(size) == 0)        &#123;       // report no memory                _THROW_NCEE(_XSTD bad_alloc, );        &#125;    &#125;    return (p);&#125;</code></pre><p>分析：调用malloc失败后会调用_callnewh。如果_callnewh返回0则抛出bac_alloc异常，返回非零则继续分配内存。<br>这个_callnewh是什么呢？它是一个new handler，通俗来讲就是new失败的时候调用的回调函数。可以通过_set_new_handler来设置。下面举个实例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;new.h&gt;int MyNewHandler(size_t size)&#123;    printf(&quot;Allocation failed.Try again&quot;);    return 1;//continue to allocate    //return 0;//stop allocating,throw bad_alloc&#125;void main()&#123;    // Set the failure handler for new to be MyNewHandler.    _set_new_handler(MyNewHandler);    while (1)    &#123;        int* p = new int[10000000];    &#125;&#125;</code></pre><p>在new基本数据类型的时候还可以指定初始化值，比如：</p><pre><code>int* p = new int(4);</code></pre><p>简单类型直接调用operator new分配内存；<br>可以通过new_handler来处理new失败的情况；<br>new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；</p><p>new[] 调用的是operator new[]，计算出数组总大小之后调用operator new。</p><h3 id="复杂数据类型（需要由构造函数初始化对象）"><a href="#复杂数据类型（需要由构造函数初始化对象）" class="headerlink" title="复杂数据类型（需要由构造函数初始化对象）"></a>复杂数据类型（需要由构造函数初始化对象）</h3><p>例如：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object();&#125;</code></pre><p>汇编码如下：</p><pre><code>Object* p = new Object();    00AD7EDD  push        4      00AD7EDF  call        operator new (0AD1384h)      00AD7EE4  add         esp,4      00AD7EE7  mov         dword ptr [ebp-0E0h],eax      00AD7EED  mov         dword ptr [ebp-4],0      00AD7EF4  cmp         dword ptr [ebp-0E0h],0      00AD7EFB  je          main+70h (0AD7F10h)      00AD7EFD  mov         ecx,dword ptr [ebp-0E0h]      00AD7F03  call        Object::Object (0AD1433h)        //在new的地址上调用构造函数    00AD7F08  mov         dword ptr [ebp-0F4h],eax      00AD7F0E  jmp         main+7Ah (0AD7F1Ah)      00AD7F10  mov         dword ptr [ebp-0F4h],0      00AD7F1A  mov         eax,dword ptr [ebp-0F4h]      00AD7F20  mov         dword ptr [ebp-0ECh],eax      00AD7F26  mov         dword ptr [ebp-4],0FFFFFFFFh      00AD7F2D  mov         ecx,dword ptr [ebp-0ECh]      00AD7F33  mov         dword ptr [p],ecx  </code></pre><p>new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。</p><p>针对复杂类型，new[]会额外存储数组大小。</p><h2 id="delete的实现"><a href="#delete的实现" class="headerlink" title="delete的实现"></a>delete的实现</h2><p>delete也分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要析构函数的类型）。"><a href="#简单数据类型（-包括基本数据类型和不需要析构函数的类型）。" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。"></a>简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。</h3><pre><code>int *p = new int(1);delete p;</code></pre><p>delete的汇编码如下：</p><pre><code>    delete p;00275314  mov         eax,dword ptr [p]  00275317  mov         dword ptr [ebp-0D4h],eax  0027531D  mov         ecx,dword ptr [ebp-0D4h]  00275323  push        ecx  00275324  call        operator delete (0271127h) </code></pre><p>分析：传入参数p之后调用operator delete，其源码如下：</p><pre><code>void operator delete( void * p )&#123;    RTCCALLBACK(_RTC_Free_hook, (p, 0));    free( p );&#125;</code></pre><p>RTCCALLBACK默认是空的宏定义，所以这个函数默认情况下就是简单的调用free函数。<br>delete简单数据类型默认只是调用free函数。</p><p>针对简单类型，delete和delete[]等同。</p><h3 id="复杂数据类型（需要由析构函数销毁对象）"><a href="#复杂数据类型（需要由析构函数销毁对象）" class="headerlink" title="复杂数据类型（需要由析构函数销毁对象）"></a>复杂数据类型（需要由析构函数销毁对象）</h3><p>代码实例：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;        cout &lt;&lt; &quot;destroy object&quot; &lt;&lt; endl;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object;    delete p;&#125;</code></pre><p>部分汇编码如下：</p><pre><code>012241F0  mov         dword ptr [this],ecx  012241F3  mov         ecx,dword ptr [this]  012241F6  call        Object::~Object (0122111Dh)     //先调用析构函数012241FB  mov         eax,dword ptr [ebp+8]  012241FE  and         eax,1  01224201  je          Object::`scalar deleting destructor&#39;+3Fh (0122420Fh)  01224203  mov         eax,dword ptr [this]  01224206  push        eax  01224207  call        operator delete (01221145h)  0122420C  add         esp,4 </code></pre><p>delete复杂数据类型先调用析构函数再调用operator delete。</p><p>释放内存之前会先调用每个对象的析构函数。<br>new[]分配的内存只能由delete[]释放。如果由delete释放会崩溃，为什么会崩溃呢？<br>假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。<br>总结：<br>针对复杂类型，new[]出来的内存只能由delete[]释放。</p><h2 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h2><p>1）plain new（默认new） 2）nothrow new（不抛异常的new） 3）placement new（放置new）</p><h3 id="plain-new-和-nothrow-new"><a href="#plain-new-和-nothrow-new" class="headerlink" title="plain new 和 nothrow new"></a>plain new 和 nothrow new</h3><p>默认的new和nothrow new用法上差不多，只不过是返回值上面的区别</p><p>默认的new在分配失败的时候会抛出异常，而非返回NULL<br>但是nothrow new在分配失败的时候会返回NULL，而不是异常</p><p>下面这个例子，我们一开始先用默认的new，不断要求分配一个内存空间，为了节省时间，可以要求分配的内存空间很大，比较容易达到“无法再分配的状态”。</p><p>当无法再继续分配的时候，new就会抛出异常“std::bad_alloc”</p><p>nothrow new，这时候已经是“无法再分配”，所以直接就会使得nothrow new失败，但是nothrow new返回的是NULL，我们可以验证一下</p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;int main()&#123;    try &#123;        while (true) &#123;            new int[100000000ul];   // throwing overload        &#125;    &#125; catch (const std::bad_alloc&amp; e) &#123;        std::cout &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;    &#125;    while (true) &#123;        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload        if (p == nullptr) &#123;            std::cout &lt;&lt; &quot;Allocation returned nullptr\n&quot;;            break;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>std::bad_allocAllocation returned nullptr</code></pre><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>该运算符用于在已分配的内存上重新构造对象,因为不分配内存，所以也不用担心分配失败<br>我们可以验证一下，我们先分配一块内存并存储数据，然后我们再在这同一块内存中申请一个相同的对象（其他对象也可以，不过要比原先申请的空间小），给新对象赋一个不同的数据，查看最后内存的数据是什么</p><pre><code>// C++ program to illustrate the placement new operator#include&lt;iostream&gt;using namespace std;int main()&#123;    // initial value of X    int X = 10;    cout &lt;&lt; &quot;Before placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    // Placement new changes the value of X to 100    int *mem = new (&amp;X) int(100);    cout &lt;&lt; &quot;\nAfter placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;mem : &quot; &lt;&lt; mem &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code>Before placement new :X : 10&amp;X : 0x7fff71ce8bfcAfter placement new :X : 100 mem : 0x7fff71ce8bfc&amp;X : 0x7fff71ce8bfc</code></pre><p>解释一下，就是一开始内存地址为”0x7fff71ce8bfc”,数据为“10”</p><p>然后进行了palcement new以后，new的内存空间还是原来的内存空间，数据变成了“100”</p><h2 id="new-x2F-delete-和-malloc-x2F-free的区别"><a href="#new-x2F-delete-和-malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free的区别"></a>new&#x2F;delete 和 malloc&#x2F;free的区别</h2><h3 id="引入上"><a href="#引入上" class="headerlink" title="引入上"></a>引入上</h3><p>new&#x2F;delete：这两个是C++中的关键字，若要使用，需要编译器支持；<br>malloc&#x2F;free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。</p><h3 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h3><p>malloc：申请空间需要显式填入申请内存的大小；<br>new：无需显式填入申请的内存大小，new会根据new的类型分配内存。</p><h3 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h3><p>new：申请的内存空间在自由存储区</p><p>malloc：申请的内存空间在堆</p><p>自由存储区：默认是堆，也可以通过自己实现，使得为进程中的其他区域</p><h3 id="是否可以重载"><a href="#是否可以重载" class="headerlink" title="是否可以重载"></a>是否可以重载</h3><p>在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等<br>而malloc和free是C里的库函数，无法对其进行重载。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br>malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。</p><p>malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；<br>new内存分配失败时，会抛出bac_alloc异常，</p><h3 id="对数组的处理"><a href="#对数组的处理" class="headerlink" title="对数组的处理"></a>对数组的处理</h3><p>使用new操作符来分配对象内存时会调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。运行相应的构造函数以构造对象，并为其传入初值，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会调用对象的析构函数，调用operator delete(或operator delete[])函数释放内存空间。</p><p>malloc：和非数组数据的内存分配没有区别<br>free：和非数组数据的的内存释放没有区别</p><p>free怎么知道要释放多大的内存空间？<br>malloc分配空间时，可以理解成整个内存空间分成两块<br>一块在首地址，记录内存的大小的。一块就是你指定大小的内存空间</p><h3 id="是否可以扩展内存空间"><a href="#是否可以扩展内存空间" class="headerlink" title="是否可以扩展内存空间"></a>是否可以扩展内存空间</h3><p>new：不行<br>malloc：可以</p><p>使用malloc分配的空间可以使用realloc函数对其进行内存的扩展</p><p>realloc先判断当前指针指向的内存空间是否有足够的连续空间支持扩展，如果有，直接原地扩展，并且返回原来地址的指针；如果没有，按照新指定的内存空间大小，开辟一块新的内存空间，然后把旧内存空间的数据复制过去，然后释放旧内存空间，返回新内存空间的指针</p><h2 id="既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？"><a href="#既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？" class="headerlink" title="既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h2><p>malloc&#x2F;free适用于： 简单的数据类型（int，char等），这些数据在定义的时候没有构造函数和析构函数，就无须使用new&#x2F;delete，只用简单分配空间和释放空间即可</p><p>new&#x2F;delete适用于： 自定义的类，这些数据在定义的时候往往需要调用构造函数初始化，释放的时候需要调用析构函数。这时简单的内存分配和内存释放无法满足需求，所以这时就需要new和delete</p><h2 id="Malloc函数的线程安全"><a href="#Malloc函数的线程安全" class="headerlink" title="Malloc函数的线程安全"></a>Malloc函数的线程安全</h2><p>malloc函数线程安全但是不可重入的，因为malloc函数在用户空间要自己管理各进程共享的内存链表，由于有共享资源访问，本身会造成线程不安全。为了做到线程安全，需要加锁进行保护。同时这个锁必须是递归锁，因为如果当程序调用malloc函数时收到信号，在信号处理函数里再调用malloc函数，如果使用一般的锁就会造成死锁（信号处理函数中断了原程序的执行），所以要使用递归锁。<br>一个函数要做到可重入，需要不在函数内部使用静态或全局数据，不返回静态或全局数据，也不调用不可重入函数。</p><h2 id="被free回收的内存怎么处理？"><a href="#被free回收的内存怎么处理？" class="headerlink" title="被free回收的内存怎么处理？"></a>被free回收的内存怎么处理？</h2><p>会被统一管理起来，而不是归还给操作系统</p><p>这些内存空间会被一条双链表连接起来，这样下一次需要分配内存空间的时候，就可以先在这里面找是否合适的内存，合适就直接使用；如果所需内存比这里的内存空间都要大，那么再去重新向系统申请一块内存空间</p><p>这样统一管理，不立即归还给操作系统的好处是避免每次free都要进行系统调用；而且避免返回给操作系统很多小的碎片，难以管理；</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载operator new<br>因为new是关键字，我们本应该无法修改new分配内存的方式。由于new在分配内存时，调用operator new。所以重载operator new就可以修改分配内存的方式了。</p><pre><code>class Foo &#123;public:    Foo() &#123; std::cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; std::endl; &#125;    virtual ~Foo() &#123; std::cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; std::endl; &#125;    void* operator new(std::size_t size)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new(std::size_t size, int num)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new (std::size_t size, void* p)    &#123;        std::cout &lt;&lt; &quot;placement new&quot; &lt;&lt; std::endl;        return p;    &#125;    void operator delete(void* ptr)    &#123;        std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Foo* m = new(100) Foo;    Foo* m2 = new(m) Foo;    std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;    //delete m2;    delete m;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;new-x2F-delete-malloc-x2F-free&quot;&gt;&lt;a href=&quot;#new-x2F-delete-malloc-x2F-free&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete  malloc&amp;#x2F;fre</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-25T13:57:23.617Z</published>
    <updated>2023-08-06T13:40:42.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>局部static是线程安全的，可以用来实现单例模式</p><h2 id="面向过程设计中的static"><a href="#面向过程设计中的static" class="headerlink" title="面向过程设计中的static"></a>面向过程设计中的static</h2><p>全局变量、静态变量和类的静态成员变量在main执行之前初始化；局部静态变量在第一次使用时初始化。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。                         </p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的，不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，该变量的值不会因为函数终止而丢失，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><p>修饰函数时，表明该函数只在同一文件中调用。</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突；</li></ul><h2 id="面向对象的static关键字"><a href="#面向对象的static关键字" class="headerlink" title="面向对象的static关键字"></a>面向对象的static关键字</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>用static修饰不访问非静态数据成员的类成员函数。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。</p><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p><strong>在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗。</strong></p><p>答：可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响。</p><p><strong>为什么静态成员函数不能申明为const</strong></p><p>答：这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。<span style="line-height:26px">一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了</span></p><p><strong>为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义</strong><br>答：因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p><strong>static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中。</strong><br>如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。</p><p><strong>为什么常量静态成员数据的初始化可以放在类内（注意：只有静态常量整型数据成员才可以在类中初始化）</strong></p><p>答：是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’&#x3D;’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p><p><strong>为什么静态成员函数只能访问静态成员变量。</strong></p><p>1.静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的<br>2.非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问<br>3.访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</p><p><strong>静态成员函数与非静态成员函数的区别</strong><br>根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。</p><p><strong>为什么要用静态成员变量和静态成员函数</strong><br>为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享</p><p><strong>静态成员的作用、优点</strong><br>静态成员函数主要为了调用方便，不需要生成对象就能调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;p&gt;局部static是线程安全的，可以用来实现单例模式&lt;/p&gt;
&lt;h2 id=&quot;面向过程设计中的static&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>字节提前批</title>
    <link href="http://example.com/p/7d1900d6.html"/>
    <id>http://example.com/p/7d1900d6.html</id>
    <published>2023-07-24T13:41:49.500Z</published>
    <updated>2023-08-06T07:11:00.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP怎么建立连接"><a href="#TCP怎么建立连接" class="headerlink" title="TCP怎么建立连接"></a>TCP怎么建立连接</h3><h3 id="有抓过包吗-（无）"><a href="#有抓过包吗-（无）" class="headerlink" title="有抓过包吗 （无）"></a>有抓过包吗 （无）</h3><h3 id="TCP的可靠性怎么保证"><a href="#TCP的可靠性怎么保证" class="headerlink" title="TCP的可靠性怎么保证"></a>TCP的可靠性怎么保证</h3><h3 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）</h3><h3 id="聊天室是怎么做的，以及一些地方的实现"><a href="#聊天室是怎么做的，以及一些地方的实现" class="headerlink" title="聊天室是怎么做的，以及一些地方的实现"></a>聊天室是怎么做的，以及一些地方的实现</h3><h3 id="用户密码明文存吗"><a href="#用户密码明文存吗" class="headerlink" title="用户密码明文存吗"></a>用户密码明文存吗</h3><h3 id="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"><a href="#因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施" class="headerlink" title="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"></a>因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施</h3><h3 id="TCP和UDP的区别，TCP为什么能保证可靠传输"><a href="#TCP和UDP的区别，TCP为什么能保证可靠传输" class="headerlink" title="TCP和UDP的区别，TCP为什么能保证可靠传输"></a>TCP和UDP的区别，TCP为什么能保证可靠传输</h3><h3 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h3><h3 id="HTTP长连接怎么保活"><a href="#HTTP长连接怎么保活" class="headerlink" title="HTTP长连接怎么保活"></a>HTTP长连接怎么保活</h3><h3 id="输入一个网址到查看到信息，中间的过程"><a href="#输入一个网址到查看到信息，中间的过程" class="headerlink" title="输入一个网址到查看到信息，中间的过程"></a>输入一个网址到查看到信息，中间的过程</h3><h3 id="讲一下什么是IO多路复用"><a href="#讲一下什么是IO多路复用" class="headerlink" title="讲一下什么是IO多路复用"></a>讲一下什么是IO多路复用</h3><h3 id="讲一讲select、poll和epoll的区别"><a href="#讲一讲select、poll和epoll的区别" class="headerlink" title="讲一讲select、poll和epoll的区别"></a>讲一讲select、poll和epoll的区别</h3><h3 id="socket通讯的流程，深入到kernel层面"><a href="#socket通讯的流程，深入到kernel层面" class="headerlink" title="socket通讯的流程，深入到kernel层面"></a>socket通讯的流程，深入到kernel层面</h3><h3 id="poll，select，epoll-ET-x2F-LT"><a href="#poll，select，epoll-ET-x2F-LT" class="headerlink" title="poll，select，epoll,ET&#x2F;LT"></a>poll，select，epoll,ET&#x2F;LT</h3><h3 id="docker里能bind-CPU-是真的bind吗"><a href="#docker里能bind-CPU-是真的bind吗" class="headerlink" title="docker里能bind CPU,是真的bind吗"></a>docker里能bind CPU,是真的bind吗</h3><h3 id="Http框架构成。"><a href="#Http框架构成。" class="headerlink" title="Http框架构成。"></a>Http框架构成。</h3><h3 id="Http和RPC区别。"><a href="#Http和RPC区别。" class="headerlink" title="Http和RPC区别。"></a>Http和RPC区别。</h3><h3 id="RPC的优势。"><a href="#RPC的优势。" class="headerlink" title="RPC的优势。"></a>RPC的优势。</h3><p>14 算法题：给一个二叉树，输出二叉树的左视图，所谓左视图就是每一层最左边的节点</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux命令用过哪些"><a href="#linux命令用过哪些" class="headerlink" title="linux命令用过哪些"></a>linux命令用过哪些</h3><h3 id="死锁怎么产生"><a href="#死锁怎么产生" class="headerlink" title="死锁怎么产生"></a>死锁怎么产生</h3><h3 id="怎么避免死锁"><a href="#怎么避免死锁" class="headerlink" title="怎么避免死锁"></a>怎么避免死锁</h3><h3 id="操作系统中内核态和用户态的区别，分别干什么"><a href="#操作系统中内核态和用户态的区别，分别干什么" class="headerlink" title="操作系统中内核态和用户态的区别，分别干什么"></a>操作系统中内核态和用户态的区别，分别干什么</h3><h3 id="敲键盘发生的中断"><a href="#敲键盘发生的中断" class="headerlink" title="敲键盘发生的中断"></a>敲键盘发生的中断</h3><h3 id="Linux里kernel里的buffer如何通知user的"><a href="#Linux里kernel里的buffer如何通知user的" class="headerlink" title="Linux里kernel里的buffer如何通知user的"></a>Linux里kernel里的buffer如何通知user的</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL的隔离级别有哪几种"><a href="#MySQL的隔离级别有哪几种" class="headerlink" title="MySQL的隔离级别有哪几种"></a>MySQL的隔离级别有哪几种</h3><h3 id="脏读和幻读分别是什么"><a href="#脏读和幻读分别是什么" class="headerlink" title="脏读和幻读分别是什么"></a>脏读和幻读分别是什么</h3><h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><h3 id="小于n的最大数（寄）"><a href="#小于n的最大数（寄）" class="headerlink" title="小于n的最大数（寄）"></a>小于n的最大数（寄）</h3><p>给一个数n，一个数组A，返回由A中元素组成的小于n的最大数<br>如n&#x3D;23121，A&#x3D;{2,4,9| 返回22999<br>n&#x3D;23121 A&#x3D;{9} 返回9999<br>n&#x3D;23333 A&#x3D;{2,3} 返回23332<br>n&#x3D;2222 A&#x3D;{2} 返回222<br>n&#x3D;2 A&#x3D;{2} 无解</p><h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><h3 id="最长连续递增子序列长度"><a href="#最长连续递增子序列长度" class="headerlink" title="最长连续递增子序列长度"></a>最长连续递增子序列长度</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就2，4或3，8，最长长度为2<br>设数组dp[i]，表示以i为结尾的最长连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，1，1，2，1，2}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[6] = &#123;1,5,2,4,3,8&#125;;    int dp[6];    dp[0] = 1;    for(int i=1;i&lt;6;i++)&#123;        dp[i] = 1;        if(Array[i] &gt; Array[i-1])&#123;            dp[i] = dp[i-1] + 1;        &#125;    &#125;    for(int i=0;i&lt;6;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre><h3 id="最长不连续递增子序列"><a href="#最长不连续递增子序列" class="headerlink" title="最长不连续递增子序列"></a>最长不连续递增子序列</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就1，2，418或1，2，3，8，最长长度为4<br>设数组dp[i]，表示以i为结尾的最长不连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，2，2，3，3，4}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[10] = &#123;1,5,2,4,3,8,7,2,9,10&#125;;    int dp[10];    dp[0]=1;    for(int i=1;i&lt;10;i++)&#123;        dp[i] = 1;        for(int j=i-1;j&gt;=0;j--)&#123;            if(Array[i]&gt;Array[j])&#123;                dp[i] = max(dp[i],dp[j]+1);            &#125;        &#125;    &#125;    for(int i=0;i&lt;10;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h2&gt;&lt;h3 id=&quot;TCP怎么建立连接&quot;&gt;&lt;a href=&quot;#TCP怎么建立连接&quot; class=&quot;headerlink&quot; title=&quot;TCP怎么建立</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>百度</title>
    <link href="http://example.com/p/158ea4f5.html"/>
    <id>http://example.com/p/158ea4f5.html</id>
    <published>2023-07-24T13:04:37.070Z</published>
    <updated>2023-08-06T07:10:06.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="计网："><a href="#计网：" class="headerlink" title="计网："></a>计网：</h2><h3 id="讲一下http和https的不同"><a href="#讲一下http和https的不同" class="headerlink" title="讲一下http和https的不同"></a>讲一下http和https的不同</h3><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><h3 id="用的是对称加密还是非对称加密"><a href="#用的是对称加密还是非对称加密" class="headerlink" title="用的是对称加密还是非对称加密"></a>用的是对称加密还是非对称加密</h3><h3 id="HTTP1-1，-2-0区别"><a href="#HTTP1-1，-2-0区别" class="headerlink" title="HTTP1.1， 2.0区别"></a>HTTP1.1， 2.0区别</h3><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h3 id="TCP能不能改成2次握手"><a href="#TCP能不能改成2次握手" class="headerlink" title="TCP能不能改成2次握手"></a>TCP能不能改成2次握手</h3><h3 id="讲一下OSI的七层模型，以及每一层的含义和应用"><a href="#讲一下OSI的七层模型，以及每一层的含义和应用" class="headerlink" title="讲一下OSI的七层模型，以及每一层的含义和应用"></a>讲一下OSI的七层模型，以及每一层的含义和应用</h3><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h3 id="三次握手中如果数据发送失败，让你设计你会怎么处理"><a href="#三次握手中如果数据发送失败，让你设计你会怎么处理" class="headerlink" title="三次握手中如果数据发送失败，让你设计你会怎么处理"></a>三次握手中如果数据发送失败，让你设计你会怎么处理</h3><h3 id="讲一讲四次挥手？"><a href="#讲一讲四次挥手？" class="headerlink" title="讲一讲四次挥手？"></a>讲一讲四次挥手？</h3><p>答：TCP的四次挥手分为主动关闭方和被动关闭方。主动关闭方因为自身的stream结束，主动发送了FIN报文，为第一次挥手。被动关闭方发送对第一次挥手确认的ACK报文，这为第二次挥手。接着被动方的stream结束，发送FIN报文，此为第三次挥手。最后，主动关闭方发送ACK报文对第三次挥手进行确认，为第四次挥手。</p><h3 id="为什么是四次挥手，不能是两次挥手吗？"><a href="#为什么是四次挥手，不能是两次挥手吗？" class="headerlink" title="为什么是四次挥手，不能是两次挥手吗？"></a>为什么是四次挥手，不能是两次挥手吗？</h3><p>答：因为发送方发送完FIN报文之后，需要对方回复ACK报文表示：发送方的FIN报文被接收方确认已经收到。所以一定需要四次挥手。如果只有两次挥手，主动关闭方和被动关闭方分别发送FIN报文，不接受ACK报文。主动关闭方和被动关闭方无法知道发送的FIN报文被对方收到，因为FIN报文可能在网络中遗失了。</p><h3 id="讲讲close-wait状态和last-ack状态的区别？"><a href="#讲讲close-wait状态和last-ack状态的区别？" class="headerlink" title="讲讲close_wait状态和last_ack状态的区别？"></a>讲讲close_wait状态和last_ack状态的区别？</h3><p>答：这两个状态都是被动结束方的状态，被动结束方接收第一次挥手，从establish状态变成close_wait状态。接着。被动结束方发送第二次和第三次挥手，从close_wait状态转变到last_ack状态。在last_ack状态，被动结束方等待主动结束方的第四次挥手。其中，第二次和第三次挥手之间，需要程序员触发close()。</p><h3 id="HTTP请求有哪些方法，GET和-POST方法有什么区别？"><a href="#HTTP请求有哪些方法，GET和-POST方法有什么区别？" class="headerlink" title="HTTP请求有哪些方法，GET和 POST方法有什么区别？"></a>HTTP请求有哪些方法，GET和 POST方法有什么区别？</h3><p>答：HTTP请求有head，get,post方法。其中GET方法语义倾向于下载，post倾向于上传。</p><h3 id="如果在time-wait状态点击read会怎样？"><a href="#如果在time-wait状态点击read会怎样？" class="headerlink" title="如果在time_wait状态点击read会怎样？"></a>如果在time_wait状态点击read会怎样？</h3><p>答：在timewait状态read类似重新进行tcp连接，如果开启时间戳机制，下一次的序列号和时间戳都比期望的大可以重新进行连接</p><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><h3 id="OSI的七层模型，以及每一层的含义和应用"><a href="#OSI的七层模型，以及每一层的含义和应用" class="headerlink" title="OSI的七层模型，以及每一层的含义和应用"></a>OSI的七层模型，以及每一层的含义和应用</h3><h3 id="三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲"><a href="#三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲" class="headerlink" title="三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲"></a>三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲</h3><h3 id="RPC协议讲解。通用于分布式框架中"><a href="#RPC协议讲解。通用于分布式框架中" class="headerlink" title="RPC协议讲解。通用于分布式框架中"></a>RPC协议讲解。通用于分布式框架中</h3><h3 id="为什么要三次握手，两次不行吗？"><a href="#为什么要三次握手，两次不行吗？" class="headerlink" title="为什么要三次握手，两次不行吗？"></a>为什么要三次握手，两次不行吗？</h3><h3 id="tcp和udp是什么，有什么区别"><a href="#tcp和udp是什么，有什么区别" class="headerlink" title="tcp和udp是什么，有什么区别"></a>tcp和udp是什么，有什么区别</h3><h3 id="为啥要OSI七层模型？有什么作用"><a href="#为啥要OSI七层模型？有什么作用" class="headerlink" title="为啥要OSI七层模型？有什么作用"></a>为啥要OSI七层模型？有什么作用</h3><h3 id="http如何进行流量控制？拥塞控制"><a href="#http如何进行流量控制？拥塞控制" class="headerlink" title="http如何进行流量控制？拥塞控制"></a>http如何进行流量控制？拥塞控制</h3><h3 id="数据链路层的传输单位，网络层呢？"><a href="#数据链路层的传输单位，网络层呢？" class="headerlink" title="数据链路层的传输单位，网络层呢？"></a>数据链路层的传输单位，网络层呢？</h3><h3 id="HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。"><a href="#HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。" class="headerlink" title="HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。"></a>HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。</h3><h3 id="ftp是什么，哪一层的协议？"><a href="#ftp是什么，哪一层的协议？" class="headerlink" title="ftp是什么，哪一层的协议？"></a>ftp是什么，哪一层的协议？</h3><p>作者：maybe的小超人<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post">https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post</a><br>来源：牛客网</p><h3 id="知不知道拥塞控制，讲一下"><a href="#知不知道拥塞控制，讲一下" class="headerlink" title="知不知道拥塞控制，讲一下"></a>知不知道拥塞控制，讲一下</h3><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>应用  http ftp  DNS POP3<br>会话<br>表示<br>运输<br>网络  IP，ICMP，RIP，OSPF，BGP，IGMP<br>链路  SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理  ISO2110，IEEE802，IEEE802.2</p><h3 id="tcp建立连接过程"><a href="#tcp建立连接过程" class="headerlink" title="tcp建立连接过程"></a>tcp建立连接过程</h3><h3 id="断开连接过程"><a href="#断开连接过程" class="headerlink" title="断开连接过程"></a>断开连接过程</h3><h3 id="为什么客户端的-TIME-WAIT-状态必须等待-2MSL"><a href="#为什么客户端的-TIME-WAIT-状态必须等待-2MSL" class="headerlink" title="为什么客户端的 TIME-WAIT 状态必须等待 2MSL"></a>为什么客户端的 TIME-WAIT 状态必须等待 2MSL</h3><h3 id="输入网址到浏览器的过程"><a href="#输入网址到浏览器的过程" class="headerlink" title="输入网址到浏览器的过程"></a>输入网址到浏览器的过程</h3><h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="查看端口的命令"><a href="#查看端口的命令" class="headerlink" title="查看端口的命令"></a>查看端口的命令</h3><h3 id="解除端口占用的命令"><a href="#解除端口占用的命令" class="headerlink" title="解除端口占用的命令"></a>解除端口占用的命令</h3><h3 id="查看日志文件接口被调用次数的命令"><a href="#查看日志文件接口被调用次数的命令" class="headerlink" title="查看日志文件接口被调用次数的命令"></a>查看日志文件接口被调用次数的命令</h3><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><h3 id="查看-TCP-状态？"><a href="#查看-TCP-状态？" class="headerlink" title="查看 TCP 状态？"></a>查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h3 id="进程间有哪些通信方式，讲一下"><a href="#进程间有哪些通信方式，讲一下" class="headerlink" title="进程间有哪些通信方式，讲一下"></a>进程间有哪些通信方式，讲一下</h3><h3 id="linux中32-和-64是什么意思"><a href="#linux中32-和-64是什么意思" class="headerlink" title="linux中32 和 64是什么意思"></a>linux中32 和 64是什么意思</h3><h3 id="I-x2F-O多路复用。水平触发和边缘触发"><a href="#I-x2F-O多路复用。水平触发和边缘触发" class="headerlink" title="I&#x2F;O多路复用。水平触发和边缘触发"></a>I&#x2F;O多路复用。水平触发和边缘触发</h3><h3 id="数据序列化实现。对二进制序列化，Pool-Buffer。"><a href="#数据序列化实现。对二进制序列化，Pool-Buffer。" class="headerlink" title="数据序列化实现。对二进制序列化，Pool Buffer。"></a>数据序列化实现。对二进制序列化，Pool Buffer。</h3><h3 id="cpu密集型和i-x2F-o密集型什么意思"><a href="#cpu密集型和i-x2F-o密集型什么意思" class="headerlink" title="cpu密集型和i&#x2F;o密集型什么意思"></a>cpu密集型和i&#x2F;o密集型什么意思</h3><h3 id="如果1g的内存，能否申请2g的空间，8g呢？"><a href="#如果1g的内存，能否申请2g的空间，8g呢？" class="headerlink" title="如果1g的内存，能否申请2g的空间，8g呢？"></a>如果1g的内存，能否申请2g的空间，8g呢？</h3><h3 id="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"><a href="#死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）" class="headerlink" title="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"></a>死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）</h3><h3 id="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"><a href="#进程调度算法有哪些，最短作业优先怎么样的，有什么弊端" class="headerlink" title="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"></a>进程调度算法有哪些，最短作业优先怎么样的，有什么弊端</h3><h3 id="讲一下select-x2F-pool-x2F-epoll"><a href="#讲一下select-x2F-pool-x2F-epoll" class="headerlink" title="讲一下select&#x2F;pool&#x2F;epoll"></a>讲一下select&#x2F;pool&#x2F;epoll</h3><h3 id="讲一下同步（阻塞，非阻塞）IO-x2F-异步IO"><a href="#讲一下同步（阻塞，非阻塞）IO-x2F-异步IO" class="headerlink" title="讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO"></a>讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO</h3><h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="用过哪些数据库，了解NOSQL吗"><a href="#用过哪些数据库，了解NOSQL吗" class="headerlink" title="用过哪些数据库，了解NOSQL吗"></a>用过哪些数据库，了解NOSQL吗</h3><h3 id="MySQL有哪些索引"><a href="#MySQL有哪些索引" class="headerlink" title="MySQL有哪些索引"></a>MySQL有哪些索引</h3><h3 id="主键索引和唯一索引区别"><a href="#主键索引和唯一索引区别" class="headerlink" title="主键索引和唯一索引区别"></a>主键索引和唯一索引区别</h3><h3 id="Mysql中的索引讲一下"><a href="#Mysql中的索引讲一下" class="headerlink" title="Mysql中的索引讲一下"></a>Mysql中的索引讲一下</h3><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><h3 id="一个联合索引（a，b，c），查询（a，c），能用到索引吗"><a href="#一个联合索引（a，b，c），查询（a，c），能用到索引吗" class="headerlink" title="一个联合索引（a，b，c），查询（a，c），能用到索引吗"></a>一个联合索引（a，b，c），查询（a，c），能用到索引吗</h3><h3 id="事物的特性"><a href="#事物的特性" class="headerlink" title="事物的特性"></a>事物的特性</h3><h3 id="SQL注入-怎么避免"><a href="#SQL注入-怎么避免" class="headerlink" title="SQL注入 怎么避免"></a>SQL注入 怎么避免</h3><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h3 id="读已提交和读未提交有什么区别"><a href="#读已提交和读未提交有什么区别" class="headerlink" title="读已提交和读未提交有什么区别"></a>读已提交和读未提交有什么区别</h3><h3 id="解释脏读"><a href="#解释脏读" class="headerlink" title="解释脏读"></a>解释脏读</h3><h3 id="解释可重复读-说一个场景-a数b数"><a href="#解释可重复读-说一个场景-a数b数" class="headerlink" title="解释可重复读 说一个场景 a数b数"></a>解释可重复读 说一个场景 a数b数</h3><h3 id="mvcc实现逻辑"><a href="#mvcc实现逻辑" class="headerlink" title="mvcc实现逻辑"></a>mvcc实现逻辑</h3><h3 id="mysql日志-有哪几种"><a href="#mysql日志-有哪几种" class="headerlink" title="mysql日志 有哪几种"></a>mysql日志 有哪几种</h3><h3 id="mvcc用的哪一个日志"><a href="#mvcc用的哪一个日志" class="headerlink" title="mvcc用的哪一个日志"></a>mvcc用的哪一个日志</h3><h3 id="mysql的锁有哪些"><a href="#mysql的锁有哪些" class="headerlink" title="mysql的锁有哪些"></a>mysql的锁有哪些</h3><h3 id="char和varchar的区别-哪一个效率高"><a href="#char和varchar的区别-哪一个效率高" class="headerlink" title="char和varchar的区别  哪一个效率高"></a>char和varchar的区别  哪一个效率高</h3><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>两个包含5亿URL的文件，找两个文件的重复URL，内存只有4G。<br>首先我们最常想到的方法是读取文件a，建立哈希表，然后再读取文件b，遍历文件b中每个url，对于每个遍历，我们都执行查找hash表的操作，若hash表中搜索到了，则说明两文件共有，存入一个集合。</p><p>但上述方法有一个明显问题，加载一个文件的数据需要50亿*64bytes &#x3D; 320G远远大于4G内存，何况我们还需要分配哈希表数据结构所使用的空间，所以不可能一次性把文件中所有数据构建一个整体的hash表。所以虽然可行，但是无法满足需求。</p><p>针对上述问题，我们采用分治算法的思想。</p><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M)，为什么是1000？主要根据内存大小和要分治的文件大小来计算，我们就大致可以把320G大小分为1000份，每份大约300M（当然，到底能不能分布尽量均匀，得看hash函数的设计）</p><p>遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999)（为什么要这样做? 文件a的hash映射和文件b的hash映射函数要保持一致，这样的话相同的url就会保存在对应的小文件中，比如，如果a中有一个url记录data1被hash到了a99文件中，那么如果b中也有相同url，则一定被hash到了b99中）</p><p>所以现在问题转换成了：找出1000对小文件中每一对相同的url（不对应的小文件不可能有相同的url）</p><p>因为每个hash大约300M，所以我们再可以采用哈希中的想法</p><h3 id="场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？"><a href="#场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？" class="headerlink" title="场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？"></a>场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？</h3><h3 id="算法场景题。一个生产者消费者场景。提了一些改进点。"><a href="#算法场景题。一个生产者消费者场景。提了一些改进点。" class="headerlink" title="算法场景题。一个生产者消费者场景。提了一些改进点。"></a>算法场景题。一个生产者消费者场景。提了一些改进点。</h3><p>&#x2F;&#x2F; 模块A、B，创建一个Buffer类，提供统一的接口供有A去生产数据，B去消费数据。<br>&#x2F;&#x2F; 一些细节：<br>&#x2F;&#x2F; 1. A创建数据的大小是任意的，可能是256个字节，也可能是1k<br>&#x2F;&#x2F; 2. 提供接口供消费者B，获取数据的大小，并可以一次性获取所有数据，或者分批获取数据<br>&#x2F;&#x2F; 3. A、B在不同的线程中，要实现线程安全的数据接口</p><p>作者：Olimiya<br>链接：<a href="https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic">https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic</a><br>来源：牛客网</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="数组中找第K大的数"><a href="#数组中找第K大的数" class="headerlink" title="数组中找第K大的数"></a>数组中找第K大的数</h3><pre><code>class Solution &#123;public:    void quickPartition(vector&lt;int&gt;&amp; nums, int start, int end, int target) &#123;        // 随机取一个数作为基准        srand(time(nullptr));        int random = rand() % (end - start + 1) + start;        int base = nums[random];        // 将该数放到待快排区间开头第一个元素        swap(nums[start], nums[random]);        int index = start;        // 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素        // 交换到index + 1位置，index++，使得最终index前面的元素都比base大。        for (int i = start + 1; i &lt;= end; ++i) &#123;            if (nums[i] &gt;= base) &#123;                swap(nums[index + 1], nums[i]);                index++;            &#125;        &#125;        // base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。        swap(nums[index], nums[start]);            // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，        // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。        if (index &lt; target) &#123;            quickPartition(nums, index + 1, end, target);        &#125;        else if (index &gt; target) &#123;            quickPartition(nums, start, index - 1, target);        &#125;    &#125;    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        // 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，        // 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k    // 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。        quickPartition(nums, 0, nums.size() - 1, k - 1);        return nums[k - 1];    &#125;&#125;;class Solution &#123;    Random random=new Random();    public int findKthLargest(int[] nums, int k) &#123;            return quickSelect(nums,k,0,nums.length-1);    &#125;    public int quickSelect(int[] nums,int k,int left,int right)&#123;        //随机获取一个值作为目标值        int index=random.nextInt(right-left+1)+left;        //保存目标值        int target=nums[index];        //在进行第一次交换时，会丢失nums[left],因此需要保存        nums[index]=nums[left];        int i=left,j=right;        while(i&lt;j)&#123;            while(i&lt;j&amp;&amp;nums[j]&lt;=target) j--;            nums[i]=nums[j];            while(i&lt;j&amp;&amp;nums[i]&gt;=target) i++;            nums[j]=nums[i];        &#125;        nums[i]=target;        //经过交换后，i左部均大于nums[i],右部均小于nums[i]        if(i==k-1) return nums[i];        //说明在左部分        else if(i&gt;k-1) return quickSelect(nums,k,left,i-1);        else return quickSelect(nums,k,i+1,right);    &#125;&#125;</code></pre><h3 id="合并k个链表"><a href="#合并k个链表" class="headerlink" title="合并k个链表"></a>合并k个链表</h3><p>class Solution {<br>public:<br>    struct Status {<br>        int val;<br>        ListNode *ptr;<br>        bool operator &lt; (const Status &amp;rhs) const {<br>            return val &gt; rhs.val;<br>        }<br>    };</p><pre><code>priority_queue &lt;Status&gt; q;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    for (auto node: lists) &#123;        if (node) q.push(&#123;node-&gt;val, node&#125;);    &#125;    ListNode head, *tail = &amp;head;    while (!q.empty()) &#123;        auto f = q.top(); q.pop();        tail-&gt;next = f.ptr;         tail = tail-&gt;next;        if (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);    &#125;    return head.next;&#125;</code></pre><p>};</p><h3 id="k个升序链表的合并"><a href="#k个升序链表的合并" class="headerlink" title="k个升序链表的合并"></a>k个升序链表的合并</h3><p>class Solution {<br>public:<br>    struct Status {<br>        int val;<br>        ListNode *ptr;<br>        bool operator &lt; (const Status &amp;rhs) const {<br>            return val &gt; rhs.val;<br>        }<br>    };</p><pre><code>priority_queue &lt;Status&gt; q;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    for (auto node: lists) &#123;        if (node) q.push(&#123;node-&gt;val, node&#125;);    &#125;    ListNode head, *tail = &amp;head;    while (!q.empty()) &#123;        auto f = q.top(); q.pop();        tail-&gt;next = f.ptr;         tail = tail-&gt;next;        if (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);    &#125;    return head.next;&#125;</code></pre><p>};</p><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><pre><code>class Solution &#123;public:    int getKthMagicNumber(int k) &#123;        set&lt;long long&gt; st;        st.insert(1LL);        long long ans = 0;        for(int i=0;i&lt;k;++i)&#123;            ans = *st.begin();            st.erase(st.begin());            st.insert(ans * 3);            st.insert(ans * 5);            st.insert(ans * 7);        &#125;        return ans;    &#125;&#125;;</code></pre><h3 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h3><h3 id="中序遍历递归和非递归写法"><a href="#中序遍历递归和非递归写法" class="headerlink" title="中序遍历递归和非递归写法"></a>中序遍历递归和非递归写法</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="数组中第K大的值，O-nlogn-，不能用sort-函数"><a href="#数组中第K大的值，O-nlogn-，不能用sort-函数" class="headerlink" title="数组中第K大的值，O(nlogn)，不能用sort()函数"></a>数组中第K大的值，O(nlogn)，不能用sort()函数</h3><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><h3 id="查找链表倒数第K个数"><a href="#查找链表倒数第K个数" class="headerlink" title="查找链表倒数第K个数"></a>查找链表倒数第K个数</h3><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><h2 id="智力题："><a href="#智力题：" class="headerlink" title="智力题："></a>智力题：</h2><h3 id="25匹马5个赛道，最少几次前三名马"><a href="#25匹马5个赛道，最少几次前三名马" class="headerlink" title="25匹马5个赛道，最少几次前三名马"></a>25匹马5个赛道，最少几次前三名马</h3><h3 id="1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药"><a href="#1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药" class="headerlink" title="1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药"></a>1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度&quot;&gt;&lt;a href=&quot;#百度&quot; class=&quot;headerlink&quot; title=&quot;百度&quot;&gt;&lt;/a&gt;百度&lt;/h1&gt;&lt;h2 id=&quot;计网：&quot;&gt;&lt;a href=&quot;#计网：&quot; class=&quot;headerlink&quot; title=&quot;计网：&quot;&gt;&lt;/a&gt;计网：&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://example.com/p/c5176eb2.html"/>
    <id>http://example.com/p/c5176eb2.html</id>
    <published>2023-07-22T08:38:09.342Z</published>
    <updated>2023-07-24T14:24:18.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。RPC 的作用就是体现在这样两个方面：</p><ul><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</li></ul><h2 id="RPC-通信流程"><a href="#RPC-通信流程" class="headerlink" title="RPC 通信流程"></a>RPC 通信流程</h2><p>RPC 是一个远程调用，那肯定就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。<br>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方<br>从 TCP 通道里面收到二进制数据.根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p><p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验</p><p><img src="https://s1.ax1x.com/2023/07/22/pCqmTbt.png" alt="pCqmTbt.png"></p><p>RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从“单体”演进成“微服务化”，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是“经络”一样的存在。RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p><h2 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h2><p>RPC 本质上就是一个远程调用，那肯定就需要通过网络来传输数据。虽然传输协议可以有多种选择，但考虑到可靠性的话，我们一般默认采用 TCP 协议。为了屏蔽网络传输的复杂性，我们需要封装一个单独的数据传输模块用来收发二进制数据，这个单独模块我们可以叫做传输模块<br>用户请求的时候是基于方法调用，方法出入参数都是对象数据，对象是肯定没法直接在网络中传输的，我们需要提前把它转成可传输的二进制，这就是我们说的序列化过程。但只是把方法调用参数的二进制数据传输到服务提供方是不够的，我们需要在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，在两个“断句”符号中间放的内容就是我们请求的二进制数据，这个过程我们叫做协议封装。<br>虽然这是两个不同的过程，但其目的都是一样的，都是为了保证数据在网络中可以正确传输。这里我说的正确，可不仅指数据能够传输，还需要保证传输后能正确还原出传输前的语义。所以我们可以把这两个处理过程放在架构中的同一个模块，统称为协议模块。除此之外，我们还可以在协议模块中加入压缩功能，这是因为压缩过程也是对传输的二进制数据进行操作。在实际的网络传输过程中，我们的请求数据包在数据链路层可能会因为太大而被拆分成多个数据包进行传输，为了减少被拆分的次数，从而导致整个传输过程时间太长的问题，我们可以在 RPC 调用的时候这样操作：在方法调用参数或者返回值的二进制数据大于某个阈值的情况下，我们可以通过压缩框架进行无损压缩，然后在另外一端也用同样的压缩算法进行解压，保证数据可还原<br>传输和协议这两个模块是 RPC 里面最基础的功能，它们使对象可以正确地传输到服务提供方。但距离 RPC 的目标——实现像调用本地一样地调用远程，还缺少点东西。因为这两个模块所提供的都是一些基础能力，要让这两个模块同时工作的话，我们需要手写一些黏合的代码，但这些代码对我们使用 RPC 的研发人员来说是没有意义的，而且属于一个重复的工作，会导致使用过程的体验非常不友好。<br>这就需要我们在 RPC 里面把这些细节对研发人员进行屏蔽，让他们感觉不到本地调用和远程调用的区别。假设有用到 Spring 的话，我们希望 RPC 能让我们把一个 RPC 接口定义成一个 Spring Bean，并且这个 Bean 也会统一被 Spring Bean Factory 管理，可以在项目中通过 Spring 依赖注入到方式引用。这是 RPC 调用的入口，我们一般叫做 Bootstrap 模块</p><p>到这儿，一个点对点（Point to Point）版本的 RPC 框架就完成了。我一般称这种模式的 RPC 框架为单机版本，因为它没有集群能力。所谓集群能力，就是针对同一个接口有着多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在 RPC 里面我们还需要给调用方找到所有的服务提供方，并需要在 RPC 里面维护好接口跟服务提供者地址的关系，这样调用方在发起请求的时候才能快速地找到对应的接收地址，这就是我们常说的“服务发现”。</p><p>但服务发现只是解决了接口和服务提供方地址映射关系的查找问题，这更多是一种“静态数据”。说它是静态数据是因为，对于我们的 RPC 来说，我们每次发送请求的时候都是需要用 TCP 连接的，相对服务提供方 IP 地址，TCP 连接状态是瞬息万变的，所以我们的 RPC框架里面要有连接管理器去维护 TCP 连接的状态。<br>有了集群之后，提供方可能就需要管理好这些服务了，那我们的 RPC 就需要内置一些服务治理的功能，比如服务提供方权重的设置、调用授权等一些常规治理手段。而服务调用方需要额外做哪些事情呢？每次调用前，我们都需要根据服务提供方设置的规则，从集群中选择可用的连接用于发送请求</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq17QO.png" alt="pCq17QO.png"></p><p>设计 RPC 框架不可能在开始时就面面俱到。有一天业务方有了新的需求，要加入很多新的功能，这时当前架构面临的可就是大挑战了，要修改很多地方才能实现。这就是我们接下来要讲的插件化架构</p><p>在 RPC 框架里面，我们是怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机制，它可以动态地为某个接口寻找服务实现。使用 SPI 机制需要在 Classpath 下的 META-INF&#x2F;services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。<br>但在实际项目中，我们其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载，ServiceLoader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。</p><p>加上了插件功能之后，我们的 RPC 框架就包含了两大核心体系——核心功能体系与插件体</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3pSf.png" alt="pCq3pSf.png"></p><p>这时，整个架构就变成了一个微内核架构，我们将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离并提供接口的默认实现。这样的架构相比之前的架构，有很多优势。首先它的可扩展性很好，实现了开闭原则，用户可以非常方便地通过插件扩展实现自己的功能，而且不需要修改核心功能的本身；其次就是保持了核心包的精简，依赖外部包少，这样可以有效减少开发人员引入 RPC 导致的包版本冲突问题</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="为什么需要服务发现？"><a href="#为什么需要服务发现？" class="headerlink" title="为什么需要服务发现？"></a>为什么需要服务发现？</h3><p>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现<br>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例。服务 IP 集合作为“通信录”中的地址，从而可以通过接口获取服务 IP 的集合来完成服务的发现。这就是我要说的 PRC 框架的服务发现机制，如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3lm4.png" alt="pCq3lm4.png"></p><ol><li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。</li><li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</li></ol><h3 id="基于-ZooKeeper-的服务发现"><a href="#基于-ZooKeeper-的服务发现" class="headerlink" title="基于 ZooKeeper 的服务发现"></a>基于 ZooKeeper 的服务发现</h3><p>整体的思路很简单，就是搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能，整体流程如下图：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3dXD.md.png" alt="pCq3dXD.md.png"></p><p>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：&#x2F;service&#x2F;com.demo.xxService），在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息。</p><p>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</p><p>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方 watch 该服务的服务提供方目录（&#x2F;service&#x2F;com.demo.xxService&#x2F;provider）中所有的服务节点数据。</p><p>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</p><p>微服务化程度越来越高之后，ZooKeeper 集群整体压力也越来越高,当连接到ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机。而宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机。</p><h3 id="基于消息总线的最终一致性的注册中心"><a href="#基于消息总线的最终一致性的注册中心" class="headerlink" title="基于消息总线的最终一致性的注册中心"></a>基于消息总线的最终一致性的注册中心</h3><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。<br>而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。</p><p>因为要求最终一致性，我们可以考虑采用消息总线机制。注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据。当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本。<br>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息。对于获取到消息的在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。<br>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面。<br>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</p><p>为了性能，这里采用了两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性。</p><p>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况，这个时候有没有问题？这个问题我们放到了 RPC 框架里面去处理，在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求。服务调用方收到拒绝异常后，会安全重试到其它节点。</p><p>通过消息总线的方式，我们就可以完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作。服务发现的特性是允许我们在设计超大规模集群服务发现系统的时候，舍弃强一致性，更多地考虑系统的健壮性。最终一致性才是分布式系统设计中更为常用</p><h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的IP 地址。为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的.<br>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况，那怎么保证选择出来的连接一定是可用的呢？</p><p>终极的解决方案是让调用方实时感知到节点的状态变化，这样他们才能做出正确的选择。</p><h3 id="健康检测的逻辑"><a href="#健康检测的逻辑" class="headerlink" title="健康检测的逻辑"></a>健康检测的逻辑</h3><p>当服务方下线，正常情况下我们肯定会收到连接断开的通知事件,但咱们这里不行，因为应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。<br>业内常用的检测方法就是用心跳机制。心跳机制说起来也不复杂，其实就是服务调用方每隔一段时间就问一下服务提供方，“兄弟，你还好吧？”，然后服务提供方很诚实地告诉调用方它目前的状态。</p><p>服务方的状态一般会有三种情况</p><ol><li>健康状态：建立连接成功，并且心跳探活也一直成功；</li><li>亚健康状态：建立连接成功，但是心跳请求连续失败；</li><li>死亡状态：建立连接失败。</li></ol><p>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化，具体状态间转换图如下：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>一开始初始化的时候，如果建立连接成功，那就是健康状态，否则就是死亡状态。这里没有亚健康这样的中间态。紧接着，如果健康状态的节点连续出现几次不能响应心跳请求的情况，那就会被标记为亚健康状态，也就是说，服务调用方会觉得它生病了。生病之后（亚健康状态），如果连续几次都能正常响应心跳请求，那就可以转回健康状态，证明病好了。如果病一直好不了，那就会被断定为是死亡节点，死亡之后还需要善后，比如关闭连接<br>当然，死亡并不是真正死亡，它还有复活的机会。如果某个时间点里，死亡的节点能够重连成功，那它就可以重新被标记为健康状态。</p><p>一个节点从健康状态过渡到亚健康状态的前提是“连续”心跳失败次数必须到达某一个阈值</p><ul><li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次，所以我们不能把简单的把总失败的次数当作判断条件。</li><li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s，所以我们也不能把 TPS 至来当作判断条件。</li></ul><p>所以可以考虑使用可用率，可用率的计算方式是某一个时间窗口内接口调用成功次数的百分比（成功次数 &#x2F; 总调用次数）。当可用率低于个比例就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口也兼顾了接口响应时间不同的问题。</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p>在真实环境中我们的服务提供方是以一个集群的方式提供服务，这对于服务调用方来说，就是一个接口会有多个服务提供方同时提供服务，所以我们的 RPC 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。<br>既然这些节点都可以用来完成这次请求，那么我们就可以简单地认为这些节点是同质的。就是这次请求无论发送到集合中的哪个节点上，返回的结果都是一样的。<br>既然服务提供方是以集群的方式对外提供服务，那就要考虑一些实际问题。要知道我们每次上线应用的时候都不止一台服务器会运行实例，那上线就涉及到变更，只要变更就可能导致原本正常运行的程序出现异常，尤其是发生重大变动的时候，导致我们应用不稳定的因素就变得很多。为了减少这种风险，我们一般会选择灰度发布我们的应用实例，比如我们可以先发布少量实例观察是否有异常，后续再根据观察的情况，选择发布更多实例还是回滚已经上线的实例。<br>但这种方式不好的一点就是，线上一旦出现问题，影响范围还是挺大的。因为对于我们的服务提供方来说，我们的服务会同时提供给很多调用方来调用，尤其是像一些基础服务的调用方会更复杂，比如商品、价格等等，一旦刚上线的实例有问题，那将会导致所有的调用方业务都会受损。</p><h3 id="如何实现路由策略？"><a href="#如何实现路由策略？" class="headerlink" title="如何实现路由策略？"></a>如何实现路由策略？</h3><p>在 RPC 里面服务调用方是通过服务发现的方式拿到了所有服务提供方的 IP 地址，当我们选择要灰度验证功能的时候，是不是就可以让注册中心在推送的时候区别对待，而不是一股脑的把服务提供方的 IP地址推送到所有调用方。换句话说就是，注册中心只会把刚上线的服务 IP 地址推送到选择指定的调用方，而其他调用方是不能通过服务发现拿到这个 IP 地址的。<br>通过服务发现的方式来隔离调用方请求，从逻辑上来看确实可行，但注册中心在 RPC 里面的定位是用来存储数据并保证数据一致性的。如果把这种复杂的计算逻辑放到注册中心里面，当集群节点变多之后，就会导致注册中心压力很大，而且大部分情况下我们一般都是采用开源软件来搭建注册中心，要满足这种需求还需要进行二次开发。所以从实际的角度出发，通过影响服务发现来实现请求隔离并不划算</p><p>我们可以重新回到调用方发起 RPC 调用的流程。在 RPC 发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（就是我们常说的负载均衡），那我们是不是可以在选择节点前加上“筛选逻辑”，把符合我们要求的节点筛选出来。那这个筛选的规则是什么呢？就是我们灰度过程中要验证的规则。</p><p>比如我们要求新上线的节点只允许某个 IP 可以调用，那我们的注册中心会把这条规则下发到服务调用方。在调用方收到规则后，在选择具体要发请求的节点前，会先通过筛选规则过滤节点集合，按照这个例子的逻辑，最后会过滤出一个节点，这个节点就是我们刚才新上线的节点。通过这样的改造，RPC 调用流程就变成了这样：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq7jMR.md.png" alt="pCq7jMR.md.png"></p><p>这个筛选过程在RPC 里面有一个专业名词，就是“路由策略”，而上面例子里面的路由策略是我们常见的 IP 路由策略，用于限制可以调用服务提供方的 IP。使用了 IP 路由策略后，整个集群的调用拓扑如下图所示</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqb8hD.png" alt="pCqb8hD.png"></p><h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><p>有了 IP 路由之后，上线过程中我们就可以做到只让部分调用方请求调用到新上线的实例，相对传统的灰度发布功能来说，这样做我们可以把试错成本降到最低。但在有些场景下，我们可能还需要更细粒度的路由方式。比如，在升级改造应用的时候，为了保证调用方能平滑地切调用我们的新应用逻辑，在升级过程中我们常用的方式是让新老应用并行运行一段时间，然后通过切流量百分比的方式，慢慢增大新应用承接的流量，直到新应用承担了 100% 且运行一段时间后才能去下线老应用。</p><p>在流量切换的过程中，为了保证整个流程的完整性，我们必须保证某个主题对象的所有请求都使用同一种应用来承接。假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作是用新应用（或者老应用）来完成所有请求的响应。很显然，上面的 IP 路由并不能满足我们这个需求，因为 IP 路由只是限制调用方来源，并不会根据请求参数请求到我们预设的服务提供方节点上去。</p><p>我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点。在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID，我们可以根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点。因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点。使用了参数路由策略后，整个集群的调用拓扑如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqbdBt.png" alt="pCqbdBt.png"></p><p>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。灰度发布功能是 RPC 路由功能的一个典型应用场景，通过 RPC 路由策略的组合使用可以让服务提供方更加灵活地管理、调用自己的流量，进一步降低上线可能导致的风<br>险。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqqjMj.png" alt="pCqqjMj.png"></p><p>负载均衡主要分为软负载和硬负载，软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等，硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等。负载均衡的算法主要有随机法、轮询法、最小连接法等。</p><h3 id="RPC-框架中的负载均衡"><a href="#RPC-框架中的负载均衡" class="headerlink" title="RPC 框架中的负载均衡"></a>RPC 框架中的负载均衡</h3><p>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。<br>RPC 负载均衡策略一般包括随机权重、Hash、轮询。当然，这还是主要看 RPC 框架自身的实现。其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制。比如我们默认每个节点的权重都是 100，但当我们把其中的一个节点的权重设置成 50 时，它接收到的流量就是其他节点的 1&#x2F;2。</p><p>由于负载均衡机制完全是由 RPC 框架自身实现的，所以它不再需要依赖任何负载均衡设备，自然也不会发生负载均衡设备的单点问题，服务调用方的负载均衡策略也完全可配，同时我们可以通过控制权重的方式，对负载均衡进行治理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h1&gt;&lt;p&gt;RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
