<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T08:35:27.079Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go泛型运用</title>
    <link href="http://example.com/p/f0317f09.html"/>
    <id>http://example.com/p/f0317f09.html</id>
    <published>2023-08-11T08:06:44.198Z</published>
    <updated>2023-08-11T08:35:27.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go泛型运用"><a href="#Go泛型运用" class="headerlink" title="Go泛型运用"></a>Go泛型运用</h1><h2 id="泛型起源"><a href="#泛型起源" class="headerlink" title="泛型起源"></a>泛型起源</h2><p>泛型编程是一种计算机编程风格，程序逻辑是根据参数指定的类型编写的，然后在调用时为作为参数提供的特定类型实例化。这种方法由1973年的ML编程语言开创，允许编写通用函数或类型，从而减少了代码重复。</p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>简而言之，类型做为参数。在Go语言语言中就是， 函数中携带泛型类型参数，接口&#x2F;结构体 支持泛型类型参数声明。</p><pre><code>func Add(a int, b int) int &#123;    return a + b&#125;func AddInt64(a int64, b int64) int64 &#123;    return a + b&#125;func Add[T int | int32 | int64 | float32 | float64](a T, b T) T &#123;    return a + b&#125;</code></pre><p>让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 泛型编程。</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>泛型能实现的功能通过接口+反射也基本能实现。但是使用过反射的人都知道反射机制有很多问题：</p><ol><li>用起来麻烦</li><li>失去了编译时的类型检查，不仔细写容易出错</li><li>性能不太理想</li></ol><h2 id="主流的泛型介绍"><a href="#主流的泛型介绍" class="headerlink" title="主流的泛型介绍"></a>主流的泛型介绍</h2><table><thead><tr><th>类型</th><th>实现原理</th><th>优点</th></tr></thead><tbody><tr><td>模板泛型</td><td>将代码中使用的每个类型编译成对应的类型的代码。</td><td>代码运行效率最高。</td></tr><tr><td>运行时泛型</td><td>编译时用占位符代替泛型参数，运行时由JIT编译成实际的类型。</td><td>编译时代码不膨胀，编译速度不受影响，经过JIT优化后性能几乎不受影响。</td></tr><tr><td>擦除泛型</td><td>编译时将类型擦除，统一转换为object或约束类。</td><td>实现简单。</td></tr><tr><td>动态语言泛型</td><td>依托编译器语法转换进行类型检查。</td><td>灵活，但具体性能和类型安全性取决于编译器。</td></tr></tbody></table><p>C#实现原理查看链接：SharpLab<br>JAVA实现原理链接：java泛型字节码</p><h2 id="Go泛型实现原理"><a href="#Go泛型实现原理" class="headerlink" title="Go泛型实现原理"></a>Go泛型实现原理</h2><p>go是基于模板的方案来实现泛型并做了改善</p><ol><li>为基础类型单独生成一份模板代码</li><li>非基础类型统一生成一个虚拟方法表，在运行时调用的时候通过虚拟方法表找到实际的类型</li></ol><h3 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h3><p>• 函数名后可以附带一个方括号，包含了该函数涉及的类型参数（Type Paramters）的列表：func F[T any](p T) { … }<br>• 这些类型参数可以在函数参数和函数体中（作为类型）被使用<br>• 自定义类型也可以有类型参数列表：type M[T any] []T<br>• 每个类型参数对应一个类型约束，上述的 any 就是预定义的匹配任意类型的约束<br>• 类型约束在语法上以 interface 的形式存在，在 interface 中嵌入类型 T 可以表示这个类型必须是 T:<br>• any\comparable\Ordered 约束类型</p><pre><code>type Integer interface &#123;    int ｜ int8 | int16 | int32 | int64&#125;type Integer1 interface &#123;    ~int ｜ ~int8&#125;</code></pre><h3 id="泛型反射"><a href="#泛型反射" class="headerlink" title="泛型反射"></a>泛型反射</h3><p>Go 1.18 版本并没有增加泛型相关的反射API，并且泛型是在编译期生成故推测Go不支持在运行时调用泛型方法&#x2F;函数. 这也是为什么Go方法不支持泛型原因之一</p><pre><code>func Test_Reflect3(t *testing.T) &#123;    myType := &amp;MyType[string]&#123;&quot;asd&quot;&#125;    mtV := reflect.ValueOf(&amp;myType).Elem()    params := make([]reflect.Value, 0)    params = append(params, reflect.ValueOf(&quot;OOOOOO&quot;))    mtV.MethodByName(&quot;Hello&quot;).Call(params)&#125;type MyType[T any] struct &#123;    name T&#125;func (mt *MyType[T]) Hello(show string) &#123;    println(mt.name, show)&#125;</code></pre><p>java 类型擦除式泛型，所以在运行是可通过反射插入不同类型的数据到泛型集合中</p><pre><code>List&lt;String&gt; strList=new ArrayList&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.add(&quot;sdadas&quot;);//但是通过反射方案可以实现插入数字    strList.add(123)</code></pre><p>C#是运行时泛型，所以反射时仍然可以做到类型检查</p><pre><code>var strList=new List&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.Add(&quot;sdadas&quot;);//反射插入数字时会报运行时错误    strList.add(123)//error</code></pre><h2 id="泛型运用"><a href="#泛型运用" class="headerlink" title="泛型运用"></a>泛型运用</h2><p>三元表达式</p><pre><code>func If[T any](flag bool, f1, f2 T) T &#123;    if flag &#123;        return f1    &#125;    return f2&#125;func IfFunc[T any](flag bool, f1, f2 func() T) T &#123;    if flag &#123;        return f1()    &#125;    return f2()&#125;//调用If(len(arr)&gt;0,arr[0],0)IfFunc(len(arr) &gt; 0 ,func()int64&#123;return arr[0]&#125;,0)</code></pre><p>泛型类型转换</p><pre><code>func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;//调用a := ToNumber[int](&quot;123&quot;)b := ToNumber[int64](&quot;123&quot;)c := ToNumber[float64](&quot;123&quot;)d := ToNumber[int32](&quot;123&quot;)</code></pre><p>linq 集合操作</p><pre><code>type Student struct &#123;    Id     int    Name   string    Age    int    Sex    bool    Score  int&#125;var list = []*Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;  </code></pre><p>a. 集合过滤</p><pre><code>//返回年龄大于19岁的学生res := linq.Where(list, func(s *Student) bool &#123; return s.Age &gt; 19 &#125;)    // Id: 3, Name: &quot;王五&quot;        </code></pre><p>b. 取第一个或者最后一个</p><pre><code>b := linq.First(list) //输出 1// 获取指定条件的第一个b = linq.First(list, func(s *Student) bool &#123; return s.Sex &#125;) //输出 1b = linq.Last(list) //输出 7 // 获取指定条件的最后一个b = linq.Last(list, func(s *Student) bool &#123; return s.Sex &#125;)</code></pre><p>   &#x2F;&#x2F;输出 3    </p><p> c. 去重</p><pre><code>//引用类型需要指定 去重的Key值   c := linq.Distinct(list, func(s *Student) int &#123; return s.Id &#125;)fmt.Println(c) //输出 1，2，3，4，5，6，7 //值类型可直接调用var list1 = []Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;d := linq.DistinctComparable(list1)fmt.Println(d) //输出 1，2，3，4，5，6，7     </code></pre><p>d. 投影成新对象</p><pre><code>//将学生数组转换为名称数组e := linq.Select(list, func(s *Student) string &#123; return s.Name &#125;)// 输出 [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,...]    </code></pre><p>e. 取前几条数据</p><pre><code>//取前几条数据f := linq.Take(list,3)fmt.Println(f)   </code></pre><p>f. 判断 元素，集合，条件 是否存在&#x2F;满足</p><pre><code>//判断是否存在分数大于99分的同学linq.Any(list, func(s *Student) bool &#123; return s.Score &gt; 99 &#125;) // falsevar arr = []int&#123;1,2,3,4,4,5&#125;linq.AnyComparable(arr, 8)//falselinq.AnyComparable(arr, 8,12,1)//true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 60 &#125;) //true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 70 &#125;) //falselinq.AnyComparable(arr,1) //判断所有元素都为1    </code></pre><p>g. 求和&#x2F;最大值&#x2F;最小值</p><pre><code> //分数汇总linq.Sum(list, func(s *Student) int &#123; return s.Score &#125;) // 654linq.Max(list, func(s *Student) int &#123; return s.Score &#125;) // Id: 6, Name: &quot;王芊&quot;linq.Min(list, func(s *Student) int &#123; return s.Score &#125;) //Id: 4, Name: &quot;赵六&quot;var arr1 = []int&#123;1, 2, 3, 4, 4, 5&#125;linq.SumOrdered(arr1) // 19linq.MaxOrdered(arr1) // 5linq.MinOrdered(arr1) // 1    </code></pre><p>h. 按照条件分组</p><pre><code>m := linq.GroupBy(list, func(s *Student) int &#123; return s.Age &#125;)// 单词出现频率统计var words = &quot;how do you do&quot;//var s = words.Split(&#39; &#39;).GroupBy(x =&gt; x).ToDictionary(x =&gt; x.Key, x =&gt; x.Count());var s5 = linq.ToComparableMap(strings.Split(words, &quot; &quot;),func(key string, es []string) int &#123; return len(es) &#125;)fmt.Println(s5)</code></pre><p>i. 链式操作，如果有集合的组合操作需求，可以先将切片转换为链式操作对象</p><pre><code>s1 := linq.AsEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort(func(s1, s2 string) bool &#123; return s1 &lt; s2 &#125;).    ToSlice()fmt.Println(s1)s2 := linq.AsComparableEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Distinct().    Take(3).    ToSlice()fmt.Println(s2)s3 := linq.AsOrderEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort().    Distinct().    Take(3).    ToSlice()fmt.Println(s3)s5 := linq.AsSelectEnumerable([]int&#123;1, 2, 3, 4, 5&#125;).    Where(func(v int) bool &#123; return v &gt; 3 &#125;).    Select(func(v int) string &#123; return &quot;mapping_&quot; + strconv.Itoa(v) &#125;).    Take(2).    ToSlice&lt;&gt;()fmt.Println(s5)</code></pre><p>实现泛型Set，泛型 LRU,泛型orm,泛型Redis返回</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>方法不支持泛型</p><pre><code>type A[T any] struct &#123;&#125;//编译通过func (a A[T]) SelectString() string &#123;    return &quot;&quot;&#125;//编译不通过func (a A[T]) Select2[E any]() E &#123;    retrun nil&#125;type Foo struct &#123;&#125;​//编译不通过func (Foo) bar[T any](t T) &#123;&#125;</code></pre><p>Go没有提供在编译期操作类型的能力,只能在运行时操作</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;</code></pre><p>类型转换，不支持转换为带类型约束的interface</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;        K, _ := v.(int)  //编译通过    g, _ := v.(Number) //编译不通过</code></pre><p>更加智能类型推导，函数lamda化</p><pre><code>f(x) = ax + by = f(x)joinCorpIds := linq.Select(newUserInfos, func(s *wps.NewUserInfo) int64 &#123; return s.CompanyId &#125;)joinCorpIds := linq.Select(newUserInfos, s = &gt; s.CompanyId)joinCorpIds = newUserInfos.Select(s = &gt; s.CompanyId)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go泛型运用&quot;&gt;&lt;a href=&quot;#Go泛型运用&quot; class=&quot;headerlink&quot; title=&quot;Go泛型运用&quot;&gt;&lt;/a&gt;Go泛型运用&lt;/h1&gt;&lt;h2 id=&quot;泛型起源&quot;&gt;&lt;a href=&quot;#泛型起源&quot; class=&quot;headerlink&quot; title=&quot;泛</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/p/f255ffad.html"/>
    <id>http://example.com/p/f255ffad.html</id>
    <published>2023-08-11T07:52:53.993Z</published>
    <updated>2023-08-11T08:35:27.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>• docker是什么<br>docker是用GO开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。<br>Docker 容器是</p><ul><li>利用Linux Namespace做资源隔离，</li><li>Cgroup做资源上限限制，</li><li>rootfs做文件系统 </li><li>运行在宿主机上面的一个特殊进程。</li></ul><p>• 为什么使用docker<br>利用docker可以将项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在宿主机创建一个容器，让镜像在容器内运行，从而实现项目的部署。<br>项目可以是mysql、nginx、nodejs、redis等，从而可以在一台宿主机上快速搭建相互隔离的不同的环境。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>镜像（image)、容器(container)、仓库（repository)<br>举个例子，电脑安装操作系统，称其为镜像，镜像是一个固定的文件，这次读盘和下次读盘内容是一样的。<br>把这个镜像安装到电脑上，再在这个电脑上删删改改，再重新打包一个镜像刻盘，固化出一个镜像来，这就是镜像打包，<br>如国内以前泛滥的盗版XP系统，从微软官方镜像出发，添加小工具，系统设置修改优化，加主题，造出番茄花园，雨林木风，深度之类的盗版安装碟。<br>镜像装到电脑后，这个电脑就是个容器，里面包含使用者的数据和设置。</p><p>• 镜像<br>镜像可以看成是由多个镜像层叠加起来的一个文件系统；<br>镜像层的主要组成部分包括镜像层 ID、镜像层指针 「指向父层」、元数据；<br>镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层。统一文件系统（ AUFS）能够将不同的层整合成一个文件系统。</p><p>• 容器<br>容器的定义和镜像几乎一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br>要点：容器 &#x3D; 镜像 + 读写层</p><p>• 仓库<br>顾名思义，docker仓库是用来存储镜像的，理解时，可以参考git仓库。</p><p>Docker环境安装，以安装docker-ce为例</p><ol><li>Linux安装<br>1）下载阿里的源<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br>sudo yum makecache<br>sudo yum install docker-ce2）docker启动<br>systemctl start docker.service</li><li>Windows安装<br><a href="https://www.runoob.com/docker/windows-docker-install.html">https://www.runoob.com/docker/windows-docker-install.html</a><br>下载Docker Desktop<br>启用Hyper-V(win10)<br>安装Docker Desttop</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>搜索镜像</li></ol><p>docker search xxx</p><ol><li>拉取镜像</li></ol><p>docker pull xxx</p><ol start="3"><li>查看镜像</li></ol><p>docker images</p><ol start="4"><li>运行镜像</li></ol><p>docker run<br>    -p 暴露端口:容器端口         #端口<br>    -v 本地路径:容器内路径       #挂在本地路径<br>    -e 环境变量&#x3D;value           #指定环境变量<br>    –add-host 域名:IP        # 绑定域名    -p 暴露端口：容器端口<br>    -v 本地路径：容器内路径<br>    -e 环境变量&#x3D;value</p><ol start="5"><li><p>查看运行中的容器</p><p> docker ps</p></li><li><p>容器启动、停止、重启</p><p> docker container start | stop | restart [containername]</p></li></ol><h2 id="启动一个nginx服务器"><a href="#启动一个nginx服务器" class="headerlink" title="启动一个nginx服务器"></a>启动一个nginx服务器</h2><pre><code># 检索nginx镜像docker search nginx --limit 5# 拉取镜像docker pull nginx:stable#采用默认配置启动一个服务器docker run -p 9080:80 --name my-nginx nginx:stable#采用自定义配置，并挂载外部目录docker run -d -p 9081:81 -v /home/luanhongjun/temp1/demo/nginx/conf.d:/etc/nginx/conf.d -v /home/luanhongjun/temp1/demo/nginx/html:/usr/share/nginx/html --name my-nginx nginx:stable</code></pre><h2 id="自定义打包镜像"><a href="#自定义打包镜像" class="headerlink" title="自定义打包镜像"></a>自定义打包镜像</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code>FROM khub.wps.cn/sreopen/node:14.2.0ADD ./ /opt/zhiliaoWORKDIR /opt/zhiliaoRUN npm installRUN npm run build:pcRUN npm run build:mobileFROM khub.wps.cn/sreopen/nginx:1.18.0COPY --from=0 /opt/zhiliao/dist/ /var/www/zhiliao/COPY --from=0 /opt/zhiliao/m-dist/ /var/www/m-zhiliao/COPY --from=0 /opt/zhiliao/nginx/nginx.conf /etc/nginx/RUN nginxCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><p>FROM：指定基础镜像<br>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。<br>WORKDIR： 指定工作目录<br>RUN：构建镜像时运行的命令<br>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源<br>CMD：构建容器后调用，也就是在容器启动时才进行调用。</p><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p><h3 id="Docker镜像瘦身技巧："><a href="#Docker镜像瘦身技巧：" class="headerlink" title="Docker镜像瘦身技巧："></a>Docker镜像瘦身技巧：</h3><p>善用 &amp;&amp;<br>优化前</p><pre><code>RUN npm installRUN npm run build:pcRUN npm run build:mobile</code></pre><p>优化后</p><pre><code>RUN /bin/bash -c &#39;npm install &amp;&amp; npm run build:pc &amp;&amp; npm run build:mobile&#39;</code></pre><p>使用多阶段构建</p><p>选择Alpine&#x2F;Distroless基础镜像<br>Alpine Linux是一个基于musl libc和busybox、面向安全的轻量级Linux发行版。它更小、更安全。</p><pre><code>FROM khub.wps.cn/zl-open/golang-base:1.14.2 AS build-linkADD wps-zhiliao-backend-mics-known-link /opt/kingsoft/src/wps.cn/drive/linkADD wps-zhiliao-backend-mics-known-lib /opt/kingsoft/src/wps.cn/drive/libADD wps-zhiliao-backend-lib /opt/kingsoft/src/wps.cn/libADD kgo-kms /opt/kingsoft/src/ksogit.kingsoft.net/kgo/kmsADD openksa-cksdk  /opt/kingsoft/src/wps.cn/cksdkADD kgo-i18n /opt/kingsoft/src/wps.cn/drive/i18nWORKDIR /opt/kingsoft/src/wps.cn/drive/linkENV GOPATH=/opt/kingsoft/:/opt/kingsoft/src/wps.cn/lib/Godeps/_workspaceENV CGO_ENABLED=0RUN go build -v -o /opt/kingsoft/src/wps.cn/drive/link/bin/main /opt/kingsoft/src/wps.cn/drive/link/main.goFROM khub.wps.cn/sreopen/sre-base:pyjinja-supervisor-alpine AS run-linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/bin/main /usr/local/bin/linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/i18n /opt/apps/link/i18n/COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/etc/link.kae.toml.j2 /etc/link.kae.toml.j2COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/kae_start.sh /usr/local/bin/kae_start.sh#EXPOSE 8080RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39; /etc/apk/repositories \    &amp;&amp; apk add --no-cache tzdata \    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \    &amp;&amp; chmod +x /usr/local/bin/kae_start.shCMD [&quot;kae_start.sh&quot;]</code></pre><p>打包</p><p>docker build . -t xxx:yy</p><h2 id="docker-compose的使用"><a href="#docker-compose的使用" class="headerlink" title="docker-compose的使用"></a>docker-compose的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。<br>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。<br>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）<br>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>方式一：下载适应版本的compose</p><pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose</code></pre><p>方式二：</p><pre><code>安装python-pippip install docker-compose</code></pre><h3 id="docker-compose-yml简介"><a href="#docker-compose-yml简介" class="headerlink" title="docker-compose.yml简介"></a>docker-compose.yml简介</h3><p>标准配置文件应该包含version、services、networks三部分:<br>version:  定义了版本信息<br>services: 定义了服务的配置信息，包含应用于该服务启动的每个容器的配置<br>networks: 定义了网络信息，提供给 services 中的 具体容器使用</p><p>实例</p><pre><code>version: &#39;3.2&#39;services:#Nginxnginx_lb:    restart: always    image: nginx:1.11.6-alpine    ports:    - 28080:80    - 80:80    - 443:443    volumes:    - /opt/kingsoft/containers/nginx/conf.d:/etc/nginx/conf.d    - /opt/kingsoft/containers/nginx/log:/var/log/nginx    - /opt/kingsoft/containers/nginx/www:/var/www    - /opt/kingsoft/containers/nginx/zhiliao-management-system:/var/zhiliao-management-system    - /opt/kingsoft/containers/nginx/ssl:/etc/nginx/ssl    extra_hosts:    - &quot;msgcenter.wps.cn:120.92.124.158&quot;    stdin_open: true    tty: true# Redis cluster#redis_db:#  image: grokzen/redis-cluster:5.0.12#  environment:#    TZ: &quot;Asia/Shanghai&quot;#  volumes:#    - /opt/kingsoft:/opt/kingsoft#  # docker network bridge mode#  networks:#      vpcbr:#      ipv4_address: 172.16.0.50#  ports:#    - &quot;7000:7000&quot;  # MySQL DBmysql_db:    image: percona:5.6    environment:    MYSQL_ROOT_PASSWORD: xxxx    TZ: &quot;Asia/Shanghai&quot;    volumes:    - /opt/kingsoft/containers/mysql/conf:/etc/mysql/conf.d    - /opt/kingsoft/containers/mysql/data:/var/lib/mysql    - /opt/kingsoft:/opt/kingsoft    ports:    - &quot;3306:3306&quot;    networks:    vpcbr:        ipv4_address: 172.16.0.51zoo1:    image: wurstmeister/zookeeper    ports:    - &quot;2181:2181&quot;    networks:    vpcbr:        ipv4_address: 172.16.0.56# kafka version: 1.1.0# scala version: 2.12kafka:    image: wurstmeister/kafka    ports:    - &quot;9092:9092&quot;    environment:    KAFKA_ADVERTISED_HOST_NAME: kafka    KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181&quot;    KAFKA_BROKER_ID: 1    KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1    KAFKA_CREATE_TOPICS: &quot;drive_fsys_fop:1:1&quot;    depends_on:    - zoo1    networks:    vpcbr:        ipv4_address: 172.16.0.57networks:vpcbr:    driver: bridge    ipam:    config:    - subnet: 172.16.0.0/16                                        </code></pre><h3 id="结合KAE使用"><a href="#结合KAE使用" class="headerlink" title="结合KAE使用"></a>结合KAE使用</h3><pre><code>绑定120.92.124.158 khub.wps.cndocker tag xximage:xxtagdocker login khub.wps.cndocker push khub.wps.cn/zl-open/golang-base:1.14.2</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>如何从一个容器做一个镜像</p><p> docker commit命令创建镜像<br> docker commit xxxcontaineridd imagename:tag</p></li><li><p>docker logs 能否输出nginx的access.log</p></li></ol><p>docker logs xxx 只能输出容器内程序输出到终端（stdout|stderr）的日志。无法输出写入到文件中的日志。所以不能直接输出nginx的access.log<br>当然，如果使用一些hook程序，将access.log内的日志实时输出到终端，可以通过docker logs看到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>mod</title>
    <link href="http://example.com/p/17f45348.html"/>
    <id>http://example.com/p/17f45348.html</id>
    <published>2023-08-11T07:44:27.341Z</published>
    <updated>2023-08-11T08:35:27.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h1><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>go 1.11 (2018-08-24)开始支持gomod的方式去管理包的依赖<br>具体的发行说明参考官方链接：<a href="https://go.dev/doc/go1.11">https://go.dev/doc/go1.11</a> [所有版本的发行说明：<a href="https://go.dev/doc/devel/release]">https://go.dev/doc/devel/release]</a></p><p>Q: GOPATH方式存在的问题？<br>A今天go get pkg1 commit了提交，第二天pkg1更新了，B去clone A的项目执行go get pkg1，此时pkg1变化了<br>同一个包，不同项目无法引用不同版本<br>vendor目录，git上传整份代码，git库体积过大，升级包时，文件太多，MR review不友好</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="GO111MODULE变量"><a href="#GO111MODULE变量" class="headerlink" title="GO111MODULE变量"></a>GO111MODULE变量</h3><p>go1.16 GO111MODULE默认值是on，并且增加了retract功能（版本撤回）</p><h2 id="go-mod常用操作命令"><a href="#go-mod常用操作命令" class="headerlink" title="go mod常用操作命令"></a>go mod常用操作命令</h2><p>用go mod初始化一个新项目</p><pre><code>mkdir democd demogo mod init demogo: creating new go.mod: module demo</code></pre><p>添加一个依赖包</p><pre><code>// 根据commit id添加依赖包的方式go get github.com/golang/groupcache@41bb18b</code></pre><p>此时，go.mod里会记录好依赖包，和对应的版本名</p><p>go.mod里出现的关键字<br>• module - go mod init指令定义的库名<br>• go - 要求go语言的最低版本，会影响到后面依赖库的下载<br>• require - 必备库，也就是代码中直接import的部分<br>• indirect：间接依赖，即A -&gt; B -&gt; C时，A就是间接依赖C了<br>• replace - 替换库，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）<br>• retract 撤回版本，告诉调用本库的项目，部分版本有严重问题、不要引用</p><p>根据go.mod下载依赖包</p><pre><code>go mod download</code></pre><p>清理下载好的go pkg缓存</p><pre><code>go clean -modcache</code></pre><p>清理go.mod不在使用的依赖</p><pre><code>go mod tidy</code></pre><p>将gomod项目依赖包存放到vendor目录，以便在离线环境下使用GOPATH方式编译</p><pre><code>go mod vendor</code></pre><p>查看一个包是怎么被引用的</p><pre><code>go mod why $&#123;pkg&#125;</code></pre><p>替换一个包</p><pre><code>go mod edit -replace wps.cn/lib=ksogit.kingsoft.net/wps-zhiliao/backend/lib.git@v0.0.2-prep</code></pre><h2 id="go-mod版本格式"><a href="#go-mod版本格式" class="headerlink" title="go mod版本格式"></a>go mod版本格式</h2><p><a href="https://go.dev/doc/modules/version-numbers">https://go.dev/doc/modules/version-numbers</a><br><a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>  译文</p><p>格式：</p><ul><li><p>第一种：v${大版本}.${功能版本}.${fix版本}。例如：v1.0.0</p></li><li><p>第二种：v${大版本}.${功能版本}.${fix版本}-${预发行版本}。例如：v1.0.0-rc.1，v1.0.0-pre，v8.0.0-alpha.0，v1.0.0-分支名.${整型序号}【目前采用】</p></li><li><p>第三种：v0.0.0-yyyyMMddHHmmss-${commitId}<br>然后我们要给对应的稳定代码版本打上tag，项目go get时，可以指定对应的版本。同时打tag的好处可以针对引用库的改动做发行说明，留底方便作兼容性记录，为后续问题排查提供依据。<br>大版本号可以用来做重构以确保一个项目里，可以同时存在v1,v2这种情况的引用链。</p><p>  main<br>  pkgA<br>  pkgX@v1<br>  pkgB<br>  pkgX@v2</p></li></ul><p>这样保证了，pkgA,pkgB可以同时存在，pkgX做了大版本升级，可能有功能是废弃的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mod&quot;&gt;&lt;a href=&quot;#mod&quot; class=&quot;headerlink&quot; title=&quot;mod&quot;&gt;&lt;/a&gt;mod&lt;/h1&gt;&lt;h2 id=&quot;发展历程&quot;&gt;&lt;a href=&quot;#发展历程&quot; class=&quot;headerlink&quot; title=&quot;发展历程&quot;&gt;&lt;/a&gt;发展历</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>goroutine</title>
    <link href="http://example.com/p/15a4d7c.html"/>
    <id>http://example.com/p/15a4d7c.html</id>
    <published>2023-08-11T07:25:22.237Z</published>
    <updated>2023-08-11T08:35:27.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="goroutine是什么？"><a href="#goroutine是什么？" class="headerlink" title="goroutine是什么？"></a>goroutine是什么？</h2><p>官方的给出的定义是一个并发逻辑块，我们可以用一个函数和一个关键字创建它。</p><pre><code>// 非匿名func main() &#123;    go sayHello()    // continue doing other things&#125;func sayHello() &#123;    fmt.Println(&quot;hello&quot;)&#125;// 匿名go func() &#123;    fmt.Println(&quot;hello&quot;)&#125;()// 1// continue doing other things</code></pre><p>从go的整体运行框架中可以看出goroutine并不属于一个操作系统线程，也不属于go语言运行时管理的线程，它在go语言执行框架之内是线程的高级抽象——协程。<br>协程是非抢占式的并发子程序，换句话说，无法被中断。<br>协程拥有自身的资源同时共享线程的资源。<br>协程自身无法独立运行必须依托于线程。</p><p>go通过一个M:N调度器实现运行，也就是go的一个核心思想线程复用。</p><h2 id="goroutine的闭包"><a href="#goroutine的闭包" class="headerlink" title="goroutine的闭包"></a>goroutine的闭包</h2><p>一般会在main函数中暂停几秒来使得goroutine得以运行。</p><pre><code>sayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;go sayHello()time.Sleep(time.Second)</code></pre><p>这是因为goroutine是独立于main的一个协程，而goroutine的运行管理是交给go的runtime来负责的，我们无法得知goroutine何时会运行，通过暂停几秒钟本质是并不是给与goroutine启动的时间，而是提高runtime调用goroutine的机会，这种方式并不能保证goroutine一定会启动。<br>如果想要确保goroutine一定会启动，需要在main和goroutine之间建立一种同步机制，保证在main的执行过程中一定会等待goroutine的调用完成。</p><pre><code>var wg sync.WaitGroupsayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;wg.Add(1)go sayHello()wg.Wait() //1</code></pre><p>goroutine拥有独立的资源空间，来满足其运行时需要的全部条件，也正是利用了这种机制go才可以实现线程这种珍贵资源的复用，但是在某些情况下，我们需要在一个goroutine调用另一个goroutine的资源，而goroutine之间都是独立运行的，如何确保资源的安全性。</p><pre><code>var wg sync.WaitGroupsalutation := &quot;hello&quot;wg.Add(1)go func() &#123;    defer wg.Done()    salutation = &quot;welcome&quot; // 1&#125;()wg.Wait()fmt.Println(salutation)</code></pre><p>上面的例子在实际的运行过程中不会出现hello被打印的情况，原因在于goroutine对main的资源进行了访问并修改。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func() &#123;        defer wg.Done()        fmt.Println(salutation) // 1    &#125;()&#125;wg.Wait()</code></pre><p>这种情况下goroutine会输出什么？<br>答案是3个good day。很奇怪不是吗？</p><p>是什么原因导致这个奇怪的现象出现？<br>我们回顾goroutine的定义，一个并发逻辑块，我们并不知道它会何时运行，在上面的例子中我们通过同步机制，确保了在main运行的期间goroutine一定会启动运行，但是仍然无法确保goroutine何时运行。<br>那么问题就迎刃而解了，for循环的执行在goroutine运行之前执行完，go为通过代码检查将salutation转移到堆中，并保存对字符串切片“good day”中最后一个值的引用。</p><p>通过上面的两个例子可以看出，因为goroutine具有独立逻辑，当一个goroutine访问另一个goroutine的资源时，是极度不安全的，资源不确定性无限放大。</p><p>如何正确的访问goroutine资源呢，确保安全性？<br>答案很简单：闭包。<br>闭包这个词用人话说就是将资源复制一份给goroutine，使得goroutine不用访问另一个goroutine的资源，实现资源的封闭。<br>再通俗一点就是，给你一份，你用你的，我用我的。<br>在程序的执行方式就是传递参数。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func(salutation string) &#123; // 1        defer wg.Done()        fmt.Println(salutation)    &#125;(salutation) // 2&#125;wg.Wait()</code></pre><p>不过需要注意go的传递是值传递，并且包含指针，闭包的概念对于指针类型的对象来说没用。</p><h2 id="goroutine的大小"><a href="#goroutine的大小" class="headerlink" title="goroutine的大小"></a>goroutine的大小</h2><p>goroutine在官方中还有一个一直被人津津乐道的一个地方，轻巧，占用空间很小，大约几KB</p><pre><code>memConsumed := func() uint64 &#123;    runtime.GC()    var s runtime.MemStats    runtime.ReadMemStats(&amp;s)    return s.Sys&#125;var c &lt;-chan interface&#123;&#125;var wg sync.WaitGroupnoop := func() &#123; wg.Done(); &lt;-c &#125; // 1const numGoroutines = 1e4 // 2wg.Add(numGoroutines)before := memConsumed() // 3for i := numGoroutines; i &gt; 0; i-- &#123;    go noop()&#125;wg.Wait()after := memConsumed() // 4fmt.Printf(&quot;%.3fkb&quot;, float64(after-before)/numGoroutines/1000)</code></pre><p>9.291kb<br>PASS</p><p>测试一下上下文切换</p><p>func BenchmarkContextSwitch(b *testing.B) {<br>    var wg sync.WaitGroup<br>    begin :&#x3D; make(chan struct{})<br>    c :&#x3D; make(chan struct{})</p><pre><code>var token struct&#123;&#125;sender := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        c &lt;- token //2    &#125;&#125;receiver := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        &lt;-c //3    &#125;&#125;wg.Add(2)go sender()go receiver()b.StartTimer() //4close(begin)   //5wg.Wait()</code></pre><p>}</p><p>结果如下：</p><pre><code>goos: windowsgoarch: amd64pkg: concurrency_mode/pipelinecpu: Intel(R) Core(TM) i5-10500 CPU @ 3.10GHzBenchmarkContextSwitch-12         4074472           293.5 ns/opPASS</code></pre><h2 id="goroutine的内存泄露"><a href="#goroutine的内存泄露" class="headerlink" title="goroutine的内存泄露"></a>goroutine的内存泄露</h2><p>goroutine虽然很牛逼，但是作为独立的线程如果不进行恰当的控制，会面对很严重泄露问题</p><p>goroutine的内存泄露一般由于程序不能正常结束所导致<br>• 死循环<br>• 阻塞等待</p><p>死循环</p><pre><code>go func() &#123;// &lt;操作会在这里永久阻塞&gt;    for&#123;    &#125;&#125;()// Do work</code></pre><p>破除死循环的最好方式就是告诉goroutine如何结束<br>• 定义退出逻辑<br>• 信号通知</p><p>阻塞等待<br>阻塞等待的情况有两种<br>go的经典语句“不要通过共享内存来通信，而应该通过通信来共享内存”<br>正因为如此<br>通道被广泛使用到各种场景，而通道阻塞是goroutine内存泄漏面临的一个大问题</p><p>通道分为进和出<br>当通道无法出时会进入阻塞状态，需要等待通道进数据</p><pre><code>doWork := func(strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123;    completed := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(completed)        for s := range strings &#123;            fmt.Println(s)        &#125;    &#125;()    return completed&#125;doWork(nil)// 这里还有其他任务执行fmt.Println(&quot;Done.&quot;)</code></pre><p>结果</p><pre><code>Done.PASS</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>doWork := func(done &lt;-chan interface&#123;&#125;, strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123; //1    terminated := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(terminated)        for &#123;            select &#123;            case s := &lt;-strings:                // Do something interesting                fmt.Println(s)            case &lt;-done: //2                return            &#125;        &#125;    &#125;()    return terminated&#125;done := make(chan interface&#123;&#125;)terminated := doWork(done, nil)go func() &#123; //3    // Cancel the operation after 1 second.    time.Sleep(1 * time.Second)    fmt.Println(&quot;Canceling doWork goroutine...&quot;)    close(done)&#125;()&lt;-terminated //4fmt.Println(&quot;Done.&quot;)</code></pre><p>结果如下：</p><pre><code>Canceling doWork goroutine...doWork exited.Done.PASS</code></pre><p>当通道无法进时会进入阻塞状态，需要等待通道出数据</p><pre><code>newRandStream := func() &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;) // 1        defer close(randStream)        for &#123;            randStream &lt;- rand.Int()        &#125;    &#125;()    return randStream&#125;randStream := newRandStream()fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;</code></pre><p>结果如下：</p><pre><code>3 random ints:1: 86597149668366241682: 35918201309525418263: 2839916754701944393</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>newRandStream := func(done &lt;-chan interface&#123;&#125;) &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;)        defer close(randStream)        for &#123;            select &#123;            case randStream &lt;- rand.Int():            case &lt;-done:                return            &#125;        &#125;    &#125;()    return randStream&#125;done := make(chan interface&#123;&#125;)randStream := newRandStream(done)fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;close(done)//模拟正在进行的工作time.Sleep(1 * time.Second)</code></pre><p>这样就可以了</p><pre><code>3 random ints:1: 83955671426514482052: 84217454730047417783: 7407000177342364812newRandStream closure exited.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a href=&quot;#goroutine&quot; class=&quot;headerlink&quot; title=&quot;goroutine&quot;&gt;&lt;/a&gt;goroutine&lt;/h1&gt;&lt;h2 id=&quot;goroutine是什么？&quot;&gt;&lt;a href=&quot;#goroutine是什么</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>git工作流</title>
    <link href="http://example.com/p/7653a710.html"/>
    <id>http://example.com/p/7653a710.html</id>
    <published>2023-08-11T07:15:20.702Z</published>
    <updated>2023-08-11T07:20:04.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h1><p>原文链接：<a href="https://juejin.cn/post/7202952940196708410">https://juejin.cn/post/7202952940196708410</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git 是目前最流行的代码管理工具，团队一般为了规范开发，保持良好的代码提交记录以及维护 Git 分支结构清晰，方便后续维护等，都会定制一套团队内部比较规范的 Git 工作流。本期主要介绍最为常见和流行的三种Git分支工作流。<br>Git工作流与我们常用的add、commit、push等命令有区别，但它们之间是相互关联的。Git工作流定义了一个开发过程的整体架构和规范，而add、commit、push等命令则是在具体操作层面上实现Git工作流的基本操作。在具体使用Git时，你可以根据所采用的工作流选择合适的命令和操作来管理代码版本和进行团队协作。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>GitFlow 是最早诞生，并且得到广泛应用的一种工作流程。GitFlow 通常包含五种类型的分支，分别为master、develop、feature、release、hotfix。<br>• master：主干分支，也是正式发布版本的分支，每次发布版本都需要打上相应的 tag，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许直接向 master 分支直接提交代码 (master 对应着生产环境)。<br>• develop：开发分支，在开发初期，由团队负责人从 master 签出，用来集成测试最新合入的开发成果，包含要发布到下一个 Release 的代码（对应开发环境）。<br>• feature：特性分支，通常从 Develop 分支签出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将 Feature 分支的代码合并至 Develop 分支，进入下一个Release 环节。<br>• release：预发布分支，发布新版本时，基于 Develop 分支创建，发布完成后，需要将此分支合并到 Master 和 Develop 分支（对应集成测试环境）。<br>• hotfix：热修复分支，生产环境发现新 Bug 时创建的临时分支，问题验证通过后，合并到 Master 和 Develop 分支。<br>develop分支包含项目完整的历史记录，而master分支将包含简化版本。团队成员在克隆中央存储库后，应基于develop创建跟踪分支，进行新功能开发。</p><p>GitFlow的优点和缺点？<br>• 优点：流程清晰可控。<br>• 缺点：管理相对复杂，需要同时维护两个长期分支。同时不适合持续发布，目标产物通常是一段时间后产出一个新版本，是基于版本发布。</p><h3 id="开发分支（Develop）"><a href="#开发分支（Develop）" class="headerlink" title="开发分支（Develop）"></a>开发分支（Develop）</h3><p>Develop 分支由团队负责人从 Master 创建。首次创建时，由团队负责人构建项目结构，推送至远端。通常在该分支上进行新特性的合并、签出予发布分支、合并hotfix分支等操作。</p><h3 id="特性分支（Feature）"><a href="#特性分支（Feature）" class="headerlink" title="特性分支（Feature）"></a>特性分支（Feature）</h3><p>新特性分支基于 Develop 分支创建，每个新功能都应该驻留在其自己的分支中，我们可以将其推送到中央存储库进行协作或者备份。<br>在新功能开发完成后，需要将其合并到 Develop 分支中，同时删除本地与远端的feature分支。<br>预发布分支（Release）<br>一旦 Develop 分支获得了足够的发布功能，或者临近预定的发布日期，就需要基于 Develop 分支创建</p><h3 id="Release-分支。"><a href="#Release-分支。" class="headerlink" title="Release 分支。"></a>Release 分支。</h3><p>创建此分支意味着将开始下一个发行周期，此刻 Release 分支不能添加任何新功能（除了错误修复、文档完善等），一旦准备发布，Release 分支将合并到 Master 分支并用版本号标记。另外，还要将其合并回 Develop 分支。待发版成功后，删除 Release 分支。<br>使用专门的分支进行版本发布可以让我们在新版本发布的同时，其他团队成员可以继续为下个版本开发新功能，而不影响此次发布。</p><h3 id="补丁分支（hotfix）"><a href="#补丁分支（hotfix）" class="headerlink" title="补丁分支（hotfix）"></a>补丁分支（hotfix）</h3><p>维护 hotfix 分支用于快速修补生产版本出现的 bug。hotfix 分支是唯一一个从 Master 分支上创建的分支。<br>待修复程序完成后，应该将其合并到 Master 和 Develop 或者当前 Release 分支中，随后删除 hotfix 分支，并应使用更新的版本号标记 Master 分支。<br>拥用有专门的错误修复分支，可以保障团队可以在不中断其余工作流程的情况下，对线上的版本进行错误修复。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>GitHub flow 是 Git Flow 的简化版，它是 github.com 使用的工作流程。它只有一个长期分支(master)，相对于 GitFlow 用起来相对比较简单。GitHubFlow 假设每次合并一个特性分支时都可以部署到生产环境，虽然这在某些情况下是不可能的。<br>它只有一个长期分支master：<br>• 第一步：根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。<br>• 第二步：新分支开发完成后，或者需要讨论的时候，就像 master 分支发起一个pull request(简称PR)。<br>• 第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码，对话过程中，你还可以不断提交代码。<br>• 第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。<br>GitHub Flow的优点和缺点？<br>• 优点：非常适合持续发布的产品，使用流程简单，仅有一个主干分支。Master 分支的最新代码，默认就是线上代码。<br>• 缺点：master 既包含生产环境，又包含开发环境，比较混乱。有些时候，代码合并进入 Master 分支，并不代表就能立刻发布，你不能控制发布的时间。例如，iOS 应用程序通过App Store验证后才发布。这是，如果后面还有新的代码合并到 Master，导致与刚刚发布的版本不一致。在这些情况下，需要额外创建一个 production 分支跟踪线上版本。如果想要查看生产环境代码，可切换至生产分支。</p><h2 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h2><p>Gitlab Flow 是 Git Flow 与 Github Flow 的结合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一分支的简单和便利，是 gitlab.com 推荐的做法。</p><h3 id="上游优先"><a href="#上游优先" class="headerlink" title="上游优先"></a>上游优先</h3><p>Gitlab Flow 的最大原则叫做“上游优先”，指存在一个主分支，他是所有其他分支的上游，只有上游分支采纳的代码变化，才能应用到其他分支。</p><h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>对于持续发布的项目，建议在 Master 之外，创建不同环境的分支，比如开发环境是 Master，预发布分支是pre-production，生产环境是production。<br>开发分支是语发布分支的上游，予发布分支是生产分支的上游。代码变化，必须由上游向下游发展。</p><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对于版本发布的项目，建议的做法是每一个稳定的版本，都要从 Master 分支上拉出一个分支，比如1.0.3-stable等等。<br>发布版本后，只有向该分支添加严重的错误修复，首先将错误修复合并到 Master 分支，然后将其合并到 stable 分支，并且此时要更新小版本号码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git工作流&quot;&gt;&lt;a href=&quot;#git工作流&quot; class=&quot;headerlink&quot; title=&quot;git工作流&quot;&gt;&lt;/a&gt;git工作流&lt;/h1&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://juejin.cn/post/72029529401967084</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-08-10T15:17:59.149Z</published>
    <updated>2023-08-11T07:20:04.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p>给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。</p><p>输入输出<br>输入</p><p>“this is a sentence”</p><p>输出</p><p>sentence a is this</p><p>首先，题目要求把每个单词倒过来，同时联想到栈有先进先出的特点。如果我们把单词作为一个整体按顺序入栈，然后再全部出栈，这时得到的就是反转后的句子了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    stack&lt;string&gt; wordStack;    int len = str.size();    string temp=&quot;&quot;;    for (int i = 0; i &lt; len; i++) &#123;        if (str[i] != &#39; &#39;) &#123;            temp += str[i];        &#125;        else &#123;            wordStack.push(temp);            temp.clear();        &#125;    &#125;    wordStack.push(temp);    string tempword;    while (!wordStack.empty())    &#123;        tempword = wordStack.top();        wordStack.pop();        if (!wordStack.empty()) &#123;            cout &lt;&lt; tempword &lt;&lt; &#39; &#39;;        &#125;        else        &#123;            cout &lt;&lt; tempword;        &#125;    &#125;    return 0;&#125;</code></pre><p>在整个字符串反转后，可以看到单词的相对位置就已经反转过来了，但是对于每个单词依然内部字母是反转的，因此考虑是否有方法将每个单词进行反转，这样单词字母的顺序就变过来了。</p><p>没错，把每个单词作为一个独立的字符串进行反转就可以了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;void reverseStr(string&amp; str, int beg, int end) &#123;    while (beg &lt; end) &#123;        swap(str[beg++], str[end--]);    &#125;&#125;int main() &#123;    string str;    getline(cin, str);    reverseStr(str, 0, str.size() - 1);    int begin=0, end=0;    for (int i = 0; i &lt; str.size(); i++) &#123;        if (str[i] != &#39; &#39;) &#123;            end=i;        &#125;        else &#123;            reverseStr(str, begin, end);            begin = end + 2;        &#125;    &#125;    reverseStr(str, begin, end);    cout &lt;&lt; str;    return 0;&#125;</code></pre><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><p>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出: 4</p><p>原文的分析是：</p><p>注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）</p><p>if nums[0] &lt;&#x3D; nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;&#x3D; target &lt;&#x3D; nums[i]时我们应该在 0 - i 范围内查找；<br>if nums[i] &lt; nums[0] 那么在 0 - i 区间的某个点处发生了下降（旋转），那么 I + 1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当 target 不属于 nums[0] 到 nums[i] 时（target &lt;&#x3D; nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;&#x3D; target），我们应该在 0 - i 区间内查找。<br>上述三种情况可以总结如下：</p><pre><code>nums[0] &lt;= target &lt;= nums[i]           target &lt;= nums[i] &lt; nums[0]                     nums[i] &lt; nums[0] &lt;= target</code></pre><p>所以我们进行三项判断：</p><p>(nums[0] &lt;&#x3D; target)， (target &lt;&#x3D; nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））</p><p>所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。</p><p>使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）</p><p>之后我们通过二分查找不断做小 target 可能位于的区间直到 low&#x3D;&#x3D;high，此时如果 nums[low]&#x3D;&#x3D;target 则找到了，如果不等则说明该数组里没有此项。</p><p>class Solution {<br>public:<br>    int search(vector<int>&amp; nums, int target) {<br>        int lo &#x3D; 0, hi &#x3D; nums.size() - 1;<br>        while (lo &lt; hi) {<br>            int mid &#x3D; (lo + hi) &#x2F; 2;<br>            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))<br>                lo &#x3D; mid + 1;<br>            else<br>                hi &#x3D; mid;<br>        }<br>        return lo &#x3D;&#x3D; hi &amp;&amp; nums[lo] &#x3D;&#x3D; target ? lo : -1;<br>    }<br>};</int></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;反转单词&quot;&gt;&lt;a href=&quot;#反转单词&quot; class=&quot;headerlink&quot; title=&quot;反转单词&quot;&gt;&lt;/a&gt;反转单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。&lt;/p&gt;
&lt;p&gt;输入输出&lt;br&gt;输入&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/p/b7e144d1.html"/>
    <id>http://example.com/p/b7e144d1.html</id>
    <published>2023-08-07T14:57:09.536Z</published>
    <updated>2023-08-11T08:42:49.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣56，合并区间"><a href="#力扣56，合并区间" class="headerlink" title="力扣56，合并区间"></a>力扣56，合并区间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣56，合并区间&quot;&gt;&lt;a href=&quot;#力扣56，合并区间&quot; class=&quot;headerlink&quot; title=&quot;力扣56，合并区间&quot;&gt;&lt;/a&gt;力扣56，合并区间&lt;/h2&gt;</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>VLD</title>
    <link href="http://example.com/p/ba0d0e90.html"/>
    <id>http://example.com/p/ba0d0e90.html</id>
    <published>2023-08-07T13:53:22.202Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p>金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。</p><h2 id="Valgrind-的介绍"><a href="#Valgrind-的介绍" class="headerlink" title="Valgrind 的介绍"></a>Valgrind 的介绍</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><pre><code>$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2$ bzip2 -d valgrind-3.13.0.tar.bz2$ tar -xf valgrind-3.13.0.tar$ cd valgrind-3.13.0$ ./configure &amp;&amp; make$ sudo make install</code></pre><p>检测内存泄漏</p><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><pre><code>#include &lt;stdlib.h&gt;int main()&#123;    int *array = malloc(sizeof(int));    return 0;&#125;</code></pre><p>编译程序时，需要加上-g选项：</p><pre><code>$ gcc -g -o main_c main.c</code></pre><p>使用 Valgrind 检测内存使用情况：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full  ./main_c==31416== Memcheck, a memory error detector==31416== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31416== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31416== Command: ./main_c==31416====31416====31416== HEAP SUMMARY:==31416==     in use at exit: 4 bytes in 1 blocks==31416==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated==31416====31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)==31416====31416== LEAK SUMMARY:==31416==    definitely lost: 4 bytes in 1 blocks==31416==    indirectly lost: 0 bytes in 0 blocks==31416==      possibly lost: 0 bytes in 0 blocks==31416==    still reachable: 0 bytes in 0 blocks==31416==         suppressed: 0 bytes in 0 blocks==31416====31416== For counts of detected and suppressed errors, rerun with: -v==31416== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>先看看输出信息中的HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees表示程序释放了 0 次内存，4 bytes allocated表示分配了 4 个字节的内存。<br>另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是main.c文件的第 5 行：</p><pre><code>==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)</code></pre><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><p>#include <string><br>int main()<br>{<br>    auto ptr &#x3D; new std::string(“Hello, World!”);<br>    delete ptr;<br>    return 0;<br>}</string></p><p>使用 Valgrind 分析这段程序：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp==31438== Memcheck, a memory error detector==31438== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31438== Command: ./main_cpp==31438====31438====31438== HEAP SUMMARY:==31438==     in use at exit: 72,704 bytes in 1 blocks==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated==31438====31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)==31438==    by 0x40105FA: call_init (dl-init.c:30)==31438==    by 0x40105FA: _dl_init (dl-init.c:120)==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)==31438====31438== LEAK SUMMARY:==31438==    definitely lost: 0 bytes in 0 blocks==31438==    indirectly lost: 0 bytes in 0 blocks==31438==      possibly lost: 0 bytes in 0 blocks==31438==    still reachable: 72,704 bytes in 1 blocks==31438==         suppressed: 0 bytes in 0 blocks==31438====31438== For counts of detected and suppressed errors, rerun with: -v==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从HEAP SUMMARY可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？<br>实际上这是由于 C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏，例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。</p><p>检测越界访问<br>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><pre><code>#include &lt;vector&gt;#include &lt;iostream&gt;int main()&#123;    std::vector&lt;int&gt; v(10, 0);    std::cout &lt;&lt; v[10] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31523== Memcheck, a memory error detector==31523== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31523== Command: ./main_cpp==31523====31523== Invalid read of size 4==31523==    at 0x400AD7: main (main.cpp:7)==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#39;d==31523==    at 0x4C2E216: operator new(unsigned long) (vg_replace_malloc.c:334)==31523==    by 0x4010D3: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)==31523==    by 0x401040: std::allocator_traits&lt;std::allocator&lt;int&gt; &gt;::allocate(std::allocator&lt;int&gt;&amp;, unsigned long) (alloc_traits.h:491)==31523==    by 0x400F91: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:170)==31523==    by 0x400E7E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_create_storage(unsigned long) (stl_vector.h:185)==31523==    by 0x400D1E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:136)==31523==    by 0x400C11: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector(unsigned long, int const&amp;, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:291)==31523==    by 0x400AB9: main (main.cpp:6)</code></pre><p>Invalid read of size 4表示越界读取 4 个字节，这个操作出现在main.cpp文件的第 7 行。另外可以看到，vector分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><p>检测未初始化的内存<br>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><pre><code>#include &lt;iostream&gt;int main()&#123;    int x;    if (x == 0)    &#123;        std::cout &lt;&lt; &quot;X is zero&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 检测这个程序：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31554== Memcheck, a memory error detector==31554== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31554== Command: ./main_cpp==31554====31554== Conditional jump or move depends on uninitialised value(s)==31554==    at 0x400852: main (main.cpp:6)</code></pre><p>　　<br>输出中提示了main.cpp文件的第 6 行访问了未初始化的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VLD&quot;&gt;&lt;a href=&quot;#VLD&quot; class=&quot;headerlink&quot; title=&quot;VLD&quot;&gt;&lt;/a&gt;VLD&lt;/h1&gt;&lt;p&gt;金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。&lt;/p&gt;
&lt;h2 id=&quot;Valgrind-的介绍&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/p/54e1373e.html"/>
    <id>http://example.com/p/54e1373e.html</id>
    <published>2023-08-06T14:59:02.859Z</published>
    <updated>2023-08-11T06:07:01.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL相关问题，事务，索引，索引的优化，用过没"><a href="#MySQL相关问题，事务，索引，索引的优化，用过没" class="headerlink" title="MySQL相关问题，事务，索引，索引的优化，用过没"></a>MySQL相关问题，事务，索引，索引的优化，用过没</h2><h2 id="数据库的水平划分和垂直划分"><a href="#数据库的水平划分和垂直划分" class="headerlink" title="数据库的水平划分和垂直划分"></a>数据库的水平划分和垂直划分</h2><h2 id="数据库ACID的概念，事务是怎么保证的"><a href="#数据库ACID的概念，事务是怎么保证的" class="headerlink" title="数据库ACID的概念，事务是怎么保证的"></a>数据库ACID的概念，事务是怎么保证的</h2><ul><li>原子性(Atomicity)：  事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：  数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)： 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>事务的原子性指一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。</p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态;如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。<br>另一部分是业务数据的一致性，这需要程序代码来保证。比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。</p><p>事务的隔离性指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>事务的持久性指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。持久性意味着事务操作最终要持久化到数据库中，持久性是由 内存+redo log来保证的，MySQL的InnoDB在修改数据的时候，同时在内存和redo log记录这次操作，宕机的时候可以从redo log中恢复数据。</p><h2 id="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"><a href="#介绍一下mysql的常见的存储引擎，以及它们的区别是什么？" class="headerlink" title="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"></a>介绍一下mysql的常见的存储引擎，以及它们的区别是什么？</h2><h2 id="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"><a href="#介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）" class="headerlink" title="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"></a>介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）</h2><ul><li>读未提交（READ UNCOMMITTED）在该隔离级别一个事务还没提交时，它做的变更就能被别的事务看到，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务提交之后，它做的变更才会被其他事务看到。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>可重复读 （REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>串行化 （SERIALIZABLE）“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p>MySQL的InnoDB引擎在可重复读级别通过间隙锁解决了幻读问题，通过MVCC解决了不可重复读的问题</p><h2 id="mysql底层为什么用的是b-树？"><a href="#mysql底层为什么用的是b-树？" class="headerlink" title="mysql底层为什么用的是b+树？"></a>mysql底层为什么用的是b+树？</h2><h2 id="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"><a href="#介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？" class="headerlink" title="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"></a>介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？</h2><h2 id="MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。"><a href="#MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。" class="headerlink" title="MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。"></a>MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。</h2><h2 id="MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"><a href="#MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。" class="headerlink" title="MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"></a>MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。</h2><h2 id="MySQL的LRU和普通的LRU算法有何区别？"><a href="#MySQL的LRU和普通的LRU算法有何区别？" class="headerlink" title="MySQL的LRU和普通的LRU算法有何区别？"></a>MySQL的LRU和普通的LRU算法有何区别？</h2><h2 id="介绍MySQL三大日志redo-log-undo-log-bin-log。"><a href="#介绍MySQL三大日志redo-log-undo-log-bin-log。" class="headerlink" title="介绍MySQL三大日志redo log,undo log,bin log。"></a>介绍MySQL三大日志redo log,undo log,bin log。</h2><h2 id="写一个LRU缓存。"><a href="#写一个LRU缓存。" class="headerlink" title="写一个LRU缓存。"></a>写一个LRU缓存。</h2><h2 id="查询优化器有哪些优化"><a href="#查询优化器有哪些优化" class="headerlink" title="查询优化器有哪些优化"></a>查询优化器有哪些优化</h2><h2 id="InnoDB里面有哪些线程"><a href="#InnoDB里面有哪些线程" class="headerlink" title="InnoDB里面有哪些线程"></a>InnoDB里面有哪些线程</h2><h2 id="为什么使用B-树做索引，而不是B树或者哈希"><a href="#为什么使用B-树做索引，而不是B树或者哈希" class="headerlink" title="为什么使用B+树做索引，而不是B树或者哈希"></a>为什么使用B+树做索引，而不是B树或者哈希</h2><h2 id="了解Trie树吗"><a href="#了解Trie树吗" class="headerlink" title="了解Trie树吗"></a>了解Trie树吗</h2><h2 id="MySQL缓存介绍一下，有哪些优化"><a href="#MySQL缓存介绍一下，有哪些优化" class="headerlink" title="MySQL缓存介绍一下，有哪些优化"></a>MySQL缓存介绍一下，有哪些优化</h2><h2 id="为什么使用索引、说一下你对索引的理解？"><a href="#为什么使用索引、说一下你对索引的理解？" class="headerlink" title="为什么使用索引、说一下你对索引的理解？"></a>为什么使用索引、说一下你对索引的理解？</h2><h2 id="事务的性质有哪些，具体概念以及实现"><a href="#事务的性质有哪些，具体概念以及实现" class="headerlink" title="事务的性质有哪些，具体概念以及实现"></a>事务的性质有哪些，具体概念以及实现</h2><h2 id="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"><a href="#也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等" class="headerlink" title="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"></a>也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;a href=&quot;#MySQL相关问题，事务，索引，索引的优化，用过没&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;/a&gt;MySQL相关问题，事</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计网</title>
    <link href="http://example.com/p/bdbd2d9.html"/>
    <id>http://example.com/p/bdbd2d9.html</id>
    <published>2023-08-06T14:58:38.217Z</published>
    <updated>2023-08-11T08:42:31.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h2><h2 id="tcp四次挥手第二次和第三次不能合并吗"><a href="#tcp四次挥手第二次和第三次不能合并吗" class="headerlink" title="tcp四次挥手第二次和第三次不能合并吗"></a>tcp四次挥手第二次和第三次不能合并吗</h2><h2 id="osi七层网络模型，每层有的协议"><a href="#osi七层网络模型，每层有的协议" class="headerlink" title="osi七层网络模型，每层有的协议"></a>osi七层网络模型，每层有的协议</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="ssl四次挥手"><a href="#ssl四次挥手" class="headerlink" title="ssl四次挥手"></a>ssl四次挥手</h2><h2 id="计算机网络的理解大概是什么样的？说下TCP的三次握手"><a href="#计算机网络的理解大概是什么样的？说下TCP的三次握手" class="headerlink" title="计算机网络的理解大概是什么样的？说下TCP的三次握手"></a>计算机网络的理解大概是什么样的？说下TCP的三次握手</h2><h2 id="SSL的四次握手知道不？"><a href="#SSL的四次握手知道不？" class="headerlink" title="SSL的四次握手知道不？"></a>SSL的四次握手知道不？</h2><h2 id="tcp三次握手过程、是否熟悉TLS协议"><a href="#tcp三次握手过程、是否熟悉TLS协议" class="headerlink" title="tcp三次握手过程、是否熟悉TLS协议"></a>tcp三次握手过程、是否熟悉TLS协议</h2><h2 id="介绍一下使用tcp进行通信的时候socket的使用过程"><a href="#介绍一下使用tcp进行通信的时候socket的使用过程" class="headerlink" title="介绍一下使用tcp进行通信的时候socket的使用过程"></a>介绍一下使用tcp进行通信的时候socket的使用过程</h2><h2 id="网络模型、介绍一下每一层的作用？"><a href="#网络模型、介绍一下每一层的作用？" class="headerlink" title="网络模型、介绍一下每一层的作用？"></a>网络模型、介绍一下每一层的作用？</h2><h2 id="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"><a href="#这个也是从上面引申的，流量控制和拥塞控制怎么实现的？" class="headerlink" title="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"></a>这个也是从上面引申的，流量控制和拥塞控制怎么实现的？</h2><h2 id="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"><a href="#具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。" class="headerlink" title="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"></a>具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。</h2><h2 id="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"><a href="#如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）" class="headerlink" title="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"></a>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）</h2><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><h2 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h2><h2 id="如何使用UDP设计一个可靠的传输协议（知识盲区）"><a href="#如何使用UDP设计一个可靠的传输协议（知识盲区）" class="headerlink" title="如何使用UDP设计一个可靠的传输协议（知识盲区）"></a>如何使用UDP设计一个可靠的传输协议（知识盲区）</h2><h2 id="一条SQL语句的执行流程"><a href="#一条SQL语句的执行流程" class="headerlink" title="一条SQL语句的执行流程"></a>一条SQL语句的执行流程</h2><h2 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h2><h2 id="为什么要用epoll"><a href="#为什么要用epoll" class="headerlink" title="为什么要用epoll"></a>为什么要用epoll</h2><h2 id="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"><a href="#reactor和proactor的好处和坏处。为什么要用reactor而不用proactor" class="headerlink" title="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"></a>reactor和proactor的好处和坏处。为什么要用reactor而不用proactor</h2><h2 id="能详细讲一下有限状态机怎么解析http报文吗"><a href="#能详细讲一下有限状态机怎么解析http报文吗" class="headerlink" title="能详细讲一下有限状态机怎么解析http报文吗"></a>能详细讲一下有限状态机怎么解析http报文吗</h2><h2 id="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"><a href="#小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题" class="headerlink" title="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"></a>小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题</h2><h2 id="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"><a href="#如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆" class="headerlink" title="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"></a>如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆</h2><h2 id="socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）"><a href="#socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）" class="headerlink" title="socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）"></a>socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）</h2><h2 id="这个时候会绑定端口吗？"><a href="#这个时候会绑定端口吗？" class="headerlink" title="这个时候会绑定端口吗？"></a>这个时候会绑定端口吗？</h2><h2 id="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"><a href="#后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）" class="headerlink" title="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"></a>后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）</h2><h2 id="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"><a href="#第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？" class="headerlink" title="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"></a>第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？</h2><h2 id="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"><a href="#第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？" class="headerlink" title="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"></a>第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？</h2><h2 id="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"><a href="#TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？" class="headerlink" title="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"></a>TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？</h2><h2 id="tcp-x2F-ip五层模型"><a href="#tcp-x2F-ip五层模型" class="headerlink" title="tcp&#x2F;ip五层模型"></a>tcp&#x2F;ip五层模型</h2><h2 id="dns服务器用的是什么协议。"><a href="#dns服务器用的是什么协议。" class="headerlink" title="dns服务器用的是什么协议。"></a>dns服务器用的是什么协议。</h2><h2 id="ping命令-用的是什么协议。在哪一层。"><a href="#ping命令-用的是什么协议。在哪一层。" class="headerlink" title="ping命令 用的是什么协议。在哪一层。"></a>ping命令 用的是什么协议。在哪一层。</h2><h2 id="tcp拥塞控制实现。"><a href="#tcp拥塞控制实现。" class="headerlink" title="tcp拥塞控制实现。"></a>tcp拥塞控制实现。</h2><h2 id="在浏览器输入URL后回车的过程，涉及什么协议"><a href="#在浏览器输入URL后回车的过程，涉及什么协议" class="headerlink" title="在浏览器输入URL后回车的过程，涉及什么协议"></a>在浏览器输入URL后回车的过程，涉及什么协议</h2><h2 id="http一定是tcp吗，http3之前是"><a href="#http一定是tcp吗，http3之前是" class="headerlink" title="http一定是tcp吗，http3之前是"></a>http一定是tcp吗，http3之前是</h2><h2 id="服务器多个进程可以都绑定80这个端口监听吗"><a href="#服务器多个进程可以都绑定80这个端口监听吗" class="headerlink" title="服务器多个进程可以都绑定80这个端口监听吗"></a>服务器多个进程可以都绑定80这个端口监听吗</h2><h2 id="原理是什么"><a href="#原理是什么" class="headerlink" title="原理是什么"></a>原理是什么</h2><h2 id="操作系统怎么转发的"><a href="#操作系统怎么转发的" class="headerlink" title="操作系统怎么转发的"></a>操作系统怎么转发的</h2><h2 id="https可以绑定80端口吗，绑定了还能加密吗，为什么"><a href="#https可以绑定80端口吗，绑定了还能加密吗，为什么" class="headerlink" title="https可以绑定80端口吗，绑定了还能加密吗，为什么"></a>https可以绑定80端口吗，绑定了还能加密吗，为什么</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h1&gt;&lt;h2 id=&quot;tcp和udp的区别&quot;&gt;&lt;a href=&quot;#tcp和udp的区别&quot; class=&quot;headerlink&quot; title=&quot;tcp和u</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>继承构造函数</title>
    <link href="http://example.com/p/4d123864.html"/>
    <id>http://example.com/p/4d123864.html</id>
    <published>2023-08-06T14:20:41.355Z</published>
    <updated>2023-08-10T14:11:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h1><p>继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    using Base::Base;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>在 C++11 以前，你就必须在 Derived 里再写一份同参数列表的构造函数，将参数转发给基类。</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y)    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>如果基类有很多重载的构造函数的话，每个重载版本都要在子类重写一下，这是违反代码复用原则的！更要命的是，如果基类构造函数重构了，而子类忘记跟着改的话，就容易 BOOM</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, double y) : x(x), y(y) // 基类 api 改了    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y) // 子类这里忘改了    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4.5); // 定义变量的时候参考了基类 api 手册    // 你就等着调 bug 调到猝死吧&#125;</code></pre><p>using Base::基类方法名的这个语法是 C++98 就有的，不是 C++11 里才加的全新玩意。</p><pre><code>#include &lt;iostream&gt;class Base&#123;    protected:        void print() const        &#123;            std::cout &lt;&lt; 2333 &lt;&lt; std::endl;        &#125;&#125;;class Derived: public Base&#123;    public:        using Base::print;        // 如果不加这句声明，        // 则 print 方法在 Derived 类中就仍是 protected 的        // main 中无法调用&#125;;int main()&#123;    Derived d;    d.print();&#125;</code></pre><p>如上例所示，这种语法可以改变方法的访问控制域，比如将基类的保护方法公开出来，当然也可以将基类的公开方法在子类中变更为私有。再强调一下，这个是 C++98 中就有的语法。只不过 98 里不能 using 父类::构造函数（构造函数在某种意义上也是类的方法对吧，所以 11 补上了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承构造函数&quot;&gt;&lt;a href=&quot;#继承构造函数&quot; class=&quot;headerlink&quot; title=&quot;继承构造函数&quot;&gt;&lt;/a&gt;继承构造函数&lt;/h1&gt;&lt;p&gt;继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数&lt;/p&gt;
&lt;pre&gt;&lt;co</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="c++11" scheme="http://example.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/p/d04bd5bc.html"/>
    <id>http://example.com/p/d04bd5bc.html</id>
    <published>2023-08-06T13:10:20.145Z</published>
    <updated>2023-08-10T15:15:16.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="多线程接触过吗？控制线程访问共享资源有哪些锁？"><a href="#多线程接触过吗？控制线程访问共享资源有哪些锁？" class="headerlink" title="多线程接触过吗？控制线程访问共享资源有哪些锁？"></a>多线程接触过吗？控制线程访问共享资源有哪些锁？</h2><h2 id="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"><a href="#介绍一下互斥锁（中间穿插了一点项目的实现细节问题）" class="headerlink" title="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"></a>介绍一下互斥锁（中间穿插了一点项目的实现细节问题）</h2><h2 id="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"><a href="#用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？" class="headerlink" title="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"></a>用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？</h2><h2 id="操作系统是怎么进行内存管理的？"><a href="#操作系统是怎么进行内存管理的？" class="headerlink" title="操作系统是怎么进行内存管理的？"></a>操作系统是怎么进行内存管理的？</h2><h2 id="程序的状态有哪些？"><a href="#程序的状态有哪些？" class="headerlink" title="程序的状态有哪些？"></a>程序的状态有哪些？</h2><h2 id="详细介绍一下每个状态是怎样转换的？"><a href="#详细介绍一下每个状态是怎样转换的？" class="headerlink" title="详细介绍一下每个状态是怎样转换的？"></a>详细介绍一下每个状态是怎样转换的？</h2><h2 id="你知道的进程调度算法有哪些？详细介绍一下？"><a href="#你知道的进程调度算法有哪些？详细介绍一下？" class="headerlink" title="你知道的进程调度算法有哪些？详细介绍一下？"></a>你知道的进程调度算法有哪些？详细介绍一下？</h2><h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><h2 id="多进程fork后不同进程会共享哪些资源"><a href="#多进程fork后不同进程会共享哪些资源" class="headerlink" title="多进程fork后不同进程会共享哪些资源"></a>多进程fork后不同进程会共享哪些资源</h2><h2 id="多线程里线程的同步方式有哪些"><a href="#多线程里线程的同步方式有哪些" class="headerlink" title="多线程里线程的同步方式有哪些"></a>多线程里线程的同步方式有哪些</h2><h2 id="select怎么用。底层原理"><a href="#select怎么用。底层原理" class="headerlink" title="select怎么用。底层原理"></a>select怎么用。底层原理</h2><h2 id="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"><a href="#select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。" class="headerlink" title="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"></a>select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。</h2><h2 id="epoll-底层为什么用红黑树不用hash"><a href="#epoll-底层为什么用红黑树不用hash" class="headerlink" title="epoll 底层为什么用红黑树不用hash"></a>epoll 底层为什么用红黑树不用hash</h2><h2 id="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"><a href="#了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别" class="headerlink" title="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"></a>了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别</h2><h2 id="介绍一下epoll的两种实现方式"><a href="#介绍一下epoll的两种实现方式" class="headerlink" title="介绍一下epoll的两种实现方式"></a>介绍一下epoll的两种实现方式</h2><h2 id="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"><a href="#磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？" class="headerlink" title="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"></a>磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？</h2><h2 id="有了解epoll的底层数据结构吗？介绍一下"><a href="#有了解epoll的底层数据结构吗？介绍一下" class="headerlink" title="有了解epoll的底层数据结构吗？介绍一下"></a>有了解epoll的底层数据结构吗？介绍一下</h2><h2 id="如何限制一个进程能够使用的线程等资源"><a href="#如何限制一个进程能够使用的线程等资源" class="headerlink" title="如何限制一个进程能够使用的线程等资源"></a>如何限制一个进程能够使用的线程等资源</h2><p>ulimit -u 4096</p><p>这属于软限制，是可以改变的。也就是说在我的机器上最多可以有4096个进程，但是我可以通过改变这个参数的值来修改对于进程数量的软限制，比如说用下面的命令将软限制改到5120。</p><p>ulimit -u 5120</p><h2 id="了解过stdexec吗（NVIDIA的异步编程高性能库）"><a href="#了解过stdexec吗（NVIDIA的异步编程高性能库）" class="headerlink" title="了解过stdexec吗（NVIDIA的异步编程高性能库）"></a>了解过stdexec吗（NVIDIA的异步编程高性能库）</h2><p>没有</p><h2 id="使用过perf吗"><a href="#使用过perf吗" class="headerlink" title="使用过perf吗"></a>使用过perf吗</h2><p>没有</p><h2 id="怎么查看tlb命中率"><a href="#怎么查看tlb命中率" class="headerlink" title="怎么查看tlb命中率"></a>怎么查看tlb命中率</h2><h2 id="如何查看进程的线程数"><a href="#如何查看进程的线程数" class="headerlink" title="如何查看进程的线程数"></a>如何查看进程的线程数</h2><p>使用top命令，具体用法是 top -H</p><pre><code>    加上这个选项，top的每一行就不是显示一个进程，而是一个线程。</code></pre><p>使用ps命令，具体用法是 ps -xH</p><pre><code>    这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。</code></pre><p> 使用ps命令，具体用法是 ps -mq PID</p><pre><code>    这样可以看到指定的进程产生的线程数目。</code></pre><h2 id="如何查看进程打开的文件有哪些"><a href="#如何查看进程打开的文件有哪些" class="headerlink" title="如何查看进程打开的文件有哪些"></a>如何查看进程打开的文件有哪些</h2><p>1.列出所有打开的文件:</p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><ol start="2"><li>查看谁正在使用某个文件</li></ol><p>lsof   &#x2F;filepath&#x2F;file</p><p>3.递归查看某个目录的文件信息</p><p>lsof +D &#x2F;filepath&#x2F;filepath2&#x2F;</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><ol start="4"><li>比使用+D选项，遍历查看某个目录的所有文件信息 的方法</li></ol><p>lsof | grep ‘&#x2F;filepath&#x2F;filepath2&#x2F;’</p><ol start="5"><li>列出某个用户打开的文件信息</li></ol><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><ol start="6"><li>列出某个程序所打开的文件信息</li></ol><p>lsof -c mysql</p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p><ol start="7"><li>列出多个程序多打开的文件信息</li></ol><p>lsof -c mysql -c apache</p><ol start="8"><li>列出某个用户以及某个程序所打开的文件信息</li></ol><p>lsof -u test -c mysql</p><ol start="9"><li>列出除了某个用户外的被打开的文件信息</li></ol><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><ol start="10"><li>通过某个进程号显示该进行打开的文件</li></ol><p>lsof -p 1</p><ol start="11"><li>列出多个进程号对应的文件信息</li></ol><p>lsof -p 123,456,789</p><ol start="12"><li>列出除了某个进程号，其他进程号所打开的文件信息</li></ol><p>lsof -p ^1</p><p>13 . 列出所有的网络连接</p><p>lsof -i</p><ol start="14"><li>列出所有tcp 网络连接信息</li></ol><p>lsof  -i tcp</p><ol start="15"><li>列出所有udp网络连接信息</li></ol><p>lsof  -i udp</p><ol start="16"><li>列出谁在使用某个端口</li></ol><p>lsof -i :3306</p><ol start="17"><li>列出谁在使用某个特定的udp端口</li></ol><p>lsof -i udp:55</p><p>特定的tcp端口</p><p>lsof -i tcp:80</p><ol start="18"><li>列出某个用户的所有活跃的网络端口</li></ol><p>lsof  -a -u test -i</p><ol start="19"><li>列出所有网络文件系统</li></ol><p>lsof -N</p><p>20.域名socket文件</p><p>lsof -u</p><p>21.某个用户组所打开的文件信息</p><p>lsof -g 5555</p><ol start="22"><li>根据文件描述列出对应的文件信息</li></ol><p>lsof -d description(like 2)</p><ol start="23"><li>根据文件描述范围列出文件信息</li></ol><p>lsof -d 2-3</p><h2 id="产生死锁的条件以及怎么解决死锁问题"><a href="#产生死锁的条件以及怎么解决死锁问题" class="headerlink" title="产生死锁的条件以及怎么解决死锁问题"></a>产生死锁的条件以及怎么解决死锁问题</h2><h2 id="Linux大概学到什么程度？"><a href="#Linux大概学到什么程度？" class="headerlink" title="Linux大概学到什么程度？"></a>Linux大概学到什么程度？</h2><h2 id="线程怎么创建，什么语言"><a href="#线程怎么创建，什么语言" class="headerlink" title="线程怎么创建，什么语言"></a>线程怎么创建，什么语言</h2><h2 id="线程的基本状态有哪几个？"><a href="#线程的基本状态有哪几个？" class="headerlink" title="线程的基本状态有哪几个？"></a>线程的基本状态有哪几个？</h2><h2 id="多线程的使用的好处是什么"><a href="#多线程的使用的好处是什么" class="headerlink" title="多线程的使用的好处是什么"></a>多线程的使用的好处是什么</h2><h2 id="多线程会竞争资源出现死锁的状态，死锁怎么解决？"><a href="#多线程会竞争资源出现死锁的状态，死锁怎么解决？" class="headerlink" title="多线程会竞争资源出现死锁的状态，死锁怎么解决？"></a>多线程会竞争资源出现死锁的状态，死锁怎么解决？</h2><h2 id="事务及事务隔离"><a href="#事务及事务隔离" class="headerlink" title="事务及事务隔离"></a>事务及事务隔离</h2><h2 id="编译一个hello-world程序并且在shell上运行打印的全过程"><a href="#编译一个hello-world程序并且在shell上运行打印的全过程" class="headerlink" title="编译一个hello world程序并且在shell上运行打印的全过程?"></a>编译一个hello world程序并且在shell上运行打印的全过程?</h2><h2 id="fork-父子进程之间的关系"><a href="#fork-父子进程之间的关系" class="headerlink" title="fork()父子进程之间的关系"></a>fork()父子进程之间的关系</h2><h2 id="缺页中断的过程"><a href="#缺页中断的过程" class="headerlink" title="缺页中断的过程"></a>缺页中断的过程</h2><h2 id="地址转换的过程"><a href="#地址转换的过程" class="headerlink" title="地址转换的过程"></a>地址转换的过程</h2><h2 id="进程状态是怎么转变的"><a href="#进程状态是怎么转变的" class="headerlink" title="进程状态是怎么转变的"></a>进程状态是怎么转变的</h2><h2 id="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"><a href="#进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）" class="headerlink" title="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"></a>进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）</h2><h2 id="总线在其中发挥的作用"><a href="#总线在其中发挥的作用" class="headerlink" title="总线在其中发挥的作用"></a>总线在其中发挥的作用</h2><h2 id="这个过程中磁盘和内存的关系"><a href="#这个过程中磁盘和内存的关系" class="headerlink" title="这个过程中磁盘和内存的关系"></a>这个过程中磁盘和内存的关系</h2><h2 id="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"><a href="#从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行" class="headerlink" title="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"></a>从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;多线程接触过吗？控制线程访问共享资源有哪些锁？&quot;&gt;&lt;a href=&quot;#多线程接触过吗？控制线程访问共享资源有哪些锁</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp面向对象</title>
    <link href="http://example.com/p/87fdbf5e.html"/>
    <id>http://example.com/p/87fdbf5e.html</id>
    <published>2023-08-06T09:30:39.389Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp面向对象"><a href="#cpp面向对象" class="headerlink" title="cpp面向对象"></a>cpp面向对象</h1><p>面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装可以隐藏实现细节，使得代码模块化；封装将一些属性和相关方法封装在一个对象中，对数据的访问只能通过已定义的界面。对外隐藏内部具体实现细节。内部实现，外界不需要关心，外界只需要根据“内部提供的接口”去使用就可以。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><ul><li>保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）</li><li>隐藏方法（实现）细节，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</li><li>封装可以使对象拥有完整的属性和方法（类中的函数）</li><li>外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p><p>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>多态的构成条件</p><ul><li>必须通过基类的指针或者引用调用虚函数<ul><li>虚函数：在类的普通成员函数前加上virtual关键字+</li></ul></li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp面向对象&quot;&gt;&lt;a href=&quot;#cpp面向对象&quot; class=&quot;headerlink&quot; title=&quot;cpp面向对象&quot;&gt;&lt;/a&gt;cpp面向对象&lt;/h1&gt;&lt;p&gt;面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp内存管理</title>
    <link href="http://example.com/p/ee3dbaf8.html"/>
    <id>http://example.com/p/ee3dbaf8.html</id>
    <published>2023-08-06T08:45:54.616Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp内存管理"><a href="#cpp内存管理" class="headerlink" title="cpp内存管理"></a>cpp内存管理</h1><p><img src="https://s1.ax1x.com/2023/08/06/pPA4Y7T.png" alt="pPA4Y7T.png"></p><p>栈：又叫堆栈，主要存放非静态局部变量、函数参数、返回值等等，栈是向下增长的；</p><p>BSS（Block started by symbol)：存放未初始化的全局和静态变量。</p><p>堆：用于程序运行时动态内存分配，堆是可以上增长的；</p><p>数据段：存储全局数据和静态数据，常量数据（如字符串常量）。</p><p>代码段：存储可执行的代码与只读常量；</p><p>当全局&#x2F;静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。</p><pre><code>int x;int z = 5;void func()&#123;    static int y;&#125;int main()&#123;    return 0;&#125;</code></pre><p>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p><p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p><p>而对于已经初始化了的全局&#x2F;静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p><h2 id="堆和栈的主要区别"><a href="#堆和栈的主要区别" class="headerlink" title="堆和栈的主要区别"></a>堆和栈的主要区别</h2><p>有以下几点：</p><ul><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ul><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="让一个对象只在栈（堆）上分配内存"><a href="#让一个对象只在栈（堆）上分配内存" class="headerlink" title="让一个对象只在栈（堆）上分配内存"></a>让一个对象只在栈（堆）上分配内存</h2><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<br>虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。<br>将operator new()设为私有即可禁止对象被new在堆上。</p><pre><code>class A  &#123;  private:      void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的      void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  public:      A()&#123;&#125;      ~A()&#123;&#125;  &#125;;</code></pre><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><p>就是不能静态建立类对象, 即不能直接调用类的构造函数。<br>首先要知道， 当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</p><pre><code>class A&#123;public:    A()&#123;&#125;    void destroy()&#123;delete this;&#125;private:    ~A()&#123;&#125;&#125;</code></pre><p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</p><p>存在问题：<br>1.无法解决继承问题：为了实现多态， 析构函数通常要设为virtual， 因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。<br>2. new和destroy的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp内存管理&quot;&gt;&lt;a href=&quot;#cpp内存管理&quot; class=&quot;headerlink&quot; title=&quot;cpp内存管理&quot;&gt;&lt;/a&gt;cpp内存管理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/06/pPA4Y7T.p</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp</title>
    <link href="http://example.com/p/caeaa4a1.html"/>
    <id>http://example.com/p/caeaa4a1.html</id>
    <published>2023-08-06T07:08:25.455Z</published>
    <updated>2023-08-11T08:42:32.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h1><p><a href="https://www.dotcpp.com/course/808">https://www.dotcpp.com/course/808</a></p><h2 id="c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗"><a href="#c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗" class="headerlink" title="c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗"></a>c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗</h2><p>封装、继承、多态</p><h2 id="c-面向对象编程讲一下"><a href="#c-面向对象编程讲一下" class="headerlink" title="c++面向对象编程讲一下"></a>c++面向对象编程讲一下</h2><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><h2 id="多态和继承在什么情况下使用"><a href="#多态和继承在什么情况下使用" class="headerlink" title="多态和继承在什么情况下使用"></a>多态和继承在什么情况下使用</h2><h2 id="除了多态和继承还有什么面向对象方法"><a href="#除了多态和继承还有什么面向对象方法" class="headerlink" title="除了多态和继承还有什么面向对象方法"></a>除了多态和继承还有什么面向对象方法</h2><h2 id="能再仔细介绍一下c-的多态吗"><a href="#能再仔细介绍一下c-的多态吗" class="headerlink" title="能再仔细介绍一下c++的多态吗"></a>能再仔细介绍一下c++的多态吗</h2><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h2 id="多态是怎么调用派生类重写的方法的"><a href="#多态是怎么调用派生类重写的方法的" class="headerlink" title="多态是怎么调用派生类重写的方法的"></a>多态是怎么调用派生类重写的方法的</h2><h2 id="实现String-的普通和拷贝构造、赋值重载和析构函数"><a href="#实现String-的普通和拷贝构造、赋值重载和析构函数" class="headerlink" title="实现String 的普通和拷贝构造、赋值重载和析构函数"></a>实现String 的普通和拷贝构造、赋值重载和析构函数</h2><pre><code>#pragma warning(disable:4996)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyString &#123;public:    // 默认构造函数    MyString(const char* str = NULL);    // 复制构造函数    MyString(const MyString&amp; str);    // 移动构造函数    MyString(MyString&amp;&amp; str)noexcept;    // 析构函数    ~MyString();    // 字符串连接    MyString operator+(const MyString&amp; str);    // 拷贝赋值    MyString&amp; operator=(const MyString&amp; str);    //移动赋值    MyString&amp; operator=(MyString&amp;&amp; str);    // 字符串赋值    MyString&amp; operator=(const char* str);    // 判断是否字符串相等    bool operator==(const MyString&amp; str);    // 获取字符串长度    int length();    // 求子字符串[start,start+n-1]    MyString substr(int start, int n);    // 重载输出    friend ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str);private:    char* m_data;    int m_size;&#125;;// 构造函数MyString::MyString(const char* str)&#123;    if (str == nullptr)    &#123;        m_data = new char[1];        m_data[0] = &#39;\0&#39;;        m_size = 0;    &#125;    else    &#123;        m_size = strlen(str);        m_data = new char[m_size + 1];        strcpy(m_data, str);    &#125;&#125;// 复制构造函数MyString::MyString(const MyString&amp; str)&#123;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);&#125;// 析构函数MyString::~MyString()&#123;    delete[] m_data;&#125;// 字符串连接MyString MyString::operator+(const MyString&amp; str)&#123;    MyString newStr;    //释放原有空间    delete[] newStr.m_data;    newStr.m_size = m_size + str.m_size;    newStr.m_data = new char[newStr.m_size + 1];    strcpy(newStr.m_data, m_data);    strcpy(newStr.m_data + m_size, str.m_data);    return newStr;&#125;// 字符串赋值MyString&amp; MyString::operator=(const MyString&amp; str)&#123;    if (m_data == str.m_data)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);    return *this;&#125;MyString&amp; MyString::operator=(MyString&amp;&amp; str)&#123;    if (str.m_data == m_data)    &#123;        return *this;    &#125;    delete m_data;    m_data = str.m_data;    m_size = str.m_size;    str.m_data = nullptr;    str.m_size = 0;&#125;// 字符串赋值MyString&amp; MyString::operator=(const char* str)&#123;    if (m_data == str)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = strlen(str);    m_data = new char[m_size + 1];    strcpy(m_data, str);    return *this;&#125;// 判断是否字符串相等bool MyString::operator==(const MyString&amp; str)&#123;    return strcmp(m_data, str.m_data) == 0;&#125;// 获取字符串长度int MyString::length()&#123;    return m_size;&#125;// 求子字符串[start,start+n-1]MyString MyString::substr(int start, int n)&#123;    MyString newStr;    // 释放原有内存    delete[] newStr.m_data;    // 重新申请内存    newStr.m_data = new char[n + 1];    for (int i = 0;i &lt; n;++i)    &#123;        newStr.m_data[i] = m_data[start + i];    &#125;    newStr.m_data[n] = &#39;\0&#39;;    newStr.m_size = n;    return newStr;&#125;MyString::MyString(MyString&amp;&amp; str) noexcept&#123;    m_data = str.m_data;    str.m_data = nullptr;    m_size = str.m_size;    str.m_size = 0;&#125;// 重载输出ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str)&#123;    o &lt;&lt; str.m_data;    return o;&#125;</code></pre><h2 id="有了new是不是可以就不用malloc了？"><a href="#有了new是不是可以就不用malloc了？" class="headerlink" title="有了new是不是可以就不用malloc了？"></a>有了new是不是可以就不用malloc了？</h2><p>比如内存池，在这个基础上可以利用placement new<br>c 没有new  </p><h2 id="malloc是如何跟物理地址关联上的？"><a href="#malloc是如何跟物理地址关联上的？" class="headerlink" title="malloc是如何跟物理地址关联上的？"></a>malloc是如何跟物理地址关联上的？</h2><p>malloc申请内存返回的是虚拟地址而不是物理地址，而且，返回的这个虚拟地址是没有map映射到物理内存中的，只有当程序(进程)用到访问了这个地址的时候，</p><p>内核才响应“缺页异常”，才回去映射一块物理地址。</p><p>关于malloc(0) 能申请成功是肯定的，它返回的是虚拟地址(对应的物理地址还不确定的)，在你没用到这块地址空间的时候，它不会再物理上开辟内存。</p><p>在你用到malloc(0)返回的地址时，因为参数为0，缺页异常不会为你的进程空间申请额外内存。所以这个指针应该是不能用的。</p><h2 id="new-x2F-delete-malloc-x2F-free-区别"><a href="#new-x2F-delete-malloc-x2F-free-区别" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free 区别"></a>new&#x2F;delete  malloc&#x2F;free 区别</h2><ol><li>运算符库函数</li><li>构造函数析构函数</li><li>可以重载</li><li>手动计算大小，自动计算大小</li><li>类型安全</li></ol><h2 id="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"><a href="#讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常" class="headerlink" title="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"></a>讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常</h2><p>调用malloc+构造函数<br>nothrow指定<br>bad——alloc</p><h2 id="malloc线程安全吗，多线程malloc系统怎么设计"><a href="#malloc线程安全吗，多线程malloc系统怎么设计" class="headerlink" title="malloc线程安全吗，多线程malloc系统怎么设计"></a>malloc线程安全吗，多线程malloc系统怎么设计</h2><p>在多线程环境下，使用 malloc() 和 free() 函数需要特别注意，因为这两个函数都会涉及到内存的分配和释放，容易引起多线程竞争问题，可能会导致内存泄漏或程序崩溃。</p><p>为了避免这些问题，需要采取以下措施：</p><p>确保线程安全：多个线程同时使用 malloc() 或 free() 时可能会导致内存竞争。为了确保线程安全，可以使用线程安全的内存分配器，例如 tcmalloc 或 jemalloc，或者使用互斥锁来保护内存分配和释放的操作。</p><p>避免内存泄漏：如果在分配内存后忘记释放，将会导致内存泄漏。在多线程环境中，内存泄漏问题可能会更加复杂，因为在一个线程中分配的内存可能需要在另一个线程中释放。为了避免内存泄漏，应该在适当的时候调用 free() 函数来释放已经不再使用的内存。</p><p>避免悬挂指针问题：在多线程环境中，如果一个线程释放了某个内存块，而另一个线程仍然在使用这个内存块，就可能导致悬挂指针问题。为了避免这个问题，应该在释放内存块之前确保没有其他线程在使用该内存块，可以使用同步机制来解决这个问题。</p><p>总之，在多线程环境中，使用 malloc() 和 free() 函数需要特别小心，需要采取适当的措施来确保线程安全和避免内存泄漏和悬挂指针问题。</p><h2 id="C-内存分布。什么样的数据在栈区，什么样的在堆区。"><a href="#C-内存分布。什么样的数据在栈区，什么样的在堆区。" class="headerlink" title="C++内存分布。什么样的数据在栈区，什么样的在堆区。"></a>C++内存分布。什么样的数据在栈区，什么样的在堆区。</h2><p>局部栈区，全局堆区</p><h2 id="C-内存管理（RAII啥的）"><a href="#C-内存管理（RAII啥的）" class="headerlink" title="C++内存管理（RAII啥的）"></a>C++内存管理（RAII啥的）</h2><p>资源获取即初始化。使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><h2 id="sizeof一个空的结构体，返回什么"><a href="#sizeof一个空的结构体，返回什么" class="headerlink" title="sizeof一个空的结构体，返回什么"></a>sizeof一个空的结构体，返回什么</h2><p>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><h2 id="问了c-文件编译过程"><a href="#问了c-文件编译过程" class="headerlink" title="问了c++文件编译过程"></a>问了c++文件编译过程</h2><p>预编译  cpp<br>汇编    i<br>编译    s<br>链接    o</p><h2 id="静态链接动态链接区别"><a href="#静态链接动态链接区别" class="headerlink" title="静态链接动态链接区别"></a>静态链接动态链接区别</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="动态链接库具体怎样操作链接的"><a href="#动态链接库具体怎样操作链接的" class="headerlink" title="动态链接库具体怎样操作链接的"></a>动态链接库具体怎样操作链接的</h2><p>重定位   忘了待更新</p><h2 id="c-学的好的是哪块-具体说"><a href="#c-学的好的是哪块-具体说" class="headerlink" title="c++学的好的是哪块 具体说"></a>c++学的好的是哪块 具体说</h2><p>学得最好的是没有</p><h2 id="野指针和内存泄漏是什么，如何避免？"><a href="#野指针和内存泄漏是什么，如何避免？" class="headerlink" title="野指针和内存泄漏是什么，如何避免？"></a>野指针和内存泄漏是什么，如何避免？</h2><p>内存泄漏：①访问已经释放的内存</p><pre><code>②访问没有权限的内存</code></pre><p>野指针：指向内存被释放的内存或者没有访问权限的内存的指针。<br>野指针”的成因主要有3种：<br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><h2 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h2><p>智能指针</p><h2 id="内存泄漏怎样应对"><a href="#内存泄漏怎样应对" class="headerlink" title="内存泄漏怎样应对"></a>内存泄漏怎样应对</h2><p>智能指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><h2 id="讲一下智能指针"><a href="#讲一下智能指针" class="headerlink" title="讲一下智能指针"></a>讲一下智能指针</h2><h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="讲讲智能指针"><a href="#讲讲智能指针" class="headerlink" title="讲讲智能指针"></a>讲讲智能指针</h2><h2 id="c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用"><a href="#c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用" class="headerlink" title="c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用"></a>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用</h2><h2 id="shared-ptr循环引用怎么解决"><a href="#shared-ptr循环引用怎么解决" class="headerlink" title="shared_ptr循环引用怎么解决"></a>shared_ptr循环引用怎么解决</h2><p>weak_ptr</p><h2 id="make-shared和shared-ptr"><a href="#make-shared和shared-ptr" class="headerlink" title="make_shared和shared_ptr"></a>make_shared和shared_ptr</h2><p>std::shared_ptr构造函数会执行两次内存申请，而std::make_shared则执行一次。<br>std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr<A> p2(new A)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared<A>()则是只执行一次内存申请，将数据和控制块的申请放到一起。</A></A></p><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>考虑下面一段代码：</p><pre><code>void f(std::shared_ptr&lt;Lhs&gt; &amp;lhs, std::shared_ptr&lt;Rhs&gt; &amp;rhs)&#123;...&#125;...f(std::shared_ptr&lt;Lhs&gt;(new Lhs()),std::shared_ptr&lt;Rhs&gt;(new Rhs()));</code></pre><p>因为C++允许参数在计算的时候打乱顺序，因此一个可能的顺序如下:</p><pre><code>new Lhs()new Rhs()std::shared_ptrstd::shared_ptr</code></pre><p>此时假设第2步出现异常，则在第一步申请的内存将没处释放了，上面产生内存泄露的本质是当申请数据指针后，没有马上传给std::shared_ptr，因此一个可能的解决办法是：</p><pre><code>auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs());auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs());f(lhs, rhs);</code></pre><p>当然更好的方法是：</p><pre><code>f(std::make_shared&lt;Lhs&gt;(),    std::make_shared&lt;Rhs&gt;());</code></pre><p>make_shared的缺点<br>因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。</p><p>什么是weak_ptr？<br>weak_ptr是用来指向shared_ptr，用来判断shared_ptr指向的数据内存是否还存在了（通过方法lock），下面是一段示例代码：</p><pre><code>#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;struct A&#123;    int _i;    A(): _i(int())&#123;&#125;    A(int i): _i(i)&#123;&#125;&#125;;int main()&#123;    shared_ptr&lt;A&gt; sharedPtr(new A(2));    weak_ptr&lt;A&gt; weakPtr = sharedPtr;    sharedPtr.reset(new A(3)); // reset，weakPtr指向的失效了。    cout &lt;&lt; weakPtr.use_count() &lt;&lt;endl;&#125;</code></pre><p>通过lock（）来判断是否存在了，lock（）相当于</p><pre><code>expired（）？shared_ptr&lt;element_type&gt;() ： shared_ptr&lt;element_type&gt;(*this)</code></pre><p>当不存在的时候，会返回一个空的shared_ptr，weak_ptr在指向shared_ptr的时候，并不会增加ref count，因此weak_ptr主要有两个用途：</p><ul><li>用来记录对象是否存在了</li><li>用来解决shared_ptr环形依赖问题</li></ul><h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a>map和set</h2><p>底层红黑树，剩下不会了</p><h2 id="迭代器作用-迭代器和指针的区别"><a href="#迭代器作用-迭代器和指针的区别" class="headerlink" title="迭代器作用 迭代器和指针的区别"></a>迭代器作用 迭代器和指针的区别</h2><p><a href="https://whl963854.github.io/p/2cf69f40.html">https://whl963854.github.io/p/2cf69f40.html</a></p><h2 id="析构函数作用"><a href="#析构函数作用" class="headerlink" title="析构函数作用"></a>析构函数作用</h2><p>完成一些清理工作，比如：释放内存等。</p><h2 id="static关键字在C-中有什么作用？"><a href="#static关键字在C-中有什么作用？" class="headerlink" title="static关键字在C++中有什么作用？"></a>static关键字在C++中有什么作用？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰的类的数据成员怎么初始化的？"><a href="#static修饰的类的数据成员怎么初始化的？" class="headerlink" title="static修饰的类的数据成员怎么初始化的？"></a>static修饰的类的数据成员怎么初始化的？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"><a href="#static修饰类的成员函数，这个成员函数使用起来有哪些限制？" class="headerlink" title="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"></a>static修饰类的成员函数，这个成员函数使用起来有哪些限制？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="知道哪些c-中的关键字，然后讲了static"><a href="#知道哪些c-中的关键字，然后讲了static" class="headerlink" title="知道哪些c++中的关键字，然后讲了static"></a>知道哪些c++中的关键字，然后讲了static</h2><h2 id="static变量存储在哪，和局部变量存储位置有什么区别"><a href="#static变量存储在哪，和局部变量存储位置有什么区别" class="headerlink" title="static变量存储在哪，和局部变量存储位置有什么区别?"></a>static变量存储在哪，和局部变量存储位置有什么区别?</h2><h2 id="C-你觉得最特别于其他语言的点是什么"><a href="#C-你觉得最特别于其他语言的点是什么" class="headerlink" title="C++你觉得最特别于其他语言的点是什么"></a>C++你觉得最特别于其他语言的点是什么</h2><h2 id="java，python，c-垃圾回收怎么实现的"><a href="#java，python，c-垃圾回收怎么实现的" class="headerlink" title="java，python，c++垃圾回收怎么实现的"></a>java，python，c++垃圾回收怎么实现的</h2><h2 id="指针和引用的区别，左值右值，右值引用"><a href="#指针和引用的区别，左值右值，右值引用" class="headerlink" title="指针和引用的区别，左值右值，右值引用"></a>指针和引用的区别，左值右值，右值引用</h2><p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>可以有const指针，但是没有const引用；<br>指针可以有多级，但是引用只能是一级<br>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或–</p><p>引用在汇编层面会被c++编译器当做const指针来进行操作</p><h2 id="说说对指针和引用的理解"><a href="#说说对指针和引用的理解" class="headerlink" title="说说对指针和引用的理解"></a>说说对指针和引用的理解</h2><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="堆和栈的区别。什么情况下会往堆里放"><a href="#堆和栈的区别。什么情况下会往堆里放" class="headerlink" title="堆和栈的区别。什么情况下会往堆里放"></a>堆和栈的区别。什么情况下会往堆里放</h2><p>new<br>malloc</p><h2 id="堆区都是手动释放？"><a href="#堆区都是手动释放？" class="headerlink" title="堆区都是手动释放？"></a>堆区都是手动释放？</h2><p>答：也不一定，主要看使用方法。如果使用的函数是malloc，new之类，就需要手动释放，不然会造成内存泄漏。但是如果我们使用智能指针，智能指针会自动释放内存，因为智能指针基于类自动调用析构函数实现了内存的自动释放</p><h2 id="C-哪些运算符不能重载？"><a href="#C-哪些运算符不能重载？" class="headerlink" title="C++哪些运算符不能重载？"></a>C++哪些运算符不能重载？</h2><p>答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p><p>以下运算符不能被重载：.、.*、::、? :、sizeof。<br>重载运算符()、[]、-&gt;、或者赋值运算符&#x3D;时，只能将它们重载为成员函数，不能重载为全局函数。</p><h2 id="char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别"><a href="#char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别" class="headerlink" title="char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别"></a>char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别</h2><p>4  3 size</p><h2 id="C-11的特性有没有"><a href="#C-11的特性有没有" class="headerlink" title="C++11的特性有没有"></a>C++11的特性有没有</h2><p>初始化列表 使用 {} 可以方便地初始化数组、结构体、类等对象<br>智能指针 引入了 std::unique_ptr、std::shared_ptr 等智能指针，方便地进行动态内存管理<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式 可以在函数内部定义匿名函数，从而方便地实现函数对象。<br>字符串字面量<br>auto 自动类型推导：使用关键字 auto 可以让编译器自动推导变量的类型。<br>枚举类<br>完美转发<br>移动语义 使用 &amp;&amp; 可以表示右值引用，引入了移动构造函数和移动赋值运算符，可以减少不必要的拷贝。<br>constexptr<br>静态断言 使用关键字 static_assert 可以在编译时检查一个表达式是否为 true<br>新的容器和算法：引入了 std::array、std::forward_list、std::unordered_map、std::move 等新特性，增强了容器和算法库的功能。</p><h2 id="聊一聊你理解的移动构造函数？"><a href="#聊一聊你理解的移动构造函数？" class="headerlink" title="聊一聊你理解的移动构造函数？"></a>聊一聊你理解的移动构造函数？</h2><p>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。</p><h2 id="那c-有哪些构造函数呢？"><a href="#那c-有哪些构造函数呢？" class="headerlink" title="那c++有哪些构造函数呢？"></a>那c++有哪些构造函数呢？</h2><p>答：默认构造函数，有参构造函数，拷贝构造函数，移动构造函数。<br>委托构造函数<br>继承构造函数</p><h2 id="介绍一下map容器？"><a href="#介绍一下map容器？" class="headerlink" title="介绍一下map容器？"></a>介绍一下map容器？</h2><p>答：map支持kv键值对的查找，底层基于红黑树，查询和插入的时间复杂度都是logn。因为底层基于红黑树，map的key是有序的，所以map容器为我们提供了一些有序的api，比如对key的二分查找(lower_bound）。与此同时，我们还有unoredered_map,这个容器是哈希表，查询和插入的时间复杂度是O(1)，但是如果遇上哈希冲突，复杂度可能退化到O(n)。这个容器的key是无序的。unordered_map的使用的常数时间是要比map快一到两倍。</p><h2 id="讲一讲const关键字。"><a href="#讲一讲const关键字。" class="headerlink" title="讲一讲const关键字。"></a>讲一讲const关键字。</h2><p>答：const关键字在C++11之前，具有只读和常量两个语义。在C++11，引入constexpr关键字之后，const语义固定在了只读，constexpr固定为常量，但总而言之，这个两个关键字核心的语义是，指向的内容不可更改。<br>const 关键字用于指定变量或对象的值是不可修改的。它可以用于修饰变量、函数参数、函数返回值和成员函数等。 constexpr 关键字用于指定表达式在编译时就能够被计算出结果，从而产生一个编译期常量。它可以用于修饰变量、函数、类和模板等。constexpr 的作用是在编译时进行计算，从而提高程序的性能。</p><h2 id="那const指向地址呢？"><a href="#那const指向地址呢？" class="headerlink" title="那const指向地址呢？"></a>那const指向地址呢？</h2><p>答：const指向的地址值不可更改，但是地址对应的内容是可更改的。</p><h2 id="const关键字修饰类的对象使用起来有什么限制？"><a href="#const关键字修饰类的对象使用起来有什么限制？" class="headerlink" title="const关键字修饰类的对象使用起来有什么限制？"></a>const关键字修饰类的对象使用起来有什么限制？</h2><p><a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="const关键字修饰类的对象有什么办法改变内部数据？"><a href="#const关键字修饰类的对象有什么办法改变内部数据？" class="headerlink" title="const关键字修饰类的对象有什么办法改变内部数据？"></a>const关键字修饰类的对象有什么办法改变内部数据？</h2><p>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="虚函数是什么，重载和重写的关系。"><a href="#虚函数是什么，重载和重写的关系。" class="headerlink" title="虚函数是什么，重载和重写的关系。"></a>虚函数是什么，重载和重写的关系。</h2><p>答：虚函数涉及到C++的多态。当、在基类中声明一个虚函数，在派生类中重写该函数，可以实现动态绑定。在运行时，程序会根据具体对象的类型调用相应的函数。重写要求函数签名完全一致，即函数名，函数变量和返回值完全一致，但是函数体可以不同。重写是运行时多态，也就是动态多态。重载是函数名相同，返回值和函数参数可以不同，重载是编译时多态，即静态多态。</p><h2 id="讲讲你理解的虚基类。"><a href="#讲讲你理解的虚基类。" class="headerlink" title="讲讲你理解的虚基类。"></a>讲讲你理解的虚基类。</h2><p>答：C++的虚基类类似Java的抽象类，是不可以实例化的。【这里回答错了】</p><p>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。虚基类是可以被实例化的。</p><h2 id="C-多态虚函数实现原理。虚函数表里面有哪些东西？"><a href="#C-多态虚函数实现原理。虚函数表里面有哪些东西？" class="headerlink" title="C++多态虚函数实现原理。虚函数表里面有哪些东西？"></a>C++多态虚函数实现原理。虚函数表里面有哪些东西？</h2><h2 id="虚函数和静态函数-虚表"><a href="#虚函数和静态函数-虚表" class="headerlink" title="虚函数和静态函数 虚表"></a>虚函数和静态函数 虚表</h2><h2 id="cpp编译生成二进制文件过程"><a href="#cpp编译生成二进制文件过程" class="headerlink" title=".cpp编译生成二进制文件过程"></a>.cpp编译生成二进制文件过程</h2><p><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><h2 id="C-从源程序到可执行程序的过程"><a href="#C-从源程序到可执行程序的过程" class="headerlink" title="C++从源程序到可执行程序的过程"></a>C++从源程序到可执行程序的过程</h2><h2 id="动态链接和静态链接区别。"><a href="#动态链接和静态链接区别。" class="headerlink" title="动态链接和静态链接区别。"></a>动态链接和静态链接区别。</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="如何优化一个c-程序-局部性"><a href="#如何优化一个c-程序-局部性" class="headerlink" title="如何优化一个c++程序,局部性"></a>如何优化一个c++程序,局部性</h2><p>时间局部性<br>空间局部性</p><h2 id="左值，右值，万能引用，完美转发"><a href="#左值，右值，万能引用，完美转发" class="headerlink" title="左值，右值，万能引用，完美转发"></a>左值，右值，万能引用，完美转发</h2><p><a href="https://whl963854.github.io/p/64657.html">https://whl963854.github.io/p/64657.html</a><br><a href="https://whl963854.github.io/p/3763.html">https://whl963854.github.io/p/3763.html</a><br><a href="https://whl963854.github.io/p/50074.html">https://whl963854.github.io/p/50074.html</a></p><h2 id="STL基本容器用过哪些"><a href="#STL基本容器用过哪些" class="headerlink" title="STL基本容器用过哪些"></a>STL基本容器用过哪些</h2><p>vector<br>string<br>stack<br>queue<br>set<br>map</p><h2 id="能说一下内存泄漏发生的情景吗"><a href="#能说一下内存泄漏发生的情景吗" class="headerlink" title="能说一下内存泄漏发生的情景吗"></a>能说一下内存泄漏发生的情景吗</h2><p>忘了释放内存资源</p><h2 id="size-of是在编译期还是在运行期确定"><a href="#size-of是在编译期还是在运行期确定" class="headerlink" title="size_of是在编译期还是在运行期确定"></a>size_of是在编译期还是在运行期确定</h2><p>sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。</p><h2 id="C-如何调整内存对齐值"><a href="#C-如何调整内存对齐值" class="headerlink" title="C++ 如何调整内存对齐值"></a>C++ 如何调整内存对齐值</h2><p>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</p><h2 id="主机大小端序"><a href="#主机大小端序" class="headerlink" title="主机大小端序"></a>主机大小端序</h2><p>C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的x86处理器是小端模式（Little Endian）。Java编写的程序则唯一采用Big Endian方式来存储数据。</p><h3 id="C-Coroutine"><a href="#C-Coroutine" class="headerlink" title="C++ Coroutine"></a>C++ Coroutine</h3><h2 id="C-虚函数-gt-构造函数能否是虚函数，析构函数"><a href="#C-虚函数-gt-构造函数能否是虚函数，析构函数" class="headerlink" title="C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数"></a>C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数</h2><p>构造不可以<br>析构可</p><h2 id="构造函数能否是虚函数？"><a href="#构造函数能否是虚函数？" class="headerlink" title="构造函数能否是虚函数？"></a>构造函数能否是虚函数？</h2><p>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。</p><p>虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。</p><p>vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。</p><p>如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。</p><p>因此，构造函数不可以是虚函数。</p><h2 id="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"><a href="#多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？" class="headerlink" title="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"></a>多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？</h2><p>使用多线程和使用多进程的选择取决于您的应用程序的需求。</p><p>多线程：在同一个进程中创建多个线程，多个线程共享进程的内存空间，因此它们可以很容易地共享数据，而且通信成本更低。因此，如果您的应用程序需要在单个进程内部并行执行不同任务，并且需要共享大量数据，则多线程是一个很好的选择。</p><p>多进程：当您的应用程序需要在不同的进程之间并行执行任务时，您可以使用多进程。不同进程之间的通信通常比同一进程中的通信慢，但它们拥有完全独立的内存空间，因此不存在内存访问冲突的问题。</p><p>总的来说，多线程适用于在单个进程中并行执行任务，并且需要共享大量数据的情况，而多进程适用于在不同进程中并行执行任务的情况。</p><h2 id="你这个项目是多线程的，那用多进程可不可以实现？"><a href="#你这个项目是多线程的，那用多进程可不可以实现？" class="headerlink" title="你这个项目是多线程的，那用多进程可不可以实现？"></a>你这个项目是多线程的，那用多进程可不可以实现？</h2><h2 id="项目相关介绍一下"><a href="#项目相关介绍一下" class="headerlink" title="项目相关介绍一下"></a>项目相关介绍一下</h2><h2 id="进程和线程的区别。"><a href="#进程和线程的区别。" class="headerlink" title="进程和线程的区别。"></a>进程和线程的区别。</h2><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="为什么要用多线程。多进程可以吗（webserver的）"><a href="#为什么要用多线程。多进程可以吗（webserver的）" class="headerlink" title="为什么要用多线程。多进程可以吗（webserver的）"></a>为什么要用多线程。多进程可以吗（webserver的）</h2><h2 id="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"><a href="#了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？" class="headerlink" title="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"></a>了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？</h2><h2 id="线程池中的队列知道吗？队列是无限大的还是有限的"><a href="#线程池中的队列知道吗？队列是无限大的还是有限的" class="headerlink" title="线程池中的队列知道吗？队列是无限大的还是有限的"></a>线程池中的队列知道吗？队列是无限大的还是有限的</h2><h2 id="介绍一下线程的几种状态。"><a href="#介绍一下线程的几种状态。" class="headerlink" title="介绍一下线程的几种状态。"></a>介绍一下线程的几种状态。</h2><h2 id="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"><a href="#一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？" class="headerlink" title="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"></a>一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？</h2><h2 id="了解线程池吗？大概介绍一下"><a href="#了解线程池吗？大概介绍一下" class="headerlink" title="了解线程池吗？大概介绍一下"></a>了解线程池吗？大概介绍一下</h2><h2 id="多线程会发生什么问题？线程同步有哪些手段？"><a href="#多线程会发生什么问题？线程同步有哪些手段？" class="headerlink" title="多线程会发生什么问题？线程同步有哪些手段？"></a>多线程会发生什么问题？线程同步有哪些手段？</h2><h2 id="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"><a href="#什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？" class="headerlink" title="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"></a>什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？</h2><h2 id="说说对设计模式的理解"><a href="#说说对设计模式的理解" class="headerlink" title="说说对设计模式的理解"></a>说说对设计模式的理解</h2><h2 id="了解设计模式吗？介绍一下单例模式"><a href="#了解设计模式吗？介绍一下单例模式" class="headerlink" title="了解设计模式吗？介绍一下单例模式"></a>了解设计模式吗？介绍一下单例模式</h2><h2 id="了解的设计模式"><a href="#了解的设计模式" class="headerlink" title="了解的设计模式"></a>了解的设计模式</h2><p>单例<br>组件</p><h2 id="手撕一个设计模式"><a href="#手撕一个设计模式" class="headerlink" title="手撕一个设计模式"></a>手撕一个设计模式</h2><h2 id="手写一个单例模式"><a href="#手写一个单例模式" class="headerlink" title="手写一个单例模式"></a>手写一个单例模式</h2><h2 id="设计模式几大原则"><a href="#设计模式几大原则" class="headerlink" title="设计模式几大原则"></a>设计模式几大原则</h2><h2 id="手撕单例模式（懒汉模式）"><a href="#手撕单例模式（懒汉模式）" class="headerlink" title="手撕单例模式（懒汉模式）"></a>手撕单例模式（懒汉模式）</h2><h2 id="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"><a href="#情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统" class="headerlink" title="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"></a>情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统</h2><h2 id="模板元编程（简历上写了，但答的不好）"><a href="#模板元编程（简历上写了，但答的不好）" class="headerlink" title="模板元编程（简历上写了，但答的不好）"></a>模板元编程（简历上写了，但答的不好）</h2><h2 id="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"><a href="#编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的" class="headerlink" title="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"></a>编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的</h2><h2 id="怎么debug，怎么看内存泄漏。"><a href="#怎么debug，怎么看内存泄漏。" class="headerlink" title="怎么debug，怎么看内存泄漏。"></a>怎么debug，怎么看内存泄漏。</h2><h2 id="介绍一下条件变量"><a href="#介绍一下条件变量" class="headerlink" title="介绍一下条件变量"></a>介绍一下条件变量</h2><h2 id="一个对象-x3D-另一个对象会发生什么（赋值构造函数）"><a href="#一个对象-x3D-另一个对象会发生什么（赋值构造函数）" class="headerlink" title="一个对象&#x3D;另一个对象会发生什么（赋值构造函数）"></a>一个对象&#x3D;另一个对象会发生什么（赋值构造函数）</h2><h2 id="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"><a href="#如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）" class="headerlink" title="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"></a>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）</h2><h2 id="py修饰器"><a href="#py修饰器" class="headerlink" title="py修饰器"></a>py修饰器</h2><h2 id="函数重载的机制。重载是在编译期还是在运行期确定"><a href="#函数重载的机制。重载是在编译期还是在运行期确定" class="headerlink" title="函数重载的机制。重载是在编译期还是在运行期确定"></a>函数重载的机制。重载是在编译期还是在运行期确定</h2><h2 id="hash表数据很大。rehash的代价很高，怎么办"><a href="#hash表数据很大。rehash的代价很高，怎么办" class="headerlink" title="hash表数据很大。rehash的代价很高，怎么办"></a>hash表数据很大。rehash的代价很高，怎么办</h2><p>为字典的备用哈希表分配空间：</p><p>如果执行的是扩展操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)*2 的 2n（2 的 n 次方幂）</p><p>如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)的 2n</p><p>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始（为-1 时表示没有进行 rehash）。</p><p>rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当一次 rehash 工作完成之后，程序将 rehashidx 属性的值+1。同时在 serverCron 中调用 rehash 相关函数，在 1ms 的时间内，进行 rehash 处理，每次仅处理少量的转移任务(100 个元素)。</p><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为-1，表示 rehash 操作已完成。</p><h2 id="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"><a href="#最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。" class="headerlink" title="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"></a>最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。</h2><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h2 id="二叉树应用场景-底层结构"><a href="#二叉树应用场景-底层结构" class="headerlink" title="二叉树应用场景 底层结构"></a>二叉树应用场景 底层结构</h2><h2 id="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"><a href="#说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的" class="headerlink" title="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"></a>说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的</h2><h2 id="了解哪些算法，说一点———–我说了排序"><a href="#了解哪些算法，说一点———–我说了排序" class="headerlink" title="了解哪些算法，说一点———–我说了排序"></a>了解哪些算法，说一点———–我说了排序</h2><h2 id="介绍下快速排序的过程"><a href="#介绍下快速排序的过程" class="headerlink" title="介绍下快速排序的过程"></a>介绍下快速排序的过程</h2><h2 id="栈和队列的区别，在实际应用中的场景"><a href="#栈和队列的区别，在实际应用中的场景" class="headerlink" title="栈和队列的区别，在实际应用中的场景"></a>栈和队列的区别，在实际应用中的场景</h2><p>队列</p><p>队列是一种先进先出的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；<br>打印机：当多个任务分配给打印机时，为了防止冲突，创建一个队列，把任务入队，按先入先出的原则处理任务；<br>远程服务器：当多个用户要访问远程服务端的文件时，也用到队列，满足先来先服务的原则；<br>队列理论：用来计算 预测用户在队中的等待时间，队的长度等等问题；<br>常用于处理任务请求队列，例如在操作系统内部处理进程队列、在网络传输协议中处理数据包队列等。</p><p>栈</p><p>栈是一种后进先出的数据结构，也就是说最新添加的项最早被移出；它是一种运算受限的线性表，只能在栈顶进行插入和删除操作。向一个栈插入新元素叫入栈（进栈），就是把新元素放入到栈顶的上面，成为新的栈顶；从一个栈删除元素叫出栈，就是把栈顶的元素删除掉，相邻的成为新栈顶。</p><p>用于符号的匹配：在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。<br>用于计算代数式：如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题；先要把代数式构造成 6 4 8 * + 的形式；逐个读取数据，当读到数字时，把数字入栈；读到运算符时，弹出栈中的两个元素进行运算并把结果压入栈中；<br>构造表达式：比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。（先规定优先级，加减的优先级最低，左括号优先级最高）<br>用于函数调用：因为CPU一次只能执行一个命令，而寄存器也是公用的，当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()。能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。target() 函数执行结束就取栈顶的返回地址继续执行 current()。</p><h2 id="手撕二分查找。"><a href="#手撕二分查找。" class="headerlink" title="手撕二分查找。"></a>手撕二分查找。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp&quot;&gt;&lt;a href=&quot;#cpp&quot; class=&quot;headerlink&quot; title=&quot;cpp&quot;&gt;&lt;/a&gt;cpp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.dotcpp.com/course/808&quot;&gt;https://www.dotcpp.com</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>招商银行</title>
    <link href="http://example.com/p/26e6c52c.html"/>
    <id>http://example.com/p/26e6c52c.html</id>
    <published>2023-08-05T13:45:29.932Z</published>
    <updated>2023-08-10T14:11:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"><a href="#介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别" class="headerlink" title="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"></a>介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别</h3><h3 id="Innodb的事务和锁机制"><a href="#Innodb的事务和锁机制" class="headerlink" title="Innodb的事务和锁机制"></a>Innodb的事务和锁机制</h3><h3 id="Mysql如何保证事务的一致性，MVCC与锁介绍"><a href="#Mysql如何保证事务的一致性，MVCC与锁介绍" class="headerlink" title="Mysql如何保证事务的一致性，MVCC与锁介绍"></a>Mysql如何保证事务的一致性，MVCC与锁介绍</h3><h3 id="Innodb和Myisam的索引机制和存储结构"><a href="#Innodb和Myisam的索引机制和存储结构" class="headerlink" title="Innodb和Myisam的索引机制和存储结构"></a>Innodb和Myisam的索引机制和存储结构</h3><h3 id="Mysql的各种日志，以及介绍用途"><a href="#Mysql的各种日志，以及介绍用途" class="headerlink" title="Mysql的各种日志，以及介绍用途"></a>Mysql的各种日志，以及介绍用途</h3><h3 id="何时使用索引，什么时候索引会失效"><a href="#何时使用索引，什么时候索引会失效" class="headerlink" title="何时使用索引，什么时候索引会失效"></a>何时使用索引，什么时候索引会失效</h3><h3 id="单表访问用到的索引"><a href="#单表访问用到的索引" class="headerlink" title="单表访问用到的索引"></a>单表访问用到的索引</h3><h3 id="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"><a href="#查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析" class="headerlink" title="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"></a>查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析</h3><h3 id="如何解决sql注入"><a href="#如何解决sql注入" class="headerlink" title="如何解决sql注入"></a>如何解决sql注入</h3><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="你还有什么我没看到的优点，可以说一说（我是懵的）"><a href="#你还有什么我没看到的优点，可以说一说（我是懵的）" class="headerlink" title="你还有什么我没看到的优点，可以说一说（我是懵的）"></a>你还有什么我没看到的优点，可以说一说（我是懵的）</h3><h3 id="对工科有什么看法？？？"><a href="#对工科有什么看法？？？" class="headerlink" title="对工科有什么看法？？？"></a>对工科有什么看法？？？</h3><h3 id="开始问项目经验，项目经历-——————-出乎意料"><a href="#开始问项目经验，项目经历-——————-出乎意料" class="headerlink" title="开始问项目经验，项目经历 ——————- 出乎意料"></a>开始问项目经验，项目经历 ——————- 出乎意料</h3><h3 id="项目中怎么做的，遇到最大的问题是什么？你有什么突破"><a href="#项目中怎么做的，遇到最大的问题是什么？你有什么突破" class="headerlink" title="项目中怎么做的，遇到最大的问题是什么？你有什么突破"></a>项目中怎么做的，遇到最大的问题是什么？你有什么突破</h3><h3 id="如果不把他当成hr-会怎么描述这个项目？"><a href="#如果不把他当成hr-会怎么描述这个项目？" class="headerlink" title="如果不把他当成hr, 会怎么描述这个项目？"></a>如果不把他当成hr, 会怎么描述这个项目？</h3><h3 id="这个项目在实际中是怎么使用的？"><a href="#这个项目在实际中是怎么使用的？" class="headerlink" title="这个项目在实际中是怎么使用的？"></a>这个项目在实际中是怎么使用的？</h3><h3 id="去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？"><a href="#去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？" class="headerlink" title="去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？"></a>去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？</h3><h3 id="最有成就感的事情？"><a href="#最有成就感的事情？" class="headerlink" title="最有成就感的事情？"></a>最有成就感的事情？</h3><h3 id="对自己的优缺点评价？"><a href="#对自己的优缺点评价？" class="headerlink" title="对自己的优缺点评价？"></a>对自己的优缺点评价？</h3><h3 id="转Java愿意吗？"><a href="#转Java愿意吗？" class="headerlink" title="转Java愿意吗？"></a>转Java愿意吗？</h3><h3 id="对其他编程语言的看法？"><a href="#对其他编程语言的看法？" class="headerlink" title="对其他编程语言的看法？"></a>对其他编程语言的看法？</h3><h3 id="工作地倾向？"><a href="#工作地倾向？" class="headerlink" title="工作地倾向？"></a>工作地倾向？</h3><h3 id="目前投的其他岗位是什么情况？"><a href="#目前投的其他岗位是什么情况？" class="headerlink" title="目前投的其他岗位是什么情况？"></a>目前投的其他岗位是什么情况？</h3><h3 id="你有什么问题"><a href="#你有什么问题" class="headerlink" title="你有什么问题"></a>你有什么问题</h3><h3 id="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"><a href="#我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。" class="headerlink" title="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"></a>我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。</h3><h3 id="项目过程中遇到的问题"><a href="#项目过程中遇到的问题" class="headerlink" title="项目过程中遇到的问题"></a>项目过程中遇到的问题</h3><h3 id="最近学了什么、学习方法是什么"><a href="#最近学了什么、学习方法是什么" class="headerlink" title="最近学了什么、学习方法是什么"></a>最近学了什么、学习方法是什么</h3><h3 id="对新入手的项目有没有什么学习技巧"><a href="#对新入手的项目有没有什么学习技巧" class="headerlink" title="对新入手的项目有没有什么学习技巧"></a>对新入手的项目有没有什么学习技巧</h3><h3 id="家庭情况"><a href="#家庭情况" class="headerlink" title="家庭情况"></a>家庭情况</h3><h3 id="base地的问题"><a href="#base地的问题" class="headerlink" title="base地的问题"></a>base地的问题</h3><h3 id="对加班的看法、最大能接受的加班强度"><a href="#对加班的看法、最大能接受的加班强度" class="headerlink" title="对加班的看法、最大能接受的加班强度"></a>对加班的看法、最大能接受的加班强度</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;招商银行&quot;&gt;&lt;a href=&quot;#招商银行&quot; class=&quot;headerlink&quot; title=&quot;招商银行&quot;&gt;&lt;/a&gt;招商银行&lt;/h1&gt;&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQ</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++新特性</title>
    <link href="http://example.com/p/a70da3b7.html"/>
    <id>http://example.com/p/a70da3b7.html</id>
    <published>2023-08-04T07:51:59.656Z</published>
    <updated>2023-08-05T07:03:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="C-11-中的新特性"><a href="#C-11-中的新特性" class="headerlink" title="C++11 中的新特性"></a>C++11 中的新特性</h2><p>C++11 引入了许多新特性，包括自动类型推导、lambda 表达式、右值引用等。下面介绍其中的一些重要特性。</p><h3 id="自动类型推导（Type-Inference）"><a href="#自动类型推导（Type-Inference）" class="headerlink" title="自动类型推导（Type Inference）"></a>自动类型推导（Type Inference）</h3><p>C++11 中引入了 auto 关键字，它可以用于自动推导变量的类型。例如：</p><pre><code>auto i = 10; // 推导为 intauto name = &quot;John&quot;; // 推导为 const char*自动类型推导使得代码更加简洁，并且可以避免显式指定类型的麻烦。</code></pre><p>auto只能推导类型，推导出来的类型不能用来定义对象，decltype解决了这点，推导类型后可以用来定义对象。</p><pre><code>#include&lt;cstring&gt;int main()&#123;    int i = 10;    auto p = &amp;i;    decltype(p) pi;//int*    pi = &amp;i;    cout &lt;&lt; *pi &lt;&lt; endl;//10    return 0;&#125;</code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种用于定义匿名函数的语法。它可以在需要函数对象的地方使用，并且可以捕获上下文中的变量。例如：</p><pre><code>auto sum = [](int a, int b) &#123;    return a + b;&#125;;int result = sum(5, 3); // 调用 lambda 表达式</code></pre><p>Lambda 表达式提供了一种简洁的方式来定义和使用函数对象，特别是在需要传递函数作为参数的情况下。</p><h3 id="右值引用（Rvalue-References）"><a href="#右值引用（Rvalue-References）" class="headerlink" title="右值引用（Rvalue References）"></a>右值引用（Rvalue References）</h3><p>C++11 引入了右值引用，它允许我们绑定到临时对象（右值），并且可以实现移动语义和完美转发。右值引用由双引号 &amp;&amp; 表示。</p><h4 id="什么是左值和右值："><a href="#什么是左值和右值：" class="headerlink" title="什么是左值和右值："></a>什么是左值和右值：</h4><p>• 一般来说，位于&#x3D; 前的表达式为左值；存储在内存中、有明确存储地址（可取地址）的数据；<br>• 右值是指可以提供数据值的数据（不可取地址）。</p><pre><code>int&amp;&amp; rvalue = 42; // 绑定到右值 42</code></pre><h4 id="右值引用的主要作用和意义如下："><a href="#右值引用的主要作用和意义如下：" class="headerlink" title="右值引用的主要作用和意义如下："></a>右值引用的主要作用和意义如下：</h4><p>移动语义：右值引用可以用于实现移动语义，即将一个对象的资源所有权从一个对象转移给另一个对象，而不需要进行深拷贝或浅拷贝。例如：</p><pre><code>class MyString &#123;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_) &#123;        other.data_ = nullptr;        other.size_ = 0;    &#125;private:    char* data_;    size_t size_;&#125;;MyString str1(&quot;Hello&quot;);      // 创建一个 MyString 对象MyString str2(std::move(str1));  // 将 str1 转移给 str2</code></pre><p>在上述代码中，MyString 类定义了一个移动构造函数，用于将一个右值引用转移给一个新对象。在创建 str2 对象时，使用 std::move 函数将 str1 转移给 str2，从而避免了不必要的深拷贝和内存分配操作，提高了程序的性能和效率。</p><p>完美转发：右值引用可以用于实现完美转发，即在函数调用时将参数按照原样转发给其他函数，从而避免了不必要的复制和拷贝操作。例如：</p><pre><code>template&lt;typename T&gt;void process(T&amp;&amp; arg) &#123;    other_func(std::forward&lt;T&gt;(arg));  // 将 arg 按照原样转发给 other_func&#125;</code></pre><p>在上述代码中，process 函数接受一个右值引用参数 arg，并使用 std::forward 函数将 arg 按照原样转发给 other_func 函数，从而避免了不必要的复制和拷贝操作，提高了程序的性能和效率。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><pre><code>for (decl : expr) &#123;    // 循环体&#125;</code></pre><p>decl表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中.<br>expr是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。<br>基于范围的 for 循环遍历容器，示例代码如下：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123;    vector&lt;int&gt; t&#123; 1,2,3,4,5,6 &#125;;    for (const auto&amp; value : t) &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="C-14-中的新特性"><a href="#C-14-中的新特性" class="headerlink" title="C++14 中的新特性"></a>C++14 中的新特性</h2><p>C++14 对 C++11 进行了一些改进，并引入了一些新特性，例如变长模板参数、二进制字面量等。</p><h3 id="变长模板参数（Variadic-Templates）"><a href="#变长模板参数（Variadic-Templates）" class="headerlink" title="变长模板参数（Variadic Templates）"></a>变长模板参数（Variadic Templates）</h3><p>C++14 允许定义可变数量的模板参数，这被称为变长模板参数。通过使用省略号 …，可以在模板参数列表中指定任意数量的参数。例如：</p><pre><code>template &lt;typename... Args&gt;void print(Args... args) &#123;    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);&#125;print(1, &quot;hello&quot;, 3.14); // 输出: 1 hello 3.14</code></pre><p>变长模板参数提供了更大的灵活性，可以处理不同数量和类型的参数。   </p><h3 id="二进制字面量（Binary-Literals）"><a href="#二进制字面量（Binary-Literals）" class="headerlink" title="二进制字面量（Binary Literals）"></a>二进制字面量（Binary Literals）</h3><p>C++14 允许使用二进制字面量来表示二进制数值。使用前缀 0b 或 0B，后跟一串二进制数字。例如：</p><pre><code>int binary = 0b1010; // 二进制数值 10</code></pre><p>二进制字面量提供了一种直观和简洁的方式来表示和使用二进制数值。</p><h2 id="C-17-中的新特性"><a href="#C-17-中的新特性" class="headerlink" title="C++17 中的新特性"></a>C++17 中的新特性</h2><p>C++17 引入了一些有用的新特性，包括结构化绑定、折叠表达式、文件系统库等。</p><h3 id="结构化绑定（Structured-Bindings）"><a href="#结构化绑定（Structured-Bindings）" class="headerlink" title="结构化绑定（Structured Bindings）"></a>结构化绑定（Structured Bindings）</h3><p>结构化绑定允许将元组或其他复杂类型的成员解包并绑定到独立的变量中。这样可以方便地访问和操作复杂类型的成员。例如：</p><pre><code>std::pair&lt;int, std::string&gt; person&#123; 25, &quot;John&quot; &#125;;auto [age, name] = person;std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Name: &quot; &lt;&lt; name; // 输出: Age: 25, Name: John</code></pre><p>结构化绑定简化了处理复杂类型的过程，使代码更加简洁易读。</p><h3 id="折叠表达式（Fold-Expressions）"><a href="#折叠表达式（Fold-Expressions）" class="headerlink" title="折叠表达式（Fold Expressions）"></a>折叠表达式（Fold Expressions）</h3><p>折叠表达式是一种用于处理可变数量参数包的语法。它允许在模板展开过程中对参数包进行操作。例如：</p><pre><code>template &lt;typename... Args&gt;bool allTrue(Args... args) &#123;    return (true &amp;&amp; ... &amp;&amp; args);&#125;bool result = allTrue(true, true, false); // 返回 false</code></pre><p>折叠表达式提供了一种简洁的方式来处理参数包，可以在编译时对参数进行组合和计算。</p><h3 id="文件系统库（Filesystem-Library）"><a href="#文件系统库（Filesystem-Library）" class="headerlink" title="文件系统库（Filesystem Library）"></a>文件系统库（Filesystem Library）</h3><p>C++传统文件操作需要使用std::ifstream 和 std::ofstream 类：分别表示输入文件流和输出文件流，可以用于读写文件内容。例如:</p><pre><code>#include &lt;fstream&gt;#include &lt;iostream&gt;int main() &#123;    std::ifstream input_file(&quot;input.txt&quot;);  // 打开输入文件    if (!input_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open input file.\n&quot;;        return 1;    &#125;    std::ofstream output_file(&quot;output.txt&quot;);  // 打开输出文件    if (!output_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open output file.\n&quot;;        return 1;    &#125;    int num;    while (input_file &gt;&gt; num) &#123;  // 从输入文件中读取数字        output_file &lt;&lt; num * 2 &lt;&lt; &#39;\n&#39;;  // 将每个数字乘以 2 并写入输出文件    &#125;    input_file.close();   // 关闭输入文件    output_file.close();  // 关闭输出文件    return 0;&#125;</code></pre><p>C++17 引入了标准文件系统库，用于处理文件和目录的操作。该库提供了一组类和函数，用于创建、删除、移动、遍历文件和目录等操作。例如：</p><pre><code>#include &lt;filesystem&gt;namespace fs = std::filesystem;int main() &#123;    fs::path dir_path = &quot;dir&quot;;   // 定义目录路径    fs::create_directory(dir_path);  // 创建目录    fs::path file_path = dir_path / &quot;file.txt&quot;;  // 定义文件路径    fs::ofstream file(file_path);   // 打开文件    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file.\n&quot;;        return 1;    &#125;    file &lt;&lt; &quot;Hello, world!\n&quot;;  // 写入文件内容    file.close();  // 关闭文件    fs::remove(file_path);     // 删除文件    fs::remove(dir_path);      // 删除目录    return 0;&#125;</code></pre><p>文件系统库简化了文件和目录操作的实现，使得操作更加方便和可移植。</p><h2 id="C-20-中的新特性"><a href="#C-20-中的新特性" class="headerlink" title="C++20 中的新特性"></a>C++20 中的新特性</h2><p>C++20 引入了一系列新特性，包括概念、协程、三路比较运算符等。</p><h3 id="概念（Concepts）"><a href="#概念（Concepts）" class="headerlink" title="概念（Concepts）"></a>概念（Concepts）</h3><p>概念是 C++20 中的一项重要特性，用于对模板的类型参数进行约束。概念允许我们对类型进行条件检查，从而限制模板的实例化。例如：</p><pre><code>template &lt;typename T&gt;concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;template &lt;Arithmetic T&gt;T square(T value) &#123;    return value * value;&#125;int result = square(5); // 正确，T 为算术类型std::string str = &quot;hello&quot;;// 错误，T 不是算术类型int result = square(str);</code></pre><p>概念提供了一种声明式的方式来定义模板参数的约束条件，使代码更具表达力和安全性。</p><h3 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h3><p>C++20 引入了协程支持，使得异步编程更加简洁和可读。协程允许函数在执行期间暂停和恢复，以便于异步任务的处理。例如</p><pre><code>#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Generator &#123;    struct promise_type &#123;        int current_value;        auto get_return_object() &#123;            return Generator&#123; std::coroutine_handle&lt;promise_type&gt;::from_promise(*this) &#125;;        &#125;        auto initial_suspend() &#123;            return std::suspend_always&#123;&#125;;        &#125;        auto final_suspend() noexcept &#123;            return std::suspend_always&#123;&#125;;        &#125;        void return_void() &#123;&#125;        auto yield_value(int value) &#123;            current_value = value;            return std::suspend_always&#123;&#125;;        &#125;        void unhandled_exception() &#123;            std::terminate();        &#125;    &#125;;    std::coroutine_handle&lt;promise_type&gt; coroutine;    bool move_next() &#123;        coroutine.resume();        return !coroutine.done();    &#125;    int current_value() &#123;        return coroutine.promise().current_value;    &#125;&#125;;Generator generate() &#123;    co_yield 1;    co_yield 2;    co_yield 3;&#125;int main() &#123;    Generator generator = generate();    while (generator.move_next()) &#123;        std::cout &lt;&lt; generator.current_value() &lt;&lt; &quot; &quot;;    &#125;    // 输出: 1 2 3    return 0;&#125;</code></pre><p>协程提供了一种简洁的方式来编写异步代码，提高了代码的可读性和可维护性。</p><h3 id="三路比较运算符（Three-Way-Comparison）"><a href="#三路比较运算符（Three-Way-Comparison）" class="headerlink" title="三路比较运算符（Three-Way Comparison）"></a>三路比较运算符（Three-Way Comparison）</h3><p>C++20 引入了三路比较运算符（&lt;&#x3D;&gt;），用于比较对象的大小关系。它返回一个可比较的结果，可以是小于、等于或大于。例如：</p><pre><code>struct Person &#123;    std::string name;    int age;    auto operator&lt;=&gt;(const Person&amp; other) const = default;//auto表示函数的返回类型将由编译器自动推导.在这里，返回类型将会是一个 std::strong_ordering 类型，这是 C++20 引入的一种枚举类型，用于表示强制排序关系。//= default：这个关键字表示使用默认实现，即使用编译器自动生成的代码来实现这个成员函数。在这里，编译器会自动生成一个使用 spaceship 运算符比较对象的代码。&#125;;Person john&#123;&quot;John&quot;, 25&#125;;Person alice&#123;&quot;Alice&quot;, 30&#125;;if (john &lt; alice) &#123;    std::cout &lt;&lt; &quot;John is younger than Alice.&quot;;&#125; else if (john &gt; alice) &#123;    std::cout &lt;&lt; &quot;John is older than Alice.&quot;;&#125; else &#123;    std::cout &lt;&lt; &quot;John and Alice have the same age.&quot;;&#125;</code></pre><p>三路比较运算符简化了比较操作的实现，提供了一种统一和直观的比较语法。</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-新特性&quot;&gt;&lt;a href=&quot;#C-新特性&quot; class=&quot;headerlink&quot; title=&quot;C++新特性&quot;&gt;&lt;/a&gt;C++新特性&lt;/h1&gt;&lt;h2 id=&quot;C-11-中的新特性&quot;&gt;&lt;a href=&quot;#C-11-中的新特性&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/p/2f57a694.html"/>
    <id>http://example.com/p/2f57a694.html</id>
    <published>2023-08-04T07:15:38.713Z</published>
    <updated>2023-08-04T10:00:36.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式是一种以字符串匹配为核心的强大的文本处理工具。通过一系列特殊字符和限定条件，正则表达式可以精确地描述一个文本片段的特征，从而达到将匹配的文本内容从整体文本中筛选出来的目的。它的核心功能就是在文本中查找符合指定规律的模式，这种模式可以是字符、字符组合或者字符范围，正则表达式就是定义这些规律的方式和规则。</p><h2 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h2><ul><li>字符匹配：<ul><li>普通字符：正则表达式中的普通字符表示自身，例如 a 匹配字符 “a”。</li><li>字符类：使用方括号 [ ] 来匹配一组字符中的任意一个字符，例如 [abc] 匹配字符 “a”、”b” 或 “c”。</li><li>转义字符：使用反斜杠 \ 来转义特殊字符，例如 . 匹配字符 “.”。</li></ul></li><li>重复匹配：<ul><li><em>：匹配前一个元素零次或多次，例如 a</em> 匹配零个或多个字符 “a”。</li><li>+：匹配前一个元素一次或多次，例如 a+ 匹配一个或多个字符 “a”。</li><li>?：匹配前一个元素零次或一次，例如 a? 匹配零个或一个字符 “a”。</li><li>{n}：匹配前一个元素恰好 n 次，例如 a{3} 匹配恰好三个字符 “a”。</li><li>{n,}：匹配前一个元素至少 n 次，例如 a{3,} 匹配至少三个字符 “a”。</li><li>{n,m}：匹配前一个元素至少 n 次，最多 m 次，例如 a{3,5} 匹配三到五个字符 “a”。</li></ul></li><li>特殊字符：<ul><li>.：匹配任意字符，除了换行符。</li><li>^：匹配输入字符串的开始位置。</li><li>$：匹配输入字符串的结束位置。</li><li>\b：匹配单词边界。</li><li>\d：匹配任意数字。</li><li>\w：匹配任意字母、数字或下划线。</li><li>\s：匹配任意空白字符。</li></ul></li><li>分组和捕获：<ul><li>()：用于分组，并且可以捕获分组的内容用于后续引用。</li></ul></li><li>选择符：<ul><li>|：用于在多个模式之间进行选择，例如 a|b 匹配字符 “a” 或 “b”。<br>这只是正则表达式的基本语法，还有更多高级的用法和特性。不同编程语言和工具对正则表达式的支持和语法也可能有所差异.</li></ul></li></ul><h2 id="C-和Qt-正则表达式的实现方法"><a href="#C-和Qt-正则表达式的实现方法" class="headerlink" title="C++ 和Qt 正则表达式的实现方法"></a>C++ 和Qt 正则表达式的实现方法</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>可以使用标准库中的正则表达式库 regex 来实现正则表达式的功能。以下是使用C++标准库的方法：<br>包含头文件：</p><pre><code>#include &lt;regex&gt;  </code></pre><p>创建正则表达式对象：</p><pre><code>std::regex regexObj(&quot;pattern&quot;);  //这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>std::string str = &quot;input string&quot;;  std::smatch match;  bool isMatch = std::regex_search(str, match, regexObj);  </code></pre><p>这里的 str 是你要匹配的字符串。match 是一个 std::smatch 对象,可以通过索引来访问匹配的子字符串,用于存储匹配结果。regex_search 函数用于搜索字符串中的第一个匹配项。</p><p>遍历匹配结果：</p><pre><code>for (size_t i = 0; i &lt; match.size(); ++i) &#123;      std::cout &lt;&lt; match[i] &lt;&lt; std::endl;  &#125;  </code></pre><h3 id="在Qt中"><a href="#在Qt中" class="headerlink" title="在Qt中"></a>在Qt中</h3><p>Qt提供了自己的正则表达式类 QRegularExpression 来处理正则表达式。以下是使用Qt的方法：<br>包含头文件：</p><pre><code>#include &lt;QRegularExpression&gt;  2. 创建正则表达式对象：QRegularExpression regexObj(&quot;pattern&quot;);  这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>QString str = &quot;input string&quot;;  QRegularExpressionMatch match = regexObj.match(str);  //这里的 str 是你要匹配的字符串。match 是一个 QRegularExpressionMatch 对象，用于存储匹配结果。match 对象提供了一组方法来访问匹配的子字符串。</code></pre><p>遍历匹配结果：</p><pre><code>while (match.hasMatch()) &#123;      QString matchedStr = match.captured();      // 处理匹配的子字符串      match = regexObj.match(str, match.capturedEnd());  &#125;  </code></pre><p>通过调用 captured 方法可以获取匹配的子字符串。capturedEnd 方法返回上一个匹配结束的位置，用于在字符串中继续搜索下一个匹配项。</p><h2 id="正则表达式的应用案例"><a href="#正则表达式的应用案例" class="headerlink" title="正则表达式的应用案例"></a>正则表达式的应用案例</h2><h3 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h3><p>以下是一个使用 Qt 的正则表达式实现文本匹配的示例：<br>    #include <QRegularExpression><br>    #include <QDebug>  </QDebug></QRegularExpression></p><pre><code>int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched word: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。该正则表达式会匹配由小写字母组成的单词,输出结果是整句话中的每个单词。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>以下是一个使用 Qt 的正则表达式实现字符串替换的示例：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QString replacedStr = str.replace(regex, &quot;REPLACED&quot;);      qDebug() &lt;&lt; &quot;Replaced string: &quot; &lt;&lt; replacedStr;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。然后，使用 replace 函数将匹配到的单词替换为 “REPLACED”。<br>输出结果会显示替换后的字符串：</p><pre><code>Replaced string: &quot;The REPLACED REPLACED REPLACED jumps over the REPLACED REPLACED.&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来实现字符串替换。</p><h3 id="提取字符串中的邮箱地址"><a href="#提取字符串中的邮箱地址" class="headerlink" title="提取字符串中的邮箱地址"></a>提取字符串中的邮箱地址</h3><p>下面使用 Qt 的正则表达式的实例，它演示了如何使用正则表达式来验证和提取字符串中的邮箱地址：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;My email is john.doe@example.com and another email is jane@example.com&quot;;      QRegularExpression regex(&quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched email: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>使用了一个正则表达式来匹配邮箱地址的模式。正则表达式 \b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b 匹配标准的邮箱地址格式。<br>输出结果会显示匹配到的邮箱地址：</p><pre><code>Matched email:  &quot;john.doe@example.com&quot;  Matched email:  &quot;jane@example.com&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来验证和提取字符串中的邮箱地址。</p><h2 id="正则表达式的扩展和优化"><a href="#正则表达式的扩展和优化" class="headerlink" title="正则表达式的扩展和优化"></a>正则表达式的扩展和优化</h2><h3 id="使用正则表达式的进阶技巧"><a href="#使用正则表达式的进阶技巧" class="headerlink" title="使用正则表达式的进阶技巧"></a>使用正则表达式的进阶技巧</h3><p>在Qt中，使用正则表达式进行一些进阶技巧的操作，可以增强正则表达式的功能和灵活性。以下是一些常见的Qt正则表达式的进阶技巧：</p><h4 id="捕获组（Capturing-Group）"><a href="#捕获组（Capturing-Group）" class="headerlink" title="捕获组（Capturing Group）"></a>捕获组（Capturing Group）</h4><p>使用括号将正则表达式的一部分括起来，可以将这部分内容作为一个捕获组。捕获组可以通过indexIn()函数的捕获组索引或capturedTexts()函数的捕获组名来获得匹配的子字符串。<br>QString input &#x3D; “Hello World”;<br>QRegExp regex(“Hello (\w+)”);  </p><p>if (regex.indexIn(input) !&#x3D; -1) {<br>    QString match &#x3D; regex.cap(0); &#x2F;&#x2F; 整个匹配的字符串<br>    QString capturingGroup &#x3D; regex.cap(1); &#x2F;&#x2F; 捕获组中的内容<br>}  </p><h4 id="替换（Replacement）："><a href="#替换（Replacement）：" class="headerlink" title="替换（Replacement）："></a>替换（Replacement）：</h4><p>使用QRegExp类的replace()函数可以进行替换操作，将匹配的部分替换为指定的内容。</p><pre><code>QString input = &quot;Hello, Alice!&quot;;  QRegExp regex(&quot;Alice&quot;);  QString replaced = input.replace(regex, &quot;Bob&quot;);  qDebug() &lt;&lt; &quot;Replaced: &quot; &lt;&lt; replaced; // Hello, Bob!  </code></pre><h4 id="最短匹配（Non-greedy）"><a href="#最短匹配（Non-greedy）" class="headerlink" title="最短匹配（Non-greedy）"></a>最短匹配（Non-greedy）</h4><p>使用问号（?）可以使量词变为最短匹配，即尽可能少地匹配字符。</p><pre><code>QString input = &quot;Hello &lt;b&gt;World&lt;/b&gt;!&quot;;  QRegExp regex(&quot;&lt;.*?&gt;&quot;);  int pos = regex.indexIn(input);  if (pos != -1) &#123;      QString match = regex.cap(0); // &lt;b&gt;  &#125;  </code></pre><h4 id="全局匹配（Global-Match）："><a href="#全局匹配（Global-Match）：" class="headerlink" title="全局匹配（Global Match）："></a>全局匹配（Global Match）：</h4><p>使用globalMatch()函数可以进行全局匹配，找到输入字符串中的所有匹配项。</p><pre><code>QString input = &quot;Hello, Alice! How are you, Alice?&quot;;  QRegExp regex(&quot;Alice&quot;);  QRegExpIterator iter(input, regex);  while (iter.hasNext()) &#123;      iter.next();      QString match = iter.value(); // Alice  &#125;  </code></pre><p>这些是一些Qt中正则表达式的进阶技巧，可以根据具体需求进行使用。</p><h3 id="利用正则表达式的编译器和解释器"><a href="#利用正则表达式的编译器和解释器" class="headerlink" title="利用正则表达式的编译器和解释器"></a>利用正则表达式的编译器和解释器</h3><p>在Qt中，有两个主要的正则表达式引擎：QRegExp和QRegularExpression。</p><h4 id="QRegExp"><a href="#QRegExp" class="headerlink" title="QRegExp"></a>QRegExp</h4><p>QRegExp是Qt早期版本中使用的正则表达式引擎。它基于C++标准库中的正则表达式功能，并在其基础上添加了一些Qt特定的扩展。QRegExp是一个解释器，它在运行时解释和匹配正则表达式。尽管QRegExp功能强大，但它不是完全兼容于Perl正则表达式语法，并且在处理大型文本时可能存在性能问题。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegExp regex(&quot;Hello (\\w+)&quot;);  if (regex.indexIn(input) != -1) &#123;      QString match = regex.cap(0); // 整个匹配的字符串      QString capturingGroup = regex.cap(1); // 捕获组中的内容  &#125;  </code></pre><h4 id="QRegularExpression"><a href="#QRegularExpression" class="headerlink" title="QRegularExpression"></a>QRegularExpression</h4><p>从Qt 5开始，引入了QRegularExpression作为新的正则表达式引擎。QRegularExpression是一个编译器，它在使用正则表达式之前将其编译成一个内部表示形式，这样可以提高效率。它也支持Perl正则表达式语法的大部分功能，并且在性能方面更优于QRegExp。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegularExpression regex(&quot;Hello (\\w+)&quot;);  QRegularExpressionMatch match = regex.match(input);  if (match.hasMatch()) &#123;      QString captured = match.captured(0); // 整个匹配的字符串      QString capturingGroup = match.captured(1); // 捕获组中的内容  &#125;  </code></pre><p>无论是QRegExp还是QRegularExpression，都可以用于正则表达式的匹配、搜索和替换等操作，但在新的代码中推荐使用QRegularExpression，以获得更好的性能和更强大的功能。</p><h4 id="正则表达式的插件和辅助工具"><a href="#正则表达式的插件和辅助工具" class="headerlink" title="正则表达式的插件和辅助工具"></a>正则表达式的插件和辅助工具</h4><p>有一些独立的正则表达式插件和辅助工具可用于不同的开发环境和编辑器。以下是一些常见的正则表达式插件和辅助工具：</p><ol><li>RegexBuddy：这是一个强大的独立工具，用于创建、调试和测试正则表达式。它提供了一个直观的界面，可以可视化地构建和编辑正则表达式，并提供实时的匹配结果和错误提示。</li><li>RegExpert：这是一个在线的正则表达式调试器和测试工具，可以帮助您验证和调试正则表达式。它提供了一个交互式界面，可以实时检查输入文本的匹配结果，并显示匹配的子字符串和捕获组。</li><li>regex101：这是一个在线的正则表达式测试和学习平台，提供了一个交互式界面，可以输入正则表达式和测试文本，并实时显示匹配结果、捕获组和匹配的解释。</li><li>RegExr：这是一个基于Web的正则表达式工具，提供了一个交互式界面，可以可视化地构建和测试正则表达式。它还提供了实时的匹配结果和错误提示，以及一个正则表达式库和示例。<br>这些正则表达式插件和辅助工具可以帮助您更方便地创建、调试和测试正则表达式，提高开发效率和准确性。</li></ol><h2 id="正则表达式的陷阱和注意事项"><a href="#正则表达式的陷阱和注意事项" class="headerlink" title="正则表达式的陷阱和注意事项"></a>正则表达式的陷阱和注意事项</h2><p>在使用正则表达式时，有一些常见的陷阱和注意事项需要注意。以下是一些常见的陷阱和注意事项：</p><ul><li>贪婪匹配：默认情况下，正则表达式是贪婪匹配的，即它会尽可能多地匹配字符。如果您想要最短匹配，可以使用非贪婪量词（如*?，+?，??）或限定符的最小化形式。</li><li>转义字符：在正则表达式中，某些字符具有特殊含义，如点号（.）、星号（<em>）、加号（+）、问号（?）等。如果需要匹配这些特殊字符本身，需要使用反斜杠进行转义（如.、</em>、+、?）。</li><li>转义序列：正则表达式中有一些特殊的转义序列，如\d表示任意一个数字字符，\w表示任意一个字母、数字或下划线字符。这些转义序列可以用于简化正则表达式的编写。</li><li>字符边界：在正则表达式中，\b表示单词边界，即单词字符和非单词字符之间的位置。但请注意，\b在C++字符串中也是转义字符，所以需要使用双反斜杠（\b）来匹配单词边界。</li><li>捕获组编号：在一些正则表达式引擎中，捕获组的编号是从1开始的，而不是从0开始。因此，在访问捕获组时需要注意编号的对应关系。</li><li>性能问题：某些复杂的正则表达式可能会导致性能问题，特别是在处理大型文本时。尽量避免使用过于复杂的正则表达式，可以考虑将其拆分为多个简单的正则表达式。</li><li>Unicode支持：如果需要处理Unicode字符，确保使用支持Unicode的正则表达式引擎，并使用相应的Unicode转义序列和属性。</li><li>测试和验证：在编写正则表达式之前，建议使用测试工具或在线正则表达式测试平台来验证和调试您的正则表达式，以确保其正确性和预期的匹配结果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>database/sql</title>
    <link href="http://example.com/p/cacc0385.html"/>
    <id>http://example.com/p/cacc0385.html</id>
    <published>2023-08-03T01:17:25.682Z</published>
    <updated>2023-08-03T03:37:59.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-database-x2F-sql-在-Go-中进行数据库操作的简介"><a href="#使用-database-x2F-sql-在-Go-中进行数据库操作的简介" class="headerlink" title="使用 database&#x2F;sql 在 Go 中进行数据库操作的简介"></a>使用 database&#x2F;sql 在 Go 中进行数据库操作的简介</h1><p>公司需要用到database&#x2F;sql，在 Go 中使用 SQL 或类似 SQL 的数据库的惯用方法是通过 database&#x2F;sql 包。它为面向行的数据库提供了一个轻量级接口。看完以后觉得和JDBC差不多。英语无障碍可以参照<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sql.DB</code> 并不是直接的数据库连接，它是数据库的抽象接口，它也不映射到任何特定数据库软件的“数据库”或“模式”概念。数据库可能像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。。它负责打开和关闭数据库连接，并管理连接池。正在使用的连接会被标记为繁忙，用完后会返回连接池等待下次使用。如果没有将连接释放回连接池，可能导致过多连接，从而耗尽系统资源。sql.DB不是数据库连接。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>要连接数据库，我们首先需要导入相应的驱动，具体取决于我们使用的数据库。例如，我们考虑使用 MySQL：</p><pre><code class="go">import (    &quot;database/sql&quot;    _ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123;    db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)    if err != nil &#123;        log.Fatal(err)    &#125;    defer db.Close()&#125;</code></pre><p><code>sql.Open()</code> 函数的第一个参数是驱动名称，第二个参数是连接数据库的信息。我们可以立即使用 <code>Ping()</code> 方法验证连接。</p><pre><code class="go">err = db.Ping()if err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>需要注意的是，<code>sql.DB</code> 被设计为长连接。频繁地进行 <code>Open()</code> 和 <code>Close()</code> 操作是不推荐的。最佳实践是为每个不同的数据存储创建一个 <code>DB</code> 对象，并保持这些对象的打开状态。如果需要短连接，请将 <code>DB</code> 对象作为参数传递给函数，而不是在函数中打开和关闭连接。</p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>如果方法涉及查询并返回多行结果，我们可以使用 <code>Query()</code>。对于其他操作，例如 INSERT、UPDATE 和 DELETE，我们使用 <code>Exec()</code>。</p><pre><code class="go">var (    id   int    name string)rows, err := db.Query(&quot;SELECT id, name FROM users WHERE id = ?&quot;, 1)if err != nil &#123;    log.Fatal(err)&#125;defer rows.Close()for rows.Next() &#123;    err := rows.Scan(&amp;id, &amp;name)    if err != nil &#123;        log.Fatal(err)    &#125;    log.Println(id, name)&#125;err = rows.Err()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><p>在迭代行时务必检查错误，并使用 <code>rows.Close()</code> 关闭结果集以释放底层连接。</p><p>对于单行查询，我们可以使用 <code>QueryRow()</code>：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    log.Fatal(err)&#125;fmt.Println(name)</code></pre><h2 id="修改数据和事务"><a href="#修改数据和事务" class="headerlink" title="修改数据和事务"></a>修改数据和事务</h2><p>对于 INSERT、UPDATE 和 DELETE 操作，我们使用预编译语句和 <code>Exec()</code>：<br>预处理执行过程：</p><ul><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ul><p>为什么要预处理？</p><ul><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ul><pre><code class="go">stmt, err := db.Prepare(&quot;INSERT INTO users (name) VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;res, err := stmt.Exec(&quot;Dolly&quot;)if err != nil &#123;    log.Fatal(err)&#125;lastId, err := res.LastInsertId()if err != nil &#123;    log.Fatal(err)&#125;rowCnt, err := res.RowsAffected()if err != nil &#123;    log.Fatal(err)&#125;log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)</code></pre><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。<br>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><p>要执行事务，我们使用 <code>Begin()</code>、<code>Commit()</code> 和 <code>Rollback()</code>：</p><pre><code class="go">tx, err := db.Begin()if err != nil &#123;    log.Fatal(err)&#125;defer tx.Rollback()stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;defer stmt.Close()for i := 0; i &lt; 10; i++ &#123;    _, err = stmt.Exec(i)    if err != nil &#123;        log.Fatal(err)    &#125;&#125;err = tx.Commit()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在与数据库交互时，适当处理错误非常重要。例如，在迭代 <code>Rows</code> 时检查错误并关闭结果集：</p><pre><code class="go">for rows.Next() &#123;    // ...&#125;if err = rows.Err(); err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>如果在迭代所有行之前退出循环，必须手动关闭结果集并处理错误：</p><pre><code class="go">for rows.Next() &#123;    // ...    break&#125;if err = rows.Close(); err != nil &#123;    log.Println(err)&#125;</code></pre><p>对于单行查询，需要单独处理 <code>ErrNoRows</code> 错误：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    if err == sql.ErrNoRows &#123;        // 处理没有找到行的情况    &#125; else &#123;        log.Fatal(err)    &#125;&#125;fmt.Println(name)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot;&gt;&lt;a href=&quot;#使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot; class=&quot;headerlink&quot; title=&quot;使用 database&amp;#x2F;sql</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>七层协议</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-31T14:30:47.327Z</published>
    <updated>2023-07-31T14:41:15.404Z</updated>
    
    <content type="html"><![CDATA[<p>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线<br>数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）<br>传输层：TCP（T&#x2F;TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS&#x2F;SSL<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP&#x2F;2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP</p><h2 id="TCP和UDP的-区别"><a href="#TCP和UDP的-区别" class="headerlink" title="TCP和UDP的 区别"></a>TCP和UDP的 区别</h2><p>TCP是面向有连接型，UDP是面向无连接型；<br>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；<br>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；<br>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线&lt;br&gt;数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）&lt;br&gt;网络层：IP、ICMP、AR</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
