<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-16T09:28:00.041Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/1f4ac2fb.html"/>
    <id>http://example.com/p/1f4ac2fb.html</id>
    <published>2023-07-16T09:10:58.637Z</published>
    <updated>2023-07-16T09:28:00.041Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-栈categories-算法与数据结构"><a href="#title-栈categories-算法与数据结构" class="headerlink" title="title: 栈categories: 算法与数据结构"></a>title: 栈<br>categories: 算法与数据结构</h2><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20,155,232,844,224,682,496.</p><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><pre><code>class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;stk;        map&lt;char,char&gt;table;        table.insert(&#123;&#39;(&#39;,&#39;)&#39;&#125;);        table.insert(&#123;&#39;[&#39;,&#39;]&#39;&#125;);        table.insert(&#123;&#39;&#123;&#39;,&#39;&#125;&#39;&#125;);        for(auto c:s)        &#123;            if(c==&#39;(&#39;||c==&#39;[&#39;||c==&#39;&#123;&#39;)            &#123;                stk.push(c);            &#125;            else            &#123;                if(stk.size()&amp;&amp;table[stk.top()]==c)                &#123;                    stk.pop();                &#125;                else&#123;                    return false;                &#125;            &#125;        &#125;        if(stk.size())return false;        return true;    &#125;&#125;;</code></pre><p>坑点有很多，比如每次pop需要注意栈非空，匹配结束如果栈有值则失败，思路想的时候很好代码实现总是遗漏要点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-栈categories-算法与数据结构&quot;&gt;&lt;a href=&quot;#title-栈categories-算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;title: 栈categories: 算法与数据结构&quot;&gt;&lt;/a&gt;titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/p/2362a8ea.html"/>
    <id>http://example.com/p/2362a8ea.html</id>
    <published>2023-07-16T07:09:58.247Z</published>
    <updated>2023-07-16T09:10:20.004Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr) &#123;            ListNode* next = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;;</code></pre><h2 id="判断环形链表"><a href="#判断环形链表" class="headerlink" title="判断环形链表"></a>判断环形链表</h2><pre><code>class Solution &#123;public:    bool hasCycle(ListNode* head) &#123;        ListNode* slow = head;        ListNode* fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if (fast == slow) &#123;    // 如果快慢指针相遇                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><pre><code>class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead = new ListNode(-1);        ListNode* prev = preHead;        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;            if (l1-&gt;val &lt; l2-&gt;val) &#123;                prev-&gt;next = l1;                l1 = l1-&gt;next;            &#125; else &#123;                prev-&gt;next = l2;                l2 = l2-&gt;next;            &#125;            prev = prev-&gt;next;        &#125;        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev-&gt;next = l1 == nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;</code></pre><h2 id="删除倒数节点"><a href="#删除倒数节点" class="headerlink" title="删除倒数节点"></a>删除倒数节点</h2><pre><code>class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        auto first=head;        auto second=first;        for(int i=0;i&lt;n;i++)&#123;            second=second-&gt;next;        &#125;        if(second==nullptr)return head-&gt;next;        second=second-&gt;next;        while(second!=nullptr)        &#123;            first=first-&gt;next;            second=second-&gt;next;        &#125;        auto temp=first-&gt;next;        first-&gt;next=temp-&gt;next;        delete temp;        return head;    &#125;&#125;;</code></pre><h2 id="返回中点"><a href="#返回中点" class="headerlink" title="返回中点"></a>返回中点</h2><pre><code>class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        auto slow=head;        auto fast=head;        while(fast&amp;&amp;fast-&gt;next)        &#123;            slow=slow-&gt;next;            fast=fast-&gt;next-&gt;next;        &#125;        return slow;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;单链表反转&lt;/li&gt;
&lt;li&gt;链表中环的检测&lt;/li&gt;
&lt;li&gt;两个有序的链表合并&lt;/li&gt;
&lt;li&gt;删除链表倒数第 </summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly与Rust实践</title>
    <link href="http://example.com/p/13592136.html"/>
    <id>http://example.com/p/13592136.html</id>
    <published>2023-07-13T13:57:09.666Z</published>
    <updated>2023-07-14T02:17:14.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly与Rust实践"><a href="#WebAssembly与Rust实践" class="headerlink" title="WebAssembly与Rust实践"></a>WebAssembly与Rust实践</h1><div class="row">    <embed src="../../../pdf/WebAssembly与Rust实践.pdf" width="100%" height="550" type="application/pdf"></div><p>注：pdf为本人编写，不需要用图床比较方便，用图太多实在不想整理到博客了，下面内容不全，真心求教大佬们有没有什么魔法可以markdown粘贴图片绑定图床自动生成链接。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Rust编程语言和WebAssembly（Wasm）都是由Mozilla推动的前沿技术，并且它们在许多方面相互补充。<strong>Rust正致力于成为WebAssembly的首选编程语言</strong>。<br>Rust语言的最大特色之一是在保证系统性能的同时提供内存安全性。通过其所有权系统、借用检查器和生命周期规则，Rust可以在编译时捕获内存安全错误，避免了许多常见的内存错误，如空指针引用、数据竞争等。这使得Rust成为开发高性能、安全和可靠系统级软件的理想选择。<br>WebAssembly是一种可移植的低级字节码格式，可以在Web环境中运行。它的目标是在不同平台和语言之间提供统一的执行环境，并以接近原生的性能运行代码。WebAssembly允许以高效且安全的方式在Web浏览器中执行性能敏感的任务，同时保持与底层平台的兼容性。<br>Rust语言在与WebAssembly的结合方面有很多优势。Rust从诞生之初就考虑到与C语言的兼容性，使得使用Rust编写的代码可以直接与C语言的二进制接口（ABI）进行交互。这使得Rust成为编写WebAssembly模块的理想语言之一。Rust的Cargo包管理工具也为构建、打包和发布WebAssembly模块提供了便利。通过使用Rust和WebAssembly，开发人员可以借助Rust语言的安全性和性能优势，同时利用WebAssembly的跨平台和高性能特性，构建出功能强大、高效且安全的Web应用程序、浏览器扩展、游戏和其他Web平台的应用。</p><h2 id="安装WebAssembly开发环境"><a href="#安装WebAssembly开发环境" class="headerlink" title="安装WebAssembly开发环境"></a>安装WebAssembly开发环境</h2><p>Rust是目前WebAssembly生态中支持力度最强的一种语言。开源社区中不仅有Rust语言开发的WebAssembly虚拟机，还有基于WebAssembly模块的管理工具。<br>Rust语言默认安装的是生成本地应用的开发环境，因此WebAssembly开发环境需要单独安装。<br>首先查看有哪些环境可以安装：</p><pre><code> rustup target list | grep wasm</code></pre><p>运行结果如下所示：<br>• rustup target add wasm32-wasi：<br>    ◦ 这个指令将把wasm32-wasi目标加入到Rust工具链中。wasm32-wasi是用于WebAssembly系统接口(WASI)的目标，WASI是一种与操作系统无关的WebAssembly运行环境，允许在不同平台上运行WebAssembly模块。<br>• rustup target add wasm32-unknown-emscripten：<br>    ◦ 为了将 wasm32-unknown-emscripten 目标添加到 Rust 工具链，需要运行以下命令。wasm32-unknown-emscripten 是 Emscripten 工具链提供的一个目标，它能够将 Rust 代码编译为适用于浏览器环境的 WebAssembly 模块。<br>• rustup target add wasm32-unknown-unknown：<br>    ◦ 此命令将在 Rust 工具链中添加 wasm32-unknown-unknown 目标。wasm32-unknown-unknown 目标是一个通用的 WebAssembly 目标，适用于在不特定于操作系统或运行时环境的情况下构建 WebAssembly 模块。</p><p>了解环境之后，我们可以通过以下命令安装：</p><pre><code>rustup target add wasm32-wasirustup target add wasm32-unknown-emscriptenrustup target add wasm32-unknown-unknown</code></pre><p>为了方便测试和运行WebAssembly模块，还需要安装wasmer虚拟机环境。使用Scoop：</p><pre><code>scoop install wasmer</code></pre><p>安装成功之后，输入以下命令查看wasmer版本信息：</p><pre><code>wasmer -h</code></pre><h2 id="将Rust编译为wasm"><a href="#将Rust编译为wasm" class="headerlink" title="将Rust编译为wasm"></a>将Rust编译为wasm</h2><p>我们仍然使用刚才的入门测试程序，打印你好，世界！<br>然后，在编译时指定目标为wasm32-wasi：</p><pre><code>cargo build --target=wasm32-wasi</code></pre><p>在src同级目录下面，target&#x2F;wasm32-wasi&#x2F;debug&#x2F;内已经生成了对应的hello.wasm文件。<br>最后，通过wasmer工具运行该程序文件</p><pre><code>wasmer run target/wasm32-wasi/debug/hello.wasm</code></pre><p>可以看到程序正常输出</p><h2 id="导入和导出函数"><a href="#导入和导出函数" class="headerlink" title="导入和导出函数"></a>导入和导出函数</h2><h3 id="导出main-函数"><a href="#导出main-函数" class="headerlink" title="导出main()函数"></a>导出main()函数</h3><p>当在 Rust 中构建 WebAssembly 模块时，导入和导出函数是实现与宿主环境进行交互的关键部分。通过导入函数，可以在 Rust 模块中调用宿主环境中提供的功能，而通过导出函数，可以将 Rust 函数暴露给宿主环境使用。<br>上面测试时编译目标为wasm32-wasi，因此程序只能在宿主支持的WASI虚拟机环境运行。现在，我们设置编译目标为wasm32-unknown-unknown（即纯WebAssembly环境），然后查看其导出的函数。<br>输入以下命令重新构建：</p><pre><code>cargo build --target wasm32-unknown-unknown</code></pre><p>默认生成.&#x2F;target&#x2F;wasm32-unknown-unknown&#x2F;debug&#x2F;hello.wasm</p><p>可以看到我们已经导出了main函数。</p><p>我们还可以在Node.js环境，通过console.dir()调试函数查看导出的内容，在wasm对应目录下创建hello.js文件：</p><pre><code>const fs = require(&#39;fs&#39;);//readFileSync文件读取会阻塞代码的执行，直到读取完成const buf = fs.readFileSync(&#39;./hello.wasm&#39;);WebAssembly.instantiate(new Uint8Array(buf)).then(function(result) &#123;    console.dir(result.instance.exports);&#125;);</code></pre><p>运行代码，得到以下输出:</p><p>这说明普通的应用程序默认导出了main()函数。</p><h3 id="导入宿主打印函数"><a href="#导入宿主打印函数" class="headerlink" title="导入宿主打印函数"></a>导入宿主打印函数</h3><p>WebAssembly是一个与宿主环境隔离的虚拟机，因此WebAssembly模块不能直接访问宿主环境的控制台或文件系统等资源。为了在WebAssembly模块中输出信息，需要通过与宿主环境的交互来完成输出操作。<br>我们假定Node.js宿主环境提供了一个console_log()函数，用于输出一个整数值：</p><pre><code>function console_log(x) &#123;    console.log(x);&#125;</code></pre><p>这样就可以通过console_log()函数输出信息了。src&#x2F;main.rs内容修改如下：</p><pre><code>extern &quot;C&quot; &#123;    fn console_log(a: i32);&#125;fn main() &#123;    unsafe &#123;        console_log(42);    &#125;&#125;</code></pre><p>其中，紧跟extern “C”后的大括弧内是宿主导入函数声明，它们都是以C语言ABI规范导入。由于外部函数的实现是由宿主环境提供的，而不是由Rust代码控制的，因此我们无法保证这些函数的安全性和正确性。为此，我们需要将调用外部函数的代码放在unsafe语句块中，这样编译器就会知道该代码可能存在不安全操作，并需要我们自行确保其正确性和安全性。<br>对应Node.js环境的启动代码如下</p><pre><code>const fs = require(&#39;fs&#39;);const buf = fs.readFileSync(&#39;./hello.wasm&#39;);function console_log(x) &#123; console.log(x); &#125;WebAssembly.instantiate(new Uint8Array(buf), &#123;    env: &#123; &quot;console_log&quot;: console_log &#125;&#125;).then(function(result) &#123;    result.instance.exports.main();&#125;);</code></pre><h1 id="TODO-更新"><a href="#TODO-更新" class="headerlink" title="TODO 更新"></a>TODO 更新</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly与Rust实践&quot;&gt;&lt;a href=&quot;#WebAssembly与Rust实践&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly与Rust实践&quot;&gt;&lt;/a&gt;WebAssembly与Rust实践&lt;/h1&gt;

	&lt;div c</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="实习" scheme="http://example.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="WebAssembly" scheme="http://example.com/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>Rust简单入门</title>
    <link href="http://example.com/p/3b2bd29.html"/>
    <id>http://example.com/p/3b2bd29.html</id>
    <published>2023-07-13T12:10:03.572Z</published>
    <updated>2023-07-17T01:13:28.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust简单入门"><a href="#Rust简单入门" class="headerlink" title="Rust简单入门"></a>Rust简单入门</h1><p>Rust的特点<br>• 零开销抽象<br>• 没有gc<br>• 内存模型没有高度封装<br>• 语法干净正交，没有C++那么繁琐。<br>• 安全性。Rust语法引入所有权和生命期概念，在编译期就能检查出一部分内存管理错误，这是rust的一个杀手锏的特性。<br>• 现代语言特性。语言特性吸收了现代语言的大量优秀特性，支持多范式。</p><h2 id="Rust环境安装"><a href="#Rust环境安装" class="headerlink" title="Rust环境安装"></a>Rust环境安装</h2><h3 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h3><p>访问Rust语言官方网站的安装地址<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br>先下载rustup安装程序再安装,安装的所有工具在~&#x2F;.cargo&#x2F;bin目录下，我们需要将该目录添加到PATH环境变量。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOJrF.png" alt="pChOJrF.png"></p><p>打开安装程序后，我们会发现需要依赖的windowsAPI库，我们采用下载vs installer的方式获取对应库。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOUa9.png" alt="pChOUa9.png"></p><p>安装vs install以后重新打开rustup安装程序，选择默认安装。<br>安装完成后，我们需要将~&#x2F;.cargo&#x2F;bin目录添加到PATH环境变量。<br>我们可以通过以下方式查看rustup、rustc和cargo工具的版本信息：</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOwP1.png" alt="pChOwP1.png"></p><p>其中，rustup是Rust工具的管理工具，rustc是Rust程序编译器，cargo是Rust工程的管理工具</p><h3 id="Rust程序测试"><a href="#Rust程序测试" class="headerlink" title="Rust程序测试"></a>Rust程序测试</h3><p>我们从“你好，世界”这个例子开始测试。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChO08x.md.png" alt="pChO08x.md.png"></p><p>其中，fn是关键字，表示定义一个函数，定义的函数的名字是main。main()函数的参数在小括弧中列出（这里的main()函数没有参数），函数体位于大括弧内。这里main()函数体中只有一个语句，就是用println!宏输出一个字符串并换行。</p><h3 id="Cargo管理工程"><a href="#Cargo管理工程" class="headerlink" title="Cargo管理工程"></a>Cargo管理工程</h3><p>Rust 编程语言引以为傲的一个重要特性是其工程管理工具 Cargo。Cargo 是 Rust 官方提供的构建系统和包管理器，被广泛认可为行业标杆。、<br>以下是 Cargo 的一些主要特性和优势：<br>• 依赖管理：Cargo 提供了强大的依赖管理功能。通过 Cargo.toml 文件，可以定义项目的依赖项和版本约束，能够轻松地引入、更新和管理外部库。<br>• 构建系统：Cargo 提供了一个集成的构建系统，使得构建、编译和测试 Rust 项目变得简单而高效。它自动处理依赖关系、编译顺序和编译标志等，开发者只需要专注于编写代码而不必手动管理构建过程。<br>• 项目管理：Cargo 提供了一组命令行工具，用于创建、初始化和管理 Rust 项目。通过简单的命令，您可以创建新项目、生成文档、运行测试、发布软件包等，提高开发者的效率和工作流程。<br>• 社区集成：Cargo 和 Rust 社区紧密结合，通过 Cargo 可以方便地共享、发布和发现 Rust 库和工具。Cargo 提供了 Cargo Crates 网站<a href="https://crates.io/">https://crates.io</a> Rust 生态系统中集中管理和发布库的中央仓库。<br>• 多工作区支持：Cargo 允许在单个项目中管理多个工作区，每个工作区可以拥有自己的依赖关系和构建配置。这对于大型项目或拥有多个模块的项目特别有用，可以更好地组织和管理代码。<br>工程一般以目录的方式组织，因此我们先创建一个空的目录（目录的名字自由选择），其中包含一个Cargo.toml文件。</p><pre><code>[package]name = &quot;hello&quot;version = &quot;0.1.0&quot;</code></pre><p>Cargo.toml是一种TOML格式的工程文件（TOML格式和ini格式类似，但是其功能更加强大）。其中，[package]部分包含工程的基本信息：name字段表示工程的名字，version字段表示工程的版本。<br>然后，创建一个src目录，在目录中创建一个main.rs文件：</p><pre><code>fn main() &#123;    println!(&quot;你好，世界&quot;);&#125;</code></pre><p>Cargo工具默认以src&#x2F;main.rs为程序的入口文件，因此只需要输入<br>cargo run就可以编译并运行程序了</p><p><img src="https://s1.ax1x.com/2023/07/13/pChXhTJ.png" alt="pChXhTJ.png"></p><p>Cargo底层依然是调用rustc编译器工具。但是，Cargo不仅可以管理可执行程序和库，还可以对其他第三方库的依赖进行管理，同时支持自定义的构建脚本。<br>cargo-generate是一个开发人员工具，通过利用预先存在的 git 存储库作为模板，帮助开发者快速启动和运行新的 Rust 项目。</p><pre><code>cargo install cargo-generate</code></pre><h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><p>Rust还提供了本地文档用于帮助学习和了解Rust。<br>我们可以在终端运行：</p><pre><code>rustup doc</code></pre><p>打开文档。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChj9pt.png" alt="pChj9pt.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust简单入门&quot;&gt;&lt;a href=&quot;#Rust简单入门&quot; class=&quot;headerlink&quot; title=&quot;Rust简单入门&quot;&gt;&lt;/a&gt;Rust简单入门&lt;/h1&gt;&lt;p&gt;Rust的特点&lt;br&gt;• 零开销抽象&lt;br&gt;• 没有gc&lt;br&gt;• 内存模型没有高度封装&lt;b</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly跨语言调用</title>
    <link href="http://example.com/p/bf55081a.html"/>
    <id>http://example.com/p/bf55081a.html</id>
    <published>2023-07-13T11:58:12.167Z</published>
    <updated>2023-07-14T01:13:51.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly跨语言调用"><a href="#WebAssembly跨语言调用" class="headerlink" title="WebAssembly跨语言调用"></a>WebAssembly跨语言调用</h1><p>WebAssembly (Wasm) 可以在多种编程语言之间进行跨语言调用。它提供了一种标准化的接口，使得不同语言的代码可以相互调用和交互。<br>选择一种编程语言（例如 Rust、C++、Go 等）编写Wasm 模块。使用相应的编译器或工具链将代码编译为 Wasm 模块文件。然后导入 Wasm 模块到目标语言：在目标语言的代码中，使用相应的 Wasm 运行时库或框架来导入和执行 Wasm 模块。不同的语言可能有不同的 Wasm 运行时库可用，例如wasmer、wasmtime 等。</p><h2 id="Go和Rust调用实例"><a href="#Go和Rust调用实例" class="headerlink" title="Go和Rust调用实例"></a>Go和Rust调用实例</h2><h3 id="被调用方Rust"><a href="#被调用方Rust" class="headerlink" title="被调用方Rust"></a>被调用方Rust</h3><p>首先我们需要将被编译的程序编译成wasm文件<br>这里我们用go程序调用rust程序<br>用cargo init  add创建一个rust文件，更改add.rs</p><pre><code>fn main()&#123;&#125;#[no_mangle]pub extern &quot;C&quot; fn sum(x: i32, y: i32) -&gt; i32 &#123;    x + y&#125;</code></pre><p>将该文件编译为wasm</p><pre><code>cargo build --target wasm32-unknown-unknown --release</code></pre><p>现在被调用者我们已经处理完了，下面我们编写调用方代码。</p><h3 id="调用方Go"><a href="#调用方Go" class="headerlink" title="调用方Go"></a>调用方Go</h3><p>这里我们参照<a href="https://github.com/wasmerio/wasmer-go%E9%87%87%E7%94%A8wasmer%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">https://github.com/wasmerio/wasmer-go采用wasmer库进行处理</a><br>需要注意的是目前该库并不支持windows，需要在linux环境下使用</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOkgf.png" alt="pChOkgf.png"></p><p>创建相应go文件调用生成的wasm文件</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;    wasmer &quot;github.com/wasmerio/wasmer-go/wasmer&quot;)func main() &#123;    // 换成生成add.wasm的路径    wasmBytes, _ := ioutil.ReadFile(&quot;add/target/wasm32-unknown-unknown/release/add.wasm&quot;)    // Create an Engine    engine := wasmer.NewEngine()    // Create a Store    store := wasmer.NewStore(engine)    // Let&#39;s compile the module.    module, err := wasmer.NewModule(store, wasmBytes)    if err != nil &#123;        fmt.Println(&quot;Failed to compile module:&quot;, err)    &#125;    // Create an empty import object.    importObject := wasmer.NewImportObject()    // Let&#39;s instantiate the WebAssembly module.    instance, err := wasmer.NewInstance(module, importObject)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to instantiate the module:&quot;, err))    &#125;    // Now let&#39;s execute the `sum` function.    sum, err := instance.Exports.GetFunction(&quot;sum&quot;)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to get the `add_one` function:&quot;, err))    &#125;    result, err := sum(1, 2)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to call the `add_one` function:&quot;, err))    &#125;    fmt.Println(&quot;Results of `sum`:&quot;, result)&#125;</code></pre><p>注意：<br>• 12行需要换成生成add.wasm的相对&#x2F;绝对路径<br>• 需要拉取对应仓库<br>• 更多具体api参照<a href="https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer">https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer</a></p><p>之后我们直接运行程序，可以看到跨语言调用成功</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOuUs.png" alt="pChOuUs.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly跨语言调用&quot;&gt;&lt;a href=&quot;#WebAssembly跨语言调用&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly跨语言调用&quot;&gt;&lt;/a&gt;WebAssembly跨语言调用&lt;/h1&gt;&lt;p&gt;WebAssembly (W</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>C++进程优雅退出</title>
    <link href="http://example.com/p/53dbe2a2.html"/>
    <id>http://example.com/p/53dbe2a2.html</id>
    <published>2023-07-13T10:05:38.797Z</published>
    <updated>2023-07-13T10:09:58.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-进程的优雅退出"><a href="#C-进程的优雅退出" class="headerlink" title="C++进程的优雅退出"></a>C++进程的优雅退出</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="通过原子变量"><a href="#通过原子变量" class="headerlink" title="通过原子变量"></a>通过原子变量</h3><p>原子变量是线程安全的，我们可以通过atomic变量控制线程开始结束</p><pre><code>#include &lt;csignal&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;// 用于确定关闭状态的全局布尔变量std::atomic&lt;bool&gt; shutdownFlag(false);// 信号处理函数void signalHandler(int signal) &#123;    // 也可以使用 switch/case 进行控制    if (signal == SIGINT) &#123;        std::cout &lt;&lt; &quot;收到 SIGINT 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125; else if (signal == SIGTERM) &#123;        std::cout &lt;&lt; &quot;收到 SIGTERM 信号。正在启动优雅关闭...&quot; &lt;&lt; std::endl;    &#125;    shutdownFlag = true;&#125;int main() &#123;    // 设置 SIGINT 和 SIGTERM 的信号处理函数    std::signal(SIGINT, signalHandler);    std::signal(SIGTERM, signalHandler);    // 服务器的主循环    while (!shutdownFlag) &#123;        // 在此处处理连接        std::this_thread::sleep_for(std::chrono::seconds(1));        std::cout &lt;&lt; &quot;服务器正在运行...&quot; &lt;&lt; std::endl;    &#125;    // 启动优雅关闭过程    std::cout &lt;&lt; &quot;正在启动优雅关闭...&quot; &lt;&lt; std::endl;        // 在这里可以进行清理操作，例如：    // 逐个关闭仍在进行中的连接，    // 保存数据，    // 正确关闭套接字等        std::cout &lt;&lt; &quot;优雅关闭完成。程序正在退出。&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>在上述例子中，我们捕获了SIGINT和SIGTERM信号，并根据这些信号进行了相应的处理。<br>SIGINT信号通常由用户在终端中按下中断键（如CTRL+C）时发送。它是一种用户主动发出的中断信号，用于通知程序终止执行。通过捕获SIGINT信号并设置相应的处理逻辑，我们可以在收到该信号时执行特定的操作，例如优雅地关闭服务器或执行其他清理任务。<br>而SIGTERM信号通常由操作系统或其他程序发送，用于请求程序正常终止。这种信号可能是远程管理工具、容器编排系统或其他管理机制发送的。与SIGINT信号类似，通过捕获SIGTERM信号并设置相应的处理逻辑，我们可以实现平滑关闭的过程，让程序有机会完成一些清理操作，确保数据的完整性和一致性。<br>通过设置信号处理函数来捕获这两个信号，并在接收到信号时设置原子变量shutdownFlag为true，以触发服务器的优雅关闭过程。这样可以在接收到这些信号时执行一些特定的操作，例如向用户发送关闭通知、保存数据、关闭连接等。</p><h3 id="休眠线程以及条件变量"><a href="#休眠线程以及条件变量" class="headerlink" title="休眠线程以及条件变量"></a>休眠线程以及条件变量</h3><p>但是如果线程大部分时间都在休眠怎么办？ 比如某一个线程仅偶尔执行一些工作，其间有长时间的睡眠。 如果终止信号到达，睡眠必须立即中断。 此外，如果向应用程序发送SIGTERM，并且应用程序没有在超时时间内终止，那么应用程序将被强行kill。<br>对于这个问题解决方式就是使用条件变量condition_variable::wait()，让线程休眠，直到经过特定时间跨度或满足条件。常用的方式就是使用条件变量，使用std::condition_variable::notify_one和std::condition_variable::notify_all 可以将线程从睡眠中唤醒，std::condition_variable的成员函数notify_one()与notify_all()是用来唤醒阻塞在wait（）的线程。假如有多个线程调用condition_variable::wait()陷入休眠之后。condition_variable的实现中有一个等待队列来保存堵塞在它之上的线程。当其他线程调用notify_one()时，只唤醒等待队列中的第一个线程；其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()才会唤醒。如果是调用notify_all()：会唤醒所有等待队列中阻塞的线程，但是存在锁争用，只有一个线程能够获得锁。队列中的其他线程，会不断尝试获得锁，当第一个唤醒的线程释放锁之后，剩余的线程就能获得锁继续执行。<br>但是notify_{one,all} 不是信号安全的，因此不能在信号处理程序中使用。所以signal handlers are out</p><blockquote><p>信号就像硬件中断一样，会打断正在执行的指令序列。信号处理函数无法判断捕获到信号的时候，进程在何处运行。如果信号处理函数中的操作与打断的函数的操作相同，而且这个操作中有静态数据结构等，当信号处理函数返回的时候（当然这里讨论的是信号处理函数可以返回），恢复原先的执行序列，可能会导致信号处理函数中的操作覆盖了之前正常操作中的数据。</p></blockquote><h3 id="采用sigwait"><a href="#采用sigwait" class="headerlink" title="采用sigwait"></a>采用sigwait</h3><p>sigwait()函数是一个POSIX函数，它允许线程挂起其执行，直到在给定的信号集中指定的某个信号成为待处理信号。该函数接受信号（从待处理信号列表中删除它），并将信号编号存储在sig变量中。<br>通过使用sigwait或sigwaitinfo，多线程应用程序可以在启动时阻塞所有信号，并有一个专用线程等待信号。这样，我们可以利用所有可用的同步原语。</p><pre><code>#include &lt;signal.h&gt;int sigwait(const sigset_t *set, int *sig);</code></pre><p>• set参数是指向信号集的指针，信号集是表示一组信号的数据结构。<br>• sig参数是一个指向整数的指针，成功完成函数后，接收到的信号编号将存储在其中。<br>以下是sigwait()的示例用法：</p><pre><code>#include &lt;condition_variable&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;signal.h&gt;int main()&#123;    // 阻塞当前线程和后续生成的线程中的信号    sigset_t sigset;    sigemptyset(&amp;sigset);    sigaddset(&amp;sigset, SIGINT);    sigaddset(&amp;sigset, SIGTERM);    pthread_sigmask(SIG_BLOCK, &amp;sigset, nullptr);    std::atomic&lt;bool&gt; shutdown_requested(false);    std::mutex cv_mutex;    std::condition_variable cv;    // 信号处理函数，在收到信号时设置shutdown_requested为true，    // 并通过条件变量cv通知其他等待的线程。    auto signal_handler = [&amp;shutdown_requested, &amp;cv, &amp;sigset]() &#123;        int signum = 0;        // 等待信号的到达：        sigwait(&amp;sigset, &amp;signum);        shutdown_requested.store(true);        // 通知所有等待的工作线程检查其断言：        cv.notify_all();        return signum;    &#125;;    // 将信号处理函数放在一个独立的线程中运行。    auto ft_signal_handler = std::async(std::launch::async, signal_handler);    auto worker = [&amp;shutdown_requested, &amp;cv_mutex, &amp;cv]() &#123;        while( shutdown_requested.load() == false )        &#123;        std::unique_lock lock(cv_mutex);        cv.wait_for(            lock,            // 最多等待一小时            std::chrono::hours(1),            // 当条件变量被唤醒并且断言为true时，停止等待：            [&amp;shutdown_requested]() &#123; return shutdown_requested.load(); &#125;);        &#125;        return shutdown_requested.load();    &#125;;    // 生成一组工作线程    std::vector&lt;std::future&lt;bool&gt;&gt; workers;    for( int i = 0; i &lt; 10; ++i )        workers.push_back(std::async(std::launch::async, worker));    std::cout &lt;&lt; &quot;等待SIGTERM或SIGINT信号（按下[CTRL]+[c]）...\n&quot;;    // 等待信号处理函数完成    int signal = ft_signal_handler.get();    std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signal &lt;&lt; &quot;\n&quot;;    // 等待工作线程    for( auto&amp; future : workers )        std::cout &lt;&lt; &quot;工作线程观察到关机请求: &quot;                &lt;&lt; std::boolalpha                &lt;&lt; future.get()                &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;正常关机\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2><p>Signal Wrangler  是一个小型的仅需要包含标头的库，更加方便管理信号。<br>Dependencies<br>• C++17<br>• Clang or GCC<br>• linux<br>• pthread<br>• cmake (recommended, but optional)<br>• Catch2 for testing</p><pre><code>#include &lt;sgnl/AtomicCondition.h&gt;#include &lt;sgnl/SignalHandler.h&gt;#include &lt;cstdlib&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;thread&gt;void Worker(const sgnl::AtomicCondition&lt;bool&gt;&amp; exit_condition)&#123;    auto predicate = [&amp;exit_condition]() &#123;        return exit_condition.get();    &#125;;    while (true)    &#123;        exit_condition.wait_for(std::chrono::minutes(1), predicate);        if (exit_condition.get())        return;        /* ... 执行工作 ... */    &#125;&#125;int main()&#123;    sgnl::AtomicCondition&lt;bool&gt; exit_condition(false);    auto handler = [&amp;exit_condition](int signum) &#123;        std::cout &lt;&lt; &quot;收到信号 &quot; &lt;&lt; signum &lt;&lt; &quot;\n&quot;;        if (signum == SIGTERM || signum == SIGINT)        &#123;        exit_condition.set(true);        // 唤醒所有等待的线程        exit_condition.notify_all();        // 停止等待信号        return true;        &#125;        // 继续等待信号        return false;    &#125;;    // 阻塞当前线程中的信号。    // 后续生成的线程将继承信号屏蔽。    sgnl::SignalHandler signal_handler(&#123;SIGINT, SIGTERM, SIGUSR1&#125;);    std::future&lt;int&gt; ft_sig_handler =        std::async(            std::launch::async,            &amp;sgnl::SignalHandler::sigwait_handler,            &amp;signal_handler,            std::ref(handler));    std::vector&lt;std::future&lt;void&gt;&gt; futures;    for (int i = 0; i &lt; 10; ++i)        futures.push_back(            std::async(                std::launch::async,                Worker,                std::ref(exit_condition)));    // 发送 SIGUSR1 信号    std::this_thread::sleep_for(std::chrono::milliseconds(100));    kill(0, SIGUSR1);    // 发送 SIGTERM 信号    kill(0, SIGTERM);    std::this_thread::sleep_for(std::chrono::milliseconds(100));    for (auto&amp; future : futures)        future.wait();    int last_signal = ft_sig_handler.get();    std::cout &lt;&lt; &quot;退出（收到信号 &quot; &lt;&lt; last_signal &lt;&lt; &quot;）\n&quot;;    return EXIT_SUCCESS;&#125;</code></pre><h2 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h2><p>C++20实现优雅退出的一个方式是通过<a href="https://whl963854.github.io/p/324821f5.html">jthread</a>来进行实现C++20 jthread通过这种方式我们不用像传统做法定义一个变量进行控制，线程本身就可以控制子线程的运行以及停止。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void task()&#123;    while (true)    &#123;        // 执行任务        std::cout &lt;&lt; &quot;Performing task...\n&quot;;        std::this_thread::sleep_for(std::chrono::seconds(1));        // 检查是否收到停止请求        if (std::jthread::stop_requested())        &#123;            std::cout &lt;&lt; &quot;Stop requested. Exiting...\n&quot;;            break;        &#125;    &#125;&#125;int main()&#123;    std::jthread thread(task);    // 等待一段时间或等待某个条件满足    std::this_thread::sleep_for(std::chrono::seconds(5));    // 请求停止子线程    thread.request_stop();    // 继续等待一段时间，确保子线程完成当前任务    std::this_thread::sleep_for(std::chrono::seconds(2));    // std::jthread的析构函数会自动调用join()，等待子线程执行完毕    // 主线程退出，整个进程结束    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-进程的优雅退出&quot;&gt;&lt;a href=&quot;#C-进程的优雅退出&quot; class=&quot;headerlink&quot; title=&quot;C++进程的优雅退出&quot;&gt;&lt;/a&gt;C++进程的优雅退出&lt;/h1&gt;&lt;h2 id=&quot;C-11&quot;&gt;&lt;a href=&quot;#C-11&quot; class=&quot;header</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Go进程的优雅退出</title>
    <link href="http://example.com/p/d080713b.html"/>
    <id>http://example.com/p/d080713b.html</id>
    <published>2023-07-13T09:47:07.554Z</published>
    <updated>2023-07-13T10:04:57.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go进程的优雅退出"><a href="#Go进程的优雅退出" class="headerlink" title="Go进程的优雅退出"></a>Go进程的优雅退出</h1><h2 id="退出的反面模式"><a href="#退出的反面模式" class="headerlink" title="退出的反面模式"></a>退出的反面模式</h2><p>反面模式（anti-pattern）是指在实践中明显出现但又低效或是有待优化的设计模式。在进程退出过程中如果直接退出会导致资源无法及时释放，关闭打开的连接以及完成正在进行的请求和处理等方面问题。如果是无GC的语言可能还会出现内存泄漏等问题。</p><h3 id="Block-artificially"><a href="#Block-artificially" class="headerlink" title="Block artificially"></a>Block artificially</h3><p>第一个反面模式是在主 goroutine中使用无限循环来阻塞程序的执行，但是退出的时候并不等待任何东西。收到信号就退出，以下是一个这种反模式的简单实现示例：</p><pre><code>package mainfunc KeepProcessAlive() &#123;    var ch chan int    &lt;-ch&#125;func main() &#123;    ...    KeepProcessAlive()&#125;</code></pre><p>当ch收到数据解除阻塞，主进程也随之运行结束，没有对资源进行释放。</p><h3 id="os-Exit"><a href="#os-Exit" class="headerlink" title="os.Exit()"></a>os.Exit()</h3><p>第二种反面模式就是在其他 go 协程仍在运行的时候就调用os.Exit(1)，这本质上等于 SIGKILL，没有机会关闭打开的连接以及完成正在进行的请求和处理。</p><pre><code>go func() &#123;        &lt;-ch                os.Exit(1)&#125;()go func () &#123;    for ... &#123;    &#125;&#125;()</code></pre><p>当func收到数据之后立刻调用os.Exit()终止进程，也没有任何关闭打开的连接以及完成正在进行的请求和处理的行为。<br>以上两种行为都是十分不可取的，也可以说他们的退出不是“优雅”的。</p><h2 id="在Go中优雅退出"><a href="#在Go中优雅退出" class="headerlink" title="在Go中优雅退出"></a>在Go中优雅退出</h2><p>为了正常关闭服务，需要了解两件事：</p><ul><li>如何等待所有正在运行的go例程退出</li><li>如何将终止信号传播到多个 goroutine<br>Go 提供了实现上面两点要求所需的所有工具，可以很方便的让我们优雅退出进程。</li></ul><h3 id="等待-go-routine-完成"><a href="#等待-go-routine-完成" class="headerlink" title="等待 go-routine 完成"></a>等待 go-routine 完成</h3><p>Go 提供了足够的方法来控制并发。让我们看看等待go-routine有哪些方法。</p><h4 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h4><p>最简单的解决方案，使用通道原语。</p><ol><li>我们创建一个空的结构通道make(chan struct{}, 1)（空结构不需要内存）。</li><li>每个子 goroutine完成后都应该发布到通道（defer在这里很有用）。</li><li>父 goroutine应该从通道消耗与预期 goroutine 一样多的次数。</li></ol><p>下面来看一个例子：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    wait := make(chan struct&#123;&#125;, 2)    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第一个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    go func() &#123;        defer func() &#123;            wait &lt;- struct&#123;&#125;&#123;&#125;        &#125;()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;第二个 goroutine 停止循环&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    // 等待两个 goroutine 完成    &lt;-wait    &lt;-wait&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    // 捕捉操作系统中断信号（如 Ctrl+C）    signals := make(chan os.Signal, 1)    signal.Notify(signals, os.Interrupt, syscall.SIGTERM)    go func() &#123;        &lt;-signals        fmt.Println(&quot;接收到中断信号&quot;)        cancel() // 取消上下文    &#125;()    run(ctx)    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.goCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loop接收到中断信号第一个 goroutine 停止循环第二个 goroutine 停止循环Main done</code></pre><p><strong>注：这在等待单个 go  routine 时非常有用。</strong></p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>通道在有多个 goroutine的情况下解决方案可能不太优雅。sync.WaitGroup是一个标准库包，这是更惯用的实现上述目标的方式。WaitGroup 是 package sync 用来做任务编排的一个并发原语。它要解决的就是并发 - 等待的问题。</p><p>Go 标准库中的 WaitGroup 提供了三个方法</p><ul><li>func (wg *WaitGroup) Add(delta int)用来设置 WaitGroup 的计数值；</li><li>func (wg *WaitGroup) Done()用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li><li>func (wg *WaitGroup) Wait()调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><p>使用 WaitGroup 的时候，一定要等所有的 Add 方法调用之后再调用 Wait，否则就可能导致 panic 或者不期望的结果。</p><p>下面是一个示例。</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h4 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h4><p>sync&#x2F;errgroup包有一种更好的方法实现上面的功能。</p><ul><li>两个errgroup的方法.Wait和.Go相对于WaitGroup更具可读性并且更易于维护。</li><li>此外，errgroup会进行错误传播并取消上下文，以便在发生错误时终止其他 goroutine</li></ul><p>下面来看示例：</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;golang.org/x/sync/errgroup&quot;    &quot;time&quot;)func run(ctx context.Context) &#123;    g, gCtx := errgroup.WithContext(ctx)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;)    g.Go(func() error &#123;        for &#123;            select &#123;            case &lt;-gCtx.Done():                fmt.Println(&quot;Break the loop&quot;)                return nil            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;)    err := g.Wait()    if err != nil &#123;        fmt.Println(&quot;Error group:&quot;, err)    &#125;    fmt.Println(&quot;Main done&quot;)&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        // 在一段时间后取消上下文        time.Sleep(5 * time.Second)        cancel()    &#125;()    run(ctx)&#125;</code></pre><p>输出结果如下：</p><pre><code>$ go run main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h3 id="控制进程终止"><a href="#控制进程终止" class="headerlink" title="控制进程终止"></a>控制进程终止</h3><p>上面我们已经弄清楚如何正确地传达进程的状态并等待它们，但是我们很多时候并不能一直等待进程运行结束，还需要实现对程序的终止的控制,将终止信号传播到多个 goroutine。<br>我们从一个非常简单的“Hello in a loop”示例开始：</p><pre><code>func main() &#123;    for &#123;        time.Sleep(1 * time.Second)        fmt.Println(&quot;Hello in a loop&quot;)    &#125;&#125;</code></pre><h4 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h4><p>通过信号量可以监听到系统发出的关停，程序意外关闭、退出、重启等，可以记录相关信息和退出前的操作。所以我们需要监听操作系统信号自主控制信号对应的事件：</p><pre><code>exit := make(chan os.Signal, 1) signal.Notify(exit, os.Interrupt, syscall.SIGTERM)</code></pre><p>• 我们需要使用 os.Interrupt 通过 Ctrl+C（即 SIGINT）正常关闭<br>• syscall.SIGTERM是常用的终止信号，也是docker容器的默认信号（可以修改） ， kubernetes也使用该信号。</p><p>注：信号具体功能如下所示：</p><table><thead><tr><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>SIGHUP</td><td>当终端断开时，将发送该信号给终端控制进程。SIGHUP 信号还可用于守护进程。</td></tr><tr><td>SIGINT</td><td>当用户键入终端中断字符（如：Ctrl + C），终端驱动程序将发送该信号给前台进程组。默认行为是终止进程。</td></tr><tr><td>SIGQUIT</td><td>当用户键入终端退出字符（如：Ctrl + \），该信号将发送给前台进程组。默认情况下，该信号终止进程，并生成可用于调试的核心转储文件。</td></tr><tr><td>SIGILL</td><td>进程试图非法执行机器语言指令，系统将向该进程发送该信号。</td></tr><tr><td>SIGTRAP</td><td>用于实现断点调试功能以及 strace 命令所执行的系统调用跟踪功能。</td></tr><tr><td>SIGABRT</td><td>当进程调用 abort 函数时，系统向该进程发送该信号。默认情况下，该信号会终止进程，并生成核心转储文件。</td></tr><tr><td>SIGBUS</td><td>总线错误，表示发生了某种内存访问错误。当使用 mmap() 创建的内存映射时，如果试图访问的地址超出了底层内存映射文件的结尾，会产生该错误。</td></tr><tr><td>SIGFPE</td><td>在发生致命的算术运算错误时发出。包括浮点运算错误、溢出以及除数为0等其他算术错误。</td></tr><tr><td>SIGKILL</td><td>必杀信号，处理器程序无法阻塞、忽略或捕获，总能杀死进程（僵尸进程除外）。</td></tr><tr><td>SIGUSR1</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGSEGV</td><td>试图访问未分配给自己的内存，或试图往没有写权限的内存地址写入数据。</td></tr><tr><td>SIGUSR2</td><td>用户自定义信号，内核不会为进程产生该信号。</td></tr><tr><td>SIGPIPE</td><td>当进程向管道、FIFO 或套接字写入信息时，如果没有相应的读进程，系统将产生该信号（管道破裂）。</td></tr><tr><td>SIGALRM</td><td>经调用 alarm() 或 setitimer() 设置的实时定时器一旦到期，内核将产生该信号。</td></tr><tr><td>SIGTERM</td><td>用来终止进程的标准信号，也是 kill 和 killall 命令所发送的默认信号。建议首先尝试使用该信号来终止进程，而将 SIGKILL 作为最后手段。</td></tr><tr><td>SIGCHLD</td><td>当父进程的某个子进程退出时，内核将向父进程发送该信号。</td></tr><tr><td>SIGCONT</td><td>该信号发送给已停止的进程，使其恢复运行。</td></tr><tr><td>SIGSTOP</td><td>进程收到该信号将停止运行，处理器程序无法将其阻塞、忽略或捕获，总能停止进程。</td></tr><tr><td>SIGTSTP</td><td>作业控制的停止信号，当用户在键盘输入挂起字符（如：Ctrl + Z）时，将发送该信号给前台进程组，使其停止运行。</td></tr><tr><td>SIGTTIN</td><td>在作业控制 shell 下运行时，若后台进程组试图对终端进行 read() 操作，终端驱动程序则将发送该信号。该信号默认将停止进程。</td></tr><tr><td>SIGTTOU</td><td>类似于 SIGTTIN，但在写终端（或修改终端模式）时收到。</td></tr><tr><td>SIGURG</td><td>系统发送该信号给一个进程，表示套接字上存在带外（紧急）数据。</td></tr><tr><td>SIGXCPU</td><td>当进程的 CPU 时间超出对应的资源限制时，将发送此信号给进程。</td></tr><tr><td>SIGXFSZ</td><td>如果进程试图增大文件而突破对进程文件大小的资源限制时，将发送该信号给进程。</td></tr><tr><td>SIGVTALRM</td><td>虚拟时钟信号，类似于 SIGALRM，但计算的是该进程占用的 CPU 时间。</td></tr><tr><td>SIGPROF</td><td>类似于 SIGALRM 和 SIGVTALRM，但包括该进程用的 CPU 时间以及系统调用的时间。</td></tr><tr><td>SIGWINCH</td><td>窗口大小改变时发出该信号。</td></tr><tr><td>SIGIO</td><td>文件描述符准备就绪，可以开始进行输入&#x2F;输出操作。</td></tr><tr><td>SIGPWR</td><td>电源故障信号。</td></tr><tr><td>SIGSYS</td><td>如果进程发起的系统调用有误，将产生该信号。</td></tr></tbody></table><p>监听 SIGINT 和 SIGKILL 信号</p><blockquote><p>ctrl+c 产生了一个 SIGINT（中断信号）。<br>kill 9 发送一个 SIGKILL 信号 终止进程的信号来结束进程。</p></blockquote><h4 id="中断循环"><a href="#中断循环" class="headerlink" title="中断循环"></a>中断循环</h4><p>现在我们有了捕获信号的方法，现在我们需要找到一种中断循环的方法。</p><h5 id="非阻塞通道选择"><a href="#非阻塞通道选择" class="headerlink" title="非阻塞通道选择"></a>非阻塞通道选择</h5><p>select 语句允许在多个通道操作中选择可用的操作进行处理。当 select 语句执行时，它会等待其中一个 case 条件满足，并执行相应的操作。<br>下面是一个简单的 hello for 循环：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    c := make(chan os.Signal, 1) // 我们需要保留缓冲区大小为1，以确保通道不会被阻塞    signal.Notify(c, os.Interrupt, syscall.SIGTERM)    for &#123;        select &#123;        case &lt;-c:            fmt.Println(&quot;打破循环&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;循环中的Hello&quot;)        &#125;    &#125;&#125;</code></pre><p>通过这种方式，程序可以同时监听操作系统信号和定时器事件，根据不同的事件类型执行相应的操作。</p><pre><code>$ go run main.go循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello循环中的Hello打破循环</code></pre><p>当接收到信号时，程序会退出循环并终止运行；而在每次定时器超时后，程序会打印出 “循环中的Hello”。这样，程序可以在接收到信号或每秒定时打印信息的情况下进行灵活的处理。</p><h5 id="使用Context来实现"><a href="#使用Context来实现" class="headerlink" title="使用Context来实现"></a>使用Context来实现</h5><p>Context（上下文）是Go语言中一个非常有用的接口，应该在所有阻塞函数中使用和传播。它可以实现取消操作在整个程序中的传播。<br>在直接或间接用于外部依赖项的每个方法或函数中，context.Context作为第一个参数是一个良好的做法。https :&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;context</p><h6 id="Channel共享问题"><a href="#Channel共享问题" class="headerlink" title="Channel共享问题"></a>Channel共享问题</h6><p>让我们看看上下文属性如何在更复杂的情况下提供帮助。<br>使用通道并行运行多个循环（反例）：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    exit := make(chan os.Signal, 1)    signal.Notify(exit, os.Interrupt, syscall.SIGTERM)    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: hello&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-exit:                fmt.Println(&quot;Break the loop: ciao&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>该代码中使用了两个 goroutine，每个 goroutine 都使用 select 语句监听操作系统信号和定时器事件。exit 通道被多个 goroutine 共享，并且每个 goroutine 都在监听 exit 通道。当其中一个 goroutine 接收到终止信号时，其他 goroutine 也会接收到信号，但只有一个 goroutine 会打印相应的消息并退出。其他 goroutine 则会继续运行并打印定时器事件的消息。<br>这会导致一个问题：wg.Wait() 语句将一直等待直到所有 goroutine 完成，但只有一个 goroutine 会接收到终止信号并退出，而另一个 goroutine 则会一直运行下去。<br>对于广播通知的需求，可以使用context包来完成。context包提供了一种在多个goroutine之间传递取消信号的机制。</p><h6 id="使用-Context-终止"><a href="#使用-Context-终止" class="headerlink" title="使用 Context 终止"></a>使用 Context 终止</h6><p>让我们尝试通过引入context.WithCancel来解决这个问题</p><pre><code>package mainimport (    &quot;context&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;sync&quot;    &quot;syscall&quot;    &quot;time&quot;)func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go func() &#123;        exit := make(chan os.Signal, 1)        signal.Notify(exit, os.Interrupt, syscall.SIGTERM)        cancel()    &#125;()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                return            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>当调用返回的取消函数或关闭父上下文的 Done 通道时，返回的上下文的 Done 通道将关闭。所有通过该上下文创建的 goroutine 中的 select 语句中的 &lt;-ctx.Done() 分支会被触发，也就是收到一个已关闭的通道。</p><pre><code>PS D:\workplace\gopath\src\wps\context_stop&gt;  go run .\main.goBreak the loopBreak the loopMain done</code></pre><p>这种行为实现了上下文的广播特性，在所有使用相同上下文的 goroutine 中，无论是直接调用取消函数还是关闭 Done 通道，都会导致所有的 &lt;-ctx.Done() 分支被执行。<br>这种广播机制使得可以在多个 goroutine 之间同时传递取消信号，而不仅仅限于单个 goroutine。通过这种方式，可以实现一次性取消多个相关 goroutine 的执行。</p><h6 id="NotifyContext"><a href="#NotifyContext" class="headerlink" title="NotifyContext"></a>NotifyContext</h6><p>在 go 1.16 中，信号包中引入了一个新的有用方法，singal.NotifyContext：</p><pre><code>func NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)</code></pre><p>创建一个新的上下文并监听指定的操作系统信号。当收到这些信号之一时，上下文将被取消，触发相关的操作。<br>使用 NotifyContext 可以将上面的示例简化为：</p><pre><code>func main() &#123;    ctx, stop := context.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)    defer stop()    var wg sync.WaitGroup    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Hello in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Add(1)    go func() &#123;        defer wg.Done()        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;Break the loop&quot;)                break            case &lt;-time.After(1 * time.Second):                fmt.Println(&quot;Ciao in a loop&quot;)            &#125;        &#125;    &#125;()    wg.Wait()    fmt.Println(&quot;Main done&quot;)&#125;</code></pre><p>将信号通过ctx进行监听，利用ctx就可以控制协程结束。</p><pre><code>PS D:\workplace\gopath\src\wps\notify_context&gt; go run .\main.goHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopHello in a loopCiao in a loopCiao in a loopHello in a loopBreak the loopBreak the loopMain done</code></pre><h2 id="优雅的方法"><a href="#优雅的方法" class="headerlink" title="优雅的方法"></a>优雅的方法</h2><p>到目前为止，我们已经看到了几种优雅地终止一段长时间运行的代码的技术。</p><h3 id="使用-ctx-进行阻止"><a href="#使用-ctx-进行阻止" class="headerlink" title="使用 ctx 进行阻止"></a>使用 ctx 进行阻止</h3><p>这是最常见的方法，也更容易理解和实施。<br>• 调用一个方法<br>• 传递一个上下文<br>• 如果发生错误或上下文被取消&#x2F;超时，它将返回。</p><pre><code>// 调用:err := srv.Run(ctx, ...)// 实现func (srv *Service) Run(ctx context.Context, ...) error &#123;    // ...    // ...    for &#123;        // ...        select &#123;        case &lt;-ctx.Done():            // 根据业务逻辑需求，决定是否返回上下文错误            return ctx.Err()        &#125;    &#125;    // 如果不需要返回其他错误，可以直接返回 nil    return nil&#125;</code></pre><h3 id="Setup-x2F-Shutdown"><a href="#Setup-x2F-Shutdown" class="headerlink" title="Setup&#x2F;Shutdown"></a>Setup&#x2F;Shutdown</h3><p>在某些情况下，使用阻塞方式的ctx代码不是最合适的方法，特别是希望控制何时执行.Shutdown()方法时。不过，需要注意确保调用.Shutdown()以优雅地关闭服务器，避免资源泄漏的情况发生。</p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>服务依赖数据库才能正常工作，我们需要确保服务不再运行后才执行db的关闭操作。通过在defer中调用db.Shutdown()，我们确保它在g.Wait返回后运行。</p><pre><code>// calling:func () &#123;    err := db.Setup() // will not block    defer db.Shutdown()    svc := Service&#123;        DB: db    &#125;    g.Run(...        svc.Run(ctx, ...)    )    g.Wait()&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优雅退出是指在进程终止前给予进程清理剩余请求的时间，等待子协程&#x2F;线程完成当前任务后再发起进程退出，以确保不会丢失任何数据。相比于暴力退出，优雅退出可以对未完成的任务和数据进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go进程的优雅退出&quot;&gt;&lt;a href=&quot;#Go进程的优雅退出&quot; class=&quot;headerlink&quot; title=&quot;Go进程的优雅退出&quot;&gt;&lt;/a&gt;Go进程的优雅退出&lt;/h1&gt;&lt;h2 id=&quot;退出的反面模式&quot;&gt;&lt;a href=&quot;#退出的反面模式&quot; class=&quot;he</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>进程通信</title>
    <link href="http://example.com/p/53ad465c.html"/>
    <id>http://example.com/p/53ad465c.html</id>
    <published>2023-07-13T09:47:07.553Z</published>
    <updated>2023-07-13T10:09:58.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>如果我们希望在本进程fork出一个子进程，可以使用os.StartProcess方法，它会fork出一个子进程后返回这个子进程的pid。</p><pre><code>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) &#123;    testlog.Open(name)    return startProcess(name, argv, attr)&#125;</code></pre><p>但是我们一般不这么做，因为 os.StartProcess 是一个比较底层的接口，一般是提供给go内部其他的方法去使用的。我们可以使用os.Command方法创建一个命令，并调用cmd.Start()方法运行命令，Start()方法内部其实就是调用的os.StartProcess()方法去fork一个子进程。</p><p>我们先来看Command方法，该方法返回一个*Cmd类型</p><pre><code>func Command(name string, arg ...string) *Cmd</code></pre><p>Cmd定义如下</p><pre><code>type Cmd struct &#123;        // Path is the path of the command to run.        //        // This is the only field that must be set to a non-zero        // value. If Path is relative, it is evaluated relative        // to Dir.        Path string        // Args holds command line arguments, including the command as Args[0].        // If the Args field is empty or nil, Run uses &#123;Path&#125;.        //        // In typical use, both Path and Args are set by calling Command.        Args []string        // Env specifies the environment of the process.        // Each entry is of the form &quot;key=value&quot;.        // If Env is nil, the new process uses the current process&#39;s        // environment.        // If Env contains duplicate environment keys, only the last        // value in the slice for each duplicate key is used.        Env []string        // Dir specifies the working directory of the command.        // If Dir is the empty string, Run runs the command in the        // calling process&#39;s current directory.        Dir string        // Stdin specifies the process&#39;s standard input.        // If Stdin is nil, the process reads from the null device (os.DevNull).        // If Stdin is an *os.File, the process&#39;s standard input is connected        // directly to that file.        // Otherwise, during the execution of the command a separate        // goroutine reads from Stdin and delivers that data to the command        // over a pipe. In this case, Wait does not complete until the goroutine        // stops copying, either because it has reached the end of Stdin        // (EOF or a read error) or because writing to the pipe returned an error.        Stdin io.Reader        // Stdout and Stderr specify the process&#39;s standard output and error.        //        // If either is nil, Run connects the corresponding file descriptor        // to the null device (os.DevNull).        //        // If Stdout and Stderr are the same writer, and have a type that can be compared with ==,        // at most one goroutine at a time will call Write.        Stdout io.Writer        Stderr io.Writer        // ExtraFiles specifies additional open files to be inherited by the        // new process. It does not include standard input, standard output, or        // standard error. If non-nil, entry i becomes file descriptor 3+i.        ExtraFiles []*os.File        // SysProcAttr holds optional, operating system-specific attributes.        // Run passes it to os.StartProcess as the os.ProcAttr&#39;s Sys field.        SysProcAttr *syscall.SysProcAttr        // Process is the underlying process, once started.        Process *os.Process        // ProcessState contains information about an exited process,        // available after a call to Wait or Run.        ProcessState *os.ProcessState        // contains filtered or unexported fields&#125;</code></pre><p>然后利用cmd调用Start函数，</p><pre><code>func (c *Cmd) Start() error</code></pre><p>Start开始执行以后并不阻塞。如果Start函数返回成功，则c.Process字段将被设置相关内容。在成功调用开始之后，必须调用Wait方法释放关联的系统资源。</p><p>这样，通过上述标准库提供的函数，我们就可以<strong>创建子进程</strong>了，下面我们来看一下如何进行<strong>进程间通信</strong>。</p><h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>操作系统信号（signal，以下简称信号）是IPC中唯一一种异步的通信方法，它的本质是用软件来模拟硬件的中断机制。信号用来通知某个进程有某个事件发生了。<br>每一个信号都有一个以“SIG”为前缀的名字，例如SIGINT、SIGQUIT以及SIGKILL等。在操作系统内部，这些信号都由正整数表示，这些正整数称为信号编号。在Linux的命令行终端下，我们可以使用kill  -l命令来查看当前系统所支持的信号</p><p>接口类型os.Signal 的声明如下：</p><pre><code>type Signal interface &#123;    String() string    Signal() // 与其他 Stringers 区分开来&#125;</code></pre><p>实现了os.Signal接口的类型就是1种信号量，或者说只要实现了Signal和String方法的类型就是1种信号量。比如像syscall.Signal类型，它的底层类型是int，但是它实现了os.Signal接口类型，因此syscall.Signal就是信号量类型（其下有多种信号量，每一个整型数字代表1中信号）。<br>os.Signal的Signal()的实现是一个空方法，syscall.Signal的Singal()是一个空方法，其他实现os.Signal的类型其Signal()也是空方法。Signal()方法的作用仅仅是为了标识这个实现了该方法的类型是一个信号量类型而已。<br>我们可以通过os.Signal的Signal()代码包os&#x2F;signal中的Notify 函数对信号进行接收</p><pre><code>func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</code></pre><p>这个函数需要传入一个channel，signal.Notify方法内部做的事就是接收到来自操作系统进程的信号并将这个信号发送给这个channel。 只有第二参sig中规定的信号量才会发送到chan中，其他信号量不会（而是执行系统默认操作）。然后在用户程序中异步的从这个channel接收信号就可以捕获来自操作系统发送的信号。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>下面是一个Notify调用示例：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;syscall&quot;)func main() &#123;    fmt.Println(&quot;Start running&quot;)    // 定义一个需要自定义处理的信号量列表    signalsHandledByMyself := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;    // 定义一个channel接收来自操作系统的信号，容量为1    signalChannel := make(chan os.Signal, 1)    // Notify监听操作系统是否有发送信号，如果有就会通过往channel发送信号量的方式异步通知当前进程（有信号量的时候才会通知）    signal.Notify(signalChannel, signalsHandledByMyself...)    // 在主进程中接收Notify的通知并处理需要自定义处理的信号    for sign := range signalChannel &#123;        fmt.Printf(&quot;Receive signal from the operating system: %s\n&quot;, sign)    &#125;&#125;</code></pre><p>运行结果如下，可以看到我们已经对信号捕获成功：</p><pre><code>$ go run main.goStart running^CReceive signal from the operating system: interrupt^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^\Receive signal from the operating system: quit^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^CReceive signal from the operating system: interrupt^Z[2]+  Stopped                 go run main.go</code></pre><p>上面我们已经能够对信号进行捕获，现在想从主进程将信号传递到子进程。Cmd保存了子进程的信息，我们查看Cmd结构，可以找到Process(*os.Process)字段有一个Signal函数。</p><pre><code>type Process struct &#123;        Pid int        // contains filtered or unexported fields&#125;func (p *Process) Signal(sig Signal) error</code></pre><p>该函数的作用就是像进程发送信号，如果发送失败则会返回错误，我们可以通过Cmd对象获取对应的Process，然后调用该进程的signal函数像该子进程发送所需要的信号。<br>现在我们已经能够从父进程向子进程发送信号，下面我们创建一个子进程写一个示例，创建main.go文件：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;time&quot;)func main() &#123;    // 创建一个用于执行外部命令的 *exec.Cmd 对象    cmd := exec.Command(&quot;./child&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr        // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;启动子进程出错: &quot;+err.Error())        return    &#125;    // 等待一段时间，然后发送信号    time.Sleep(time.Millisecond * 500)    err = cmd.Process.Signal(os.Interrupt)    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;发送信号出错: &quot;+err.Error())        return    &#125;    // 等待子进程结束    err = cmd.Wait()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;等待子进程结束出错: &quot;+err.Error())    &#125;    return&#125;</code></pre><p>该函数通过 exec 包启动了一个子进程，并在一段时间后向子进程发送中断信号。子进程存储在child.go当中，我们直接运行child.go的编译的可执行文件。下面是子进程一个简单实现：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;)func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    fmt.Println(&quot;started&quot;)    &lt;-stop    fmt.Println(&quot;stopped&quot;)&#125;</code></pre><p>运行结果如下所示：</p><pre><code>$ go run main.gostartedstopped</code></pre><p>可以看到我们已经成功将信号传入了子函数当中。<br>结合Go进程的优雅退出(待附链接，金山文档容易链接失效，等待更新到博客再更新)<br>我们可以创建graceful_shutdown.go：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;time&quot;)func grace() &#123;    fmt.Println(&quot;处理剩余资源&quot;)    time.Sleep(2 * time.Second)&#125;func main() &#123;    stop := make(chan os.Signal, 1)    signal.Notify(stop, os.Interrupt)    for &#123;        select &#123;        case &lt;-stop:            fmt.Println(&quot;收到父进程信号&quot;)            grace()            fmt.Println(&quot;子进程退出&quot;)            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;子进程运行&quot;)        &#125;    &#125;&#125;</code></pre><p>模拟主进程收到信号传递给子进程的过程，我们将main.go文件也进行改写</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;os/signal&quot;    &quot;time&quot;)func main() &#123;    cmd := exec.Command(&quot;./grace_shutdown&quot;)    cmd.Stdout = os.Stdout    cmd.Stderr = os.Stderr    // 启动子进程    err := cmd.Start()    if err != nil &#123;        _, _ = fmt.Fprintf(os.Stderr, &quot;Start: &quot;+err.Error())        return    &#125;    // 创建一个接收信号的通道    sigChannel := make(chan os.Signal, 1)    // 监听中断信号    signal.Notify(sigChannel, os.Interrupt)    for &#123;        select &#123;        case &lt;-sigChannel:            fmt.Println(&quot;父进程收到系统信号&quot;)            // 发送信号给子进程            err = cmd.Process.Signal(os.Interrupt)            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Signal: &quot;+err.Error())                return            &#125;            // 等待子进程结束            err = cmd.Wait()            if err != nil &#123;                _, _ = fmt.Fprintf(os.Stderr, &quot;Wait: &quot;+err.Error())            &#125;            return        case &lt;-time.After(1 * time.Second):            fmt.Println(&quot;wait...&quot;)        &#125;    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code>$ go run main.gowait...子进程运行wait...子进程运行wait...子进程运行^C父进程收到系统信号收到父进程信号处理剩余资源子进程退出</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程通信&quot;&gt;&lt;a href=&quot;#进程通信&quot; class=&quot;headerlink&quot; title=&quot;进程通信&quot;&gt;&lt;/a&gt;进程通信&lt;/h1&gt;&lt;h2 id=&quot;进程的创建&quot;&gt;&lt;a href=&quot;#进程的创建&quot; class=&quot;headerlink&quot; title=&quot;进程的创建&quot;&gt;</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>寻宝大作战</title>
    <link href="http://example.com/p/59129.html"/>
    <id>http://example.com/p/59129.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>暑假要到了。可惜由于种种原因，小 P 原本的出游计划取消。失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……</p><p>某天，小 P 获得了一张神秘的藏宝图。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。<br>简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，<br>地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 A[0][0] 和 A[L][L]。<br>其中 A[i][j]&#x3D;1 表示坐标 (i,j) 处种有一棵树，A[i][j]&#x3D;0 则表示坐标 (i,j) 处没有树。<br>换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。</p><p>传说，大冒险家顿顿的宝藏就埋藏在某棵树下。<br>并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。<br>具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。<br>理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：<br>对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 A[x+i][y+j]&#x3D;B[i][j]。<br>当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。</p><p>实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。<br>请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。</p><p>特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]&#x3D;B[0][0]&#x3D;1，表示了宝藏埋藏的位置。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从标准输入读入数据。</p><p>输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。</p><p>由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。</p><p>最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 B[S−i][0]⋯B[S−i][S]。<br>需要注意，最先输入的是 B[S][0]⋯B[S][S] 一行，B[0][0]⋯B[0][S] 一行最后输入。</p><p><strong>样例 1 输入</strong></p><pre><code>5 100 20 01 12 23 34 40 0 10 1 01 0 0</code></pre><p><strong>样例 1 输出</strong></p><pre><code>3</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>对stl掌握的不好，只能用数组碰运气来做。浪费很多时间，最后只拿了200分，第三题本来可以骗几个用例分数的，，，，，我采用的是记录稀疏矩阵，然后根据横坐标纵坐标排序，最后采用O(n)枚举的暴力做法。代码又臭又长，如下所示（不看也罢）：</p><p> <strong>代码实现</strong></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */struct Zb&#123;    int x;    int y;&#125;zb[1050],cbt[60];int ss[60][60];int cmp(struct Zb a,struct Zb b)&#123;    if(a.x==b.x)&#123;        return a.y&lt;b.y;    &#125;    else return a.x&lt;b.x;    &#125;int main(int argc, char** argv) &#123;    int n,L,s ;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;L,&amp;s);    for(int i=0;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;zb[i].x,&amp;zb[i].y);    &#125;        sort(zb,zb+n,cmp);        int t,count=0;        for(int i=s;i&gt;=0;i--)&#123;            for(int j=0;j&lt;=s;j++)&#123;                scanf(&quot;%d&quot;,&amp;ss[i][j]);                if(ss[i][j]==1)&#123;                    cbt[count].y=j;                    cbt[count].x=i;                    count++;                &#125;            &#125;        &#125;        sort(cbt,cbt+count,cmp);        int vcount =0;        for(int i=0;i&lt;n;i++)&#123;            int flag=0;            int k=i+1;            int countzb=0;            if(zb[i].x&gt;L-s||zb[i].y&gt;L-s)flag=1;            while(zb[k].x-zb[i].x&lt;=s&amp;&amp;k&lt;n)&#123;                if(abs(zb[k].x-zb[i].x)&lt;=s&amp;&amp;zb[k].y-zb[i].y&lt;=s&amp;&amp;zb[k].y-zb[i].y&gt;=0)&#123;                    if(ss[abs(zb[k].x-zb[i].x)][abs(zb[k].y-zb[i].y)]!=1)&#123;                        flag=1;                        break;                    &#125;                     countzb++;                &#125;                k++;            &#125;            if(countzb+1!=count)flag=1;            if(flag==0)&#123;                    vcount++;            &#125;        &#125;        printf(&quot;%d&quot;,vcount);     return 0;&#125;</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p>对于较大数据10^9，如果用二维数组vector的话无法开辟那么大空间，换成二维map来存储可以解决较大数据问题。解决好两个图的存储问题之后，接下来就是找到符合要求的可能埋有宝藏地点个数，无非就是两个条件：一是满足藏宝图可以在绿化图某块区域完美对上，二是满足藏宝图在绿化图中不出界。可以利用这两个条件去判断每一个符合条件的绿树点。如果两个条件都满足即有可能此处为藏宝点。<br><strong>代码实现</strong></p><pre><code>#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;cmath&gt;using namespace std;//pair&lt;int ,int&gt;和int对应map&lt;int,map&lt;int,int&gt; &gt;mp;struct node&#123;    int x,y;&#125;point[1001];int g[51][51];//地图int main()&#123;    int n,L,S;    cin&gt;&gt;n&gt;&gt;L&gt;&gt;S;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;point[i].x&gt;&gt;point[i].y;        mp[point[i].x][point[i].y]=1;    &#125;    //输入也是一个坑    for(int i=S;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=S;j++)&#123;            cin&gt;&gt;g[i][j];        &#125;    &#125;    int cnt=0;    for(int i=0;i&lt;n;i++)&#123;        int flag=1;        int x=point[i].x,y=point[i].y;        for(int j=0;j&lt;=S;j++)&#123;            for(int k=0;k&lt;=S;k++)&#123;                if(x+S&gt;L||y+S&gt;L||mp[x+j][y+k]!=g[j][k])&#123;                    flag=0;                    break;                &#125;            &#125;            if(!flag) break;        &#125;        if(flag) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;</code></pre><p><a href="https://blog.csdn.net/victory066/article/details/125819918">作者原文</a><br><a href="https://blog.csdn.net/victory066/article/details/125819918">https://blog.csdn.net/victory066/article/details/125819918</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;h3 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>非零段划分</title>
    <link href="http://example.com/p/40034.html"/>
    <id>http://example.com/p/40034.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称其中 Ai,…,Aj 是一个非零段     当且仅当以下条件同时满足：    ·1≤i≤j≤n；    ·对于任意的整数 k，若 i≤k≤j，则 Ak＞0；    ·i=1 或 Ai-1=0；    ·j=n 或 Aj+1=0。    下面展示了几个简单的例子：    ·A = [3,1,2,0,0,2,0,4,5,0,2]中的4个非零段依次为[3, 1, 2],[2],[4, 5]和[2]；    ·A = [2, 3, 1, 4, 5] 仅有 1 个非零段；    ·A = [0, 0, 0] 则不含非零段（即非零段个数为 0）。    现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。    试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，    可取 p = 1，即不对 A 做任何修改。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    输入格式    从标准输入读入数据。    输入的第一行包含一个正整数 n。    输入的第二行包含 n 个用空格分隔的自然数 A1, A2, … , An。    输出格式    输出到标准输出。    仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>借用岛屿情况来分析这个题。考虑p足够大的情况，所有的数都被海水淹没了，只有0个岛屿。然后，海平面逐渐下降，岛屿数量出现变化。每当一个凸峰出现，岛屿数就会多一个；每当一个凹谷出现，原本相邻的两个岛屿就被这个凹谷连在一起了，岛屿数减少一个。使用数组cnt[]，cnt[i] 表示海平面下降到i时，岛屿数量的变化。差分法是最简洁的解题程序。数组元素d[i]中存储该元素被替换为0时，划分数变化的差分值。最大值则只需要从其前缀和（程序中为后缀和）中找出最大值就是所要的结果。程序代码中，STL算法函数unique()用来去除相邻重复的元素。语句“a[0] = a[n + 1] = 0;”用来设置边界值，起辅助计算作用，可以简化程序代码。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* CCF202109-2 非零段划分 */#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500000;const int M = 10000;int a[N + 2], d[M + 1];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    a[0] = a[n + 1] = 0;    n = unique(a, a + n + 2) - a - 1;    memset(d, 0, sizeof d);    for (int i = 1; i &lt; n; i++)        if (a[i - 1] &lt; a[i] &amp;&amp; a[i] &gt; a[i + 1]) d[a[i]]++;        else if (a[i - 1] &gt; a[i] &amp;&amp; a[i] &lt;a[i + 1]) d[a[i]]--;    int ans = 0, sum = 0;   // 差分前缀和即为答案    for (int i = M; i &gt;= 1; i--)        sum += d[i], ans = max(ans, sum);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;&#125;</code></pre><p>来源：<a href="https://blog.csdn.net/tigerisland45/article/details/120598581">https://blog.csdn.net/tigerisland45/article/details/120598581</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;     A1,A2,…,An是一个由 n 个自然数（非负整数）组成的数组。我们称</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>防疫大数据</title>
    <link href="http://example.com/p/43256.html"/>
    <id>http://example.com/p/43256.html</id>
    <published>2023-07-11T14:27:38.896Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防疫大数据"><a href="#防疫大数据" class="headerlink" title="防疫大数据"></a>防疫大数据</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>近期，国内 COVID-19 疫情多点散发，西西艾弗岛的防疫形势也异常严峻。西西艾弗岛疫情防控指挥部决定在岛上建立一套疫情风险监测系统。这套风险监测系统的主要功能是，收集手机用户到访地区的信息，根据用户的到访地区，判断用户的疫情风险。具体而言，在每天夜里，西西艾弗岛大数据运行管理中心都会收到一批手机用户到访地区的信息，以及当天疫情风险地区的信息。数据中心需要根据这些信息，生成一份存在风险的手机用户的名单，提供给疫情防控指挥部，以便进行后续的疫情防控工作。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://imgse.com/i/x6kjot"><img src="https://s1.ax1x.com/2022/10/20/x6kjot.png" alt="x6kjot.png"></a></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输出到标准输出。<br>输出 n 行，自第 0 天起，按顺序输出各日运算产生的疫情风险名单。每行包含空格分隔的若干整数。其中第一个整数表示当天的日期，接下来的各个整数为按从小到大排序的存在风险的用户列表。</p><p><strong>样例 1 输入</strong></p><pre><code>91 4 10 1 1-1 1 1-1 2 10 2 20 30 3 11 2 21 3 20 00 00 00 00 00 15 4 11 0 1</code></pre><p><strong>样例 1 输出</strong></p><pre><code>0 11 1 32 1 33 1 34 1 35 1 36 1 378</code></pre><h3 id="本弱鸡解题思路"><a href="#本弱鸡解题思路" class="headerlink" title="本弱鸡解题思路"></a>本弱鸡解题思路</h3><p>无脑做，不知道哪里有问题，只有20分，哭死（）</p><p> <strong>代码实现</strong></p><pre><code>？？？忘保存了！！！</code></pre><h3 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h3><p><strong>代码实现</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;set&lt;LL&gt; sd[1050], su;struct node&#123;    LL d, u, r;&#125;a;vector&lt;node&gt; v[1050];LL n, ri, mi, d, u, r, pi;int main()&#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) // i:生成名单这一天    &#123;        cin &gt;&gt; ri &gt;&gt; mi;                for (int j = 0; j &lt; ri; j ++ ) // ri个风险地区        &#123;            cin &gt;&gt; pi;            for (int k = i; k &lt; i + 7; k ++ ) sd[k].insert(pi); // pi地区i ~ i+6天都是风险地区        &#125;                for (int j = 0; j &lt; mi; j ++ ) //         &#123;            cin &gt;&gt; d &gt;&gt; u &gt;&gt; r;            if (d &lt; 0) continue;            if (!sd[d].count(r)) continue; // 到访的地区在到访的那一日不处于风险状态,肯定无风险            v[i].push_back(&#123;d, u, r&#125;); // 存储第i天的漫游数据        &#125;                // 对漫游信息进行判断,从第i-6天开始.因为7天前的用户漫游数据有可能到现在还是风险的        for (int j = max(0, i - 6); j &lt;= i; j ++ )        &#123;            for (int k = 0; k &lt; v[j].size(); k ++ )            &#123;                d = v[j][k].d;                u = v[j][k].u;                r = v[j][k].r;                                // 1.该用户的d要在7日内                // 2.该用户在近7日内到访的地区在到访的那一日处于风险状态                // 3.上述存在风险的地区自到访日(d)至生成名单当日(i)持续处于风险状态                bool flag = 1;                if (d &lt;= i - 7) continue; // 要求1                for (int l = d; l &lt;= i; l ++ ) // 要一直持续到当前i这一天 要求2&amp;3                    flag = flag &amp; sd[l].count(r);                if (flag) su.insert(u);            &#125;        &#125;                cout &lt;&lt; i &lt;&lt; &quot; &quot;;        for (auto it : su) cout &lt;&lt; it &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;        su.clear();    &#125;        return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防疫大数据&quot;&gt;&lt;a href=&quot;#防疫大数据&quot; class=&quot;headerlink&quot; title=&quot;防疫大数据&quot;&gt;&lt;/a&gt;防疫大数据&lt;/h1&gt;&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="csp" scheme="http://example.com/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://example.com/p/14283.html"/>
    <id>http://example.com/p/14283.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code class="bash">     给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code class="bash">    示例 1:        输入: s = &quot;abcabcbb&quot;        输出: 3         解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。    示例 2:        输入: s = &quot;bbbbb&quot;        输出: 1        解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。    示例 3:        输入: s = &quot;pwwkew&quot;        输出: 3        解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。             请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>    采用双指针的做法，通过一个桶记录字符是否出现过以及出现的位置，在O(n)的时间内解决问题</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        // 记录字符上一次出现的位置        int last[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s[i];            start = max(start, last[index] + 1);            res   = max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;     给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
&lt;/</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数组中数字出现的个数</title>
    <link href="http://example.com/p/34639.html"/>
    <id>http://example.com/p/34639.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组中数字出现的个数"><a href="#数组中数字出现的个数" class="headerlink" title="数组中数字出现的个数"></a>数组中数字出现的个数</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>输入：</p><pre><code>1 2 3 4 4 2</code></pre><p>输出：</p><pre><code>1 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code>这里只想到了如何快速获得一个只出现一次的数字，没有想到分组异或相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>class Solution &#123;public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ret = 0;        for (int n : nums)            ret ^= n;        int div = 1;        while ((div &amp; ret) == 0)            div &lt;&lt;= 1;        int a = 0, b = 0;        for (int n : nums)            if (div &amp; n)                a ^= n;            else                b ^= n;        return vector&lt;int&gt;&#123;a, b&#125;;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组中数字出现的个数&quot;&gt;&lt;a href=&quot;#数组中数字出现的个数&quot; class=&quot;headerlink&quot; title=&quot;数组中数字出现的个数&quot;&gt;&lt;/a&gt;数组中数字出现的个数&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;head</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://example.com/p/52608.html"/>
    <id>http://example.com/p/52608.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串求他的最长回文子串</p><h2 id="方法1-暴力法"><a href="#方法1-暴力法" class="headerlink" title="方法1 暴力法"></a>方法1 暴力法</h2><p>略；</p><h2 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2 动态规划"></a>方法2 动态规划</h2><p>给定一个字符串s，设[p,q]是他的一个从p到q的回文字串，那么当p+1&lt;&#x3D;q-1的时候，[p+1，q-1]必定也是s的一个子串；<br>由此我们可以找到动态规划的递推表达式：</p><p>设：</p><pre><code>dp[i][i]=1; //单个字符是回文串dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串</code></pre><p>思考状态转移方程：</p><pre><code>根据头尾字符是否相等，需要分类讨论：dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></pre><p>最终代码如下：</p><pre><code>string longestPalindrome(string s) &#123;    int slen=s.size();    vector&lt;vector&lt;bool&gt;&gt; dp(slen, vector&lt;bool&gt;(slen, 0));    int maxlenth = 0;    int left = 0;    int right = 0;    for (int i = slen - 1; i &gt;= 0; i--) &#123;        for (int j = i; j &lt; slen; j++) &#123;            if (s[i] == s[j]) &#123;                if (j - i &lt;= 1) &#123;                    dp[i][j] = true;                &#125;                 else if (dp[i + 1][j - 1]) &#123;                     dp[i][j] = true;                &#125;            &#125;            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxlenth) &#123;                maxlenth = j - i + 1;                left = i;                right = j;            &#125;        &#125;    &#125;    return s.substr(left, maxlenth);&#125;</code></pre><h2 id="方法三-中心拓展法"><a href="#方法三-中心拓展法" class="headerlink" title="方法三 中心拓展法"></a>方法三 中心拓展法</h2><p>我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 P(i+1,j-1)P(i+1,j−1) 扩展到 P(i,j)P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</p><pre><code>class Solution &#123;public:    string longestPalindrome(string s) &#123;        int lans=0;        int length=s.size();        int left=0;        string ans=&quot;&quot;;        for(int i=0;i&lt;length;i++)&#123;            int j=1;            int tans=0;            while(i-j&gt;=0&amp;&amp;i+j&lt;length&amp;&amp;s[i-j]==s[i+j])&#123;                tans++;                j++;            &#125;            if(lans&lt;tans*2+1)&#123;                lans=tans*2+1;                left=i-tans;            &#125;            j=0;            tans=0;            while(i-j&gt;=0&amp;&amp;i+j+1&lt;length&amp;&amp;s[i-j]==s[i+j+1])&#123;                    tans++;                    j++;            &#125;            if(lans&lt;tans&lt;&lt;1)&#123;                lans=tans&lt;&lt;1;                left=i-tans+1;            &#125;            if(lans&gt;(length-i)*2)break;        &#125;        ans=s.substr(left,lans);        return ans;    &#125;&#125;;</code></pre><h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><pre><code>int countSubstrings(string s) &#123;    int n = s.size();    string t = &quot;$#&quot;;    for (const char &amp;c: s) &#123;        t += c;        t += &#39;#&#39;;    &#125;    n = t.size();    t += &#39;!&#39;;    auto f = vector &lt;int&gt; (n);    int iMax = 0, rMax = 0, ans = 0;    for (int i = 1; i &lt; n; ++i) &#123;        // 初始化 f[i]        f[i] = (i &lt;= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;        // 中心拓展        while (t[i + f[i]] == t[i - f[i]]) ++f[i];        // 动态维护 iMax 和 rMax        if (i + f[i] - 1 &gt; rMax) &#123;            iMax = i;            rMax = i + f[i] - 1;        &#125;        // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整        ans += (f[i] / 2);    &#125;    return ans;&#125;</code></pre><p>本题目重点需要说明的是马拉车算法；<br>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。那么我们如何统一奇数对称和偶数对称情况呢？<br>在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。<br><a href="https://imgse.com/i/p9eh1Mt"><img src="https://s1.ax1x.com/2023/04/23/p9eh1Mt.png" alt="处理后的字符串.png"></a></p><p>首先我们用一个数组 P 保存从中心扩展的最大个数。我们用 C 表示回文串的中心，用 R 表示回文串的右边半径坐标，所以 R &#x3D; C + P[ C ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。求 P [ i ] 的时候，如下图。</p><p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。<br><a href="https://imgse.com/i/p9ehrLV"><img src="https://s1.ax1x.com/2023/04/23/p9ehrLV.png" alt="p9ehrLV.png"></a></p><p>但是，利用对称性并不一定能完全得到结果<br><a href="https://imgse.com/i/p9ehzOP"><img src="https://s1.ax1x.com/2023/04/23/p9ehzOP.png" alt="p9ehzOP.png"></a><br>当我们要求 P [ i ] 的时候，P [ mirror ] &#x3D; 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i<br>此外如果，mirror因为碰到边界而截止<br><a href="https://imgse.com/i/p9e44hQ"><img src="https://s1.ax1x.com/2023/04/23/p9e44hQ.png" alt="p9e44hQ.png"></a><br>此时P [ i_mirror ] &#x3D; 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” &#x3D;&#x3D; “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><p>总之，综合思想就是利用对称性降低复杂度，使得我们判断过的部分避免反复计算，总体是时间复杂度大概是2n，即O(n);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>日期差值</title>
    <link href="http://example.com/p/1868.html"/>
    <id>http://example.com/p/1868.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>求出两个日期之间的相差的天数，相邻日期算两天</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>示例 1:    输入: 20200111         20200112    输出: 2 </code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一道比较简单的题，只要月份天数闰年平年，注重细节就好了，记录这道题仅仅是熟悉一个思路比较清晰的方法。</p><p>不妨假设第一个日期早于第二个日期（否则交换即可)。<br>这种求日期之间相差天数的题目有一个很直接的思路，即令日期不断加1天，直到第一个日期等于第二个日期为止，即可统计出答案。具体处理时，如果当加了一天之后天数d等于当前月份m所拥有的天数加1，那么就令月份m加1、同时置天数d为1号（即把日期变为下一个月的1号);如果此时月份m变为了13，那么就令年份y加1、同时置月份m为1月（即把日期变为下一年的1月)。<br>为了方便直接取出每个月的天数，不妨给定一个二维数组int month[13][2]，用来存放每个月的天数，其中第二维为0时表示平年，为1时表示闰年。<br>注意:如果想要加快速度，只需要先把第一个日期的年份不断加1，直到与第二个日期的年份相差1为止，期间根据平年或是闰年来累加365天或者366天即可。之后再进行不断令天数加1的操作。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>    #include &lt;cstdio&gt;    int month[13][2] =&#123; //平年和闰年的每个月的天数    &#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,    &#123;31, 31&#125;,&#123;31,31&#125;, &#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;    &#125;    bool isLeap(int year) &#123;//判断是否是闰年        return (year % 4== 0 &amp;&amp; year % 100 = 0) &amp;&amp;(year % 400== 0);    &#125;    int main() &#123;        int timel, yl,ml,dl;        int time2, y2,m2,d2;        while(scanf( &quot;%d%d&quot;,&amp;timel,&amp;time2) !=EOF)&#123;            if(time1 &gt;time2)&#123; 1/第一个日期晚于第二个日期,则交换                int temp=timel;                timel = time2;                time2 = temp;            &#125;            y1 = time1 / 10000, ml = time1 % 10000 / 100,d1 = timel % 100;            y2 = time2 / 10000, m2 = time2 % 10000 / 100,d2 = time2 % 100;            int ans =1;//记录结果            //第一个日期没有达到第二个日期时进行循环            //即!((y1 == y2) &amp;&amp; (ml == m2) &amp;&amp;(d1 == d2))            while(yl&lt; y2 || ml&lt; m2 || d1&lt;d2)&#123;                d1++;//天数加1                if(d1 == month [m1] [isLeap(y1)] +1)&#123;//满当月天数                    m1++;//日期变为下个月的1号                    dl =1;                &#125;                if(m1 ==13) &#123; //月份满12个月                    y1++;//日期变为下一年的1月m1=1;                &#125;                ans++;//累计            &#125;        &#125;    return 0;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;求出两个日期之间的相差的天数，相邻日期算两天
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;输入用例&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数组游戏</title>
    <link href="http://example.com/p/64084.html"/>
    <id>http://example.com/p/64084.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。小猫咪表示“我太难了”你能帮帮它么?</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>输入说明：</p><pre><code>会有多组询问首先输入一个数字t (1&lt;=t&lt;=10)接下来有t组数据每组数据里，首先会有一个数n，表示接下来这个数列的长度为n然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><p>输出描述:</p><pre><code>对于每一个提问，请依次输出最多可以选取多少个数</code></pre><p>备注:</p><pre><code>每个数字a (-10^9&lt;=a&lt;=10^9)(1&lt;=n&lt;=2000)</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题目相对比较简单，注意从左到右依次取，并且取的过程中sum一直非负，而不是最后sum非负，<br>思路:</p><pre><code>从左到右依次遍历，遇到正数或者零直接选，遇到负数则分两种情况，情况1:选了之后sum &gt;= 0，那么直接选。情况2︰选了之后sum &lt; ，那么从已经选择的负数中置换出一个最小的。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main() &#123;    int t;cin &gt; t;    while(t--)&#123;        int n;        while (cin &gt;&gt;n) &#123;            vector&lt;int&gt; nums(n);            for(auto &amp;e : nums) cin &gt;&gt; e;            LL sum = e, cnt = e;            priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;            for(auto &amp;e : nums)&#123;                if(e &gt;= e) &#123;//遥到正数直接选                    sum += e;                    cnt+t;                &#125;                else &#123;                    if(sum + e &gt;= e)&#123;//情况                        sum += e;                        pq.push(e);cnt++;                    &#125;                    else &#123; //情况                        pq. push(e);                        sum += e;                        sum -= pq.top();                        pq. pop();                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; cnt &lt;&lt; endl;    &#125;    return e;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。
凯凯在小黑板上写下一串有正有负的数列，猫咪从左到</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="字节" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>零钱兑换</title>
    <link href="http://example.com/p/61401.html"/>
    <id>http://example.com/p/61401.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</code></pre><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一-暴力法"><a href="#一-暴力法" class="headerlink" title="一 暴力法"></a>一 暴力法</h4><pre><code>—略—</code></pre><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><pre><code>其实这道题很明显就满足最优子结构性，如果想用最少的硬币兑换money，这对硬币的子集的总金额所需硬币数一定是最少的，否则用更少的硬币替换这个子集的硬币，则总money所需硬币数一定比原来少。现在的问题是如何获得状态方程。假设硬币的金额有m1,m2...mx,需要兑换的总金额为money，金额为money的硬币数存在f[money]中，那么f[money]一定可以由f[money-m1]+1,f[money-m2]+1...f[money-mx]+1中的一个或者多个组成，上面已经说明最优子结构，这样，我们只需要找f[money-m1],f[money-m2]...f[money-mx]中的最小值。问题不断分解，分解到f[m1],f[m2]...f[mx]这些确定值上面（都为1）。按照这个思路，我们反向进行迭代最终就可以求得f[money];    </code></pre><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        int Max = amount + 1;        vector&lt;int&gt; dp(amount + 1, Max);        dp[0] = 0;        for (int i = 1; i &lt;= amount; ++i) &#123;            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;                if (coins[j] &lt;= i) &#123;                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &gt; amount ? -1 : dp[amount];    &#125;&#125;;</code></pre><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/">https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长字符串链</title>
    <link href="http://example.com/p/53127.html"/>
    <id>http://example.com/p/53127.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长字符串链"><a href="#最长字符串链" class="headerlink" title="最长字符串链"></a>最长字符串链</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给出一个单词数组 words ，其中每个单词都由小写英文字母组成。</p><p>如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的 前身 。</p><p>例如，”abc” 是 “abac” 的 前身 ，而 “cba” 不是 “bcad” 的 前身<br>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k &#x3D;&#x3D; 1 的 单词链 。</p><p>从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。 </p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>示例 1：</p><pre><code>输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]输出：4解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]</code></pre><p>示例 2:</p><pre><code>输入：words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]输出：5解释：所有的单词都可以放入单词链 [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;].</code></pre><p>示例 3:</p><pre><code>输入：words = [&quot;abcd&quot;,&quot;dbqca&quot;]输出：1解释：字链[&quot;abcd&quot;]是最长的字链之一。[&quot;abcd&quot;，&quot;dbqca&quot;]不是一个有效的单词链，因为字母的顺序被改变了。</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><pre><code>1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 16words[i] 仅由小写英文字母组成。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们将问题分解成几个子问题，我们先来看单词链的判断，单词链相邻单词必然满足长度相差一且长度较长的单词&#x3D;长度短的单词+任意位置插入一个字母，也就是说如果没有插入字母两个字符串是完全相同的，插入一个字母以后，除了那一个位置以外的所有字母都是一一对应的。那么我们可以根据这个对短单词进行遍历，一一与长单词进行对应，如果不相同则跳过这个字母，比对后面的字母，如果跳过次数不等于1，则两个单词不能组成单词链。<br>接下来我们分析题目，需要求最长单词链，我们仔细观察可以发现最长单词链是满足最优子结构性的，例如长度为最大为m的单词组成的最长链必须由单词+最长的单词长度最大为m-1的单词链组成。<br>定义</p><pre><code>dp[i]表示以单词i为结尾的最长的单词链长度</code></pre><p>初始化</p><pre><code>至少一个单词，初始化为1</code></pre><p>计算</p><pre><code>预处理先按照字符串长度升序排列从短到长来计算, 对于当前单词去找序号比它小的 j 情况： 如果相等，则 max(d[i], d[j]+1)</code></pre><p>代码 </p><pre><code>class Solution &#123;    // a是否是b的前身    bool isFor(string&amp; a, string&amp; b) &#123;        int asize=a.size();        int bsize=b.size();        if(bsize - asize== 1) &#123;            int i = 0, j = 0;            while(i &lt; asize &amp;&amp; j &lt; bsize) &#123;                if(a[i] == b[j]) i++;                j++;            &#125;            if(i == asize) return true;        &#125;        return false;    &#125;public:    int longestStrChain(vector&lt;string&gt;&amp; words) &#123;        if(words.size() &lt; 2)            return words.size();                vector&lt;int&gt; dp(words.size(), 1);        int res = 1;                // 按字符串长度递增排序        sort(words.begin(), words.end(),             [](string a, string b) &#123;return a.size() &lt; b.size();&#125;);                for(int i = 0; i &lt; words.size(); i++) &#123;            for(int j = i - 1; j &gt;= 0; j--) &#123;                if(isFor(words[j], words[i])) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-string-chain">https://leetcode.cn/problems/longest-string-chain</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最长字符串链&quot;&gt;&lt;a href=&quot;#最长字符串链&quot; class=&quot;headerlink&quot; title=&quot;最长字符串链&quot;&gt;&lt;/a&gt;最长字符串链&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>棘手怀念摧毁</title>
    <link href="http://example.com/p/12758.html"/>
    <id>http://example.com/p/12758.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="棘手怀念摧毁"><a href="#棘手怀念摧毁" class="headerlink" title="棘手怀念摧毁"></a>棘手怀念摧毁</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p><img src="/p/12758.htm/%E6%A3%98%E6%89%8B%E6%80%80%E5%BF%B5%E6%91%A7%E6%AF%81.png"></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>输入格式:第一行有三个整数n,m，A ;<br>第二行有n个数ai，表示每头大象的愤怒值。<br>输出格式:一个整数表示新大象住下后象棚最大的愤怒值。</p><h2 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h2><p>样例1</p><pre><code>输入:   3 2 50        60 100 70输出:270</code></pre><p>备注<br>其中:1≤m≤n ≤5* 106，0 ≤ai, A ≤100。【样例解释】<br>1.当新大象在第一个位置时(50,60,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 60,100 + max 100,70，即60＋100＋100&#x3D;260。<br>2.当新大象在第二个位置时( 60,50,100,70 )，整个象棚的愤怒值的最大值为max 60,50 + max 50,100 + max 100,70，即60＋100+100&#x3D; 260。<br>3.当新大象在第三个位置时( 60,100,50,70 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,50 + max 50,70，即100＋100＋70 &#x3D; 270。<br>4.当新大象在第四个位置时( 60,100,70,50 )，整个象棚的愤怒值的最大值为max 60,100 + max 100,70 + max 70,50，即70＋100＋100 &#x3D; 270。<br>整个象棚的愤怒值的最大值为max 260,260,270,270 &#x3D; 270。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;棘手怀念摧毁&quot;&gt;&lt;a href=&quot;#棘手怀念摧毁&quot; class=&quot;headerlink&quot; title=&quot;棘手怀念摧毁&quot;&gt;&lt;/a&gt;棘手怀念摧毁&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="码题集" scheme="http://example.com/tags/%E7%A0%81%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>香槟塔</title>
    <link href="http://example.com/p/52292.html"/>
    <id>http://example.com/p/52292.html</id>
    <published>2023-07-11T14:27:38.880Z</published>
    <updated>2023-07-09T09:09:24.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</code></pre><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.00000解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</code></pre><p>示例 2:</p><pre><code>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.50000解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</code></pre><p>示例 3:</p><pre><code>输入: poured = 100000009, query_row = 33, query_glass = 17输出: 1.00000</code></pre><p>提示：</p><pre><code>0 &lt;= poured &lt;= 1090 &lt;= query_glass &lt;= query_row &lt; 100</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>本弱鸡一直在纠结是不是数学问题，暴力的话poured是不是够用，每层减少对应数目，但是最后还是算不出来，最终也没有做出来。贴一个官方题解。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;</code></pre><p>public:<br>    double champagneTower(int poured, int query_row, int query_glass) {<br>        vector<double> row &#x3D; {(double)poured};<br>        for (int i &#x3D; 1; i &lt;&#x3D; query_row; i++) {<br>            vector<double> nextRow(i + 1, 0.0);<br>            for (int j &#x3D; 0; j &lt; row.size(); j++) {<br>                double volume &#x3D; row[j];<br>                if (volume &gt; 1) {<br>                    nextRow[j] +&#x3D; (volume - 1) &#x2F; 2;<br>                    nextRow[j + 1] +&#x3D; (volume - 1) &#x2F; 2;<br>                }<br>            }<br>            row &#x3D; nextRow;<br>        }<br>        return min(1.0, row[query_glass]);<br>    }<br>};</double></double></p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/">https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
