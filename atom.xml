<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-31T14:41:15.404Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七层协议</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-31T14:30:47.327Z</published>
    <updated>2023-07-31T14:41:15.404Z</updated>
    
    <content type="html"><![CDATA[<p>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线<br>数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）<br>传输层：TCP（T&#x2F;TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS&#x2F;SSL<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP&#x2F;2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP</p><h2 id="TCP和UDP的-区别"><a href="#TCP和UDP的-区别" class="headerlink" title="TCP和UDP的 区别"></a>TCP和UDP的 区别</h2><p>TCP是面向有连接型，UDP是面向无连接型；<br>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；<br>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；<br>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线&lt;br&gt;数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）&lt;br&gt;网络层：IP、ICMP、AR</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://example.com/p/36b011d7.html"/>
    <id>http://example.com/p/36b011d7.html</id>
    <published>2023-07-27T14:53:47.358Z</published>
    <updated>2023-07-31T14:29:51.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP：80端口<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><p>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议的主要特点可概括如下：<br>1、支持客户&#x2F;服务器模式。支持基本认证和安全认证。<br>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。<br>5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。<br>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p><p>一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。一般http中存在如下问题：</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h4 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h4><p>减少重定向请求次数；<br>合并请求；<br>延迟发送请求；</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。<br>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。<br>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递<br>如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了，直接通过代理服务器重新请求，而不是客户端重新请求，更进一步，如果代理服务器缓存了重定向网站可以直接向服务端发送请求。</p><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP&#x2F;1.1 管道模式是默认不使用的，所以讨论 HTTP&#x2F;1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。<br>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。</p><p>按需获取的方式，来减少第一时间的 HTTP 请求次数。请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><p>头部压缩<br>二进制格式<br>并发传输<br>服务器主动推送资源</p><h4 id="头部压缩（Header-Compression）"><a href="#头部压缩（Header-Compression）" class="headerlink" title="头部压缩（Header Compression）"></a>头部压缩（Header Compression）</h4><p>http1.x的头带有大量信息，而且每次都要重复发送。http&#x2F;2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p><p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><p>需要注意的是，http 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p><p>http&#x2F;2使用的是专门为首部压缩而设计的HPACK②算法。<br>用header字段表里的索引代替实际的header。</p><p>http&#x2F;2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>http2.0之所以能够突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p><p>在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><h4 id="多路复用-Multiplexing-x2F-连接共享"><a href="#多路复用-Multiplexing-x2F-连接共享" class="headerlink" title="多路复用 (Multiplexing) &#x2F; 连接共享"></a>多路复用 (Multiplexing) &#x2F; 连接共享</h4><p>在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，http&#x2F;2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><h4 id="服务端推送（Server-Push）"><a href="#服务端推送（Server-Push）" class="headerlink" title="服务端推送（Server Push）"></a>服务端推送（Server Push）</h4><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。<br>服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h4 id="http2-0性能瓶颈"><a href="#http2-0性能瓶颈" class="headerlink" title="http2.0性能瓶颈"></a>http2.0性能瓶颈</h4><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。、</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</p><ul><li>HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；</li><li>HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；</li><li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li></ul><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h4 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h4><p>TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>TCP实现高并发有3个弊端：</p><ul><li>实现成本高。TCP是由操作系统内核实现的，如果通过多线程实现并发，并发线程数不能太多，否则线程间切换成本会以指数级上升；如果通过异步、非阻塞socket实现并发，开发效率又太低；</li><li>每个TCP连接与TLS会话都叠加了2-3个RTT的建链成本；</li><li>TCP连接有一个防止出现拥塞的慢启动流程，它会对每个TCP连接都产生减速效果。</li></ul><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="https://s1.ax1x.com/2023/07/30/pPpTX1P.png" alt="小林code"></p><h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。https端口：443</p><p>前面我们知道一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被<strong>窃听截取</strong>。</li><li>数据的完整性未校验，容易被<strong>篡改</strong></li><li>没有验证对方身份，存在<strong>冒充</strong>危险</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了HTTP的风险：</p><ul><li>数据保密性：保证数据内容在传输的过程中不会被第三方查看,交互信息无法被窃取。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</li><li>数据完整性：及时发现被第三方篡改的传输内容,无法篡改通信内容，篡改了就不能正常显示。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</li><li>身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</li></ul><p>对应采取了以下三种做法：</p><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了<strong>窃听</strong>的风险。</li><li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了<strong>冒充</strong>的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。<br>采用「混合加密」的方式的原因：</li><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个哈希值，然后同内容一起传输给对方。<br>对方收到后，先是对内容也计算出一个哈希值，然后跟发送方发送的哈希值做一个比较，如果哈希值相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证秘钥本身就是货真价实的公开密钥；</p><p>那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：</p><p>一个是公钥，这个是可以公开给所有人的；<br>一个是私钥，这个必须由本人管理，不可泄露。<br>这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。<br>流程的不同，意味着目的也不相同：</p><p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<br>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。<br>所以非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。<br>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>前面我们知道：<br>可以通过哈希算法来保证消息的完整性；<br>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？我伪造一个网站然后发给你公钥，按照前面流程我是知道私钥的，因为公钥是我伪造的，前面流程只能验证公钥和私钥匹配的，并不能解决身份冒充的问题。为了解决这个问题，可以使用由数字证书认证机构（CA）和其他相关机构颁发的公开秘钥证书。<br>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程：</li><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><ul><li>服务器拥有自己的私钥与公钥。</li><li>服务器将公钥交给CA认证机构，请求给予一份数字证书。</li><li>CA认证机构生成数字证书，并颁发给服务器。</li><li>服务器将带有公钥信息的数字证书发给客户端。</li><li>进入客户端生成对称密钥再进行对接的过程。</li></ul><h3 id="HTTPS的通信步骤"><a href="#HTTPS的通信步骤" class="headerlink" title="HTTPS的通信步骤"></a>HTTPS的通信步骤</h3><p>SSL&#x2F;TLS 协议基本流程：</p><p>客户端向服务器索要并验证服务器的公钥。<br>双方协商生产「会话秘钥」。<br>双方采用「会话秘钥」进行加密通信。<br>TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法</p><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ul><li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ul><p>客户端回应，客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li><p>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p></li><li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li><li><p>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="https://s1.ax1x.com/2023/07/30/pPp6EZV.png" alt="pPp6EZV.png"></p></li></ul><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改、确保数据的完整性。<br>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但他大幅度增加了中间人攻击的成本。</p><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>慢，HTTPS未经任何优化的情况下要比HTTP慢几百毫秒以上，特别在移动端可能要慢500毫秒以上，关于HTTPS慢和如何优化已经是一个非常系统和复杂的话题。<br>贵，特别在计算性能和服务器成本方面。HTTPS要额外计算，要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。<br>大量的计算.SSL的每一个字节都涉及到较为复杂的计算。即使是clientHello，也需要在握手完成时做校验。<br>TLS协议的封装和解析。HTTPS所有数据都是按照TLS record格式进行封装和解析的。<br>协议的网络交互。从TLS的握手过程可以看出，即使不需要进行任何计算，TLS的握手也需要至少1个RTT（round trip time)以上的网络交互。RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。<br>HTTPS降低用户访问速度（需多次握手）。<br>网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）。<br>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https 访问过程需要加解密）。</p><h3 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h3><p>1）HSTS重定向技术：将http自动转换为https，减少301重定向。<br>2）TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据。直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT<br>3）会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了。<br>4）OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询。<br>5）完全前向加密PFS：使用更牛逼复杂的秘钥算法。</p><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><ol><li>DHCP 请求报文，目的端口67源端口68的UTP报文，广播地址255.255.255.255，源地址0.0.0.0</li><li>DHCP的IP数据报被放置在以太网帧当中以太网帧具有FF:FF:FF:FF:FF:FF进行广播。</li><li>当DHCP服务器收到后，通过CIDR分配IP</li><li>DNS 域名解析发送UDP报文段获取域名IP</li><li>不知道网关路由器mac地址，ARP广播报文查询</li><li>获取mac地址后发送DNS解析帧通过RIP，OSPF，或者IS-IS或者域间协议BGP将报文请求，获取ip</li><li>获取ip后tcp三次握手</li><li>http协议</li></ol><p>在浏览器输入网址后，首先要经过<strong>域名解析</strong>。通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p>为了查找DNS记录，浏览器会检查四个缓存。<br>第一，检查浏览器缓存。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。<br>第二，浏览器检查操作系统缓存。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。<br>第三，检查路由器缓存。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。<br>第四，检查ISP缓存。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。<br>如果请求的URL不在缓存中，ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）<br>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈，生成HTTP 请求信息，<strong>封装成一个 HTTP 数据包。</strong><br>HTTP 底层是依赖 TCP&#x2F;IP 协议实现的，所以在底层数据传输时，会将 HTTP 请求包进一步<strong>封装成 TCP 数据包。</strong><br>打开⼀个socket与⽬标IP地址，端⼝<strong>建⽴TCP链接</strong>，三次握⼿如下：</p><ul><li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端口</li><li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li><li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z<br>TCP链接建⽴后浏览器<strong>向 web 服务器发送一个 HTTP 请求</strong><br>服务器端拿到了客户端的请求参数之后，会进行相应的业务处理，处理完成之后，再将处理的结果返回给客户端。返回的流程和发送的流程类似，先将结果封装成 HTTP 数据包</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https&quot;&gt;&lt;a href=&quot;#http和https&quot; class=&quot;headerlink&quot; title=&quot;http和https&quot;&gt;&lt;/a&gt;http和https&lt;/h1&gt;&lt;h2 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>new/delete  malloc/free 区别</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-26T14:33:36.535Z</published>
    <updated>2023-07-27T13:50:32.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-x2F-delete-malloc-x2F-free-区别"><a href="#new-x2F-delete-malloc-x2F-free-区别" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free 区别"></a>new&#x2F;delete  malloc&#x2F;free 区别</h1><h2 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h2><p>1）plain new（默认new） 2）nothrow new（不抛异常的new） 3）placement new（放置new）</p><h3 id="plain-new-和-nothrow-new"><a href="#plain-new-和-nothrow-new" class="headerlink" title="plain new 和 nothrow new"></a>plain new 和 nothrow new</h3><p>默认的new和nothrow new用法上差不多，只不过是返回值上面的区别</p><p>默认的new在分配失败的时候会抛出异常，而非返回NULL<br>但是nothrow new在分配失败的时候会返回NULL，而不是异常</p><p>下面这个例子，我们一开始先用默认的new，不断要求分配一个内存空间，为了节省时间，可以要求分配的内存空间很大，比较容易达到“无法再分配的状态”。</p><p>当无法再继续分配的时候，new就会抛出异常“std::bad_alloc”</p><p>nothrow new，这时候已经是“无法再分配”，所以直接就会使得nothrow new失败，但是nothrow new返回的是NULL，我们可以验证一下</p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;int main()&#123;    try &#123;        while (true) &#123;            new int[100000000ul];   // throwing overload        &#125;    &#125; catch (const std::bad_alloc&amp; e) &#123;        std::cout &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;    &#125;    while (true) &#123;        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload        if (p == nullptr) &#123;            std::cout &lt;&lt; &quot;Allocation returned nullptr\n&quot;;            break;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>std::bad_allocAllocation returned nullptr</code></pre><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>该运算符用于在已分配的内存上重新构造对象,因为不分配内存，所以也不用担心分配失败<br>我们可以验证一下，我们先分配一块内存并存储数据，然后我们再在这同一块内存中申请一个相同的对象（其他对象也可以，不过要比原先申请的空间小），给新对象赋一个不同的数据，查看最后内存的数据是什么</p><pre><code>// C++ program to illustrate the placement new operator#include&lt;iostream&gt;using namespace std;int main()&#123;    // initial value of X    int X = 10;    cout &lt;&lt; &quot;Before placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    // Placement new changes the value of X to 100    int *mem = new (&amp;X) int(100);    cout &lt;&lt; &quot;\nAfter placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;mem : &quot; &lt;&lt; mem &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code>Before placement new :X : 10&amp;X : 0x7fff71ce8bfcAfter placement new :X : 100 mem : 0x7fff71ce8bfc&amp;X : 0x7fff71ce8bfc</code></pre><p>解释一下，就是一开始内存地址为”0x7fff71ce8bfc”,数据为“10”</p><p>然后进行了palcement new以后，new的内存空间还是原来的内存空间，数据变成了“100”</p><h2 id="new-x2F-delete-和-malloc-x2F-free的区别"><a href="#new-x2F-delete-和-malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free的区别"></a>new&#x2F;delete 和 malloc&#x2F;free的区别</h2><h3 id="引入上"><a href="#引入上" class="headerlink" title="引入上"></a>引入上</h3><p>new&#x2F;delete：这两个是C++中的关键字，若要使用，需要编译器支持；<br>malloc&#x2F;free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。</p><h3 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h3><p>malloc：申请空间需要显式填入申请内存的大小；<br>new：无需显式填入申请的内存大小，new会根据new的类型分配内存。</p><h3 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h3><p>new：申请的内存空间在自由存储区</p><p>malloc：申请的内存空间在堆</p><p>自由存储区：默认是堆，也可以通过自己实现，使得为进程中的其他区域</p><h3 id="是否可以重载"><a href="#是否可以重载" class="headerlink" title="是否可以重载"></a>是否可以重载</h3><p>在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等<br>而malloc和free是C里的库函数，无法对其进行重载。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br>malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。</p><p>malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；<br>new内存分配失败时，会抛出bac_alloc异常，</p><h3 id="对数组的处理"><a href="#对数组的处理" class="headerlink" title="对数组的处理"></a>对数组的处理</h3><p>使用new操作符来分配对象内存时会调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。运行相应的构造函数以构造对象，并为其传入初值，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会调用对象的析构函数，调用operator delete(或operator delete[])函数释放内存空间。</p><p>malloc：和非数组数据的内存分配没有区别<br>free：和非数组数据的的内存释放没有区别</p><p>free怎么知道要释放多大的内存空间？<br>malloc分配空间时，可以理解成整个内存空间分成两块<br>一块在首地址，记录内存的大小的。一块就是你指定大小的内存空间</p><h3 id="是否可以扩展内存空间"><a href="#是否可以扩展内存空间" class="headerlink" title="是否可以扩展内存空间"></a>是否可以扩展内存空间</h3><p>new：不行<br>malloc：可以</p><p>使用malloc分配的空间可以使用realloc函数对其进行内存的扩展</p><p>realloc先判断当前指针指向的内存空间是否有足够的连续空间支持扩展，如果有，直接原地扩展，并且返回原来地址的指针；如果没有，按照新指定的内存空间大小，开辟一块新的内存空间，然后把旧内存空间的数据复制过去，然后释放旧内存空间，返回新内存空间的指针</p><h2 id="既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？"><a href="#既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？" class="headerlink" title="既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h2><p>malloc&#x2F;free适用于： 简单的数据类型（int，char等），这些数据在定义的时候没有构造函数和析构函数，就无须使用new&#x2F;delete，只用简单分配空间和释放空间即可</p><p>new&#x2F;delete适用于： 自定义的类，这些数据在定义的时候往往需要调用构造函数初始化，释放的时候需要调用析构函数。这时简单的内存分配和内存释放无法满足需求，所以这时就需要new和delete</p><h2 id="被free回收的内存怎么处理？"><a href="#被free回收的内存怎么处理？" class="headerlink" title="被free回收的内存怎么处理？"></a>被free回收的内存怎么处理？</h2><p>会被统一管理起来，而不是归还给操作系统</p><p>这些内存空间会被一条双链表连接起来，这样下一次需要分配内存空间的时候，就可以先在这里面找是否合适的内存，合适就直接使用；如果所需内存比这里的内存空间都要大，那么再去重新向系统申请一块内存空间</p><p>这样统一管理，不立即归还给操作系统的好处是避免每次free都要进行系统调用；而且避免返回给操作系统很多小的碎片，难以管理；</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载operator new<br>因为new是关键字，我们本应该无法修改new分配内存的方式。由于new在分配内存时，调用operator new。所以重载operator new就可以修改分配内存的方式了。</p><pre><code>class Foo &#123;public:    Foo() &#123; std::cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; std::endl; &#125;    virtual ~Foo() &#123; std::cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; std::endl; &#125;    void* operator new(std::size_t size)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new(std::size_t size, int num)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new (std::size_t size, void* p)    &#123;        std::cout &lt;&lt; &quot;placement new&quot; &lt;&lt; std::endl;        return p;    &#125;    void operator delete(void* ptr)    &#123;        std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Foo* m = new(100) Foo;    Foo* m2 = new(m) Foo;    std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;    //delete m2;    delete m;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;new-x2F-delete-malloc-x2F-free-区别&quot;&gt;&lt;a href=&quot;#new-x2F-delete-malloc-x2F-free-区别&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete  malloc&amp;#x</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-25T13:57:23.617Z</published>
    <updated>2023-07-25T14:42:40.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>局部static是线程安全的，可以用来实现单例模式</p><h2 id="面向过程设计中的static"><a href="#面向过程设计中的static" class="headerlink" title="面向过程设计中的static"></a>面向过程设计中的static</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。                         </p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的，不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，该变量的值不会因为函数终止而丢失，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><p>修饰函数时，表明该函数只在同一文件中调用。</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突；</li></ul><h2 id="面向对象的static关键字"><a href="#面向对象的static关键字" class="headerlink" title="面向对象的static关键字"></a>面向对象的static关键字</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>用static修饰不访问非静态数据成员的类成员函数。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。</p><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p><strong>在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗。</strong></p><p>答：可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响。</p><p><strong>为什么静态成员函数不能申明为const</strong></p><p>答：这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。<span style="line-height:26px">一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了</span></p><p><strong>为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义</strong><br>答：因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p><strong>static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中。</strong><br>如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。</p><p><strong>为什么常量静态成员数据的初始化可以放在类内（注意：只有静态常量整型数据成员才可以在类中初始化）</strong></p><p>答：是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’&#x3D;’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p><p><strong>为什么静态成员函数只能访问静态成员变量。</strong></p><p>1.静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的<br>2.非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问<br>3.访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</p><p><strong>静态成员函数与非静态成员函数的区别</strong><br>根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。</p><p><strong>为什么要用静态成员变量和静态成员函数</strong><br>为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享</p><p><strong>静态成员的作用、优点</strong><br>静态成员函数主要为了调用方便，不需要生成对象就能调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;p&gt;局部static是线程安全的，可以用来实现单例模式&lt;/p&gt;
&lt;h2 id=&quot;面向过程设计中的static&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>字节提前批</title>
    <link href="http://example.com/p/7d1900d6.html"/>
    <id>http://example.com/p/7d1900d6.html</id>
    <published>2023-07-24T13:41:49.500Z</published>
    <updated>2023-07-25T14:25:23.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节提前批"><a href="#字节提前批" class="headerlink" title="字节提前批"></a>字节提前批</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="malloc是如何跟物理地址关联上的？"><a href="#malloc是如何跟物理地址关联上的？" class="headerlink" title="malloc是如何跟物理地址关联上的？"></a>malloc是如何跟物理地址关联上的？</h3><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP怎么建立连接"><a href="#TCP怎么建立连接" class="headerlink" title="TCP怎么建立连接"></a>TCP怎么建立连接</h3><h3 id="有抓过包吗-（无）"><a href="#有抓过包吗-（无）" class="headerlink" title="有抓过包吗 （无）"></a>有抓过包吗 （无）</h3><h3 id="TCP的可靠性怎么保证"><a href="#TCP的可靠性怎么保证" class="headerlink" title="TCP的可靠性怎么保证"></a>TCP的可靠性怎么保证</h3><h3 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）</h3><h3 id="聊天室是怎么做的，以及一些地方的实现"><a href="#聊天室是怎么做的，以及一些地方的实现" class="headerlink" title="聊天室是怎么做的，以及一些地方的实现"></a>聊天室是怎么做的，以及一些地方的实现</h3><h3 id="用户密码明文存吗"><a href="#用户密码明文存吗" class="headerlink" title="用户密码明文存吗"></a>用户密码明文存吗</h3><h3 id="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"><a href="#因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施" class="headerlink" title="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"></a>因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施</h3><h3 id="TCP和UDP的区别，TCP为什么能保证可靠传输"><a href="#TCP和UDP的区别，TCP为什么能保证可靠传输" class="headerlink" title="TCP和UDP的区别，TCP为什么能保证可靠传输"></a>TCP和UDP的区别，TCP为什么能保证可靠传输</h3><h3 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h3><h3 id="HTTP长连接怎么保活"><a href="#HTTP长连接怎么保活" class="headerlink" title="HTTP长连接怎么保活"></a>HTTP长连接怎么保活</h3><h3 id="输入一个网址到查看到信息，中间的过程"><a href="#输入一个网址到查看到信息，中间的过程" class="headerlink" title="输入一个网址到查看到信息，中间的过程"></a>输入一个网址到查看到信息，中间的过程</h3><h3 id="讲一下什么是IO多路复用"><a href="#讲一下什么是IO多路复用" class="headerlink" title="讲一下什么是IO多路复用"></a>讲一下什么是IO多路复用</h3><h3 id="讲一讲select、poll和epoll的区别"><a href="#讲一讲select、poll和epoll的区别" class="headerlink" title="讲一讲select、poll和epoll的区别"></a>讲一讲select、poll和epoll的区别</h3><h3 id="socket通讯的流程，深入到kernel层面"><a href="#socket通讯的流程，深入到kernel层面" class="headerlink" title="socket通讯的流程，深入到kernel层面"></a>socket通讯的流程，深入到kernel层面</h3><h3 id="poll，select，epoll-ET-x2F-LT"><a href="#poll，select，epoll-ET-x2F-LT" class="headerlink" title="poll，select，epoll,ET&#x2F;LT"></a>poll，select，epoll,ET&#x2F;LT</h3><h3 id="docker里能bind-CPU-是真的bind吗"><a href="#docker里能bind-CPU-是真的bind吗" class="headerlink" title="docker里能bind CPU,是真的bind吗"></a>docker里能bind CPU,是真的bind吗</h3><h3 id="Http框架构成。"><a href="#Http框架构成。" class="headerlink" title="Http框架构成。"></a>Http框架构成。</h3><h3 id="Http和RPC区别。"><a href="#Http和RPC区别。" class="headerlink" title="Http和RPC区别。"></a>Http和RPC区别。</h3><h3 id="RPC的优势。"><a href="#RPC的优势。" class="headerlink" title="RPC的优势。"></a>RPC的优势。</h3><p>14 算法题：给一个二叉树，输出二叉树的左视图，所谓左视图就是每一层最左边的节点</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux命令用过哪些"><a href="#linux命令用过哪些" class="headerlink" title="linux命令用过哪些"></a>linux命令用过哪些</h3><h3 id="死锁怎么产生"><a href="#死锁怎么产生" class="headerlink" title="死锁怎么产生"></a>死锁怎么产生</h3><h3 id="怎么避免死锁"><a href="#怎么避免死锁" class="headerlink" title="怎么避免死锁"></a>怎么避免死锁</h3><h3 id="操作系统中内核态和用户态的区别，分别干什么"><a href="#操作系统中内核态和用户态的区别，分别干什么" class="headerlink" title="操作系统中内核态和用户态的区别，分别干什么"></a>操作系统中内核态和用户态的区别，分别干什么</h3><h3 id="敲键盘发生的中断"><a href="#敲键盘发生的中断" class="headerlink" title="敲键盘发生的中断"></a>敲键盘发生的中断</h3><h3 id="Linux里kernel里的buffer如何通知user的"><a href="#Linux里kernel里的buffer如何通知user的" class="headerlink" title="Linux里kernel里的buffer如何通知user的"></a>Linux里kernel里的buffer如何通知user的</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL的隔离级别有哪几种"><a href="#MySQL的隔离级别有哪几种" class="headerlink" title="MySQL的隔离级别有哪几种"></a>MySQL的隔离级别有哪几种</h3><h3 id="脏读和幻读分别是什么"><a href="#脏读和幻读分别是什么" class="headerlink" title="脏读和幻读分别是什么"></a>脏读和幻读分别是什么</h3><h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><h3 id="小于n的最大数（寄）"><a href="#小于n的最大数（寄）" class="headerlink" title="小于n的最大数（寄）"></a>小于n的最大数（寄）</h3><p>给一个数n，一个数组A，返回由A中元素组成的小于n的最大数<br>如n&#x3D;23121，A&#x3D;{2,4,9| 返回22999<br>n&#x3D;23121 A&#x3D;{9} 返回9999<br>n&#x3D;23333 A&#x3D;{2,3} 返回23332<br>n&#x3D;2222 A&#x3D;{2} 返回222<br>n&#x3D;2 A&#x3D;{2} 无解</p><h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><h3 id="最长连续递增子序列长度"><a href="#最长连续递增子序列长度" class="headerlink" title="最长连续递增子序列长度"></a>最长连续递增子序列长度</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就2，4或3，8，最长长度为2<br>设数组dp[i]，表示以i为结尾的最长连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，1，1，2，1，2}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[6] = &#123;1,5,2,4,3,8&#125;;    int dp[6];    dp[0] = 1;    for(int i=1;i&lt;6;i++)&#123;        dp[i] = 1;        if(Array[i] &gt; Array[i-1])&#123;            dp[i] = dp[i-1] + 1;        &#125;    &#125;    for(int i=0;i&lt;6;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre><h3 id="最长不连续递增子序列"><a href="#最长不连续递增子序列" class="headerlink" title="最长不连续递增子序列"></a>最长不连续递增子序列</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就1，2，418或1，2，3，8，最长长度为4<br>设数组dp[i]，表示以i为结尾的最长不连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，2，2，3，3，4}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[10] = &#123;1,5,2,4,3,8,7,2,9,10&#125;;    int dp[10];    dp[0]=1;    for(int i=1;i&lt;10;i++)&#123;        dp[i] = 1;        for(int j=i-1;j&gt;=0;j--)&#123;            if(Array[i]&gt;Array[j])&#123;                dp[i] = max(dp[i],dp[j]+1);            &#125;        &#125;    &#125;    for(int i=0;i&lt;10;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节提前批&quot;&gt;&lt;a href=&quot;#字节提前批&quot; class=&quot;headerlink&quot; title=&quot;字节提前批&quot;&gt;&lt;/a&gt;字节提前批&lt;/h1&gt;&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C+</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>百度</title>
    <link href="http://example.com/p/158ea4f5.html"/>
    <id>http://example.com/p/158ea4f5.html</id>
    <published>2023-07-24T13:04:37.070Z</published>
    <updated>2023-07-30T10:52:32.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="c-【24提前批】百度嵌入式深度学习一面"><a href="#c-【24提前批】百度嵌入式深度学习一面" class="headerlink" title="c++【24提前批】百度嵌入式深度学习一面"></a>c++【24提前批】百度嵌入式深度学习一面</h2><h3 id="主要关注C-方面，你觉得C-掌握的咋样，C-满分10分你给自己打几分？"><a href="#主要关注C-方面，你觉得C-掌握的咋样，C-满分10分你给自己打几分？" class="headerlink" title="主要关注C++方面，你觉得C++掌握的咋样，C++满分10分你给自己打几分？"></a>主要关注C++方面，你觉得C++掌握的咋样，C++满分10分你给自己打几分？</h3><p>0分</p><h3 id="C-11的特性有没有"><a href="#C-11的特性有没有" class="headerlink" title="C++11的特性有没有"></a>C++11的特性有没有</h3><p>智能指针<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式<br>字符串字面量<br>auto<br>枚举类<br>完美转发<br>移动语义<br>constexptr</p><h3 id="static关键字在C-中有什么作用？"><a href="#static关键字在C-中有什么作用？" class="headerlink" title="static关键字在C++中有什么作用？"></a>static关键字在C++中有什么作用？</h3><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h3 id="static修饰的类的数据成员怎么初始化的？"><a href="#static修饰的类的数据成员怎么初始化的？" class="headerlink" title="static修饰的类的数据成员怎么初始化的？"></a>static修饰的类的数据成员怎么初始化的？</h3><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h3 id="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"><a href="#static修饰类的成员函数，这个成员函数使用起来有哪些限制？" class="headerlink" title="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"></a>static修饰类的成员函数，这个成员函数使用起来有哪些限制？</h3><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h3 id="const关键字修饰类的对象使用起来有什么限制？"><a href="#const关键字修饰类的对象使用起来有什么限制？" class="headerlink" title="const关键字修饰类的对象使用起来有什么限制？"></a>const关键字修饰类的对象使用起来有什么限制？</h3><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h3 id="const关键字修饰类的对象有什么办法改变内部数据？"><a href="#const关键字修饰类的对象有什么办法改变内部数据？" class="headerlink" title="const关键字修饰类的对象有什么办法改变内部数据？"></a>const关键字修饰类的对象有什么办法改变内部数据？</h3><p>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h3 id="C-多态虚函数实现原理。虚函数表里面有哪些东西？"><a href="#C-多态虚函数实现原理。虚函数表里面有哪些东西？" class="headerlink" title="C++多态虚函数实现原理。虚函数表里面有哪些东西？"></a>C++多态虚函数实现原理。虚函数表里面有哪些东西？</h3><h3 id="cpp编译生成二进制文件过程"><a href="#cpp编译生成二进制文件过程" class="headerlink" title=".cpp编译生成二进制文件过程"></a>.cpp编译生成二进制文件过程</h3><p><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><h3 id="动态链接和静态链接区别。"><a href="#动态链接和静态链接区别。" class="headerlink" title="动态链接和静态链接区别。"></a>动态链接和静态链接区别。</h3><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h3 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h3><h3 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h3><p><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><h3 id="STL基本容器用过哪些"><a href="#STL基本容器用过哪些" class="headerlink" title="STL基本容器用过哪些"></a>STL基本容器用过哪些</h3><h3 id="sizeof一个空的结构体，返回什么"><a href="#sizeof一个空的结构体，返回什么" class="headerlink" title="sizeof一个空的结构体，返回什么"></a>sizeof一个空的结构体，返回什么</h3><p>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><h3 id="malloc-x2F-free和new-x2F-delete区别"><a href="#malloc-x2F-free和new-x2F-delete区别" class="headerlink" title="malloc&#x2F;free和new&#x2F;delete区别"></a>malloc&#x2F;free和new&#x2F;delete区别</h3><h3 id="有了new是不是可以就不用malloc了？"><a href="#有了new是不是可以就不用malloc了？" class="headerlink" title="有了new是不是可以就不用malloc了？"></a>有了new是不是可以就不用malloc了？</h3><p>比如内存池，在这个基础上可以利用placement new</p><h2 id="计网："><a href="#计网：" class="headerlink" title="计网："></a>计网：</h2><h3 id="讲一下http和https的不同"><a href="#讲一下http和https的不同" class="headerlink" title="讲一下http和https的不同"></a>讲一下http和https的不同</h3><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><h3 id="用的是对称加密还是非对称加密"><a href="#用的是对称加密还是非对称加密" class="headerlink" title="用的是对称加密还是非对称加密"></a>用的是对称加密还是非对称加密</h3><h3 id="HTTP1-1，-2-0区别"><a href="#HTTP1-1，-2-0区别" class="headerlink" title="HTTP1.1， 2.0区别"></a>HTTP1.1， 2.0区别</h3><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h3 id="TCP能不能改成2次握手"><a href="#TCP能不能改成2次握手" class="headerlink" title="TCP能不能改成2次握手"></a>TCP能不能改成2次握手</h3><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>应用  http ftp  DNS POP3<br>会话<br>表示<br>运输<br>网络  IP，ICMP，RIP，OSPF，BGP，IGMP<br>链路  SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理  ISO2110，IEEE802，IEEE802.2</p><h3 id="tcp建立连接过程"><a href="#tcp建立连接过程" class="headerlink" title="tcp建立连接过程"></a>tcp建立连接过程</h3><h3 id="断开连接过程"><a href="#断开连接过程" class="headerlink" title="断开连接过程"></a>断开连接过程</h3><h3 id="为什么客户端的-TIME-WAIT-状态必须等待-2MSL"><a href="#为什么客户端的-TIME-WAIT-状态必须等待-2MSL" class="headerlink" title="为什么客户端的 TIME-WAIT 状态必须等待 2MSL"></a>为什么客户端的 TIME-WAIT 状态必须等待 2MSL</h3><h3 id="输入网址到浏览器的过程"><a href="#输入网址到浏览器的过程" class="headerlink" title="输入网址到浏览器的过程"></a>输入网址到浏览器的过程</h3><h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="查看端口的命令"><a href="#查看端口的命令" class="headerlink" title="查看端口的命令"></a>查看端口的命令</h3><h3 id="解除端口占用的命令"><a href="#解除端口占用的命令" class="headerlink" title="解除端口占用的命令"></a>解除端口占用的命令</h3><h3 id="查看日志文件接口被调用次数的命令"><a href="#查看日志文件接口被调用次数的命令" class="headerlink" title="查看日志文件接口被调用次数的命令"></a>查看日志文件接口被调用次数的命令</h3><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><h3 id="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"><a href="#死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）" class="headerlink" title="死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）"></a>死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）</h3><h3 id="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"><a href="#进程调度算法有哪些，最短作业优先怎么样的，有什么弊端" class="headerlink" title="进程调度算法有哪些，最短作业优先怎么样的，有什么弊端"></a>进程调度算法有哪些，最短作业优先怎么样的，有什么弊端</h3><h3 id="讲一下select-x2F-pool-x2F-epoll"><a href="#讲一下select-x2F-pool-x2F-epoll" class="headerlink" title="讲一下select&#x2F;pool&#x2F;epoll"></a>讲一下select&#x2F;pool&#x2F;epoll</h3><h3 id="讲一下同步（阻塞，非阻塞）IO-x2F-异步IO"><a href="#讲一下同步（阻塞，非阻塞）IO-x2F-异步IO" class="headerlink" title="讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO"></a>讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO</h3><h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="用过哪些数据库，了解NOSQL吗"><a href="#用过哪些数据库，了解NOSQL吗" class="headerlink" title="用过哪些数据库，了解NOSQL吗"></a>用过哪些数据库，了解NOSQL吗</h3><h3 id="MySQL有哪些索引"><a href="#MySQL有哪些索引" class="headerlink" title="MySQL有哪些索引"></a>MySQL有哪些索引</h3><h3 id="主键索引和唯一索引区别"><a href="#主键索引和唯一索引区别" class="headerlink" title="主键索引和唯一索引区别"></a>主键索引和唯一索引区别</h3><h3 id="一个联合索引（a，b，c），查询（a，c），能用到索引吗"><a href="#一个联合索引（a，b，c），查询（a，c），能用到索引吗" class="headerlink" title="一个联合索引（a，b，c），查询（a，c），能用到索引吗"></a>一个联合索引（a，b，c），查询（a，c），能用到索引吗</h3><h3 id="事物的特性"><a href="#事物的特性" class="headerlink" title="事物的特性"></a>事物的特性</h3><h3 id="SQL注入-怎么避免"><a href="#SQL注入-怎么避免" class="headerlink" title="SQL注入 怎么避免"></a>SQL注入 怎么避免</h3><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h3 id="读已提交和读未提交有什么区别"><a href="#读已提交和读未提交有什么区别" class="headerlink" title="读已提交和读未提交有什么区别"></a>读已提交和读未提交有什么区别</h3><h3 id="解释脏读"><a href="#解释脏读" class="headerlink" title="解释脏读"></a>解释脏读</h3><h3 id="解释可重复读-说一个场景-a数b数"><a href="#解释可重复读-说一个场景-a数b数" class="headerlink" title="解释可重复读 说一个场景 a数b数"></a>解释可重复读 说一个场景 a数b数</h3><h3 id="mvcc实现逻辑"><a href="#mvcc实现逻辑" class="headerlink" title="mvcc实现逻辑"></a>mvcc实现逻辑</h3><h3 id="mysql日志-有哪几种"><a href="#mysql日志-有哪几种" class="headerlink" title="mysql日志 有哪几种"></a>mysql日志 有哪几种</h3><h3 id="mvcc用的哪一个日志"><a href="#mvcc用的哪一个日志" class="headerlink" title="mvcc用的哪一个日志"></a>mvcc用的哪一个日志</h3><h3 id="mysql的锁有哪些"><a href="#mysql的锁有哪些" class="headerlink" title="mysql的锁有哪些"></a>mysql的锁有哪些</h3><h3 id="char和varchar的区别-哪一个效率高"><a href="#char和varchar的区别-哪一个效率高" class="headerlink" title="char和varchar的区别  哪一个效率高"></a>char和varchar的区别  哪一个效率高</h3><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><p>两个包含5亿URL的文件，找两个文件的重复URL，内存只有4G。<br>首先我们最常想到的方法是读取文件a，建立哈希表，然后再读取文件b，遍历文件b中每个url，对于每个遍历，我们都执行查找hash表的操作，若hash表中搜索到了，则说明两文件共有，存入一个集合。</p><p>但上述方法有一个明显问题，加载一个文件的数据需要50亿*64bytes &#x3D; 320G远远大于4G内存，何况我们还需要分配哈希表数据结构所使用的空间，所以不可能一次性把文件中所有数据构建一个整体的hash表。所以虽然可行，但是无法满足需求。</p><p>针对上述问题，我们采用分治算法的思想。</p><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M)，为什么是1000？主要根据内存大小和要分治的文件大小来计算，我们就大致可以把320G大小分为1000份，每份大约300M（当然，到底能不能分布尽量均匀，得看hash函数的设计）</p><p>遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999)（为什么要这样做? 文件a的hash映射和文件b的hash映射函数要保持一致，这样的话相同的url就会保存在对应的小文件中，比如，如果a中有一个url记录data1被hash到了a99文件中，那么如果b中也有相同url，则一定被hash到了b99中）</p><p>所以现在问题转换成了：找出1000对小文件中每一对相同的url（不对应的小文件不可能有相同的url）</p><p>因为每个hash大约300M，所以我们再可以采用哈希中的想法</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="数组中找第K大的数"><a href="#数组中找第K大的数" class="headerlink" title="数组中找第K大的数"></a>数组中找第K大的数</h3><pre><code>class Solution &#123;public:    void quickPartition(vector&lt;int&gt;&amp; nums, int start, int end, int target) &#123;        // 随机取一个数作为基准        srand(time(nullptr));        int random = rand() % (end - start + 1) + start;        int base = nums[random];        // 将该数放到待快排区间开头第一个元素        swap(nums[start], nums[random]);        int index = start;        // 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素        // 交换到index + 1位置，index++，使得最终index前面的元素都比base大。        for (int i = start + 1; i &lt;= end; ++i) &#123;            if (nums[i] &gt;= base) &#123;                swap(nums[index + 1], nums[i]);                index++;            &#125;        &#125;        // base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。        swap(nums[index], nums[start]);            // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，        // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。        if (index &lt; target) &#123;            quickPartition(nums, index + 1, end, target);        &#125;        else if (index &gt; target) &#123;            quickPartition(nums, start, index - 1, target);        &#125;    &#125;    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        // 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，        // 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k    // 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。        quickPartition(nums, 0, nums.size() - 1, k - 1);        return nums[k - 1];    &#125;&#125;;class Solution &#123;    Random random=new Random();    public int findKthLargest(int[] nums, int k) &#123;            return quickSelect(nums,k,0,nums.length-1);    &#125;    public int quickSelect(int[] nums,int k,int left,int right)&#123;        //随机获取一个值作为目标值        int index=random.nextInt(right-left+1)+left;        //保存目标值        int target=nums[index];        //在进行第一次交换时，会丢失nums[left],因此需要保存        nums[index]=nums[left];        int i=left,j=right;        while(i&lt;j)&#123;            while(i&lt;j&amp;&amp;nums[j]&lt;=target) j--;            nums[i]=nums[j];            while(i&lt;j&amp;&amp;nums[i]&gt;=target) i++;            nums[j]=nums[i];        &#125;        nums[i]=target;        //经过交换后，i左部均大于nums[i],右部均小于nums[i]        if(i==k-1) return nums[i];        //说明在左部分        else if(i&gt;k-1) return quickSelect(nums,k,left,i-1);        else return quickSelect(nums,k,i+1,right);    &#125;&#125;</code></pre><h3 id="合并k个链表"><a href="#合并k个链表" class="headerlink" title="合并k个链表"></a>合并k个链表</h3><p>class Solution {<br>public:<br>    struct Status {<br>        int val;<br>        ListNode *ptr;<br>        bool operator &lt; (const Status &amp;rhs) const {<br>            return val &gt; rhs.val;<br>        }<br>    };</p><pre><code>priority_queue &lt;Status&gt; q;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    for (auto node: lists) &#123;        if (node) q.push(&#123;node-&gt;val, node&#125;);    &#125;    ListNode head, *tail = &amp;head;    while (!q.empty()) &#123;        auto f = q.top(); q.pop();        tail-&gt;next = f.ptr;         tail = tail-&gt;next;        if (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);    &#125;    return head.next;&#125;</code></pre><p>};</p><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><pre><code>class Solution &#123;public:    int getKthMagicNumber(int k) &#123;        set&lt;long long&gt; st;        st.insert(1LL);        long long ans = 0;        for(int i=0;i&lt;k;++i)&#123;            ans = *st.begin();            st.erase(st.begin());            st.insert(ans * 3);            st.insert(ans * 5);            st.insert(ans * 7);        &#125;        return ans;    &#125;&#125;;</code></pre><h3 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h3><h3 id="中序遍历递归和非递归写法"><a href="#中序遍历递归和非递归写法" class="headerlink" title="中序遍历递归和非递归写法"></a>中序遍历递归和非递归写法</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度&quot;&gt;&lt;a href=&quot;#百度&quot; class=&quot;headerlink&quot; title=&quot;百度&quot;&gt;&lt;/a&gt;百度&lt;/h1&gt;&lt;h2 id=&quot;c-【24提前批】百度嵌入式深度学习一面&quot;&gt;&lt;a href=&quot;#c-【24提前批】百度嵌入式深度学习一面&quot; class=&quot;head</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://example.com/p/c5176eb2.html"/>
    <id>http://example.com/p/c5176eb2.html</id>
    <published>2023-07-22T08:38:09.342Z</published>
    <updated>2023-07-24T14:24:18.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。RPC 的作用就是体现在这样两个方面：</p><ul><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑</li></ul><h2 id="RPC-通信流程"><a href="#RPC-通信流程" class="headerlink" title="RPC 通信流程"></a>RPC 通信流程</h2><p>RPC 是一个远程调用，那肯定就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。<br>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方<br>从 TCP 通道里面收到二进制数据.根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p><p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验</p><p><img src="https://s1.ax1x.com/2023/07/22/pCqmTbt.png" alt="pCqmTbt.png"></p><p>RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从“单体”演进成“微服务化”，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是“经络”一样的存在。RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p><h2 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h2><p>RPC 本质上就是一个远程调用，那肯定就需要通过网络来传输数据。虽然传输协议可以有多种选择，但考虑到可靠性的话，我们一般默认采用 TCP 协议。为了屏蔽网络传输的复杂性，我们需要封装一个单独的数据传输模块用来收发二进制数据，这个单独模块我们可以叫做传输模块<br>用户请求的时候是基于方法调用，方法出入参数都是对象数据，对象是肯定没法直接在网络中传输的，我们需要提前把它转成可传输的二进制，这就是我们说的序列化过程。但只是把方法调用参数的二进制数据传输到服务提供方是不够的，我们需要在方法调用参数的二进制数据后面增加“断句”符号来分隔出不同的请求，在两个“断句”符号中间放的内容就是我们请求的二进制数据，这个过程我们叫做协议封装。<br>虽然这是两个不同的过程，但其目的都是一样的，都是为了保证数据在网络中可以正确传输。这里我说的正确，可不仅指数据能够传输，还需要保证传输后能正确还原出传输前的语义。所以我们可以把这两个处理过程放在架构中的同一个模块，统称为协议模块。除此之外，我们还可以在协议模块中加入压缩功能，这是因为压缩过程也是对传输的二进制数据进行操作。在实际的网络传输过程中，我们的请求数据包在数据链路层可能会因为太大而被拆分成多个数据包进行传输，为了减少被拆分的次数，从而导致整个传输过程时间太长的问题，我们可以在 RPC 调用的时候这样操作：在方法调用参数或者返回值的二进制数据大于某个阈值的情况下，我们可以通过压缩框架进行无损压缩，然后在另外一端也用同样的压缩算法进行解压，保证数据可还原<br>传输和协议这两个模块是 RPC 里面最基础的功能，它们使对象可以正确地传输到服务提供方。但距离 RPC 的目标——实现像调用本地一样地调用远程，还缺少点东西。因为这两个模块所提供的都是一些基础能力，要让这两个模块同时工作的话，我们需要手写一些黏合的代码，但这些代码对我们使用 RPC 的研发人员来说是没有意义的，而且属于一个重复的工作，会导致使用过程的体验非常不友好。<br>这就需要我们在 RPC 里面把这些细节对研发人员进行屏蔽，让他们感觉不到本地调用和远程调用的区别。假设有用到 Spring 的话，我们希望 RPC 能让我们把一个 RPC 接口定义成一个 Spring Bean，并且这个 Bean 也会统一被 Spring Bean Factory 管理，可以在项目中通过 Spring 依赖注入到方式引用。这是 RPC 调用的入口，我们一般叫做 Bootstrap 模块</p><p>到这儿，一个点对点（Point to Point）版本的 RPC 框架就完成了。我一般称这种模式的 RPC 框架为单机版本，因为它没有集群能力。所谓集群能力，就是针对同一个接口有着多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在 RPC 里面我们还需要给调用方找到所有的服务提供方，并需要在 RPC 里面维护好接口跟服务提供者地址的关系，这样调用方在发起请求的时候才能快速地找到对应的接收地址，这就是我们常说的“服务发现”。</p><p>但服务发现只是解决了接口和服务提供方地址映射关系的查找问题，这更多是一种“静态数据”。说它是静态数据是因为，对于我们的 RPC 来说，我们每次发送请求的时候都是需要用 TCP 连接的，相对服务提供方 IP 地址，TCP 连接状态是瞬息万变的，所以我们的 RPC框架里面要有连接管理器去维护 TCP 连接的状态。<br>有了集群之后，提供方可能就需要管理好这些服务了，那我们的 RPC 就需要内置一些服务治理的功能，比如服务提供方权重的设置、调用授权等一些常规治理手段。而服务调用方需要额外做哪些事情呢？每次调用前，我们都需要根据服务提供方设置的规则，从集群中选择可用的连接用于发送请求</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq17QO.png" alt="pCq17QO.png"></p><p>设计 RPC 框架不可能在开始时就面面俱到。有一天业务方有了新的需求，要加入很多新的功能，这时当前架构面临的可就是大挑战了，要修改很多地方才能实现。这就是我们接下来要讲的插件化架构</p><p>在 RPC 框架里面，我们是怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机制，它可以动态地为某个接口寻找服务实现。使用 SPI 机制需要在 Classpath 下的 META-INF&#x2F;services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。<br>但在实际项目中，我们其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载，ServiceLoader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。</p><p>加上了插件功能之后，我们的 RPC 框架就包含了两大核心体系——核心功能体系与插件体</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3pSf.png" alt="pCq3pSf.png"></p><p>这时，整个架构就变成了一个微内核架构，我们将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离并提供接口的默认实现。这样的架构相比之前的架构，有很多优势。首先它的可扩展性很好，实现了开闭原则，用户可以非常方便地通过插件扩展实现自己的功能，而且不需要修改核心功能的本身；其次就是保持了核心包的精简，依赖外部包少，这样可以有效减少开发人员引入 RPC 导致的包版本冲突问题</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="为什么需要服务发现？"><a href="#为什么需要服务发现？" class="headerlink" title="为什么需要服务发现？"></a>为什么需要服务发现？</h3><p>为了高可用，在生产环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些 IP 随时可能变化，我们也需要用一本“通信录”及时获取到对应的服务节点，这个获取的过程我们一般叫作“服务发现<br>对于服务调用方和服务提供方来说，其契约就是接口，相当于“通信录”中的姓名，服务节点就是提供该契约的一个具体实例。服务 IP 集合作为“通信录”中的地址，从而可以通过接口获取服务 IP 的集合来完成服务的发现。这就是我要说的 PRC 框架的服务发现机制，如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3lm4.png" alt="pCq3lm4.png"></p><ol><li>服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。</li><li>服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用</li></ol><h3 id="基于-ZooKeeper-的服务发现"><a href="#基于-ZooKeeper-的服务发现" class="headerlink" title="基于 ZooKeeper 的服务发现"></a>基于 ZooKeeper 的服务发现</h3><p>整体的思路很简单，就是搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能，整体流程如下图：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3dXD.md.png" alt="pCq3dXD.md.png"></p><p>服务平台管理端先在 ZooKeeper 中创建一个服务根路径，可以根据接口名命名（例如：&#x2F;service&#x2F;com.demo.xxService），在这个路径再创建服务提供方目录与服务调用方目录（例如：provider、consumer），分别用来存储服务提供方的节点信息和服务调用方的节点信息。</p><p>当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。</p><p>当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方 watch 该服务的服务提供方目录（&#x2F;service&#x2F;com.demo.xxService&#x2F;provider）中所有的服务节点数据。</p><p>当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方</p><p>微服务化程度越来越高之后，ZooKeeper 集群整体压力也越来越高,当连接到ZooKeeper 的节点数量特别多，对 ZooKeeper 读写特别频繁，且 ZooKeeper 存储的目录达到一定数量的时候，ZooKeeper 将不再稳定，CPU 持续升高，最终宕机。而宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，ZooKeeper 就因无法承受瞬间的读写压力，马上宕机。</p><h3 id="基于消息总线的最终一致性的注册中心"><a href="#基于消息总线的最终一致性的注册中心" class="headerlink" title="基于消息总线的最终一致性的注册中心"></a>基于消息总线的最终一致性的注册中心</h3><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。<br>而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。</p><p>因为要求最终一致性，我们可以考虑采用消息总线机制。注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据。当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本。<br>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息。对于获取到消息的在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。<br>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面。<br>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并</p><p>为了性能，这里采用了两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性。</p><p>服务调用方拿到的服务节点不是最新的，所以目标节点存在已经下线或不提供指定接口服务的情况，这个时候有没有问题？这个问题我们放到了 RPC 框架里面去处理，在服务调用方发送请求到目标节点后，目标节点会进行合法性验证，如果指定接口服务不存在或正在下线，则会拒绝该请求。服务调用方收到拒绝异常后，会安全重试到其它节点。</p><p>通过消息总线的方式，我们就可以完成注册中心集群间数据变更的通知，保证数据的最终一致性，并能及时地触发注册中心的服务下发操作。服务发现的特性是允许我们在设计超大规模集群服务发现系统的时候，舍弃强一致性，更多地考虑系统的健壮性。最终一致性才是分布式系统设计中更为常用</p><h2 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h2><p>因为有了集群，所以每次发请求前，RPC 框架会根据路由和负载均衡算法选择一个具体的IP 地址。为了保证请求成功，我们就需要确保每次选择出来的 IP 对应的连接是健康的.<br>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能会出现闪断或者网络设备损坏等情况，那怎么保证选择出来的连接一定是可用的呢？</p><p>终极的解决方案是让调用方实时感知到节点的状态变化，这样他们才能做出正确的选择。</p><h3 id="健康检测的逻辑"><a href="#健康检测的逻辑" class="headerlink" title="健康检测的逻辑"></a>健康检测的逻辑</h3><p>当服务方下线，正常情况下我们肯定会收到连接断开的通知事件,但咱们这里不行，因为应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。<br>业内常用的检测方法就是用心跳机制。心跳机制说起来也不复杂，其实就是服务调用方每隔一段时间就问一下服务提供方，“兄弟，你还好吧？”，然后服务提供方很诚实地告诉调用方它目前的状态。</p><p>服务方的状态一般会有三种情况</p><ol><li>健康状态：建立连接成功，并且心跳探活也一直成功；</li><li>亚健康状态：建立连接成功，但是心跳请求连续失败；</li><li>死亡状态：建立连接失败。</li></ol><p>节点的状态并不是固定不变的，它会根据心跳或者重连的结果来动态变化，具体状态间转换图如下：</p><p><img src="https://s1.ax1x.com/2023/07/22/pCq3hng.md.png" alt="pCq3hng.md.png"></p><p>一开始初始化的时候，如果建立连接成功，那就是健康状态，否则就是死亡状态。这里没有亚健康这样的中间态。紧接着，如果健康状态的节点连续出现几次不能响应心跳请求的情况，那就会被标记为亚健康状态，也就是说，服务调用方会觉得它生病了。生病之后（亚健康状态），如果连续几次都能正常响应心跳请求，那就可以转回健康状态，证明病好了。如果病一直好不了，那就会被断定为是死亡节点，死亡之后还需要善后，比如关闭连接<br>当然，死亡并不是真正死亡，它还有复活的机会。如果某个时间点里，死亡的节点能够重连成功，那它就可以重新被标记为健康状态。</p><p>一个节点从健康状态过渡到亚健康状态的前提是“连续”心跳失败次数必须到达某一个阈值</p><ul><li>调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次，所以我们不能把简单的把总失败的次数当作判断条件。</li><li>服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s，所以我们也不能把 TPS 至来当作判断条件。</li></ul><p>所以可以考虑使用可用率，可用率的计算方式是某一个时间窗口内接口调用成功次数的百分比（成功次数 &#x2F; 总调用次数）。当可用率低于个比例就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口也兼顾了接口响应时间不同的问题。</p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p>在真实环境中我们的服务提供方是以一个集群的方式提供服务，这对于服务调用方来说，就是一个接口会有多个服务提供方同时提供服务，所以我们的 RPC 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。<br>既然这些节点都可以用来完成这次请求，那么我们就可以简单地认为这些节点是同质的。就是这次请求无论发送到集合中的哪个节点上，返回的结果都是一样的。<br>既然服务提供方是以集群的方式对外提供服务，那就要考虑一些实际问题。要知道我们每次上线应用的时候都不止一台服务器会运行实例，那上线就涉及到变更，只要变更就可能导致原本正常运行的程序出现异常，尤其是发生重大变动的时候，导致我们应用不稳定的因素就变得很多。为了减少这种风险，我们一般会选择灰度发布我们的应用实例，比如我们可以先发布少量实例观察是否有异常，后续再根据观察的情况，选择发布更多实例还是回滚已经上线的实例。<br>但这种方式不好的一点就是，线上一旦出现问题，影响范围还是挺大的。因为对于我们的服务提供方来说，我们的服务会同时提供给很多调用方来调用，尤其是像一些基础服务的调用方会更复杂，比如商品、价格等等，一旦刚上线的实例有问题，那将会导致所有的调用方业务都会受损。</p><h3 id="如何实现路由策略？"><a href="#如何实现路由策略？" class="headerlink" title="如何实现路由策略？"></a>如何实现路由策略？</h3><p>在 RPC 里面服务调用方是通过服务发现的方式拿到了所有服务提供方的 IP 地址，当我们选择要灰度验证功能的时候，是不是就可以让注册中心在推送的时候区别对待，而不是一股脑的把服务提供方的 IP地址推送到所有调用方。换句话说就是，注册中心只会把刚上线的服务 IP 地址推送到选择指定的调用方，而其他调用方是不能通过服务发现拿到这个 IP 地址的。<br>通过服务发现的方式来隔离调用方请求，从逻辑上来看确实可行，但注册中心在 RPC 里面的定位是用来存储数据并保证数据一致性的。如果把这种复杂的计算逻辑放到注册中心里面，当集群节点变多之后，就会导致注册中心压力很大，而且大部分情况下我们一般都是采用开源软件来搭建注册中心，要满足这种需求还需要进行二次开发。所以从实际的角度出发，通过影响服务发现来实现请求隔离并不划算</p><p>我们可以重新回到调用方发起 RPC 调用的流程。在 RPC 发起真实请求的时候，有一个步骤就是从服务提供方节点集合里面选择一个合适的节点（就是我们常说的负载均衡），那我们是不是可以在选择节点前加上“筛选逻辑”，把符合我们要求的节点筛选出来。那这个筛选的规则是什么呢？就是我们灰度过程中要验证的规则。</p><p>比如我们要求新上线的节点只允许某个 IP 可以调用，那我们的注册中心会把这条规则下发到服务调用方。在调用方收到规则后，在选择具体要发请求的节点前，会先通过筛选规则过滤节点集合，按照这个例子的逻辑，最后会过滤出一个节点，这个节点就是我们刚才新上线的节点。通过这样的改造，RPC 调用流程就变成了这样：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq7jMR.md.png" alt="pCq7jMR.md.png"></p><p>这个筛选过程在RPC 里面有一个专业名词，就是“路由策略”，而上面例子里面的路由策略是我们常见的 IP 路由策略，用于限制可以调用服务提供方的 IP。使用了 IP 路由策略后，整个集群的调用拓扑如下图所示</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqb8hD.png" alt="pCqb8hD.png"></p><h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><p>有了 IP 路由之后，上线过程中我们就可以做到只让部分调用方请求调用到新上线的实例，相对传统的灰度发布功能来说，这样做我们可以把试错成本降到最低。但在有些场景下，我们可能还需要更细粒度的路由方式。比如，在升级改造应用的时候，为了保证调用方能平滑地切调用我们的新应用逻辑，在升级过程中我们常用的方式是让新老应用并行运行一段时间，然后通过切流量百分比的方式，慢慢增大新应用承接的流量，直到新应用承担了 100% 且运行一段时间后才能去下线老应用。</p><p>在流量切换的过程中，为了保证整个流程的完整性，我们必须保证某个主题对象的所有请求都使用同一种应用来承接。假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作是用新应用（或者老应用）来完成所有请求的响应。很显然，上面的 IP 路由并不能满足我们这个需求，因为 IP 路由只是限制调用方来源，并不会根据请求参数请求到我们预设的服务提供方节点上去。</p><p>我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点。在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID，我们可以根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点。因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点。使用了参数路由策略后，整个集群的调用拓扑如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqbdBt.png" alt="pCqbdBt.png"></p><p>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。灰度发布功能是 RPC 路由功能的一个典型应用场景，通过 RPC 路由策略的组合使用可以让服务提供方更加灵活地管理、调用自己的流量，进一步降低上线可能导致的风<br>险。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCqqjMj.png" alt="pCqqjMj.png"></p><p>负载均衡主要分为软负载和硬负载，软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等，硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等。负载均衡的算法主要有随机法、轮询法、最小连接法等。</p><h3 id="RPC-框架中的负载均衡"><a href="#RPC-框架中的负载均衡" class="headerlink" title="RPC 框架中的负载均衡"></a>RPC 框架中的负载均衡</h3><p>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。<br>RPC 负载均衡策略一般包括随机权重、Hash、轮询。当然，这还是主要看 RPC 框架自身的实现。其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制。比如我们默认每个节点的权重都是 100，但当我们把其中的一个节点的权重设置成 50 时，它接收到的流量就是其他节点的 1&#x2F;2。</p><p>由于负载均衡机制完全是由 RPC 框架自身实现的，所以它不再需要依赖任何负载均衡设备，自然也不会发生负载均衡设备的单点问题，服务调用方的负载均衡策略也完全可配，同时我们可以通过控制权重的方式，对负载均衡进行治理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC&quot;&gt;&lt;a href=&quot;#RPC&quot; class=&quot;headerlink&quot; title=&quot;RPC&quot;&gt;&lt;/a&gt;RPC&lt;/h1&gt;&lt;p&gt;RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://example.com/p/a3a0c28e.html"/>
    <id>http://example.com/p/a3a0c28e.html</id>
    <published>2023-07-21T06:12:33.035Z</published>
    <updated>2023-07-24T01:19:39.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><strong>【分库】</strong></p><p>分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就可能会成为瓶颈，因为数据库的连接数是有限的，虽然可以调整，但是也不是无限调整的。当你的数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</p><p>常见的分库方式有：单库单表 -&gt; 单库多表 -&gt; 多库多表</p><p><strong>【分表】</strong></p><p>分表，就是将一个表结构分为多个表，分表后，可以存在于同一个库里，也可以放到不同的库。分表其实主要解决的是数据量大的问题。</p><p>常见的分表方式：</p><ul><li>纵向分表：根据数据的活跃度进行拆分，也就是按照字段使用活跃度来拆分。</li><li>横向分表：把大的表结构，横向切割为同样结构的不同表，也就是同样的表按照某个业务规则复制很多个。</li></ul><p><strong>分库分表根本不是一件事，而是三件事。分别是”只分库不分表”、”只分表不分库”、以及”既分库又分表”。</strong></p><h2 id="为什么需要考虑分库分表呢"><a href="#为什么需要考虑分库分表呢" class="headerlink" title="为什么需要考虑分库分表呢"></a>为什么需要考虑分库分表呢</h2><p>不管是分库还是分表都是因为单个空间内存储数据过多，导致性能下降无法满足正常业务需要。拆分后减小单个个体的负担，缩短操作时间，提高性能满足业务需要。数据库出现性能瓶颈，对外表现有几个方面：</p><ul><li>大量请求阻塞<ul><li>在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。</li></ul></li><li>SQL 操作变慢<ul><li>如果数据库中存在一张上亿数据量的表，一条 SQL 没有命中索引会全表扫描，这个查询耗时会非常久。</li></ul></li><li>存储出现问题<ul><li>业务量剧增，单库数据量越来越大，给存储造成巨大压力。</li></ul></li></ul><p><strong>IO 瓶颈</strong><br>第一种：磁盘读 IO 瓶颈。</p><p>由于热点数据太多，数据库缓存完全放不下，查询时会产生大量的磁盘 IO，查询速度会比较慢，这样会导致产生大量活跃连接，最终可能会发展成无连接可用的后果。</p><p>可以采用一主多从，读写分离的方案，用多个从库分摊查询流量。或者采用分库+水平分表(把一张表的数据拆成多张表来存放，比如订单表可以按 user_id 来拆分)的方案。</p><p>第二种：磁盘写 IO 瓶颈。</p><p>由于数据库写入频繁，会产生频繁的磁盘写入 IO 操作，频繁的磁盘 IO 操作导致产生大量活跃连接，最终同样会发展成无连接可用的后果。</p><p>这时只能采用分库方案，用多个库来分摊写入压力。再加上水平分表的策略，分表后，单表存储的数据量会更小，插入数据时索引查找和更新的成本会更低，插入速度自然会更快。</p><p><strong>CPU 瓶颈</strong></p><p>SQL 问题：如果 SQL 中包含 join，group by，order by，非索引字段条件查询等增加 CPU 运算的操作，会对 CPU 产生明显的压力。</p><p>这时可以考虑 SQL 优化，创建适当的索引，也可以把一些计算量大的SQL逻辑放到应用中处理。</p><p>单表数据量太大：由于单张表数据量过大，比如超过一亿，查询时遍历树的层次太深或者扫描的行太多，SQL 效率会很低，也会非常消耗 CPU。这时可以根据业务场景水平分表。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>随着业务快速发展，数据库中的数据量猛增，所有的数据限制在一台服务器，「数据库物理机本身的CPU、内存、网络IO、磁盘等都会成为性能瓶颈」，此时我们可以按照业务的划分，将不同的表放在不同的服务器中，分散流量，减轻单个数据库的压力，提高系统的性能。</p><p><strong>「垂直分库优点」</strong></p><ul><li>专库专用，业务层面解耦</li><li>能够针对不同业务的数据进行分级管理、维护、监控、扩展</li><li>在一定程度上提升了IO、数据库连接数、降低单机硬件资源的瓶颈</li></ul><p><strong>「垂直分库缺点」</strong></p><ul><li>事务一致性的问题</li><li>多表连接查询困难</li></ul><p><strong>场景</strong>：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>当我们的一行数据过大时，数据页存储的数据行就会减少，也就是说跨数据页查询的概率就会增加，因此垂直分表就是将一个表拆分到多个表，避免出现数据库跨页存储的问题，从而提升查效率。</p><p><strong>「垂直分表拆分原则」</strong></p><ul><li>将热点字段和不常用的字段区分，放在不同的表中</li><li>将text，blob等大字段拆分出来放在附表中</li><li>将组合查询的列放在一张表中</li></ul><p><strong>「垂直分表优点」</strong></p><ul><li>减少锁竞争，查询不同字段数据互不影响</li><li>可实现冷热分离的数据表设计</li><li>可以使得行数据变小，一个数据页能存放更多的数据，最大限度利用数据页缓存，减少查询的 I&#x2F;O 次 数</li></ul><p><strong>「垂直分表缺点」</strong></p><ul><li>事务一致性的问题</li><li>多表连接查询困难</li><li>无法解决单表数据量过大</li></ul><p><strong>场景：</strong>系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>垂直分库是将不同业务表分别放在了不同数据库中以此减轻单个数据库的性能瓶颈，但是如果某个核心业务的并发非常高，比如订单库，双十一下单的并发非常高，单个的订单库仍然存在单个订单数据库性能瓶颈问题，因此我们可以对数据进行分片，将单个订单库进行拆分成多个库，以此提高数据库总体性能。水平分库的本质也是分表，是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</p><p><strong>水平分库优点」</strong></p><ul><li>解决单个库高并发的性能瓶颈</li><li>切分的表的结构相同，应用层改造较少，只需要增加路由规则即可</li><li>提高了系统的稳定性和负载能力。<br><strong>「水平分库缺点」</strong></li><li>分片事务的一致性难以解决</li><li>数据扩容的难度和维护量极大</li></ul><p><strong>场景：</strong>系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>当我们的业务量猛增，单表数据达数千万甚至上亿的时候，查询效率会降低，此时我们考虑将数据表按照一定的规则将表中的记录进行分片，存储在不同的表中，以此提高查询效率。<br>水平分表的本质是数据分片，将不同的数据按照一定的规则（ hash取模&#x2F;range范围）将数据存储在不同的表中，以此减少单表的数据量，提高查询效率</p><p><strong>「水平分表优点」</strong></p><ul><li>解决单表数据量大，查询性能下降的问题</li><li>可实现多表连接查询<br><strong>「水平分表缺点」</strong></li><li>引发排序、分页、函数计算等问题</li><li>数据扩容的难度和维护量极大。</li></ul><p><strong>场景</strong>：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</p><h2 id="数据切分"><a href="#数据切分" class="headerlink" title="数据切分"></a>数据切分</h2><p>当设计中按照业务逻辑实现了分库或者分表，我们在开发过程中怎样将不同的数据存放到指定的库或者表中。要想做到数据的水平切分，在每一个表中都要有相冗余字符作为切分依据和标记字段，通常的应用中我们选用id作为区分字段，基于此就有如下三种分库或者分表的方式和规则：（当然还可以有其他的方式）</p><h3 id="号段分区"><a href="#号段分区" class="headerlink" title="号段分区"></a>号段分区</h3><p>id为1～1000的对应DB1，1001～2000的对应DB2，以此类推；</p><p>优点：可部分迁移</p><p>缺点：数据分布不均</p><h3 id="hash取模分区"><a href="#hash取模分区" class="headerlink" title="hash取模分区"></a>hash取模分区</h3><p>对id进行hash（或者如果id是数值型的话直接使用id 的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对id的hash值进行取模运算，也就是id%4,这样的话每次运算就有四种可能：结果为1的时候对应DB1；结果为2的时候对应DB2；结果为3的时候对应DB3；结果为0的时候对应DB4。这样一来就非常均匀的将数据分配到4个DB中。</p><p>优点：数据分布均匀</p><p>缺点：数据迁移的时候麻烦，不能按照机器性能分摊数据，如果需要扩容二次分表，表的总数量发生变化时，就需要重新计算hash值，就需要涉及到数据迁移了。</p><p>为了解决扩容的问题，我们可以采用一致性哈希的方式来做分表。</p><h3 id="在认证库中保存数据库配置"><a href="#在认证库中保存数据库配置" class="headerlink" title="在认证库中保存数据库配置"></a>在认证库中保存数据库配置</h3><p>就是建立一个DB，这个DB单独保存id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作。</p><p>优点：灵活性强，一对一关系</p><p>缺点：每次查询之前都要多一次查询，性能大打折扣</p><h2 id="分库分表引发什么问题"><a href="#分库分表引发什么问题" class="headerlink" title="分库分表引发什么问题"></a>分库分表引发什么问题</h2><p>分库分表之后，虽然能够解决数据库的性能问题，但是也带来了一系列的其他问题：</p><p>事务问题<br>跨库关联问题<br>排序、分页、函数计算问题<br>分布式ID问题<br>多数据源问题</p><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><h3 id="跨库关联问题"><a href="#跨库关联问题" class="headerlink" title="跨库关联问题"></a>跨库关联问题</h3><p>在单库单表中，我们经常使用JOIN来进行多表查询，但是经过分库分表后多个表可能存在于多个数据库中，无法直接使用join进行联表查询，但是联表查询是非常常见的，所以针对这种情况有以下几种解决方式</p><h4 id="字段冗余"><a href="#字段冗余" class="headerlink" title="字段冗余"></a>字段冗余</h4><p>利用空间换时间，为了性能而避免join查询，将查询字段冗余。<br>例如：订单表保存userId时候，也将用户名称性别等需要查询的字段冗余保存一份，这样查询订单详情时就不需要再去查询用户表了。</p><h4 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h4><p>在系统模块中，对于一些依赖的数据表，在每个数据库都保存一份，避免跨库join查询。</p><h4 id="ER-表（绑定表）"><a href="#ER-表（绑定表）" class="headerlink" title="ER 表（绑定表）"></a>ER 表（绑定表）</h4><p>先确定各个业务表的关联关系，将那些存在关联关系的表记录存放在同一个分片上，避免跨分片join问题</p><h4 id="系统层组装"><a href="#系统层组装" class="headerlink" title="系统层组装"></a>系统层组装</h4><p>在系统层面，分多次查询，将获得到的数据通过代码进行字段拼装</p><h3 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h3><p>分库分表之后，数据分散，在跨节点进行count,order by,group by,limit 以及聚合函数的时候需要特殊处理，可以采用分片的方式：先在每个分片上执行相应的函数，得到结果后在应用程序端进行合并，得到最终结果。</p><h3 id="分布式ID问题"><a href="#分布式ID问题" class="headerlink" title="分布式ID问题"></a>分布式ID问题</h3><p>分库分表之后，我们不能再依赖数据库自增主键了，分表以后每个表都可以自增，会导致ID 重复或者混乱的问题，因此我们需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p><ul><li>UUID</li><li>基于数据库自增单独维护一张 ID表</li><li>号段模式</li><li>Redis</li><li>雪花算法（Snowflake）</li><li>美团Leaf</li><li>滴滴Tinyid</li></ul><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>好处就是本地生成，不要基于数据库；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><h3 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h3><p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p>适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>实例1生成的ID从1000开始，到1999结束。<br>实例2生成的ID从2000开始，到2999结束。<br>实例3生成的ID从3000开始，到3999结束。<br>实例4生成的ID从4000开始，到4999结束。<br>如果第一个实例的ID已经用到1999了怎么办?那就生成一个新的起始值：实例1生成的ID从5000开始，到5999结束。实例2生成的ID从6000开始，到6999结束。实例3生成的ID从7000开始，到7999结束。实例4生成的ID从8000开始，到8999结束。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法也是比较常用的一种分布式ID的生成方式，它具有全局唯一、递增、高可用的特点。</p><p>雪花算法生成的主键主要由 4 部分组成，1bit符号位、41bit时间戳位、10bit工作进程位以及 12bit 序列号位。</p><p>时间戳占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p><p>工作进程位占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p><p>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p><p>所以，一个雪花算法可以在同一毫秒内最多可以生成1024 X 4096 &#x3D; 4194304个唯一的ID</p><h4 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h4><p>这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。</p><p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="多数据源问题"><a href="#多数据源问题" class="headerlink" title="多数据源问题"></a>多数据源问题</h3><p>多数据源主要针对分库，既然数据库变成了多个，那什么时候查询那个库必然是一个必须要解决的问题，一般的解决方式有：「应用程序适配和代理层适配」。一般我们都会使用比较成熟的中间件来处理。</p><h2 id="如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>如何设计才可以让系统从未分库分表动态切换到分库分表上？</h2><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个导数的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>验证一下，ok了，完美，大家伸个懒腰，看看看凌晨 4 点钟的夜景，打个滴滴回家吧。</p><p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看凌晨 4 点的风景。</p><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p><p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p><p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p><p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p><p>现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</p><h2 id="如何设计可以动态扩容缩容的分库分表方案"><a href="#如何设计可以动态扩容缩容的分库分表方案" class="headerlink" title="如何设计可以动态扩容缩容的分库分表方案"></a>如何设计可以动态扩容缩容的分库分表方案</h2><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1小时数据就导完了。这没有问题。</p><p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载32 * 1000 &#x3D; 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 &#x3D; 48000 的写并发，接近 5万&#x2F;s 的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128个库，256个库，512个库。</p><p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>每秒的 5 万写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>一个实践是利用 32 * 32 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><p>+———+——–+——–+<br>| orderId | 库编号 | 表编号 |<br>+———+——–+——–+<br>|   259   |   3    |   8    |<br>|   1189  |   5    |   5    |<br>|   352   |   0    |   11   |<br>|   4593  |   17   |   15   |<br>+———+——–+——–+</p><p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表。</p><p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>这里对步骤做一个总结：</p><ul><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 &#x3D; 库，orderId &#x2F; 32 模 32 &#x3D; 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;【分库】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分库主要解决的是并发量大的问题。因为并发量一旦上来了，那么数据库就</summary>
      
    
    
    
    <category term="Database" scheme="http://example.com/categories/Database/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>concepts</title>
    <link href="http://example.com/p/7082d49f.html"/>
    <id>http://example.com/p/7082d49f.html</id>
    <published>2023-07-20T13:46:19.620Z</published>
    <updated>2023-07-25T14:42:40.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h1><p>我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义half 对于 int 和 string 有不同的作用：</p><pre><code>int half(int n)&#123;    return n / 2;&#125;string half(string s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>除了 int，我们还有差不多的 short、long 等类型，甚至还有 boost::multiprecision::cpp_int；除了 string，我们也还有 wstring、u16string、u32string 等等。上面的每个函数，实际上都适用于一族类型，而不是单个类型。重载在这方面并帮不了什么忙</p><p>C++ 的概念就是用来解决这个问题的。对于上面的例子，我们只需要事先定义了 Integer和 String 的概念），我们就可以写出下面这样的代码：</p><pre><code>template &lt;Integer N&gt;N half(N n)&#123;    return n / 2;&#125;template &lt;String S&gt;S half(S s)&#123;    s.resize(s.size() / 2);    return s;&#125;</code></pre><p>从概念上讲，上面这种形式的含义和下面的代码实质相同（以上面的第一个函数为例）</p><pre><code>template &lt;typename N&gt;requires Integer&lt;N&gt;N half(N n)&#123;    return n / 2;&#125;</code></pre><p>这个 half 是一个函数模板，有一个模板参数，启用这个模板的前提条件是这个参数满足 Integer 这个约束。</p><h2 id="基本的-Concepts"><a href="#基本的-Concepts" class="headerlink" title="基本的 Concepts"></a>基本的 Concepts</h2><p><img src="https://s1.ax1x.com/2023/07/20/pCHyjiT.png" alt="pCHyjiT.png"></p><p>我们从下往上看一下：</p><ul><li>move_constructible：可移动构造</li><li>swappable：可交换</li><li>movable：可移动构造、可交换，合在一起就是可移动了</li><li>copy_constructible：可拷贝构造</li><li>copyable：可拷贝构造、可移动，合在一起就是可拷贝了</li><li>default_initializable：可默认初始化（名字不叫 default_constructible 是因为目前的 type traits 中有 is_default_constructible，且意义和default_initializable 有点微妙的区别；</li><li>semiregular：可复制、可默认初始化，合在一起就是半正则了</li><li>equality_comparable：可相等比较，即对象之间可以使用 &#x3D;&#x3D; 运算符</li><li>regular：半正则、可相等比较，合在一起就是正则了</li></ul><ol><li><code>move_constructible</code>（可移动构造）：类型可以通过移动构造函数从另一个对象获得资源，而不会进行深拷贝。通常用于支持资源所有权的转移。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MyClass &#123;public:    // Move constructor    MyClass(MyClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::move_constructible&lt;MyClass&gt;::value, &quot;MyClass must be move constructible&quot;);</code></pre><ol start="2"><li><code>swappable</code>（可交换）：类型的对象可以通过 <code>std::swap</code> 进行交换，即可以互相交换其内部状态或资源。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class SwappableClass &#123;public:    // Implement the swap function to enable swapping of objects    void swap(SwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::swappable&lt;SwappableClass&gt;, &quot;SwappableClass must be swappable&quot;);</code></pre><ol start="3"><li><code>movable</code>（可移动构造、可交换）：类型既支持移动构造（<code>move_constructible</code>）又支持交换（<code>swappable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">#include &lt;utility&gt;class MovableAndSwappableClass &#123;public:    // Move constructor    MovableAndSwappableClass(MovableAndSwappableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;    // Implement the swap function to enable swapping of objects    void swap(MovableAndSwappableClass&amp; other) &#123;        // Swap the internal state/resources    &#125;&#125;;static_assert(std::movable&lt;MovableAndSwappableClass&gt;, &quot;MovableAndSwappableClass must be movable&quot;);</code></pre><ol start="4"><li><code>copy_constructible</code>（可拷贝构造）：类型可以通过拷贝构造函数从另一个对象创建一个副本。</li></ol><p>示例：</p><pre><code class="cpp">class CopyConstructibleClass &#123;public:    // Copy constructor    CopyConstructibleClass(const CopyConstructibleClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::copy_constructible&lt;CopyConstructibleClass&gt;, &quot;CopyConstructibleClass must be copy constructible&quot;);</code></pre><ol start="5"><li><code>copyable</code>（可拷贝构造、可移动）：类型既支持拷贝构造（<code>copy_constructible</code>）又支持移动构造（<code>move_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class CopyableAndMovableClass &#123;public:    // Copy constructor    CopyableAndMovableClass(const CopyableAndMovableClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;    // Move constructor    CopyableAndMovableClass(CopyableAndMovableClass&amp;&amp; other) &#123;        // Perform resource transfer here    &#125;&#125;;static_assert(std::copyable&lt;CopyableAndMovableClass&gt;, &quot;CopyableAndMovableClass must be copyable&quot;);</code></pre><ol start="6"><li><code>default_initializable</code>（可默认初始化）：类型可以通过默认构造函数进行初始化，而不需要提供任何参数。</li></ol><p>示例：</p><pre><code class="cpp">class DefaultInitializableClass &#123;public:    // Default constructor    DefaultInitializableClass() &#123;        // Initialize internal state/resources here    &#125;&#125;;static_assert(std::default_initializable&lt;DefaultInitializableClass&gt;, &quot;DefaultInitializableClass must be default initializable&quot;);</code></pre><ol start="7"><li><code>semiregular</code>（可复制、可默认初始化）：类型既支持默认初始化（<code>default_initializable</code>）又支持拷贝构造（<code>copy_constructible</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class SemiregularClass &#123;public:    // Default constructor    SemiregularClass() &#123;        // Initialize internal state/resources here    &#125;    // Copy constructor    SemiregularClass(const SemiregularClass&amp; other) &#123;        // Perform deep copy of resources here    &#125;&#125;;static_assert(std::semiregular&lt;SemiregularClass&gt;, &quot;SemiregularClass must be semiregular&quot;);</code></pre><ol start="8"><li><code>equality_comparable</code>（可相等比较）：类型的对象可以使用 <code>==</code> 运算符进行相等比较。</li></ol><p>示例：</p><pre><code class="cpp">class EqualityComparableClass &#123;public:    // Implement the equality operator (==)    bool operator==(const EqualityComparableClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::equality_comparable&lt;EqualityComparableClass&gt;, &quot;EqualityComparableClass must be equality comparable&quot;);</code></pre><ol start="9"><li><code>regular</code>（半正则、可相等比较）：类型既支持可相等比较（<code>equality_comparable</code>）又支持默认初始化（<code>default_initializable</code>）。</li></ol><p>示例：</p><pre><code class="cpp">class RegularClass &#123;public:    // Default constructor    RegularClass() &#123;        // Initialize internal state/resources here    &#125;    // Implement the equality operator (==)    bool operator==(const RegularClass&amp; other) const &#123;        // Implement the comparison logic here        // Return true if objects are considered equal, false otherwise    &#125;&#125;;static_assert(std::regular&lt;RegularClass&gt;, &quot;RegularClass must be regular&quot;);</code></pre><p>上述匹配的行为都是在编译期完成的，因此concept其实是zero-cost的。 </p><pre><code>// 任意类型都能匹配成功的约束，因此mul只要支持乘法运算符的类型都可以匹配成功。template &lt;always_satisfied T&gt;T mul(T a, T b) &#123;    return a * b;&#125;// 整型才能匹配add函数的Ttemplate &lt;integral T&gt;T add(T a, T b) &#123;    return a + b;&#125;// 有符号整型才能匹配subtract函数的Ttemplate &lt;signed_integral T&gt;T subtract(T a, T b) &#123;    return a - b;&#125;int main() &#123;    mul(1, 2); // 匹配成功, T =&gt; int    mul(1.0f, 2.0f);  // 匹配成功，T =&gt; float    add(1, -2);  // 匹配成功, T =&gt; int    add(1.0f, 2.0f); // 匹配失败, T =&gt; float，而T必须是整型    subtract(1U, 2U); // 匹配失败，T =&gt; unsigned int,而T必须是有符号整型    subtract(1, 2); // 匹配成功, T =&gt; int&#125;</code></pre><p>简单总结就是 有3种方式，另外再加上与auto关键字的一些结合方式。</p><pre><code>// 约束函数模板方法1template &lt;my_concept T&gt;void f(T v);// 约束函数模板方法2template &lt;typename T&gt;requires my_concept&lt;T&gt;void f(T v);// 约束函数模板方法3template &lt;typename T&gt;void f(T v) requires my_concept&lt;T&gt;;// 直接约束C++14的auto的函数参数void f(my_concept auto v);// 约束模板的auto参数template &lt;my_concept auto v&gt;void g();// 约束auto变量my_concept auto foo = ...;</code></pre><p>Concept当然也可以用在lambda函数上，使用方法跟上面一样，也有同样数量的花式用法</p><pre><code>// 约束lambda函数的方法1auto f = []&lt;my_concept T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法2auto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) &#123;// ...&#125;;// 约束lambda函数的方法3auto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; &#123;// ...&#125;;// auto函数参数约束auto f = [](my_concept auto v) &#123;// ...&#125;;// auto模板参数约束auto g = []&lt;my_concept auto v&gt; () &#123;// ...&#125;;</code></pre><h2 id="requires关键字的其他用法"><a href="#requires关键字的其他用法" class="headerlink" title="requires关键字的其他用法"></a>requires关键字的其他用法</h2><p>requires关键字不仅能用在concept的使用上，也可以用在定义中。 例如</p><pre><code>// requires用在使用concept时template &lt;typename T&gt;requires my_concept&lt;T&gt;void f(T);// requires用在concept的定义，它表达了类型T的参数f，必须符合大括号内的模式，也就是能被调用。// 也就是它是一个函数或者一个重载了operator()的类型template &lt;typename T&gt;concept callable = requires (T f) &#123; f(); &#125;; template &lt;typename T&gt;requires requires (T x) &#123; x + x; &#125; // `requires` 同时使用在concept的定义和使用上T add(T a, T b) &#123;return a + b;&#125;requires的语法看起来很复杂，初看会觉得很乱，没有啥规律或者总结性的东西。我这边个人理解大概是这样：// 这种也就是，requires后面接的是一个正在被eval的concept，这也就是用在上面的concept的使用中。requires evaled-concept// 本质上，concept在evaluate时，也就会是一个编译期返回结果为bool的表达式。这种其实等价于上面那种。requires expression// 例如 下面这种就是requires后直接接个bool表达式了template &lt;typename T&gt;requires std::is_integral_v&lt;T&gt;T add(T a, T b) &#123;    return a + b;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concepts&quot;&gt;&lt;a href=&quot;#concepts&quot; class=&quot;headerlink&quot; title=&quot;concepts&quot;&gt;&lt;/a&gt;concepts&lt;/h1&gt;&lt;p&gt;我们知道 C++ 里有重载，可以根据参数的类型来选择合适的函数。比如，我们可以定义half </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp20" scheme="http://example.com/tags/cpp20/"/>
    
  </entry>
  
  <entry>
    <title>本地套接字</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-19T14:54:49.693Z</published>
    <updated>2023-07-21T08:17:20.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h1><p>本地套接字是 IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是进程间通信的常用方法，但因为本地套接字开发便捷，接受度高，所以普遍适用于在同一台主机上进程间通信的各种场景.</p><p>现在最火的云计算技术是什么？无疑是 Kubernetes 和 Docker。在 Kubernetes 和 Docker 的技术体系中，有很多优秀的设计，比如 Kubernetes 的 CRI（Container Runtime Interface），其思想是将 Kubernetes 的主要逻辑和 Container Runtime 的实现解耦。</p><p>为了实现和容器运行时的解耦，kubelet 设计了基于本地套接字的客户端 - 服务器 GRPC 调用。<br>Docker 其实也是大量使用了本地套接字技术来构建的。</p><h2 id="本地套接字概述"><a href="#本地套接字概述" class="headerlink" title="本地套接字概述"></a>本地套接字概述</h2><p>本地套接字一般也叫做 UNIX 域套接字，最新的规范已经改叫本地套接字。在前面的 TCP&#x2F;UDP 例子中，我们经常使用 127.0.0.1 完成客户端进程和服务器端进程同时在本机上的通信，那么，这里的本地套接字又是什么呢？</p><p>本地套接字是一种特殊类型的套接字，和 TCP&#x2F;UDP 套接字不同。TCP&#x2F;UDP 即使在本地地址通信，也要走系统网络协议栈，而本地套接字，严格意义上说提供了一种单主机跨进程间调用的手段，减少了协议栈实现的复杂度，效率比 TCP&#x2F;UDP 套接字都要高许多。类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等。<br>比如 X Window 实现，如果发现是本地连接，就会走本地套接字，工作效率非常高。</p><h2 id="本地字节流套接字"><a href="#本地字节流套接字" class="headerlink" title="本地字节流套接字"></a>本地字节流套接字</h2><p>这是一个字节流类型的本地套接字服务器端例子。在这个例子中，服务器程序打开本地套接字后，接收客户端发送来的字节流，并往客户端回送了新的字节流。</p><pre><code class="cpp">#include  &quot;lib/common.h&quot; int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamserver &lt;local_path&gt;&quot;);    &#125;     int listenfd, connfd;    socklen_t clilen;    struct sockaddr_un cliaddr, servaddr;     listenfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (listenfd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;     char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);     if (bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;     if (listen(listenfd, LISTENQ) &lt; 0) &#123;        error(1, errno, &quot;listen failed&quot;);    &#125;     clilen = sizeof(cliaddr);    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;clilen)) &lt; 0) &#123;        if (errno == EINTR)            error(1, errno, &quot;accept failed&quot;);        /* back to for() */        else            error(1, errno, &quot;accept failed&quot;);    &#125;     char buf[BUFFER_SIZE];     while (1) &#123;        bzero(buf, sizeof(buf));        if (read(connfd, buf, BUFFER_SIZE) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s&quot;, buf);         char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, buf);         int nbytes = sizeof(send_line);         if (write(connfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);    &#125;     close(listenfd);    close(connfd);     exit(0); &#125;</code></pre><p>第 12～15 行非常关键，这里创建的套接字类型，注意是 AF_LOCAL，并且使用字节流格式。TCP 的类型是 AF_INET 和字节流类型；UDP 的类型是 AF_INET 和数据报类型。 AF_UNIX 也是可以的，基本上可以认为和 AF_LOCAL 是等价的。<br>第 17～21 行创建了一个本地地址，这里的本地地址和 IPv4、IPv6 地址可以对应，数据类型为 sockaddr_un，这个数据类型中的 sun_family 需要填写为 AF_LOCAL，最为关键的是需要对 sun_path 设置一个本地文件路径。我们这里还做了一个 unlink 操作，以便把存在的文件删除掉，这样可以保持幂等性。<br>第 23～29 行，分别执行 bind 和 listen 操作，这样就监听在一个本地文件路径标识的套接字上，这和普通的 TCP 服务端程序没什么区别。<br>第 41～56 行，使用 read 和 write 函数从套接字中按照字节流的方式读取和发送数据。</p><p>这个本地文件，必须是一个“文件”，不能是一个“目录”。如果文件不存在，后面 bind 操作时会自动创建这个文件。</p><p>下面我们再看一下客户端程序。</p><pre><code class="cpp">#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixstreamclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un servaddr;    sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, argv[1]);    if (connect(sockfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;connect failed&quot;);    &#125;    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int nbytes = sizeof(send_line);        if (write(sockfd, send_line, nbytes) != nbytes)            error(1, errno, &quot;write error&quot;);        if (read(sockfd, recv_line, MAXLINE) == 0)            error(1, errno, &quot;server terminated prematurely&quot;);        fputs(recv_line, stdout);    &#125;    exit(0);&#125;</code></pre><p>11～14 行创建了一个本地套接字，和前面服务器端程序一样，用的也是字节流类型 SOCK_STREAM。<br>16～18 行初始化目标服务器端的地址。我们知道在 TCP 编程中，使用的是服务器的 IP 地址和端口作为目标，在本地套接字中则使用文件路径作为目标标识，sun_path 这个字段标识的是目标文件路径，所以这里需要对 sun_path 进行初始化。<br>20 行和 TCP 客户端一样，发起对目标套接字的 connect 调用，不过由于是本地套接字，并不会有三次握手。<br>28～38 行从标准输入中读取字符串，向服务器端发送，之后将服务器端传输过来的字符打印到标准输出上。</p><p>本地字节流套接字和 TCP 服务器端、客户端编程最大的差异就是套接字类型的不同。本地字节流套接字识别服务器不再通过 IP 地址和端口，而是通过本地文件。</p><h2 id="只启动客户端"><a href="#只启动客户端" class="headerlink" title="只启动客户端"></a>只启动客户端</h2><p>第一个场景中，我们只启动客户端程序：</p><pre><code>$ ./unixstreamclient /tmp/unixstream.sockconnect failed: No such file or directory (2)</code></pre><p>由于没有启动服务器端，没有一个本地套接字在 &#x2F;tmp&#x2F;unixstream.sock 这个文件上监听，客户端直接报错，提示我们没有文件存在。</p><h2 id="服务器端监听在无权限的文件路径上"><a href="#服务器端监听在无权限的文件路径上" class="headerlink" title="服务器端监听在无权限的文件路径上"></a>服务器端监听在无权限的文件路径上</h2><p>在 Linux 下，执行任何应用程序都有应用属主的概念。在这里，我们让服务器端程序的应用属主没有 &#x2F;var&#x2F;lib&#x2F; 目录的权限，然后试着启动一下这个服务器程序 ：</p><pre><code>$ ./unixstreamserver /var/lib/unixstream.sockbind failed: Permission denied (13)</code></pre><p>这个结果告诉我们启动服务器端程序的用户，必须对本地监听路径有权限。<br>试一下 root 用户启动该程序：</p><pre><code>sudo ./unixstreamserver /var/lib/unixstream.sock(阻塞运行中)</code></pre><p>打开另外一个 shell，我们看到 &#x2F;var&#x2F;lib 下创建了一个本地文件，大小为 0，而且文件的最后结尾有一个（&#x3D;）号。其实这就是 bind 的时候自动创建出来的文件。</p><pre><code>$ ls -al /var/lib/unixstream.sockrwxr-xr-x 1 root root 0 Jul 15 12:41 /var/lib/unixstream.sock=</code></pre><p>如果我们使用 netstat 命令查看 UNIX 域套接字，就会发现 unixstreamserver 这个进程，监听在 &#x2F;var&#x2F;lib&#x2F;unixstream.sock 这个文件路径上。</p><h2 id="服务器-客户端应答"><a href="#服务器-客户端应答" class="headerlink" title="服务器 - 客户端应答"></a>服务器 - 客户端应答</h2><p>现在，我们让服务器和客户端都正常启动，并且客户端依次发送字符：</p><pre><code>$./unixstreamserver /tmp/unixstream.sockReceive: g1Receive: g2Receive: g3client quit</code></pre><p>服务器端陆续收到客户端发送的字节，同时，客户端也收到了服务器端的应答；最后，当我们使用 Ctrol+C，让客户端程序退出时，服务器端也正常退出。</p><pre><code>$./unixstreamclient /tmp/unixstream.sockg1Hi, g1g2Hi, g2g3Hi, g3^C</code></pre><h2 id="本地数据报套接字"><a href="#本地数据报套接字" class="headerlink" title="本地数据报套接字"></a>本地数据报套接字</h2><p>我们再来看下在本地套接字上使用数据报的服务器端例子：</p><pre><code>#include  &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataserver &lt;local_path&gt;&quot;);    &#125;    int socket_fd;    socket_fd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (socket_fd &lt; 0) &#123;        error(1, errno, &quot;socket create failed&quot;);    &#125;    struct sockaddr_un servaddr;    char *local_path = argv[1];    unlink(local_path);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sun_family = AF_LOCAL;    strcpy(servaddr.sun_path, local_path);    if (bind(socket_fd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    char buf[BUFFER_SIZE];    struct sockaddr_un client_addr;    socklen_t client_len = sizeof(client_addr);    while (1) &#123;        bzero(buf, sizeof(buf));        if (recvfrom(socket_fd, buf, BUFFER_SIZE, 0, (struct sockadd *) &amp;client_addr, &amp;client_len) == 0) &#123;            printf(&quot;client quit&quot;);            break;        &#125;        printf(&quot;Receive: %s \n&quot;, buf);        char send_line[MAXLINE];        bzero(send_line, MAXLINE);        sprintf(send_line, &quot;Hi, %s&quot;, buf);        size_t nbytes = strlen(send_line);        printf(&quot;now sending: %s \n&quot;, send_line);        if (sendto(socket_fd, send_line, nbytes, 0, (struct sockadd *) &amp;client_addr, client_len) != nbytes)            error(1, errno, &quot;sendto error&quot;);    &#125;    close(socket_fd);    exit(0);&#125;</code></pre><p>本地数据报套接字和前面的字节流本地套接字有以下几点不同：</p><p>这里创建的套接字类型，注意是 AF_LOCAL，协议类型为 SOCK_DGRAM。<br>bind 到本地地址之后，没有再调用 listen 和 accept，这其实和 UDP 的性质一样。<br>使用 recvfrom 和 sendto 来进行数据报的收发，不再是 read 和 send</p><p>然后我们再看一下客户端的例子：</p><pre><code>#include &quot;lib/common.h&quot;int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: unixdataclient &lt;local_path&gt;&quot;);    &#125;    int sockfd;    struct sockaddr_un client_addr, server_addr;    sockfd = socket(AF_LOCAL, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        error(1, errno, &quot;create socket failed&quot;);    &#125;    bzero(&amp;client_addr, sizeof(client_addr));        /* bind an address for us */    client_addr.sun_family = AF_LOCAL;    strcpy(client_addr.sun_path, tmpnam(NULL));    if (bind(sockfd, (struct sockaddr *) &amp;client_addr, sizeof(client_addr)) &lt; 0) &#123;        error(1, errno, &quot;bind failed&quot;);    &#125;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sun_family = AF_LOCAL;    strcpy(server_addr.sun_path, argv[1]);    char send_line[MAXLINE];    bzero(send_line, MAXLINE);    char recv_line[MAXLINE];    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        size_t nbytes = strlen(send_line);        printf(&quot;now sending %s \n&quot;, send_line);        if (sendto(sockfd, send_line, nbytes, 0, (struct sockaddr *) &amp;server_addr, sizeof(server_addr)) != nbytes)            error(1, errno, &quot;sendto error&quot;);        int n = recvfrom(sockfd, recv_line, MAXLINE, 0, NULL, NULL);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>这个程序和 UDP 网络编程的例子基本是一致的，我们可以把它当做是用本地文件替换了 IP 地址和端口的 UDP 程序，不过，这里还是有一个非常大的不同的。</p><p>这个不同点是本地套接字 bind 到本地一个路径上，然而 UDP 客户端程序是不需要这么做的。本地数据报套接字这么做的原因是，它需要指定一个本地路径，以便在服务器端回包时，可以正确地找到地址；而在 UDP 客户端程序里，数据是可以通过 UDP 包的本地地址和端口来匹配的。</p><p>下面这段代码就展示了服务器端和客户端通过数据报应答的场景：</p><pre><code>./unixdataserver /tmp/unixdata.sockReceive: g1now sending: Hi, g1Receive: g2now sending: Hi, g2Receive: g3now sending: Hi, g3</code></pre><p>我们可以看到，服务器端陆续收到客户端发送的数据报，同时，客户端也收到了服务器端的应答。</p><pre><code>$ ./unixdataclient /tmp/unixdata.sockg1now sending g1Hi, g1g2now sending g2Hi, g2g3now sending g3Hi, g3^C</code></pre><p>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议。<br>本地套接字的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报套接字实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地套接字&quot;&gt;&lt;a href=&quot;#本地套接字&quot; class=&quot;headerlink&quot; title=&quot;本地套接字&quot;&gt;&lt;/a&gt;本地套接字&lt;/h1&gt;&lt;p&gt;本地套接字是 IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>UDP</title>
    <link href="http://example.com/p/6a48eebc.html"/>
    <id>http://example.com/p/6a48eebc.html</id>
    <published>2023-07-19T14:43:53.003Z</published>
    <updated>2023-07-21T08:17:20.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>TCP 是一个面向连接的协议，TCP 在 IP 报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定的上下文中工作的。</p><p>而 UDP 则不同，UDP 没有这样一个确定的上下文，它是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。我们可以简单地理解为，在 IP 报文的基础上，UDP 增加的能力有限。<br>UDP 不保证报文的有效传递，不保证报文的有序，也就是说使用 UDP 的时候，我们需要做好丢包、重传、报文组装等工作。</p><p><img src="https://s1.ax1x.com/2023/07/19/pC7BS54.png" alt="pC7BS54.png"></p><p>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 recvfrom 函数等待客户端的报文发送；客户端创建套接字之后，调用 sendto 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程。<br>recvfrom 和 sendto 是 UDP 用来接收和发送报文的两个主要函数：</p><pre><code>#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,const struct sockaddr *to, socklen_t *addrlen); </code></pre><p>先来看一下 recvfrom 函数。</p><ul><li><p>sockfd、buff 和 nbytes 是前三个参数。sockfd 是本地创建的套接字描述符，buff 指向本地的缓存，nbytes 表示最大接收数据字节。第四个参数 flags 是和 I&#x2F;O 相关的参数，这里我们还用不到，设置为 0。</p></li><li><p>后面两个参数 from 和 addrlen，实际上是返回对端发送方的地址和端口等信息，这和 TCP 非常不一样，TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息。另外 UDP 报文每次接收都会获取对端的信息，也就是说报文和报文之间是没有上下文的。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>接下来看一下 sendto 函数。</p><ul><li><p>sendto 函数中的前三个参数为 sockfd、buff 和 nbytes。sockfd 是本地创建的套接字描述符，buff 指向发送的缓存，nbytes 表示发送字节数。第四个参数 flags 依旧设置为 0。</p></li><li><p>后面两个参数 to 和 addrlen，表示发送的对端地址和端口等信息。</p></li><li><p>函数的返回值告诉我们实际接收的字节数。</p></li></ul><p>TCP 的发送和接收每次都是在一个上下文中，类似这样的过程：</p><p>A 连接上: 接收→发送→接收→发送→…<br>B 连接上: 接收→发送→接收→发送→ …</p><p>而 UDP 的每次接收和发送都是一个独立的上下文，类似这样：</p><p>接收 A→发送 A→接收 B→发送 B →接收 C→发送 C→ …</p><h2 id="UDP-服务端例子"><a href="#UDP-服务端例子" class="headerlink" title="UDP 服务端例子"></a>UDP 服务端例子</h2><p>先来看一个 UDP 服务器端的例子：</p><pre><code>#include &quot;lib/common.h&quot;static int count;static void recvfrom_int(int signo) &#123;    printf(&quot;\nreceived %d datagrams\n&quot;, count);    exit(0);&#125;int main(int argc, char **argv) &#123;    int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);    bind(socket_fd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));    socklen_t client_len;    char message[MAXLINE];    count = 0;    signal(SIGINT, recvfrom_int);//信号    struct sockaddr_in client_addr;    client_len = sizeof(client_addr);    for (;;) &#123;        int n = recvfrom(socket_fd, message, MAXLINE, 0, (struct sockaddr *) &amp;client_addr, &amp;client_len);        message[n] = 0;        printf(&quot;received %d bytes: %s\n&quot;, n, message);        char send_line[MAXLINE];        sprintf(send_line, &quot;Hi, %s&quot;, message);        sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;client_addr, client_len);        count++;    &#125;&#125;</code></pre><p>首先创建一个套接字，这里的套接字类型是“SOCK_DGRAM”，表示的是 UDP 数据报。<br>绑定数据报套接字到本地的一个端口上。<br>为该服务器创建了一个信号处理函数，以便在响应“Ctrl+C”退出时，打印出收到的报文总数。<br>通过调用 recvfrom 函数获取客户端发送的报文，之后我们对收到的报文进行重新改造，加上“Hi”的前缀，再通过 sendto 函数发送给客户端对端。</p><h2 id="UDP-客户端例子"><a href="#UDP-客户端例子" class="headerlink" title="UDP 客户端例子"></a>UDP 客户端例子</h2><p>接下来我们再来构建一个对应的 UDP 客户端。在这个例子中，从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上。</p><pre><code>#include &quot;lib/common.h&quot;# define    MAXLINE     4096int main(int argc, char **argv) &#123;    if (argc != 2) &#123;        error(1, 0, &quot;usage: udpclient &lt;IPaddress&gt;&quot;);    &#125;        int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server_addr;    bzero(&amp;server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);    socklen_t server_len = sizeof(server_addr);    struct sockaddr *reply_addr;    reply_addr = malloc(server_len);    char send_line[MAXLINE], recv_line[MAXLINE + 1];    socklen_t len;    int n;    while (fgets(send_line, MAXLINE, stdin) != NULL) &#123;        int i = strlen(send_line);        if (send_line[i - 1] == &#39;\n&#39;) &#123;            send_line[i - 1] = 0;        &#125;        printf(&quot;now sending %s\n&quot;, send_line);        size_t rt = sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &amp;server_addr, server_len);        if (rt &lt; 0) &#123;            error(1, errno, &quot;send failed &quot;);        &#125;        printf(&quot;send bytes: %zu \n&quot;, rt);        len = 0;        n = recvfrom(socket_fd, recv_line, MAXLINE, 0, reply_addr, &amp;len);        if (n &lt; 0)            error(1, errno, &quot;recvfrom failed&quot;);        recv_line[n] = 0;        fputs(recv_line, stdout);        fputs(&quot;\n&quot;, stdout);    &#125;    exit(0);&#125;</code></pre><p>创建一个类型为“SOCK_DGRAM”的套接字。<br>初始化目标服务器的地址和端口。<br>从标准输入中读取的字符进行处理后，调用 sendto 函数发送给目标服务器端，然后再次调用 recvfrom 函数接收目标服务器发送过来的新报文，并将其打印到标准输出上。</p><h2 id="UDP-的三种运行场景"><a href="#UDP-的三种运行场景" class="headerlink" title="UDP 的三种运行场景"></a>UDP 的三种运行场景</h2><h3 id="只运行客户端"><a href="#只运行客户端" class="headerlink" title="只运行客户端"></a>只运行客户端</h3><p>如果我们只运行客户端，程序会一直阻塞在 recvfrom 上。</p><pre><code>$ ./udpclient 127.0.0.11now sending g1send bytes: 2&lt; 阻塞在这里 &gt;</code></pre><p>如果不开启服务端，TCP 客户端的 connect 函数会直接返回“Connection refused”报错信息。而在 UDP 程序里，则会一直阻塞在这里。</p><h3 id="先开启服务端，再开启客户端"><a href="#先开启服务端，再开启客户端" class="headerlink" title="先开启服务端，再开启客户端"></a>先开启服务端，再开启客户端</h3><p>我们先开启服务端在端口侦听，然后再开启客户端</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2$./udpclient 127.0.0.1g1now sending g1send bytes: 2Hi, g1g2now sending g2send bytes: 2Hi, g2</code></pre><h3 id="开启服务端，再一次开启两个客户端"><a href="#开启服务端，再一次开启两个客户端" class="headerlink" title="开启服务端，再一次开启两个客户端"></a>开启服务端，再一次开启两个客户端</h3><p>这个实验中，在服务端开启之后，依次开启两个客户端，并发送报文。</p><p>服务端：</p><pre><code>$./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4</code></pre><p>两个客户端发送的报文，依次都被服务端收到，并且客户端也可以收到服务端处理之后的报文。<br>如果我们此时把服务器端进程杀死，就可以看到信号函数在进程退出之前，打印出服务器端接收到的报文个数。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams</code></pre><p>我们再重启服务器端进程，并使用客户端 1 和客户端 2 继续发送新的报文，我们可以看到和 TCP 非常不同的结果。<br>TCP 断联之后必须重新连接才可以发送报文信息。但是 UDP 报文的”无连接“的特点，可以在 UDP 服务器重启之后，继续进行报文的发送，这就是 UDP 报文“无上下文”的最好说明。</p><pre><code>$ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams$ ./udpserverreceived 2 bytes: g5received 2 bytes: g6</code></pre><p>第一个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3g5now sending g5send bytes: 2Hi, g5</code></pre><p>第二个客户端：</p><pre><code>$./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4g6now sending g6send bytes: 2Hi, g6</code></pre><p>UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。<br>UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;p&gt;TCP 是一个面向连接的协议，TCP 在 IP 报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP连接</title>
    <link href="http://example.com/p/d6bcf660.html"/>
    <id>http://example.com/p/d6bcf660.html</id>
    <published>2023-07-19T13:36:07.963Z</published>
    <updated>2023-07-31T14:51:48.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。<br>因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。<br>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p><ul><li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h2 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h2><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。<br>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li>Socket：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题等</li><li>窗口大小：用来做流量控制</li></ul><p>如何唯一确定一个 TCP 连接呢？<br>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p>服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p><ul><li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li>系统级：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；</li><li>用户级：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；</li><li>进程级：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li></ul></li><li>内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>先从服务器端开始，看看tcp如何连接的。</p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>创建一个可用的套接字要使用下面的函数：</p><pre><code>int socket(int domain, int type, int protocol)</code></pre><p>domain 就是指 PF_INET、PF_INET6 以及 PF_LOCAL 等，表示什么样的套接字。</p><p>type 可用的值是：</p><ul><li>SOCK_STREAM: 表示的是字节流，对应 TCP；</li><li>SOCK_DGRAM： 表示的是数据报，对应 UDP；</li><li>SOCK_RAW: 表示的是原始套接字。</li></ul><p>参数 protocol 原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。protocol 目前一般写成 0 即可。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>创建出来的套接字如果需要被别人使用，就需要调用 bind 函数把套接字和套接字地址绑定</p><pre><code>bind(int fd, sockaddr * addr, socklen_t len)</code></pre><p>bind 函数后面的第二个参数是通用地址格式sockaddr * addr。这里有一个地方值得注意，那就是虽然接收的是通用地址格式，实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式。bind 函数会根据 len 字段判断传入的参数 addr 该怎么解析，len 字段表示的就是传入的地址长度，它是一个可变值。<br>对于使用者来说，每次需要将 IPv4、IPv6 或者本地套接字格式转化为通用套接字格式，就像下面的 IPv4 套接字地址格式的例子一样：</p><pre><code>struct sockaddr_in name;bind (sock, (struct sockaddr *) &amp;name, sizeof (name)</code></pre><p>对于实现者来说，可根据该地址结构的前两个字节判断出是哪种地址。为了处理长度可变的结构，需要读取函数里的第三个参数，也就是 len 字段，这样就可以对地址进行解析和判断了。</p><p>设置 bind 的时候，对地址和端口可以有多种处理方式。我们可以把地址设置成本机的 IP 地址，这相当告诉操作系统内核，仅仅对目标 IP 是本机 IP 地址的 IP 包进行处理。但是这样写的程序在部署时有一个问题，我们编写应用程序时并不清楚自己的应用程序将会被部署到哪台机器上。这个时候，可以利用通配地址的能力帮助我们解决这个问题。比如一台机器有两块网卡，IP 地址分别是 202.61.22.55 和 192.168.1.11，那么向这两个 IP 请求的请求包都会被我们编写的应用程序处理。<br>对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置；对于 IPv6 的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置。</p><pre><code>struct sockaddr_in name;name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4 通配地址 */</code></pre><p>除了地址，还有端口。如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核来处理，操作系统内核会根据一定的算法选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用。<br>一般来说，服务器端的程序一定要绑定到一个众所周知的端口上。服务器端的 IP 地址和端口数据，相当于打电话拨号时需要知道的对方号码，如果没有电话号码，就没有办法和对方建立连接。</p><pre><code>include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int make_socket (uint16_t port)&#123;    int sock;    struct sockaddr_in name;        /* 创建字节流类型的 IPV4 socket. */    sock = socket (PF_INET, SOCK_STREAM, 0);    if (sock &lt; 0)    &#123;        perror (&quot;socket&quot;);        exit (EXIT_FAILURE);    &#125;        /* 绑定到 port 和 ip. */    name.sin_family = AF_INET; /* IPV4 */    name.sin_port = htons (port);  /* 指定端口 */    name.sin_addr.s_addr = htonl (INADDR_ANY); /* 通配地址 */    /* 把 IPV4 地址转换成通用地址格式，同时传递长度 */    if (bind (sock, (struct sockaddr *) &amp;name, sizeof (name)) &lt; 0)    &#123;        perror (&quot;bind&quot;);        exit (EXIT_FAILURE);    &#125;            return sock&#125;</code></pre><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 connect 函数，后面会讲到）。通过 listen 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：“我这个套接字是用来等待用户请求的。”当然，操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。<br>listen 函数的原型是这样的：</p><pre><code>int listen (int socketfd, int backlog)</code></pre><p>第一个参数 socketfd 为套接字描述符，第二个参数 backlog，官方的解释为未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目。这个参数越大，并发数目理论上也会越大。但是参数过大也会占用过多的系统资源，一些系统，比如 Linux 并不允许对这个参数进行改变。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这个时候操作系统内核需要把这个事件通知到应用程序，并让应用程序感知到这个连接。<br>accept 这个函数的作用就是连接建立之后，操作系统内核和应用程序之间的桥梁。它的原型是：</p><pre><code>int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)</code></pre><p>第一个参数 listensockfd 是套接字，可以叫它为 listen 套接字，因为这就是前面通过 bind，listen 一系列操作而得到的套接字。函数的返回值有两个部分，第一个部分 cliadd 是通过指针方式获取的客户端的地址，addrlen 告诉我们地址的大小；另一个部分是函数的返回值，这个返回值是一个全新的描述字，代表了与客户端的连接。<br>第一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><p>一个是监听套接字描述字 listensockfd，它是作为输入参数存在的；第二个是返回的已连接套接字描述字。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>第一步还是和服务端一样，要建立一个套接字，方法和前面是一样的。</p><p>不一样的是客户端需要调用 connect 向服务端发起请求。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>客户端和服务器端的连接建立，是通过 connect 函数完成的。这是 connect 的构建函数：</p><pre><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)</code></pre><p>函数的第一个参数 sockfd 是连接套接字，通过前面讲述的 socket 函数创建。第二个、第三个参数 servaddr 和 addrlen 分别代表指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的 IP 地址和端口号。</p><p>客户在调用函数 connect 前不必非得调用 bind 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口。</p><p>如果是 TCP 套接字，那么调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：</p><ul><li>三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。</li><li>客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。产生 RST 的三个条件是：目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；TCP 想取消一个已有连接；TCP 接收到一个根本不存在的连接上的分节。</li><li>客户发出的 SYN 包在网络上引起了”destination unreachable”，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们先看一下最初的过程，服务器端通过 socket，bind 和 listen 完成了被动套接字的准备工作，被动的意思就是等着别人来连接，然后调用 accept，就会阻塞在这里，等待客户端的连接来临；客户端通过调用 socket 和 connect 函数之后，也会阻塞。接下来的事情是由操作系统内核完成的，更具体一点的说，是操作系统内核网络协议栈在工作。<br>下面是具体的过程：</p><ul><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，指明客户端打算连接的服务器的端口，客户端进入 SYNC_SENT 状态；</li><li>服务器端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack&#x3D;J+1，随机产生一个序号值seq&#x3D;K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ul><p><img src="https://s1.ax1x.com/2023/07/27/pCxuSmD.png" alt="pCxuSmD.png"><br>这样就连接成功了</p><h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>两次为什么不行<br>防止失效的连接请求报文段被服务端接收，从而产生错误。<br>我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。<br>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</p><p>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p>如果是四次握手呢？无疑是做了无用功，因为三次握手，已经让双方都确认了接收数据的能力，再多次握手，也不过是确定了已经确定的事情。</p><h2 id="发送和接受"><a href="#发送和接受" class="headerlink" title="发送和接受"></a>发送和接受</h2><p>连接建立的根本目的是为了数据的收发，首先我们先来看一下发送数据。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>发送数据时常用的有三个函数，分别是 write、send 和 sendmsg。</p><pre><code>size_t write (int socketfd, const void *buffer, size_t size)size_t send (int socketfd, const void *buffer, size_t size, int flags)size_t sendmsg(int sockfd, const struct msghdr *msg, int flags)</code></pre><p>第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。<br>如果想指定选项，发送带外数据，就需要使用第二个带 flag 的函数。所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。<br>如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。</p><p>既然套接字描述符是一种特殊的描述符，那么在套接字描述符上调用 write 函数，应该和在普通文件描述符上调用 write 函数的行为是一致的，都是通过描述符句柄写入指定的数据。</p><p>乍一看，两者的表现形式是一样，内在的区别还是很不一样的。</p><p>对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。<br>对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的。</p><h3 id="发送缓冲区"><a href="#发送缓冲区" class="headerlink" title="发送缓冲区"></a>发送缓冲区</h3><p>当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。</p><p>这里有几种情况：</p><ul><li><p>第一种情况很简单，操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，那么皆大欢喜，我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小。</p></li><li><p>第二种情况是，操作系统内核的发送缓冲区是够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，操作系统内核并不会返回，也不会报错，而是应用程序被阻塞，也就是说应用程序在 write 函数调用处停留，不直接返回。大部分 UNIX 系统的做法是一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回。</p></li></ul><p>发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据。至于什么时候发送到对端的接收缓冲区，或者更进一步说，什么时候被对方应用程序缓冲所接收，对我们而言完全都是透明的。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>套接字描述本身和本地文件描述符并无区别，在 UNIX 的世界里万物都是文件，这就意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。这些函数包括 read 和 write 交换数据的函数。</p><p>先从最简单的 read 函数开始看起，这个函数的原型如下：</p><pre><code>size_t read (int socketfd, void *buffer, size_t size)</code></pre><p>read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；</p><p>这里是最多读取 size 个字节。如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取。</p><pre><code>/* 从 socketfd 描述字中读取 &quot;size&quot; 个字节. */ssize_t readn(int fd, void *vptr, size_t size)&#123;    size_t  nleft;    ssize_t nread;    char    *ptr;    ptr = vptr;    nleft = size;        while (nleft &gt; 0) &#123;        if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;            if (errno == EINTR)                nread = 0;      /* 这里需要再次调用 read */            else                return(-1);        &#125; else if (nread == 0)            break;              /* EOF(End of File) 表示套接字关闭 */        nleft -= nread;        ptr   += nread;    &#125;    return(n - nleft);      /* 返回的是实际读取的字节数 */&#125;</code></pre><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br><img src="https://s1.ax1x.com/2023/07/27/pCxu2He.png" alt="pCxu2He.png"></p><p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p><ul><li>第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</li><li>第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</li><li>第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</li><li>第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</li></ul><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h3><p>建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。</p><p>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h3 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h3><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。有以下两个原因：</p><p>第一点：保证TCP协议的全双工连接能够可靠关闭：<br>由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于CLOESD状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT，如果第四次挥手ACK报文没到达服务端，接收方会重新发送第三次挥手的报文给客户端，客户端收到之后，就知道之前第四次挥手的 ACK 报文丢失了，然后再次发送 ACK 报文。确保正确地结束这次连接。<br>第二点：保证这次连接的重复数据段从网络中消失<br>如果Client端发送最后的ACK直接进入CLOSED状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。</p><h3 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h3><p>关闭的连接的函数有两种函数：</p><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。<br>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。<br>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p><p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。<br>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN。</p><h3 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h3><p>当被动关闭方在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><h3 id="CLOSE-WAIT-和TIME-WAIT-的状态和意义"><a href="#CLOSE-WAIT-和TIME-WAIT-的状态和意义" class="headerlink" title="CLOSE-WAIT 和TIME-WAIT 的状态和意义"></a>CLOSE-WAIT 和TIME-WAIT 的状态和意义</h3><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。<br>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。</p><h3 id="Time-wait过多有什么危害"><a href="#Time-wait过多有什么危害" class="headerlink" title="Time_wait过多有什么危害?"></a>Time_wait过多有什么危害?</h3><p>内存资源占用、端口资源占用(一个TCP连接至少消耗一个端口)，每端口，无法建立新连接。<br>服务器资源受限:服务器监听一个端口，会把连接丢给线程处理，可以继续监听端口，但是线程池处理不了那么多连接。</p><h3 id="Time-wait状态过多的优化"><a href="#Time-wait状态过多的优化" class="headerlink" title="Time_wait状态过多的优化?"></a>Time_wait状态过多的优化?</h3><p>什么时候产生: 首先调用close()发起主动关闭的一方，再发送最后一个ACK之后。<br>为何产生:  确保最后一个ACK到达，保证TCP全双工连接可靠释放;使旧的数据包过期消失。什么时候会产生大量Time_wait:当请求量比较大的时候，而且所有的请求都是短连接的时候。<br>如何避免: 多IP增加随机端口;内核参数调优（服务器设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口)﹔使用长连接(Connection: keep-<br>alive) 、 Linux参数net.ipv4.tcp_tw_reuse和 tcp_timestamps开启，复用处于TIME_WAIT的socket为新的连接所用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP连接&quot;&gt;&lt;a href=&quot;#TCP连接&quot; class=&quot;headerlink&quot; title=&quot;TCP连接&quot;&gt;&lt;/a&gt;TCP连接&lt;/h1&gt;&lt;p&gt;IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>表存储格式</title>
    <link href="http://example.com/p/de74da3e.html"/>
    <id>http://example.com/p/de74da3e.html</id>
    <published>2023-07-18T01:46:59.601Z</published>
    <updated>2023-07-21T09:56:27.130Z</updated>
    
    <content type="html"><![CDATA[<p>在 MySQL 中，表的行格式是指表中存储的行数据在磁盘上的存储方式。MySQL 支持多种行格式，不同的行格式有不同的特点和适用场景。在函数中，我们使用 switch 语句根据传入的 enum 值来确定对应的行格式，并返回相应的字符串。</p><p>以下是对应关系的解释：</p><ul><li>ast.RowFormatDefault：表示默认行格式，没有显式指定行格式时使用的默认值。</li><li>ast.RowFormatFixed：表示固定行格式，适用于具有固定长度的行数据。</li><li>ast.RowFormatCompact：表示紧凑行格式，适用于大部分情况下的行数据。</li><li>ast.RowFormatCompressed：表示压缩行格式，适用于对数据进行压缩以减少存储空间的情况。</li><li>ast.RowFormatDynamic：表示动态行格式，适用于具有可变长度的行数据。</li><li>ast.RowFormatRedundant：表示冗余行格式，适用于具有较大数据行的情况。</li></ul><p>如果传入的 enum 值没有对应的行格式，函数将返回空字符串 “”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 MySQL 中，表的行格式是指表中存储的行数据在磁盘上的存储方式。MySQL 支持多种行格式，不同的行格式有不同的特点和适用场景。在函数中，我们使用 switch 语句根据传入的 enum 值来确定对应的行格式，并返回相应的字符串。&lt;/p&gt;
&lt;p&gt;以下是对应关系的解释：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字面量</title>
    <link href="http://example.com/p/ddc66992.html"/>
    <id>http://example.com/p/ddc66992.html</id>
    <published>2023-07-17T13:28:22.979Z</published>
    <updated>2023-07-21T08:17:20.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。</p><pre><code>#include &lt;chrono&gt;#include &lt;complex&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;i * i = &quot; &lt;&lt; 1i * 1i &lt;&lt; endl;    cout &lt;&lt; &quot;Waiting for 500ms&quot; &lt;&lt; endl;    this_thread::sleep_for(500ms);    cout &lt;&lt; &quot;Hello world&quot;s.substr(0, 5) &lt;&lt; endl;&#125;</code></pre><p>输出结果为：</p><pre><code>i * i = (-1,0)Waiting for 500msHello</code></pre><p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 basic_string 字面量的后缀。<br>上面使用了 using namespace std，这会同时引入std 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p><pre><code>std::literals::complex_literalsstd::literals::chrono_literalsstd::literals::string_literals</code></pre><p>在产品项目中，一般不会（也不应该）全局使用 using namespace std<br>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 _打头。比如，假如我们有下面的长度类：</p><pre><code>struct length &#123;    double value;    enum unit &#123;        metre,        kilometre,        millimetre,        centimetre,        inch,        foot,        yard,        mile,    &#125;;    static constexpr double factors[] =        &#123;1.0, 1000.0, 1e-3,        1e-2, 0.0254, 0.3048,        0.9144, 1609.344&#125;;    explicit length(double v, unit u = metre) &#123;        value = v * factors[u];    &#125;&#125;;length operator+(length lhs, length rhs) &#123;    return length(lhs.value + rhs.value);&#125;// 可能有其他运算符</code></pre><p>我们可以手写 length(1.0, length::metre) 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p><pre><code> 1.0_m + 10.0_cm</code></pre><p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p><pre><code>length operator&quot;&quot; _m(long double v)&#123;    return length(v, length::metre);&#125;length operator&quot;&quot; _cm(long double v)&#123;    return length(v, length::centimetre);&#125;</code></pre><h2 id="二进制字面量"><a href="#二进制字面量" class="headerlink" title="二进制字面量"></a>二进制字面量</h2><p>我们知道c++有16进制，8进制，10进制表示方法，但是没有二进制<br>从 C++14 开始，我们对于二进制也有了直接的字面量：</p><pre><code>unsigned mask = 0b111000000;</code></pre><p>这在需要比特级操作等场合还是非常有用的。<br>遗憾的是， I&#x2F;O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p><pre><code>#include &lt;bitset&gt;cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;</code></pre><p>输出结果是：</p><pre><code>111000000</code></pre><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。C++14 开始，允许在数字型字面量中任意添加 ‘ 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。比如说：</p><ul><li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li><li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li><li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li><li>二进制数字使用三位的分隔，对应文件系统的权限分组</li></ul><p>一些例子如下：</p><pre><code>unsigned mask = 0b111&#39;000&#39;000;long r_earth_equatorial = 6&#39;378&#39;137;double pi = 3.14159&#39;26535&#39;89793;const unsigned magic = 0x44&#39;42&#39;47&#39;4E;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字面量&quot;&gt;&lt;a href=&quot;#字面量&quot; class=&quot;headerlink&quot; title=&quot;字面量&quot;&gt;&lt;/a&gt;字面量&lt;/h1&gt;&lt;p&gt;C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>torm框架学习</title>
    <link href="http://example.com/p/14433829.html"/>
    <id>http://example.com/p/14433829.html</id>
    <published>2023-07-17T08:48:12.186Z</published>
    <updated>2023-07-21T08:17:20.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="torm"><a href="#torm" class="headerlink" title="torm"></a>torm</h1><p>TORM（Type-safe ORM）是一个强大的 Go 语言 ORM 库，具有以下特性</p><ul><li>精细化查询、插入、更新字段控制</li><li>类型安全</li><li><ul><li>软删除支持</li></ul></li><li>Id、创建、更新字段自动填充</li><li>分库分表支持</li><li>读写分离支持</li><li>使用 Hook 机制灵活拓展如 Prometheus 上报，自动加解密等</li><li>快，相比其他 ORM 框架性能损耗更少</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;torm&quot;&gt;&lt;a href=&quot;#torm&quot; class=&quot;headerlink&quot; title=&quot;torm&quot;&gt;&lt;/a&gt;torm&lt;/h1&gt;&lt;p&gt;TORM（Type-safe ORM）是一个强大的 Go 语言 ORM 库，具有以下特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精细化查</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://example.com/p/1f4ac2fb.html"/>
    <id>http://example.com/p/1f4ac2fb.html</id>
    <published>2023-07-16T09:10:58.637Z</published>
    <updated>2023-07-24T14:24:18.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>20,155,232,844,224,682,496.</p><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><pre><code>class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;stk;        map&lt;char,char&gt;table;        table.insert(&#123;&#39;(&#39;,&#39;)&#39;&#125;);        table.insert(&#123;&#39;[&#39;,&#39;]&#39;&#125;);        table.insert(&#123;&#39;&#123;&#39;,&#39;&#125;&#39;&#125;);        for(auto c:s)        &#123;            if(c==&#39;(&#39;||c==&#39;[&#39;||c==&#39;&#123;&#39;)            &#123;                stk.push(c);            &#125;            else            &#123;                if(stk.size()&amp;&amp;table[stk.top()]==c)                &#123;                    stk.pop();                &#125;                else&#123;                    return false;                &#125;            &#125;        &#125;        if(stk.size())return false;        return true;    &#125;&#125;;</code></pre><p>坑点有很多，比如每次pop需要注意栈非空，匹配结束如果栈有值则失败，思路想的时候很好代码实现总是遗漏要点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;p&gt;20,155,232,844,224,682,496.&lt;/p&gt;
&lt;h2 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/p/2362a8ea.html"/>
    <id>http://example.com/p/2362a8ea.html</id>
    <published>2023-07-16T07:09:58.247Z</published>
    <updated>2023-07-24T14:24:18.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = nullptr;        ListNode* curr = head;        while (curr) &#123;            ListNode* next = curr-&gt;next;            curr-&gt;next = prev;            prev = curr;            curr = next;        &#125;        return prev;    &#125;&#125;;</code></pre><h2 id="判断环形链表"><a href="#判断环形链表" class="headerlink" title="判断环形链表"></a>判断环形链表</h2><pre><code>class Solution &#123;public:    bool hasCycle(ListNode* head) &#123;        ListNode* slow = head;        ListNode* fast = head;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;            if (fast == slow) &#123;    // 如果快慢指针相遇                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><pre><code>class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* preHead = new ListNode(-1);        ListNode* prev = preHead;        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;            if (l1-&gt;val &lt; l2-&gt;val) &#123;                prev-&gt;next = l1;                l1 = l1-&gt;next;            &#125; else &#123;                prev-&gt;next = l2;                l2 = l2-&gt;next;            &#125;            prev = prev-&gt;next;        &#125;        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev-&gt;next = l1 == nullptr ? l2 : l1;        return preHead-&gt;next;    &#125;&#125;;</code></pre><h2 id="删除倒数节点"><a href="#删除倒数节点" class="headerlink" title="删除倒数节点"></a>删除倒数节点</h2><pre><code>class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        auto first=head;        auto second=first;        for(int i=0;i&lt;n;i++)&#123;            second=second-&gt;next;        &#125;        if(second==nullptr)return head-&gt;next;        second=second-&gt;next;        while(second!=nullptr)        &#123;            first=first-&gt;next;            second=second-&gt;next;        &#125;        auto temp=first-&gt;next;        first-&gt;next=temp-&gt;next;        delete temp;        return head;    &#125;&#125;;</code></pre><h2 id="返回中点"><a href="#返回中点" class="headerlink" title="返回中点"></a>返回中点</h2><pre><code>class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        auto slow=head;        auto fast=head;        while(fast&amp;&amp;fast-&gt;next)        &#123;            slow=slow-&gt;next;            fast=fast-&gt;next-&gt;next;        &#125;        return slow;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;单链表反转&lt;/li&gt;
&lt;li&gt;链表中环的检测&lt;/li&gt;
&lt;li&gt;两个有序的链表合并&lt;/li&gt;
&lt;li&gt;删除链表倒数第 n 个结点</summary>
      
    
    
    
    <category term="算法与数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly与Rust实践</title>
    <link href="http://example.com/p/13592136.html"/>
    <id>http://example.com/p/13592136.html</id>
    <published>2023-07-13T13:57:09.666Z</published>
    <updated>2023-07-14T02:17:14.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly与Rust实践"><a href="#WebAssembly与Rust实践" class="headerlink" title="WebAssembly与Rust实践"></a>WebAssembly与Rust实践</h1><div class="row">    <embed src="../../../pdf/WebAssembly与Rust实践.pdf" width="100%" height="550" type="application/pdf"></div><p>注：pdf为本人编写，不需要用图床比较方便，用图太多实在不想整理到博客了，下面内容不全，真心求教大佬们有没有什么魔法可以markdown粘贴图片绑定图床自动生成链接。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Rust编程语言和WebAssembly（Wasm）都是由Mozilla推动的前沿技术，并且它们在许多方面相互补充。<strong>Rust正致力于成为WebAssembly的首选编程语言</strong>。<br>Rust语言的最大特色之一是在保证系统性能的同时提供内存安全性。通过其所有权系统、借用检查器和生命周期规则，Rust可以在编译时捕获内存安全错误，避免了许多常见的内存错误，如空指针引用、数据竞争等。这使得Rust成为开发高性能、安全和可靠系统级软件的理想选择。<br>WebAssembly是一种可移植的低级字节码格式，可以在Web环境中运行。它的目标是在不同平台和语言之间提供统一的执行环境，并以接近原生的性能运行代码。WebAssembly允许以高效且安全的方式在Web浏览器中执行性能敏感的任务，同时保持与底层平台的兼容性。<br>Rust语言在与WebAssembly的结合方面有很多优势。Rust从诞生之初就考虑到与C语言的兼容性，使得使用Rust编写的代码可以直接与C语言的二进制接口（ABI）进行交互。这使得Rust成为编写WebAssembly模块的理想语言之一。Rust的Cargo包管理工具也为构建、打包和发布WebAssembly模块提供了便利。通过使用Rust和WebAssembly，开发人员可以借助Rust语言的安全性和性能优势，同时利用WebAssembly的跨平台和高性能特性，构建出功能强大、高效且安全的Web应用程序、浏览器扩展、游戏和其他Web平台的应用。</p><h2 id="安装WebAssembly开发环境"><a href="#安装WebAssembly开发环境" class="headerlink" title="安装WebAssembly开发环境"></a>安装WebAssembly开发环境</h2><p>Rust是目前WebAssembly生态中支持力度最强的一种语言。开源社区中不仅有Rust语言开发的WebAssembly虚拟机，还有基于WebAssembly模块的管理工具。<br>Rust语言默认安装的是生成本地应用的开发环境，因此WebAssembly开发环境需要单独安装。<br>首先查看有哪些环境可以安装：</p><pre><code> rustup target list | grep wasm</code></pre><p>运行结果如下所示：<br>• rustup target add wasm32-wasi：<br>    ◦ 这个指令将把wasm32-wasi目标加入到Rust工具链中。wasm32-wasi是用于WebAssembly系统接口(WASI)的目标，WASI是一种与操作系统无关的WebAssembly运行环境，允许在不同平台上运行WebAssembly模块。<br>• rustup target add wasm32-unknown-emscripten：<br>    ◦ 为了将 wasm32-unknown-emscripten 目标添加到 Rust 工具链，需要运行以下命令。wasm32-unknown-emscripten 是 Emscripten 工具链提供的一个目标，它能够将 Rust 代码编译为适用于浏览器环境的 WebAssembly 模块。<br>• rustup target add wasm32-unknown-unknown：<br>    ◦ 此命令将在 Rust 工具链中添加 wasm32-unknown-unknown 目标。wasm32-unknown-unknown 目标是一个通用的 WebAssembly 目标，适用于在不特定于操作系统或运行时环境的情况下构建 WebAssembly 模块。</p><p>了解环境之后，我们可以通过以下命令安装：</p><pre><code>rustup target add wasm32-wasirustup target add wasm32-unknown-emscriptenrustup target add wasm32-unknown-unknown</code></pre><p>为了方便测试和运行WebAssembly模块，还需要安装wasmer虚拟机环境。使用Scoop：</p><pre><code>scoop install wasmer</code></pre><p>安装成功之后，输入以下命令查看wasmer版本信息：</p><pre><code>wasmer -h</code></pre><h2 id="将Rust编译为wasm"><a href="#将Rust编译为wasm" class="headerlink" title="将Rust编译为wasm"></a>将Rust编译为wasm</h2><p>我们仍然使用刚才的入门测试程序，打印你好，世界！<br>然后，在编译时指定目标为wasm32-wasi：</p><pre><code>cargo build --target=wasm32-wasi</code></pre><p>在src同级目录下面，target&#x2F;wasm32-wasi&#x2F;debug&#x2F;内已经生成了对应的hello.wasm文件。<br>最后，通过wasmer工具运行该程序文件</p><pre><code>wasmer run target/wasm32-wasi/debug/hello.wasm</code></pre><p>可以看到程序正常输出</p><h2 id="导入和导出函数"><a href="#导入和导出函数" class="headerlink" title="导入和导出函数"></a>导入和导出函数</h2><h3 id="导出main-函数"><a href="#导出main-函数" class="headerlink" title="导出main()函数"></a>导出main()函数</h3><p>当在 Rust 中构建 WebAssembly 模块时，导入和导出函数是实现与宿主环境进行交互的关键部分。通过导入函数，可以在 Rust 模块中调用宿主环境中提供的功能，而通过导出函数，可以将 Rust 函数暴露给宿主环境使用。<br>上面测试时编译目标为wasm32-wasi，因此程序只能在宿主支持的WASI虚拟机环境运行。现在，我们设置编译目标为wasm32-unknown-unknown（即纯WebAssembly环境），然后查看其导出的函数。<br>输入以下命令重新构建：</p><pre><code>cargo build --target wasm32-unknown-unknown</code></pre><p>默认生成.&#x2F;target&#x2F;wasm32-unknown-unknown&#x2F;debug&#x2F;hello.wasm</p><p>可以看到我们已经导出了main函数。</p><p>我们还可以在Node.js环境，通过console.dir()调试函数查看导出的内容，在wasm对应目录下创建hello.js文件：</p><pre><code>const fs = require(&#39;fs&#39;);//readFileSync文件读取会阻塞代码的执行，直到读取完成const buf = fs.readFileSync(&#39;./hello.wasm&#39;);WebAssembly.instantiate(new Uint8Array(buf)).then(function(result) &#123;    console.dir(result.instance.exports);&#125;);</code></pre><p>运行代码，得到以下输出:</p><p>这说明普通的应用程序默认导出了main()函数。</p><h3 id="导入宿主打印函数"><a href="#导入宿主打印函数" class="headerlink" title="导入宿主打印函数"></a>导入宿主打印函数</h3><p>WebAssembly是一个与宿主环境隔离的虚拟机，因此WebAssembly模块不能直接访问宿主环境的控制台或文件系统等资源。为了在WebAssembly模块中输出信息，需要通过与宿主环境的交互来完成输出操作。<br>我们假定Node.js宿主环境提供了一个console_log()函数，用于输出一个整数值：</p><pre><code>function console_log(x) &#123;    console.log(x);&#125;</code></pre><p>这样就可以通过console_log()函数输出信息了。src&#x2F;main.rs内容修改如下：</p><pre><code>extern &quot;C&quot; &#123;    fn console_log(a: i32);&#125;fn main() &#123;    unsafe &#123;        console_log(42);    &#125;&#125;</code></pre><p>其中，紧跟extern “C”后的大括弧内是宿主导入函数声明，它们都是以C语言ABI规范导入。由于外部函数的实现是由宿主环境提供的，而不是由Rust代码控制的，因此我们无法保证这些函数的安全性和正确性。为此，我们需要将调用外部函数的代码放在unsafe语句块中，这样编译器就会知道该代码可能存在不安全操作，并需要我们自行确保其正确性和安全性。<br>对应Node.js环境的启动代码如下</p><pre><code>const fs = require(&#39;fs&#39;);const buf = fs.readFileSync(&#39;./hello.wasm&#39;);function console_log(x) &#123; console.log(x); &#125;WebAssembly.instantiate(new Uint8Array(buf), &#123;    env: &#123; &quot;console_log&quot;: console_log &#125;&#125;).then(function(result) &#123;    result.instance.exports.main();&#125;);</code></pre><h1 id="TODO-更新"><a href="#TODO-更新" class="headerlink" title="TODO 更新"></a>TODO 更新</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly与Rust实践&quot;&gt;&lt;a href=&quot;#WebAssembly与Rust实践&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly与Rust实践&quot;&gt;&lt;/a&gt;WebAssembly与Rust实践&lt;/h1&gt;

	&lt;div c</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
    <category term="实习" scheme="http://example.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="WebAssembly" scheme="http://example.com/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>Rust简单入门</title>
    <link href="http://example.com/p/3b2bd29.html"/>
    <id>http://example.com/p/3b2bd29.html</id>
    <published>2023-07-13T12:10:03.572Z</published>
    <updated>2023-07-17T03:51:09.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust简单入门"><a href="#Rust简单入门" class="headerlink" title="Rust简单入门"></a>Rust简单入门</h1><p>Rust的特点<br>• 零开销抽象<br>• 没有gc<br>• 内存模型没有高度封装<br>• 语法干净正交，没有C++那么繁琐。<br>• 安全性。Rust语法引入所有权和生命期概念，在编译期就能检查出一部分内存管理错误，这是rust的一个杀手锏的特性。<br>• 现代语言特性。语言特性吸收了现代语言的大量优秀特性，支持多范式。</p><h2 id="Rust环境安装"><a href="#Rust环境安装" class="headerlink" title="Rust环境安装"></a>Rust环境安装</h2><h3 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h3><p>访问Rust语言官方网站的安装地址<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br>先下载rustup安装程序再安装,安装的所有工具在~&#x2F;.cargo&#x2F;bin目录下，我们需要将该目录添加到PATH环境变量。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOJrF.png" alt="pChOJrF.png"></p><p>打开安装程序后，我们会发现需要依赖的windowsAPI库，我们采用下载vs installer的方式获取对应库。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOUa9.png" alt="pChOUa9.png"></p><p>安装vs install以后重新打开rustup安装程序，选择默认安装。<br>安装完成后，我们需要将~&#x2F;.cargo&#x2F;bin目录添加到PATH环境变量。<br>我们可以通过以下方式查看rustup、rustc和cargo工具的版本信息：</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOwP1.png" alt="pChOwP1.png"></p><p>其中，rustup是Rust工具的管理工具，rustc是Rust程序编译器，cargo是Rust工程的管理工具</p><h3 id="Rust程序测试"><a href="#Rust程序测试" class="headerlink" title="Rust程序测试"></a>Rust程序测试</h3><p>我们从“你好，世界”这个例子开始测试。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChO08x.md.png" alt="pChO08x.md.png"></p><p>其中，fn是关键字，表示定义一个函数，定义的函数的名字是main。main()函数的参数在小括弧中列出（这里的main()函数没有参数），函数体位于大括弧内。这里main()函数体中只有一个语句，就是用println!宏输出一个字符串并换行。</p><h3 id="Cargo管理工程"><a href="#Cargo管理工程" class="headerlink" title="Cargo管理工程"></a>Cargo管理工程</h3><p>Rust 编程语言引以为傲的一个重要特性是其工程管理工具 Cargo。Cargo 是 Rust 官方提供的构建系统和包管理器，被广泛认可为行业标杆。、<br>以下是 Cargo 的一些主要特性和优势：<br>• 依赖管理：Cargo 提供了强大的依赖管理功能。通过 Cargo.toml 文件，可以定义项目的依赖项和版本约束，能够轻松地引入、更新和管理外部库。<br>• 构建系统：Cargo 提供了一个集成的构建系统，使得构建、编译和测试 Rust 项目变得简单而高效。它自动处理依赖关系、编译顺序和编译标志等，开发者只需要专注于编写代码而不必手动管理构建过程。<br>• 项目管理：Cargo 提供了一组命令行工具，用于创建、初始化和管理 Rust 项目。通过简单的命令，您可以创建新项目、生成文档、运行测试、发布软件包等，提高开发者的效率和工作流程。<br>• 社区集成：Cargo 和 Rust 社区紧密结合，通过 Cargo 可以方便地共享、发布和发现 Rust 库和工具。Cargo 提供了 Cargo Crates 网站<a href="https://crates.io/">https://crates.io</a> Rust 生态系统中集中管理和发布库的中央仓库。<br>• 多工作区支持：Cargo 允许在单个项目中管理多个工作区，每个工作区可以拥有自己的依赖关系和构建配置。这对于大型项目或拥有多个模块的项目特别有用，可以更好地组织和管理代码。<br>工程一般以目录的方式组织，因此我们先创建一个空的目录（目录的名字自由选择），其中包含一个Cargo.toml文件。</p><pre><code>[package]name = &quot;hello&quot;version = &quot;0.1.0&quot;</code></pre><p>Cargo.toml是一种TOML格式的工程文件（TOML格式和ini格式类似，但是其功能更加强大）。其中，[package]部分包含工程的基本信息：name字段表示工程的名字，version字段表示工程的版本。<br>然后，创建一个src目录，在目录中创建一个main.rs文件：</p><pre><code>fn main() &#123;    println!(&quot;你好，世界&quot;);&#125;</code></pre><p>Cargo工具默认以src&#x2F;main.rs为程序的入口文件，因此只需要输入<br>cargo run就可以编译并运行程序了</p><p><img src="https://s1.ax1x.com/2023/07/13/pChXhTJ.png" alt="pChXhTJ.png"></p><p>Cargo底层依然是调用rustc编译器工具。但是，Cargo不仅可以管理可执行程序和库，还可以对其他第三方库的依赖进行管理，同时支持自定义的构建脚本。<br>cargo-generate是一个开发人员工具，通过利用预先存在的 git 存储库作为模板，帮助开发者快速启动和运行新的 Rust 项目。</p><pre><code>cargo install cargo-generate</code></pre><h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><p>Rust还提供了本地文档用于帮助学习和了解Rust。<br>我们可以在终端运行：</p><pre><code>rustup doc</code></pre><p>打开文档。</p><p><img src="https://s1.ax1x.com/2023/07/13/pChj9pt.png" alt="pChj9pt.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust简单入门&quot;&gt;&lt;a href=&quot;#Rust简单入门&quot; class=&quot;headerlink&quot; title=&quot;Rust简单入门&quot;&gt;&lt;/a&gt;Rust简单入门&lt;/h1&gt;&lt;p&gt;Rust的特点&lt;br&gt;• 零开销抽象&lt;br&gt;• 没有gc&lt;br&gt;• 内存模型没有高度封装&lt;b</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>WebAssembly跨语言调用</title>
    <link href="http://example.com/p/bf55081a.html"/>
    <id>http://example.com/p/bf55081a.html</id>
    <published>2023-07-13T11:58:12.167Z</published>
    <updated>2023-07-14T01:13:51.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebAssembly跨语言调用"><a href="#WebAssembly跨语言调用" class="headerlink" title="WebAssembly跨语言调用"></a>WebAssembly跨语言调用</h1><p>WebAssembly (Wasm) 可以在多种编程语言之间进行跨语言调用。它提供了一种标准化的接口，使得不同语言的代码可以相互调用和交互。<br>选择一种编程语言（例如 Rust、C++、Go 等）编写Wasm 模块。使用相应的编译器或工具链将代码编译为 Wasm 模块文件。然后导入 Wasm 模块到目标语言：在目标语言的代码中，使用相应的 Wasm 运行时库或框架来导入和执行 Wasm 模块。不同的语言可能有不同的 Wasm 运行时库可用，例如wasmer、wasmtime 等。</p><h2 id="Go和Rust调用实例"><a href="#Go和Rust调用实例" class="headerlink" title="Go和Rust调用实例"></a>Go和Rust调用实例</h2><h3 id="被调用方Rust"><a href="#被调用方Rust" class="headerlink" title="被调用方Rust"></a>被调用方Rust</h3><p>首先我们需要将被编译的程序编译成wasm文件<br>这里我们用go程序调用rust程序<br>用cargo init  add创建一个rust文件，更改add.rs</p><pre><code>fn main()&#123;&#125;#[no_mangle]pub extern &quot;C&quot; fn sum(x: i32, y: i32) -&gt; i32 &#123;    x + y&#125;</code></pre><p>将该文件编译为wasm</p><pre><code>cargo build --target wasm32-unknown-unknown --release</code></pre><p>现在被调用者我们已经处理完了，下面我们编写调用方代码。</p><h3 id="调用方Go"><a href="#调用方Go" class="headerlink" title="调用方Go"></a>调用方Go</h3><p>这里我们参照<a href="https://github.com/wasmerio/wasmer-go%E9%87%87%E7%94%A8wasmer%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">https://github.com/wasmerio/wasmer-go采用wasmer库进行处理</a><br>需要注意的是目前该库并不支持windows，需要在linux环境下使用</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOkgf.png" alt="pChOkgf.png"></p><p>创建相应go文件调用生成的wasm文件</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;    wasmer &quot;github.com/wasmerio/wasmer-go/wasmer&quot;)func main() &#123;    // 换成生成add.wasm的路径    wasmBytes, _ := ioutil.ReadFile(&quot;add/target/wasm32-unknown-unknown/release/add.wasm&quot;)    // Create an Engine    engine := wasmer.NewEngine()    // Create a Store    store := wasmer.NewStore(engine)    // Let&#39;s compile the module.    module, err := wasmer.NewModule(store, wasmBytes)    if err != nil &#123;        fmt.Println(&quot;Failed to compile module:&quot;, err)    &#125;    // Create an empty import object.    importObject := wasmer.NewImportObject()    // Let&#39;s instantiate the WebAssembly module.    instance, err := wasmer.NewInstance(module, importObject)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to instantiate the module:&quot;, err))    &#125;    // Now let&#39;s execute the `sum` function.    sum, err := instance.Exports.GetFunction(&quot;sum&quot;)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to get the `add_one` function:&quot;, err))    &#125;    result, err := sum(1, 2)    if err != nil &#123;        panic(fmt.Sprintln(&quot;Failed to call the `add_one` function:&quot;, err))    &#125;    fmt.Println(&quot;Results of `sum`:&quot;, result)&#125;</code></pre><p>注意：<br>• 12行需要换成生成add.wasm的相对&#x2F;绝对路径<br>• 需要拉取对应仓库<br>• 更多具体api参照<a href="https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer">https://pkg.go.dev/github.com/wasmerio/wasmer-go/wasmer</a></p><p>之后我们直接运行程序，可以看到跨语言调用成功</p><p><img src="https://s1.ax1x.com/2023/07/13/pChOuUs.png" alt="pChOuUs.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebAssembly跨语言调用&quot;&gt;&lt;a href=&quot;#WebAssembly跨语言调用&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly跨语言调用&quot;&gt;&lt;/a&gt;WebAssembly跨语言调用&lt;/h1&gt;&lt;p&gt;WebAssembly (W</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
</feed>
