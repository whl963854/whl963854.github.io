<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T07:18:58.858Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git工作流</title>
    <link href="http://example.com/p/7653a710.html"/>
    <id>http://example.com/p/7653a710.html</id>
    <published>2023-08-11T07:15:20.702Z</published>
    <updated>2023-08-11T07:18:58.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h1><p>原文链接：<a href="https://juejin.cn/post/7202952940196708410">https://juejin.cn/post/7202952940196708410</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git 是目前最流行的代码管理工具，团队一般为了规范开发，保持良好的代码提交记录以及维护 Git 分支结构清晰，方便后续维护等，都会定制一套团队内部比较规范的 Git 工作流。本期主要介绍最为常见和流行的三种Git分支工作流。<br>Git工作流与我们常用的add、commit、push等命令有区别，但它们之间是相互关联的。Git工作流定义了一个开发过程的整体架构和规范，而add、commit、push等命令则是在具体操作层面上实现Git工作流的基本操作。在具体使用Git时，你可以根据所采用的工作流选择合适的命令和操作来管理代码版本和进行团队协作。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>GitFlow 是最早诞生，并且得到广泛应用的一种工作流程。GitFlow 通常包含五种类型的分支，分别为master、develop、feature、release、hotfix。<br>• master：主干分支，也是正式发布版本的分支，每次发布版本都需要打上相应的 tag，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许直接向 master 分支直接提交代码 (master 对应着生产环境)。<br>• develop：开发分支，在开发初期，由团队负责人从 master 签出，用来集成测试最新合入的开发成果，包含要发布到下一个 Release 的代码（对应开发环境）。<br>• feature：特性分支，通常从 Develop 分支签出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将 Feature 分支的代码合并至 Develop 分支，进入下一个Release 环节。<br>• release：预发布分支，发布新版本时，基于 Develop 分支创建，发布完成后，需要将此分支合并到 Master 和 Develop 分支（对应集成测试环境）。<br>• hotfix：热修复分支，生产环境发现新 Bug 时创建的临时分支，问题验证通过后，合并到 Master 和 Develop 分支。<br>develop分支包含项目完整的历史记录，而master分支将包含简化版本。团队成员在克隆中央存储库后，应基于develop创建跟踪分支，进行新功能开发。</p><p>GitFlow的优点和缺点？<br>• 优点：流程清晰可控。<br>• 缺点：管理相对复杂，需要同时维护两个长期分支。同时不适合持续发布，目标产物通常是一段时间后产出一个新版本，是基于版本发布。</p><h3 id="开发分支（Develop）"><a href="#开发分支（Develop）" class="headerlink" title="开发分支（Develop）"></a>开发分支（Develop）</h3><p>Develop 分支由团队负责人从 Master 创建。首次创建时，由团队负责人构建项目结构，推送至远端。通常在该分支上进行新特性的合并、签出予发布分支、合并hotfix分支等操作。</p><h3 id="特性分支（Feature）"><a href="#特性分支（Feature）" class="headerlink" title="特性分支（Feature）"></a>特性分支（Feature）</h3><p>新特性分支基于 Develop 分支创建，每个新功能都应该驻留在其自己的分支中，我们可以将其推送到中央存储库进行协作或者备份。<br>在新功能开发完成后，需要将其合并到 Develop 分支中，同时删除本地与远端的feature分支。<br>预发布分支（Release）<br>一旦 Develop 分支获得了足够的发布功能，或者临近预定的发布日期，就需要基于 Develop 分支创建</p><h3 id="Release-分支。"><a href="#Release-分支。" class="headerlink" title="Release 分支。"></a>Release 分支。</h3><p>创建此分支意味着将开始下一个发行周期，此刻 Release 分支不能添加任何新功能（除了错误修复、文档完善等），一旦准备发布，Release 分支将合并到 Master 分支并用版本号标记。另外，还要将其合并回 Develop 分支。待发版成功后，删除 Release 分支。<br>使用专门的分支进行版本发布可以让我们在新版本发布的同时，其他团队成员可以继续为下个版本开发新功能，而不影响此次发布。</p><h3 id="补丁分支（hotfix）"><a href="#补丁分支（hotfix）" class="headerlink" title="补丁分支（hotfix）"></a>补丁分支（hotfix）</h3><p>维护 hotfix 分支用于快速修补生产版本出现的 bug。hotfix 分支是唯一一个从 Master 分支上创建的分支。<br>待修复程序完成后，应该将其合并到 Master 和 Develop 或者当前 Release 分支中，随后删除 hotfix 分支，并应使用更新的版本号标记 Master 分支。<br>拥用有专门的错误修复分支，可以保障团队可以在不中断其余工作流程的情况下，对线上的版本进行错误修复。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>GitHub flow 是 Git Flow 的简化版，它是 github.com 使用的工作流程。它只有一个长期分支(master)，相对于 GitFlow 用起来相对比较简单。GitHubFlow 假设每次合并一个特性分支时都可以部署到生产环境，虽然这在某些情况下是不可能的。<br>它只有一个长期分支master：<br>• 第一步：根据需求，从 master 拉出新分支，不区分功能分支或补丁分支。<br>• 第二步：新分支开发完成后，或者需要讨论的时候，就像 master 分支发起一个pull request(简称PR)。<br>• 第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码，对话过程中，你还可以不断提交代码。<br>• 第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。<br>GitHub Flow的优点和缺点？<br>• 优点：非常适合持续发布的产品，使用流程简单，仅有一个主干分支。Master 分支的最新代码，默认就是线上代码。<br>• 缺点：master 既包含生产环境，又包含开发环境，比较混乱。有些时候，代码合并进入 Master 分支，并不代表就能立刻发布，你不能控制发布的时间。例如，iOS 应用程序通过App Store验证后才发布。这是，如果后面还有新的代码合并到 Master，导致与刚刚发布的版本不一致。在这些情况下，需要额外创建一个 production 分支跟踪线上版本。如果想要查看生产环境代码，可切换至生产分支。</p><h2 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h2><p>Gitlab Flow 是 Git Flow 与 Github Flow 的结合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一分支的简单和便利，是 gitlab.com 推荐的做法。</p><h3 id="上游优先"><a href="#上游优先" class="headerlink" title="上游优先"></a>上游优先</h3><p>Gitlab Flow 的最大原则叫做“上游优先”，指存在一个主分支，他是所有其他分支的上游，只有上游分支采纳的代码变化，才能应用到其他分支。</p><h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>对于持续发布的项目，建议在 Master 之外，创建不同环境的分支，比如开发环境是 Master，预发布分支是pre-production，生产环境是production。<br>开发分支是语发布分支的上游，予发布分支是生产分支的上游。代码变化，必须由上游向下游发展。</p><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对于版本发布的项目，建议的做法是每一个稳定的版本，都要从 Master 分支上拉出一个分支，比如1.0.3-stable等等。<br>发布版本后，只有向该分支添加严重的错误修复，首先将错误修复合并到 Master 分支，然后将其合并到 stable 分支，并且此时要更新小版本号码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git工作流&quot;&gt;&lt;a href=&quot;#git工作流&quot; class=&quot;headerlink&quot; title=&quot;git工作流&quot;&gt;&lt;/a&gt;git工作流&lt;/h1&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://juejin.cn/post/72029529401967084</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-08-10T15:17:59.149Z</published>
    <updated>2023-08-10T15:26:44.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p>给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。</p><p>输入输出<br>输入</p><p>“this is a sentence”</p><p>输出</p><p>sentence a is this</p><p>首先，题目要求把每个单词倒过来，同时联想到栈有先进先出的特点。如果我们把单词作为一个整体按顺序入栈，然后再全部出栈，这时得到的就是反转后的句子了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    stack&lt;string&gt; wordStack;    int len = str.size();    string temp=&quot;&quot;;    for (int i = 0; i &lt; len; i++) &#123;        if (str[i] != &#39; &#39;) &#123;            temp += str[i];        &#125;        else &#123;            wordStack.push(temp);            temp.clear();        &#125;    &#125;    wordStack.push(temp);    string tempword;    while (!wordStack.empty())    &#123;        tempword = wordStack.top();        wordStack.pop();        if (!wordStack.empty()) &#123;            cout &lt;&lt; tempword &lt;&lt; &#39; &#39;;        &#125;        else        &#123;            cout &lt;&lt; tempword;        &#125;    &#125;    return 0;&#125;</code></pre><p>在整个字符串反转后，可以看到单词的相对位置就已经反转过来了，但是对于每个单词依然内部字母是反转的，因此考虑是否有方法将每个单词进行反转，这样单词字母的顺序就变过来了。</p><p>没错，把每个单词作为一个独立的字符串进行反转就可以了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;void reverseStr(string&amp; str, int beg, int end) &#123;    while (beg &lt; end) &#123;        swap(str[beg++], str[end--]);    &#125;&#125;int main() &#123;    string str;    getline(cin, str);    reverseStr(str, 0, str.size() - 1);    int begin=0, end=0;    for (int i = 0; i &lt; str.size(); i++) &#123;        if (str[i] != &#39; &#39;) &#123;            end=i;        &#125;        else &#123;            reverseStr(str, begin, end);            begin = end + 2;        &#125;    &#125;    reverseStr(str, begin, end);    cout &lt;&lt; str;    return 0;&#125;</code></pre><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><p>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出: 4</p><p>原文的分析是：</p><p>注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）</p><p>if nums[0] &lt;&#x3D; nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;&#x3D; target &lt;&#x3D; nums[i]时我们应该在 0 - i 范围内查找；<br>if nums[i] &lt; nums[0] 那么在 0 - i 区间的某个点处发生了下降（旋转），那么 I + 1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当 target 不属于 nums[0] 到 nums[i] 时（target &lt;&#x3D; nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;&#x3D; target），我们应该在 0 - i 区间内查找。<br>上述三种情况可以总结如下：</p><pre><code>nums[0] &lt;= target &lt;= nums[i]           target &lt;= nums[i] &lt; nums[0]                     nums[i] &lt; nums[0] &lt;= target</code></pre><p>所以我们进行三项判断：</p><p>(nums[0] &lt;&#x3D; target)， (target &lt;&#x3D; nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））</p><p>所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。</p><p>使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）</p><p>之后我们通过二分查找不断做小 target 可能位于的区间直到 low&#x3D;&#x3D;high，此时如果 nums[low]&#x3D;&#x3D;target 则找到了，如果不等则说明该数组里没有此项。</p><p>class Solution {<br>public:<br>    int search(vector<int>&amp; nums, int target) {<br>        int lo &#x3D; 0, hi &#x3D; nums.size() - 1;<br>        while (lo &lt; hi) {<br>            int mid &#x3D; (lo + hi) &#x2F; 2;<br>            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))<br>                lo &#x3D; mid + 1;<br>            else<br>                hi &#x3D; mid;<br>        }<br>        return lo &#x3D;&#x3D; hi &amp;&amp; nums[lo] &#x3D;&#x3D; target ? lo : -1;<br>    }<br>};</int></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;反转单词&quot;&gt;&lt;a href=&quot;#反转单词&quot; class=&quot;headerlink&quot; title=&quot;反转单词&quot;&gt;&lt;/a&gt;反转单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。&lt;/p&gt;
&lt;p&gt;输入输出&lt;br&gt;输入&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-08-07T14:57:09.536Z</published>
    <updated>2023-08-10T14:11:31.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣56，合并区间"><a href="#力扣56，合并区间" class="headerlink" title="力扣56，合并区间"></a>力扣56，合并区间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣56，合并区间&quot;&gt;&lt;a href=&quot;#力扣56，合并区间&quot; class=&quot;headerlink&quot; title=&quot;力扣56，合并区间&quot;&gt;&lt;/a&gt;力扣56，合并区间&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VLD</title>
    <link href="http://example.com/p/ba0d0e90.html"/>
    <id>http://example.com/p/ba0d0e90.html</id>
    <published>2023-08-07T13:53:22.202Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p>金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。</p><h2 id="Valgrind-的介绍"><a href="#Valgrind-的介绍" class="headerlink" title="Valgrind 的介绍"></a>Valgrind 的介绍</h2><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><pre><code>$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2$ bzip2 -d valgrind-3.13.0.tar.bz2$ tar -xf valgrind-3.13.0.tar$ cd valgrind-3.13.0$ ./configure &amp;&amp; make$ sudo make install</code></pre><p>检测内存泄漏</p><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><pre><code>#include &lt;stdlib.h&gt;int main()&#123;    int *array = malloc(sizeof(int));    return 0;&#125;</code></pre><p>编译程序时，需要加上-g选项：</p><pre><code>$ gcc -g -o main_c main.c</code></pre><p>使用 Valgrind 检测内存使用情况：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full  ./main_c==31416== Memcheck, a memory error detector==31416== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31416== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31416== Command: ./main_c==31416====31416====31416== HEAP SUMMARY:==31416==     in use at exit: 4 bytes in 1 blocks==31416==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated==31416====31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)==31416====31416== LEAK SUMMARY:==31416==    definitely lost: 4 bytes in 1 blocks==31416==    indirectly lost: 0 bytes in 0 blocks==31416==      possibly lost: 0 bytes in 0 blocks==31416==    still reachable: 0 bytes in 0 blocks==31416==         suppressed: 0 bytes in 0 blocks==31416====31416== For counts of detected and suppressed errors, rerun with: -v==31416== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>先看看输出信息中的HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的1 allocs表示程序分配了 1 次内存，0 frees表示程序释放了 0 次内存，4 bytes allocated表示分配了 4 个字节的内存。<br>另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是main.c文件的第 5 行：</p><pre><code>==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31416==    by 0x400537: main (main.c:5)</code></pre><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><p>#include <string><br>int main()<br>{<br>    auto ptr &#x3D; new std::string(“Hello, World!”);<br>    delete ptr;<br>    return 0;<br>}</string></p><p>使用 Valgrind 分析这段程序：</p><pre><code>$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp==31438== Memcheck, a memory error detector==31438== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31438== Command: ./main_cpp==31438====31438====31438== HEAP SUMMARY:==31438==     in use at exit: 72,704 bytes in 1 blocks==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated==31438====31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)==31438==    by 0x40105FA: call_init (dl-init.c:30)==31438==    by 0x40105FA: _dl_init (dl-init.c:120)==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)==31438====31438== LEAK SUMMARY:==31438==    definitely lost: 0 bytes in 0 blocks==31438==    indirectly lost: 0 bytes in 0 blocks==31438==      possibly lost: 0 bytes in 0 blocks==31438==    still reachable: 72,704 bytes in 1 blocks==31438==         suppressed: 0 bytes in 0 blocks==31438====31438== For counts of detected and suppressed errors, rerun with: -v==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre><p>　　<br>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从HEAP SUMMARY可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？<br>实际上这是由于 C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏，例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。</p><p>检测越界访问<br>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><pre><code>#include &lt;vector&gt;#include &lt;iostream&gt;int main()&#123;    std::vector&lt;int&gt; v(10, 0);    std::cout &lt;&lt; v[10] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31523== Memcheck, a memory error detector==31523== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31523== Command: ./main_cpp==31523====31523== Invalid read of size 4==31523==    at 0x400AD7: main (main.cpp:7)==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc&#39;d==31523==    at 0x4C2E216: operator new(unsigned long) (vg_replace_malloc.c:334)==31523==    by 0x4010D3: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)==31523==    by 0x401040: std::allocator_traits&lt;std::allocator&lt;int&gt; &gt;::allocate(std::allocator&lt;int&gt;&amp;, unsigned long) (alloc_traits.h:491)==31523==    by 0x400F91: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:170)==31523==    by 0x400E7E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_create_storage(unsigned long) (stl_vector.h:185)==31523==    by 0x400D1E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:136)==31523==    by 0x400C11: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector(unsigned long, int const&amp;, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:291)==31523==    by 0x400AB9: main (main.cpp:6)</code></pre><p>Invalid read of size 4表示越界读取 4 个字节，这个操作出现在main.cpp文件的第 7 行。另外可以看到，vector分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><p>检测未初始化的内存<br>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><pre><code>#include &lt;iostream&gt;int main()&#123;    int x;    if (x == 0)    &#123;        std::cout &lt;&lt; &quot;X is zero&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>　　<br>使用 Valgrind 检测这个程序：</p><pre><code>$ g++ -std=c++11 -g -o main_cpp main.cpp$ valgrind --tool=memcheck --leak-check=full ./main_cpp==31554== Memcheck, a memory error detector==31554== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info==31554== Command: ./main_cpp==31554====31554== Conditional jump or move depends on uninitialised value(s)==31554==    at 0x400852: main (main.cpp:6)</code></pre><p>　　<br>输出中提示了main.cpp文件的第 6 行访问了未初始化的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VLD&quot;&gt;&lt;a href=&quot;#VLD&quot; class=&quot;headerlink&quot; title=&quot;VLD&quot;&gt;&lt;/a&gt;VLD&lt;/h1&gt;&lt;p&gt;金山课程给了一个检测内存泄漏的工具，帮助我们检查程序内存泄漏完善大作业。&lt;/p&gt;
&lt;h2 id=&quot;Valgrind-的介绍&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/p/54e1373e.html"/>
    <id>http://example.com/p/54e1373e.html</id>
    <published>2023-08-06T14:59:02.859Z</published>
    <updated>2023-08-11T06:07:01.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL相关问题，事务，索引，索引的优化，用过没"><a href="#MySQL相关问题，事务，索引，索引的优化，用过没" class="headerlink" title="MySQL相关问题，事务，索引，索引的优化，用过没"></a>MySQL相关问题，事务，索引，索引的优化，用过没</h2><h2 id="数据库的水平划分和垂直划分"><a href="#数据库的水平划分和垂直划分" class="headerlink" title="数据库的水平划分和垂直划分"></a>数据库的水平划分和垂直划分</h2><h2 id="数据库ACID的概念，事务是怎么保证的"><a href="#数据库ACID的概念，事务是怎么保证的" class="headerlink" title="数据库ACID的概念，事务是怎么保证的"></a>数据库ACID的概念，事务是怎么保证的</h2><ul><li>原子性(Atomicity)：  事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：  数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)： 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>事务的原子性指一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。</p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态;如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。<br>另一部分是业务数据的一致性，这需要程序代码来保证。比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。</p><p>事务的隔离性指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>事务的持久性指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。持久性意味着事务操作最终要持久化到数据库中，持久性是由 内存+redo log来保证的，MySQL的InnoDB在修改数据的时候，同时在内存和redo log记录这次操作，宕机的时候可以从redo log中恢复数据。</p><h2 id="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"><a href="#介绍一下mysql的常见的存储引擎，以及它们的区别是什么？" class="headerlink" title="介绍一下mysql的常见的存储引擎，以及它们的区别是什么？"></a>介绍一下mysql的常见的存储引擎，以及它们的区别是什么？</h2><h2 id="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"><a href="#介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）" class="headerlink" title="介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）"></a>介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）</h2><ul><li>读未提交（READ UNCOMMITTED）在该隔离级别一个事务还没提交时，它做的变更就能被别的事务看到，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务提交之后，它做的变更才会被其他事务看到。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li>可重复读 （REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li>串行化 （SERIALIZABLE）“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p>MySQL的InnoDB引擎在可重复读级别通过间隙锁解决了幻读问题，通过MVCC解决了不可重复读的问题</p><h2 id="mysql底层为什么用的是b-树？"><a href="#mysql底层为什么用的是b-树？" class="headerlink" title="mysql底层为什么用的是b+树？"></a>mysql底层为什么用的是b+树？</h2><h2 id="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"><a href="#介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？" class="headerlink" title="介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？"></a>介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？</h2><h2 id="MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。"><a href="#MySQL的Buffer-Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer-pool吗？回答不是，buffer-pool只是缓存需要的数据并且尽可能缓存热数据。" class="headerlink" title="MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。"></a>MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。</h2><h2 id="MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"><a href="#MySQL的Buffer-Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。" class="headerlink" title="MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。"></a>MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。</h2><h2 id="MySQL的LRU和普通的LRU算法有何区别？"><a href="#MySQL的LRU和普通的LRU算法有何区别？" class="headerlink" title="MySQL的LRU和普通的LRU算法有何区别？"></a>MySQL的LRU和普通的LRU算法有何区别？</h2><h2 id="介绍MySQL三大日志redo-log-undo-log-bin-log。"><a href="#介绍MySQL三大日志redo-log-undo-log-bin-log。" class="headerlink" title="介绍MySQL三大日志redo log,undo log,bin log。"></a>介绍MySQL三大日志redo log,undo log,bin log。</h2><h2 id="写一个LRU缓存。"><a href="#写一个LRU缓存。" class="headerlink" title="写一个LRU缓存。"></a>写一个LRU缓存。</h2><h2 id="查询优化器有哪些优化"><a href="#查询优化器有哪些优化" class="headerlink" title="查询优化器有哪些优化"></a>查询优化器有哪些优化</h2><h2 id="InnoDB里面有哪些线程"><a href="#InnoDB里面有哪些线程" class="headerlink" title="InnoDB里面有哪些线程"></a>InnoDB里面有哪些线程</h2><h2 id="为什么使用B-树做索引，而不是B树或者哈希"><a href="#为什么使用B-树做索引，而不是B树或者哈希" class="headerlink" title="为什么使用B+树做索引，而不是B树或者哈希"></a>为什么使用B+树做索引，而不是B树或者哈希</h2><h2 id="了解Trie树吗"><a href="#了解Trie树吗" class="headerlink" title="了解Trie树吗"></a>了解Trie树吗</h2><h2 id="MySQL缓存介绍一下，有哪些优化"><a href="#MySQL缓存介绍一下，有哪些优化" class="headerlink" title="MySQL缓存介绍一下，有哪些优化"></a>MySQL缓存介绍一下，有哪些优化</h2><h2 id="为什么使用索引、说一下你对索引的理解？"><a href="#为什么使用索引、说一下你对索引的理解？" class="headerlink" title="为什么使用索引、说一下你对索引的理解？"></a>为什么使用索引、说一下你对索引的理解？</h2><h2 id="事务的性质有哪些，具体概念以及实现"><a href="#事务的性质有哪些，具体概念以及实现" class="headerlink" title="事务的性质有哪些，具体概念以及实现"></a>事务的性质有哪些，具体概念以及实现</h2><h2 id="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"><a href="#也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等" class="headerlink" title="也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等"></a>也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;a href=&quot;#MySQL相关问题，事务，索引，索引的优化，用过没&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关问题，事务，索引，索引的优化，用过没&quot;&gt;&lt;/a&gt;MySQL相关问题，事</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计网</title>
    <link href="http://example.com/p/bdbd2d9.html"/>
    <id>http://example.com/p/bdbd2d9.html</id>
    <published>2023-08-06T14:58:38.217Z</published>
    <updated>2023-08-10T15:14:46.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h2><h2 id="tcp四次挥手第二次和第三次不能合并吗"><a href="#tcp四次挥手第二次和第三次不能合并吗" class="headerlink" title="tcp四次挥手第二次和第三次不能合并吗"></a>tcp四次挥手第二次和第三次不能合并吗</h2><h2 id="osi七层网络模型，每层有的协议"><a href="#osi七层网络模型，每层有的协议" class="headerlink" title="osi七层网络模型，每层有的协议"></a>osi七层网络模型，每层有的协议</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="ssl四次挥手"><a href="#ssl四次挥手" class="headerlink" title="ssl四次挥手"></a>ssl四次挥手</h2><h2 id="计算机网络的理解大概是什么样的？说下TCP的三次握手"><a href="#计算机网络的理解大概是什么样的？说下TCP的三次握手" class="headerlink" title="计算机网络的理解大概是什么样的？说下TCP的三次握手"></a>计算机网络的理解大概是什么样的？说下TCP的三次握手</h2><h2 id="SSL的四次握手知道不？"><a href="#SSL的四次握手知道不？" class="headerlink" title="SSL的四次握手知道不？"></a>SSL的四次握手知道不？</h2><h2 id="tcp三次握手过程、是否熟悉TLS协议"><a href="#tcp三次握手过程、是否熟悉TLS协议" class="headerlink" title="tcp三次握手过程、是否熟悉TLS协议"></a>tcp三次握手过程、是否熟悉TLS协议</h2><h2 id="介绍一下使用tcp进行通信的时候socket的使用过程"><a href="#介绍一下使用tcp进行通信的时候socket的使用过程" class="headerlink" title="介绍一下使用tcp进行通信的时候socket的使用过程"></a>介绍一下使用tcp进行通信的时候socket的使用过程</h2><h2 id="网络模型、介绍一下每一层的作用？"><a href="#网络模型、介绍一下每一层的作用？" class="headerlink" title="网络模型、介绍一下每一层的作用？"></a>网络模型、介绍一下每一层的作用？</h2><h2 id="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"><a href="#这个也是从上面引申的，流量控制和拥塞控制怎么实现的？" class="headerlink" title="这个也是从上面引申的，流量控制和拥塞控制怎么实现的？"></a>这个也是从上面引申的，流量控制和拥塞控制怎么实现的？</h2><h2 id="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"><a href="#具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。" class="headerlink" title="具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。"></a>具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。</h2><h2 id="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"><a href="#如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）" class="headerlink" title="如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）"></a>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）</h2><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><h2 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h2><h2 id="如何使用UDP设计一个可靠的传输协议（知识盲区）"><a href="#如何使用UDP设计一个可靠的传输协议（知识盲区）" class="headerlink" title="如何使用UDP设计一个可靠的传输协议（知识盲区）"></a>如何使用UDP设计一个可靠的传输协议（知识盲区）</h2><h2 id="一条SQL语句的执行流程"><a href="#一条SQL语句的执行流程" class="headerlink" title="一条SQL语句的执行流程"></a>一条SQL语句的执行流程</h2><h2 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h2><h2 id="为什么要用epoll"><a href="#为什么要用epoll" class="headerlink" title="为什么要用epoll"></a>为什么要用epoll</h2><h2 id="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"><a href="#reactor和proactor的好处和坏处。为什么要用reactor而不用proactor" class="headerlink" title="reactor和proactor的好处和坏处。为什么要用reactor而不用proactor"></a>reactor和proactor的好处和坏处。为什么要用reactor而不用proactor</h2><h2 id="能详细讲一下有限状态机怎么解析http报文吗"><a href="#能详细讲一下有限状态机怎么解析http报文吗" class="headerlink" title="能详细讲一下有限状态机怎么解析http报文吗"></a>能详细讲一下有限状态机怎么解析http报文吗</h2><h2 id="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"><a href="#小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题" class="headerlink" title="小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题"></a>小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题</h2><h2 id="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"><a href="#如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆" class="headerlink" title="如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆"></a>如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆</h2><h2 id="socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）"><a href="#socket通信问，connect时，操作系统会进行什么操作？（我：0-0，阿巴阿巴…）" class="headerlink" title="socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）"></a>socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）</h2><h2 id="这个时候会绑定端口吗？"><a href="#这个时候会绑定端口吗？" class="headerlink" title="这个时候会绑定端口吗？"></a>这个时候会绑定端口吗？</h2><h2 id="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"><a href="#后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）" class="headerlink" title="后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）"></a>后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）</h2><h2 id="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"><a href="#第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？" class="headerlink" title="第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？"></a>第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？</h2><h2 id="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"><a href="#第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？" class="headerlink" title="第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？"></a>第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？</h2><h2 id="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"><a href="#TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？" class="headerlink" title="TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？"></a>TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？</h2><h2 id="tcp-x2F-ip五层模型"><a href="#tcp-x2F-ip五层模型" class="headerlink" title="tcp&#x2F;ip五层模型"></a>tcp&#x2F;ip五层模型</h2><h2 id="dns服务器用的是什么协议。"><a href="#dns服务器用的是什么协议。" class="headerlink" title="dns服务器用的是什么协议。"></a>dns服务器用的是什么协议。</h2><h2 id="ping命令-用的是什么协议。在哪一层。"><a href="#ping命令-用的是什么协议。在哪一层。" class="headerlink" title="ping命令 用的是什么协议。在哪一层。"></a>ping命令 用的是什么协议。在哪一层。</h2><h2 id="tcp拥塞控制实现。"><a href="#tcp拥塞控制实现。" class="headerlink" title="tcp拥塞控制实现。"></a>tcp拥塞控制实现。</h2><h2 id="在浏览器输入URL后回车的过程，涉及什么协议"><a href="#在浏览器输入URL后回车的过程，涉及什么协议" class="headerlink" title="在浏览器输入URL后回车的过程，涉及什么协议"></a>在浏览器输入URL后回车的过程，涉及什么协议</h2><h2 id="http一定是tcp吗，http3之前是"><a href="#http一定是tcp吗，http3之前是" class="headerlink" title="http一定是tcp吗，http3之前是"></a>http一定是tcp吗，http3之前是</h2><h2 id="服务器多个进程可以都绑定80这个端口监听吗"><a href="#服务器多个进程可以都绑定80这个端口监听吗" class="headerlink" title="服务器多个进程可以都绑定80这个端口监听吗"></a>服务器多个进程可以都绑定80这个端口监听吗</h2><h2 id="原理是什么"><a href="#原理是什么" class="headerlink" title="原理是什么"></a>原理是什么</h2><h2 id="操作系统怎么转发的"><a href="#操作系统怎么转发的" class="headerlink" title="操作系统怎么转发的"></a>操作系统怎么转发的</h2><h2 id="https可以绑定80端口吗，绑定了还能加密吗，为什么"><a href="#https可以绑定80端口吗，绑定了还能加密吗，为什么" class="headerlink" title="https可以绑定80端口吗，绑定了还能加密吗，为什么"></a>https可以绑定80端口吗，绑定了还能加密吗，为什么</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h1&gt;&lt;h2 id=&quot;tcp和udp的区别&quot;&gt;&lt;a href=&quot;#tcp和udp的区别&quot; class=&quot;headerlink&quot; title=&quot;tcp和u</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>继承构造函数</title>
    <link href="http://example.com/p/4d123864.html"/>
    <id>http://example.com/p/4d123864.html</id>
    <published>2023-08-06T14:20:41.355Z</published>
    <updated>2023-08-10T14:11:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h1><p>继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    using Base::Base;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>在 C++11 以前，你就必须在 Derived 里再写一份同参数列表的构造函数，将参数转发给基类。</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, int y) : x(x), y(y)    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y)    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4);&#125;</code></pre><p>如果基类有很多重载的构造函数的话，每个重载版本都要在子类重写一下，这是违反代码复用原则的！更要命的是，如果基类构造函数重构了，而子类忘记跟着改的话，就容易 BOOM</p><pre><code>struct Base &#123;    int x;    int y;        Base(int x, double y) : x(x), y(y) // 基类 api 改了    &#123;    &#125;&#125;;struct Derived: Base&#123;    Derived(int x, int y) : Base(x, y) // 子类这里忘改了    &#123;    &#125;&#125;;int main()&#123;    Derived d(3, 4.5); // 定义变量的时候参考了基类 api 手册    // 你就等着调 bug 调到猝死吧&#125;</code></pre><p>using Base::基类方法名的这个语法是 C++98 就有的，不是 C++11 里才加的全新玩意。</p><pre><code>#include &lt;iostream&gt;class Base&#123;    protected:        void print() const        &#123;            std::cout &lt;&lt; 2333 &lt;&lt; std::endl;        &#125;&#125;;class Derived: public Base&#123;    public:        using Base::print;        // 如果不加这句声明，        // 则 print 方法在 Derived 类中就仍是 protected 的        // main 中无法调用&#125;;int main()&#123;    Derived d;    d.print();&#125;</code></pre><p>如上例所示，这种语法可以改变方法的访问控制域，比如将基类的保护方法公开出来，当然也可以将基类的公开方法在子类中变更为私有。再强调一下，这个是 C++98 中就有的语法。只不过 98 里不能 using 父类::构造函数（构造函数在某种意义上也是类的方法对吧，所以 11 补上了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承构造函数&quot;&gt;&lt;a href=&quot;#继承构造函数&quot; class=&quot;headerlink&quot; title=&quot;继承构造函数&quot;&gt;&lt;/a&gt;继承构造函数&lt;/h1&gt;&lt;p&gt;继承构造函数，即使用 using Base::Base; 语句直接继承基类构造函数&lt;/p&gt;
&lt;pre&gt;&lt;co</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="c++11" scheme="http://example.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/p/d04bd5bc.html"/>
    <id>http://example.com/p/d04bd5bc.html</id>
    <published>2023-08-06T13:10:20.145Z</published>
    <updated>2023-08-10T15:15:16.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="多线程接触过吗？控制线程访问共享资源有哪些锁？"><a href="#多线程接触过吗？控制线程访问共享资源有哪些锁？" class="headerlink" title="多线程接触过吗？控制线程访问共享资源有哪些锁？"></a>多线程接触过吗？控制线程访问共享资源有哪些锁？</h2><h2 id="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"><a href="#介绍一下互斥锁（中间穿插了一点项目的实现细节问题）" class="headerlink" title="介绍一下互斥锁（中间穿插了一点项目的实现细节问题）"></a>介绍一下互斥锁（中间穿插了一点项目的实现细节问题）</h2><h2 id="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"><a href="#用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？" class="headerlink" title="用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？"></a>用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？</h2><h2 id="操作系统是怎么进行内存管理的？"><a href="#操作系统是怎么进行内存管理的？" class="headerlink" title="操作系统是怎么进行内存管理的？"></a>操作系统是怎么进行内存管理的？</h2><h2 id="程序的状态有哪些？"><a href="#程序的状态有哪些？" class="headerlink" title="程序的状态有哪些？"></a>程序的状态有哪些？</h2><h2 id="详细介绍一下每个状态是怎样转换的？"><a href="#详细介绍一下每个状态是怎样转换的？" class="headerlink" title="详细介绍一下每个状态是怎样转换的？"></a>详细介绍一下每个状态是怎样转换的？</h2><h2 id="你知道的进程调度算法有哪些？详细介绍一下？"><a href="#你知道的进程调度算法有哪些？详细介绍一下？" class="headerlink" title="你知道的进程调度算法有哪些？详细介绍一下？"></a>你知道的进程调度算法有哪些？详细介绍一下？</h2><h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><h2 id="多进程fork后不同进程会共享哪些资源"><a href="#多进程fork后不同进程会共享哪些资源" class="headerlink" title="多进程fork后不同进程会共享哪些资源"></a>多进程fork后不同进程会共享哪些资源</h2><h2 id="多线程里线程的同步方式有哪些"><a href="#多线程里线程的同步方式有哪些" class="headerlink" title="多线程里线程的同步方式有哪些"></a>多线程里线程的同步方式有哪些</h2><h2 id="select怎么用。底层原理"><a href="#select怎么用。底层原理" class="headerlink" title="select怎么用。底层原理"></a>select怎么用。底层原理</h2><h2 id="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"><a href="#select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。" class="headerlink" title="select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。"></a>select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。</h2><h2 id="epoll-底层为什么用红黑树不用hash"><a href="#epoll-底层为什么用红黑树不用hash" class="headerlink" title="epoll 底层为什么用红黑树不用hash"></a>epoll 底层为什么用红黑树不用hash</h2><h2 id="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"><a href="#了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别" class="headerlink" title="了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别"></a>了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别</h2><h2 id="介绍一下epoll的两种实现方式"><a href="#介绍一下epoll的两种实现方式" class="headerlink" title="介绍一下epoll的两种实现方式"></a>介绍一下epoll的两种实现方式</h2><h2 id="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"><a href="#磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？" class="headerlink" title="磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？"></a>磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？</h2><h2 id="有了解epoll的底层数据结构吗？介绍一下"><a href="#有了解epoll的底层数据结构吗？介绍一下" class="headerlink" title="有了解epoll的底层数据结构吗？介绍一下"></a>有了解epoll的底层数据结构吗？介绍一下</h2><h2 id="如何限制一个进程能够使用的线程等资源"><a href="#如何限制一个进程能够使用的线程等资源" class="headerlink" title="如何限制一个进程能够使用的线程等资源"></a>如何限制一个进程能够使用的线程等资源</h2><p>ulimit -u 4096</p><p>这属于软限制，是可以改变的。也就是说在我的机器上最多可以有4096个进程，但是我可以通过改变这个参数的值来修改对于进程数量的软限制，比如说用下面的命令将软限制改到5120。</p><p>ulimit -u 5120</p><h2 id="了解过stdexec吗（NVIDIA的异步编程高性能库）"><a href="#了解过stdexec吗（NVIDIA的异步编程高性能库）" class="headerlink" title="了解过stdexec吗（NVIDIA的异步编程高性能库）"></a>了解过stdexec吗（NVIDIA的异步编程高性能库）</h2><p>没有</p><h2 id="使用过perf吗"><a href="#使用过perf吗" class="headerlink" title="使用过perf吗"></a>使用过perf吗</h2><p>没有</p><h2 id="怎么查看tlb命中率"><a href="#怎么查看tlb命中率" class="headerlink" title="怎么查看tlb命中率"></a>怎么查看tlb命中率</h2><h2 id="如何查看进程的线程数"><a href="#如何查看进程的线程数" class="headerlink" title="如何查看进程的线程数"></a>如何查看进程的线程数</h2><p>使用top命令，具体用法是 top -H</p><pre><code>    加上这个选项，top的每一行就不是显示一个进程，而是一个线程。</code></pre><p>使用ps命令，具体用法是 ps -xH</p><pre><code>    这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。</code></pre><p> 使用ps命令，具体用法是 ps -mq PID</p><pre><code>    这样可以看到指定的进程产生的线程数目。</code></pre><h2 id="如何查看进程打开的文件有哪些"><a href="#如何查看进程打开的文件有哪些" class="headerlink" title="如何查看进程打开的文件有哪些"></a>如何查看进程打开的文件有哪些</h2><p>1.列出所有打开的文件:</p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><ol start="2"><li>查看谁正在使用某个文件</li></ol><p>lsof   &#x2F;filepath&#x2F;file</p><p>3.递归查看某个目录的文件信息</p><p>lsof +D &#x2F;filepath&#x2F;filepath2&#x2F;</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><ol start="4"><li>比使用+D选项，遍历查看某个目录的所有文件信息 的方法</li></ol><p>lsof | grep ‘&#x2F;filepath&#x2F;filepath2&#x2F;’</p><ol start="5"><li>列出某个用户打开的文件信息</li></ol><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><ol start="6"><li>列出某个程序所打开的文件信息</li></ol><p>lsof -c mysql</p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p><ol start="7"><li>列出多个程序多打开的文件信息</li></ol><p>lsof -c mysql -c apache</p><ol start="8"><li>列出某个用户以及某个程序所打开的文件信息</li></ol><p>lsof -u test -c mysql</p><ol start="9"><li>列出除了某个用户外的被打开的文件信息</li></ol><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><ol start="10"><li>通过某个进程号显示该进行打开的文件</li></ol><p>lsof -p 1</p><ol start="11"><li>列出多个进程号对应的文件信息</li></ol><p>lsof -p 123,456,789</p><ol start="12"><li>列出除了某个进程号，其他进程号所打开的文件信息</li></ol><p>lsof -p ^1</p><p>13 . 列出所有的网络连接</p><p>lsof -i</p><ol start="14"><li>列出所有tcp 网络连接信息</li></ol><p>lsof  -i tcp</p><ol start="15"><li>列出所有udp网络连接信息</li></ol><p>lsof  -i udp</p><ol start="16"><li>列出谁在使用某个端口</li></ol><p>lsof -i :3306</p><ol start="17"><li>列出谁在使用某个特定的udp端口</li></ol><p>lsof -i udp:55</p><p>特定的tcp端口</p><p>lsof -i tcp:80</p><ol start="18"><li>列出某个用户的所有活跃的网络端口</li></ol><p>lsof  -a -u test -i</p><ol start="19"><li>列出所有网络文件系统</li></ol><p>lsof -N</p><p>20.域名socket文件</p><p>lsof -u</p><p>21.某个用户组所打开的文件信息</p><p>lsof -g 5555</p><ol start="22"><li>根据文件描述列出对应的文件信息</li></ol><p>lsof -d description(like 2)</p><ol start="23"><li>根据文件描述范围列出文件信息</li></ol><p>lsof -d 2-3</p><h2 id="产生死锁的条件以及怎么解决死锁问题"><a href="#产生死锁的条件以及怎么解决死锁问题" class="headerlink" title="产生死锁的条件以及怎么解决死锁问题"></a>产生死锁的条件以及怎么解决死锁问题</h2><h2 id="Linux大概学到什么程度？"><a href="#Linux大概学到什么程度？" class="headerlink" title="Linux大概学到什么程度？"></a>Linux大概学到什么程度？</h2><h2 id="线程怎么创建，什么语言"><a href="#线程怎么创建，什么语言" class="headerlink" title="线程怎么创建，什么语言"></a>线程怎么创建，什么语言</h2><h2 id="线程的基本状态有哪几个？"><a href="#线程的基本状态有哪几个？" class="headerlink" title="线程的基本状态有哪几个？"></a>线程的基本状态有哪几个？</h2><h2 id="多线程的使用的好处是什么"><a href="#多线程的使用的好处是什么" class="headerlink" title="多线程的使用的好处是什么"></a>多线程的使用的好处是什么</h2><h2 id="多线程会竞争资源出现死锁的状态，死锁怎么解决？"><a href="#多线程会竞争资源出现死锁的状态，死锁怎么解决？" class="headerlink" title="多线程会竞争资源出现死锁的状态，死锁怎么解决？"></a>多线程会竞争资源出现死锁的状态，死锁怎么解决？</h2><h2 id="事务及事务隔离"><a href="#事务及事务隔离" class="headerlink" title="事务及事务隔离"></a>事务及事务隔离</h2><h2 id="编译一个hello-world程序并且在shell上运行打印的全过程"><a href="#编译一个hello-world程序并且在shell上运行打印的全过程" class="headerlink" title="编译一个hello world程序并且在shell上运行打印的全过程?"></a>编译一个hello world程序并且在shell上运行打印的全过程?</h2><h2 id="fork-父子进程之间的关系"><a href="#fork-父子进程之间的关系" class="headerlink" title="fork()父子进程之间的关系"></a>fork()父子进程之间的关系</h2><h2 id="缺页中断的过程"><a href="#缺页中断的过程" class="headerlink" title="缺页中断的过程"></a>缺页中断的过程</h2><h2 id="地址转换的过程"><a href="#地址转换的过程" class="headerlink" title="地址转换的过程"></a>地址转换的过程</h2><h2 id="进程状态是怎么转变的"><a href="#进程状态是怎么转变的" class="headerlink" title="进程状态是怎么转变的"></a>进程状态是怎么转变的</h2><h2 id="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"><a href="#进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）" class="headerlink" title="进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）"></a>进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）</h2><h2 id="总线在其中发挥的作用"><a href="#总线在其中发挥的作用" class="headerlink" title="总线在其中发挥的作用"></a>总线在其中发挥的作用</h2><h2 id="这个过程中磁盘和内存的关系"><a href="#这个过程中磁盘和内存的关系" class="headerlink" title="这个过程中磁盘和内存的关系"></a>这个过程中磁盘和内存的关系</h2><h2 id="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"><a href="#从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行" class="headerlink" title="从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行"></a>从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;多线程接触过吗？控制线程访问共享资源有哪些锁？&quot;&gt;&lt;a href=&quot;#多线程接触过吗？控制线程访问共享资源有哪些锁</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp面向对象</title>
    <link href="http://example.com/p/87fdbf5e.html"/>
    <id>http://example.com/p/87fdbf5e.html</id>
    <published>2023-08-06T09:30:39.389Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp面向对象"><a href="#cpp面向对象" class="headerlink" title="cpp面向对象"></a>cpp面向对象</h1><p>面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装可以隐藏实现细节，使得代码模块化；封装将一些属性和相关方法封装在一个对象中，对数据的访问只能通过已定义的界面。对外隐藏内部具体实现细节。内部实现，外界不需要关心，外界只需要根据“内部提供的接口”去使用就可以。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><ul><li>保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）</li><li>隐藏方法（实现）细节，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</li><li>封装可以使对象拥有完整的属性和方法（类中的函数）</li><li>外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p><p>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>多态的构成条件</p><ul><li>必须通过基类的指针或者引用调用虚函数<ul><li>虚函数：在类的普通成员函数前加上virtual关键字+</li></ul></li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp面向对象&quot;&gt;&lt;a href=&quot;#cpp面向对象&quot; class=&quot;headerlink&quot; title=&quot;cpp面向对象&quot;&gt;&lt;/a&gt;cpp面向对象&lt;/h1&gt;&lt;p&gt;面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp内存管理</title>
    <link href="http://example.com/p/ee3dbaf8.html"/>
    <id>http://example.com/p/ee3dbaf8.html</id>
    <published>2023-08-06T08:45:54.616Z</published>
    <updated>2023-08-10T14:11:31.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp内存管理"><a href="#cpp内存管理" class="headerlink" title="cpp内存管理"></a>cpp内存管理</h1><p><img src="https://s1.ax1x.com/2023/08/06/pPA4Y7T.png" alt="pPA4Y7T.png"></p><p>栈：又叫堆栈，主要存放非静态局部变量、函数参数、返回值等等，栈是向下增长的；</p><p>BSS（Block started by symbol)：存放未初始化的全局和静态变量。</p><p>堆：用于程序运行时动态内存分配，堆是可以上增长的；</p><p>数据段：存储全局数据和静态数据，常量数据（如字符串常量）。</p><p>代码段：存储可执行的代码与只读常量；</p><p>当全局&#x2F;静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。</p><pre><code>int x;int z = 5;void func()&#123;    static int y;&#125;int main()&#123;    return 0;&#125;</code></pre><p>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p><p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p><p>而对于已经初始化了的全局&#x2F;静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p><h2 id="堆和栈的主要区别"><a href="#堆和栈的主要区别" class="headerlink" title="堆和栈的主要区别"></a>堆和栈的主要区别</h2><p>有以下几点：</p><ul><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ul><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="让一个对象只在栈（堆）上分配内存"><a href="#让一个对象只在栈（堆）上分配内存" class="headerlink" title="让一个对象只在栈（堆）上分配内存"></a>让一个对象只在栈（堆）上分配内存</h2><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<br>虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。<br>将operator new()设为私有即可禁止对象被new在堆上。</p><pre><code>class A  &#123;  private:      void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的      void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  public:      A()&#123;&#125;      ~A()&#123;&#125;  &#125;;</code></pre><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><p>就是不能静态建立类对象, 即不能直接调用类的构造函数。<br>首先要知道， 当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</p><pre><code>class A&#123;public:    A()&#123;&#125;    void destroy()&#123;delete this;&#125;private:    ~A()&#123;&#125;&#125;</code></pre><p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</p><p>存在问题：<br>1.无法解决继承问题：为了实现多态， 析构函数通常要设为virtual， 因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。<br>2. new和destroy的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp内存管理&quot;&gt;&lt;a href=&quot;#cpp内存管理&quot; class=&quot;headerlink&quot; title=&quot;cpp内存管理&quot;&gt;&lt;/a&gt;cpp内存管理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/06/pPA4Y7T.p</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>cpp</title>
    <link href="http://example.com/p/caeaa4a1.html"/>
    <id>http://example.com/p/caeaa4a1.html</id>
    <published>2023-08-06T07:08:25.455Z</published>
    <updated>2023-08-10T14:11:31.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h1><p><a href="https://www.dotcpp.com/course/808">https://www.dotcpp.com/course/808</a></p><h2 id="c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗"><a href="#c-是面向对象的编程语言，能介绍一下c-面向对象的几个特性吗" class="headerlink" title="c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗"></a>c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗</h2><p>封装、继承、多态</p><h2 id="c-面向对象编程讲一下"><a href="#c-面向对象编程讲一下" class="headerlink" title="c++面向对象编程讲一下"></a>c++面向对象编程讲一下</h2><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><h2 id="多态和继承在什么情况下使用"><a href="#多态和继承在什么情况下使用" class="headerlink" title="多态和继承在什么情况下使用"></a>多态和继承在什么情况下使用</h2><h2 id="除了多态和继承还有什么面向对象方法"><a href="#除了多态和继承还有什么面向对象方法" class="headerlink" title="除了多态和继承还有什么面向对象方法"></a>除了多态和继承还有什么面向对象方法</h2><h2 id="能再仔细介绍一下c-的多态吗"><a href="#能再仔细介绍一下c-的多态吗" class="headerlink" title="能再仔细介绍一下c++的多态吗"></a>能再仔细介绍一下c++的多态吗</h2><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><h2 id="多态是怎么调用派生类重写的方法的"><a href="#多态是怎么调用派生类重写的方法的" class="headerlink" title="多态是怎么调用派生类重写的方法的"></a>多态是怎么调用派生类重写的方法的</h2><h2 id="实现String-的普通和拷贝构造、赋值重载和析构函数"><a href="#实现String-的普通和拷贝构造、赋值重载和析构函数" class="headerlink" title="实现String 的普通和拷贝构造、赋值重载和析构函数"></a>实现String 的普通和拷贝构造、赋值重载和析构函数</h2><pre><code>#pragma warning(disable:4996)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyString &#123;public:    // 默认构造函数    MyString(const char* str = NULL);    // 复制构造函数    MyString(const MyString&amp; str);    // 移动构造函数    MyString(MyString&amp;&amp; str)noexcept;    // 析构函数    ~MyString();    // 字符串连接    MyString operator+(const MyString&amp; str);    // 拷贝赋值    MyString&amp; operator=(const MyString&amp; str);    //移动赋值    MyString&amp; operator=(MyString&amp;&amp; str);    // 字符串赋值    MyString&amp; operator=(const char* str);    // 判断是否字符串相等    bool operator==(const MyString&amp; str);    // 获取字符串长度    int length();    // 求子字符串[start,start+n-1]    MyString substr(int start, int n);    // 重载输出    friend ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str);private:    char* m_data;    int m_size;&#125;;// 构造函数MyString::MyString(const char* str)&#123;    if (str == nullptr)    &#123;        m_data = new char[1];        m_data[0] = &#39;\0&#39;;        m_size = 0;    &#125;    else    &#123;        m_size = strlen(str);        m_data = new char[m_size + 1];        strcpy(m_data, str);    &#125;&#125;// 复制构造函数MyString::MyString(const MyString&amp; str)&#123;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);&#125;// 析构函数MyString::~MyString()&#123;    delete[] m_data;&#125;// 字符串连接MyString MyString::operator+(const MyString&amp; str)&#123;    MyString newStr;    //释放原有空间    delete[] newStr.m_data;    newStr.m_size = m_size + str.m_size;    newStr.m_data = new char[newStr.m_size + 1];    strcpy(newStr.m_data, m_data);    strcpy(newStr.m_data + m_size, str.m_data);    return newStr;&#125;// 字符串赋值MyString&amp; MyString::operator=(const MyString&amp; str)&#123;    if (m_data == str.m_data)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = str.m_size;    m_data = new char[m_size + 1];    strcpy(m_data, str.m_data);    return *this;&#125;MyString&amp; MyString::operator=(MyString&amp;&amp; str)&#123;    if (str.m_data == m_data)    &#123;        return *this;    &#125;    delete m_data;    m_data = str.m_data;    m_size = str.m_size;    str.m_data = nullptr;    str.m_size = 0;&#125;// 字符串赋值MyString&amp; MyString::operator=(const char* str)&#123;    if (m_data == str)    &#123;        return *this;    &#125;    delete[] m_data;    m_size = strlen(str);    m_data = new char[m_size + 1];    strcpy(m_data, str);    return *this;&#125;// 判断是否字符串相等bool MyString::operator==(const MyString&amp; str)&#123;    return strcmp(m_data, str.m_data) == 0;&#125;// 获取字符串长度int MyString::length()&#123;    return m_size;&#125;// 求子字符串[start,start+n-1]MyString MyString::substr(int start, int n)&#123;    MyString newStr;    // 释放原有内存    delete[] newStr.m_data;    // 重新申请内存    newStr.m_data = new char[n + 1];    for (int i = 0;i &lt; n;++i)    &#123;        newStr.m_data[i] = m_data[start + i];    &#125;    newStr.m_data[n] = &#39;\0&#39;;    newStr.m_size = n;    return newStr;&#125;MyString::MyString(MyString&amp;&amp; str) noexcept&#123;    m_data = str.m_data;    str.m_data = nullptr;    m_size = str.m_size;    str.m_size = 0;&#125;// 重载输出ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str)&#123;    o &lt;&lt; str.m_data;    return o;&#125;</code></pre><h2 id="有了new是不是可以就不用malloc了？"><a href="#有了new是不是可以就不用malloc了？" class="headerlink" title="有了new是不是可以就不用malloc了？"></a>有了new是不是可以就不用malloc了？</h2><p>比如内存池，在这个基础上可以利用placement new<br>c 没有new  </p><h2 id="malloc是如何跟物理地址关联上的？"><a href="#malloc是如何跟物理地址关联上的？" class="headerlink" title="malloc是如何跟物理地址关联上的？"></a>malloc是如何跟物理地址关联上的？</h2><p>malloc申请内存返回的是虚拟地址而不是物理地址，而且，返回的这个虚拟地址是没有map映射到物理内存中的，只有当程序(进程)用到访问了这个地址的时候，</p><p>内核才响应“缺页异常”，才回去映射一块物理地址。</p><p>关于malloc(0) 能申请成功是肯定的，它返回的是虚拟地址(对应的物理地址还不确定的)，在你没用到这块地址空间的时候，它不会再物理上开辟内存。</p><p>在你用到malloc(0)返回的地址时，因为参数为0，缺页异常不会为你的进程空间申请额外内存。所以这个指针应该是不能用的。</p><h2 id="new-x2F-delete-malloc-x2F-free-区别"><a href="#new-x2F-delete-malloc-x2F-free-区别" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free 区别"></a>new&#x2F;delete  malloc&#x2F;free 区别</h2><ol><li>运算符库函数</li><li>构造函数析构函数</li><li>可以重载</li><li>手动计算大小，自动计算大小</li><li>类型安全</li></ol><h2 id="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"><a href="#讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常" class="headerlink" title="讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常"></a>讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常</h2><p>调用malloc+构造函数<br>nothrow指定<br>bad——alloc</p><h2 id="malloc线程安全吗，多线程malloc系统怎么设计"><a href="#malloc线程安全吗，多线程malloc系统怎么设计" class="headerlink" title="malloc线程安全吗，多线程malloc系统怎么设计"></a>malloc线程安全吗，多线程malloc系统怎么设计</h2><p>在多线程环境下，使用 malloc() 和 free() 函数需要特别注意，因为这两个函数都会涉及到内存的分配和释放，容易引起多线程竞争问题，可能会导致内存泄漏或程序崩溃。</p><p>为了避免这些问题，需要采取以下措施：</p><p>确保线程安全：多个线程同时使用 malloc() 或 free() 时可能会导致内存竞争。为了确保线程安全，可以使用线程安全的内存分配器，例如 tcmalloc 或 jemalloc，或者使用互斥锁来保护内存分配和释放的操作。</p><p>避免内存泄漏：如果在分配内存后忘记释放，将会导致内存泄漏。在多线程环境中，内存泄漏问题可能会更加复杂，因为在一个线程中分配的内存可能需要在另一个线程中释放。为了避免内存泄漏，应该在适当的时候调用 free() 函数来释放已经不再使用的内存。</p><p>避免悬挂指针问题：在多线程环境中，如果一个线程释放了某个内存块，而另一个线程仍然在使用这个内存块，就可能导致悬挂指针问题。为了避免这个问题，应该在释放内存块之前确保没有其他线程在使用该内存块，可以使用同步机制来解决这个问题。</p><p>总之，在多线程环境中，使用 malloc() 和 free() 函数需要特别小心，需要采取适当的措施来确保线程安全和避免内存泄漏和悬挂指针问题。</p><h2 id="C-内存分布。什么样的数据在栈区，什么样的在堆区。"><a href="#C-内存分布。什么样的数据在栈区，什么样的在堆区。" class="headerlink" title="C++内存分布。什么样的数据在栈区，什么样的在堆区。"></a>C++内存分布。什么样的数据在栈区，什么样的在堆区。</h2><p>局部栈区，全局堆区</p><h2 id="C-内存管理（RAII啥的）"><a href="#C-内存管理（RAII啥的）" class="headerlink" title="C++内存管理（RAII啥的）"></a>C++内存管理（RAII啥的）</h2><p>资源获取即初始化。使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><h2 id="sizeof一个空的结构体，返回什么"><a href="#sizeof一个空的结构体，返回什么" class="headerlink" title="sizeof一个空的结构体，返回什么"></a>sizeof一个空的结构体，返回什么</h2><p>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><h2 id="问了c-文件编译过程"><a href="#问了c-文件编译过程" class="headerlink" title="问了c++文件编译过程"></a>问了c++文件编译过程</h2><p>预编译  cpp<br>汇编    i<br>编译    s<br>链接    o</p><h2 id="静态链接动态链接区别"><a href="#静态链接动态链接区别" class="headerlink" title="静态链接动态链接区别"></a>静态链接动态链接区别</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="动态链接库具体怎样操作链接的"><a href="#动态链接库具体怎样操作链接的" class="headerlink" title="动态链接库具体怎样操作链接的"></a>动态链接库具体怎样操作链接的</h2><p>重定位   忘了待更新</p><h2 id="c-学的好的是哪块-具体说"><a href="#c-学的好的是哪块-具体说" class="headerlink" title="c++学的好的是哪块 具体说"></a>c++学的好的是哪块 具体说</h2><p>学得最好的是没有</p><h2 id="野指针和内存泄漏是什么，如何避免？"><a href="#野指针和内存泄漏是什么，如何避免？" class="headerlink" title="野指针和内存泄漏是什么，如何避免？"></a>野指针和内存泄漏是什么，如何避免？</h2><p>内存泄漏：①访问已经释放的内存</p><pre><code>②访问没有权限的内存</code></pre><p>野指针：指向内存被释放的内存或者没有访问权限的内存的指针。<br>野指针”的成因主要有3种：<br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><h2 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h2><p>智能指针</p><h2 id="内存泄漏怎样应对"><a href="#内存泄漏怎样应对" class="headerlink" title="内存泄漏怎样应对"></a>内存泄漏怎样应对</h2><p>智能指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><h2 id="讲一下智能指针"><a href="#讲一下智能指针" class="headerlink" title="讲一下智能指针"></a>讲一下智能指针</h2><h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="讲讲智能指针"><a href="#讲讲智能指针" class="headerlink" title="讲讲智能指针"></a>讲讲智能指针</h2><h2 id="c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用"><a href="#c-11的智能指针有哪些。weak-ptr的使用场景。什么情况下会产生循环引用" class="headerlink" title="c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用"></a>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用</h2><h2 id="shared-ptr循环引用怎么解决"><a href="#shared-ptr循环引用怎么解决" class="headerlink" title="shared_ptr循环引用怎么解决"></a>shared_ptr循环引用怎么解决</h2><p>weak_ptr</p><h2 id="make-shared和shared-ptr"><a href="#make-shared和shared-ptr" class="headerlink" title="make_shared和shared_ptr"></a>make_shared和shared_ptr</h2><p>std::shared_ptr构造函数会执行两次内存申请，而std::make_shared则执行一次。<br>std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr<A> p2(new A)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared<A>()则是只执行一次内存申请，将数据和控制块的申请放到一起。</A></A></p><h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>考虑下面一段代码：</p><pre><code>void f(std::shared_ptr&lt;Lhs&gt; &amp;lhs, std::shared_ptr&lt;Rhs&gt; &amp;rhs)&#123;...&#125;...f(std::shared_ptr&lt;Lhs&gt;(new Lhs()),std::shared_ptr&lt;Rhs&gt;(new Rhs()));</code></pre><p>因为C++允许参数在计算的时候打乱顺序，因此一个可能的顺序如下:</p><pre><code>new Lhs()new Rhs()std::shared_ptrstd::shared_ptr</code></pre><p>此时假设第2步出现异常，则在第一步申请的内存将没处释放了，上面产生内存泄露的本质是当申请数据指针后，没有马上传给std::shared_ptr，因此一个可能的解决办法是：</p><pre><code>auto lhs = std::shared_ptr&lt;Lhs&gt;(new Lhs());auto rhs = std::shared_ptr&lt;Rhs&gt;(new Rhs());f(lhs, rhs);</code></pre><p>当然更好的方法是：</p><pre><code>f(std::make_shared&lt;Lhs&gt;(),    std::make_shared&lt;Rhs&gt;());</code></pre><p>make_shared的缺点<br>因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。</p><p>什么是weak_ptr？<br>weak_ptr是用来指向shared_ptr，用来判断shared_ptr指向的数据内存是否还存在了（通过方法lock），下面是一段示例代码：</p><pre><code>#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;struct A&#123;    int _i;    A(): _i(int())&#123;&#125;    A(int i): _i(i)&#123;&#125;&#125;;int main()&#123;    shared_ptr&lt;A&gt; sharedPtr(new A(2));    weak_ptr&lt;A&gt; weakPtr = sharedPtr;    sharedPtr.reset(new A(3)); // reset，weakPtr指向的失效了。    cout &lt;&lt; weakPtr.use_count() &lt;&lt;endl;&#125;</code></pre><p>通过lock（）来判断是否存在了，lock（）相当于</p><pre><code>expired（）？shared_ptr&lt;element_type&gt;() ： shared_ptr&lt;element_type&gt;(*this)</code></pre><p>当不存在的时候，会返回一个空的shared_ptr，weak_ptr在指向shared_ptr的时候，并不会增加ref count，因此weak_ptr主要有两个用途：</p><ul><li>用来记录对象是否存在了</li><li>用来解决shared_ptr环形依赖问题</li></ul><h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a>map和set</h2><p>底层红黑树，剩下不会了</p><h2 id="迭代器作用-迭代器和指针的区别"><a href="#迭代器作用-迭代器和指针的区别" class="headerlink" title="迭代器作用 迭代器和指针的区别"></a>迭代器作用 迭代器和指针的区别</h2><p><a href="https://whl963854.github.io/p/2cf69f40.html">https://whl963854.github.io/p/2cf69f40.html</a></p><h2 id="析构函数作用"><a href="#析构函数作用" class="headerlink" title="析构函数作用"></a>析构函数作用</h2><p>完成一些清理工作，比如：释放内存等。</p><h2 id="static关键字在C-中有什么作用？"><a href="#static关键字在C-中有什么作用？" class="headerlink" title="static关键字在C++中有什么作用？"></a>static关键字在C++中有什么作用？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰的类的数据成员怎么初始化的？"><a href="#static修饰的类的数据成员怎么初始化的？" class="headerlink" title="static修饰的类的数据成员怎么初始化的？"></a>static修饰的类的数据成员怎么初始化的？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"><a href="#static修饰类的成员函数，这个成员函数使用起来有哪些限制？" class="headerlink" title="static修饰类的成员函数，这个成员函数使用起来有哪些限制？"></a>static修饰类的成员函数，这个成员函数使用起来有哪些限制？</h2><p><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><h2 id="知道哪些c-中的关键字，然后讲了static"><a href="#知道哪些c-中的关键字，然后讲了static" class="headerlink" title="知道哪些c++中的关键字，然后讲了static"></a>知道哪些c++中的关键字，然后讲了static</h2><h2 id="static变量存储在哪，和局部变量存储位置有什么区别"><a href="#static变量存储在哪，和局部变量存储位置有什么区别" class="headerlink" title="static变量存储在哪，和局部变量存储位置有什么区别?"></a>static变量存储在哪，和局部变量存储位置有什么区别?</h2><h2 id="C-你觉得最特别于其他语言的点是什么"><a href="#C-你觉得最特别于其他语言的点是什么" class="headerlink" title="C++你觉得最特别于其他语言的点是什么"></a>C++你觉得最特别于其他语言的点是什么</h2><h2 id="java，python，c-垃圾回收怎么实现的"><a href="#java，python，c-垃圾回收怎么实现的" class="headerlink" title="java，python，c++垃圾回收怎么实现的"></a>java，python，c++垃圾回收怎么实现的</h2><h2 id="指针和引用的区别，左值右值，右值引用"><a href="#指针和引用的区别，左值右值，右值引用" class="headerlink" title="指针和引用的区别，左值右值，右值引用"></a>指针和引用的区别，左值右值，右值引用</h2><p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>可以有const指针，但是没有const引用；<br>指针可以有多级，但是引用只能是一级<br>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或–</p><p>引用在汇编层面会被c++编译器当做const指针来进行操作</p><h2 id="说说对指针和引用的理解"><a href="#说说对指针和引用的理解" class="headerlink" title="说说对指针和引用的理解"></a>说说对指针和引用的理解</h2><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题</strong>：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="堆和栈的区别。什么情况下会往堆里放"><a href="#堆和栈的区别。什么情况下会往堆里放" class="headerlink" title="堆和栈的区别。什么情况下会往堆里放"></a>堆和栈的区别。什么情况下会往堆里放</h2><p>new<br>malloc</p><h2 id="堆区都是手动释放？"><a href="#堆区都是手动释放？" class="headerlink" title="堆区都是手动释放？"></a>堆区都是手动释放？</h2><p>答：也不一定，主要看使用方法。如果使用的函数是malloc，new之类，就需要手动释放，不然会造成内存泄漏。但是如果我们使用智能指针，智能指针会自动释放内存，因为智能指针基于类自动调用析构函数实现了内存的自动释放</p><h2 id="C-哪些运算符不能重载？"><a href="#C-哪些运算符不能重载？" class="headerlink" title="C++哪些运算符不能重载？"></a>C++哪些运算符不能重载？</h2><p>答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p><p>以下运算符不能被重载：.、.*、::、? :、sizeof。<br>重载运算符()、[]、-&gt;、或者赋值运算符&#x3D;时，只能将它们重载为成员函数，不能重载为全局函数。</p><h2 id="char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别"><a href="#char-p-x3D-“123”-和char-p-x3D-“1”-“2”-“3”-的区别" class="headerlink" title="char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别"></a>char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别</h2><p>4  3 size</p><h2 id="C-11的特性有没有"><a href="#C-11的特性有没有" class="headerlink" title="C++11的特性有没有"></a>C++11的特性有没有</h2><p>初始化列表 使用 {} 可以方便地初始化数组、结构体、类等对象<br>智能指针 引入了 std::unique_ptr、std::shared_ptr 等智能指针，方便地进行动态内存管理<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式 可以在函数内部定义匿名函数，从而方便地实现函数对象。<br>字符串字面量<br>auto 自动类型推导：使用关键字 auto 可以让编译器自动推导变量的类型。<br>枚举类<br>完美转发<br>移动语义 使用 &amp;&amp; 可以表示右值引用，引入了移动构造函数和移动赋值运算符，可以减少不必要的拷贝。<br>constexptr<br>静态断言 使用关键字 static_assert 可以在编译时检查一个表达式是否为 true<br>新的容器和算法：引入了 std::array、std::forward_list、std::unordered_map、std::move 等新特性，增强了容器和算法库的功能。</p><h2 id="聊一聊你理解的移动构造函数？"><a href="#聊一聊你理解的移动构造函数？" class="headerlink" title="聊一聊你理解的移动构造函数？"></a>聊一聊你理解的移动构造函数？</h2><p>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。</p><h2 id="那c-有哪些构造函数呢？"><a href="#那c-有哪些构造函数呢？" class="headerlink" title="那c++有哪些构造函数呢？"></a>那c++有哪些构造函数呢？</h2><p>答：默认构造函数，有参构造函数，拷贝构造函数，移动构造函数。<br>委托构造函数<br>继承构造函数</p><h2 id="介绍一下map容器？"><a href="#介绍一下map容器？" class="headerlink" title="介绍一下map容器？"></a>介绍一下map容器？</h2><p>答：map支持kv键值对的查找，底层基于红黑树，查询和插入的时间复杂度都是logn。因为底层基于红黑树，map的key是有序的，所以map容器为我们提供了一些有序的api，比如对key的二分查找(lower_bound）。与此同时，我们还有unoredered_map,这个容器是哈希表，查询和插入的时间复杂度是O(1)，但是如果遇上哈希冲突，复杂度可能退化到O(n)。这个容器的key是无序的。unordered_map的使用的常数时间是要比map快一到两倍。</p><h2 id="讲一讲const关键字。"><a href="#讲一讲const关键字。" class="headerlink" title="讲一讲const关键字。"></a>讲一讲const关键字。</h2><p>答：const关键字在C++11之前，具有只读和常量两个语义。在C++11，引入constexpr关键字之后，const语义固定在了只读，constexpr固定为常量，但总而言之，这个两个关键字核心的语义是，指向的内容不可更改。<br>const 关键字用于指定变量或对象的值是不可修改的。它可以用于修饰变量、函数参数、函数返回值和成员函数等。 constexpr 关键字用于指定表达式在编译时就能够被计算出结果，从而产生一个编译期常量。它可以用于修饰变量、函数、类和模板等。constexpr 的作用是在编译时进行计算，从而提高程序的性能。</p><h2 id="那const指向地址呢？"><a href="#那const指向地址呢？" class="headerlink" title="那const指向地址呢？"></a>那const指向地址呢？</h2><p>答：const指向的地址值不可更改，但是地址对应的内容是可更改的。</p><h2 id="const关键字修饰类的对象使用起来有什么限制？"><a href="#const关键字修饰类的对象使用起来有什么限制？" class="headerlink" title="const关键字修饰类的对象使用起来有什么限制？"></a>const关键字修饰类的对象使用起来有什么限制？</h2><p><a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="const关键字修饰类的对象有什么办法改变内部数据？"><a href="#const关键字修饰类的对象有什么办法改变内部数据？" class="headerlink" title="const关键字修饰类的对象有什么办法改变内部数据？"></a>const关键字修饰类的对象有什么办法改变内部数据？</h2><p>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><h2 id="虚函数是什么，重载和重写的关系。"><a href="#虚函数是什么，重载和重写的关系。" class="headerlink" title="虚函数是什么，重载和重写的关系。"></a>虚函数是什么，重载和重写的关系。</h2><p>答：虚函数涉及到C++的多态。当、在基类中声明一个虚函数，在派生类中重写该函数，可以实现动态绑定。在运行时，程序会根据具体对象的类型调用相应的函数。重写要求函数签名完全一致，即函数名，函数变量和返回值完全一致，但是函数体可以不同。重写是运行时多态，也就是动态多态。重载是函数名相同，返回值和函数参数可以不同，重载是编译时多态，即静态多态。</p><h2 id="讲讲你理解的虚基类。"><a href="#讲讲你理解的虚基类。" class="headerlink" title="讲讲你理解的虚基类。"></a>讲讲你理解的虚基类。</h2><p>答：C++的虚基类类似Java的抽象类，是不可以实例化的。【这里回答错了】</p><p>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。虚基类是可以被实例化的。</p><h2 id="C-多态虚函数实现原理。虚函数表里面有哪些东西？"><a href="#C-多态虚函数实现原理。虚函数表里面有哪些东西？" class="headerlink" title="C++多态虚函数实现原理。虚函数表里面有哪些东西？"></a>C++多态虚函数实现原理。虚函数表里面有哪些东西？</h2><h2 id="虚函数和静态函数-虚表"><a href="#虚函数和静态函数-虚表" class="headerlink" title="虚函数和静态函数 虚表"></a>虚函数和静态函数 虚表</h2><h2 id="cpp编译生成二进制文件过程"><a href="#cpp编译生成二进制文件过程" class="headerlink" title=".cpp编译生成二进制文件过程"></a>.cpp编译生成二进制文件过程</h2><p><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><h2 id="C-从源程序到可执行程序的过程"><a href="#C-从源程序到可执行程序的过程" class="headerlink" title="C++从源程序到可执行程序的过程"></a>C++从源程序到可执行程序的过程</h2><h2 id="动态链接和静态链接区别。"><a href="#动态链接和静态链接区别。" class="headerlink" title="动态链接和静态链接区别。"></a>动态链接和静态链接区别。</h2><p><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><h2 id="如何优化一个c-程序-局部性"><a href="#如何优化一个c-程序-局部性" class="headerlink" title="如何优化一个c++程序,局部性"></a>如何优化一个c++程序,局部性</h2><p>时间局部性<br>空间局部性</p><h2 id="左值，右值，万能引用，完美转发"><a href="#左值，右值，万能引用，完美转发" class="headerlink" title="左值，右值，万能引用，完美转发"></a>左值，右值，万能引用，完美转发</h2><p><a href="https://whl963854.github.io/p/64657.html">https://whl963854.github.io/p/64657.html</a><br><a href="https://whl963854.github.io/p/3763.html">https://whl963854.github.io/p/3763.html</a><br><a href="https://whl963854.github.io/p/50074.html">https://whl963854.github.io/p/50074.html</a></p><h2 id="STL基本容器用过哪些"><a href="#STL基本容器用过哪些" class="headerlink" title="STL基本容器用过哪些"></a>STL基本容器用过哪些</h2><p>vector<br>string<br>stack<br>queue<br>set<br>map</p><h2 id="能说一下内存泄漏发生的情景吗"><a href="#能说一下内存泄漏发生的情景吗" class="headerlink" title="能说一下内存泄漏发生的情景吗"></a>能说一下内存泄漏发生的情景吗</h2><p>忘了释放内存资源</p><h2 id="size-of是在编译期还是在运行期确定"><a href="#size-of是在编译期还是在运行期确定" class="headerlink" title="size_of是在编译期还是在运行期确定"></a>size_of是在编译期还是在运行期确定</h2><p>sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。</p><h2 id="C-如何调整内存对齐值"><a href="#C-如何调整内存对齐值" class="headerlink" title="C++ 如何调整内存对齐值"></a>C++ 如何调整内存对齐值</h2><p>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</p><h2 id="主机大小端序"><a href="#主机大小端序" class="headerlink" title="主机大小端序"></a>主机大小端序</h2><p>C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的x86处理器是小端模式（Little Endian）。Java编写的程序则唯一采用Big Endian方式来存储数据。</p><h3 id="C-Coroutine"><a href="#C-Coroutine" class="headerlink" title="C++ Coroutine"></a>C++ Coroutine</h3><h2 id="C-虚函数-gt-构造函数能否是虚函数，析构函数"><a href="#C-虚函数-gt-构造函数能否是虚函数，析构函数" class="headerlink" title="C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数"></a>C++ 虚函数 -&gt; 构造函数能否是虚函数，析构函数</h2><p>构造不可以<br>析构可</p><h2 id="构造函数能否是虚函数？"><a href="#构造函数能否是虚函数？" class="headerlink" title="构造函数能否是虚函数？"></a>构造函数能否是虚函数？</h2><p>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。</p><p>虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。</p><p>vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。</p><p>如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。</p><p>因此，构造函数不可以是虚函数。</p><h2 id="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"><a href="#多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？" class="headerlink" title="多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？"></a>多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？</h2><p>使用多线程和使用多进程的选择取决于您的应用程序的需求。</p><p>多线程：在同一个进程中创建多个线程，多个线程共享进程的内存空间，因此它们可以很容易地共享数据，而且通信成本更低。因此，如果您的应用程序需要在单个进程内部并行执行不同任务，并且需要共享大量数据，则多线程是一个很好的选择。</p><p>多进程：当您的应用程序需要在不同的进程之间并行执行任务时，您可以使用多进程。不同进程之间的通信通常比同一进程中的通信慢，但它们拥有完全独立的内存空间，因此不存在内存访问冲突的问题。</p><p>总的来说，多线程适用于在单个进程中并行执行任务，并且需要共享大量数据的情况，而多进程适用于在不同进程中并行执行任务的情况。</p><h2 id="你这个项目是多线程的，那用多进程可不可以实现？"><a href="#你这个项目是多线程的，那用多进程可不可以实现？" class="headerlink" title="你这个项目是多线程的，那用多进程可不可以实现？"></a>你这个项目是多线程的，那用多进程可不可以实现？</h2><h2 id="项目相关介绍一下"><a href="#项目相关介绍一下" class="headerlink" title="项目相关介绍一下"></a>项目相关介绍一下</h2><h2 id="进程和线程的区别。"><a href="#进程和线程的区别。" class="headerlink" title="进程和线程的区别。"></a>进程和线程的区别。</h2><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><h2 id="为什么要用多线程。多进程可以吗（webserver的）"><a href="#为什么要用多线程。多进程可以吗（webserver的）" class="headerlink" title="为什么要用多线程。多进程可以吗（webserver的）"></a>为什么要用多线程。多进程可以吗（webserver的）</h2><h2 id="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"><a href="#了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？" class="headerlink" title="了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？"></a>了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？</h2><h2 id="线程池中的队列知道吗？队列是无限大的还是有限的"><a href="#线程池中的队列知道吗？队列是无限大的还是有限的" class="headerlink" title="线程池中的队列知道吗？队列是无限大的还是有限的"></a>线程池中的队列知道吗？队列是无限大的还是有限的</h2><h2 id="介绍一下线程的几种状态。"><a href="#介绍一下线程的几种状态。" class="headerlink" title="介绍一下线程的几种状态。"></a>介绍一下线程的几种状态。</h2><h2 id="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"><a href="#一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？" class="headerlink" title="一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？"></a>一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？</h2><h2 id="了解线程池吗？大概介绍一下"><a href="#了解线程池吗？大概介绍一下" class="headerlink" title="了解线程池吗？大概介绍一下"></a>了解线程池吗？大概介绍一下</h2><h2 id="多线程会发生什么问题？线程同步有哪些手段？"><a href="#多线程会发生什么问题？线程同步有哪些手段？" class="headerlink" title="多线程会发生什么问题？线程同步有哪些手段？"></a>多线程会发生什么问题？线程同步有哪些手段？</h2><h2 id="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"><a href="#什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？" class="headerlink" title="什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？"></a>什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？</h2><h2 id="说说对设计模式的理解"><a href="#说说对设计模式的理解" class="headerlink" title="说说对设计模式的理解"></a>说说对设计模式的理解</h2><h2 id="了解设计模式吗？介绍一下单例模式"><a href="#了解设计模式吗？介绍一下单例模式" class="headerlink" title="了解设计模式吗？介绍一下单例模式"></a>了解设计模式吗？介绍一下单例模式</h2><h2 id="了解的设计模式"><a href="#了解的设计模式" class="headerlink" title="了解的设计模式"></a>了解的设计模式</h2><p>单例<br>组件</p><h2 id="手撕一个设计模式"><a href="#手撕一个设计模式" class="headerlink" title="手撕一个设计模式"></a>手撕一个设计模式</h2><h2 id="手写一个单例模式"><a href="#手写一个单例模式" class="headerlink" title="手写一个单例模式"></a>手写一个单例模式</h2><h2 id="设计模式几大原则"><a href="#设计模式几大原则" class="headerlink" title="设计模式几大原则"></a>设计模式几大原则</h2><h2 id="手撕单例模式（懒汉模式）"><a href="#手撕单例模式（懒汉模式）" class="headerlink" title="手撕单例模式（懒汉模式）"></a>手撕单例模式（懒汉模式）</h2><h2 id="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"><a href="#情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统" class="headerlink" title="情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统"></a>情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统</h2><h2 id="模板元编程（简历上写了，但答的不好）"><a href="#模板元编程（简历上写了，但答的不好）" class="headerlink" title="模板元编程（简历上写了，但答的不好）"></a>模板元编程（简历上写了，但答的不好）</h2><h2 id="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"><a href="#编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的" class="headerlink" title="编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的"></a>编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的</h2><h2 id="怎么debug，怎么看内存泄漏。"><a href="#怎么debug，怎么看内存泄漏。" class="headerlink" title="怎么debug，怎么看内存泄漏。"></a>怎么debug，怎么看内存泄漏。</h2><h2 id="介绍一下条件变量"><a href="#介绍一下条件变量" class="headerlink" title="介绍一下条件变量"></a>介绍一下条件变量</h2><h2 id="一个对象-x3D-另一个对象会发生什么（赋值构造函数）"><a href="#一个对象-x3D-另一个对象会发生什么（赋值构造函数）" class="headerlink" title="一个对象&#x3D;另一个对象会发生什么（赋值构造函数）"></a>一个对象&#x3D;另一个对象会发生什么（赋值构造函数）</h2><h2 id="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"><a href="#如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）" class="headerlink" title="如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）"></a>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）</h2><h2 id="py修饰器"><a href="#py修饰器" class="headerlink" title="py修饰器"></a>py修饰器</h2><h2 id="函数重载的机制。重载是在编译期还是在运行期确定"><a href="#函数重载的机制。重载是在编译期还是在运行期确定" class="headerlink" title="函数重载的机制。重载是在编译期还是在运行期确定"></a>函数重载的机制。重载是在编译期还是在运行期确定</h2><h2 id="hash表数据很大。rehash的代价很高，怎么办"><a href="#hash表数据很大。rehash的代价很高，怎么办" class="headerlink" title="hash表数据很大。rehash的代价很高，怎么办"></a>hash表数据很大。rehash的代价很高，怎么办</h2><p>为字典的备用哈希表分配空间：</p><p>如果执行的是扩展操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)*2 的 2n（2 的 n 次方幂）</p><p>如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)的 2n</p><p>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始（为-1 时表示没有进行 rehash）。</p><p>rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当一次 rehash 工作完成之后，程序将 rehashidx 属性的值+1。同时在 serverCron 中调用 rehash 相关函数，在 1ms 的时间内，进行 rehash 处理，每次仅处理少量的转移任务(100 个元素)。</p><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为-1，表示 rehash 操作已完成。</p><h2 id="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"><a href="#最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。" class="headerlink" title="最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。"></a>最后手撕代码，单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。</h2><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><h2 id="二叉树应用场景-底层结构"><a href="#二叉树应用场景-底层结构" class="headerlink" title="二叉树应用场景 底层结构"></a>二叉树应用场景 底层结构</h2><h2 id="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"><a href="#说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的" class="headerlink" title="说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的"></a>说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的</h2><h2 id="了解哪些算法，说一点———–我说了排序"><a href="#了解哪些算法，说一点———–我说了排序" class="headerlink" title="了解哪些算法，说一点———–我说了排序"></a>了解哪些算法，说一点———–我说了排序</h2><h2 id="介绍下快速排序的过程"><a href="#介绍下快速排序的过程" class="headerlink" title="介绍下快速排序的过程"></a>介绍下快速排序的过程</h2><h2 id="栈和队列的区别，在实际应用中的场景"><a href="#栈和队列的区别，在实际应用中的场景" class="headerlink" title="栈和队列的区别，在实际应用中的场景"></a>栈和队列的区别，在实际应用中的场景</h2><p>队列</p><p>队列是一种先进先出的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；<br>打印机：当多个任务分配给打印机时，为了防止冲突，创建一个队列，把任务入队，按先入先出的原则处理任务；<br>远程服务器：当多个用户要访问远程服务端的文件时，也用到队列，满足先来先服务的原则；<br>队列理论：用来计算 预测用户在队中的等待时间，队的长度等等问题；<br>常用于处理任务请求队列，例如在操作系统内部处理进程队列、在网络传输协议中处理数据包队列等。</p><p>栈</p><p>栈是一种后进先出的数据结构，也就是说最新添加的项最早被移出；它是一种运算受限的线性表，只能在栈顶进行插入和删除操作。向一个栈插入新元素叫入栈（进栈），就是把新元素放入到栈顶的上面，成为新的栈顶；从一个栈删除元素叫出栈，就是把栈顶的元素删除掉，相邻的成为新栈顶。</p><p>用于符号的匹配：在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。<br>用于计算代数式：如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题；先要把代数式构造成 6 4 8 * + 的形式；逐个读取数据，当读到数字时，把数字入栈；读到运算符时，弹出栈中的两个元素进行运算并把结果压入栈中；<br>构造表达式：比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。（先规定优先级，加减的优先级最低，左括号优先级最高）<br>用于函数调用：因为CPU一次只能执行一个命令，而寄存器也是公用的，当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()。能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。target() 函数执行结束就取栈顶的返回地址继续执行 current()。</p><h2 id="手撕二分查找。"><a href="#手撕二分查找。" class="headerlink" title="手撕二分查找。"></a>手撕二分查找。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp&quot;&gt;&lt;a href=&quot;#cpp&quot; class=&quot;headerlink&quot; title=&quot;cpp&quot;&gt;&lt;/a&gt;cpp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.dotcpp.com/course/808&quot;&gt;https://www.dotcpp.com</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>招商银行</title>
    <link href="http://example.com/p/26e6c52c.html"/>
    <id>http://example.com/p/26e6c52c.html</id>
    <published>2023-08-05T13:45:29.932Z</published>
    <updated>2023-08-10T14:11:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"><a href="#介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别" class="headerlink" title="介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别"></a>介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别</h3><h3 id="Innodb的事务和锁机制"><a href="#Innodb的事务和锁机制" class="headerlink" title="Innodb的事务和锁机制"></a>Innodb的事务和锁机制</h3><h3 id="Mysql如何保证事务的一致性，MVCC与锁介绍"><a href="#Mysql如何保证事务的一致性，MVCC与锁介绍" class="headerlink" title="Mysql如何保证事务的一致性，MVCC与锁介绍"></a>Mysql如何保证事务的一致性，MVCC与锁介绍</h3><h3 id="Innodb和Myisam的索引机制和存储结构"><a href="#Innodb和Myisam的索引机制和存储结构" class="headerlink" title="Innodb和Myisam的索引机制和存储结构"></a>Innodb和Myisam的索引机制和存储结构</h3><h3 id="Mysql的各种日志，以及介绍用途"><a href="#Mysql的各种日志，以及介绍用途" class="headerlink" title="Mysql的各种日志，以及介绍用途"></a>Mysql的各种日志，以及介绍用途</h3><h3 id="何时使用索引，什么时候索引会失效"><a href="#何时使用索引，什么时候索引会失效" class="headerlink" title="何时使用索引，什么时候索引会失效"></a>何时使用索引，什么时候索引会失效</h3><h3 id="单表访问用到的索引"><a href="#单表访问用到的索引" class="headerlink" title="单表访问用到的索引"></a>单表访问用到的索引</h3><h3 id="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"><a href="#查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析" class="headerlink" title="查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析"></a>查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析</h3><h3 id="如何解决sql注入"><a href="#如何解决sql注入" class="headerlink" title="如何解决sql注入"></a>如何解决sql注入</h3><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><h3 id="你还有什么我没看到的优点，可以说一说（我是懵的）"><a href="#你还有什么我没看到的优点，可以说一说（我是懵的）" class="headerlink" title="你还有什么我没看到的优点，可以说一说（我是懵的）"></a>你还有什么我没看到的优点，可以说一说（我是懵的）</h3><h3 id="对工科有什么看法？？？"><a href="#对工科有什么看法？？？" class="headerlink" title="对工科有什么看法？？？"></a>对工科有什么看法？？？</h3><h3 id="开始问项目经验，项目经历-——————-出乎意料"><a href="#开始问项目经验，项目经历-——————-出乎意料" class="headerlink" title="开始问项目经验，项目经历 ——————- 出乎意料"></a>开始问项目经验，项目经历 ——————- 出乎意料</h3><h3 id="项目中怎么做的，遇到最大的问题是什么？你有什么突破"><a href="#项目中怎么做的，遇到最大的问题是什么？你有什么突破" class="headerlink" title="项目中怎么做的，遇到最大的问题是什么？你有什么突破"></a>项目中怎么做的，遇到最大的问题是什么？你有什么突破</h3><h3 id="如果不把他当成hr-会怎么描述这个项目？"><a href="#如果不把他当成hr-会怎么描述这个项目？" class="headerlink" title="如果不把他当成hr, 会怎么描述这个项目？"></a>如果不把他当成hr, 会怎么描述这个项目？</h3><h3 id="这个项目在实际中是怎么使用的？"><a href="#这个项目在实际中是怎么使用的？" class="headerlink" title="这个项目在实际中是怎么使用的？"></a>这个项目在实际中是怎么使用的？</h3><h3 id="去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？"><a href="#去当老师，来做技术是逃避吗？-——-——-我，这为啥是逃避？" class="headerlink" title="去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？"></a>去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？</h3><h3 id="最有成就感的事情？"><a href="#最有成就感的事情？" class="headerlink" title="最有成就感的事情？"></a>最有成就感的事情？</h3><h3 id="对自己的优缺点评价？"><a href="#对自己的优缺点评价？" class="headerlink" title="对自己的优缺点评价？"></a>对自己的优缺点评价？</h3><h3 id="转Java愿意吗？"><a href="#转Java愿意吗？" class="headerlink" title="转Java愿意吗？"></a>转Java愿意吗？</h3><h3 id="对其他编程语言的看法？"><a href="#对其他编程语言的看法？" class="headerlink" title="对其他编程语言的看法？"></a>对其他编程语言的看法？</h3><h3 id="工作地倾向？"><a href="#工作地倾向？" class="headerlink" title="工作地倾向？"></a>工作地倾向？</h3><h3 id="目前投的其他岗位是什么情况？"><a href="#目前投的其他岗位是什么情况？" class="headerlink" title="目前投的其他岗位是什么情况？"></a>目前投的其他岗位是什么情况？</h3><h3 id="你有什么问题"><a href="#你有什么问题" class="headerlink" title="你有什么问题"></a>你有什么问题</h3><h3 id="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"><a href="#我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0-8，其他没问出来啥。对了，项目经历大概问了15-20分钟。" class="headerlink" title="我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。"></a>我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。</h3><h3 id="项目过程中遇到的问题"><a href="#项目过程中遇到的问题" class="headerlink" title="项目过程中遇到的问题"></a>项目过程中遇到的问题</h3><h3 id="最近学了什么、学习方法是什么"><a href="#最近学了什么、学习方法是什么" class="headerlink" title="最近学了什么、学习方法是什么"></a>最近学了什么、学习方法是什么</h3><h3 id="对新入手的项目有没有什么学习技巧"><a href="#对新入手的项目有没有什么学习技巧" class="headerlink" title="对新入手的项目有没有什么学习技巧"></a>对新入手的项目有没有什么学习技巧</h3><h3 id="家庭情况"><a href="#家庭情况" class="headerlink" title="家庭情况"></a>家庭情况</h3><h3 id="base地的问题"><a href="#base地的问题" class="headerlink" title="base地的问题"></a>base地的问题</h3><h3 id="对加班的看法、最大能接受的加班强度"><a href="#对加班的看法、最大能接受的加班强度" class="headerlink" title="对加班的看法、最大能接受的加班强度"></a>对加班的看法、最大能接受的加班强度</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;招商银行&quot;&gt;&lt;a href=&quot;#招商银行&quot; class=&quot;headerlink&quot; title=&quot;招商银行&quot;&gt;&lt;/a&gt;招商银行&lt;/h1&gt;&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQ</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++新特性</title>
    <link href="http://example.com/p/a70da3b7.html"/>
    <id>http://example.com/p/a70da3b7.html</id>
    <published>2023-08-04T07:51:59.656Z</published>
    <updated>2023-08-05T07:03:45.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="C-11-中的新特性"><a href="#C-11-中的新特性" class="headerlink" title="C++11 中的新特性"></a>C++11 中的新特性</h2><p>C++11 引入了许多新特性，包括自动类型推导、lambda 表达式、右值引用等。下面介绍其中的一些重要特性。</p><h3 id="自动类型推导（Type-Inference）"><a href="#自动类型推导（Type-Inference）" class="headerlink" title="自动类型推导（Type Inference）"></a>自动类型推导（Type Inference）</h3><p>C++11 中引入了 auto 关键字，它可以用于自动推导变量的类型。例如：</p><pre><code>auto i = 10; // 推导为 intauto name = &quot;John&quot;; // 推导为 const char*自动类型推导使得代码更加简洁，并且可以避免显式指定类型的麻烦。</code></pre><p>auto只能推导类型，推导出来的类型不能用来定义对象，decltype解决了这点，推导类型后可以用来定义对象。</p><pre><code>#include&lt;cstring&gt;int main()&#123;    int i = 10;    auto p = &amp;i;    decltype(p) pi;//int*    pi = &amp;i;    cout &lt;&lt; *pi &lt;&lt; endl;//10    return 0;&#125;</code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种用于定义匿名函数的语法。它可以在需要函数对象的地方使用，并且可以捕获上下文中的变量。例如：</p><pre><code>auto sum = [](int a, int b) &#123;    return a + b;&#125;;int result = sum(5, 3); // 调用 lambda 表达式</code></pre><p>Lambda 表达式提供了一种简洁的方式来定义和使用函数对象，特别是在需要传递函数作为参数的情况下。</p><h3 id="右值引用（Rvalue-References）"><a href="#右值引用（Rvalue-References）" class="headerlink" title="右值引用（Rvalue References）"></a>右值引用（Rvalue References）</h3><p>C++11 引入了右值引用，它允许我们绑定到临时对象（右值），并且可以实现移动语义和完美转发。右值引用由双引号 &amp;&amp; 表示。</p><h4 id="什么是左值和右值："><a href="#什么是左值和右值：" class="headerlink" title="什么是左值和右值："></a>什么是左值和右值：</h4><p>• 一般来说，位于&#x3D; 前的表达式为左值；存储在内存中、有明确存储地址（可取地址）的数据；<br>• 右值是指可以提供数据值的数据（不可取地址）。</p><pre><code>int&amp;&amp; rvalue = 42; // 绑定到右值 42</code></pre><h4 id="右值引用的主要作用和意义如下："><a href="#右值引用的主要作用和意义如下：" class="headerlink" title="右值引用的主要作用和意义如下："></a>右值引用的主要作用和意义如下：</h4><p>移动语义：右值引用可以用于实现移动语义，即将一个对象的资源所有权从一个对象转移给另一个对象，而不需要进行深拷贝或浅拷贝。例如：</p><pre><code>class MyString &#123;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_) &#123;        other.data_ = nullptr;        other.size_ = 0;    &#125;private:    char* data_;    size_t size_;&#125;;MyString str1(&quot;Hello&quot;);      // 创建一个 MyString 对象MyString str2(std::move(str1));  // 将 str1 转移给 str2</code></pre><p>在上述代码中，MyString 类定义了一个移动构造函数，用于将一个右值引用转移给一个新对象。在创建 str2 对象时，使用 std::move 函数将 str1 转移给 str2，从而避免了不必要的深拷贝和内存分配操作，提高了程序的性能和效率。</p><p>完美转发：右值引用可以用于实现完美转发，即在函数调用时将参数按照原样转发给其他函数，从而避免了不必要的复制和拷贝操作。例如：</p><pre><code>template&lt;typename T&gt;void process(T&amp;&amp; arg) &#123;    other_func(std::forward&lt;T&gt;(arg));  // 将 arg 按照原样转发给 other_func&#125;</code></pre><p>在上述代码中，process 函数接受一个右值引用参数 arg，并使用 std::forward 函数将 arg 按照原样转发给 other_func 函数，从而避免了不必要的复制和拷贝操作，提高了程序的性能和效率。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><pre><code>for (decl : expr) &#123;    // 循环体&#125;</code></pre><p>decl表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中.<br>expr是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。<br>基于范围的 for 循环遍历容器，示例代码如下：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void) &#123;    vector&lt;int&gt; t&#123; 1,2,3,4,5,6 &#125;;    for (const auto&amp; value : t) &#123;        cout &lt;&lt; value &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;</code></pre><h2 id="C-14-中的新特性"><a href="#C-14-中的新特性" class="headerlink" title="C++14 中的新特性"></a>C++14 中的新特性</h2><p>C++14 对 C++11 进行了一些改进，并引入了一些新特性，例如变长模板参数、二进制字面量等。</p><h3 id="变长模板参数（Variadic-Templates）"><a href="#变长模板参数（Variadic-Templates）" class="headerlink" title="变长模板参数（Variadic Templates）"></a>变长模板参数（Variadic Templates）</h3><p>C++14 允许定义可变数量的模板参数，这被称为变长模板参数。通过使用省略号 …，可以在模板参数列表中指定任意数量的参数。例如：</p><pre><code>template &lt;typename... Args&gt;void print(Args... args) &#123;    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);&#125;print(1, &quot;hello&quot;, 3.14); // 输出: 1 hello 3.14</code></pre><p>变长模板参数提供了更大的灵活性，可以处理不同数量和类型的参数。   </p><h3 id="二进制字面量（Binary-Literals）"><a href="#二进制字面量（Binary-Literals）" class="headerlink" title="二进制字面量（Binary Literals）"></a>二进制字面量（Binary Literals）</h3><p>C++14 允许使用二进制字面量来表示二进制数值。使用前缀 0b 或 0B，后跟一串二进制数字。例如：</p><pre><code>int binary = 0b1010; // 二进制数值 10</code></pre><p>二进制字面量提供了一种直观和简洁的方式来表示和使用二进制数值。</p><h2 id="C-17-中的新特性"><a href="#C-17-中的新特性" class="headerlink" title="C++17 中的新特性"></a>C++17 中的新特性</h2><p>C++17 引入了一些有用的新特性，包括结构化绑定、折叠表达式、文件系统库等。</p><h3 id="结构化绑定（Structured-Bindings）"><a href="#结构化绑定（Structured-Bindings）" class="headerlink" title="结构化绑定（Structured Bindings）"></a>结构化绑定（Structured Bindings）</h3><p>结构化绑定允许将元组或其他复杂类型的成员解包并绑定到独立的变量中。这样可以方便地访问和操作复杂类型的成员。例如：</p><pre><code>std::pair&lt;int, std::string&gt; person&#123; 25, &quot;John&quot; &#125;;auto [age, name] = person;std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot;, Name: &quot; &lt;&lt; name; // 输出: Age: 25, Name: John</code></pre><p>结构化绑定简化了处理复杂类型的过程，使代码更加简洁易读。</p><h3 id="折叠表达式（Fold-Expressions）"><a href="#折叠表达式（Fold-Expressions）" class="headerlink" title="折叠表达式（Fold Expressions）"></a>折叠表达式（Fold Expressions）</h3><p>折叠表达式是一种用于处理可变数量参数包的语法。它允许在模板展开过程中对参数包进行操作。例如：</p><pre><code>template &lt;typename... Args&gt;bool allTrue(Args... args) &#123;    return (true &amp;&amp; ... &amp;&amp; args);&#125;bool result = allTrue(true, true, false); // 返回 false</code></pre><p>折叠表达式提供了一种简洁的方式来处理参数包，可以在编译时对参数进行组合和计算。</p><h3 id="文件系统库（Filesystem-Library）"><a href="#文件系统库（Filesystem-Library）" class="headerlink" title="文件系统库（Filesystem Library）"></a>文件系统库（Filesystem Library）</h3><p>C++传统文件操作需要使用std::ifstream 和 std::ofstream 类：分别表示输入文件流和输出文件流，可以用于读写文件内容。例如:</p><pre><code>#include &lt;fstream&gt;#include &lt;iostream&gt;int main() &#123;    std::ifstream input_file(&quot;input.txt&quot;);  // 打开输入文件    if (!input_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open input file.\n&quot;;        return 1;    &#125;    std::ofstream output_file(&quot;output.txt&quot;);  // 打开输出文件    if (!output_file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open output file.\n&quot;;        return 1;    &#125;    int num;    while (input_file &gt;&gt; num) &#123;  // 从输入文件中读取数字        output_file &lt;&lt; num * 2 &lt;&lt; &#39;\n&#39;;  // 将每个数字乘以 2 并写入输出文件    &#125;    input_file.close();   // 关闭输入文件    output_file.close();  // 关闭输出文件    return 0;&#125;</code></pre><p>C++17 引入了标准文件系统库，用于处理文件和目录的操作。该库提供了一组类和函数，用于创建、删除、移动、遍历文件和目录等操作。例如：</p><pre><code>#include &lt;filesystem&gt;namespace fs = std::filesystem;int main() &#123;    fs::path dir_path = &quot;dir&quot;;   // 定义目录路径    fs::create_directory(dir_path);  // 创建目录    fs::path file_path = dir_path / &quot;file.txt&quot;;  // 定义文件路径    fs::ofstream file(file_path);   // 打开文件    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file.\n&quot;;        return 1;    &#125;    file &lt;&lt; &quot;Hello, world!\n&quot;;  // 写入文件内容    file.close();  // 关闭文件    fs::remove(file_path);     // 删除文件    fs::remove(dir_path);      // 删除目录    return 0;&#125;</code></pre><p>文件系统库简化了文件和目录操作的实现，使得操作更加方便和可移植。</p><h2 id="C-20-中的新特性"><a href="#C-20-中的新特性" class="headerlink" title="C++20 中的新特性"></a>C++20 中的新特性</h2><p>C++20 引入了一系列新特性，包括概念、协程、三路比较运算符等。</p><h3 id="概念（Concepts）"><a href="#概念（Concepts）" class="headerlink" title="概念（Concepts）"></a>概念（Concepts）</h3><p>概念是 C++20 中的一项重要特性，用于对模板的类型参数进行约束。概念允许我们对类型进行条件检查，从而限制模板的实例化。例如：</p><pre><code>template &lt;typename T&gt;concept Arithmetic = std::is_arithmetic&lt;T&gt;::value;template &lt;Arithmetic T&gt;T square(T value) &#123;    return value * value;&#125;int result = square(5); // 正确，T 为算术类型std::string str = &quot;hello&quot;;// 错误，T 不是算术类型int result = square(str);</code></pre><p>概念提供了一种声明式的方式来定义模板参数的约束条件，使代码更具表达力和安全性。</p><h3 id="协程（Coroutines）"><a href="#协程（Coroutines）" class="headerlink" title="协程（Coroutines）"></a>协程（Coroutines）</h3><p>C++20 引入了协程支持，使得异步编程更加简洁和可读。协程允许函数在执行期间暂停和恢复，以便于异步任务的处理。例如</p><pre><code>#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Generator &#123;    struct promise_type &#123;        int current_value;        auto get_return_object() &#123;            return Generator&#123; std::coroutine_handle&lt;promise_type&gt;::from_promise(*this) &#125;;        &#125;        auto initial_suspend() &#123;            return std::suspend_always&#123;&#125;;        &#125;        auto final_suspend() noexcept &#123;            return std::suspend_always&#123;&#125;;        &#125;        void return_void() &#123;&#125;        auto yield_value(int value) &#123;            current_value = value;            return std::suspend_always&#123;&#125;;        &#125;        void unhandled_exception() &#123;            std::terminate();        &#125;    &#125;;    std::coroutine_handle&lt;promise_type&gt; coroutine;    bool move_next() &#123;        coroutine.resume();        return !coroutine.done();    &#125;    int current_value() &#123;        return coroutine.promise().current_value;    &#125;&#125;;Generator generate() &#123;    co_yield 1;    co_yield 2;    co_yield 3;&#125;int main() &#123;    Generator generator = generate();    while (generator.move_next()) &#123;        std::cout &lt;&lt; generator.current_value() &lt;&lt; &quot; &quot;;    &#125;    // 输出: 1 2 3    return 0;&#125;</code></pre><p>协程提供了一种简洁的方式来编写异步代码，提高了代码的可读性和可维护性。</p><h3 id="三路比较运算符（Three-Way-Comparison）"><a href="#三路比较运算符（Three-Way-Comparison）" class="headerlink" title="三路比较运算符（Three-Way Comparison）"></a>三路比较运算符（Three-Way Comparison）</h3><p>C++20 引入了三路比较运算符（&lt;&#x3D;&gt;），用于比较对象的大小关系。它返回一个可比较的结果，可以是小于、等于或大于。例如：</p><pre><code>struct Person &#123;    std::string name;    int age;    auto operator&lt;=&gt;(const Person&amp; other) const = default;//auto表示函数的返回类型将由编译器自动推导.在这里，返回类型将会是一个 std::strong_ordering 类型，这是 C++20 引入的一种枚举类型，用于表示强制排序关系。//= default：这个关键字表示使用默认实现，即使用编译器自动生成的代码来实现这个成员函数。在这里，编译器会自动生成一个使用 spaceship 运算符比较对象的代码。&#125;;Person john&#123;&quot;John&quot;, 25&#125;;Person alice&#123;&quot;Alice&quot;, 30&#125;;if (john &lt; alice) &#123;    std::cout &lt;&lt; &quot;John is younger than Alice.&quot;;&#125; else if (john &gt; alice) &#123;    std::cout &lt;&lt; &quot;John is older than Alice.&quot;;&#125; else &#123;    std::cout &lt;&lt; &quot;John and Alice have the same age.&quot;;&#125;</code></pre><p>三路比较运算符简化了比较操作的实现，提供了一种统一和直观的比较语法。</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-新特性&quot;&gt;&lt;a href=&quot;#C-新特性&quot; class=&quot;headerlink&quot; title=&quot;C++新特性&quot;&gt;&lt;/a&gt;C++新特性&lt;/h1&gt;&lt;h2 id=&quot;C-11-中的新特性&quot;&gt;&lt;a href=&quot;#C-11-中的新特性&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/p/2f57a694.html"/>
    <id>http://example.com/p/2f57a694.html</id>
    <published>2023-08-04T07:15:38.713Z</published>
    <updated>2023-08-04T10:00:36.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式是一种以字符串匹配为核心的强大的文本处理工具。通过一系列特殊字符和限定条件，正则表达式可以精确地描述一个文本片段的特征，从而达到将匹配的文本内容从整体文本中筛选出来的目的。它的核心功能就是在文本中查找符合指定规律的模式，这种模式可以是字符、字符组合或者字符范围，正则表达式就是定义这些规律的方式和规则。</p><h2 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h2><ul><li>字符匹配：<ul><li>普通字符：正则表达式中的普通字符表示自身，例如 a 匹配字符 “a”。</li><li>字符类：使用方括号 [ ] 来匹配一组字符中的任意一个字符，例如 [abc] 匹配字符 “a”、”b” 或 “c”。</li><li>转义字符：使用反斜杠 \ 来转义特殊字符，例如 . 匹配字符 “.”。</li></ul></li><li>重复匹配：<ul><li><em>：匹配前一个元素零次或多次，例如 a</em> 匹配零个或多个字符 “a”。</li><li>+：匹配前一个元素一次或多次，例如 a+ 匹配一个或多个字符 “a”。</li><li>?：匹配前一个元素零次或一次，例如 a? 匹配零个或一个字符 “a”。</li><li>{n}：匹配前一个元素恰好 n 次，例如 a{3} 匹配恰好三个字符 “a”。</li><li>{n,}：匹配前一个元素至少 n 次，例如 a{3,} 匹配至少三个字符 “a”。</li><li>{n,m}：匹配前一个元素至少 n 次，最多 m 次，例如 a{3,5} 匹配三到五个字符 “a”。</li></ul></li><li>特殊字符：<ul><li>.：匹配任意字符，除了换行符。</li><li>^：匹配输入字符串的开始位置。</li><li>$：匹配输入字符串的结束位置。</li><li>\b：匹配单词边界。</li><li>\d：匹配任意数字。</li><li>\w：匹配任意字母、数字或下划线。</li><li>\s：匹配任意空白字符。</li></ul></li><li>分组和捕获：<ul><li>()：用于分组，并且可以捕获分组的内容用于后续引用。</li></ul></li><li>选择符：<ul><li>|：用于在多个模式之间进行选择，例如 a|b 匹配字符 “a” 或 “b”。<br>这只是正则表达式的基本语法，还有更多高级的用法和特性。不同编程语言和工具对正则表达式的支持和语法也可能有所差异.</li></ul></li></ul><h2 id="C-和Qt-正则表达式的实现方法"><a href="#C-和Qt-正则表达式的实现方法" class="headerlink" title="C++ 和Qt 正则表达式的实现方法"></a>C++ 和Qt 正则表达式的实现方法</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>可以使用标准库中的正则表达式库 regex 来实现正则表达式的功能。以下是使用C++标准库的方法：<br>包含头文件：</p><pre><code>#include &lt;regex&gt;  </code></pre><p>创建正则表达式对象：</p><pre><code>std::regex regexObj(&quot;pattern&quot;);  //这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>std::string str = &quot;input string&quot;;  std::smatch match;  bool isMatch = std::regex_search(str, match, regexObj);  </code></pre><p>这里的 str 是你要匹配的字符串。match 是一个 std::smatch 对象,可以通过索引来访问匹配的子字符串,用于存储匹配结果。regex_search 函数用于搜索字符串中的第一个匹配项。</p><p>遍历匹配结果：</p><pre><code>for (size_t i = 0; i &lt; match.size(); ++i) &#123;      std::cout &lt;&lt; match[i] &lt;&lt; std::endl;  &#125;  </code></pre><h3 id="在Qt中"><a href="#在Qt中" class="headerlink" title="在Qt中"></a>在Qt中</h3><p>Qt提供了自己的正则表达式类 QRegularExpression 来处理正则表达式。以下是使用Qt的方法：<br>包含头文件：</p><pre><code>#include &lt;QRegularExpression&gt;  2. 创建正则表达式对象：QRegularExpression regexObj(&quot;pattern&quot;);  这里的 &quot;pattern&quot; 是你要匹配的正则表达式模式。</code></pre><p>匹配字符串：</p><pre><code>QString str = &quot;input string&quot;;  QRegularExpressionMatch match = regexObj.match(str);  //这里的 str 是你要匹配的字符串。match 是一个 QRegularExpressionMatch 对象，用于存储匹配结果。match 对象提供了一组方法来访问匹配的子字符串。</code></pre><p>遍历匹配结果：</p><pre><code>while (match.hasMatch()) &#123;      QString matchedStr = match.captured();      // 处理匹配的子字符串      match = regexObj.match(str, match.capturedEnd());  &#125;  </code></pre><p>通过调用 captured 方法可以获取匹配的子字符串。capturedEnd 方法返回上一个匹配结束的位置，用于在字符串中继续搜索下一个匹配项。</p><h2 id="正则表达式的应用案例"><a href="#正则表达式的应用案例" class="headerlink" title="正则表达式的应用案例"></a>正则表达式的应用案例</h2><h3 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h3><p>以下是一个使用 Qt 的正则表达式实现文本匹配的示例：<br>    #include <QRegularExpression><br>    #include <QDebug>  </QDebug></QRegularExpression></p><pre><code>int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched word: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。该正则表达式会匹配由小写字母组成的单词,输出结果是整句话中的每个单词。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>以下是一个使用 Qt 的正则表达式实现字符串替换的示例：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;The quick brown fox jumps over the lazy dog.&quot;;      QRegularExpression regex(&quot;\\b[a-z]+\\b&quot;);      QString replacedStr = str.replace(regex, &quot;REPLACED&quot;);      qDebug() &lt;&lt; &quot;Replaced string: &quot; &lt;&lt; replacedStr;      return 0;  &#125;  </code></pre><p>在这个例子中，我们使用正则表达式 \b[a-z]+\b 来匹配字符串中的单词。然后，使用 replace 函数将匹配到的单词替换为 “REPLACED”。<br>输出结果会显示替换后的字符串：</p><pre><code>Replaced string: &quot;The REPLACED REPLACED REPLACED jumps over the REPLACED REPLACED.&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来实现字符串替换。</p><h3 id="提取字符串中的邮箱地址"><a href="#提取字符串中的邮箱地址" class="headerlink" title="提取字符串中的邮箱地址"></a>提取字符串中的邮箱地址</h3><p>下面使用 Qt 的正则表达式的实例，它演示了如何使用正则表达式来验证和提取字符串中的邮箱地址：</p><pre><code>#include &lt;QRegularExpression&gt;  #include &lt;QDebug&gt;  int main()  &#123;      QString str = &quot;My email is john.doe@example.com and another email is jane@example.com&quot;;      QRegularExpression regex(&quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,&#125;\\b&quot;);      QRegularExpressionMatchIterator matchIterator = regex.globalMatch(str);      while (matchIterator.hasNext()) &#123;          QRegularExpressionMatch match = matchIterator.next();          QString matchedStr = match.captured();          qDebug() &lt;&lt; &quot;Matched email: &quot; &lt;&lt; matchedStr;      &#125;      return 0;  &#125;  </code></pre><p>使用了一个正则表达式来匹配邮箱地址的模式。正则表达式 \b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b 匹配标准的邮箱地址格式。<br>输出结果会显示匹配到的邮箱地址：</p><pre><code>Matched email:  &quot;john.doe@example.com&quot;  Matched email:  &quot;jane@example.com&quot;  </code></pre><p>这个例子展示了如何使用 Qt 的正则表达式来验证和提取字符串中的邮箱地址。</p><h2 id="正则表达式的扩展和优化"><a href="#正则表达式的扩展和优化" class="headerlink" title="正则表达式的扩展和优化"></a>正则表达式的扩展和优化</h2><h3 id="使用正则表达式的进阶技巧"><a href="#使用正则表达式的进阶技巧" class="headerlink" title="使用正则表达式的进阶技巧"></a>使用正则表达式的进阶技巧</h3><p>在Qt中，使用正则表达式进行一些进阶技巧的操作，可以增强正则表达式的功能和灵活性。以下是一些常见的Qt正则表达式的进阶技巧：</p><h4 id="捕获组（Capturing-Group）"><a href="#捕获组（Capturing-Group）" class="headerlink" title="捕获组（Capturing Group）"></a>捕获组（Capturing Group）</h4><p>使用括号将正则表达式的一部分括起来，可以将这部分内容作为一个捕获组。捕获组可以通过indexIn()函数的捕获组索引或capturedTexts()函数的捕获组名来获得匹配的子字符串。<br>QString input &#x3D; “Hello World”;<br>QRegExp regex(“Hello (\w+)”);  </p><p>if (regex.indexIn(input) !&#x3D; -1) {<br>    QString match &#x3D; regex.cap(0); &#x2F;&#x2F; 整个匹配的字符串<br>    QString capturingGroup &#x3D; regex.cap(1); &#x2F;&#x2F; 捕获组中的内容<br>}  </p><h4 id="替换（Replacement）："><a href="#替换（Replacement）：" class="headerlink" title="替换（Replacement）："></a>替换（Replacement）：</h4><p>使用QRegExp类的replace()函数可以进行替换操作，将匹配的部分替换为指定的内容。</p><pre><code>QString input = &quot;Hello, Alice!&quot;;  QRegExp regex(&quot;Alice&quot;);  QString replaced = input.replace(regex, &quot;Bob&quot;);  qDebug() &lt;&lt; &quot;Replaced: &quot; &lt;&lt; replaced; // Hello, Bob!  </code></pre><h4 id="最短匹配（Non-greedy）"><a href="#最短匹配（Non-greedy）" class="headerlink" title="最短匹配（Non-greedy）"></a>最短匹配（Non-greedy）</h4><p>使用问号（?）可以使量词变为最短匹配，即尽可能少地匹配字符。</p><pre><code>QString input = &quot;Hello &lt;b&gt;World&lt;/b&gt;!&quot;;  QRegExp regex(&quot;&lt;.*?&gt;&quot;);  int pos = regex.indexIn(input);  if (pos != -1) &#123;      QString match = regex.cap(0); // &lt;b&gt;  &#125;  </code></pre><h4 id="全局匹配（Global-Match）："><a href="#全局匹配（Global-Match）：" class="headerlink" title="全局匹配（Global Match）："></a>全局匹配（Global Match）：</h4><p>使用globalMatch()函数可以进行全局匹配，找到输入字符串中的所有匹配项。</p><pre><code>QString input = &quot;Hello, Alice! How are you, Alice?&quot;;  QRegExp regex(&quot;Alice&quot;);  QRegExpIterator iter(input, regex);  while (iter.hasNext()) &#123;      iter.next();      QString match = iter.value(); // Alice  &#125;  </code></pre><p>这些是一些Qt中正则表达式的进阶技巧，可以根据具体需求进行使用。</p><h3 id="利用正则表达式的编译器和解释器"><a href="#利用正则表达式的编译器和解释器" class="headerlink" title="利用正则表达式的编译器和解释器"></a>利用正则表达式的编译器和解释器</h3><p>在Qt中，有两个主要的正则表达式引擎：QRegExp和QRegularExpression。</p><h4 id="QRegExp"><a href="#QRegExp" class="headerlink" title="QRegExp"></a>QRegExp</h4><p>QRegExp是Qt早期版本中使用的正则表达式引擎。它基于C++标准库中的正则表达式功能，并在其基础上添加了一些Qt特定的扩展。QRegExp是一个解释器，它在运行时解释和匹配正则表达式。尽管QRegExp功能强大，但它不是完全兼容于Perl正则表达式语法，并且在处理大型文本时可能存在性能问题。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegExp regex(&quot;Hello (\\w+)&quot;);  if (regex.indexIn(input) != -1) &#123;      QString match = regex.cap(0); // 整个匹配的字符串      QString capturingGroup = regex.cap(1); // 捕获组中的内容  &#125;  </code></pre><h4 id="QRegularExpression"><a href="#QRegularExpression" class="headerlink" title="QRegularExpression"></a>QRegularExpression</h4><p>从Qt 5开始，引入了QRegularExpression作为新的正则表达式引擎。QRegularExpression是一个编译器，它在使用正则表达式之前将其编译成一个内部表示形式，这样可以提高效率。它也支持Perl正则表达式语法的大部分功能，并且在性能方面更优于QRegExp。<br>示例代码：</p><pre><code>QString input = &quot;Hello World&quot;;  QRegularExpression regex(&quot;Hello (\\w+)&quot;);  QRegularExpressionMatch match = regex.match(input);  if (match.hasMatch()) &#123;      QString captured = match.captured(0); // 整个匹配的字符串      QString capturingGroup = match.captured(1); // 捕获组中的内容  &#125;  </code></pre><p>无论是QRegExp还是QRegularExpression，都可以用于正则表达式的匹配、搜索和替换等操作，但在新的代码中推荐使用QRegularExpression，以获得更好的性能和更强大的功能。</p><h4 id="正则表达式的插件和辅助工具"><a href="#正则表达式的插件和辅助工具" class="headerlink" title="正则表达式的插件和辅助工具"></a>正则表达式的插件和辅助工具</h4><p>有一些独立的正则表达式插件和辅助工具可用于不同的开发环境和编辑器。以下是一些常见的正则表达式插件和辅助工具：</p><ol><li>RegexBuddy：这是一个强大的独立工具，用于创建、调试和测试正则表达式。它提供了一个直观的界面，可以可视化地构建和编辑正则表达式，并提供实时的匹配结果和错误提示。</li><li>RegExpert：这是一个在线的正则表达式调试器和测试工具，可以帮助您验证和调试正则表达式。它提供了一个交互式界面，可以实时检查输入文本的匹配结果，并显示匹配的子字符串和捕获组。</li><li>regex101：这是一个在线的正则表达式测试和学习平台，提供了一个交互式界面，可以输入正则表达式和测试文本，并实时显示匹配结果、捕获组和匹配的解释。</li><li>RegExr：这是一个基于Web的正则表达式工具，提供了一个交互式界面，可以可视化地构建和测试正则表达式。它还提供了实时的匹配结果和错误提示，以及一个正则表达式库和示例。<br>这些正则表达式插件和辅助工具可以帮助您更方便地创建、调试和测试正则表达式，提高开发效率和准确性。</li></ol><h2 id="正则表达式的陷阱和注意事项"><a href="#正则表达式的陷阱和注意事项" class="headerlink" title="正则表达式的陷阱和注意事项"></a>正则表达式的陷阱和注意事项</h2><p>在使用正则表达式时，有一些常见的陷阱和注意事项需要注意。以下是一些常见的陷阱和注意事项：</p><ul><li>贪婪匹配：默认情况下，正则表达式是贪婪匹配的，即它会尽可能多地匹配字符。如果您想要最短匹配，可以使用非贪婪量词（如*?，+?，??）或限定符的最小化形式。</li><li>转义字符：在正则表达式中，某些字符具有特殊含义，如点号（.）、星号（<em>）、加号（+）、问号（?）等。如果需要匹配这些特殊字符本身，需要使用反斜杠进行转义（如.、</em>、+、?）。</li><li>转义序列：正则表达式中有一些特殊的转义序列，如\d表示任意一个数字字符，\w表示任意一个字母、数字或下划线字符。这些转义序列可以用于简化正则表达式的编写。</li><li>字符边界：在正则表达式中，\b表示单词边界，即单词字符和非单词字符之间的位置。但请注意，\b在C++字符串中也是转义字符，所以需要使用双反斜杠（\b）来匹配单词边界。</li><li>捕获组编号：在一些正则表达式引擎中，捕获组的编号是从1开始的，而不是从0开始。因此，在访问捕获组时需要注意编号的对应关系。</li><li>性能问题：某些复杂的正则表达式可能会导致性能问题，特别是在处理大型文本时。尽量避免使用过于复杂的正则表达式，可以考虑将其拆分为多个简单的正则表达式。</li><li>Unicode支持：如果需要处理Unicode字符，确保使用支持Unicode的正则表达式引擎，并使用相应的Unicode转义序列和属性。</li><li>测试和验证：在编写正则表达式之前，建议使用测试工具或在线正则表达式测试平台来验证和调试您的正则表达式，以确保其正确性和预期的匹配结果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>database/sql</title>
    <link href="http://example.com/p/cacc0385.html"/>
    <id>http://example.com/p/cacc0385.html</id>
    <published>2023-08-03T01:17:25.682Z</published>
    <updated>2023-08-03T03:37:59.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-database-x2F-sql-在-Go-中进行数据库操作的简介"><a href="#使用-database-x2F-sql-在-Go-中进行数据库操作的简介" class="headerlink" title="使用 database&#x2F;sql 在 Go 中进行数据库操作的简介"></a>使用 database&#x2F;sql 在 Go 中进行数据库操作的简介</h1><p>公司需要用到database&#x2F;sql，在 Go 中使用 SQL 或类似 SQL 的数据库的惯用方法是通过 database&#x2F;sql 包。它为面向行的数据库提供了一个轻量级接口。看完以后觉得和JDBC差不多。英语无障碍可以参照<a href="http://go-database-sql.org/index.html">http://go-database-sql.org/index.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sql.DB</code> 并不是直接的数据库连接，它是数据库的抽象接口，它也不映射到任何特定数据库软件的“数据库”或“模式”概念。数据库可能像本地文件一样变化，可以通过网络连接访问，也可以在内存中和进程中访问。。它负责打开和关闭数据库连接，并管理连接池。正在使用的连接会被标记为繁忙，用完后会返回连接池等待下次使用。如果没有将连接释放回连接池，可能导致过多连接，从而耗尽系统资源。sql.DB不是数据库连接。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>要连接数据库，我们首先需要导入相应的驱动，具体取决于我们使用的数据库。例如，我们考虑使用 MySQL：</p><pre><code class="go">import (    &quot;database/sql&quot;    _ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123;    db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)    if err != nil &#123;        log.Fatal(err)    &#125;    defer db.Close()&#125;</code></pre><p><code>sql.Open()</code> 函数的第一个参数是驱动名称，第二个参数是连接数据库的信息。我们可以立即使用 <code>Ping()</code> 方法验证连接。</p><pre><code class="go">err = db.Ping()if err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>需要注意的是，<code>sql.DB</code> 被设计为长连接。频繁地进行 <code>Open()</code> 和 <code>Close()</code> 操作是不推荐的。最佳实践是为每个不同的数据存储创建一个 <code>DB</code> 对象，并保持这些对象的打开状态。如果需要短连接，请将 <code>DB</code> 对象作为参数传递给函数，而不是在函数中打开和关闭连接。</p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>如果方法涉及查询并返回多行结果，我们可以使用 <code>Query()</code>。对于其他操作，例如 INSERT、UPDATE 和 DELETE，我们使用 <code>Exec()</code>。</p><pre><code class="go">var (    id   int    name string)rows, err := db.Query(&quot;SELECT id, name FROM users WHERE id = ?&quot;, 1)if err != nil &#123;    log.Fatal(err)&#125;defer rows.Close()for rows.Next() &#123;    err := rows.Scan(&amp;id, &amp;name)    if err != nil &#123;        log.Fatal(err)    &#125;    log.Println(id, name)&#125;err = rows.Err()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><p>在迭代行时务必检查错误，并使用 <code>rows.Close()</code> 关闭结果集以释放底层连接。</p><p>对于单行查询，我们可以使用 <code>QueryRow()</code>：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    log.Fatal(err)&#125;fmt.Println(name)</code></pre><h2 id="修改数据和事务"><a href="#修改数据和事务" class="headerlink" title="修改数据和事务"></a>修改数据和事务</h2><p>对于 INSERT、UPDATE 和 DELETE 操作，我们使用预编译语句和 <code>Exec()</code>：<br>预处理执行过程：</p><ul><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ul><p>为什么要预处理？</p><ul><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ul><pre><code class="go">stmt, err := db.Prepare(&quot;INSERT INTO users (name) VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;res, err := stmt.Exec(&quot;Dolly&quot;)if err != nil &#123;    log.Fatal(err)&#125;lastId, err := res.LastInsertId()if err != nil &#123;    log.Fatal(err)&#125;rowCnt, err := res.RowsAffected()if err != nil &#123;    log.Fatal(err)&#125;log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)</code></pre><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。<br>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><p>要执行事务，我们使用 <code>Begin()</code>、<code>Commit()</code> 和 <code>Rollback()</code>：</p><pre><code class="go">tx, err := db.Begin()if err != nil &#123;    log.Fatal(err)&#125;defer tx.Rollback()stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)if err != nil &#123;    log.Fatal(err)&#125;defer stmt.Close()for i := 0; i &lt; 10; i++ &#123;    _, err = stmt.Exec(i)    if err != nil &#123;        log.Fatal(err)    &#125;&#125;err = tx.Commit()if err != nil &#123;    log.Fatal(err)&#125;</code></pre><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在与数据库交互时，适当处理错误非常重要。例如，在迭代 <code>Rows</code> 时检查错误并关闭结果集：</p><pre><code class="go">for rows.Next() &#123;    // ...&#125;if err = rows.Err(); err != nil &#123;    // 在这里处理错误&#125;</code></pre><p>如果在迭代所有行之前退出循环，必须手动关闭结果集并处理错误：</p><pre><code class="go">for rows.Next() &#123;    // ...    break&#125;if err = rows.Close(); err != nil &#123;    log.Println(err)&#125;</code></pre><p>对于单行查询，需要单独处理 <code>ErrNoRows</code> 错误：</p><pre><code class="go">var name stringerr = db.QueryRow(&quot;SELECT name FROM users WHERE id = ?&quot;, 1).Scan(&amp;name)if err != nil &#123;    if err == sql.ErrNoRows &#123;        // 处理没有找到行的情况    &#125; else &#123;        log.Fatal(err)    &#125;&#125;fmt.Println(name)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot;&gt;&lt;a href=&quot;#使用-database-x2F-sql-在-Go-中进行数据库操作的简介&quot; class=&quot;headerlink&quot; title=&quot;使用 database&amp;#x2F;sql</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>七层协议</title>
    <link href="http://example.com/p/e431c708.html"/>
    <id>http://example.com/p/e431c708.html</id>
    <published>2023-07-31T14:30:47.327Z</published>
    <updated>2023-07-31T14:41:15.404Z</updated>
    
    <content type="html"><![CDATA[<p>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线<br>数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）<br>传输层：TCP（T&#x2F;TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS&#x2F;SSL<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP&#x2F;2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP</p><h2 id="TCP和UDP的-区别"><a href="#TCP和UDP的-区别" class="headerlink" title="TCP和UDP的 区别"></a>TCP和UDP的 区别</h2><p>TCP是面向有连接型，UDP是面向无连接型；<br>TCP是一对一传输，UDP支持一对一、一对多、多对一和多对多的交互通信；<br>TCP是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部；UDP是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加UDP首部；<br>TCP支持传输可靠性的多种措施，包括保证包的传输顺序、重发机制、流量控制和拥塞控制；UDP仅提供最基本的数据传输能力。<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）,ISO2110,光导纤维，双绞线&lt;br&gt;数据链路层：wi-fi, ATM, DTM,令牌环，以太网，PPPoE ,PPP、FR、HDLC、VLAN、MAC（网桥、交换机）&lt;br&gt;网络层：IP、ICMP、AR</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://example.com/p/36b011d7.html"/>
    <id>http://example.com/p/36b011d7.html</id>
    <published>2023-07-27T14:53:47.358Z</published>
    <updated>2023-07-31T14:52:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP：80端口<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><p>客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议的主要特点可概括如下：<br>1、支持客户&#x2F;服务器模式。支持基本认证和安全认证。<br>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。<br>5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。<br>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息</p><p>一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。一般http中存在如下问题：</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h4 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h4><p>减少重定向请求次数；<br>合并请求；<br>延迟发送请求；</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。<br>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。<br>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递<br>如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了，直接通过代理服务器重新请求，而不是客户端重新请求，更进一步，如果代理服务器缓存了重定向网站可以直接向服务端发送请求。</p><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。另外由于 HTTP&#x2F;1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP&#x2F;1.1 管道模式是默认不使用的，所以讨论 HTTP&#x2F;1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。<br>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。</p><p>按需获取的方式，来减少第一时间的 HTTP 请求次数。请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><p>头部压缩<br>二进制格式<br>并发传输<br>服务器主动推送资源</p><h4 id="头部压缩（Header-Compression）"><a href="#头部压缩（Header-Compression）" class="headerlink" title="头部压缩（Header Compression）"></a>头部压缩（Header Compression）</h4><p>http1.x的头带有大量信息，而且每次都要重复发送。http&#x2F;2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p><p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><p>需要注意的是，http 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p><p>http&#x2F;2使用的是专门为首部压缩而设计的HPACK②算法。<br>用header字段表里的索引代替实际的header。</p><p>http&#x2F;2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>http2.0之所以能够突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p><p>在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><h4 id="多路复用-Multiplexing-x2F-连接共享"><a href="#多路复用-Multiplexing-x2F-连接共享" class="headerlink" title="多路复用 (Multiplexing) &#x2F; 连接共享"></a>多路复用 (Multiplexing) &#x2F; 连接共享</h4><p>在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，http&#x2F;2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><h4 id="服务端推送（Server-Push）"><a href="#服务端推送（Server-Push）" class="headerlink" title="服务端推送（Server Push）"></a>服务端推送（Server Push）</h4><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。<br>服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h4 id="http2-0性能瓶颈"><a href="#http2-0性能瓶颈" class="headerlink" title="http2.0性能瓶颈"></a>http2.0性能瓶颈</h4><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。、</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</p><ul><li>HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；</li><li>HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；</li><li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li></ul><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><h4 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h4><p>TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>TCP实现高并发有3个弊端：</p><ul><li>实现成本高。TCP是由操作系统内核实现的，如果通过多线程实现并发，并发线程数不能太多，否则线程间切换成本会以指数级上升；如果通过异步、非阻塞socket实现并发，开发效率又太低；</li><li>每个TCP连接与TLS会话都叠加了2-3个RTT的建链成本；</li><li>TCP连接有一个防止出现拥塞的慢启动流程，它会对每个TCP连接都产生减速效果。</li></ul><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="https://s1.ax1x.com/2023/07/30/pPpTX1P.png" alt="小林code"></p><h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。https端口：443</p><p>前面我们知道一般http中存在如下问题：</p><ul><li>请求信息明文传输，容易被<strong>窃听截取</strong>。</li><li>数据的完整性未校验，容易被<strong>篡改</strong></li><li>没有验证对方身份，存在<strong>冒充</strong>危险</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了HTTP的风险：</p><ul><li>数据保密性：保证数据内容在传输的过程中不会被第三方查看,交互信息无法被窃取。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</li><li>数据完整性：及时发现被第三方篡改的传输内容,无法篡改通信内容，篡改了就不能正常显示。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</li><li>身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</li></ul><p>对应采取了以下三种做法：</p><ul><li><strong>混合加密</strong>的方式实现信息的机密性，解决了<strong>窃听</strong>的风险。</li><li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了<strong>篡改</strong>的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了<strong>冒充</strong>的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS采用混合加密方式：利用两种加密方式的优点，组合起来进行通信；在交换秘钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享加密方式。</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。<br>采用「混合加密」的方式的原因：</li><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个哈希值，然后同内容一起传输给对方。<br>对方收到后，先是对内容也计算出一个哈希值，然后跟发送方发送的哈希值做一个比较，如果哈希值相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>通过哈希算法可以确保内容不会被篡改，但是并不能保证秘钥本身就是货真价实的公开密钥；</p><p>那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：</p><p>一个是公钥，这个是可以公开给所有人的；<br>一个是私钥，这个必须由本人管理，不可泄露。<br>这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。<br>流程的不同，意味着目的也不相同：</p><p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<br>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。<br>所以非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。<br>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>前面我们知道：<br>可以通过哈希算法来保证消息的完整性；<br>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？我伪造一个网站然后发给你公钥，按照前面流程我是知道私钥的，因为公钥是我伪造的，前面流程只能验证公钥和私钥匹配的，并不能解决身份冒充的问题。为了解决这个问题，可以使用由数字证书认证机构（CA）和其他相关机构颁发的公开秘钥证书。<br>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程：</li><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><ul><li>服务器拥有自己的私钥与公钥。</li><li>服务器将公钥交给CA认证机构，请求给予一份数字证书。</li><li>CA认证机构生成数字证书，并颁发给服务器。</li><li>服务器将带有公钥信息的数字证书发给客户端。</li><li>进入客户端生成对称密钥再进行对接的过程。</li></ul><h3 id="HTTPS的通信步骤"><a href="#HTTPS的通信步骤" class="headerlink" title="HTTPS的通信步骤"></a>HTTPS的通信步骤</h3><p>SSL&#x2F;TLS 协议基本流程：</p><p>客户端向服务器索要并验证服务器的公钥。<br>双方协商生产「会话秘钥」。<br>双方采用「会话秘钥」进行加密通信。<br>TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法</p><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ul><li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ul><p>客户端回应，客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li><p>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p></li><li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li><li><p>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></li><li><p>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></li><li><p>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></li><li><p>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></li><li><p>Web服务器利用自己的私钥解密出会话密钥。</p></li><li><p>Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="https://s1.ax1x.com/2023/07/30/pPp6EZV.png" alt="pPp6EZV.png"></p></li></ul><p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p><p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改、确保数据的完整性。<br>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但他大幅度增加了中间人攻击的成本。</p><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>慢，HTTPS未经任何优化的情况下要比HTTP慢几百毫秒以上，特别在移动端可能要慢500毫秒以上，关于HTTPS慢和如何优化已经是一个非常系统和复杂的话题。<br>贵，特别在计算性能和服务器成本方面。HTTPS要额外计算，要频繁地做加密和解密操作，几乎每一个字节都需要做加解密，这就产生了服务器成本。<br>大量的计算.SSL的每一个字节都涉及到较为复杂的计算。即使是clientHello，也需要在握手完成时做校验。<br>TLS协议的封装和解析。HTTPS所有数据都是按照TLS record格式进行封装和解析的。<br>协议的网络交互。从TLS的握手过程可以看出，即使不需要进行任何计算，TLS的握手也需要至少1个RTT（round trip time)以上的网络交互。RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。<br>HTTPS降低用户访问速度（需多次握手）。<br>网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）。<br>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https 访问过程需要加解密）。</p><h3 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h3><p>1）HSTS重定向技术：将http自动转换为https，减少301重定向。<br>2）TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据。直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT<br>3）会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了。<br>4）OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询。<br>5）完全前向加密PFS：使用更牛逼复杂的秘钥算法。</p><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><ol><li>DHCP 请求报文，目的端口67源端口68的UTP报文，广播地址255.255.255.255，源地址0.0.0.0</li><li>DHCP的IP数据报被放置在以太网帧当中以太网帧具有FF:FF:FF:FF:FF:FF进行广播。</li><li>当DHCP服务器收到后，通过CIDR分配IP</li><li>DNS 域名解析发送UDP报文段获取域名IP</li><li>不知道网关路由器mac地址，ARP广播报文查询</li><li>获取mac地址后发送DNS解析帧通过RIP，OSPF，或者IS-IS或者域间协议BGP将报文请求，获取ip</li><li>获取ip后tcp三次握手</li><li>http协议</li></ol><p>在浏览器输入网址后，首先要经过<strong>域名解析</strong>。通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p>为了查找DNS记录，浏览器会检查四个缓存。<br>第一，检查浏览器缓存。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。<br>第二，浏览器检查操作系统缓存。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。<br>第三，检查路由器缓存。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。<br>第四，检查ISP缓存。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。<br>如果请求的URL不在缓存中，ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）<br>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈，生成HTTP 请求信息，<strong>封装成一个 HTTP 数据包。</strong><br>HTTP 底层是依赖 TCP&#x2F;IP 协议实现的，所以在底层数据传输时，会将 HTTP 请求包进一步<strong>封装成 TCP 数据包。</strong><br>打开⼀个socket与⽬标IP地址，端⼝<strong>建⽴TCP链接</strong>，三次握⼿如下：</p><ul><li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端口</li><li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li><li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z<br>TCP链接建⽴后浏览器<strong>向 web 服务器发送一个 HTTP 请求</strong><br>服务器端拿到了客户端的请求参数之后，会进行相应的业务处理，处理完成之后，再将处理的结果返回给客户端。返回的流程和发送的流程类似，先将结果封装成 HTTP 数据包</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http和https&quot;&gt;&lt;a href=&quot;#http和https&quot; class=&quot;headerlink&quot; title=&quot;http和https&quot;&gt;&lt;/a&gt;http和https&lt;/h1&gt;&lt;h2 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机通信与网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>new/delete  malloc/free</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-26T14:33:36.535Z</published>
    <updated>2023-08-05T06:29:47.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-x2F-delete-malloc-x2F-free"><a href="#new-x2F-delete-malloc-x2F-free" class="headerlink" title="new&#x2F;delete  malloc&#x2F;free"></a>new&#x2F;delete  malloc&#x2F;free</h1><h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><p>new操作针对数据类型的处理，分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要构造函数的类型）"><a href="#简单数据类型（-包括基本数据类型和不需要构造函数的类型）" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要构造函数的类型）"></a>简单数据类型（ 包括基本数据类型和不需要构造函数的类型）</h3><p>代码实例：</p><pre><code>int* p = new int;</code></pre><p>汇编码如下：</p><pre><code>int* p = new int;    00E54C44  push        4      00E54C46  call        operator new (0E51384h)      00E54C4B  add         esp,4  </code></pre><p>分析：传入4byte的参数后调用operator new。其源码如下：</p><pre><code>void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)&#123;           // try to allocate size bytes    void *p;    while ((p = malloc(size)) == 0)    &#123;        if (_callnewh(size) == 0)        &#123;       // report no memory                _THROW_NCEE(_XSTD bad_alloc, );        &#125;    &#125;    return (p);&#125;</code></pre><p>分析：调用malloc失败后会调用_callnewh。如果_callnewh返回0则抛出bac_alloc异常，返回非零则继续分配内存。<br>这个_callnewh是什么呢？它是一个new handler，通俗来讲就是new失败的时候调用的回调函数。可以通过_set_new_handler来设置。下面举个实例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;new.h&gt;int MyNewHandler(size_t size)&#123;    printf(&quot;Allocation failed.Try again&quot;);    return 1;//continue to allocate    //return 0;//stop allocating,throw bad_alloc&#125;void main()&#123;    // Set the failure handler for new to be MyNewHandler.    _set_new_handler(MyNewHandler);    while (1)    &#123;        int* p = new int[10000000];    &#125;&#125;</code></pre><p>在new基本数据类型的时候还可以指定初始化值，比如：</p><pre><code>int* p = new int(4);</code></pre><p>简单类型直接调用operator new分配内存；<br>可以通过new_handler来处理new失败的情况；<br>new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；</p><p>new[] 调用的是operator new[]，计算出数组总大小之后调用operator new。</p><h3 id="复杂数据类型（需要由构造函数初始化对象）"><a href="#复杂数据类型（需要由构造函数初始化对象）" class="headerlink" title="复杂数据类型（需要由构造函数初始化对象）"></a>复杂数据类型（需要由构造函数初始化对象）</h3><p>例如：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object();&#125;</code></pre><p>汇编码如下：</p><pre><code>Object* p = new Object();    00AD7EDD  push        4      00AD7EDF  call        operator new (0AD1384h)      00AD7EE4  add         esp,4      00AD7EE7  mov         dword ptr [ebp-0E0h],eax      00AD7EED  mov         dword ptr [ebp-4],0      00AD7EF4  cmp         dword ptr [ebp-0E0h],0      00AD7EFB  je          main+70h (0AD7F10h)      00AD7EFD  mov         ecx,dword ptr [ebp-0E0h]      00AD7F03  call        Object::Object (0AD1433h)        //在new的地址上调用构造函数    00AD7F08  mov         dword ptr [ebp-0F4h],eax      00AD7F0E  jmp         main+7Ah (0AD7F1Ah)      00AD7F10  mov         dword ptr [ebp-0F4h],0      00AD7F1A  mov         eax,dword ptr [ebp-0F4h]      00AD7F20  mov         dword ptr [ebp-0ECh],eax      00AD7F26  mov         dword ptr [ebp-4],0FFFFFFFFh      00AD7F2D  mov         ecx,dword ptr [ebp-0ECh]      00AD7F33  mov         dword ptr [p],ecx  </code></pre><p>new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。</p><p>针对复杂类型，new[]会额外存储数组大小。</p><h2 id="delete的实现"><a href="#delete的实现" class="headerlink" title="delete的实现"></a>delete的实现</h2><p>delete也分为两种情况：</p><h3 id="简单数据类型（-包括基本数据类型和不需要析构函数的类型）。"><a href="#简单数据类型（-包括基本数据类型和不需要析构函数的类型）。" class="headerlink" title="简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。"></a>简单数据类型（ 包括基本数据类型和不需要析构函数的类型）。</h3><pre><code>int *p = new int(1);delete p;</code></pre><p>delete的汇编码如下：</p><pre><code>    delete p;00275314  mov         eax,dword ptr [p]  00275317  mov         dword ptr [ebp-0D4h],eax  0027531D  mov         ecx,dword ptr [ebp-0D4h]  00275323  push        ecx  00275324  call        operator delete (0271127h) </code></pre><p>分析：传入参数p之后调用operator delete，其源码如下：</p><pre><code>void operator delete( void * p )&#123;    RTCCALLBACK(_RTC_Free_hook, (p, 0));    free( p );&#125;</code></pre><p>RTCCALLBACK默认是空的宏定义，所以这个函数默认情况下就是简单的调用free函数。<br>delete简单数据类型默认只是调用free函数。</p><p>针对简单类型，delete和delete[]等同。</p><h3 id="复杂数据类型（需要由析构函数销毁对象）"><a href="#复杂数据类型（需要由析构函数销毁对象）" class="headerlink" title="复杂数据类型（需要由析构函数销毁对象）"></a>复杂数据类型（需要由析构函数销毁对象）</h3><p>代码实例：</p><pre><code>class Object&#123;public:    Object()    &#123;        _val = 1;    &#125;    ~Object()    &#123;        cout &lt;&lt; &quot;destroy object&quot; &lt;&lt; endl;    &#125;private:    int _val;&#125;;void main()&#123;    Object* p = new Object;    delete p;&#125;</code></pre><p>部分汇编码如下：</p><pre><code>012241F0  mov         dword ptr [this],ecx  012241F3  mov         ecx,dword ptr [this]  012241F6  call        Object::~Object (0122111Dh)     //先调用析构函数012241FB  mov         eax,dword ptr [ebp+8]  012241FE  and         eax,1  01224201  je          Object::`scalar deleting destructor&#39;+3Fh (0122420Fh)  01224203  mov         eax,dword ptr [this]  01224206  push        eax  01224207  call        operator delete (01221145h)  0122420C  add         esp,4 </code></pre><p>delete复杂数据类型先调用析构函数再调用operator delete。</p><p>释放内存之前会先调用每个对象的析构函数。<br>new[]分配的内存只能由delete[]释放。如果由delete释放会崩溃，为什么会崩溃呢？<br>假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。<br>总结：<br>针对复杂类型，new[]出来的内存只能由delete[]释放。</p><h2 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h2><p>1）plain new（默认new） 2）nothrow new（不抛异常的new） 3）placement new（放置new）</p><h3 id="plain-new-和-nothrow-new"><a href="#plain-new-和-nothrow-new" class="headerlink" title="plain new 和 nothrow new"></a>plain new 和 nothrow new</h3><p>默认的new和nothrow new用法上差不多，只不过是返回值上面的区别</p><p>默认的new在分配失败的时候会抛出异常，而非返回NULL<br>但是nothrow new在分配失败的时候会返回NULL，而不是异常</p><p>下面这个例子，我们一开始先用默认的new，不断要求分配一个内存空间，为了节省时间，可以要求分配的内存空间很大，比较容易达到“无法再分配的状态”。</p><p>当无法再继续分配的时候，new就会抛出异常“std::bad_alloc”</p><p>nothrow new，这时候已经是“无法再分配”，所以直接就会使得nothrow new失败，但是nothrow new返回的是NULL，我们可以验证一下</p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;int main()&#123;    try &#123;        while (true) &#123;            new int[100000000ul];   // throwing overload        &#125;    &#125; catch (const std::bad_alloc&amp; e) &#123;        std::cout &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;    &#125;    while (true) &#123;        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload        if (p == nullptr) &#123;            std::cout &lt;&lt; &quot;Allocation returned nullptr\n&quot;;            break;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>std::bad_allocAllocation returned nullptr</code></pre><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>该运算符用于在已分配的内存上重新构造对象,因为不分配内存，所以也不用担心分配失败<br>我们可以验证一下，我们先分配一块内存并存储数据，然后我们再在这同一块内存中申请一个相同的对象（其他对象也可以，不过要比原先申请的空间小），给新对象赋一个不同的数据，查看最后内存的数据是什么</p><pre><code>// C++ program to illustrate the placement new operator#include&lt;iostream&gt;using namespace std;int main()&#123;    // initial value of X    int X = 10;    cout &lt;&lt; &quot;Before placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    // Placement new changes the value of X to 100    int *mem = new (&amp;X) int(100);    cout &lt;&lt; &quot;\nAfter placement new :&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;X : &quot; &lt;&lt; X &lt;&lt; endl;    cout &lt;&lt; &quot;mem : &quot; &lt;&lt; mem &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;X : &quot; &lt;&lt; &amp;X &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code>Before placement new :X : 10&amp;X : 0x7fff71ce8bfcAfter placement new :X : 100 mem : 0x7fff71ce8bfc&amp;X : 0x7fff71ce8bfc</code></pre><p>解释一下，就是一开始内存地址为”0x7fff71ce8bfc”,数据为“10”</p><p>然后进行了palcement new以后，new的内存空间还是原来的内存空间，数据变成了“100”</p><h2 id="new-x2F-delete-和-malloc-x2F-free的区别"><a href="#new-x2F-delete-和-malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free的区别"></a>new&#x2F;delete 和 malloc&#x2F;free的区别</h2><h3 id="引入上"><a href="#引入上" class="headerlink" title="引入上"></a>引入上</h3><p>new&#x2F;delete：这两个是C++中的关键字，若要使用，需要编译器支持；<br>malloc&#x2F;free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。</p><h3 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h3><p>malloc：申请空间需要显式填入申请内存的大小；<br>new：无需显式填入申请的内存大小，new会根据new的类型分配内存。</p><h3 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h3><p>new：申请的内存空间在自由存储区</p><p>malloc：申请的内存空间在堆</p><p>自由存储区：默认是堆，也可以通过自己实现，使得为进程中的其他区域</p><h3 id="是否可以重载"><a href="#是否可以重载" class="headerlink" title="是否可以重载"></a>是否可以重载</h3><p>在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等<br>而malloc和free是C里的库函数，无法对其进行重载。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br>malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。</p><p>malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；<br>new内存分配失败时，会抛出bac_alloc异常，</p><h3 id="对数组的处理"><a href="#对数组的处理" class="headerlink" title="对数组的处理"></a>对数组的处理</h3><p>使用new操作符来分配对象内存时会调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。运行相应的构造函数以构造对象，并为其传入初值，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会调用对象的析构函数，调用operator delete(或operator delete[])函数释放内存空间。</p><p>malloc：和非数组数据的内存分配没有区别<br>free：和非数组数据的的内存释放没有区别</p><p>free怎么知道要释放多大的内存空间？<br>malloc分配空间时，可以理解成整个内存空间分成两块<br>一块在首地址，记录内存的大小的。一块就是你指定大小的内存空间</p><h3 id="是否可以扩展内存空间"><a href="#是否可以扩展内存空间" class="headerlink" title="是否可以扩展内存空间"></a>是否可以扩展内存空间</h3><p>new：不行<br>malloc：可以</p><p>使用malloc分配的空间可以使用realloc函数对其进行内存的扩展</p><p>realloc先判断当前指针指向的内存空间是否有足够的连续空间支持扩展，如果有，直接原地扩展，并且返回原来地址的指针；如果没有，按照新指定的内存空间大小，开辟一块新的内存空间，然后把旧内存空间的数据复制过去，然后释放旧内存空间，返回新内存空间的指针</p><h2 id="既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？"><a href="#既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？" class="headerlink" title="既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h2><p>malloc&#x2F;free适用于： 简单的数据类型（int，char等），这些数据在定义的时候没有构造函数和析构函数，就无须使用new&#x2F;delete，只用简单分配空间和释放空间即可</p><p>new&#x2F;delete适用于： 自定义的类，这些数据在定义的时候往往需要调用构造函数初始化，释放的时候需要调用析构函数。这时简单的内存分配和内存释放无法满足需求，所以这时就需要new和delete</p><h2 id="Malloc函数的线程安全"><a href="#Malloc函数的线程安全" class="headerlink" title="Malloc函数的线程安全"></a>Malloc函数的线程安全</h2><p>malloc函数线程安全但是不可重入的，因为malloc函数在用户空间要自己管理各进程共享的内存链表，由于有共享资源访问，本身会造成线程不安全。为了做到线程安全，需要加锁进行保护。同时这个锁必须是递归锁，因为如果当程序调用malloc函数时收到信号，在信号处理函数里再调用malloc函数，如果使用一般的锁就会造成死锁（信号处理函数中断了原程序的执行），所以要使用递归锁。<br>一个函数要做到可重入，需要不在函数内部使用静态或全局数据，不返回静态或全局数据，也不调用不可重入函数。</p><h2 id="被free回收的内存怎么处理？"><a href="#被free回收的内存怎么处理？" class="headerlink" title="被free回收的内存怎么处理？"></a>被free回收的内存怎么处理？</h2><p>会被统一管理起来，而不是归还给操作系统</p><p>这些内存空间会被一条双链表连接起来，这样下一次需要分配内存空间的时候，就可以先在这里面找是否合适的内存，合适就直接使用；如果所需内存比这里的内存空间都要大，那么再去重新向系统申请一块内存空间</p><p>这样统一管理，不立即归还给操作系统的好处是避免每次free都要进行系统调用；而且避免返回给操作系统很多小的碎片，难以管理；</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载operator new<br>因为new是关键字，我们本应该无法修改new分配内存的方式。由于new在分配内存时，调用operator new。所以重载operator new就可以修改分配内存的方式了。</p><pre><code>class Foo &#123;public:    Foo() &#123; std::cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; std::endl; &#125;    virtual ~Foo() &#123; std::cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; std::endl; &#125;    void* operator new(std::size_t size)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new(std::size_t size, int num)    &#123;        std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;num is &quot; &lt;&lt; num &lt;&lt; std::endl;        return std::malloc(size);    &#125;    void* operator new (std::size_t size, void* p)    &#123;        std::cout &lt;&lt; &quot;placement new&quot; &lt;&lt; std::endl;        return p;    &#125;    void operator delete(void* ptr)    &#123;        std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Foo* m = new(100) Foo;    Foo* m2 = new(m) Foo;    std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;    //delete m2;    delete m;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;new-x2F-delete-malloc-x2F-free&quot;&gt;&lt;a href=&quot;#new-x2F-delete-malloc-x2F-free&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete  malloc&amp;#x2F;fre</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://example.com/p/80c02825.html"/>
    <id>http://example.com/p/80c02825.html</id>
    <published>2023-07-25T13:57:23.617Z</published>
    <updated>2023-08-06T13:40:42.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>局部static是线程安全的，可以用来实现单例模式</p><h2 id="面向过程设计中的static"><a href="#面向过程设计中的static" class="headerlink" title="面向过程设计中的static"></a>面向过程设计中的static</h2><p>全局变量、静态变量和类的静态成员变量在main执行之前初始化；局部静态变量在第一次使用时初始化。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。                         </p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的，不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，该变量的值不会因为函数终止而丢失，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><p>修饰函数时，表明该函数只在同一文件中调用。</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突；</li></ul><h2 id="面向对象的static关键字"><a href="#面向对象的static关键字" class="headerlink" title="面向对象的static关键字"></a>面向对象的static关键字</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。</li><li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>用static修饰不访问非静态数据成员的类成员函数。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。</p><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p><strong>在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗。</strong></p><p>答：可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件中，这个static变量将在各个cpp文件中将是独立的，彼此修改不会对相互有影响。</p><p><strong>为什么静态成员函数不能申明为const</strong></p><p>答：这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。<span style="line-height:26px">一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了</span></p><p><strong>为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义</strong><br>答：因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p><strong>static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中。</strong><br>如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。</p><p><strong>为什么常量静态成员数据的初始化可以放在类内（注意：只有静态常量整型数据成员才可以在类中初始化）</strong></p><p>答：是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’&#x3D;’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p><p><strong>为什么静态成员函数只能访问静态成员变量。</strong></p><p>1.静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的<br>2.非静态成员当且仅当实例化对象之后才存在，静态成员函数产生在前，非静态成员函数产生在后，故不能访问<br>3.访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</p><p><strong>静态成员函数与非静态成员函数的区别</strong><br>根本区别：静态成员函数不存在this指针，不能访问非静态成员变量。</p><p><strong>为什么要用静态成员变量和静态成员函数</strong><br>为了实现共享。因为静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享</p><p><strong>静态成员的作用、优点</strong><br>静态成员函数主要为了调用方便，不需要生成对象就能调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;p&gt;局部static是线程安全的，可以用来实现单例模式&lt;/p&gt;
&lt;h2 id=&quot;面向过程设计中的static&quot;&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>字节提前批</title>
    <link href="http://example.com/p/7d1900d6.html"/>
    <id>http://example.com/p/7d1900d6.html</id>
    <published>2023-07-24T13:41:49.500Z</published>
    <updated>2023-08-06T07:11:00.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP怎么建立连接"><a href="#TCP怎么建立连接" class="headerlink" title="TCP怎么建立连接"></a>TCP怎么建立连接</h3><h3 id="有抓过包吗-（无）"><a href="#有抓过包吗-（无）" class="headerlink" title="有抓过包吗 （无）"></a>有抓过包吗 （无）</h3><h3 id="TCP的可靠性怎么保证"><a href="#TCP的可靠性怎么保证" class="headerlink" title="TCP的可靠性怎么保证"></a>TCP的可靠性怎么保证</h3><h3 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理（寄）</h3><h3 id="聊天室是怎么做的，以及一些地方的实现"><a href="#聊天室是怎么做的，以及一些地方的实现" class="headerlink" title="聊天室是怎么做的，以及一些地方的实现"></a>聊天室是怎么做的，以及一些地方的实现</h3><h3 id="用户密码明文存吗"><a href="#用户密码明文存吗" class="headerlink" title="用户密码明文存吗"></a>用户密码明文存吗</h3><h3 id="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"><a href="#因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施" class="headerlink" title="因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施"></a>因为提到日志，日志系统怎么做的，如果系统宕机了能否正常写，有什么解决措施</h3><h3 id="TCP和UDP的区别，TCP为什么能保证可靠传输"><a href="#TCP和UDP的区别，TCP为什么能保证可靠传输" class="headerlink" title="TCP和UDP的区别，TCP为什么能保证可靠传输"></a>TCP和UDP的区别，TCP为什么能保证可靠传输</h3><h3 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h3><h3 id="HTTP长连接怎么保活"><a href="#HTTP长连接怎么保活" class="headerlink" title="HTTP长连接怎么保活"></a>HTTP长连接怎么保活</h3><h3 id="输入一个网址到查看到信息，中间的过程"><a href="#输入一个网址到查看到信息，中间的过程" class="headerlink" title="输入一个网址到查看到信息，中间的过程"></a>输入一个网址到查看到信息，中间的过程</h3><h3 id="讲一下什么是IO多路复用"><a href="#讲一下什么是IO多路复用" class="headerlink" title="讲一下什么是IO多路复用"></a>讲一下什么是IO多路复用</h3><h3 id="讲一讲select、poll和epoll的区别"><a href="#讲一讲select、poll和epoll的区别" class="headerlink" title="讲一讲select、poll和epoll的区别"></a>讲一讲select、poll和epoll的区别</h3><h3 id="socket通讯的流程，深入到kernel层面"><a href="#socket通讯的流程，深入到kernel层面" class="headerlink" title="socket通讯的流程，深入到kernel层面"></a>socket通讯的流程，深入到kernel层面</h3><h3 id="poll，select，epoll-ET-x2F-LT"><a href="#poll，select，epoll-ET-x2F-LT" class="headerlink" title="poll，select，epoll,ET&#x2F;LT"></a>poll，select，epoll,ET&#x2F;LT</h3><h3 id="docker里能bind-CPU-是真的bind吗"><a href="#docker里能bind-CPU-是真的bind吗" class="headerlink" title="docker里能bind CPU,是真的bind吗"></a>docker里能bind CPU,是真的bind吗</h3><h3 id="Http框架构成。"><a href="#Http框架构成。" class="headerlink" title="Http框架构成。"></a>Http框架构成。</h3><h3 id="Http和RPC区别。"><a href="#Http和RPC区别。" class="headerlink" title="Http和RPC区别。"></a>Http和RPC区别。</h3><h3 id="RPC的优势。"><a href="#RPC的优势。" class="headerlink" title="RPC的优势。"></a>RPC的优势。</h3><p>14 算法题：给一个二叉树，输出二叉树的左视图，所谓左视图就是每一层最左边的节点</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux命令用过哪些"><a href="#linux命令用过哪些" class="headerlink" title="linux命令用过哪些"></a>linux命令用过哪些</h3><h3 id="死锁怎么产生"><a href="#死锁怎么产生" class="headerlink" title="死锁怎么产生"></a>死锁怎么产生</h3><h3 id="怎么避免死锁"><a href="#怎么避免死锁" class="headerlink" title="怎么避免死锁"></a>怎么避免死锁</h3><h3 id="操作系统中内核态和用户态的区别，分别干什么"><a href="#操作系统中内核态和用户态的区别，分别干什么" class="headerlink" title="操作系统中内核态和用户态的区别，分别干什么"></a>操作系统中内核态和用户态的区别，分别干什么</h3><h3 id="敲键盘发生的中断"><a href="#敲键盘发生的中断" class="headerlink" title="敲键盘发生的中断"></a>敲键盘发生的中断</h3><h3 id="Linux里kernel里的buffer如何通知user的"><a href="#Linux里kernel里的buffer如何通知user的" class="headerlink" title="Linux里kernel里的buffer如何通知user的"></a>Linux里kernel里的buffer如何通知user的</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL的隔离级别有哪几种"><a href="#MySQL的隔离级别有哪几种" class="headerlink" title="MySQL的隔离级别有哪几种"></a>MySQL的隔离级别有哪几种</h3><h3 id="脏读和幻读分别是什么"><a href="#脏读和幻读分别是什么" class="headerlink" title="脏读和幻读分别是什么"></a>脏读和幻读分别是什么</h3><h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><h3 id="小于n的最大数（寄）"><a href="#小于n的最大数（寄）" class="headerlink" title="小于n的最大数（寄）"></a>小于n的最大数（寄）</h3><p>给一个数n，一个数组A，返回由A中元素组成的小于n的最大数<br>如n&#x3D;23121，A&#x3D;{2,4,9| 返回22999<br>n&#x3D;23121 A&#x3D;{9} 返回9999<br>n&#x3D;23333 A&#x3D;{2,3} 返回23332<br>n&#x3D;2222 A&#x3D;{2} 返回222<br>n&#x3D;2 A&#x3D;{2} 无解</p><h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><h3 id="最长连续递增子序列长度"><a href="#最长连续递增子序列长度" class="headerlink" title="最长连续递增子序列长度"></a>最长连续递增子序列长度</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就2，4或3，8，最长长度为2<br>设数组dp[i]，表示以i为结尾的最长连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，1，1，2，1，2}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[6] = &#123;1,5,2,4,3,8&#125;;    int dp[6];    dp[0] = 1;    for(int i=1;i&lt;6;i++)&#123;        dp[i] = 1;        if(Array[i] &gt; Array[i-1])&#123;            dp[i] = dp[i-1] + 1;        &#125;    &#125;    for(int i=0;i&lt;6;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre><h3 id="最长不连续递增子序列"><a href="#最长不连续递增子序列" class="headerlink" title="最长不连续递增子序列"></a>最长不连续递增子序列</h3><p>例如：Array[6] &#x3D; {1，5，2，4，3，8}<br>其最长连续递增子序列就1，2，418或1，2，3，8，最长长度为4<br>设数组dp[i]，表示以i为结尾的最长不连续子序列长度，即上述数组的dp数组即为<br>dp[6] &#x3D; {1，2，2，3，3，4}<br>代码如下</p><pre><code>#include&lt;iostream&gt;using namespace std;int main()&#123;    int Array[10] = &#123;1,5,2,4,3,8,7,2,9,10&#125;;    int dp[10];    dp[0]=1;    for(int i=1;i&lt;10;i++)&#123;        dp[i] = 1;        for(int j=i-1;j&gt;=0;j--)&#123;            if(Array[i]&gt;Array[j])&#123;                dp[i] = max(dp[i],dp[j]+1);            &#125;        &#125;    &#125;    for(int i=0;i&lt;10;i++)        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h2&gt;&lt;h3 id=&quot;TCP怎么建立连接&quot;&gt;&lt;a href=&quot;#TCP怎么建立连接&quot; class=&quot;headerlink&quot; title=&quot;TCP怎么建立</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
</feed>
