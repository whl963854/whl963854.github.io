<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-29T10:01:15.251Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>goroutine</title>
    <link href="http://example.com/p/15a4d7c.html"/>
    <id>http://example.com/p/15a4d7c.html</id>
    <published>2023-12-28T08:35:00.621Z</published>
    <updated>2023-12-29T10:01:15.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="goroutine是什么？"><a href="#goroutine是什么？" class="headerlink" title="goroutine是什么？"></a>goroutine是什么？</h2><p>官方的给出的定义是一个并发逻辑块，我们可以用一个函数和一个关键字创建它。</p><pre><code>// 非匿名func main() &#123;    go sayHello()    // continue doing other things&#125;func sayHello() &#123;    fmt.Println(&quot;hello&quot;)&#125;// 匿名go func() &#123;    fmt.Println(&quot;hello&quot;)&#125;()// 1// continue doing other things</code></pre><p>从go的整体运行框架中可以看出goroutine并不属于一个操作系统线程，也不属于go语言运行时管理的线程，它在go语言执行框架之内是线程的高级抽象——协程。<br>协程是非抢占式的并发子程序，换句话说，无法被中断。<br>协程拥有自身的资源同时共享线程的资源。<br>协程自身无法独立运行必须依托于线程。</p><p>go通过一个M:N调度器实现运行，也就是go的一个核心思想线程复用。</p><h2 id="goroutine的闭包"><a href="#goroutine的闭包" class="headerlink" title="goroutine的闭包"></a>goroutine的闭包</h2><p>一般会在main函数中暂停几秒来使得goroutine得以运行。</p><pre><code>sayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;go sayHello()time.Sleep(time.Second)</code></pre><p>这是因为goroutine是独立于main的一个协程，而goroutine的运行管理是交给go的runtime来负责的，我们无法得知goroutine何时会运行，通过暂停几秒钟本质是并不是给与goroutine启动的时间，而是提高runtime调用goroutine的机会，这种方式并不能保证goroutine一定会启动。<br>如果想要确保goroutine一定会启动，需要在main和goroutine之间建立一种同步机制，保证在main的执行过程中一定会等待goroutine的调用完成。</p><pre><code>var wg sync.WaitGroupsayHello := func() &#123;    defer wg.Done()    fmt.Println(&quot;hello&quot;)&#125;wg.Add(1)go sayHello()wg.Wait() //1</code></pre><p>goroutine拥有独立的资源空间，来满足其运行时需要的全部条件，也正是利用了这种机制go才可以实现线程这种珍贵资源的复用，但是在某些情况下，我们需要在一个goroutine调用另一个goroutine的资源，而goroutine之间都是独立运行的，如何确保资源的安全性。</p><pre><code>var wg sync.WaitGroupsalutation := &quot;hello&quot;wg.Add(1)go func() &#123;    defer wg.Done()    salutation = &quot;welcome&quot; // 1&#125;()wg.Wait()fmt.Println(salutation)</code></pre><p>上面的例子在实际的运行过程中不会出现hello被打印的情况，原因在于goroutine对main的资源进行了访问并修改。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func() &#123;        defer wg.Done()        fmt.Println(salutation) // 1    &#125;()&#125;wg.Wait()</code></pre><p>这种情况下goroutine会输出什么？<br>答案是3个good day。很奇怪不是吗？</p><p>是什么原因导致这个奇怪的现象出现？<br>我们回顾goroutine的定义，一个并发逻辑块，我们并不知道它会何时运行，在上面的例子中我们通过同步机制，确保了在main运行的期间goroutine一定会启动运行，但是仍然无法确保goroutine何时运行。<br>那么问题就迎刃而解了，for循环的执行在goroutine运行之前执行完，go为通过代码检查将salutation转移到堆中，并保存对字符串切片“good day”中最后一个值的引用。</p><p>通过上面的两个例子可以看出，因为goroutine具有独立逻辑，当一个goroutine访问另一个goroutine的资源时，是极度不安全的，资源不确定性无限放大。</p><p>如何正确的访问goroutine资源呢，确保安全性？<br>答案很简单：闭包。<br>闭包这个词用人话说就是将资源复制一份给goroutine，使得goroutine不用访问另一个goroutine的资源，实现资源的封闭。<br>再通俗一点就是，给你一份，你用你的，我用我的。<br>在程序的执行方式就是传递参数。</p><pre><code>var wg sync.WaitGroupfor _, salutation := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;    wg.Add(1)    go func(salutation string) &#123; // 1        defer wg.Done()        fmt.Println(salutation)    &#125;(salutation) // 2&#125;wg.Wait()</code></pre><p>不过需要注意go的传递是值传递，并且包含指针，闭包的概念对于指针类型的对象来说没用。</p><h2 id="goroutine的大小"><a href="#goroutine的大小" class="headerlink" title="goroutine的大小"></a>goroutine的大小</h2><p>goroutine在官方中还有一个一直被人津津乐道的一个地方，轻巧，占用空间很小，大约几KB</p><pre><code>memConsumed := func() uint64 &#123;    runtime.GC()    var s runtime.MemStats    runtime.ReadMemStats(&amp;s)    return s.Sys&#125;var c &lt;-chan interface&#123;&#125;var wg sync.WaitGroupnoop := func() &#123; wg.Done(); &lt;-c &#125; // 1const numGoroutines = 1e4 // 2wg.Add(numGoroutines)before := memConsumed() // 3for i := numGoroutines; i &gt; 0; i-- &#123;    go noop()&#125;wg.Wait()after := memConsumed() // 4fmt.Printf(&quot;%.3fkb&quot;, float64(after-before)/numGoroutines/1000)</code></pre><p>9.291kb<br>PASS</p><p>测试一下上下文切换</p><pre><code>func BenchmarkContextSwitch(b *testing.B) &#123;var wg sync.WaitGroupbegin := make(chan struct&#123;&#125;)c := make(chan struct&#123;&#125;)var token struct&#123;&#125;sender := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        c &lt;- token //2    &#125;&#125;receiver := func() &#123;    defer wg.Done()    &lt;-begin //1    for i := 0; i &lt; b.N; i++ &#123;        &lt;-c //3    &#125;&#125;wg.Add(2)go sender()go receiver()b.StartTimer() //4close(begin)   //5wg.Wait()&#125;</code></pre><p>结果如下：</p><pre><code>goos: windowsgoarch: amd64pkg: concurrency_mode/pipelinecpu: Intel(R) Core(TM) i5-10500 CPU @ 3.10GHzBenchmarkContextSwitch-12         4074472           293.5 ns/opPASS</code></pre><h2 id="goroutine的内存泄露"><a href="#goroutine的内存泄露" class="headerlink" title="goroutine的内存泄露"></a>goroutine的内存泄露</h2><p>goroutine虽然很牛逼，但是作为独立的线程如果不进行恰当的控制，会面对很严重泄露问题</p><p>goroutine的内存泄露一般由于程序不能正常结束所导致<br>• 死循环<br>• 阻塞等待</p><p>死循环</p><pre><code>go func() &#123;// &lt;操作会在这里永久阻塞&gt;    for&#123;    &#125;&#125;()// Do work</code></pre><p>破除死循环的最好方式就是告诉goroutine如何结束<br>• 定义退出逻辑<br>• 信号通知</p><p>阻塞等待<br>阻塞等待的情况有两种<br>go的经典语句“不要通过共享内存来通信，而应该通过通信来共享内存”<br>正因为如此<br>通道被广泛使用到各种场景，而通道阻塞是goroutine内存泄漏面临的一个大问题</p><p>通道分为进和出<br>当通道无法出时会进入阻塞状态，需要等待通道进数据</p><pre><code>doWork := func(strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123;    completed := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(completed)        for s := range strings &#123;            fmt.Println(s)        &#125;    &#125;()    return completed&#125;doWork(nil)// 这里还有其他任务执行fmt.Println(&quot;Done.&quot;)</code></pre><p>结果</p><pre><code>Done.PASS</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>doWork := func(done &lt;-chan interface&#123;&#125;, strings &lt;-chan string) &lt;-chan interface&#123;&#125; &#123; //1    terminated := make(chan interface&#123;&#125;)    go func() &#123;        defer fmt.Println(&quot;doWork exited.&quot;)        defer close(terminated)        for &#123;            select &#123;            case s := &lt;-strings:                // Do something interesting                fmt.Println(s)            case &lt;-done: //2                return            &#125;        &#125;    &#125;()    return terminated&#125;done := make(chan interface&#123;&#125;)terminated := doWork(done, nil)go func() &#123; //3    // Cancel the operation after 1 second.    time.Sleep(1 * time.Second)    fmt.Println(&quot;Canceling doWork goroutine...&quot;)    close(done)&#125;()&lt;-terminated //4fmt.Println(&quot;Done.&quot;)</code></pre><p>结果如下：</p><pre><code>Canceling doWork goroutine...doWork exited.Done.PASS</code></pre><p>当通道无法进时会进入阻塞状态，需要等待通道出数据</p><pre><code>newRandStream := func() &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;) // 1        defer close(randStream)        for &#123;            randStream &lt;- rand.Int()        &#125;    &#125;()    return randStream&#125;randStream := newRandStream()fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;</code></pre><p>结果如下：</p><pre><code>3 random ints:1: 86597149668366241682: 35918201309525418263: 2839916754701944393</code></pre><p>解决办法，告诉通道何时结束<br>使用信号量</p><pre><code>newRandStream := func(done &lt;-chan interface&#123;&#125;) &lt;-chan int &#123;    randStream := make(chan int)    go func() &#123;        defer fmt.Println(&quot;newRandStream closure exited.&quot;)        defer close(randStream)        for &#123;            select &#123;            case randStream &lt;- rand.Int():            case &lt;-done:                return            &#125;        &#125;    &#125;()    return randStream&#125;done := make(chan interface&#123;&#125;)randStream := newRandStream(done)fmt.Println(&quot;3 random ints:&quot;)for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;%d: %d\n&quot;, i, &lt;-randStream)&#125;close(done)//模拟正在进行的工作time.Sleep(1 * time.Second)</code></pre><p>这样就可以了</p><pre><code>3 random ints:1: 83955671426514482052: 84217454730047417783: 7407000177342364812newRandStream closure exited.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a href=&quot;#goroutine&quot; class=&quot;headerlink&quot; title=&quot;goroutine&quot;&gt;&lt;/a&gt;goroutine&lt;/h1&gt;&lt;h2 id=&quot;goroutine是什么？&quot;&gt;&lt;a href=&quot;#goroutine是什么</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mod</title>
    <link href="http://example.com/p/17f45348.html"/>
    <id>http://example.com/p/17f45348.html</id>
    <published>2023-12-28T08:32:20.246Z</published>
    <updated>2023-12-29T10:01:15.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h1><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>go 1.11 (2018-08-24)开始支持gomod的方式去管理包的依赖<br>具体的发行说明参考官方链接：<a href="https://go.dev/doc/go1.11">https://go.dev/doc/go1.11</a> [所有版本的发行说明：<a href="https://go.dev/doc/devel/release]">https://go.dev/doc/devel/release]</a></p><p>Q: GOPATH方式存在的问题？<br>A今天go get pkg1 commit了提交，第二天pkg1更新了，B去clone A的项目执行go get pkg1，此时pkg1变化了<br>同一个包，不同项目无法引用不同版本<br>vendor目录，git上传整份代码，git库体积过大，升级包时，文件太多，MR review不友好</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="GO111MODULE变量"><a href="#GO111MODULE变量" class="headerlink" title="GO111MODULE变量"></a>GO111MODULE变量</h3><p>go1.16 GO111MODULE默认值是on，并且增加了retract功能（版本撤回）</p><h3 id="go-mod常用操作命令"><a href="#go-mod常用操作命令" class="headerlink" title="go mod常用操作命令"></a>go mod常用操作命令</h3><p>用go mod初始化一个新项目</p><pre><code>mkdir democd demogo mod init demogo: creating new go.mod: module demo</code></pre><p>添加一个依赖包</p><pre><code>// 根据commit id添加依赖包的方式go get github.com/golang/groupcache@41bb18b</code></pre><p>此时，go.mod里会记录好依赖包，和对应的版本名</p><p>go.mod里出现的关键字<br>• module - go mod init指令定义的库名<br>• go - 要求go语言的最低版本，会影响到后面依赖库的下载<br>• require - 必备库，也就是代码中直接import的部分<br>• indirect：间接依赖，即A -&gt; B -&gt; C时，A就是间接依赖C了<br>• replace - 替换库，在重构时挺好用（比如某个开源组件有问题，内部fork了一版，直接replace即可）<br>• retract 撤回版本，告诉调用本库的项目，部分版本有严重问题、不要引用</p><p>根据go.mod下载依赖包</p><pre><code>go mod download</code></pre><p>清理下载好的go pkg缓存</p><pre><code>go clean -modcache</code></pre><p>清理go.mod不在使用的依赖</p><pre><code>go mod tidy</code></pre><p>将gomod项目依赖包存放到vendor目录，以便在离线环境下使用GOPATH方式编译</p><pre><code>go mod vendor</code></pre><p>查看一个包是怎么被引用的</p><pre><code>go mod why $&#123;pkg&#125;</code></pre><p>替换一个包</p><p>go mod edit -replace wps.cn&#x2F;lib&#x3D;ksogit.kingsoft.net&#x2F;wps-zhiliao&#x2F;backend&#x2F;<a href="mailto:&#x6c;&#105;&#98;&#x2e;&#103;&#105;&#x74;&#x40;&#x76;&#48;&#x2e;&#x30;&#x2e;&#50;&#45;&#x70;&#x72;&#101;&#x70;">&#x6c;&#105;&#98;&#x2e;&#103;&#105;&#x74;&#x40;&#x76;&#48;&#x2e;&#x30;&#x2e;&#50;&#45;&#x70;&#x72;&#101;&#x70;</a></p><h2 id="go-mod版本格式"><a href="#go-mod版本格式" class="headerlink" title="go mod版本格式"></a>go mod版本格式</h2><p><a href="https://go.dev/doc/modules/version-numbers">https://go.dev/doc/modules/version-numbers</a><br><a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a> 译文</p><p>格式：</p><pre><code>第一种：v大版本.&#123;功能版本&#125;.$&#123;fix版本&#125;。例如：v1.0.0第二种：v大版本.&#123;功能版本&#125;.fix版本−&#123;预发行版本&#125;。例如：v1.0.0-rc.1，v1.0.0-pre，v8.0.0-alpha.0，v1.0.0-分支名.$&#123;整型序号&#125;【目前采用】第三种：v0.0.0-yyyyMMddHHmmss-$&#123;commitId&#125;然后我们要给对应的稳定代码版本打上tag，项目go get时，可以指定对应的版本。同时打tag的好处可以针对引用库的改动做发行说明，留底方便作兼容性记录，为后续问题排查提供依据。大版本号可以用来做重构以确保一个项目里，可以同时存在v1,v2这种情况的引用链。mainpkgApkgX@v1pkgBpkgX@v2</code></pre><p>这样保证了，pkgA,pkgB可以同时存在，pkgX做了大版本升级，可能有功能是废弃的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mod&quot;&gt;&lt;a href=&quot;#mod&quot; class=&quot;headerlink&quot; title=&quot;mod&quot;&gt;&lt;/a&gt;mod&lt;/h1&gt;&lt;h2 id=&quot;发展历程&quot;&gt;&lt;a href=&quot;#发展历程&quot; class=&quot;headerlink&quot; title=&quot;发展历程&quot;&gt;&lt;/a&gt;发展历</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go泛型运用</title>
    <link href="http://example.com/p/f0317f09.html"/>
    <id>http://example.com/p/f0317f09.html</id>
    <published>2023-12-28T08:26:16.172Z</published>
    <updated>2023-12-29T10:01:15.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go泛型运用"><a href="#Go泛型运用" class="headerlink" title="Go泛型运用"></a>Go泛型运用</h1><h2 id="泛型起源"><a href="#泛型起源" class="headerlink" title="泛型起源"></a>泛型起源</h2><p>泛型编程是一种计算机编程风格，程序逻辑是根据参数指定的类型编写的，然后在调用时为作为参数提供的特定类型实例化。这种方法由1973年的ML编程语言开创，允许编写通用函数或类型，从而减少了代码重复。</p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>简而言之，类型做为参数。在Go语言语言中就是， 函数中携带泛型类型参数，接口&#x2F;结构体 支持泛型类型参数声明。</p><pre><code>func Add(a int, b int) int &#123;    return a + b&#125;func AddInt64(a int64, b int64) int64 &#123;    return a + b&#125;func Add[T int | int32 | int64 | float32 | float64](a T, b T) T &#123;    return a + b&#125;</code></pre><p>让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 泛型编程。</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>泛型能实现的功能通过接口+反射也基本能实现。但是使用过反射的人都知道反射机制有很多问题：</p><ul><li>用起来麻烦</li><li>失去了编译时的类型检查，不仔细写容易出错</li><li>性能不太理想</li></ul><h2 id="主流的泛型介绍"><a href="#主流的泛型介绍" class="headerlink" title="主流的泛型介绍"></a>主流的泛型介绍</h2><table><thead><tr><th>类型</th><th>实现原理</th><th>优点</th></tr></thead><tbody><tr><td>模板泛型</td><td>将代码中使用的每个类型编译成对应的类型的代码。</td><td>代码运行效率最高。</td></tr><tr><td>运行时泛型</td><td>编译时用占位符代替泛型参数，运行时由JIT编译成实际的类型。</td><td>编译时代码不膨胀，编译速度不受影响，经过JIT优化后性能几乎不受影响。</td></tr><tr><td>擦除泛型</td><td>编译时将类型擦除，统一转换为object或约束类。</td><td>实现简单。</td></tr><tr><td>动态语言泛型</td><td>依托编译器语法转换进行类型检查。</td><td>灵活，但具体性能和类型安全性取决于编译器。</td></tr></tbody></table><p>C#实现原理查看链接：SharpLab<br>JAVA实现原理链接：java泛型字节码</p><h2 id="Go泛型实现原理"><a href="#Go泛型实现原理" class="headerlink" title="Go泛型实现原理"></a>Go泛型实现原理</h2><p>go是基于模板的方案来实现泛型并做了改善</p><ul><li>为基础类型单独生成一份模板代码</li><li>非基础类型统一生成一个虚拟方法表，在运行时调用的时候通过虚拟方法表找到实际的类型</li></ul><h3 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h3><p>• 函数名后可以附带一个方括号，包含了该函数涉及的类型参数（Type Paramters）的列表：func F[T any](p T) { … }<br>• 这些类型参数可以在函数参数和函数体中（作为类型）被使用<br>• 自定义类型也可以有类型参数列表：type M[T any] []T<br>• 每个类型参数对应一个类型约束，上述的 any 就是预定义的匹配任意类型的约束<br>• 类型约束在语法上以 interface 的形式存在，在 interface 中嵌入类型 T 可以表示这个类型必须是 T:<br>• any\comparable\Ordered 约束类型</p><pre><code>type Integer interface &#123;    int ｜ int8 | int16 | int32 | int64&#125;type Integer1 interface &#123;    ~int ｜ ~int8&#125;</code></pre><h3 id="泛型反射"><a href="#泛型反射" class="headerlink" title="泛型反射"></a>泛型反射</h3><p>Go 1.18 版本并没有增加泛型相关的反射API，并且泛型是在编译期生成故推测Go不支持在运行时调用泛型方法&#x2F;函数. 这也是为什么Go方法不支持泛型原因之一</p><pre><code>func Test_Reflect3(t *testing.T) &#123;    myType := &amp;MyType[string]&#123;&quot;asd&quot;&#125;    mtV := reflect.ValueOf(&amp;myType).Elem()    params := make([]reflect.Value, 0)    params = append(params, reflect.ValueOf(&quot;OOOOOO&quot;))    mtV.MethodByName(&quot;Hello&quot;).Call(params)&#125;type MyType[T any] struct &#123;    name T&#125;func (mt *MyType[T]) Hello(show string) &#123;    println(mt.name, show)&#125;</code></pre><p>java 类型擦除式泛型，所以在运行是可通过反射插入不同类型的数据到泛型集合中</p><pre><code>List&lt;String&gt; strList=new ArrayList&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.add(&quot;sdadas&quot;);//但是通过反射方案可以实现插入数字    strList.add(123)</code></pre><p>C#是运行时泛型，所以反射时仍然可以做到类型检查</p><pre><code>var strList=new List&lt;String&gt;();//如果存放其他类型的对象时会出现编译错误strList.Add(&quot;sdadas&quot;);//反射插入数字时会报运行时错误    strList.add(123)//error</code></pre><h3 id="泛型运用"><a href="#泛型运用" class="headerlink" title="泛型运用"></a>泛型运用</h3><p>三元表达式</p><pre><code>func If[T any](flag bool, f1, f2 T) T &#123;    if flag &#123;        return f1    &#125;    return f2&#125;func IfFunc[T any](flag bool, f1, f2 func() T) T &#123;    if flag &#123;        return f1()    &#125;    return f2()&#125;//调用If(len(arr)&gt;0,arr[0],0)IfFunc(len(arr) &gt; 0 ,func()int64&#123;return arr[0]&#125;,0)</code></pre><p>泛型类型转换</p><pre><code>func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;//调用a := ToNumber[int](&quot;123&quot;)b := ToNumber[int64](&quot;123&quot;)c := ToNumber[float64](&quot;123&quot;)d := ToNumber[int32](&quot;123&quot;)</code></pre><p>linq 集合操作</p><pre><code>type Student struct &#123;    Id     int    Name   string    Age    int    Sex    bool    Score  int&#125;var list = []*Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;  </code></pre><p>a. 集合过滤</p><pre><code>//返回年龄大于19岁的学生res := linq.Where(list, func(s *Student) bool &#123; return s.Age &gt; 19 &#125;)    // Id: 3, Name: &quot;王五&quot;        </code></pre><p>b. 取第一个或者最后一个</p><pre><code>b := linq.First(list) //输出 1// 获取指定条件的第一个b = linq.First(list, func(s *Student) bool &#123; return s.Sex &#125;) //输出 1b = linq.Last(list) //输出 7 // 获取指定条件的最后一个b = linq.Last(list, func(s *Student) bool &#123; return s.Sex &#125;)//输出 3</code></pre><p>c. 去重</p><pre><code>//引用类型需要指定 去重的Key值   c := linq.Distinct(list, func(s *Student) int &#123; return s.Id &#125;)fmt.Println(c) //输出 1，2，3，4，5，6，7 //值类型可直接调用var list1 = []Student&#123;    &#123;Id: 1, Name: &quot;张三&quot;, Age: 18, Sex: true, Score: 80&#125;,    &#123;Id: 2, Name: &quot;李四&quot;, Age: 19, Sex: true, Score: 88&#125;,    &#123;Id: 3, Name: &quot;王五&quot;, Age: 20, Sex: true, Score: 87&#125;,    &#123;Id: 4, Name: &quot;赵六&quot;, Age: 18, Sex: false, Score: 67&#125;,    &#123;Id: 5, Name: &quot;李娟&quot;, Age: 17, Sex: false, Score: 89&#125;,    &#123;Id: 6, Name: &quot;王芊&quot;, Age: 18, Sex: false, Score: 99&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,    &#123;Id: 7, Name: &quot;赵月&quot;, Age: 19, Sex: false, Score: 72&#125;,&#125;d := linq.DistinctComparable(list1)fmt.Println(d) //输出 1，2，3，4，5，6，7     </code></pre><p>d. 投影成新对象</p><pre><code>//将学生数组转换为名称数组e := linq.Select(list, func(s *Student) string &#123; return s.Name &#125;)// 输出 [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,...]    </code></pre><p>e. 取前几条数据</p><pre><code>//取前几条数据f := linq.Take(list,3)fmt.Println(f)   </code></pre><p>f. 判断 元素，集合，条件 是否存在&#x2F;满足</p><pre><code>//判断是否存在分数大于99分的同学linq.Any(list, func(s *Student) bool &#123; return s.Score &gt; 99 &#125;) // falsevar arr = []int&#123;1,2,3,4,4,5&#125;linq.AnyComparable(arr, 8)//falselinq.AnyComparable(arr, 8,12,1)//true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 60 &#125;) //true//判断所有同学分数大于60linq.All(list, func(s *Student) bool &#123; return s.Score &gt; 70 &#125;) //falselinq.AnyComparable(arr,1) //判断所有元素都为1    </code></pre><p>g. 求和&#x2F;最大值&#x2F;最小值</p><pre><code>//分数汇总linq.Sum(list, func(s *Student) int &#123; return s.Score &#125;) // 654linq.Max(list, func(s *Student) int &#123; return s.Score &#125;) // Id: 6, Name: &quot;王芊&quot;linq.Min(list, func(s *Student) int &#123; return s.Score &#125;) //Id: 4, Name: &quot;赵六&quot;var arr1 = []int&#123;1, 2, 3, 4, 4, 5&#125;linq.SumOrdered(arr1) // 19linq.MaxOrdered(arr1) // 5linq.MinOrdered(arr1) // 1    复制代码h. 按照条件分组m := linq.GroupBy(list, func(s *Student) int &#123; return s.Age &#125;)// 单词出现频率统计var words = &quot;how do you do&quot;//var s = words.Split(&#39; &#39;).GroupBy(x =&gt; x).ToDictionary(x =&gt; x.Key, x =&gt; x.Count());var s5 = linq.ToComparableMap(strings.Split(words, &quot; &quot;),func(key string, es []string) int &#123; return len(es) &#125;)fmt.Println(s5)</code></pre><p>i. 链式操作，如果有集合的组合操作需求，可以先将切片转换为链式操作对象</p><pre><code>s1 := linq.AsEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort(func(s1, s2 string) bool &#123; return s1 &lt; s2 &#125;).    ToSlice()fmt.Println(s1)s2 := linq.AsComparableEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Distinct().    Take(3).    ToSlice()fmt.Println(s2)s3 := linq.AsOrderEnumerable([]string&#123;&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;&#125;).    Where(func(s string) bool &#123; return s != &quot;b&quot; &#125;).    Select(func(s string) string &#123; return &quot;class_&quot; + s &#125;).    Sort().    Distinct().    Take(3).    ToSlice()fmt.Println(s3)s5 := linq.AsSelectEnumerable([]int&#123;1, 2, 3, 4, 5&#125;).    Where(func(v int) bool &#123; return v &gt; 3 &#125;).    Select(func(v int) string &#123; return &quot;mapping_&quot; + strconv.Itoa(v) &#125;).    Take(2).    ToSlice&lt;&gt;()fmt.Println(s5)</code></pre><p>实现泛型Set，泛型 LRU,泛型orm,泛型Redis返回</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>方法不支持泛型</p><pre><code>type A[T any] struct &#123;&#125;//编译通过func (a A[T]) SelectString() string &#123;    return &quot;&quot;&#125;//编译不通过func (a A[T]) Select2[E any]() E &#123;    retrun nil&#125;type Foo struct &#123;&#125;​//编译不通过func (Foo) bar[T any](t T) &#123;&#125;</code></pre><p>Go没有提供在编译期操作类型的能力,只能在运行时操作</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;func ToNumber[N Number](strNumber string) N &#123;    var num N    switch (interface&#123;&#125;)(num).(type) &#123;    case int:        cn, _ := strconv.Atoi(strNumber)        return N(cn)    case int32:        cn, _ := strconv.ParseInt(strNumber, 10, 32)        return N(cn)    case int64:        cn, _ := strconv.ParseInt(strNumber, 10, 64)        return N(cn)    case uint32:        cn, _ := strconv.ParseUint(strNumber, 10, 32)        return N(cn)    case uint64:        cn, _ := strconv.ParseUint(strNumber, 10, 64)        return N(cn)    case float32:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    case float64:        cn, _ := strconv.ParseFloat(strNumber, 64)        return N(cn)    &#125;    return num&#125;</code></pre><p>类型转换，不支持转换为带类型约束的interface</p><pre><code>type Number interface &#123;    int | int32 | int64 | uint32 | uint64 | float64 | float32&#125;    K, _ := v.(int)  //编译通过g, _ := v.(Number) //编译不通过</code></pre><p>更加智能类型推导，函数lamda化</p><pre><code>f(x) = ax + by = f(x)joinCorpIds := linq.Select(newUserInfos, func(s *wps.NewUserInfo) int64 &#123; return s.CompanyId &#125;)joinCorpIds := linq.Select(newUserInfos, s = &gt; s.CompanyId)joinCorpIds = newUserInfos.Select(s = &gt; s.CompanyId)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go泛型运用&quot;&gt;&lt;a href=&quot;#Go泛型运用&quot; class=&quot;headerlink&quot; title=&quot;Go泛型运用&quot;&gt;&lt;/a&gt;Go泛型运用&lt;/h1&gt;&lt;h2 id=&quot;泛型起源&quot;&gt;&lt;a href=&quot;#泛型起源&quot; class=&quot;headerlink&quot; title=&quot;泛</summary>
      
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T08:22:34.759Z</published>
    <updated>2023-12-29T10:01:15.265Z</updated>
    
    <content type="html"><![CDATA[<p>招商银行<br>SQL<br>介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别<br>Innodb的事务和锁机制<br>Mysql如何保证事务的一致性，MVCC与锁介绍<br>Innodb和Myisam的索引机制和存储结构<br>Mysql的各种日志，以及介绍用途<br>何时使用索引，什么时候索引会失效<br>单表访问用到的索引<br>查询缓慢的时候如何优化，使用explain，开启慢查询看结果分析<br>如何解决sql注入<br>HR<br>你还有什么我没看到的优点，可以说一说（我是懵的）<br>对工科有什么看法？？？<br>开始问项目经验，项目经历 ——————- 出乎意料<br>项目中怎么做的，遇到最大的问题是什么？你有什么突破<br>如果不把他当成hr, 会怎么描述这个项目？<br>这个项目在实际中是怎么使用的？<br>去当老师，来做技术是逃避吗？ —— ——-我，这为啥是逃避？<br>最有成就感的事情？<br>对自己的优缺点评价？<br>转Java愿意吗？<br>对其他编程语言的看法？<br>工作地倾向？<br>目前投的其他岗位是什么情况？<br>你有什么问题<br>我问的问题，几乎都被巧妙规避了，说不知道—-但是，试用期3个月，工资打折0.8，其他没问出来啥。对了，项目经历大概问了15-20分钟。<br>项目过程中遇到的问题<br>最近学了什么、学习方法是什么<br>对新入手的项目有没有什么学习技巧<br>家庭情况<br>base地的问题<br>对加班的看法、最大能接受的加班强度<br>算法<br>判断链表是否有环</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;招商银行&lt;br&gt;SQL&lt;br&gt;介绍知道的Mysql使用的数据库，Innodb和Myisam，以及区别&lt;br&gt;Innodb的事务和锁机制&lt;br&gt;Mysql如何保证事务的一致性，MVCC与锁介绍&lt;br&gt;Innodb和Myisam的索引机制和存储结构&lt;br&gt;Mysql的各种日志，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T08:22:16.999Z</published>
    <updated>2023-12-29T10:01:15.272Z</updated>
    
    <content type="html"><![CDATA[<p>Dijstra算法怎么实现<br>二叉树的特性和你对二叉树的理解<br>贪婪算法和动态规划怎么实现的，思想是什么，二者有什么区别<br>课程中有一个贪婪思想，有所调整的算法是什么？（忘记了）<br>问了堆排序和堆实现<br>力扣56，合并区间<br>单词逆序，简述思想以及时间空间复杂度，vector以及string的扩容。<br>A*算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dijstra算法怎么实现&lt;br&gt;二叉树的特性和你对二叉树的理解&lt;br&gt;贪婪算法和动态规划怎么实现的，思想是什么，二者有什么区别&lt;br&gt;课程中有一个贪婪思想，有所调整的算法是什么？（忘记了）&lt;br&gt;问了堆排序和堆实现&lt;br&gt;力扣56，合并区间&lt;br&gt;单词逆序，简述思想以及时</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T08:21:59.894Z</published>
    <updated>2023-12-29T10:01:15.262Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL相关问题，事务，索引，索引的优化，用过没<br>数据库的水平划分和垂直划分<br>数据库ACID的概念，事务是怎么保证的<br>原子性(Atomicity)： 事务是不可分割的最小操作单元，要么全部成功，要么全部失败<br>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态<br>隔离性(Isolation)： 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行<br>持久性(Durability)： 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的<br>事务的原子性指一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。</p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态;如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。<br>比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。<br>另一部分是业务数据的一致性，这需要程序代码来保证。比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。</p><p>事务的隔离性指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>事务的持久性指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。持久性意味着事务操作最终要持久化到数据库中，持久性是由 内存+redo log来保证的，MySQL的InnoDB在修改数据的时候，同时在内存和redo log记录这次操作，宕机的时候可以从redo log中恢复数据。</p><p>介绍一下mysql的常见的存储引擎，以及它们的区别是什么？<br>介绍一下数据库的几个隔离级别以及mysql默认的隔离级别（可重复读）<br>读未提交（READ UNCOMMITTED）在该隔离级别一个事务还没提交时，它做的变更就能被别的事务看到，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。<br>读提交 （READ COMMITTED）它满足了隔离的简单定义：一个事务提交之后，它做的变更才会被其他事务看到。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。<br>可重复读 （REPEATABLE READ）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。<br>串行化 （SERIALIZABLE）“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。<br>MySQL的InnoDB引擎在可重复读级别通过间隙锁解决了幻读问题，通过MVCC解决了不可重复读的问题</p><p>mysql底层为什么用的是b+树？<br>介绍MySQL的索引，叶子节点存什么，非叶子节点存什么？建立索引时有哪些原则？<br>MySQL的Buffer Pool是什么？存储哪些数据？如果磁盘上有100G数据，是都把这些数据load到buffer pool吗？回答不是，buffer pool只是缓存需要的数据并且尽可能缓存热数据。<br>MySQL的Buffer Pool如何区分冷热数据？回答使用LRU，类似统计预测。面试官说不对，追问是不是想问当page在磁盘上的时候，就把冷热数据区分出来，面试官说是。我回答这样没办法区分，不知道面试官想考察什么，没明白这个问题什么意思。<br>MySQL的LRU和普通的LRU算法有何区别？<br>介绍MySQL三大日志redo log,undo log,bin log。<br>写一个LRU缓存。<br>查询优化器有哪些优化<br>InnoDB里面有哪些线程<br>为什么使用B+树做索引，而不是B树或者哈希<br>了解Trie树吗<br>MySQL缓存介绍一下，有哪些优化<br>为什么使用索引、说一下你对索引的理解？<br>事务的性质有哪些，具体概念以及实现<br>也是从前面引申出来的，因为隔离性需要MVCC，然后就会细讲MVCC靠什么实现等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL相关问题，事务，索引，索引的优化，用过没&lt;br&gt;数据库的水平划分和垂直划分&lt;br&gt;数据库ACID的概念，事务是怎么保证的&lt;br&gt;原子性(Atomicity)： 事务是不可分割的最小操作单元，要么全部成功，要么全部失败&lt;br&gt;一致性(Consistency)：事务完</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T08:21:17.286Z</published>
    <updated>2023-12-29T10:01:15.272Z</updated>
    
    <content type="html"><![CDATA[<p>百度<br>计网：<br>讲一下http和https的不同<br>https加密过程<br>用的是对称加密还是非对称加密<br>HTTP1.1， 2.0区别<br>TCP三次握手四次挥手<br>TCP能不能改成2次握手<br>讲一下OSI的七层模型，以及每一层的含义和应用<br>三次握手和四次挥手<br>三次握手中如果数据发送失败，让你设计你会怎么处理<br>讲一讲四次挥手？<br>答：TCP的四次挥手分为主动关闭方和被动关闭方。主动关闭方因为自身的stream结束，主动发送了FIN报文，为第一次挥手。被动关闭方发送对第一次挥手确认的ACK报文，这为第二次挥手。接着被动方的stream结束，发送FIN报文，此为第三次挥手。最后，主动关闭方发送ACK报文对第三次挥手进行确认，为第四次挥手。</p><p>为什么是四次挥手，不能是两次挥手吗？<br>答：因为发送方发送完FIN报文之后，需要对方回复ACK报文表示：发送方的FIN报文被接收方确认已经收到。所以一定需要四次挥手。如果只有两次挥手，主动关闭方和被动关闭方分别发送FIN报文，不接受ACK报文。主动关闭方和被动关闭方无法知道发送的FIN报文被对方收到，因为FIN报文可能在网络中遗失了。</p><p>讲讲close_wait状态和last_ack状态的区别？<br>答：这两个状态都是被动结束方的状态，被动结束方接收第一次挥手，从establish状态变成close_wait状态。接着。被动结束方发送第二次和第三次挥手，从close_wait状态转变到last_ack状态。在last_ack状态，被动结束方等待主动结束方的第四次挥手。其中，第二次和第三次挥手之间，需要程序员触发close()。</p><p>HTTP请求有哪些方法，GET和 POST方法有什么区别？<br>答：HTTP请求有head，get,post方法。其中GET方法语义倾向于下载，post倾向于上传。</p><p>如果在time_wait状态点击read会怎样？<br>答：在timewait状态read类似重新进行tcp连接，如果开启时间戳机制，下一次的序列号和时间戳都比期望的大可以重新进行连接</p><p>什么是TCP<br>OSI的七层模型，以及每一层的含义和应用<br>三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲<br>RPC协议讲解。通用于分布式框架中<br>为什么要三次握手，两次不行吗？<br>tcp和udp是什么，有什么区别<br>为啥要OSI七层模型？有什么作用<br>http如何进行流量控制？拥塞控制<br>数据链路层的传输单位，网络层呢？<br>HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。<br>ftp是什么，哪一层的协议？<br>作者：maybe的小超人<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post">https://www.nowcoder.com/feed/main/detail/15ee11e3898e43cf9b072ff7d5c49b1e?sourceSSR=post</a><br>来源：牛客网</p><p>知不知道拥塞控制，讲一下<br>OSI七层网络模型<br>应用 http ftp DNS POP3<br>会话<br>表示<br>运输<br>网络 IP，ICMP，RIP，OSPF，BGP，IGMP<br>链路 SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理 ISO2110，IEEE802，IEEE802.2</p><p>tcp建立连接过程<br>断开连接过程<br>为什么客户端的 TIME-WAIT 状态必须等待 2MSL<br>输入网址到浏览器的过程<br>操作系统：<br>查看端口的命令<br>解除端口占用的命令<br>查看日志文件接口被调用次数的命令<br>上下文切换<br>进程调度算法<br>进程通信方式<br>查看 TCP 状态？<br>TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。</p><p>进程和线程<br>进程间有哪些通信方式，讲一下<br>linux中32 和 64是什么意思<br>I&#x2F;O多路复用。水平触发和边缘触发<br>数据序列化实现。对二进制序列化，Pool Buffer。<br>cpu密集型和i&#x2F;o密集型什么意思<br>如果1g的内存，能否申请2g的空间，8g呢？<br>死锁的必要条件是什么（描述了死锁的情况，但不满意，一直问必要条件是什么，麻了）<br>进程调度算法有哪些，最短作业优先怎么样的，有什么弊端<br>讲一下select&#x2F;pool&#x2F;epoll<br>讲一下同步（阻塞，非阻塞）IO&#x2F;异步IO<br>MySQL：<br>用过哪些数据库，了解NOSQL吗<br>MySQL有哪些索引<br>主键索引和唯一索引区别<br>Mysql中的索引讲一下<br>索引覆盖<br>数据库的隔离级别<br>一个联合索引（a，b，c），查询（a，c），能用到索引吗<br>事物的特性<br>SQL注入 怎么避免<br>隔离级别<br>读已提交和读未提交有什么区别<br>解释脏读<br>解释可重复读 说一个场景 a数b数<br>mvcc实现逻辑<br>mysql日志 有哪几种<br>mvcc用的哪一个日志<br>mysql的锁有哪些<br>char和varchar的区别 哪一个效率高<br>场景题<br>两个包含5亿URL的文件，找两个文件的重复URL，内存只有4G。<br>首先我们最常想到的方法是读取文件a，建立哈希表，然后再读取文件b，遍历文件b中每个url，对于每个遍历，我们都执行查找hash表的操作，若hash表中搜索到了，则说明两文件共有，存入一个集合。</p><p>但上述方法有一个明显问题，加载一个文件的数据需要50亿*64bytes &#x3D; 320G远远大于4G内存，何况我们还需要分配哈希表数据结构所使用的空间，所以不可能一次性把文件中所有数据构建一个整体的hash表。所以虽然可行，但是无法满足需求。</p><p>针对上述问题，我们采用分治算法的思想。</p><p>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M)，为什么是1000？主要根据内存大小和要分治的文件大小来计算，我们就大致可以把320G大小分为1000份，每份大约300M（当然，到底能不能分布尽量均匀，得看hash函数的设计）</p><p>遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999)（为什么要这样做? 文件a的hash映射和文件b的hash映射函数要保持一致，这样的话相同的url就会保存在对应的小文件中，比如，如果a中有一个url记录data1被hash到了a99文件中，那么如果b中也有相同url，则一定被hash到了b99中）</p><p>所以现在问题转换成了：找出1000对小文件中每一对相同的url（不对应的小文件不可能有相同的url）</p><p>因为每个hash大约300M，所以我们再可以采用哈希中的想法</p><p>场景题：如果给数据库中的表加一列数据，但是用户是上亿规模的，这个时候用户访问页面可能会卡，如何解决？<br>算法场景题。一个生产者消费者场景。提了一些改进点。<br>&#x2F;&#x2F; 模块A、B，创建一个Buffer类，提供统一的接口供有A去生产数据，B去消费数据。<br>&#x2F;&#x2F; 一些细节：<br>&#x2F;&#x2F; 1. A创建数据的大小是任意的，可能是256个字节，也可能是1k<br>&#x2F;&#x2F; 2. 提供接口供消费者B，获取数据的大小，并可以一次性获取所有数据，或者分批获取数据<br>&#x2F;&#x2F; 3. A、B在不同的线程中，要实现线程安全的数据接口</p><p>作者：Olimiya<br>链接：<a href="https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic">https://www.nowcoder.com/discuss/514852293896888320?sourceSSR=dynamic</a><br>来源：牛客网</p><p>算法<br>数组中找第K大的数<br>class Solution {<br>public:<br>    void quickPartition(vector<int>&amp; nums, int start, int end, int target) {<br>        &#x2F;&#x2F; 随机取一个数作为基准<br>        srand(time(nullptr));<br>        int random &#x3D; rand() % (end - start + 1) + start;<br>        int base &#x3D; nums[random];<br>        &#x2F;&#x2F; 将该数放到待快排区间开头第一个元素<br>        swap(nums[start], nums[random]);<br>        int index &#x3D; start;<br>        &#x2F;&#x2F; 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素<br>        &#x2F;&#x2F; 交换到index + 1位置，index++，使得最终index前面的元素都比base大。<br>        for (int i &#x3D; start + 1; i &lt;&#x3D; end; ++i) {<br>            if (nums[i] &gt;&#x3D; base) {<br>                swap(nums[index + 1], nums[i]);<br>                index++;<br>            }<br>        }<br>        &#x2F;&#x2F; base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。<br>        swap(nums[index], nums[start]);</int></p><pre><code>    // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，    // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。    if (index &lt; target) &#123;        quickPartition(nums, index + 1, end, target);    &#125;    else if (index &gt; target) &#123;        quickPartition(nums, start, index - 1, target);    &#125;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    // 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，    // 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k// 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。    quickPartition(nums, 0, nums.size() - 1, k - 1);    return nums[k - 1];&#125;</code></pre><p>};</p><p>class Solution {<br>    Random random&#x3D;new Random();<br>    public int findKthLargest(int[] nums, int k) {<br>            return quickSelect(nums,k,0,nums.length-1);<br>    }<br>    public int quickSelect(int[] nums,int k,int left,int right){<br>        &#x2F;&#x2F;随机获取一个值作为目标值<br>        int index&#x3D;random.nextInt(right-left+1)+left;<br>        &#x2F;&#x2F;保存目标值<br>        int target&#x3D;nums[index];<br>        &#x2F;&#x2F;在进行第一次交换时，会丢失nums[left],因此需要保存<br>        nums[index]&#x3D;nums[left];<br>        int i&#x3D;left,j&#x3D;right;<br>        while(i&lt;j){<br>            while(i&lt;j&amp;&amp;nums[j]&lt;&#x3D;target) j–;<br>            nums[i]&#x3D;nums[j];<br>            while(i&lt;j&amp;&amp;nums[i]&gt;&#x3D;target) i++;<br>            nums[j]&#x3D;nums[i];<br>        }<br>        nums[i]&#x3D;target;<br>        &#x2F;&#x2F;经过交换后，i左部均大于nums[i],右部均小于nums[i]<br>        if(i&#x3D;&#x3D;k-1) return nums[i];<br>        &#x2F;&#x2F;说明在左部分<br>        else if(i&gt;k-1) return quickSelect(nums,k,left,i-1);<br>        else return quickSelect(nums,k,i+1,right);<br>    }<br>}<br>复制代码<br>合并k个链表<br>class Solution {<br>public:<br>struct Status {<br>int val;<br>ListNode *ptr;<br>bool operator &lt; (const Status &amp;rhs) const {<br>return val &gt; rhs.val;<br>}<br>};</p><p>priority_queue <Status> q;</Status></p><p>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {<br>    for (auto node: lists) {<br>        if (node) q.push({node-&gt;val, node});<br>    }<br>    ListNode head, *tail &#x3D; &amp;head;<br>    while (!q.empty()) {<br>        auto f &#x3D; q.top(); q.pop();<br>        tail-&gt;next &#x3D; f.ptr;<br>        tail &#x3D; tail-&gt;next;<br>        if (f.ptr-&gt;next) q.push({f.ptr-&gt;next-&gt;val, f.ptr-&gt;next});<br>    }<br>    return head.next;<br>}<br>复制代码<br>};</p><p>k个升序链表的合并<br>class Solution {<br>public:<br>struct Status {<br>int val;<br>ListNode *ptr;<br>bool operator &lt; (const Status &amp;rhs) const {<br>return val &gt; rhs.val;<br>}<br>};</p><p>priority_queue <Status> q;</Status></p><p>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {<br>    for (auto node: lists) {<br>        if (node) q.push({node-&gt;val, node});<br>    }<br>    ListNode head, *tail &#x3D; &amp;head;<br>    while (!q.empty()) {<br>        auto f &#x3D; q.top(); q.pop();<br>        tail-&gt;next &#x3D; f.ptr;<br>        tail &#x3D; tail-&gt;next;<br>        if (f.ptr-&gt;next) q.push({f.ptr-&gt;next-&gt;val, f.ptr-&gt;next});<br>    }<br>    return head.next;<br>}<br>复制代码<br>};</p><p>丑数<br>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p>class Solution {<br>public:<br>    int getKthMagicNumber(int k) {<br>        set<long long> st;<br>        st.insert(1LL);<br>        long long ans &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;k;++i){<br>            ans &#x3D; *st.begin();<br>            st.erase(st.begin());<br>            st.insert(ans * 3);<br>            st.insert(ans * 5);<br>            st.insert(ans * 7);<br>        }<br>        return ans;<br>    }<br>};<br>复制代码<br>数组删除元素<br>中序遍历递归和非递归写法<br>归并排序<br>数组中第K大的值，O(nlogn)，不能用sort()函数<br>二叉树的层序遍历<br>查找链表倒数第K个数<br>判断链表是否有环<br>智力题：<br>25匹马5个赛道，最少几次前三名马<br>1000个瓶子，一瓶毒药，10只白鼠，喝下毒药一周后死亡，找毒药</long></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;百度&lt;br&gt;计网：&lt;br&gt;讲一下http和https的不同&lt;br&gt;https加密过程&lt;br&gt;用的是对称加密还是非对称加密&lt;br&gt;HTTP1.1， 2.0区别&lt;br&gt;TCP三次握手四次挥手&lt;br&gt;TCP能不能改成2次握手&lt;br&gt;讲一下OSI的七层模型，以及每一层的含义和应用&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp内存管理</title>
    <link href="http://example.com/p/ee3dbaf8.html"/>
    <id>http://example.com/p/ee3dbaf8.html</id>
    <published>2023-12-28T08:01:32.781Z</published>
    <updated>2023-12-29T10:01:15.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp内存管理"><a href="#cpp内存管理" class="headerlink" title="cpp内存管理"></a>cpp内存管理</h1><p><img src="https://s1.ax1x.com/2023/08/06/pPA4Y7T.png"></p><p>栈：又叫堆栈，主要存放非静态局部变量、函数参数、返回值等等，栈是向下增长的；</p><p>BSS（Block started by symbol)：存放未初始化的全局和静态变量。</p><p>堆：用于程序运行时动态内存分配，堆是可以上增长的；</p><p>数据段：存储全局数据和静态数据，常量数据（如字符串常量）。</p><p>代码段：存储可执行的代码与只读常量；</p><p>当全局&#x2F;静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。</p><pre><code>int x;int z = 5;void func()&#123;    static int y;&#125;int main()&#123;    return 0;&#125;</code></pre><p>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p><p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p><p>而对于已经初始化了的全局&#x2F;静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p><h2 id="堆和栈的主要区别"><a href="#堆和栈的主要区别" class="headerlink" title="堆和栈的主要区别"></a>堆和栈的主要区别</h2><p>有以下几点：</p><ul><li>管理方式不同；</li><li>空间大小不同；</li><li>能否产生碎片不同；</li><li>生长方向不同；</li><li>分配方式不同；</li><li>分配效率不同；</li></ul><p><strong>管理方式：</strong>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br><strong>空间大小：</strong>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br><strong>碎片问题：</strong>对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br><strong>生长方向：</strong>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br><strong>分配方式：</strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br><strong>分配效率：</strong>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><h2 id="让一个对象只在栈（堆）上分配内存"><a href="#让一个对象只在栈（堆）上分配内存" class="headerlink" title="让一个对象只在栈（堆）上分配内存"></a>让一个对象只在栈（堆）上分配内存</h2><h3 id="只在栈上分配内存"><a href="#只在栈上分配内存" class="headerlink" title="只在栈上分配内存"></a>只在栈上分配内存</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<br>虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new，而后者我们是可以自行声明重写的。<br>将operator new()设为私有即可禁止对象被new在堆上。</p><pre><code>class A  &#123;  private:      void* operator new(size_t t)&#123;&#125;     // 注意函数的第一个参数和返回值都是固定的      void operator delete(void* ptr)&#123;&#125; // 重载了new就需要重载delete  public:      A()&#123;&#125;      ~A()&#123;&#125;  &#125;;</code></pre><h3 id="只在堆上分配内存"><a href="#只在堆上分配内存" class="headerlink" title="只在堆上分配内存"></a>只在堆上分配内存</h3><p>就是不能静态建立类对象, 即不能直接调用类的构造函数。<br>首先要知道， 当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。 实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的， 则编程器不会在栈空间上为类对象分配内存。 因此, 我们只需要将析构函数设为私有，类对象就无法建立在栈上了。</p><pre><code>class A&#123;public:    A()&#123;&#125;    void destroy()&#123;delete this;&#125;private:    ~A()&#123;&#125;&#125;</code></pre><p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。</p><p>存在问题：</p><ol><li>无法解决继承问题：为了实现多态， 析构函数通常要设为virtual， 因此析构函数不能设为private，此时我们可以使用protected， 这样，子类可以访问析构函数，而外部无法访问。</li><li>new和destroy的对应关系容易引起误解，解决办法是将构造函数也设置为protected，然后提供一个create函数和destroy对应。</li></ol><h3 id="在栈上动态分配内存"><a href="#在栈上动态分配内存" class="headerlink" title="在栈上动态分配内存"></a>在栈上动态分配内存</h3><p>C提供了在栈中动态分配内存的函数alloca，用法和malloc一样，但不用free，因为他是在栈中分配空间，超出定义域后自动释放:</p><pre><code>int lenght = 10;char* str = (char*)alloca(length * sizeof(char));</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp内存管理&quot;&gt;&lt;a href=&quot;#cpp内存管理&quot; class=&quot;headerlink&quot; title=&quot;cpp内存管理&quot;&gt;&lt;/a&gt;cpp内存管理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/06/pPA4Y7T.p</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp面向对象</title>
    <link href="http://example.com/p/87fdbf5e.html"/>
    <id>http://example.com/p/87fdbf5e.html</id>
    <published>2023-12-28T07:59:07.966Z</published>
    <updated>2023-12-29T10:01:15.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp面向对象"><a href="#cpp面向对象" class="headerlink" title="cpp面向对象"></a>cpp面向对象</h1><p>面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装可以隐藏实现细节，使得代码模块化；封装将一些属性和相关方法封装在一个对象中，对数据的访问只能通过已定义的界面。对外隐藏内部具体实现细节。内部实现，外界不需要关心，外界只需要根据“内部提供的接口”去使用就可以。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。<br>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。<br>类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p><p>封装的意义</p><ul><li>保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）</li><li>隐藏方法（实现）细节，只要接口不变，内容的修改不会影响到外部的调用者（方法封装）</li><li>封装可以使对象拥有完整的属性和方法（类中的函数）</li><li>外部不能直接访问对象的属性，只能通过该属性对应的公有方法访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。继承是用来表示类之间的is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>通过继承创建的新类称为“子类”或“派生类”。被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>C++支持两种多态性：编译时多态性，运行时多态性。<br>编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding<br>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</p><p>覆盖：是指子类重新定义父类的虚函数的做法。<br>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>多态的构成条件</p><ul><li>必须通过基类的指针或者引用调用虚函数<ul><li>虚函数：在类的普通成员函数前加上virtual关键字+</li></ul></li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</li></ul><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p><p>多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><p>除了重载与覆盖（重写），C++还有隐藏。隐藏是指派生类的函数屏蔽了与其同名的基类函数。隐藏规则如下：</p><p>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。<br>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。</p><ul><li>参数相同、有virtual关键字：多态重写；</li><li>参数相同、无virtual关键字：隐藏；与重写区分。</li><li>参数不同、有virtual关键字：隐藏；与重载区分。</li><li>参数不同、无virtual关键字：隐藏；与重载区分。</li></ul><h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>什么是虚函数？<br>被 virtual 关键字修饰的成员函数称为虚函数。<br>虚函数的作用是实现多态性，即通过基类访问派生类的函数。<br>什么是纯虚函数？<br>在虚函数后面添加 &#x3D;0 ，虚函数就成为纯虚函数，<br>在很多情况下，基类生成对象很不合理。为了解决这个问题，引入了纯虚函数的概念，将函数定义为纯虚函数，派生类中必须重写实现纯虚函数。对于实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p><p>区别：</p><p>虚函数定义形式：成员函数前添加 virtual 关键字，纯虚函数在虚函数后添加 &#x3D;0 ；<br>含有纯虚函数的类，称为抽象类；只含有虚函数的类，不能称为抽象类。<br>虚函数既可以直接使用，也可以被子类重载实现后，以多态的形式调用；而纯虚函数必须被子类重载实现，才能以多态的形式调用，因为纯虚函数在基类中只有声明。<br>无论虚函数还是纯虚函数，定义中都不能有 static 关键字。因为 static 关键字修饰的内容在编译前就要确定，而虚函数、纯虚函数是在运行时动态绑定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp面向对象&quot;&gt;&lt;a href=&quot;#cpp面向对象&quot; class=&quot;headerlink&quot; title=&quot;cpp面向对象&quot;&gt;&lt;/a&gt;cpp面向对象&lt;/h1&gt;&lt;p&gt;面向对象的三个基本特征是：封装、继承、多态。其中，封装可以隐藏实现细节，使得代码模块化；继承可以扩展</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T07:58:37.465Z</published>
    <updated>2023-12-29T10:01:15.270Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统<br>多线程接触过吗？控制线程访问共享资源有哪些锁？<br>线程与进程的定义，区别<br>线程和进程都是操作系统中用于执行程序的基本概念，它们之间有一些重要的区别：</p><p>进程（Process）：</p><p>进程是操作系统中的一个独立的执行单元，拥有独立的内存空间、系统资源和执行状态。<br>每个进程都有自己的地址空间，不同进程之间的数据不共享，通信需要通过进程间通信（Inter-Process Communication，IPC）机制来实现。<br>进程之间相对独立，一个进程的崩溃不会影响其他进程的执行。<br>进程的创建和销毁通常比较耗时，占用更多的系统资源。<br>线程（Thread）：</p><p>线程是进程内的一个执行单元，多个线程共享同一个进程的内存空间和系统资源。<br>线程之间可以方便地共享数据，因为它们属于同一个进程。<br>线程的创建和销毁相对快速，消耗较少的系统资源。<br>由于线程共享进程的内存空间，一个线程的错误可能会影响同一进程内的其他线程，导致整个进程的崩溃。<br>区别总结：</p><p>进程是独立的执行单位，拥有独立的资源，线程是进程内的执行单位，共享同一进程的资源。<br>进程间通信需要复杂的IPC机制，线程间通信相对容易。<br>进程之间相对独立，线程之间相对共享。<br>进程的创建和销毁开销大，线程的创建和销毁开销小。<br>线程和进程通常用于多任务并发执行。在多核处理器上，多线程可以更充分地利用多核资源，提高程序的性能。需要根据具体的应用场景选择使用进程或线程。</p><p>线程与进程通信的方式有哪些？<br>介绍一下互斥锁（中间穿插了一点项目的实现细节问题）<br>用户级线程和内核级线程<br>用户态和内核态？怎么切换？为什么要有内核态？内核态可以进行哪些操作，举具体例子？<br>进程和线程的区别。<br>操作系统是怎么进行内存管理的？<br>程序的状态有哪些？<br>详细介绍一下每个状态是怎样转换的？<br>你知道的进程调度算法有哪些？详细介绍一下？<br>介绍一下信号量<br>多进程fork后不同进程会共享哪些资源<br>多线程里线程的同步方式有哪些<br>select怎么用。底层原理<br>select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。<br>epoll 底层为什么用红黑树不用hash<br>了解IO多路复用机制吗？（select、poll和epoll）介绍一下他们的区别<br>介绍一下epoll的两种实现方式<br>磁盘、内存读取文件以及socket通信会有哪些软硬件的配合？<br>有了解epoll的底层数据结构吗？介绍一下<br>如何限制一个进程能够使用的线程等资源<br>ulimit -u 4096</p><p>这属于软限制，是可以改变的。也就是说在我的机器上最多可以有4096个进程，但是我可以通过改变这个参数的值来修改对于进程数量的软限制，比如说用下面的命令将软限制改到5120。</p><p>ulimit -u 5120</p><p>了解过stdexec吗（NVIDIA的异步编程高性能库）<br>没有</p><p>使用过perf吗<br>没有</p><p>怎么查看tlb命中率<br>如何查看进程的线程数<br>使用top命令，具体用法是 top -H</p><pre><code>加上这个选项，top的每一行就不是显示一个进程，而是一个线程。</code></pre><p>复制代码<br>使用ps命令，具体用法是 ps -xH</p><pre><code>这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。</code></pre><p>复制代码<br>使用ps命令，具体用法是 ps -mq PID</p><pre><code>这样可以看到指定的进程产生的线程数目。</code></pre><p>复制代码<br>如何查看进程打开的文件有哪些<br>1.列出所有打开的文件:</p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><p>查看谁正在使用某个文件<br>lsof &#x2F;filepath&#x2F;file</p><p>3.递归查看某个目录的文件信息</p><p>lsof +D &#x2F;filepath&#x2F;filepath2&#x2F;</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><p>比使用+D选项，遍历查看某个目录的所有文件信息 的方法<br>lsof | grep ‘&#x2F;filepath&#x2F;filepath2&#x2F;’</p><p>列出某个用户打开的文件信息<br>lsof -u username</p><p>备注: -u 选项，u其实是user的缩写</p><p>列出某个程序所打开的文件信息<br>lsof -c mysql</p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</p><p>列出多个程序多打开的文件信息<br>lsof -c mysql -c apache</p><p>列出某个用户以及某个程序所打开的文件信息<br>lsof -u test -c mysql</p><p>列出除了某个用户外的被打开的文件信息<br>lsof -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><p>通过某个进程号显示该进行打开的文件<br>lsof -p 1</p><p>列出多个进程号对应的文件信息<br>lsof -p 123,456,789</p><p>列出除了某个进程号，其他进程号所打开的文件信息<br>lsof -p ^1</p><p>13 . 列出所有的网络连接</p><p>lsof -i</p><p>列出所有tcp 网络连接信息<br>lsof -i tcp</p><p>列出所有udp网络连接信息<br>lsof -i udp</p><p>列出谁在使用某个端口<br>lsof -i :3306</p><p>列出谁在使用某个特定的udp端口<br>lsof -i udp:55</p><p>特定的tcp端口</p><p>lsof -i tcp:80</p><p>列出某个用户的所有活跃的网络端口<br>lsof -a -u test -i</p><p>列出所有网络文件系统<br>lsof -N</p><p>20.域名socket文件</p><p>lsof -u</p><p>21.某个用户组所打开的文件信息</p><p>lsof -g 5555</p><p>根据文件描述列出对应的文件信息<br>lsof -d description(like 2)</p><p>根据文件描述范围列出文件信息<br>lsof -d 2-3</p><p>产生死锁的条件以及怎么解决死锁问题<br>Linux大概学到什么程度？<br>线程怎么创建，什么语言<br>线程的基本状态有哪几个？<br>多线程的使用的好处是什么<br>多线程会竞争资源出现死锁的状态，死锁怎么解决？<br>事务及事务隔离<br>编译一个hello world程序并且在shell上运行打印的全过程?<br>fork()父子进程之间的关系<br>缺页中断的过程<br>地址转换的过程<br>进程状态是怎么转变的<br>进程会不会睡眠，哪个阶段（会睡眠，送到总线到显示器打印输出的这个阶段内会睡眠）<br>总线在其中发挥的作用<br>这个过程中磁盘和内存的关系<br>从磁盘放到内存地址中，为什么放到一个地址比如0x12345就会执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统&lt;br&gt;多线程接触过吗？控制线程访问共享资源有哪些锁？&lt;br&gt;线程与进程的定义，区别&lt;br&gt;线程和进程都是操作系统中用于执行程序的基本概念，它们之间有一些重要的区别：&lt;/p&gt;
&lt;p&gt;进程（Process）：&lt;/p&gt;
&lt;p&gt;进程是操作系统中的一个独立的执行单元，拥有独</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T07:58:00.118Z</published>
    <updated>2023-12-29T10:01:15.273Z</updated>
    
    <content type="html"><![CDATA[<p>计网<br>讲一下OSI的七层模型，以及每一层的含义和应用<br>osi七层网络模型，每层有的协议<br>应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet<br>表示层 数据格式化，代码转换，数据加密 没有协议<br>会话层 解除或建立与别的接点的联系 没有协议<br>传输层 提供端对端的接口 TCP，UDP<br>网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP<br>数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</p><p>为啥要OSI七层模型？有什么作用<br>什么是TCP<br>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><p>tcp和udp的区别<br>1、TCP 是面向连接的（三次握手建立连接），UDP 是无连接的即发送数据前不需要先建立链接。<br>2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，不保证可靠交付。 （并且因为 TCP 可靠，面向连接，不会丢失数据因此适合大数据量的交换）<br>3、TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。<br>4、TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。<br>5、TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。<br>6、TCP 是面向连接的可靠性传输，而 UDP 是不可靠的</p><p>tcp和udp是什么，有什么区别<br>1.TCP提供的是面向连接的、可靠的数据流传输；UDP提供的是非面向连接的、不可靠的数据流传输。<br>2.TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，按序到达；UDP尽最大努力交付，即不保证可靠交付。<br>3.TCP面向字节流；UDP面向报文。<br>4.TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。<br>5.UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>6.TCP对系统资源要求较多，UDP对系统资源要求较少。TCP首部有20字节；UDP的首部只有8个字节。<br>7.TCP的逻辑通信信道是全双工的可靠信道；UDP的逻辑通信信道是不可靠信道。</p><p>介绍一下使用tcp进行通信的时候socket的使用过程<br>服务端： 创建socket bind listen accept send&#x2F;read close<br>客户端: 创建socket connect send&#x2F;resv close</p><p>tcp建立连接过程<br>断开连接过程<br>为什么客户端的 TIME-WAIT 状态必须等待 2MSL<br>计算机网络的理解大概是什么样的？说下TCP的三次握手<br>SSL的四次握手知道不？<br>tcp三次握手四次挥手<br>tcp四次挥手第二次和第三次不能合并吗<br>ssl四次挥手<br>tcp三次握手过程、是否熟悉TLS协议<br>三次握手，四次挥手，SYN是什么，各自处于什么状态，详细讲<br>三次握手和四次挥手<br>TCP三次握手四次挥手<br>TCP能不能改成2次握手<br>三次握手中如果数据发送失败，让你设计你会怎么处理<br>讲一讲四次挥手？<br>答：TCP的四次挥手分为主动关闭方和被动关闭方。主动关闭方因为自身的stream结束，主动发送了FIN报文，为第一次挥手。被动关闭方发送对第一次挥手确认的ACK报文，这为第二次挥手。接着被动方的stream结束，发送FIN报文，此为第三次挥手。最后，主动关闭方发送ACK报文对第三次挥手进行确认，为第四次挥手。</p><p>为什么是四次挥手，不能是两次挥手吗？<br>答：因为发送方发送完FIN报文之后，需要对方回复ACK报文表示：发送方的FIN报文被接收方确认已经收到。所以一定需要四次挥手。如果只有两次挥手，主动关闭方和被动关闭方分别发送FIN报文，不接受ACK报文。主动关闭方和被动关闭方无法知道发送的FIN报文被对方收到，因为FIN报文可能在网络中遗失了。</p><p>讲讲close_wait状态和last_ack状态的区别？<br>答：这两个状态都是被动结束方的状态，被动结束方接收第一次挥手，从establish状态变成close_wait状态。接着。被动结束方发送第二次和第三次挥手，从close_wait状态转变到last_ack状态。在last_ack状态，被动结束方等待主动结束方的第四次挥手。其中，第二次和第三次挥手之间，需要程序员触发close()。</p><p>讲一下http和https的不同<br>http和https的区别<br>HTTP和HTTPS的区别<br>https加密过程<br>用的是对称加密还是非对称加密<br>HTTP1.1， 2.0区别<br>HTTP请求有哪些方法，GET和 POST方法有什么区别？<br>答：HTTP请求有head，get,post方法。其中GET方法语义倾向于下载，post倾向于上传。</p><p>如果在time_wait状态点击read会怎样？<br>答：在timewait状态read类似重新进行tcp连接，如果开启时间戳机制，下一次的序列号和时间戳都比期望的大可以重新进行连接</p><p>RPC协议讲解。通用于分布式框架中<br>为什么要三次握手，两次不行吗？<br>http如何进行流量控制？拥塞控制<br>数据链路层的传输单位，网络层呢？<br>HTTP报文内容。POST和GET有什么区别。和websocket的区别。能不能传输二进制数据。<br>ftp是什么，哪一层的协议？<br>知不知道拥塞控制，讲一下<br>输入网址到浏览器的过程<br>网络模型、介绍一下每一层的作用？<br>这个也是从上面引申的，流量控制和拥塞控制怎么实现的？<br>具体原理很细滑动窗口怎么移动、拥塞每个过程每个算法原理实现等。<br>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）<br>如何使用UDP设计一个可靠的传输协议（知识盲区）<br>一条SQL语句的执行流程<br>epoll实现原理<br>为什么要用epoll<br>reactor和proactor的好处和坏处。为什么要用reactor而不用proactor<br>能详细讲一下有限状态机怎么解析http报文吗<br>小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题<br>如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆<br>socket通信问，connect时，操作系统会进行什么操作？（我：0_0，阿巴阿巴…）<br>这个时候会绑定端口吗？<br>后续简述TCP三次握手以及四次挥手。（我：巴拉巴拉）<br>第一次握手丢失会怎样？第二次握手丢失会怎样？第二次握手绑定端口号了吗？<br>第二次挥手和第三次挥手之间，传输一个大文件会怎么样？一直等待吗？<br>TCP粘包拆包了解吗？HTTP为什么没有粘包拆包？<br>tcp&#x2F;ip五层模型<br>dns服务器用的是什么协议。<br>ping命令 用的是什么协议。在哪一层。<br>tcp拥塞控制实现。<br>在浏览器输入URL后回车的过程，涉及什么协议<br>http一定是tcp吗，http3之前是<br>http3 quic</p><p>服务器多个进程可以都绑定80这个端口监听吗<br>可以，不同套接字</p><p>原理是什么<br>套接字不同可以区分</p><p>操作系统怎么转发的<br>https可以绑定80端口吗，绑定了还能加密吗，为什么</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计网&lt;br&gt;讲一下OSI的七层模型，以及每一层的含义和应用&lt;br&gt;osi七层网络模型，每层有的协议&lt;br&gt;应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet&lt;br&gt;表示层 数据格式化，代码转换，数据加密 没有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/p/0.html"/>
    <id>http://example.com/p/0.html</id>
    <published>2023-12-28T07:57:23.230Z</published>
    <updated>2023-12-29T10:01:15.267Z</updated>
    
    <content type="html"><![CDATA[<p>cpp<br><a href="https://www.dotcpp.com/course/808">https://www.dotcpp.com/course/808</a></p><p>面向对象<br>c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗<br>封装、继承、多态</p><p>c++面向对象编程讲一下<br>C++多态<br>编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding<br>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</p><p>多态和继承在什么情况下使用<br>继承是指：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</p><p>除了多态和继承还有什么面向对象方法<br>能再仔细介绍一下c++的多态吗<br>虚析构函数<br>析构函数和构造函数会是虚函数吗？<br>析构函数作用<br>完成一些清理工作，比如：释放内存等。</p><p>构造函数能否是虚函数？<br>当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。</p><p>虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。</p><p>vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。</p><p>如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。</p><p>因此，构造函数不可以是虚函数。</p><p>虚函数和纯虚函数<br>虚函数是什么，重载和重写的关系。<br>答：虚函数涉及到C++的多态。当、在基类中声明一个虚函数，在派生类中重写该函数，可以实现动态绑定。在运行时，程序会根据具体对象的类型调用相应的函数。重写要求函数签名完全一致，即函数名，函数变量和返回值完全一致，但是函数体可以不同。重写是运行时多态，也就是动态多态。重载是函数名相同，返回值和函数参数可以不同，重载是编译时多态，即静态多态。</p><p>讲讲你理解的虚基类。<br>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。虚基类是可以被实例化的。</p><p>C++多态虚函数实现原理。虚函数表里面有哪些东西？<br>多态是怎么调用派生类重写的方法的<br>虚函数和静态函数 虚表<br>static关键字在C++中有什么作用？<br><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><p>static修饰的类的数据成员怎么初始化的？<br><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><p>static修饰类的成员函数，这个成员函数使用起来有哪些限制？<br><a href="https://whl963854.github.io/p/80c02825.html">https://whl963854.github.io/p/80c02825.html</a></p><p>知道哪些c++中的关键字，然后讲了static<br>static变量存储在哪，和局部变量存储位置有什么区别?<br>实现String 的普通和拷贝构造、赋值重载和析构函数<br>#pragma warning(disable:4996)<br>#include <iostream><br>#include <cstring><br>using namespace std;</cstring></iostream></p><p>class MyString {<br>public:<br>    &#x2F;&#x2F; 默认构造函数<br>    MyString(const char* str &#x3D; NULL);<br>    &#x2F;&#x2F; 复制构造函数<br>    MyString(const MyString&amp; str);<br>    &#x2F;&#x2F; 移动构造函数<br>    MyString(MyString&amp;&amp; str)noexcept;<br>    &#x2F;&#x2F; 析构函数<br>    ~MyString();<br>    &#x2F;&#x2F; 字符串连接<br>    MyString operator+(const MyString&amp; str);<br>    &#x2F;&#x2F; 拷贝赋值<br>    MyString&amp; operator&#x3D;(const MyString&amp; str);<br>    &#x2F;&#x2F;移动赋值<br>    MyString&amp; operator&#x3D;(MyString&amp;&amp; str);</p><pre><code>// 字符串赋值MyString&amp; operator=(const char* str);// 判断是否字符串相等bool operator==(const MyString&amp; str);// 获取字符串长度int length();// 求子字符串[start,start+n-1]MyString substr(int start, int n);// 重载输出friend ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str);</code></pre><p>private:<br>    char* m_data;<br>    int m_size;<br>};<br>&#x2F;&#x2F; 构造函数<br>MyString::MyString(const char* str)<br>{<br>    if (str &#x3D;&#x3D; nullptr)<br>    {<br>        m_data &#x3D; new char[1];<br>        m_data[0] &#x3D; ‘\0’;<br>        m_size &#x3D; 0;<br>    }<br>    else<br>    {<br>        m_size &#x3D; strlen(str);<br>        m_data &#x3D; new char[m_size + 1];<br>        strcpy(m_data, str);<br>    }<br>}<br>&#x2F;&#x2F; 复制构造函数<br>MyString::MyString(const MyString&amp; str)<br>{<br>    m_size &#x3D; str.m_size;<br>    m_data &#x3D; new char[m_size + 1];<br>    strcpy(m_data, str.m_data);<br>}<br>&#x2F;&#x2F; 析构函数<br>MyString::~MyString()<br>{<br>    delete[] m_data;<br>}<br>&#x2F;&#x2F; 字符串连接<br>MyString MyString::operator+(const MyString&amp; str)<br>{<br>    MyString newStr;<br>    &#x2F;&#x2F;释放原有空间<br>    delete[] newStr.m_data;<br>    newStr.m_size &#x3D; m_size + str.m_size;<br>    newStr.m_data &#x3D; new char[newStr.m_size + 1];<br>    strcpy(newStr.m_data, m_data);<br>    strcpy(newStr.m_data + m_size, str.m_data);<br>    return newStr;<br>}<br>&#x2F;&#x2F; 字符串赋值<br>MyString&amp; MyString::operator&#x3D;(const MyString&amp; str)<br>{<br>    if (m_data &#x3D;&#x3D; str.m_data)<br>    {<br>        return *this;<br>    }<br>    delete[] m_data;<br>    m_size &#x3D; str.m_size;<br>    m_data &#x3D; new char[m_size + 1];<br>    strcpy(m_data, str.m_data);<br>    return *this;<br>}<br>MyString&amp; MyString::operator&#x3D;(MyString&amp;&amp; str)<br>{<br>    if (str.m_data &#x3D;&#x3D; m_data)<br>    {<br>        return <em>this;<br>    }<br>    delete m_data;<br>    m_data &#x3D; str.m_data;<br>    m_size &#x3D; str.m_size;<br>    str.m_data &#x3D; nullptr;<br>    str.m_size &#x3D; 0;<br>}<br>&#x2F;&#x2F; 字符串赋值<br>MyString&amp; MyString::operator&#x3D;(const char</em> str)<br>{<br>    if (m_data &#x3D;&#x3D; str)<br>    {<br>        return *this;<br>    }<br>    delete[] m_data;<br>    m_size &#x3D; strlen(str);<br>    m_data &#x3D; new char[m_size + 1];<br>    strcpy(m_data, str);<br>    return *this;<br>}<br>&#x2F;&#x2F; 判断是否字符串相等<br>bool MyString::operator&#x3D;&#x3D;(const MyString&amp; str)<br>{<br>    return strcmp(m_data, str.m_data) &#x3D;&#x3D; 0;<br>}<br>&#x2F;&#x2F; 获取字符串长度<br>int MyString::length()<br>{<br>    return m_size;<br>}<br>&#x2F;&#x2F; 求子字符串[start,start+n-1]<br>MyString MyString::substr(int start, int n)<br>{<br>    MyString newStr;<br>    &#x2F;&#x2F; 释放原有内存<br>    delete[] newStr.m_data;<br>    &#x2F;&#x2F; 重新申请内存<br>    newStr.m_data &#x3D; new char[n + 1];<br>    for (int i &#x3D; 0;i &lt; n;++i)<br>    {<br>        newStr.m_data[i] &#x3D; m_data[start + i];<br>    }<br>    newStr.m_data[n] &#x3D; ‘\0’;<br>    newStr.m_size &#x3D; n;<br>    return newStr;<br>}<br>MyString::MyString(MyString&amp;&amp; str) noexcept<br>{<br>    m_data &#x3D; str.m_data;<br>    str.m_data &#x3D; nullptr;<br>    m_size &#x3D; str.m_size;<br>    str.m_size &#x3D; 0;<br>}<br>&#x2F;&#x2F; 重载输出<br>ostream&amp; operator&lt;&lt;(ostream&amp; o, const MyString&amp; str)<br>{<br>    o &lt;&lt; str.m_data;<br>    return o;<br>}<br>复制代码<br>内存管理<br>内存破坏<br>强制类型转换：大家都知道不匹配的类型强制转换会带来一些bug，比如int和unsigned int互相转换，又或者int和__int64强行转换，有的时候因为系统产生这些问题。<br>字符串拷贝溢出，覆盖空间<br>随机性的内存被修改<br>缓冲区溢出：这是最常见的内存破坏情况之一。它发生在程序试图向一个缓冲区写入超过其分配大小的数据时。这可能导致数据覆盖，破坏相邻内存区域，以及潜在的安全漏洞。<br>野指针：使用未初始化或已经释放的指针会导致内存破坏。这通常会导致程序崩溃或不确定的行为。<br>重复释放：多次释放同一块内存可能导致内存破坏，因为第一次释放后，该内存不再属于程序。<br>不匹配的内存分配和释放：使用new和delete或malloc和free等内存分配和释放函数时，必须确保它们匹配使用。如果分配和释放不匹配，可能会导致内存破坏。<br>使用已释放内存：在内存被释放后，程序仍然尝试使用该内存区域的指针。这会导致内存破坏。<br>数组越界访问：当程序试图访问数组元素的索引超过数组的边界时，会导致内存破坏。</p><p>栈溢出是什么？栈溢出的原因<br>栈溢出（Stack Overflow）是一种常见的编程错误，它发生在程序使用栈内存时，当递归或函数调用嵌套层级过深，导致栈内存不足时，就会出现栈溢出错误。栈是一块用于存储函数调用信息和局部变量的内存区域，通常有限制的大小。</p><p>栈溢出的主要原因包括：</p><p>递归调用：在递归函数中，如果递归层级过深，栈会不断增长，最终耗尽可用内存，导致栈溢出。</p><p>大型局部变量：在函数中定义大量的局部变量或数组，这些变量被存储在栈上，如果栈空间不足以容纳这些变量，就会导致栈溢出。</p><p>无限循环：在循环中，如果没有适当的终止条件，或者条件不满足退出循环，会导致无限循环，栈不断增长，最终导致栈溢出。</p><p>函数调用嵌套过深：如果函数调用嵌套层级过深，每次函数调用都会在栈上创建一个新的函数调用记录，导致栈空间迅速耗尽。</p><p>递归函数中缺少基本情况：在递归函数中，没有适当的基本情况和递归情况，递归可能无法终止，导致栈溢出。</p><p>栈溢出通常会导致程序异常终止，这是一个严重的错误，应该通过优化算法、减少递归深度、合理分配局部变量等方式来避免。如果出现栈溢出错误，可以增大栈大小，但这并不是一个持久的解决方案，更好的方法是改进代码以减少栈的使用。</p><p>有了new是不是可以就不用malloc了？<br>比如内存池，在这个基础上可以利用placement new<br>c 没有new</p><p>malloc是如何跟物理地址关联上的？<br>malloc申请内存返回的是虚拟地址而不是物理地址，而且，返回的这个虚拟地址是没有map映射到物理内存中的，只有当程序(进程)用到访问了这个地址的时候，</p><p>内核才响应“缺页异常”，才回去映射一块物理地址。</p><p>关于malloc(0) 能申请成功是肯定的，它返回的是虚拟地址(对应的物理地址还不确定的)，在你没用到这块地址空间的时候，它不会再物理上开辟内存。</p><p>在你用到malloc(0)返回的地址时，因为参数为0，缺页异常不会为你的进程空间申请额外内存。所以这个指针应该是不能用的。</p><p>new&#x2F;delete malloc&#x2F;free 区别<br>运算符库函数<br>构造函数析构函数<br>可以重载<br>手动计算大小，自动计算大小<br>类型安全<br>返回值<br>讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常<br>调用malloc+构造函数<br>nothrow指定<br>bad——alloc</p><p>malloc线程安全吗，多线程malloc系统怎么设计<br>在多线程环境下，使用 malloc() 和 free() 函数需要特别注意，因为这两个函数都会涉及到内存的分配和释放，容易引起多线程竞争问题，可能会导致内存泄漏或程序崩溃。</p><p>要在多线程环境下安全地使用内存分配和释放函数，你可以考虑以下几种方法：</p><p>使用线程局部存储（Thread-Local Storage，TLS）：每个线程拥有独立的内存池来分配和释放内存。这可以减少线程间的竞争条件。你可以使用pthread库提供的pthread_key_create和pthread_setspecific函数来创建和管理线程局部存储。</p><p>使用锁：在malloc和free的调用中使用互斥锁，确保每次只有一个线程可以访问内存分配和释放函数。这会降低并发性能，但可以确保安全性。请注意，过多地使用锁可能会引发性能问题，因此需要权衡使用。</p><p>使用线程安全的内存分配函数：一些库提供了线程安全的内存分配函数，例如pthread_malloc。这些函数会在内部使用锁或其他机制来保证多线程安全。</p><p>自定义内存分配器：你可以实现自己的内存分配器，针对多线程环境进行优化。这需要深入了解内存分配算法和多线程编程，需要谨慎处理锁的使用和内存池的管理。</p><p>C++内存分布。什么样的数据在栈区，什么样的在堆区。<br>局部栈区，全局堆区</p><p>C++内存管理（RAII啥的）<br>资源获取即初始化。使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><p>size_of是在编译期还是在运行期确定<br>sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。</p><p>C++ 如何调整内存对齐值<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br>更改C编译器的缺省字节对齐方式：</p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：</p><p>使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。<br>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</p><p>主机大小端序<br>C&#x2F;C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而现在比较普遍的x86处理器是小端模式（Little Endian）。Java编写的程序则唯一采用Big Endian方式来存储数据。</p><p>C++内存泄漏问题<br>在类的构造函数和析构函数中没有匹配的调用new和delete函数<br>两种情况下会出现这种内存泄露：<br>在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；<br>在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存。<br>没有正确地清除嵌套的对象指针<br>在释放对象数组时在delete中没有使用方括号<br>没有将基类的析构函数定义为虚函数<br>能说一下内存泄漏发生的情景吗<br>忘记释放动态分配的内存：程序使用malloc、new等动态分配内存，但忘记在使用完毕后调用free、delete等来释放这些内存。</p><p>使用循环引用的数据结构：在某些情况下，例如使用引用计数的内存管理方式，如果存在循环引用，可能导致内存无法被正确释放，即使没有引用指向这部分内存，它也不会被释放。</p><p>全局数据指针不被清理：在程序运行过程中分配的全局数据，如果在程序结束时没有被正确清理释放，就会导致内存泄漏。</p><p>异常处理不当：如果在异常处理中没有适当地释放内存，就会导致内存泄漏。例如，某个异常发生时，释放了一部分内存，但后续的异常处理没有释放剩余的内存。</p><p>资源管理错误：不仅仅限于内存，其他资源如文件、网络连接等也需要适当的释放。如果程序在使用完这些资源后没有正确关闭或释放，就可能发生资源泄漏。</p><p>线程问题：在线程中分配的内存，如果在线程退出前没有被释放，会导致内存泄漏。同样，在多线程环境中，如果多个线程共享内存，而没有正确同步释放，也可能导致内存泄漏。</p><p>sizeof一个空的结构体，返回什么<br>1个字节。这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</p><p>空结构体虽然不包含任何成员变量，但在某些情况下仍然具有一定的作用。以下是一些空结构体的常见用途：</p><p>比如接口，一个抽象类</p><p>占位符：空结构体可以用作占位符，用于表示某些特定的语义，或在其他数据结构中起到标记的作用。例如，在链表的节点中，可以使用一个空结构体作为尾节点的标记，以便于在遍历链表时判断是否到达了链表的末尾。</p><p>语义明确：在一些代码中，可能需要声明一个类型来表示某种概念或行为，而不需要实际的数据成员。这可以使代码更具语义明确性，使其他开发人员更容易理解你的意图。</p><p>接口一致性：在一些接口设计中，为了保持一致性，可能需要在某些情况下返回一个类型，即使这个类型不包含任何实际数据。这种情况下，可以使用空结构体来满足接口定义的需求。</p><p>辅助编程技巧：有时，空结构体可以用于一些特殊的编程技巧，例如在模板元编程（Template Metaprogramming）中，可以使用空结构体来触发模板特化或实现条件编译等。</p><p>扩展性：在设计复杂的数据结构或库时，留出空结构体作为未来扩展的可能性，以便在需要时添加新的成员变量而不会破坏现有的接口。</p><p>堆和栈的区别<br>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。<br>碎片问题：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。<br>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>详细阐述堆栈的区别<br>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；<br>（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；<br>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。<br>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。<br>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。<br>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><p>堆和栈的区别。什么情况下会往堆里放<br>new<br>malloc</p><p>堆区都是手动释放？<br>答：也不一定，主要看使用方法。如果使用的函数是malloc，new之类，就需要手动释放，不然会造成内存泄漏。但是如果我们使用智能指针，智能指针会自动释放内存，因为智能指针基于类自动调用析构函数实现了内存的自动释放</p><p>野指针和内存泄漏是什么，如何避免？<br>野指针（Dangling Pointer）: 野指针是指指向已经被释放或者无效的内存地址的指针。当你释放了某块内存并且后续仍然使用指向这块内存的指针，就会产生野指针。这可能导致不可预测的行为，包括程序崩溃。</p><p>避免野指针的方法：</p><p>在释放内存后，将指针置为 NULL。<br>避免在超出作用域的情况下继续使用指针。<br>使用智能指针来管理资源，智能指针会在资源不再需要时自动释放。<br>内存泄漏（Memory Leak）: 内存泄漏指的是程序分配了内存但没有在不再需要时释放它，导致程序持续占用内存而不归还给系统。如果内存泄漏严重，会导致程序运行变慢，最终耗尽系统内存。</p><p>避免内存泄漏的方法：</p><p>保持良好的内存管理习惯，每次分配内存后，一定要在不需要时释放。<br>注意及时释放不再需要的动态分配的内存（使用 delete 或 free），避免忘记释放。<br>使用 RAII（Resource Acquisition Is Initialization）的思想，利用对象的析构函数来管理资源，确保资源在不再需要时会被自动释放。</p><p>如何防止内存泄漏<br>智能指针<br>清理资源的异常安全性: 在使用异常处理时，确保资源在异常情况下也能得到正确释放。最好使用 RAII 来保证在出现异常时资源能够被正确清理。</p><p>避免循环引用: 当对象之间存在循环引用时，可能导致资源无法被释放。确保使用适当的智能指针、弱引用（std::weak_ptr）来打破循环引用，使对象可以正确释放。</p><p>内存泄漏怎样应对<br>智能指针</p><p>怎么debug，怎么看内存泄漏。<br>使用调试器： 最基本的方法是使用调试器，如GDB（Linux），LLDB（macOS），或Visual Studio Debugger（Windows）。您可以设置断点，单步执行代码，观察变量的值，以查找问题。使用调试器是解决各种程序错误的关键。</p><p>打印调试信息： 在关键点打印变量的值、消息或日志，以了解程序执行的状态。使用cout（或printf）语句在代码中插入输出语句，然后查看控制台或日志文件。</p><p>内存检测工具： C++具有一些内存检测工具，如Valgrind（Linux），Dr. Memory（跨平台），以及内置的工具如MemoryLeakDump（Windows）。这些工具可以帮助您检测内存泄漏和潜在的内存问题。</p><p>使用智能指针： 使用智能指针（例如std::shared_ptr和std::unique_ptr）可以减少手动内存管理的错误，因为它们会在对象不再需要时自动释放内存。</p><p>静态分析工具： 使用静态代码分析工具（例如Clang Static Analyzer或PVS-Studio）来检测潜在的问题，包括内存泄漏。</p><p>内存泄漏检测工具： 使用专门的内存泄漏检测工具，如Valgrind的Memcheck工具，来分析程序的内存使用情况。</p><p>代码审查： 请同事或朋友审查您的代码，因为其他人可能会发现您忽略的问题。</p><p>单元测试： 编写单元测试，以确保各个组件的正确性。一些测试框架和工具可以检测内存泄漏。</p><p>规范和最佳实践： 遵循C++的最佳实践和规范，如RAII（资源获取即初始化），以确保正确的资源释放。</p><p>编译过程<br>C++从源程序到可执行程序的过程<br>问了c++文件编译过程<br>预编译 cpp<br>汇编 i<br>编译 s<br>链接 o</p><p>.cpp编译生成二进制文件过程<br><a href="https://whl963854.github.io/p/43341.html">https://whl963854.github.io/p/43341.html</a></p><p>静态链接动态链接区别<br><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><p>动态链接库具体怎样操作链接的<br>重定位 忘了待更新<br>编写源代码: 首先，你需要编写要包含在动态链接库中的源代码，这可以是一组函数、类或其他可以在多个程序中共享的代码。通常，你需要在这些代码上使用适当的导出修饰符，以告诉编译器哪些函数或符号应该在库中导出。</p><p>编译源代码: 使用编译器将源代码编译成目标代码（Object Files）。</p><p>创建动态链接库: 使用链接器将目标代码文件链接成一个动态链接库文件（通常是DLL文件）。在这个过程中，链接器会处理导出的符号表，以便其他程序可以在运行时找到和使用这些符号。</p><p>程序链接时引用: 当你编译另一个程序时，如果你希望使用动态链接库中的函数或符号，你需要在程序的编译和链接过程中将动态链接库引入。这可以通过指定链接选项来完成，例如在gcc中使用-l标志指定要链接的库。</p><p>运行时加载: 当程序运行时，操作系统会加载动态链接库的代码和数据到内存中。这个加载过程通常发生在程序启动时，操作系统会根据程序的链接信息加载所需的动态链接库。</p><p>符号解析: 在运行时，程序中的符号引用会被解析为动态链接库中的实际地址。这个解析过程由操作系统的动态链接器完成。</p><p>c++学的好的是哪块 具体说<br>学得最好的是没有</p><p>智能指针<br>智能指针<br><a href="https://whl963854.github.io/p/47718.html">https://whl963854.github.io/p/47718.html</a></p><p>make_shared 和 make_unique 都是哪个版本的 C++ 引入的？<br>make_shared 是 C++ 11；make_unique 是 C++ 14</p><p>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用<br>shared_ptr循环引用怎么解决<br>weak_ptr</p><p>make_shared和shared_ptr<br>std::shared_ptr构造函数会执行两次内存申请，而std::make_shared则执行一次。<br>std::shared_ptr在实现的时候使用的refcount技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr p2(new A)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared()则是只执行一次内存申请，将数据和控制块的申请放到一起。</p><p>异常安全<br>考虑下面一段代码：</p><p>void f(std::shared_ptr<Lhs> &amp;lhs, std::shared_ptr<Rhs> &amp;rhs){…}</Rhs></Lhs></p><p>…</p><p>f(std::shared_ptr<Lhs>(new Lhs()),std::shared_ptr<Rhs>(new Rhs()));<br>复制代码<br>因为C++允许参数在计算的时候打乱顺序，因此一个可能的顺序如下:</Rhs></Lhs></p><p>new Lhs()<br>new Rhs()<br>std::shared_ptr<br>std::shared_ptr<br>复制代码<br>此时假设第2步出现异常，则在第一步申请的内存将没处释放了，上面产生内存泄露的本质是当申请数据指针后，没有马上传给std::shared_ptr，因此一个可能的解决办法是：</p><p>auto lhs &#x3D; std::shared_ptr<Lhs>(new Lhs());<br>auto rhs &#x3D; std::shared_ptr<Rhs>(new Rhs());<br>f(lhs, rhs);<br>复制代码<br>当然更好的方法是：</Rhs></Lhs></p><p>f(std::make_shared<Lhs>(),<br>    std::make_shared<Rhs>()<br>);<br>复制代码<br>make_shared的缺点<br>因为make_shared只申请一次内存，因此控制块和数据块在一起，只有当控制块中不再使用时，内存才会释放，但是weak_ptr却使得控制块一直在使用。</Rhs></Lhs></p><p>什么是weak_ptr？<br>weak_ptr是用来指向shared_ptr，用来判断shared_ptr指向的数据内存是否还存在了（通过方法lock），下面是一段示例代码：</p><p>#include <memory><br>#include <iostream><br>using namespace std;<br>struct A{<br>    int _i;<br>    A(): _i(int()){}<br>    A(int i): _i(i){}<br>};</iostream></memory></p><p>int main()<br>{<br>    shared_ptr<A> sharedPtr(new A(2));<br>    weak_ptr<A> weakPtr &#x3D; sharedPtr;<br>    sharedPtr.reset(new A(3)); &#x2F;&#x2F; reset，weakPtr指向的失效了。<br>    cout &lt;&lt; weakPtr.use_count() &lt;&lt;endl;<br>}<br>复制代码<br>通过lock（）来判断是否存在了，lock（）相当于</A></A></p><p>expired（）？shared_ptr<element_type>() ： shared_ptr<element_type>(*this)<br>复制代码<br>当不存在的时候，会返回一个空的shared_ptr，weak_ptr在指向shared_ptr的时候，并不会增加ref count，因此weak_ptr主要有两个用途：</element_type></element_type></p><p>用来记录对象是否存在了<br>用来解决shared_ptr环形依赖问题<br>STL<br>vector的clear的时间复杂度，内存是怎么分布的，如何释放内存<br>vector().swap(v);<br>C++11推出了shrink_to_fit方法，也可以达到目的。<br>v.clear();<br>v.shrink_to_fit();</p><p>STL容器中是否了解线程相关的函数？不了解…<br>多线程一写多读STL容器也不是线程安全的<br>并发多个线程去写STL容器（“写”指的是插入新元素） 不是线程安全的，可能会触发core dump。但大家可能常常忽略一种不常见的情况：一个线程写，其他线程都是读的时候 其实也不是线程安全的。</p><p>比如vector，尽管只有一个线程来写入，但是如果他触发了扩容了。那么其他线程尽管是只读这个vector的，其中的迭代器也会失效。对于unordered_map也是类似，单线程不停插入元素的话，可能触发rehash，导致其他线程中在unordered_map中find的过程中core dump。</p><p>vector 扩容, 开放题: 1.5 和 2倍扩容什么区别<br>1.5倍会使用之前释放的空间</p><p>map和set<br>底层红黑树，剩下不会了</p><p>迭代器作用 迭代器和指针的区别<br><a href="https://whl963854.github.io/p/2cf69f40.html">https://whl963854.github.io/p/2cf69f40.html</a></p><p>介绍一下map容器？<br>答：map支持kv键值对的查找，底层基于红黑树，查询和插入的时间复杂度都是logn。因为底层基于红黑树，map的key是有序的，所以map容器为我们提供了一些有序的api，比如对key的二分查找(lower_bound）。与此同时，我们还有unoredered_map,这个容器是哈希表，查询和插入的时间复杂度是O(1)，但是如果遇上哈希冲突，复杂度可能退化到O(n)。这个容器的key是无序的。unordered_map的使用的常数时间是要比map快一到两倍。</p><p>动态链接和静态链接区别。<br><a href="https://whl963854.github.io/p/43574.html">https://whl963854.github.io/p/43574.html</a></p><p>如何优化一个c++程序,局部性<br>时间局部性<br>空间局部性</p><p>左值，右值，万能引用，完美转发<br><a href="https://whl963854.github.io/p/64657.html">https://whl963854.github.io/p/64657.html</a><br><a href="https://whl963854.github.io/p/3763.html">https://whl963854.github.io/p/3763.html</a><br><a href="https://whl963854.github.io/p/50074.html">https://whl963854.github.io/p/50074.html</a></p><p>STL基本容器用过哪些<br>vector<br>string<br>stack<br>queue<br>set<br>map</p><p>三种继承方式(public protected private)及区别<br>二叉树应用场景 底层结构<br>说下哈希底层原理是什么，怎么用的，怎么解决冲突的，怎么扩容的<br>了解哪些算法，说一点———–我说了排序<br>介绍下快速排序的过程<br>栈和队列的区别，在实际应用中的场景<br>队列</p><p>队列是一种先进先出的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；<br>打印机：当多个任务分配给打印机时，为了防止冲突，创建一个队列，把任务入队，按先入先出的原则处理任务；<br>远程服务器：当多个用户要访问远程服务端的文件时，也用到队列，满足先来先服务的原则；<br>队列理论：用来计算 预测用户在队中的等待时间，队的长度等等问题；<br>常用于处理任务请求队列，例如在操作系统内部处理进程队列、在网络传输协议中处理数据包队列等。</p><p>栈</p><p>栈是一种后进先出的数据结构，也就是说最新添加的项最早被移出；它是一种运算受限的线性表，只能在栈顶进行插入和删除操作。向一个栈插入新元素叫入栈（进栈），就是把新元素放入到栈顶的上面，成为新的栈顶；从一个栈删除元素叫出栈，就是把栈顶的元素删除掉，相邻的成为新栈顶。</p><p>用于符号的匹配：在编译器的语法检查中，一个过程就是检查各种括号是否匹配，比如 ([]) ，这就是匹配的，而 {[}] 就不匹配了。<br>用于计算代数式：如果我们要计算 6 + 4 * 8 ，要考虑到优先级的问题；先要把代数式构造成 6 4 8 * + 的形式；逐个读取数据，当读到数字时，把数字入栈；读到运算符时，弹出栈中的两个元素进行运算并把结果压入栈中；<br>构造表达式：比如一个正常的代数式（叫他infix）, a + b * c + ( d * e + f ) * g , 转化成表达式 a b c * + d e * f + g * +, 这个表达式我们叫他 postfix。（先规定优先级，加减的优先级最低，左括号优先级最高）<br>用于函数调用：因为CPU一次只能执行一个命令，而寄存器也是公用的，当前函数 current() 在运行时，数据储存在寄存器中，如果要调用另外一个函数 target()，而target() 也要求使用寄存器，为了防止数据丢失并且在执行完 target()。能够返回到 current() 继续执行, 这时候就要把当前函数的重要数据储存起来，压入内存中的栈中( 包括变量的值和函数地址 )。这样target()函数就可以无所顾忌的使用寄存器了。target() 函数执行结束就取栈顶的返回地址继续执行 current()。</p><p>手撕二分查找。<br>数据结构常用的STL<br>多线程<br>C++ Coroutine<br>多线程和多进程都能实现并发，什么情况下用多进程，什么情况下用多线程？<br>使用多线程和使用多进程的选择取决于您的应用程序的需求。</p><p>多线程：在同一个进程中创建多个线程，多个线程共享进程的内存空间，因此它们可以很容易地共享数据，而且通信成本更低。因此，如果您的应用程序需要在单个进程内部并行执行不同任务，并且需要共享大量数据，则多线程是一个很好的选择。</p><p>多进程：当您的应用程序需要在不同的进程之间并行执行任务时，您可以使用多进程。不同进程之间的通信通常比同一进程中的通信慢，但它们拥有完全独立的内存空间，因此不存在内存访问冲突的问题。</p><p>总的来说，多线程适用于在单个进程中并行执行任务，并且需要共享大量数据的情况，而多进程适用于在不同进程中并行执行任务的情况。</p><p>你这个项目是多线程的，那用多进程可不可以实现？<br>项目相关介绍一下<br>介绍一下条件变量<br>为什么要用线程池<br>为什么要用多线程。多进程可以吗（webserver的）<br>了解线程池吗？线程池是怎么实现的？代码是你自己写的吗？<br>线程池中的队列知道吗？队列是无限大的还是有限的<br>项目中有渲染相关，问了渲染<br>介绍一下线程的几种状态。<br>一个服务器上可以部署多个同样的进程吗？如果可以，为什么可以？客户端怎么知道是哪个进程提供服务？<br>了解线程池吗？大概介绍一下<br>多线程会发生什么问题？线程同步有哪些手段？<br>什么是线程池，怎么创建，怎么设置参数，什么时候创建，什么时候销毁？<br>设计模式<br>说说对设计模式的理解<br>了解设计模式吗？介绍一下单例模式<br>了解的设计模式<br>单例<br>组件</p><p>手撕一个设计模式<br>手写一个单例模式<br>设计模式几大原则<br>手撕单例模式（懒汉模式）<br>情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统<br>模板元编程（简历上写了，但答的不好）<br>编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的<br>语法特性<br>C++11特性了解多少？<br>我了解C++11的特性相当丰富。以下是一些C++11引入的重要特性：</p><p>右值引用和移动语义：引入了右值引用，允许移动语义，从而提高了性能，减少了不必要的拷贝操作。这对于处理大型数据结构和资源管理非常有用。</p><p>智能指针：引入了std::shared_ptr和std::unique_ptr等智能指针，用于更安全和方便的内存管理。</p><p>Lambda表达式：允许在函数内部定义匿名函数，提高了代码的可读性和可维护性。</p><p>范围-based for循环：引入了for-each循环，简化了遍历容器和数组的过程。</p><p>auto关键字：允许编译器根据变量的初始化值推断其类型，提高了代码的可读性和可维护性。</p><p>nullptr：引入了明确的空指针常量nullptr，用于取代传统的NULL或0，以减少指针引起的歧义。</p><p>初始化列表：引入了std::initializer_list，用于初始化容器和自定义类型。</p><p>委托构造函数：允许一个构造函数调用同一个类的其他构造函数，减少了冗余代码。</p><p>多线程支持：引入了std::thread，std::mutex，std::condition_variable等多线程支持库。</p><p>新的容器和算法：引入了新的容器，如std::unordered_map和std::unordered_set，以及新的算法和函数，如std::move，std::forward，std::chrono等。</p><p>静态断言：引入了static_assert，用于在编译时检查条件。</p><p>显式虚函数重写：引入了关键字override和final，用于明确指示虚函数的重写和禁止重写。</p><p>类型推导：引入了auto关键字和decltype运算符，用于更好地处理模板和泛型编程。</p><p>讲一讲const关键字。<br>答：const关键字在C++11之前，具有只读和常量两个语义。在C++11，引入constexpr关键字之后，const语义固定在了只读，constexpr固定为常量，但总而言之，这个两个关键字核心的语义是，指向的内容不可更改。<br>const 关键字用于指定变量或对象的值是不可修改的。它可以用于修饰变量、函数参数、函数返回值和成员函数等。 constexpr 关键字用于指定表达式在编译时就能够被计算出结果，从而产生一个编译期常量。它可以用于修饰变量、函数、类和模板等。constexpr 的作用是在编译时进行计算，从而提高程序的性能。</p><p>四大强制类型转换<br><a href="https://whl963854.github.io/p/63561.html">https://whl963854.github.io/p/63561.html</a></p><p>指针和引用区别<br>那const指向地址呢？<br>答：const指向的地址值不可更改，但是地址对应的内容是可更改的。</p><p>const关键字修饰类的对象使用起来有什么限制？<br><a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><p>const关键字修饰类的对象有什么办法改变内部数据？<br>mutable <a href="https://whl963854.github.io/p/c082d8df.html">https://whl963854.github.io/p/c082d8df.html</a></p><p>C++你觉得最特别于其他语言的点是什么<br>多范式支持: C++ 是一门多范式的语言，支持面向对象编程、泛型编程和过程式编程。这意味着你可以根据问题的需求选择合适的编程方式，使得 C++ 可以用于各种不同的应用领域。</p><p>性能和控制: C++ 提供了低级别的内存控制，允许程序员直接管理内存、精细控制数据布局和算法。这使得 C++ 成为高性能应用程序（如游戏引擎、系统编程）的首选语言之一。</p><p>STL（Standard Template Library）: C++ 的标准模板库（STL）提供了丰富的数据结构和算法。STL 的使用简化了代码编写，提高了开发效率，同时保证了高性能。</p><p>运算符重载: C++ 允许你自定义运算符的行为，使得用户自定义的类型可以使用与内置类型相似的语法，增加了代码的可读性。</p><p>强大的类型系统: C++ 提供了丰富的类型系统，包括类、枚举、联合、指针、引用等，这使得 C++ 能够更好地表示和组织复杂的数据。</p><p>兼容 C: C++ 是 C 的扩展，兼容 C 语言。这意味着你可以在 C++ 中直接使用 C 的代码，C++ 可以很好地与 C 代码互操作。</p><p>资源管理: C++ 支持 RAII（Resource Acquisition Is Initialization）的概念，即资源的获取和释放应该在对象的构造和析构时完成。这有助于自动资源管理，避免资源泄漏。</p><p>模板元编程: C++ 允许使用模板来实现元编程，这意味着你可以在编译时进行计算，生成类型安全的代码，提高性能和灵活性。</p><p>java，python，c++垃圾回收怎么实现的<br>Java:<br>Java 使用自动垃圾回收（Automatic Garbage Collection）来管理内存。它主要依赖于 Java 虚拟机（JVM）的垃圾回收器，以下是一些 Java 垃圾回收的关键特点：</p><p>分代垃圾回收: Java 堆内存被划分为年轻代（Young Generation）、年老代（Old Generation）和永久代（Permanent Generation）。垃圾回收器主要集中在年轻代，因为大部分对象都具有短暂的生命周期。<br>GC 算法: Java 有不同的垃圾回收算法，如标记-清除（Mark-Sweep）、复制（Copying）、标记-压缩（Mark-Compact）等。不同的垃圾回收器使用不同的算法。<br>停顿时间控制: 一些 Java 垃圾回收器致力于减少应用程序停顿时间，例如 G1（Garbage-First）垃圾回收器。<br>Python:<br>Python 使用引用计数和循环引用检测的组合来实现垃圾回收。以下是关于 Python 垃圾回收的主要特点：</p><p>引用计数: 每个对象都有一个引用计数，当引用计数为零时，对象就会被释放。<br>循环引用检测: Python 运行时会定期检测循环引用（两个或多个对象互相引用，但再没有外部引用时无法访问）并清除它们。<br>C++:<br>C++ 并没有内置的自动垃圾回收机制，但是可以通过一些库来实现。例如：</p><p>智能指针: C++11 引入了智能指针，如 std::shared_ptr 和 std::unique_ptr。这些智能指针使用引用计数和所有权的概念来管理资源。<br>RAII: Resource Acquisition Is Initialization 是一种 C++ 的编程范式，通过对象生命周期来管理资源（如内存、文件句柄等）的分配和释放。</p><p>指针和引用的区别，左值右值，右值引用<br>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。<br>可以有const指针，但是没有const引用；<br>指针可以有多级，但是引用只能是一级<br>指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或–</p><p>引用在汇编层面会被c++编译器当做const指针来进行操作</p><p>说说对指针和引用的理解<br>右值引用，作用？<br>右值引用是 C++ 11 引入的特性，为了解决拷贝语义带来的对对象传递带来的开销（以值传递的方式返回某一个对象，在 vs 编译器中需要调用一次拷贝构造函数，用临时变量保存返回出来的对象的值，然后再把这个对象的值的临时变量拷贝给弹栈后的父域函数中的接收该函数返回值的对象变量中，因为无法管理右值的生命周期导致的无用开销），用右值引用可以延长右值的生命周期，用移动语义解决值传递问题，可以避免无用的拷贝开销</p><p>右值引用（Rvalue Reference）在C++11引入的特性中有多重重要作用，不仅仅用于解决拷贝语义带来的开销。以下是右值引用的一些主要作用：</p><p>移动语义：右值引用使得在合适的情况下，可以将资源（如堆内存）从一个对象“移动”到另一个对象，而不是传统的拷贝。这降低了内存和性能开销，特别对于大型数据结构或资源密集型操作非常有用。移动语义可以通过移动构造函数和移动赋值运算符实现。</p><p>完美转发：右值引用允许函数参数接受任何类型的值，包括左值和右值。这在实现泛型编程时非常有用，例如STL容器和智能指针。</p><p>减少不必要的拷贝：右值引用可以延长右值（临时对象）的生命周期，以避免不必要的拷贝操作。这在函数返回右值或传递右值参数时可以提高性能。</p><p>移动语义的容器：右值引用的引入使STL容器如std::vector，std::map等，能够实现高效的元素移动操作，而不是必须拷贝所有元素。</p><p>实现性能优化：通过允许移动语义和右值引用，程序员可以更精细地控制内存和性能，从而实现性能优化。</p><p>支持移动语义的标准库类型：C++标准库中的许多类型，如std::unique_ptr，std::shared_ptr，std::string等，都使用了右值引用和移动语义来提高性能。</p><p>总之，右值引用在C++中引入了一些重要的性能优化和灵活性，可以帮助程序员更好地管理资源和减少不必要的拷贝操作。它是现代C++编程中的关键特性之一。</p><p>C++哪些运算符不能重载？<br>答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p><p>以下运算符不能被重载：.、.*、::、? :、sizeof。<br>重载运算符()、[]、-&gt;、或者赋值运算符&#x3D;时，只能将它们重载为成员函数，不能重载为全局函数。</p><p>char *p &#x3D; {“123”}和char p[] &#x3D; {“1”, “2”, “3”} 的区别<br>4 3 size</p><p>C++11的特性有没有<br>初始化列表 使用 {} 可以方便地初始化数组、结构体、类等对象<br>智能指针 引入了 std::unique_ptr、std::shared_ptr 等智能指针，方便地进行动态内存管理<br>nullptr<br>注解标签noreturn<br>mutex 条件变量<br>lambda表达式 可以在函数内部定义匿名函数，从而方便地实现函数对象。<br>字符串字面量<br>auto 自动类型推导：使用关键字 auto 可以让编译器自动推导变量的类型。<br>枚举类<br>完美转发<br>移动语义 使用 &amp;&amp; 可以表示右值引用，引入了移动构造函数和移动赋值运算符，可以减少不必要的拷贝。<br>constexptr<br>静态断言 使用关键字 static_assert 可以在编译时检查一个表达式是否为 true<br>新的容器和算法：引入了 std::array、std::forward_list、std::unordered_map、std::move 等新特性，增强了容器和算法库的功能。</p><p>聊一聊你理解的移动构造函数？<br>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。</p><p>那c++有哪些构造函数呢？<br>答：默认构造函数，有参构造函数，拷贝构造函数，移动构造函数。<br>委托构造函数<br>继承构造函数</p><p>一个对象&#x3D;另一个对象会发生什么（赋值构造函数）<br>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）<br>py修饰器<br>函数重载的机制。重载是在编译期还是在运行期确定<br>hash表数据很大。rehash的代价很高，怎么办<br>为字典的备用哈希表分配空间：</p><p>如果执行的是扩展操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)*2 的 2n（2 的 n 次方幂）</p><p>如果执行的是收缩操作，那么备用哈希表的大小为第一个大于等于(已用节点个数)的 2n</p><p>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0，表示 rehash 工作正式开始（为-1 时表示没有进行 rehash）。</p><p>rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当一次 rehash 工作完成之后，程序将 rehashidx 属性的值+1。同时在 serverCron 中调用 rehash 相关函数，在 1ms 的时间内，进行 rehash 处理，每次仅处理少量的转移任务(100 个元素)。</p><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为-1，表示 rehash 操作已完成。</p><p>mmap<br>temp<br>空类是否具有虚函数指针<br>虚继承解决什么问题, 虚继承的内存分布 继承、虚继承、虚函数内存分布（MSVC下）_JACKSONMHLN的博客-CSDN博客<br>了解traits吗，它的作用是什么；<br>“Traits” 是一种编程技术，通常用于C++编程中，用于将类型相关的信息（如类型特性）与代码分离，以增强代码的可重用性和泛化性。Traits 主要用于元编程（metaprogramming）和泛型编程，它的作用是帮助程序员定义和使用通用的操作，而不是为每种特定类型编写特定的操作。</p><p>#include <iostream></iostream></p><p>&#x2F;&#x2F; 枚举类型，表示不同的数据类型<br>enum DataType {<br>    INT,<br>    FLOAT,<br>    STRING<br>};</p><p>&#x2F;&#x2F; Traits 类，用于为不同数据类型提供类型信息<br>template <typename t><br>struct TypeTraits {<br>    static const DataType dataType &#x3D; INT; &#x2F;&#x2F; 默认类型为整数<br>};</typename></p><p>template &lt;&gt;<br>struct TypeTraits<float> {<br>    static const DataType dataType &#x3D; FLOAT; &#x2F;&#x2F; 浮点数类型<br>};</float></p><p>template &lt;&gt;<br>struct TypeTraits<a href="std::string">std::string</a> {<br>    static const DataType dataType &#x3D; STRING; &#x2F;&#x2F; 字符串类型<br>};</p><p>&#x2F;&#x2F; 函数模板，根据数据类型进行不同操作<br>template <typename t><br>void ProcessData(const T&amp; data) {<br>    switch (TypeTraits<T>::dataType) {<br>        case INT:<br>            std::cout &lt;&lt; “Processing Integer: “ &lt;&lt; data &lt;&lt; std::endl;<br>            break;<br>        case FLOAT:<br>            std::cout &lt;&lt; “Processing Float: “ &lt;&lt; data &lt;&lt; std::endl;<br>            break;<br>        case STRING:<br>            std::cout &lt;&lt; “Processing String: “ &lt;&lt; data &lt;&lt; std::endl;<br>            break;<br>        default:<br>            std::cout &lt;&lt; “Unknown Data Type” &lt;&lt; std::endl;<br>            break;<br>    }<br>}</T></typename></p><p>int main() {<br>    int intData &#x3D; 42;<br>    float floatData &#x3D; 3.14;<br>    std::string stringData &#x3D; “Hello, World!”;</p><pre><code>ProcessData(intData);ProcessData(floatData);ProcessData(stringData);return 0;</code></pre><p>}<br>复制代码<br>我们想要为这些不同的类型提供统一的编码函数 decode() ，该怎样实现呢？</p><p>下面我们尝试使用模板函数来实现，自定义数据类型中定义类型字段，然后在函数中进行判断。</p><p>&#x2F;&#x2F; 自定义类型<br>enum Type {<br>TYPE_1,<br>TYPE_2<br>};<br>class Foo {<br>Type type &#x3D; Type::TYPE_1;<br>};<br>class Bar {<br>public:<br>Type type &#x3D; Type::TYPE_2;<br>};<br>&#x2F;&#x2F; 模板函数<br>template<typename t><br>void decode(const T&amp; data, char* buf) {<br>if(T::type &#x3D;&#x3D; Type::TYPE_1) {<br>    …<br>}<br>else if(T::type &#x3D;&#x3D; Type::TYPE_2) {<br>    ..<br>}<br>…<br>}<br>复制代码<br>这样一来，对于同一种自定义类型，我们只需要写一遍 decode 函数就可以了，但是对于系统自定义变量 int, double 而言，是无法在其内部定义 type 的，这时候我们该怎么办呢？这时候就需要用到 traits 技术了。</typename></p><p>方案三：traits 模板类<br>traits 技术的关键在于，使用另外的模板类 type_traits 来保存不同数据类型的 type，这样就可以兼容自定义数据类型和内置数据类型，代码如下：</p><p>&#x2F;&#x2F; 定义数据 type 类<br>enum Type {<br>TYPE_1,<br>TYPE_2,<br>TYPE_3<br>}<br>对于自定义类型，与方案二中类似，我们在类内部定义了数据类型 type，然后在 traits 类中定义同样的 type</p><p>&#x2F;&#x2F; 自定义数据类型<br>class Foo {<br>public:<br>Type type &#x3D; TYPE_1;<br>};<br>class Bar {<br>public:<br>Type type &#x3D; TYPE_2;<br>};<br>template<typename t><br>struct type_traits {<br>Type type &#x3D; T::type;<br>}<br>复制代码<br>对于内置数据类型，使用模板类的特化为自定义类型生成独有的 type_traits（感谢指证，模板类的特化类型应该写在类名后面）</typename></p><p>&#x2F;&#x2F; 内置数据类型<br>template&lt;&gt;<br>struct type_traits<int> {<br>Type type &#x3D; Type::TYPE_1;<br>}<br>template&lt;&gt;<br>struct type_traits<double> {<br>Type type &#x3D; Type::TYPE_3;<br>}<br>这样就可以为不同数据类型生成统一的模板函数</double></int></p><p>&#x2F;&#x2F; 统一的编码函数<br>template<typename t><br>void decode&lt;const T&amp; data, char* buf) {<br>if(type_traits<T>::type &#x3D;&#x3D; Type::TYPE_1) {<br>    …<br>}<br>else if(type_traits<T>::type &#x3D;&#x3D; Type::TYPE_2) {<br>    …<br>}<br>}<br>复制代码<br>怎么在栈上动态分配内存 (回答用 placement_new 不知道对不对 )<br>栈也是能动态分配的，C语言提供了alloca函数让程序员动态分配栈内存，且不需要手动释放，对没错，你来分配，主调函数返回时由编译器（生成的类析构程序）来给你擦屁股。但alloca不具可移植性, 而且在没有传统堆栈的机器上很难实现。当它的返回值直接传入另一个函数时会带来问题,因为他分配在栈上.</T></T></typename></p><p>由于这些原因, alloca不宜使用在必须广泛移植的程序中, 一般使用的很少，不管它可能多么有用</p><p>还知道哪些多态技术？函数模板<br>C++中的多态主要分为两类：</p><p>动态多态(dynamic polymorphism)<br>通过类继承和虚函数机制生效于运行期，也被称为运行时多态或子类型多态（Subtype polymorphism）。其可以优雅地处理异质对象集合，只要异质对象共同的基类定义了虚函数的接口。面向对象程序设计中指的多态就是动态多态。<br>静态多态(static polymorphism)<br>通过模板也能实现不同特殊行为和单个泛化记号相关联，但这种关联在编译期就完成了（通过给模板参数指定类型），因此也被称作编译时多态。其可以用来实现类型安全、运行高效的同质对象集合操作。C++ STL采用模板来实现就是个例子。</p><p>讲讲多态，动态多态怎么实现<br>三个类A、B、C，C继承B，B继承A，A中有一个虚函数，三个类对象的虚表和成员变量在内存中的分布。<br>函数模板底层工作原理是什么？<br>编译器并不是把函数模板处理成能够处理任意类的函数；编译器是根据函数模板调用时的具体类型产生不同的函数；<br>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译（这次只进行简单纠错，替换），在调用的时候还会进行一次编译，这次会产生具体的函数体，并调用之。</p><p>在调用函数时，栈会发生什么变化；<br>智能指针介绍，注意事项，可否在STL容器中使用<br>协程也会产生时间片的抢占，为什么协程好？<br>1<br>2、项目挑一个讲讲？<br>3、使用了什么设计模式？<br>4、</p><p>进程、线程间通信及同步的方法有什么？（进程通信：匿名管道，有名管道，消息队列，共享内存，信号量，信号，套接字；线程通信：共享进程的全局变量，信号量，消息传递（OC 中的 GCD 等）；进程同步：信号量，管程，消息传递；线程同步：信号量，互斥锁，条件变量等）<br>12 进程间通信最快的是什么？（共享内存）第二快的呢？（不会）</p><p>锁了解哪些（按加锁策略分：乐观锁：假定在访问过程中不会发生修改，访问后再判断版本号，查看是否在访问期间修改了（Git，共享文档常用；效率高，但对高并发效果差）、悲观锁：认为访问过程中会被修改，所以访问前就加锁（读写锁就是一类悲观锁）；按等待方式分：阻塞锁（阻塞未能获取到资源的进程，不再分配时间片，资源被释放时唤醒该进程，有上下文切换开销，适合大尺度时间调度）、自旋锁（让进程忙等，继续分配时间片，无上下文切换，但因为分配时间片忙等有开销，适合小尺度时间调度）；按加锁意图分：读锁（共享锁，S锁）：加读锁的资源还可以被想加读锁的进程获取，不能被想加写锁的进程获取、写锁（独占锁，X锁）：加写锁）：加写锁的资源不能被想加读锁的进程获取，也不能被想加写锁的进程获取；数据库中的锁（库级锁、表级锁（表结构锁，读写意向锁，表读写锁）、行级锁（行锁（读写锁），记录锁（读写锁），间隙锁（GAP 锁：锁区间、插入意向锁；锁点））：为实现数据库系统的隔离性）<br>C++ 11 thread 库中的 join 和 detach 的区别（join 是让父线程运行到 child thread.join() 处时，等待子线程的结束，并回收子线程资源，可以保证父线程不会在子线程结束之间结束；detach 是让该子线程与其父线程拆离父子关系，使子线程变成守护线程，与程序的主线程拥有相同的生命周期，结束时原子线程自己回收资源）<br>介绍一下同步和互斥的概念？<br>只使用互斥锁不可以实现同步吗？<br>多线程和多进程开发的区别？<br>进程调度算法？一下卡住了，让说了一个自己最熟悉的，我就说了个时间片轮转算法。<br>epoll 底层结构<br>怎么禁止动态分配内存<br>继承方式的作用是什么，分别举例三种不同继承方式的应用场景。。。<br>windows下的异常机制和处理<br>看你简历里面加粗了并行, qt多线程和windows多线程有什么区别</p><p>问题错误，协程是非抢占式多任务，线程是抢占式多任务。<br>服务器有没有部署上线。<br>说一下多态。<br>红黑树和bst的区别，红黑树的原理。</p><p>介绍一下容器。<br>给你1百万个数据，怎么来选择容器。<br>final和override关键字</p><p>给一个空类，sizeof是多少<br>怎么知道weak_ptr失效了没<br>多线程死锁怎么解决<br>c和c++编译区别（不会c）<br>讲讲linux 文件系统….. 不咋会 ,随便说说了软链接 和 硬链接<br>多进程 多线程 区别,<br>线程共享什么<br>线程同步和互斥 概念<br>虚拟内存<br>多线程之间怎么通信<br>信号量具体实现<br>我来问问，你对linux的了解？cmake会吗？<br>你怎么在make文件里动态编译静态编译的？<br>多线程gdb调试会用吗？（我就这节课没看。。。）<br>gdb调试如何回到上级函数<br>哦所以你就只会简单使用 &#x3D; &#x3D;</p><p>6.栈溢出，栈溢出的原因？还有吗？如何解决栈溢出？还有吗？<br>（4）一个空类在实例化对象后会自动生成哪些函数<br>（3）动态是什么，静态多态与动态多态的区别，静态多态有哪些？除了函数重载还有哪些。。。<br>8可调用对象（啥玩意？？后面查了一下是c++11新特性）<br>5、unique_ptr是什么？<br>6、make_unique是什么，它与new有什么区别？<br>7、unique_ptr怎么防止拷贝？<br>9、记事本敲归并排序（手口并用）</p><p> set存储自定义数据类型，要怎么做<br> unordered_set存储自定义数据类型，要怎么做<br> 左值和右值的区别<br> unique_ptr的实现原理<br>4、线程池的实现原理、线程数量的确定<br>一定要深挖项目，项目是面试的大头，从项目中能够了解到你个人的解决问题的能力和技术力，对于项目细节一定要反复打磨，最好将其记录在文本上，记下来避免临时组织语言带来的疏漏。<br>用过qt界面的哪些模块<br>有没有做过qt的重绘<br>qt信号槽跨线程用过没 怎么设置<br>虚继承解决什么问题, 虚继承的内存分布<br>windows下的异常机制和处理<br>什么是协程？协程相对于线程的优点有哪些？<br>线程间的同步有哪些，线程相对于进程的区别有哪些？<br>linux的线程有几个状态？<br>锁的分类;<br>了解过多态么？静态多态和动态多态在使用上的区别？<br>map的底层为什么是红黑树，红黑树和AVL树的区别？<br>C++、Python和Go的区别？<br>怎么看待工业软件的发展，和互联网相比呢？<br>了解过强弱符号么（这是啥？我根本不知道这是啥！）百度了一下，大概就是比如两个全局变量都命名为a，若一个进行了初始化，那么这个是强符号；另一个没有初始化，则这个是弱符号。或者两个重名的函数，编译时候可能会报重定义错误，那么可以通过weak属性声明，此时编译是没问题的，但是链接阶段会报错。<br>了解过链接顺序么？（有过这样的问题，但是解决了就没关注了，回答：不了解）<br>了解过函数调用约定么？（不了解不了解……）<br>百度看了一下大概就是__cdecl、__stdcall、__fastcall、__pascal、__thiscal<br>用windows排查过异常么？（排查过一次内存泄漏，但是忘了用了啥工具了）<br>windbg、crt、任务管理器、dump文件、debug_new……<br>详细说一下RPC的流程；<br>介绍一下自己对协程的理解；<br>说一下日志库的实现，有参考过哪些开源项目？<br>对自己的日志库有没有过测试？<br>现在要对日志文件进行每秒十几万行的写入，如何提升你的日志库性能：<br>线程底层有了解过么？（指令寄存器相关，一下子忘了是指令寄存器了，直接不了解）；<br>框架设计要考虑过哪些因素？（这里回答的乱七八糟的，主要结合多人开发去聊了聊单一职责、开放封闭啥的）<br>链路追踪用的啥？（记不得名字了，然后扯到了日志……）<br>linux开发时候怎么去定位错误调试的？（看日志、看进程线程号、打断点、gdb、主要聊了一次死锁的排查）<br>如果有时候偶然的数据出现问题，怎么排查？或者说常规的方法还能不能用？（模块化的测试、查看日志了解数据是个什么特殊情况、自动化测试……PS.啥是自动化测试啊……）<br>做测试用了哪些工具？（日志、Ping、curl、postman……反正就是看日志呗）<br>读研or工作的考虑<br>12、对于公司和行业怎么看？<br>13、平常的兴趣爱好是什么？<br>14、怎么看待加班现象？<br>自己最大的优点和缺点是什么？<br>为什么选中望？<br>自己经历过的压力最大的事情是什么？<br>最近主要是怎么提升自己的？<br>学习有计划么？<br>写博客的目的是什么<br>投了哪些，职业赛道选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;cpp&lt;br&gt;&lt;a href=&quot;https://www.dotcpp.com/course/808&quot;&gt;https://www.dotcpp.com/course/808&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面向对象&lt;br&gt;c++是面向对象的编程语言，能介绍一下c++面向对象的几个特性吗&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kubernetes介绍</title>
    <link href="http://example.com/p/39432f30.html"/>
    <id>http://example.com/p/39432f30.html</id>
    <published>2023-12-28T07:52:03.984Z</published>
    <updated>2023-12-29T10:01:15.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubernetes介绍"><a href="#kubernetes介绍" class="headerlink" title="kubernetes介绍"></a>kubernetes介绍</h1><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><p>Kubernetes 为你提供：<br>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。<br>• 存储编排<br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。<br>• 自动部署和回滚<br>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。<br>• 自动完成装箱计算<br>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来为容器分配资源。<br>• 自我修复<br>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。<br>• 密钥与配置管理<br>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kubernetes介绍&quot;&gt;&lt;a href=&quot;#kubernetes介绍&quot; class=&quot;headerlink&quot; title=&quot;kubernetes介绍&quot;&gt;&lt;/a&gt;kubernetes介绍&lt;/h1&gt;&lt;p&gt;Kubernetes 是一个可移植、可扩展的开源平台，用于管</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/p/f255ffad.html"/>
    <id>http://example.com/p/f255ffad.html</id>
    <published>2023-12-28T07:46:44.954Z</published>
    <updated>2023-12-29T10:01:15.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h3><p>docker是用GO开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。<br>Docker 容器是</p><ul><li>利用Linux Namespace做资源隔离，</li><li>Cgroup做资源上限限制，</li><li>rootfs做文件系统</li><li>运行在宿主机上面的一个特殊进程。</li></ul><h3 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h3><p>利用docker可以将项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在宿主机创建一个容器，让镜像在容器内运行，从而实现项目的部署。<br>项目可以是mysql、nginx、nodejs、redis等，从而可以在一台宿主机上快速搭建相互隔离的不同的环境。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>镜像（image)、容器(container)、仓库（repository)<br>举个例子，电脑安装操作系统，称其为镜像，镜像是一个固定的文件，这次读盘和下次读盘内容是一样的。<br>把这个镜像安装到电脑上，再在这个电脑上删删改改，再重新打包一个镜像刻盘，固化出一个镜像来，这就是镜像打包，<br>如国内以前泛滥的盗版XP系统，从微软官方镜像出发，添加小工具，系统设置修改优化，加主题，造出番茄花园，雨林木风，深度之类的盗版安装碟。<br>镜像装到电脑后，这个电脑就是个容器，里面包含使用者的数据和设置。</p><p>• 镜像<br>镜像可以看成是由多个镜像层叠加起来的一个文件系统；<br>镜像层的主要组成部分包括镜像层 ID、镜像层指针 「指向父层」、元数据；<br>镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层。统一文件系统（ AUFS）能够将不同的层整合成一个文件系统。</p><p>• 容器<br>容器的定义和镜像几乎一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br>要点：容器 &#x3D; 镜像 + 读写层</p><p>• 仓库<br>顾名思义，docker仓库是用来存储镜像的，理解时，可以参考git仓库。</p><p>Docker环境安装，以安装docker-ce为例</p><pre><code>Linux安装    1）下载阿里的源    wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    sudo yum makecache    sudo yum install docker-ce2）docker启动    systemctl start docker.serviceWindows安装    https://www.runoob.com/docker/windows-docker-install.html    下载Docker Desktop    启用Hyper-V(win10)    安装Docker Desttop</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>搜索镜像</p><pre><code>docker search xxx</code></pre><p>拉取镜像</p><pre><code>docker pull xxx</code></pre><p>查看镜像</p><pre><code>docker images</code></pre><p>运行镜像</p><pre><code>docker run-p 暴露端口:容器端口 #端口-v 本地路径:容器内路径 #挂在本地路径-e 环境变量=value #指定环境变量–add-host 域名:IP # 绑定域名 -p 暴露端口：容器端口-v 本地路径：容器内路径-e 环境变量=value</code></pre><p>查看运行中的容器</p><pre><code>docker ps</code></pre><p>容器启动、停止、重启</p><pre><code>docker container start | stop | restart [containername]</code></pre><h2 id="启动一个nginx服务器"><a href="#启动一个nginx服务器" class="headerlink" title="启动一个nginx服务器"></a>启动一个nginx服务器</h2><pre><code># 检索nginx镜像docker search nginx --limit 5# 拉取镜像docker pull nginx:stable#采用默认配置启动一个服务器docker run -p 9080:80 --name my-nginx nginx:stable#采用自定义配置，并挂载外部目录docker run -d -p 9081:81 -v /home/luanhongjun/temp1/demo/nginx/conf.d:/etc/nginx/conf.d -v /home/luanhongjun/temp1/demo/nginx/html:/usr/share/nginx/html --name my-nginx nginx:stable</code></pre><h2 id="自定义打包镜像"><a href="#自定义打包镜像" class="headerlink" title="自定义打包镜像"></a>自定义打包镜像</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code>FROM khub.wps.cn/sreopen/node:14.2.0ADD ./ /opt/zhiliaoWORKDIR /opt/zhiliaoRUN npm installRUN npm run build:pcRUN npm run build:mobileFROM khub.wps.cn/sreopen/nginx:1.18.0COPY --from=0 /opt/zhiliao/dist/ /var/www/zhiliao/COPY --from=0 /opt/zhiliao/m-dist/ /var/www/m-zhiliao/COPY --from=0 /opt/zhiliao/nginx/nginx.conf /etc/nginx/RUN nginxCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><p>FROM：指定基础镜像<br>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。<br>WORKDIR： 指定工作目录<br>RUN：构建镜像时运行的命令<br>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源<br>CMD：构建容器后调用，也就是在容器启动时才进行调用。</p><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p><h2 id="Docker镜像瘦身技巧："><a href="#Docker镜像瘦身技巧：" class="headerlink" title="Docker镜像瘦身技巧："></a>Docker镜像瘦身技巧：</h2><h3 id="善用-amp-amp"><a href="#善用-amp-amp" class="headerlink" title="善用 &amp;&amp;"></a>善用 &amp;&amp;</h3><p>优化前</p><pre><code>RUN npm installRUN npm run build:pcRUN npm run build:mobile</code></pre><p>优化后</p><pre><code>RUN /bin/bash -c &#39;npm install &amp;&amp; npm run build:pc &amp;&amp; npm run build:mobile&#39;</code></pre><h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>选择Alpine&#x2F;Distroless基础镜像<br>Alpine Linux是一个基于musl libc和busybox、面向安全的轻量级Linux发行版。它更小、更安全。</p><pre><code>FROM khub.wps.cn/zl-open/golang-base:1.14.2 AS build-linkADD wps-zhiliao-backend-mics-known-link /opt/kingsoft/src/wps.cn/drive/linkADD wps-zhiliao-backend-mics-known-lib /opt/kingsoft/src/wps.cn/drive/libADD wps-zhiliao-backend-lib /opt/kingsoft/src/wps.cn/libADD kgo-kms /opt/kingsoft/src/ksogit.kingsoft.net/kgo/kmsADD openksa-cksdk /opt/kingsoft/src/wps.cn/cksdkADD kgo-i18n /opt/kingsoft/src/wps.cn/drive/i18nWORKDIR /opt/kingsoft/src/wps.cn/drive/linkENV GOPATH=/opt/kingsoft/:/opt/kingsoft/src/wps.cn/lib/Godeps/_workspaceENV CGO_ENABLED=0RUN go build -v -o /opt/kingsoft/src/wps.cn/drive/link/bin/main /opt/kingsoft/src/wps.cn/drive/link/main.goFROM khub.wps.cn/sreopen/sre-base:pyjinja-supervisor-alpine AS run-linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/bin/main /usr/local/bin/linkCOPY --from=0 /opt/kingsoft/src/wps.cn/drive/i18n /opt/apps/link/i18n/COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/etc/link.kae.toml.j2 /etc/link.kae.toml.j2COPY --from=0 /opt/kingsoft/src/wps.cn/drive/link/kae_start.sh /usr/local/bin/kae_start.sh#EXPOSE 8080RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39; /etc/apk/repositories \&amp;&amp; apk add --no-cache tzdata \&amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \&amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \&amp;&amp; chmod +x /usr/local/bin/kae_start.shCMD [&quot;kae_start.sh&quot;]</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>docker build . -t xxx:yy</p><h2 id="docker-compose的使用"><a href="#docker-compose的使用" class="headerlink" title="docker-compose的使用"></a>docker-compose的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。<br>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。<br>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）<br>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>方式一：下载适应版本的compose</p><pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose</code></pre><p>方式二：</p><pre><code>安装python-pippip install docker-compose</code></pre><h3 id="docker-compose-yml简介"><a href="#docker-compose-yml简介" class="headerlink" title="docker-compose.yml简介"></a>docker-compose.yml简介</h3><p>标准配置文件应该包含version、services、networks三部分:<br>version: 定义了版本信息<br>services: 定义了服务的配置信息，包含应用于该服务启动的每个容器的配置<br>networks: 定义了网络信息，提供给 services 中的 具体容器使用<br>实例</p><pre><code>version: &#39;3.2&#39;services:#Nginxnginx_lb:restart: alwaysimage: nginx:1.11.6-alpineports:- 28080:80- 80:80- 443:443volumes:- /opt/kingsoft/containers/nginx/conf.d:/etc/nginx/conf.d- /opt/kingsoft/containers/nginx/log:/var/log/nginx- /opt/kingsoft/containers/nginx/www:/var/www- /opt/kingsoft/containers/nginx/zhiliao-management-system:/var/zhiliao-management-system- /opt/kingsoft/containers/nginx/ssl:/etc/nginx/sslextra_hosts:- &quot;msgcenter.wps.cn:120.92.124.158&quot;stdin_open: truetty: true# Redis cluster#redis_db:# image: grokzen/redis-cluster:5.0.12# environment:# TZ: &quot;Asia/Shanghai&quot;# volumes:# - /opt/kingsoft:/opt/kingsoft# # docker network bridge mode# networks:# vpcbr:# ipv4_address: 172.16.0.50# ports:# - &quot;7000:7000&quot;# MySQL DBmysql_db:image: percona:5.6environment:MYSQL_ROOT_PASSWORD: xxxxTZ: &quot;Asia/Shanghai&quot;volumes:- /opt/kingsoft/containers/mysql/conf:/etc/mysql/conf.d- /opt/kingsoft/containers/mysql/data:/var/lib/mysql- /opt/kingsoft:/opt/kingsoftports:- &quot;3306:3306&quot;networks:vpcbr:ipv4_address: 172.16.0.51zoo1:image: wurstmeister/zookeeperports:- &quot;2181:2181&quot;networks:vpcbr:ipv4_address: 172.16.0.56# kafka version: 1.1.0# scala version: 2.12kafka:image: wurstmeister/kafkaports:- &quot;9092:9092&quot;environment:KAFKA_ADVERTISED_HOST_NAME: kafkaKAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181&quot;KAFKA_BROKER_ID: 1KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1KAFKA_CREATE_TOPICS: &quot;drive_fsys_fop:1:1&quot;depends_on:- zoo1networks:vpcbr:ipv4_address: 172.16.0.57networks:vpcbr:driver: bridgeipam:config:- subnet: 172.16.0.0/16</code></pre><p>结合KAE使用</p><pre><code>绑定120.92.124.158 khub.wps.cndocker tag xximage:xxtagdocker login khub.wps.cndocker push khub.wps.cn/zl-open/golang-base:1.14.2</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如何从一个容器做一个镜像</p><p>docker commit命令创建镜像<br>docker commit xxxcontaineridd imagename:tag</p><p>docker logs 能否输出nginx的access.log</p><p>docker logs xxx 只能输出容器内程序输出到终端（stdout|stderr）的日志。无法输出写入到文件中的日志。所以不能直接输出nginx的access.log<br>当然，如果使用一些hook程序，将access.log内的日志实时输出到终端，可以通过docker logs看到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>消息队列</title>
    <link href="http://example.com/p/fec99276.html"/>
    <id>http://example.com/p/fec99276.html</id>
    <published>2023-12-28T07:45:47.420Z</published>
    <updated>2023-12-29T10:01:15.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列是一种用于在分布式系统中传递消息的通信模式。它基于异步通信的概念，允许不同的应用程序、服务或组件之间通过消息传递来进行通信，而无需即时响应。消息队列的核心思想是将消息发送到队列中，接收者从队列中接收消息并处理。</p><ul><li>异步通信：消息队列支持异步通信模式，即消息的发送和接收不需要立即的直接响应。这对于处理高并发、削峰填谷、提高系统的吞吐量等场景非常有用。</li><li>解耦组件：通过使用消息队列，不同的组件可以解耦，减少直接依赖，使系统的各个部分能够相对独立地开发和维护。这有助于提高系统的可维护性和扩展性。</li><li>可靠性：大多数消息队列系统都具备高可靠性。它们通常会确保消息的可靠传递，即使某个组件暂时不可用，消息也不会丢失。消息队列能够在组件恢复正常后继续处理消息。</li><li>数据传输：消息队列可以用于在不同的系统、应用程序或服务之间传输数据。它为数据传输提供了一个可靠的通道，确保数据在传输过程中不会丢失。</li><li>任务分发：消息队列常被用于任务分发系统。例如，一个后台任务队列可以接收待处理的任务，然后按照优先级或其他策略将任务分发给多个工作节点进行处理。</li><li>松耦合：消息队列允许不同的系统或服务通过共享消息队列来进行通信，而无需了解对方的具体实现细节。这种松耦合有助于系统的灵活性和可扩展性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h1&gt;&lt;p&gt;消息队列是一种用于在分布式系统中传递消息的通信模式。它基于异步通信的概念，允许不同的应用程序、服务或组件之间通过消息传递来进</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>bufferevent</title>
    <link href="http://example.com/p/284ab3e9.html"/>
    <id>http://example.com/p/284ab3e9.html</id>
    <published>2023-12-28T07:40:36.858Z</published>
    <updated>2023-12-29T10:01:15.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h1><p>云盘项目使用了bufferevnt</p><p>先看看struct bufferevent这个结构体</p><pre><code>struct bufferevent &#123;    struct event_base *ev_base;    const struct bufferevent_ops *be_ops;    struct event ev_read;    struct event ev_write;    struct evbuffer *input;    struct evbuffer *output;    ……    bufferevent_data_cb readcb;    bufferevent_data_cb writecb;    bufferevent_event_cb errorcb;    ……&#125;</code></pre><p>和rpc一样，维护回调函数以及缓冲区，内置了两个event（读&#x2F;写）和对应的缓冲区。当有数据被读入(input)的时候，readcb被调用，当output被输出完成的时候，writecb被调用，当网络I&#x2F;O出现错误，如链接中断，超时或其他错误时，errorcb被调用。</p><p>设置sock为非阻塞的</p><pre><code>eg: evutil_make_socket_nonblocking(fd);</code></pre><p>使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base</p><pre><code>struct bufferevent * bufferevent_socket_new(struct event_base *base, evutil_socket_t fd,  int options)eg:  struct bufferevent *bev;bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);language-cpp</code></pre><p>设置读写对应的回调函数</p><pre><code>void bufferevent_setcb(struct bufferevent *bufev,    bufferevent_data_cb readcb, bufferevent_data_cb writecb,    bufferevent_event_cb eventcb, void *cbarg)eg.  bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);</code></pre><p>启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的</p><pre><code>int bufferevent_enable(struct bufferevent *bufev, short event)eg.  bufferevent_enable(bev, EV_READ|EV_WRITE);language-cpp</code></pre><p>进入bufferevent_setcb回调函数：<br>在readcb里面从input中读取数据，处理完毕后填充到output中；<br>writecb对于服务端程序，只需要readcb就可以了，可以置为NULL；<br>errorcb用于处理一些错误信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bufferevent&quot;&gt;&lt;a href=&quot;#bufferevent&quot; class=&quot;headerlink&quot; title=&quot;bufferevent&quot;&gt;&lt;/a&gt;bufferevent&lt;/h1&gt;&lt;p&gt;云盘项目使用了bufferevnt&lt;/p&gt;
&lt;p&gt;先看看struct</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>反转单词</title>
    <link href="http://example.com/p/881199c7.html"/>
    <id>http://example.com/p/881199c7.html</id>
    <published>2023-12-28T07:38:44.412Z</published>
    <updated>2023-12-29T10:01:15.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h1><p>给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。</p><p>输入输出<br>输入</p><pre><code>“this is a sentence”</code></pre><p>输出</p><pre><code>sentence a is this</code></pre><p>首先，题目要求把每个单词倒过来，同时联想到栈有先进先出的特点。如果我们把单词作为一个整体按顺序入栈，然后再全部出栈，这时得到的就是反转后的句子了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    stack&lt;string&gt; wordStack;    int len = str.size();    string temp=&quot;&quot;;    for (int i = 0; i &lt; len; i++) &#123;        if (str[i] != &#39; &#39;) &#123;            temp += str[i];        &#125;        else &#123;            wordStack.push(temp);            temp.clear();        &#125;    &#125;    wordStack.push(temp);    string tempword;    while (!wordStack.empty())    &#123;        tempword = wordStack.top();        wordStack.pop();        if (!wordStack.empty()) &#123;            cout &lt;&lt; tempword &lt;&lt; &#39; &#39;;        &#125;        else        &#123;            cout &lt;&lt; tempword;        &#125;    &#125;    return 0;&#125;</code></pre><p>在整个字符串反转后，可以看到单词的相对位置就已经反转过来了，但是对于每个单词依然内部字母是反转的，因此考虑是否有方法将每个单词进行反转，这样单词字母的顺序就变过来了。</p><p>没错，把每个单词作为一个独立的字符串进行反转就可以了。</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;void reverseStr(string&amp; str, int beg, int end) &#123;    while (beg &lt; end) &#123;        swap(str[beg++], str[end--]);    &#125;&#125;int main() &#123;    string str;    getline(cin, str);    reverseStr(str, 0, str.size() - 1);    int begin=0, end=0;    for (int i = 0; i &lt; str.size(); i++) &#123;        if (str[i] != &#39; &#39;) &#123;            end=i;        &#125;        else &#123;            reverseStr(str, begin, end);            begin = end + 2;        &#125;    &#125;    reverseStr(str, begin, end);    cout &lt;&lt; str;    return 0;&#125;</code></pre><h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p>原文的分析是：</p><p>注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）</p><p>if nums[0] &lt;&#x3D; nums[I] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] &lt;&#x3D; target &lt;&#x3D; nums[i]时我们应该在 0 - i 范围内查找；<br>if nums[i] &lt; nums[0] 那么在 0 - i 区间的某个点处发生了下降（旋转），那么 I + 1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当 target 不属于 nums[0] 到 nums[i] 时（target &lt;&#x3D; nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;&#x3D; target），我们应该在 0 - i 区间内查找。<br>上述三种情况可以总结如下：</p><pre><code>nums[0] &lt;= target &lt;= nums[i]        target &lt;= nums[i] &lt; nums[0]                    nums[i] &lt; nums[0] &lt;= target</code></pre><p>所以我们进行三项判断：</p><p>(nums[0] &lt;&#x3D; target)， (target &lt;&#x3D; nums[i]) ，(nums[i] &lt; nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））</p><p>所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。</p><p>使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）</p><p>之后我们通过二分查找不断做小 target 可能位于的区间直到 low&#x3D;&#x3D;high，此时如果 nums[low]&#x3D;&#x3D;target 则找到了，如果不等则说明该数组里没有此项。</p><pre><code>class Solution &#123;public:    int search(vector&amp; nums, int target) &#123;        int lo = 0, hi = nums.size() - 1;        while (lo &lt; hi) &#123;            int mid = (lo + hi) / 2;            if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]))            lo = mid + 1;            else            hi = mid;        &#125;        return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反转单词&quot;&gt;&lt;a href=&quot;#反转单词&quot; class=&quot;headerlink&quot; title=&quot;反转单词&quot;&gt;&lt;/a&gt;反转单词&lt;/h1&gt;&lt;p&gt;给定一个字符串，其中单词之间以空格进行分隔，现在要求将整个字符串的单词进行反转。&lt;/p&gt;
&lt;p&gt;输入输出&lt;br&gt;输入&lt;/p&gt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>中望软件</title>
    <link href="http://example.com/p/d9f4dee9.html"/>
    <id>http://example.com/p/d9f4dee9.html</id>
    <published>2023-12-28T07:37:38.609Z</published>
    <updated>2023-12-29T10:01:15.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://notion.olimi.icu/article/a41a5e7d-a826-4017-9864-c573d9466951?theme=matery">https://notion.olimi.icu/article/a41a5e7d-a826-4017-9864-c573d9466951?theme=matery</a></p><p>自我介绍</p><p>实习的情况。</p><p>C++现代化新特性</p><p>结构化绑定</p><p>移动语义</p><p>智能指针。</p><p>unique_ptr独占的实现。</p><p>class多态的理解</p><p>virual析构函数需不需要虚函数。</p><p>为什么析构函数能不能调用虚函数，为什么。</p><p>内存泄漏，有没有碰到，怎么解决。</p><p>RAII了不了解。</p><p>项目的情况。代码量、工作量。作为团队管理，如何组织分工。</p><p>实习的收获。实习上有没有碰到什么沟通问题。</p><p>有没有offer，怎么看待。</p><p>三年内的职业规划。</p><p>问c语言的从c文件到exe文件的整个过程，问项目，问c++的书看过那些，问多态，问内存泄漏的原理，问c++11啥能解决这个问题吗，回答的智能指针，但是没继续问，人很好，问常用的容器，问vector和map的底层实现，问自己的学习模式，问了后面的打算。问城市意向，说沿海城市，广州深圳杭州。问行业，说我啥都投没有特别要求</p><p>C++ 封装继承多态<br>虚函数相关<br>哈希以及如何解决哈希冲突，几种哈希冲突解决方法的适用场景<br>死锁如何避免</p><p>2.数据结构和算法<br>介绍快排思想，以及如何优化</p><p>兴趣爱好<br>有无实习经历<br>科研生活<br>期望薪资以及该消息获取来源</p><p>二面（30 min）<br>平时做笔记总结的内容<br>介绍下 WebServer 项目以及主要改进点，线程池，epoll<br>什么时候开始准备秋招，手中有哪些 offer，是否有走完面试流程的<br>选择一家公司，从哪些因素考虑<br>硕士期间最佩服的人<br>自己三个最大的优点<br>期望薪资<br>对 CAD 软件以及中望的了解</p><p>自我介绍<br>项目问了几句，因为太简单没有深问<br>多态<br>如何实现多态<br>析构函数和构造函数可以是虚函数吗，可以包含虚函数吗？<br>两个成员函数只有返回类型不同，可以重载吗<br>两个成员函数一个是const修饰，可以重载吗（这个不知道）<br>右值引用，引用后还是右值吗<br>数据结构，讲一下vector的底层实现原理<br>vector扩容<br>deque的底层实现机制（双向索引）<br>map和unordered_map的底层实现机制<br>红黑树性质（这个确实了解的还不够深入）<br>hash的底层实现机制，你会采用什么方式实现（我说vector……）<br>暂时就这么多，栓Q了。真的好多不清楚，学去了……<br>对我们公司了解吗？CAD 用过吗？猜测一下我们的 CAD 软件产品使用了什么技术。（面试前特意去了解了一下他们公司，中国图形建模龙头企业，简单吹捧了一下。没用过。全程尬聊，说了说 C++ 客户端开发可能用到的计数，还有图形渲染技术）</p><ol><li>哪个项目用到比较深的技术，接触设计模式了吗？（没有什么比较深的技术，说了多线程并发）</li><li>还了解什么设计模式？</li><li>智能指针？使用的时候要注意什么？（四种智能指针 auto_ptr（已弃用），unique_ptr，shared_ptr，weak_ptr，早期的 auto_ptr 和之后的 unique_ptr 是为了实现对某一堆中对象的唯一管理，但当移交管理的时候 auto_ptr 采取的是拷贝语义，unique_ptr 采用的是移动语义，使得后者通用性更好；shared_ptr 采取引用计数思路管理对象生命周期，当多一个指向该对象的 shared_ptr，引用计数加一，相反减一，引用计数为 0 时，释放被指向的内存空间；weak_ptr 是为了解决 shared_ptr 强指向可能出现的循环引用导致的内存泄漏，和当被指向的对象被释放产生的悬垂指针。使用时需要注意尽量不要直接使用智能指针的裸指针；在初始化只能指针的使用尽量使用 make_shared 和 make_unique 方法，一来可以加快初始化只能指针的速度（少编译一次），二来可以避免因赋值初始化操作执行一半造成的内存泄漏；使用 shared_ptr 要注意是否会产生循环引用。）</li><li>weak_ptr 除了你说的这两个作用（避免循环引用和悬垂指针）还有什么用途？weak_ptr 可以放在 STL 容器中吗？（不会）</li></ol><p>中望C++开发 二面（30min）<br>10.21更新：已经OC啦</p><p>3、C++11新特性，右值引用，移动语义，完美转发</p><p>4、STL容器的底层实现</p><p>5、offer情况，如何选择？对中望的看法，期望薪资</p><p>6、相比其他人的竞争优势，自己的缺点</p><p>7、自认为自己的学习能力怎么样</p><p>8、怎么学习C++</p><p>9、如何准备中望的面试</p><p>10、反问</p><p>作者：Charles丶丶<br>链接：<a href="https://www.nowcoder.com/discuss/410525196936814592?sourceSSR=enterprise">https://www.nowcoder.com/discuss/410525196936814592?sourceSSR=enterprise</a><br>来源：牛客网</p><p>C++研发工程师</p><p>内容不全，凭回忆写的；<br>问的有点深，如果你答得不够多，他会问还有吗，或者直接提示你还有什么没说到，问的问题应该是事先记在本子上一个一个问的；</p><p>项目介绍，问设计到的技术；<br>C++多态；<br>虚函数表的工作原理；<br>虚函数表的存储在内存的哪里；(给我问不会了分析了一个静态区，有大佬知道能告诉我一下吗)<br>inline是什么，什么情况下使用；<br>vector和list的区别；<br>new和malloc的区别；<br>static的作用；</p><p>计算机网络的五层&#x2F;七层模型；<br>网络层有哪些常用协议，说说作用；</p><p>算法题：一个正整数无序数组，求有多少个子区间的元素和等于k；(当时我只写了暴力解，问优化才想到滑动窗口)<br>走流程反问；</p><p>作者：学不明白<br>链接：<a href="https://www.nowcoder.com/discuss/395725387634933760?sourceSSR=enterprise">https://www.nowcoder.com/discuss/395725387634933760?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望软件 二面<br>二面（30min）<br>自我介绍<br>项目开发中遇到了什么困难吗？<br>C++怎么学习的？<br>还看过什么书？<br>右值引用？<br>extern C？<br>完美转发？<br>迭代器失效？<br>反问：</p><p>部门介绍<br>部门规模<br>加班时长<br>大概啥时候出结果？</p><p>作者：garbage_man<br>链接：<a href="https://www.nowcoder.com/discuss/394235723589713920?sourceSSR=enterprise">https://www.nowcoder.com/discuss/394235723589713920?sourceSSR=enterprise</a><br>来源：牛客网</p><p>广州中望C++开发 一面 （40min）<br>1.项目介绍，难点，用到哪些C++知识，是否用到过设计模式</p><p>3.进程和线程，通信方式，最快的进程通信方式，第二快呢？</p><p>6.兴趣爱好</p><p>7.野指针，什么会造成野指针？</p><p>8.右值引用</p><p>9.引用折叠</p><p>11.二维和三维软件的区别</p><p>12.你觉得制作CAD软件需要哪些知识和工具</p><p>13.对996和加班怎么看？</p><p>14.中望吸引你的点</p><p>作者：Charles丶丶<br>链接：<a href="https://www.nowcoder.com/discuss/408635697302654976?sourceSSR=enterprise">https://www.nowcoder.com/discuss/408635697302654976?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望软件 一面</p><p>聊项目<br>介绍一下你整个项目的开发流程？<br>服务器项目压力测试结果怎么样？<br>EPOLL看过源码吗？没看过就算了。<br>这个项目很多人都做过，你的差异点在哪里？<br>C++基础<br>介绍一下多态？<br>面试官还给我补充了一下为什么不同的操作系统选择不同的扩容因子<br>map和unordered_map的区别？<br>哈希法解决碰撞冲突的方式？<br>拉链法可能会被退化成O(n)的查找效率，如何优化？<br>自定义的数据机构如何在map中使用？重载&lt; 和 &#x3D;&#x3D; 运算符<br>除了重载，还有其他方法实现吗？类外写比较器或者写仿函数<br>new和malloc的区别？<br>如何只在栈上创建对象？重载new运算符并设为私有权限<br>在使用new运算符的情况下，也只在栈上创建对象？不会<br>操作系统<br>介绍一下同步和互斥的概念？<br>只使用互斥锁不可以实现同步吗？<br>多线程和多进程开发的区别？<br>进程调度算法？一下卡住了，让说了一个自己最熟悉的，我就说了个时间片轮转算法。</p><p>算法<br>力扣刷了多少题？对半说了一下。<br>给我出了个题，力扣的原题，但是最近没有二刷到，所以最优方法没有做出来。（等我找到原题题号再补充）<br>第一种思路：哈希表+遍历。然后让我优化空间复杂度为O(1)<br>第二种思路：排序+遍历。<br>你会选择哪种排序算法？快排或者堆排序？<br>介绍一下堆排序的时间复杂度和空间复杂度？堆排序是稳定算法吗？<br>第三种思路：元素的值作为下标，交换两个元素的位置。第三种优化方法没有做过所以想不起来，面试官一步步引导我。<br>时间复杂度和空间复杂度说一下？<br>最后就是一些闲聊：</p><p>怎么了解到我们公司的？本科画图用过。<br>反问：</p><p>上班时间、加班时长？<br>部门主要是做什么的？3维CAD的高级组件的开发，需要C++和数学能力。<br>新人培养？</p><p>作者：garbage_man<br>链接：<a href="https://www.nowcoder.com/discuss/391308586817789952?sourceSSR=enterprise">https://www.nowcoder.com/discuss/391308586817789952?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望C++西安面经<br>50分钟….<br>自我介绍<br>项目介绍<br>epoll 底层结构<br>讲讲多态<br>动态多态怎么实现<br>讲讲malloc new<br>怎么禁止动态分配内存<br>怎么在栈上动态分配内存 (回答用 placement_new 不知道对不对 )<br>讲讲 inline<br>我前面说 inline适用于 短小简单且重复使用的函数 面试官问 : 复杂的函数不能用?<br>我说 inline不需要函数调压栈的开销 复杂函数 本身开销就大, 不在乎多点函数调用的开销…. 不知道对不对<br>宏定义和inline<br>说到了编译,预编译 那讲讲分为几步 每个步骤的作用<br>讲讲linux 文件系统….. 不咋会 ,随便说说了软链接 和 硬链接<br>vector 和 list<br>vector 插入时间复杂度<br>vector 扩容, 开放题: 1.5 和 2倍扩容什么区别 .. 我不会 面试官解释了解释 1.5倍会使用之前释放的空间<br>多进程 多线程 区别,<br>线程共享什么<br>线程同步和互斥 概念<br>刷了几道题 , 来做道题 口述<br>数组大小为n, 每个元素数值属于 [1,n] 每个元素出现一次或两次, 找出所有出现两次的元素<br>哈希表 巴拉巴拉… 有没有更好的<br>……….想了想 面试官也提示了<br>原地交换, 假设下标从1开始, 交换让数组满足 a[i]&#x3D;i 不满足的就是出现两次的<br>反问</p><p>8.19 二面凉<br>20分钟…<br>自我介绍<br>挑个项目介绍<br>讲讲研究方向, 讲讲论文<br>看过什么c++书<br>说说项目用到的c++特性<br>静态链接 动态链接<br>stl什么时候迭代器失效<br>extern c<br>vector删除怎么得到有效的迭代器<br>讲讲c++11新特征<br>说说右值引用<br>说说完美转发<br>讲讲智能指针<br>反问</p><p>作者：贼贼困<br>链接：<a href="https://www.nowcoder.com/discuss/389467627150733312?sourceSSR=enterprise">https://www.nowcoder.com/discuss/389467627150733312?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望C++一二面经<br>8.10 笔试</p><p>8.12 一面<br>C++三大特性<br>详细说说多态<br>详细说说虚函数如何实现多态<br>使用过什么容器<br>vector迭代器什么时候失效，什么时候扩容<br>vector和list区别<br>set和map区别<br>红黑树说说你的了解</p><p>项目相关，你怎么用到的线程，你的线程怎么同步的（我项目里的线程没有同步，他们各跑各的）<br>视频流怎么读balabala</p><p>一面 30min 聊天式<br>自我介绍</p><p>面试问题：C++基础知识<br>多态<br>虚函数、纯虚函数<br>final和override关键字<br>指针和引用<br>STL容器，回答vector</p><p>一面凉经</p><p>多态<br>虚函数、纯虚函数<br>virtual和override关键字<br>指针和引用<br>STL容器，回答vector<br>vector跟数组的区别<br>map和unordered_map的区别<br>多线程，死锁<br>智能指针shared_ptr与weak_ptr<br>设计模式，单例模式<br>个人情况，期望薪资<br>反问</p><p>作者：牛客524117058号<br>链接：<a href="https://www.nowcoder.com/discuss/384041048715149312?sourceSSR=enterprise">https://www.nowcoder.com/discuss/384041048715149312?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望面试凉经：7-29<br>投c++，15号笔试、18号约面试，29号面试。半小时后感谢信。<br>面向对象的三大特性，简介。<br>三种继承方式。<br>继承方式的经典应用场景（抱歉，非科班，没懂他具体想问啥，直接pass这个问题）。<br>多态<br>堆、栈区，区别，哪个效率高，为什么？<br>const引用的应用场景。<br>空类会自动生成啥？</p><p>虚函数表是数组还是指针<br>auto 能不能作为返回类型、函数参数，auto 定义的变量一定要初始化<br>int 的基本运算符能不能重载，运算符重载能不能改变运算符的优先级<br>考了模板的传入参数能不能为数据类型<br>是否优先加载const类型的用户自定义类型函数参数（没看懂）<br>. $ @ 不能重载吗<br>识别地址表示<br>delete new malloc free。malloc不会返回异常<br>智能指针 unique 不能拷贝，weak 不会改变计数<br>微信在接受和发送消息时进程会阻塞吗？互斥？就绪<br>用单链表实现栈，问入栈的语句<br>struct TreeNode {<br>int val;<br>struct TreeNode <em>left;<br>struct TreeNode right;<br>TreeNode(int x) :<br>val(x), left(NULL), right(NULL) {<br>}<br>};&#x2F;<br>&#x2F;&#x2F; 1. 检测是否为平衡树<br>class Balance {<br>&#x2F;&#x2F; map&lt;TreeNode*,int&gt; h;<br>bool is;<br>int getHeight(TreeNode</em> root){<br>if(!is) return 0;<br>int lh&#x3D;0,rh&#x3D;0;<br>if(root-&gt;left){<br>lh&#x3D;getHeight(root-&gt;left);<br>&#x2F;&#x2F; h[root-&gt;left]&#x3D;lh;<br>}<br>if(root-&gt;right){<br>rh&#x3D;getHeight(root-&gt;right);<br>&#x2F;&#x2F; h[root-&gt;right]&#x3D;rh;<br>}<br>&#x2F;&#x2F; h[root]&#x3D;max(lh,rh)+1;<br>if(abs(lh-rh)&gt;1){<br>is&#x3D;false;<br>}<br>return max(lh,rh)+1;<br>}<br>public:<br>bool isBalance(TreeNode* root) {<br>&#x2F;&#x2F; write code here<br>if(!root) return true;<br>is&#x3D;true;<br>getHeight(root);<br>return is;<br>}<br>};</p><p>&#x2F;&#x2F; 求最大能装的单位数 83.3%<br>&#x2F;&#x2F; 给出 n 类箱子，给出每类箱子的个数、每类箱子一个能装多少单位<br>&#x2F;&#x2F; 一共能装 truckSize 个箱子<br>class Solution {<br>public:<br>&#x2F;**</p><ul><li>代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</li><li></li><li></li><li>@param boxArray int整型vector&lt;vector&lt;&gt;&gt; 箱子</li><li>@param boxTypesSize int整型 箱子类型数量</li><li>@param truckSize int整型 卡车容纳箱子数</li><li>@return int整型<br>*&#x2F;<br>int maximumUnits(vector<vector>&amp; ba, int bts, int ts) {<br>&#x2F;&#x2F; write code here<br>sort(ba.begin(),ba.end(),[](auto a,auto b){return a[1]&gt;b[1];});<br>int i&#x3D;0;<br>int ans&#x3D;0;<br>while(ts&gt;0&amp;&amp;i&lt;ba.size()){<br>if(ts&gt;ba[i][0]){<br>ans+&#x3D;ba[i][0]ba[i][1];<br>ts-&#x3D;ba[i][0];<br>i++;<br>}else{<br>ans+&#x3D;tsba[i][1];<br>ts&#x3D;0;<br>}<br>}<br>return ans;<br>}<br>};</vector></li></ul><p>&#x2F;&#x2F; 83.3%<br><a href="https://leetcode.cn/problems/maximum-units-on-a-truck/submissions/">https://leetcode.cn/problems/maximum-units-on-a-truck/submissions/</a></p><p>力扣过了但笔试只83.3% &#x2F;&#x2F; 检测某个点是否在某个区域内<br>&#x2F;&#x2F; 如果在区域内或者在边上，返回到区域顶点的最大距离<br>&#x2F;&#x2F; 如果在区域外或者在顶点上，返回到区域顶点的最小距离<br>class Solution {<br>public:<br>&#x2F;**</p><ul><li>代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</li><li></li><li></li><li>@param point double浮点型vector 鸟儿落地的坐标</li><li>@param array double浮点型vector&lt;vector&lt;&gt;&gt; 桩的坐标</li><li>@return double浮点型<br>*&#x2F;</li></ul><p>double distance(vector<double>&amp; p, vector&lt;vector<double> &gt;&amp; a) {<br>    &#x2F;&#x2F; write code here<br>    double x&#x3D;p[0], y&#x3D;p[1];<br>    int n &#x3D; a.size();<br>    for(const auto&amp; i:a){<br>        if(i[0]&#x3D;&#x3D;x&amp;&amp;i[1]&#x3D;&#x3D;y)<br>            return 0.0;<br>    }<br>    double maxDis&#x3D;0, minDis&#x3D;0x0fffffff;<br>    for(const auto&amp; i:a){<br>        double dis&#x3D;sqrt((i[0]-x)<em>(i[0]-x)+(i[1]-y)</em>(i[1]-y));<br>        maxDis &#x3D; max(dis, maxDis);<br>        minDis &#x3D; min(dis, minDis);<br>    }<br>    bool in &#x3D; true;<br>    sort(a.begin(),a.end());<br>    if(x&lt;a[0][0]||x&gt;a[n-1][0])<br>        in &#x3D; false;<br>    return in ? maxDis : minDis;<br>}<br>复制代码<br>};</double></double></p><p>作者：廿陆畵生<br>链接：<a href="https://www.nowcoder.com/discuss/382288318027898880?sourceSSR=enterprise">https://www.nowcoder.com/discuss/382288318027898880?sourceSSR=enterprise</a><br>来源：牛客网</p><p>面试内容基本是C++和设计模式（25min），设计模式没复习答不上来之后就开始唠嗑了~</p><p>shared_ptr&amp;weak_ptr<br>智能指针能够完全避免内存泄漏吗</p><p>多态<br>类的成员变量是否可以是引用<br>纯虚函数和虚函数区别<br>继承虚函数需要写virtual吗？overide呢<br>用过哪些stl<br>已经有指针，为什么要用迭代器<br>vector怎么实现？如何清空vector<br>map和unorder_map怎么实现<br>设计模式，懒汉&#x2F;饿汉，观察者（这就去看设计模式…）<br>8.2 二面<br>依然是一个超级nice的面试官<br>面试内容唠嗑+问了几个技术问题+hr问题（40min）<br>栈和队列怎么实现，看过源码吗<br>用队列实现栈<br>归并排序思想<br>extern使用<br>项目用到的多线程</p><p>项目涉及的设计模式<br>项目中有用到多态吗，展开说说</p><p>作者：敲敲敲敲敲<br>链接：<a href="https://www.nowcoder.com/discuss/381899879633813504?sourceSSR=enterprise">https://www.nowcoder.com/discuss/381899879633813504?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望一面凉经<br>有点混乱 不一定全<br>自我介绍<br>扯了一堆项目，似乎不感兴趣<br>重点八股<br>智能指针 可调用对象 栈溢出 内存对齐 右值引用 优先队列的数据结构 排序</p><p>复盘<br>项目表述有点不熟练<br>八股确实有点不知道，我都是记的原理，所以坑坑巴巴，但是我记忆确实不好啊呜呜呜<br>没有表现出强烈的喜欢这个公司的意愿，不够舔，我猜还有一点家庭地点的考虑<br>还是有点菜，继续加油<br>秋招加油！！！</p><p>作者：匿名牛油<br>链接：<a href="https://www.nowcoder.com/discuss/381133378811187200?sourceSSR=enterprise">https://www.nowcoder.com/discuss/381133378811187200?sourceSSR=enterprise</a><br>来源：牛客网</p><p>3、编程题：</p><p>如何删除一个数组中指定数值的元素（双指针）</p><p>4、开放问题：</p><p>举例谈谈缓存的作用</p><p>为啥看别人面经全是聊聊天就结束了，我这个咋问的这么灵活，面试官说网络不好面试还全程没开摄像头。。。还有编程题问的形式让我根本就没有意识到是个编程题，还以为是在问迭代器失效怎么办，我服。。。</p><p>作者：walker_z<br>链接：<a href="https://www.nowcoder.com/discuss/380800341338587136?sourceSSR=enterprise">https://www.nowcoder.com/discuss/380800341338587136?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望一面凉经<br>7.21下午面，提前看了一下面经，感觉就是常规八股加手撕。<br>大约半个小时，7.22感谢信</p><p>正式开始<br>2.用的c++是吧，window还是Linux，我们是做CAD的，你觉得c++开发CAD能干嘛（？这不是该我反问的吗→_→）<br>2.static有什么用，static成员函数的应用场景？还有其他应用场景吗？（不知道了）<br>3.内存对齐，内存对齐的作用<br>4.进程间通信方式，优缺点<br>7.右值引用？应用场景？还有吗？<br>9.对公司的了解，为什么选我们公司（我说在牛客上面看的，被贵公司企业文化吸引，然后了解到了是做CAD的，这一块没准备好，低情商了属于是）<br>10.用过CAD吗<br>11.有什么想问的</p><p>作者：直面产蛋的人生<br>链接：<a href="https://www.nowcoder.com/discuss/379963085413531648?sourceSSR=enterprise">https://www.nowcoder.com/discuss/379963085413531648?sourceSSR=enterprise</a><br>来源：牛客网</p><p>面试问题：</p><p>3、webserver项目是从哪里接触的？</p><p>8、说一下归并排序的思想、时间复杂度、空间复杂度</p><p>[项目] - [ ] 项目中C&#x2F;S的实现形式</p><p> C++面向对象特性在项目中的体现<br> 项目的并发量<br> 为什么用多进程<br> 进程和线程的区别<br> 各种常用数据结构的优缺点<br> std set的底层结构<br> unordered_set和set的区别<br>已挂</p><p>作者：Akumi_<br>链接：<a href="https://www.nowcoder.com/discuss/377566130402078720?sourceSSR=enterprise">https://www.nowcoder.com/discuss/377566130402078720?sourceSSR=enterprise</a><br>来源：牛客网</p><p>7.11 中望C++研发 一面<br>1、怎么找到应聘信息的？</p><p>6、C++11智能指针，有哪几个，特性如何？有何用处？</p><p>7、weak_ptr有什么作用？</p><p>8、weak_ptr和shared_ptr是怎么配合的？</p><p>9、static关键字</p><p>二面 悟空+云事业<br>领导给你个工作 但时间不够怎么办<br>领导让你干活, 没给你提具体的需求怎么办<br>团队任务中, 其他人不配合怎么办<br>看你博客上写了一些 思路里面提到了代码不够优美, 那你什么样的代码是优美的</p><p>虚继承解决什么问题, 虚继承的内存分布<br>windows下的异常机制和处理</p><p>为什么熬夜, 没有工作和学业的压力的话, 还会熬夜吗<br>toB还是toC有什么看法, 工业软件, 互联网, 金融软件怎么看<br>对薪酬有什么要求<br>本以为等到了offer, 结果等到了笔试通知, 说是他们系统出了bug, 我的信息缺失, 让我重新笔试…</p><p>作者：千寻slimg<br>链接：<a href="https://www.nowcoder.com/discuss/374211263465877504?sourceSSR=enterprise">https://www.nowcoder.com/discuss/374211263465877504?sourceSSR=enterprise</a><br>来源：牛客网</p><p>中望软件（武汉）：C++软件开发凉经<br>一面（腾讯会议，半小时）：</p><p>STL有哪些常用的容器？</p><p>七层模型、五层模型；<br>实验室C++相关项目？<br>排序算法有哪些，堆排序的实现？</p><p>看过什么C++的书？<br>传统图像处理算法研究过么？<br>总结：感觉是凉了，基本问题都回答了，但都是浅尝辄止，所以半小时就结束了，而且看面试官的表情感觉有一点，嫌弃？或者是冷漠吧。而且很多问题都是我大概回答了一下，然后就没有继续问下去而是转而问另外的问题了。</p><p>二面（腾讯会议，半小时）：</p><p>反问<br>期望薪资。<br>总结：没想到一面竟然过了，然后今天是Linux部门和云部门的面试。只要问道专业知识直接对不起、不了解、你说的啥？面试官还比较好说话，最后甚至陪他笑了笑……但感觉是凉了……中间几个东西都是一问三不知，别的扯得也是乱七八糟的……</p><p>二面（腾讯会议，四十分钟）：</p><p>为什么要支教？<br>做过windows相关开发么？能否接受？<br>总结：昨天hr联系说上次二面有些不匹配，所以今天又安排了一次面试，算是被捞了一下？这次面试官很明确关注的就是部门的业务内容，属于自己了解的东西撞枪口上了……感觉无论回答的好不好在面试官眼里都是小儿科了……不过面试官很nice，对自己的部门业务介绍得很清楚，也帮我复盘了一下之前的面试，后面一二十分钟主要都是他在讲，我在记，感觉不管能不能过都是血赚！</p><p>后续：<br>今天问了一下hr，说一般一星期内会有消息，不通过的话也么的感谢信……看了看时间，好像是上周三面的……也算是一个多星期了么的消息了……</p><p>作者：农村错题集<br>链接：<a href="https://www.nowcoder.com/discuss/371366709364621312?sourceSSR=enterprise">https://www.nowcoder.com/discuss/371366709364621312?sourceSSR=enterprise</a><br>来源：牛客网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://notion.olimi.icu/article/a41a5e7d-a826-4017-9864-c573d9466951?theme=matery&quot;&gt;https://notion.olimi.icu/article/a41a5e7d-a8</summary>
      
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>写作</title>
    <link href="http://example.com/p/f9cb768.html"/>
    <id>http://example.com/p/f9cb768.html</id>
    <published>2023-12-28T06:56:29.558Z</published>
    <updated>2023-12-29T10:01:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写作原理"><a href="#写作原理" class="headerlink" title="写作原理"></a>写作原理</h1><p>对于一棵树来说，根系越发达，吸收的养分就越多。那阅读也是一样的，经典作品就好比树根，可以触及无数人已经筛选好的最佳养分。那谈到经典，有人说读起来太费劲了，但如果考虑到最终收益的话，其实这是效率最高的方法。因为它可以帮助你迅速找到一条基准线，了解这个领域最基本的观点和概念是什么，然后用他们的观点帮着你去理解复杂的社会现象。<br>那阅读经典的顺序又是怎样的呢？我的建议是先读基本原理，再读通史。比如说，你打算写作的领域是时政，那么你可以先读迈克尔罗斯金撰写的《政治科学》，这是一本被多个国家的高等院校广泛采用的政治学教科书，读完它你基本上就对政治学有个大概的认识了。我们不是为了搞研究，而是拓宽视野，学习不同的思维路径，所以可以选择一些好看又能读懂的经典。比如像吴国盛教授写的《科学的历程》，讲的就是从古至今自然科学史的演变。</p><h2 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h2><h3 id="技巧-1：区分式阅读"><a href="#技巧-1：区分式阅读" class="headerlink" title="技巧 1：区分式阅读"></a>技巧 1：区分式阅读</h3><p>第一个技巧有些老生常谈了，但这是最基础的。之所以要拿出来讲，这和我的观察有关。我发现很多人阅读，无论读什么材料都是一种模式、一个速度。其实这是不对的，阅读要学会深度阅读和浏览两种模式。从字面上看，这很好区分，我们要做的就是根据不同的阅读材料，选择不同的阅读模式。这一点，我们从义务教育阶段就已经在培养了。比如我们学习一篇课文，老师会让我们先快速浏览全文，回答问题，接着是深度阅读，再回答问题。<br>这种方法完全可以移植到现在的阅读中。对于经典，一定要深度阅读。其实这没有捷径可言，要下笨功夫。我唯一的建议是多和专业人士、感兴趣的朋友边讨论边读。比如你和朋友商量，这周我们必须完成某一个章节的阅读，到了周末就线上交流感想，如果让对方察觉出来，你没读完，那就来个君子（金子）协定吧，比如发个红包😁。<br>剩下的大部分阅读材料，其实是浏览。首先就是看目录，因为它是整本书的文本架构。进入到正文后，我们可以根据5W1H 原则，快速找到一本书的主题和线索，把那些无关的内容跳过去。比如一本专著里，作者为了阐述某个观点，他会用很多例子帮助你去理解，但如果你通过其中一个例子就明白了作者的意思，那剩下的例子就没必要再看了。单篇的文章就更简单了，基本上就按照“是什么、为什么、怎么办”的结构来写的，直接找对你有用的部分就好。<br>当你看得越来越多，眼光也会越敏锐，你可以快速地发现一篇文章里，哪些是套路，哪些是干货。</p><h3 id="技巧-2：提炼观点"><a href="#技巧-2：提炼观点" class="headerlink" title="技巧 2：提炼观点"></a>技巧 2：提炼观点</h3><p>提炼观点首先就是要理解别人的观点。一个好的学习者，都会有一个习惯。当读完一本书或者一则材料后，他会把作者要传达的观点整理或者复述出来。如果你做不到这点，说明你根本没有吃透。<br>首先，阅读的时候，你一定要边读边划重点。这有两个好处，一是帮助你理解，二是方便你回头再来仔细阅读。如果涉及到重点内容，还可以做内容索引。比如，在阅读有关洪水治理的文章时，你可以对那些重要的时间节点和治理手段进行圈画，以便将来写作时需要，也方便找到。<br>这里有两点误区需要你格外注意：<br>对于写作来说，阅读不仅仅是了解、吸收作者的观点，还要学习作者给你带来启示的表达手法。<br>其次是提出问题。在阅读前和阅读中，你要为自己的阅读内容提出问题，比如这本书的问题点是什么，提到了哪些重要的事实，比较有特点的部分是什么等等，然后写在纸上，等阅读完后自问自答。<br>这些问题的答案对于我们写作是很有必要的。比如阅读社会学家涂尔干的作品《自杀论》时，在纸上写了：作者认为哪些深层次原因可能导致自杀？读完整本书后，给出答案：涂尔干认为，个体的社会关系越孤立，越容易自杀。这个观点就可以运用到写作中，往往可以达到深化主题的效果。比如我现在要写一篇文章分析社会中的有些人，他们因为找不到朋友和心灵慰藉，最终走向了不归路。我就可以这样写：在快节奏的生活中，有些人因为找不到好的沟通方式，愈发孤单，有时甚至会演变成一种对生的绝望。法国社会学家涂尔干一百多年前的著作《自杀论》放在今天仍可作为参照：个体的社会关系越孤立、疏离，便越容易自杀。正是在这种孤立里，集体生活中的相互取没有重点的胡乱圈画；只圈画观点性的句子。<br>暖对个体心灵慰藉的重要性便凸显出来。毕竟，在涂尔干看来，集体的力量，是最能遏制自杀的障碍之一。</p><h3 id="技巧-3：学会联想"><a href="#技巧-3：学会联想" class="headerlink" title="技巧 3：学会联想"></a>技巧 3：学会联想</h3><p>为什么写作的时候就是想不起来这些材料里的内容呢？<br>第 3 个技巧简单说，就是阅读一本书或者一则材料时，把自己所知的事和阅读文本联系起来。<br>这主要包括以下 3 个要素：<br>运用联想，你可以把这 3 个要素串起来，既可以帮助你记住曾经看过的内容，还可以助你触类旁通、打开思路。举个例子：有一次我在浏览一则材料时，看到了拍摄《武林外传》之前姚晨的境况。材料里说，姚晨没出名前，在家乡福州的歌舞团工作，没事的时候就去肯德基兼职，但她还是想演戏，于是就去了北京。可因为投资方嫌弃她嘴巴大，导致没有人找她拍戏。这让我联想到了我曾经看到的一段采访。被采访的人是同样拍摄了武林外传的沙溢。他提到，21 世纪初，电视剧里的男主流行陈道明那种成熟风格的，像他这样美少年面相的演员很难找到合适的角色，所以他会尽量把自己变得沧桑一些。假如在这部剧开播的周年纪念日那天，你想写一篇文章记录下这部国产剧，你就可以让联想发挥重要作用了。放大二人“无戏可拍”的这个共同点，串起姚晨和沙溢两个人物的命运，例如我可以这样写：过去读过的书或材料；自己曾经的体验和感悟；正在发生的事。怀揣着演员梦想的姚晨，毅然而然地辞掉了歌舞团的工作，踏上了北漂之路。然而现实给她浇了盆冷水。因为嘴巴大被投资方嫌弃难看，她常常无戏可拍。同样面临无戏可拍的，还有曾经的奶油小生沙溢。与姚晨不一样的是，当时电视剧里的男性角色流行陈道明那样的成熟风，而沙溢因为有着一张美少年面相，往往接不到合适的戏。<br>两个在演艺事业中穷途末路的人，都在等待命运的垂怜。直到《武林外传》的导演找到了他们，一个荒诞的武林就此上演，他俩的命运也随即改写。</p><h3 id="技巧-4：随时记录"><a href="#技巧-4：随时记录" class="headerlink" title="技巧 4：随时记录"></a>技巧 4：随时记录</h3><p>灵感这事，就像晨雾，转瞬即逝，所以在日常的阅读积累中，你一定要学会随时记录灵感。一方面是把你想到的有意思的点迅速做成笔记，另一方面就是把你看过的重要资料随手拍下来。记录的时候，要有章法。最基本的就是分类，我把手机备忘录分为了 3 类：<br>第一个观点类很好理解了吧，这里不过多展开了，记住标出处就好。表现手法类怎么理解呢？举个例子。假如 2008 年北京奥运会开幕前一个月，你接到一个任务，让你写刘翔，你会怎么写？记者李海鹏就写了一篇，题目叫《两个刘翔的跨<br>越》。从这个题目我们就可以看出，整个文本就是用对比的方法来写，但关键是怎么对比。他的方法是把刘翔拆分，一个运动员刘翔，一个符号学意义上的刘翔。于是就有了这样一段话：</p><ol><li>观点类，把有意思的观点记录下来，记录时一定要标明出处，方便查找；</li><li>表现手法类，记录手法的时候，你可以联想一下这个手法可以用在什么地方；</li><li>自我感想类，把自己突然迸发的感想用文字表达出来。</li></ol><p>北京奥运会上至少有两个刘翔。第一个是 21 世纪的青年运动员，轻松、自信，口头禅是“随便混混”；第二个是中国体育代表团的招牌运动员，中国体育的战鼓需要他来敲出恢弘之声。第一次看到这段话的时候，可以记录下来记录内容是这样的：对比是我们常见的修辞手法，似乎每个人都会用，一篇文章中，用两三处对比也很常见但整篇文章都用对比的基调来写，就需要努力去找这个人身上一切相互矛盾或者冲突的特征。我脑海中暂时能想到的就是撒贝宁，一个是法制主持人撒贝宁，一个是娱乐主持人撒贝宁，一个是中央电视台里的撒贝宁，一个是湖南电视台里的撒贝宁，像这样极具反差的人，使用这样的手法会比较适合。这个记录的过程其实也是思考的过程，它既可以帮助我们提炼观点，同时也完成了联想的过程。那再看看自我感想类，还是举个例子。同样也是李海鹏写的，《灾后北川残酷一面》描写了 2008 年地震后北川的残酷场景，他这样写道：死亡的气味是在 5 月 15 日下午开始在北川县城里弥漫开来的。那是一种甜、臭和焦糊的味道。地震在北川危害最烈，由于缺少尸袋，仍有大量遗体摆放在街道上废墟的空隙间等待处理。因为我是四川人，对汶川地震有很深的记忆，所以阅读时，我很快闪现出一些场景，我就用文字把这些场景、感觉记录了下来：地震后，雨水也紧随而至。但死亡的气息没有被雨水冲淡，反而更让人担心北川的危险。相比散落的小雨，余震才是北川周而复始的休止符。它总在人们稍稍宽心之时，再次震痛这座城市，人们默默承受这一切。你也可以像我这样，在阅读时，把这些感触记录下来。当下一次遇到类似的场景时，它就像肌肉记忆一样，条件反射般地出现在你的脑海里了</p><h2 id="好文章都有哪些标志"><a href="#好文章都有哪些标志" class="headerlink" title="好文章都有哪些标志"></a>好文章都有哪些标志</h2><h3 id="行文节奏：简单即美"><a href="#行文节奏：简单即美" class="headerlink" title="行文节奏：简单即美"></a>行文节奏：简单即美</h3><p>行文节奏，简单即美。这事是可追溯到古代的。北宋期间，有个叫刘几的学生，文风十分古怪，用咱们现在的话说就是标新立异。比如“万物生”，他非要写成“万物茁”，然后再去圆自己的说法，且词藻十分华丽偏僻。一向主张文章质朴流畅的欧阳修对此噗之一鼻，直接批注“大纰谬”。<br>像刘几这样的奇特文风，其实现在同样有人借鉴和推崇，总有人觉得写出一些复杂的句式、冷僻炫目的词语，就能写出好文章，但往往让人感受不到文章的真实。在我看来，一个好的写作者，常常是苛刻的，惜墨如金，找不到半点废话，也找不到一个故作高深之语。对一篇好的写作而言，文风一定是简单干练的，一字能说清绝不说第二个字。</p><p>举个例子：<br>由于腰椎不大好，65 岁的李青很少再出去走动，一天的大多数时刻，他都在床上度过，岁月的皱纹早已刻满了他的脸庞。这天一大早，他被屋外嘈杂的声音吵醒，直觉告诉他，外面出事了。出事的地方是成都某处家属院，这还是上世纪建造的，石头已经有些发黑，墙壁上长满了青苔。短短 125 个字，很多消息冗余，比如“很少出去走动”和“在床上度过”，表达的是同样的意思；再比如“岁月的皱纹”，这样的表达并不恰当，皱纹往往意味着年老，没必要再去修饰。“刻满”这个词语就不如“爬满”来得精确，“石头有些发黑”指代不清，哪里的石头，联系上下文其实是指墙壁上的砖头。</p><p>改写一下：<br>李青 65 岁，腰椎不好，大多数时间都在床上待着，皱纹已爬满了他的脸庞。这天一早，屋外的嘈杂声吵醒了他，他感觉外面出事了。事发地是成都某处上世纪建造的家属院，院内苔绿斑斑的墙壁上，砖头已经发黑。<br>改后的文字只有 94 个字，这就说明第一段文字有超过 30% 的内容都是没用的“脂肪”，抛掉冗余的内容后，文字节奏会轻快很多。</p><h3 id="文字表述：确保准确，再看词藻"><a href="#文字表述：确保准确，再看词藻" class="headerlink" title="文字表述：确保准确，再看词藻"></a>文字表述：确保准确，再看词藻</h3><p>好文章的第二个标志：文字表述。我认为先要确保准确，才能推敲词藻。<br>我们从小时候开始学习写作，大家经常会做这样一件事，就是背诵优美的段落。有个阶段我也是这样的，觉得那些文字很优美，读起来朗朗上口，写进文章中很加分。但其实过了应试阶段，你再回看的话，往往会发现那些文字多是内容空洞、用词浮夸。摘录一句感受一下。寓言凝聚人类的智慧，闪烁着道义的光华，有聚瑰宝撒珠玑之美，能给人以顿悟般的针砭与启迪。<br>如果我把这句话里的主语换一个，比如勇敢，勇敢凝聚人类的智慧，闪烁着道义的光华……发现了吗？完全可以套用。主要原因就在于这段文字用词模糊、言不及义。这样的习惯短期来看不会对写作造成很大的影响，偶尔穿插一两句可能你仍会觉得很得意，但长期以往，其实会潜移默化地影响我们。这么一句话，“河道两岸天空阴沉，长鸣的汽笛声让清冷的空气颤抖”。本意是想渲染一种悲伤的氛围，用空气的颤抖来烘托受灾人心的颤抖，用颤抖来形容空气就是不合适的，不仅不<br>精准，还画蛇添足，并且这样的描述用在灾区这里本身就很违和。所以啊，遣词造句永远是写作里最重要的一环，这就需要我们运用恰当的语法、句法和词语。再举个例子。烈士陵园内，墓碑上扑克牌大小的姓名从未随着时光流逝而消失。每次擦拭墓碑，王明都会小声念着上面的字，不自主地感叹一句，短短 30 多个字就代表了他们一生。<br>粗看下来，这句话流畅，不算糟糕，但仔细读，会发现有两个地方表达得不够精确：</p><ol><li>“消失”太过平常，而且看了不知道姓名为什么会消失；</li><li>“代表”同样很普通，没有任何色彩</li></ol><p>墓碑上的字为什么会消失？当然是因为时间久了，会被风化，所以把消失改为风化殆尽，意义会更加明确；而代表可以用什么词替换呢？人的一生是复杂的，但只能用短短几十个字去描述人的一生，那显然这几十个字是浓缩了嘛，所以用“浓缩”就比“代表”好，更能体现情感，而非冷冰冰地刻画。以下就是改后的文字：烈士陵园内，墓碑上扑克牌大小的姓名从未随着时光流逝而风化殆尽。每次擦拭墓碑，王明都会小声念着上面的字，不自主地感叹一句，短短 30 多个字就浓缩了他们一生。</p><p>刚刚接触写作的人，不太喜欢考究用词。比如人们面临的任何困难，有些人就喜欢用“危机”来描述，但如果这种情况是危机，那么碰到下一个困难呢？你该怎么在写作中去区分？难道要用“巨型危机”吗？所以选择恰如其分的词语是很重要的</p><h3 id="主题刻画：鲜明与否？突出与否？"><a href="#主题刻画：鲜明与否？突出与否？" class="headerlink" title="主题刻画：鲜明与否？突出与否？"></a>主题刻画：鲜明与否？突出与否？</h3><p>好的文章，它的主题一定是鲜明的，而且立意还要突出，有值得深入探讨的余地。为了突出主题，我们往往会有很多的描写，而描写恰恰也是一篇文章中最能展示作者才华的部分，但也最容易暴露文章的缺陷。有时，你费尽心思、激情澎湃地写下一大段话，运用了大量的形容词，原是想表达得更加细腻，但写着写着却跑了题，写到最后读者根本不知道你要表达的重点是什么。这就是我接下来要强调的重点：我们的描写，包括精细描写，都是服务于主题。</p><p>举个例子：<br>从北京出发，越过山海关，一条东临辽东湾，西依松岭山，长约 180 多公里的辽西走廊，如刀刻般陷入东北腹地。辽宁就坐落在这咽喉之处。60 多年前，为了争夺东北的工业基地，中国共产党数十万军队从这里秘密出关。如今硝烟散尽，年轻劳动力入关成了这里的常态。数据显示，2015 年开始，辽宁也和黑龙江、吉林一样，人口开始净流出。（摘自《南方周末》）</p><p>这次这个是正例。我们一块看看好在哪里吧。首先，读完这段话，主题我们是清楚的，就是在讲“这几年辽宁的经济形势不好，大量年轻劳动力外流”。那如果只是这样一句话，干巴巴地直接表达主题，那就不叫文章了，那叫资讯。没有任何描写去烘托主题的话，一下就让人失去了阅读的欲望。</p><p>其次，这段话的前面恰好有非常棒的描写。<br>第一句话“从北京出发”，其实是点明了人口劳动力外流的去向是北京。那他们是沿着哪条路呢？有些地理基础的同学应该知道，从东北到中原腹地，如果不翻山越岭，最方便的道路就是辽西走廊。这条走廊发挥着沟通东北和中原经济文化的作用，所以描写它，既是把地理背景勾勒出来，方便读者在脑海中形成画面，也是为接下来的劳动力流动做铺垫。<br>接着，作者开始从时间上的纵深描写，谈到了 60 多年前那场辽沈战役，为什么要写到这点呢？当年，国共两党在东北大打出手，正是为了争夺东北，因为这是我国重工业最发达的地区。而现在东北的经济形势不好，老工业基地有了麻烦，从原来军队出关抢占工业基地，到现在的年轻人为了生计入关，这一进一出之间，实则是为了制造戏剧性的对比效果。你看，所谓的精准描写，本质上还是为了表现文章的主题，让读者产生进一步读下去的欲望</p><h3 id="以正合，以奇胜"><a href="#以正合，以奇胜" class="headerlink" title="以正合，以奇胜"></a>以正合，以奇胜</h3><p>一篇好的文章会有这么几个特质</p><ol><li>文字简单清晰；</li><li>用词恰如其分；</li><li>描写精准、服务主题。</li></ol><p>所谓“以正合”就是用读者熟悉的解读方式、熟悉的意象去讲你的主题，而“以奇胜”就是强调作者自己的思考，利用你的独特观察创造性地去解释读者没有注意到的东西。<br>现今这个内容丰富甚至冗余的时代，写作的主题越来越同质化，如果没有一个独到的主题，这篇文章很难脱颖而出。所谓独到，就是指作者看到了一些读者没有注意到的东西，看了这篇文章后，读者才明白，哦～原来是这样子的。所谓“以正合”就是用读者熟悉的解读方式、熟悉的意象去讲你的主题，而“以奇胜”就是强调作者自己的思考，利用你的独特观察创造性地去解释读者没有注意到的东西。<br>皇上出考题让画家根据“踏花归去马蹄香”来作画，只有一人独具匠心，在全面体会诗句含义的基础上着重表现诗句末尾的“香”字。他的画面是：在一个夏天的落日近黄昏的时刻，一个游玩了一天的官人骑着马回归乡里，马儿疾驰、马蹄高举，几只蝴蝶追逐着马蹄蹁跹飞舞。画面感一下子就出来了。这样的切入角度，写作中也有很多应用。比如《冰点周刊》曾发表过一篇名为《西南偏南》的特稿，作者写西南边境的闭塞和边远，他是这么写的：现代文明一定是吃尽了苦头，才走到西藏边境这个叫做“陇”的地方。2018 年第一个月，爱迪生发明电灯近 140 年后，这里的灯丝终于接入了国家电网。在很多方面，喜马拉雅山南麓这个群山环抱的峡谷都与外界之间存在一定的脱节。书信在此地延续了更长的生命。2006 年这里才进入电话时代，公路要再等 3 年才会开通。第四代移动网络服务迟到了 3 年以上。报纸总是延迟一周送达。首先作者把现代文明拟人化，打破了常规。接着他把现代文明具象化，灯、通信工具、报纸等常见的意象，都用一种奇妙的组合<br>拟人化地展现了出来。这就是典型的“以正合，以奇胜”，这种方式很多公众号都会用，比较有代表性的就是“六神磊磊读金庸”，他里面的很多故事其实都是读者看过的，但他总能找到一个主题把故事重新整合，这就是他的独到之处。</p><h2 id="4大写作误区"><a href="#4大写作误区" class="headerlink" title="4大写作误区"></a>4大写作误区</h2><h3 id="误区-1：滥用形容词和连词"><a href="#误区-1：滥用形容词和连词" class="headerlink" title="误区 1：滥用形容词和连词"></a>误区 1：滥用形容词和连词</h3><p>滥用，不仅指写作者使用形容词不准确，还有堆砌形容词的意思。<br>首先，回忆下我们小时候背诵的优美段落，为什么会觉得优美呢？因为我们发现，这些段落里用的形容词特别多且炫目，有一种到商店选商品看花了眼的感觉。我在百度上随意搜到了一段文字，你感受下：</p><pre><code>青春岁月里的相逢不需要任何约定，偶然擦肩，一个不经意的回眸都可以结下一段美好的缘分。我们都有过花枝招展的年岁，为某个喜欢的人倾尽所有的激情，对着巍峨的高山，对着奔腾的河流，许下滔滔誓言。</code></pre><p>短短的 93 个字，几乎每一句话都有一个形容词，这些形容词似乎让整个段落变得花枝招展，但随着我年岁渐长，已经打动不了我。为什么呢？第一，用得太多了，感受不到它的美妙；第二，用得不准确，让你觉得矫揉造作。</p><p>北宋著名文学家苏轼有个侄儿，有一次他写信给苏轼，向他请教写作方法，苏轼非常认真地给侄儿回了信，他说：“凡文字，少小时须令气象峥嵘，彩色绚烂。渐老渐熟，乃造平淡。其实不是平淡，绚烂之极也。汝只见爷伯而今平淡，一向只是此样，何不取旧时应举时文字看，高下抑扬，如龙蛇捉不住，当且学此。只书学亦然，善思吾言。”什么意思呢？翻译成白话文就是说：“所有的文字，小时候必须让气象峥嵘，色彩绚丽灿烂。逐渐成熟，于是趋于平淡。其实这不是平淡，而是绚丽灿烂的顶点。你只看见我现在平淡，一直只是这个样，为什么不拿我们过去参加科举考试时的文章看看，那时文章高低抑扬，如龙蛇捉摸不定，你现在应当先学习这个。读书学习也是这样，好好想想我说的话吧。<br>其实，仔细想想，为什么小时候要背诵或摘抄绚丽灿烂的文字，主要的目的就是积累，经受这些绚烂文风的熏陶，其实有利于创造者潜在的才情得到激发。用时髦的话说，就是要炫技。然后随着人生阅历的丰富，从绚烂中脱离出来，归于真实。等到了那个时候，你的写作如果再滥用形容词，就会给人浮夸之感。</p><p>不滥用，不是不用，而是要把形容词用精当，就像在一抹绿色点缀了一朵芬芳，让人过目不忘。</p><p>这里以彼得·海斯勒的著作《寻路中国》为例，这是一本非虚构作品，是描写作者在中国自驾过程中的所见所闻。举个书中描写环境的例子，感受下形容词用得精当的好处。相信大部分人都见过：随着年轻劳动力外出，中国部分农村凋敝。如果是你，你会怎么描述？我们来看看《寻路中国》的作者是怎么描述的：</p><pre><code>在中国的有些农村，人们似乎离去得十分匆忙。石磨翻覆在地，泥土地板上散落着垃圾，房屋只剩下框架，与沉寂的墓碑比肩而立。土墙已经开始剥落，每当我看见这些空荡荡的村落，就会对自己说：来晚了。</code></pre><p>这段话你到了几个形容词？只有沉寂和空荡荡两个形容词，其它几乎都是名词、动词。尽管如此，村庄破败的样子也已经跃然纸上，而且印象深刻。这是为什么呢？因为作者找准了意象，这就像元代戏曲家马致远写的秋思，“枯藤老树昏鸦，小桥流水人家，古道西风瘦马”。九个名词性词组就把一副萧瑟的秋景图摆在了我们面前。从这两个例子我们可以看出，描述某个环境、物品或者状态，不需要靠堆砌形容词来完成。我的基本原则是，想不出来精准的形容词，就不要用。</p><p>为什么很多人偏爱形容词，主要有两个原因：<br>第一，是因为你找不到好的意象和细节，就只能通过形容词来修饰。比如你注意不到泥土地板上散落的垃圾，就只能用破旧、散乱这样的形容词来修饰泥土地板，但哪个更好，其实一目了然；<br>第二，就是因为我们认知上存在误区了，总以为写得好的文章，必须多用形容词，而且形容词越少见、越绚丽越好。</p><p>再说说连词的滥用。连词在一篇文章中的作用不言而喻，它往往能使逻辑清楚，方便阅读。但你要知道，我们这里讲的写作不是指写论文，连词用得过多，会影响句子的节奏和美感。<br>比如，清风徐来，水波不兴，这句话就暗含了因果关系，但我们写的时候，难道要写成，因为清风徐来，所以水波不兴吗？再比如，秦末天下大乱，群雄并起，这句话也暗含了因果关系，按照中文写作的习惯，没有必要写成，由于秦末天下大乱，群雄并起。<br>上述表达虽然形式上注重了逻辑，但一定不会让你感受到文字的美妙。我的建议是，除非逻辑表达容易混淆，否则，慎用连词</p><h3 id="误区-2：中文西化"><a href="#误区-2：中文西化" class="headerlink" title="误区 2：中文西化"></a>误区 2：中文西化</h3><p>刚才我们说了遣词方面的误区，接下来我们讲句式上的误区。这些年，随着懂英语的人越来越多，很多人不可避免地受到了英语句式的影响，喜欢用倒装句、从句来表达一件事情。比如中文的习惯表达，是“动词 + 名词”，但受到英语影响，我们把名词倒置。例如，“选购书籍”会写成“书籍的选购”。<br>这种写作表达，进而会影响到长句。比如，中文表达，习惯用人来做主语，但同样受到西方影响，很多人喜欢用抽象名词来做主语。举个例子，他因为收入减少，不得不改变了生活方式。如果用西化的表达方式，这句话就变成了：收入的减少让他不得不改变了生活方式。<br>当然这算不得错，但是这会影响中文表达的美感，长此以往，会贻害我们的写作。比如你明明可以写“这个人素有名望”，非要造一些抽象名词，写成“这个人具有很高的知名度”。<br>这里，推荐已逝的余光中先生的一篇文章，《怎样改进英式中文？——论中文的常态和变态》，相信你看了，一定收获颇丰，能更直观地感受到其中的别扭。</p><p>常见的三种中文西化的表现。<br>第一，滥用被字句。比如他被升为省长，他不被准许上课，这些表达都失之生硬，和我们传统的中文生态有很大区别，不如改成：他升为省长，他未获准上课。那什么时候用被字句呢？当我们需要强调主语的不如意、出乎意料时，可以用被字句。我举个例子，蛇把小王咬了和小王被蛇咬了，哪种表达更好？显然是被字句更好，因为蛇和我们并不同类，很难引起我们的共鸣，把小王放在主语位置，既突出了小王的不如意，也能让读者有一种强烈的代入感。再举个例子，比如我想写一篇文章，谈快餐对中国文化的影响。那么，我开头写，“快餐逐渐被中国人喜欢”就比“中国人越来越喜欢快餐”的表达要好，因为文章主旨就是为了强调快餐。但我还是要强调，中文的正常表达，是主语 + 动词 + 名词，要改变句式顺序，一定要有特别的原因。<br>第二，喜欢用弱动词。所谓弱动词，我一般称之为“万能动词”，比如造成、进行这样的动词。举个例子，飞机失事，造成一百多人死亡，这句话里的造成就是弱动词，这样用不会错，但却体现不出动词的美感。还不如直接写，飞机失事，死了一百多人。再举个例子，陈景润对数学问题进行了详细的研究，“进行”这个动词放在这里，让人觉得莫名其妙，直接写，陈景润对数学问题详加研究，就好了。<br>第三，喜欢用从句。特别是在修饰一个名词的时候，用一个很长的句式来表达。比如，武汉疫情中，有人想起了去年樱花绽开的时候，这样写了一句：被困在家的日子里，我想起了去年樱花盛开、游客满园的那天。这就不太符合中文的写作习惯，啰嗦半天，读者才知道樱花盛开、游客满园这样的从句是来描述那天的情景，为什么不简练一点，直接写：被困在家的日子里，我想起去年那天樱花盛开、游客满园……</p><h3 id="误区-3：随意堆砌段落"><a href="#误区-3：随意堆砌段落" class="headerlink" title="误区 3：随意堆砌段落"></a>误区 3：随意堆砌段落</h3><p>一般而言，段落与段落之间，本来就具有递进关系、转折关系，写作时处理起来不难，顺着往下写就好了。但是，当上个段落和下个段落并不具有上述关系的时候，需要从 A 内容跳到 B 内容，很多人写作的时候，常犯的毛病就是直接把这些段落放到一起，没有联系，这样的话，读者感受不到你的巧思，而且很容易打乱文章的节奏。要解决这个问题，有很多技巧，比如使用过渡句。<br>以彼得·海斯勒《寻路中国》这本书为例，看看作者是怎么把两个段落有机联系起来的。比如上一段，作者想写在中国自驾时为自己定下了许多规矩，以免惹上麻烦；下一段要写中国法律对驾驶员的身体方面作出了非常详细的规定。这完全是风牛马不相及的两件事，那怎么从这一段跳到下一段呢？<br>我先把作者的两个段落贴出来：</p><pre><code>A 段落：一路上，我给自己定了一些规矩，并尽量遵守。日落后安营扎寨，天一亮就动身出发。中午时分，我通常把车停在路边打个盹。我从不在夜间开车。B 段落：手册规定，卡车驾驶员身高至少达到 155 厘米，小轿车驾驶员的身高至少到150 厘米。在中国要取得驾照，每只手上至少有三个手指功能正常，大拇指是必不可少的。</code></pre><p>那这两个段落作者是怎么联系起来的呢？<br>接着 A 段落的最后一句，我从不在夜间开车。作者继续写道：在中国的公路上，疲劳这个问题甚至出现在驾驶员考试题里。133 题：如果行车达 4 个小时，驾驶员必须停车，并强制休息至少：A.10 分钟；B.20 分钟；C.15 分钟。正确答案是 B。如果你只休息一刻钟，那么缺少五分钟也是违规的，至少规则手册里是这么描述的。接着，作者马上接上了 B 段落第一句，手册规定，卡车驾驶员身高至少达到 155 厘米。</p><h3 id="误区-4：缺乏逻辑思维"><a href="#误区-4：缺乏逻辑思维" class="headerlink" title="误区 4：缺乏逻辑思维"></a>误区 4：缺乏逻辑思维</h3><p>写文章，简单来说就是用语言传递信息，体现出的是作者的思考。很多人的写作有这样一个误区，洋洋洒洒几千字，但文章没有逻辑，或者说通过推演论证，得不出你想论证的结论。<br>要解决这个问题，我们首先要明白，写作的第一要务就是要清楚地表达信息。信息通常被分成 3 类：</p><ul><li>第一是记述信息，是指用于描述事物的情况和现象信息，比如“这瓶矿泉水的容量为500ml”；</li><li>第二是评价信息，是指价值判断，比如“500ml 的容量已经很大了”；</li><li>第三是规范信息，即事物应该有的状态以及人该采取的行动，比如“一瓶矿泉水的容量就应该设定在 500ml”。</li></ul><p>我们要根据不同的文本，使用不同的信息。比如，对专业论文来讲，多用记述信息，因为准确；对科普文章，就要多用些评价信息，方便理解。清楚地区分了信息的种类，接下来就是组织这些信息，怎么组织呢？<br>通过下面这个例子，我们可以先感受下，逻辑思维的重要性。这个例子选自《华尔街日报是如何讲故事的》这本书。</p><pre><code>“许多医疗专业都缺少医生，这一现象正变得越来越严重”，美国医疗协会的主席约翰塞波恩说。来自洛杉矶西奈山雪松医疗中心的外科主治医生詹姆斯希波恩也说，“医疗保健的质量正在下降”。在明尼阿波利斯总医院的主任医师爱德华也说，我们现在就需要增加至少 5 个产科医生。</code></pre><p>我们分析下这段文字，作者想传递的观点是，医生紧缺，直接导致了医疗保健质量的下降。现在是需要我们引用权威言论或者事实依据来支持这个论点，上面这段话的论据虽然有了，但散乱，没有经过搭配，结果是缺乏可信度。</p><p>那怎么改写呢？第一，在论证方式上下功夫，比如对比论证；第二，用权威的数据；第三，用最有代表性的权威言论。</p><p>根据这三条，修改以后就变成了：<br>在明尼阿波利斯总医院，获得批准的助产士现在可以直接接生婴儿。之所以如此，是因为医院的产科医生数量不断减少，现有的产科医生已经不堪重负。在洛杉矶西奈山雪松医疗中心，一些非急需的手术被推迟到数月之后，詹姆斯希波恩医生的解释是，医疗保健的质量正在下降。根据美国医疗协会的说法，全国现在急需大约 5 万名不同专业的医生，从内科医生到放射科医生，都非常紧缺。<br>再看看这段文字。第一，增加了对比论证，产科医生减少，和产科医生对应的助产士可以直接接生婴儿；第二，放入了数据，相当于我们前面讲的记述信息，在这里它是比评价信息更有说服力的证据；第三，保留了一位权威医生最精辟的话。可以说，这里使用了三个主要证据，使得整个信息变得有趣和权威起来，这就是逻辑的力量。</p><h1 id="写作方法"><a href="#写作方法" class="headerlink" title="写作方法"></a>写作方法</h1><h2 id="如何量身打造一个好的写作主题？"><a href="#如何量身打造一个好的写作主题？" class="headerlink" title="如何量身打造一个好的写作主题？"></a>如何量身打造一个好的写作主题？</h2><p>你想表达的主题，一定要和某个更大的东西联系起来。这个更大的东西可能是一种情感，比如爱、孤独；也可能是一种观念，比如自由、平等；还可能是一种反思，比如对公共安全的拷问等等。我们写作其实就是在寻找这个更大的东西。那如何找到这个更大的东西呢？下面两种常用的方法。</p><h3 id="打开宽度：跨领域思考"><a href="#打开宽度：跨领域思考" class="headerlink" title="打开宽度：跨领域思考"></a>打开宽度：跨领域思考</h3><p>打开宽度、跨领域思考，称之为发散思维。<br>先从一个例子讲起，微博上有过这样一个热搜，热搜词是“散装卫生巾”。按常理来说，现在已经是人类文明最为富足的时代了，像卫生巾这种日常使用的必需品，应该是人人都买得起、用得起，想不到还有平台售卖散装卫生巾的，让人觉得惊奇。好了，我们现在想写一篇文章来谈谈“散装卫生巾”这个话题，我们第一步要做的就是确定主题。怎么确定呢？这里就可以用到跨领域思考。所谓跨领域思考，其实并不神秘，就是根据我们常见的一些分类来寻找主题。比如领域分类，政治经济文化；比如性别分类，男性女性；比如年龄分类，老中青。不同的分类意味着不同的观察视角。<br>我们继续用“散装卫生巾”这个例子，来看看具体怎么用这个方法。首先，我们从这个话题可以抽离出一个基本的判断，这是一个女性议题。既然是女性议题，那么它的对立面就是男性，那么男性如何看待这个议题，自然而然就形成了一个视角。但是这个视角太容易想到，很多人都会从这个视角出发，去构思整篇文章。写作者可以发挥的空间很少，所以如果是我，就会放弃这个视角。这条路不通，我们就换下一条路。我们按照政治经济文化这个常见分类来思考，具体分析分析。<br>第一，政治角度。说到政治，在我们日常生活中就主要表现为政策，所以我们大可以从政策的角度去想想，这个话题应该怎么聊。搜索后发现，很多地方政府都出台了一些政策，比如 2019 年山东省就出台了《山东省女职工劳动保护办法》，里面提到要为经期女工给予保护。<br>一个政策体现的是官方的态度，所以我们完全可以写篇文章来谈谈各地政策，围绕经期女性都提供哪些政策支持，相同在什么地方，不同点在哪。由此，我们可以确定一个主题：地方政策当中经期女工的权利保护。<br>第二，经济角度。我们遵循同样的思路，说到经济，你会想到什么，价格、税收、贫困、经济福利等等。记住这些要素，对我们下一步分析有帮助。<br>我们分析“散装卫生巾”为何存在？是因为有人买不起正常包装的卫生巾，那为什么买不起呢？因为它太贵。那下一个问题是，一包正常包装的卫生巾价格，税收是多高呢？我到网上去搜了下，我发现在我们国家，卫生巾的征用税率是 13%，这是增值税里最高的一档。下一个问题，如果税收很高，能否把降低甚至取消卫生巾税收，作为经济福利呢？如果不能降低或者取消，原因是什么？当你问完这些问题，其实我们从经济角度已经确定了一个主题：女性摆脱“月经贫困”的阻力在哪？<br>第三，文化角度。说到文化角度，一个比较常见的角度就是，女性主义的观点。女性主义者认为，现代社会依然是一个父权制社会，对女性议题的看法始终站在男性立场，比如有男性会认为，一包卫生巾不过是一杯奶茶的价格，省这点钱买散装卫生巾，有必要吗？所以，我们可以根据这点展开，来谈论男权社会下的女性议题困境。<br>同样，如果你的阅读量够大，读过一些女权主义的著作，是很容易想到这个角度的，也很难写出新意。所以，我们还可以考虑换一个文化角度，为什么现在很多人谈到月经，依然会觉得难以启齿，为什么微博上讨论这个话题时，下面的评论仍然会问出一些缺乏常识的问题，实际上这是因为月经长期以来是一种文化禁忌，那么这种禁忌是怎么来的？历史上有过哪些演变？根据这个思路，其实我们就从文化角度找到了一个切入口：视而不见的月经禁忌。<br>跨领域思考，学会这个方法的关键，就是你一定要锻炼发散思维。<br>一种常用的方法吧。打开微博看热搜，找出自己觉得有意思的话题，先不要看评论区；然后在头脑中或者笔记本上，根据这个话题，想出或者写出几个角度；最后再去对照评论区中不同的人写的观点，看看哪些自己想到了，哪些没有想到。这个方法对我的帮助非常大，直到现在我也还在使用。</p><h3 id="挖掘深度：由表及里"><a href="#挖掘深度：由表及里" class="headerlink" title="挖掘深度：由表及里"></a>挖掘深度：由表及里</h3><p>如果说第一种方法是通过发散思维来确定主题的，那么我现在要讲的第二种方法，对应的就是逻辑思维了。第一种方法适用于开放性话题，而第二种方法比较适用于对某一个现象的分析。</p><p>举个例子，某个地方的高速出口老是出事情，隔一段时间，就会发生车祸。那段高速出口有点特殊，就是当初设计的时候，因为地形的限制，这条高速公路到这个出口的最后十公里都是下坡路，比较陡。像货车这种大型卡车，因为超载或者疲劳驾驶，每次过这段下坡路就很危险，特别是第一次跑这条路的货车司机，面对这样的下坡路，容易麻痹大意，不减档、不提前刹车，一旦发生紧急情况或者到最后 100 米，才注意到前面有个收费站需要停车时，车根本停不下来，结果就是货车撞向收费站，造成人员伤亡。<br>大概能想到这几个原因：</p><ol><li>长下坡路的设计不合理；</li><li>货车司机麻痹大意；</li><li>在长下坡路段后，设置一个收费站也不合理</li></ol><p>在公共平台上，95% 的文章分析这个现象都会从这 3 个原因中选一个原因来写。如果我们再定这个主题，已经很难出彩了。</p><p>所以我们得另辟新径，既然这个地方老出事，作为政府一定想过一些措施来规避，那么都采取了哪些措施呢？这条高速路上有减速带、醒目的提示牌、强制停车点、避险车道等等，而且知道这些措施各自的作用是什么。对比这 4 种措施，很容易就能想到，避险车道是司机在遇到紧急情况时，可以主动选择的避险方式。<br>所谓避险车道，就是设置在下坡路段车道外侧的专用通道，这个通道一般会铺设砂砾石等材料，司机一旦发现车辆失控，可以开进避险车道，在阻力的作用下，让车辆在短时间内减速、停止。<br>事实上，解决下坡路段的交通安全难题，避险车道在理论上也被认为是最有效的方式之一。<br>接下来的问题就变成了，既然司机知道车辆失控了，为什么很少有车辆主动开进避险车道，避免事故的发生呢？是因为避险车道数量太少？还是因为没看见？或者是因为司机明知有避险车道，但还是选择了忽视？无论是上面哪种原因，我们都找到了一个新的写作主题，那就是“高速路上的避险车道难题：有意回避还是无意忽视”。<br>这段分析，其实就是通过层层剥茧、由表及里，不断地追问，从而确定了文章的主题。</p><p>再举个例子，这是生活中一个很普遍的现象。很多男性下班回家，到了地下停车场，都会在车里待一会儿抽根烟、听听歌，甚至就静静地坐在车里，过了好一阵才回家。现在，你观察到了这个现象，并想动笔谈谈自己的体会，你要怎么确定主题呢？<br>这个现象就很适合用挖掘深度这个方法。我们简单分析下，他们为什么不马上停好车回家？如果只是因为累了，那他完全可以回家后或者在公司休息，显然这不是主要原因，那是为什么呢？进一步分析，我们可以联想到一个原因，他们是在逃离或者躲避什么。<br>紧接着，新的问题又来了，这种逃离或者躲避是长期的吗？不是，因为他们只是在车里待一会儿，说明这种逃离或者躲避是短期的，最终他们还是会回到现实中来。下一个问题是，他们在逃离什么呢？当然是逃离家。家意味着什么？柴米油盐，我们进一步抽象出来，家的意义里面，有一层意义代表着琐碎的日常生活。<br>综合上面的分析，我们可以得出这样一个结论：这个群体其实知道逃离的行为是短暂的，因为迟早都要回到现实。但为什么还要这么做呢？因为人行为背后的动机有时候并不重要，也许在此时此刻，他们才放下了生活中的一切面具，回到了那个最真实的自己。换言之，这个现象背后其实反映出来的是人类对日常生活那种逃离的欲望，再进一步升华，其实是人类对自由的向往。根据这个分析，我们就可以确定一个写作主题：独处是灵魂的短暂假期。</p><h2 id="如何为主题搭建一个好的结构"><a href="#如何为主题搭建一个好的结构" class="headerlink" title="如何为主题搭建一个好的结构"></a>如何为主题搭建一个好的结构</h2><p>如何为这个主题搭建一个好的结构。事实上，这个问题常常被忽略。为主题找到一个好的结构，就像是有了一幅路线图，它为我们的主题提供了执行的步骤和模块。不仅如此，一个精心安排的结构，能让读者更快地进入角色，明白写作者想要表达什么。</p><h3 id="一句话法则"><a href="#一句话法则" class="headerlink" title="一句话法则"></a>一句话法则</h3><p>好的文章一定是饱满的，而饱满的表达一定需要一副好骨架。其中，主心骨是必要的，它决定了这篇文章能否打动人，是否具有吸引读者阅读的价值。那怎么确定主心骨呢？简单说，就是用一句话来确定文章的主线，我们通常称之为“一句话法则”。它由美国著名作家罗伯特·麦基提出。他在自己的著作《故事》这本书中提到，“文章的真正主线不是一个词语，而是一个连贯的句子，这个句子一定能够清晰地概括整篇文章”。这里需要特别说明一下，主题和主线是不同的概念。主题一定是和一个更大的东西联系起来的，比如爱、孤独，再比如自由、平等；而主线是概括整篇文章内容的。</p><p>举个例子，著名的电影《阿甘正传》，请你想想它的主题和主线分别是什么。<br>在这部电影中，主题就是坚强，即便你坠入深渊，也要抗击。如果用文艺点的话说就是，“当你认清了生活的本质，你还热爱它，那你就是英雄”。电影里阿甘不就是这样的人物吗？<br>那主线又是什么？用一句话概括整部电影的内容就是，“傻子”阿甘，本着说到做到的信念，跨过重重障碍，闯出了一片天空。</p><p>明白了主题和主线的区别，那怎么践行一句话法则呢？<br>这就需要我们写作者去判断，你想写的内容中，最打动你的价值是什么，然后把它概括出来。举个例子。2020 年 8 月 4 日，服刑了 26 年的江西“杀人犯”张玉环被江西省高级人民法院宣告无罪。好了，这是一个众所周知的事件，假如我们想写，26 来张玉环的前妻是怎么生活的，怎么为他申诉的。<br>最重要的就是找关键词，这个关键词代表着最能打动你的价值。<br>就上面的例子而言，我想其中有一个关键词是“污名”。之所以会想到这个词，第一，因为她的前夫是一名“杀人犯”，一定会遭到当地人的说三道四；第二，在张玉环服刑期间，她改嫁了，这点在传统农村是很难被人接受的，同样会受到歧视。那么第二个关键词，我会想到“信念”。因为尽管自己被污名化，26 年来，张玉环的前妻依然四处奔走，支撑她的一定有一种信念，而这个信念是可以打动人的。综合上面的分析，我们就可以确定文章的主线了：一名“杀人犯”的前妻，在流言蜚语之下，凭借着某种信念，在长达 26 年的时间里为前夫伸冤，最终成功。总结来说，主心骨就是通过“一句话原则”，先确定价值（找关键词），再高度概括。</p><h2 id="三段式结构"><a href="#三段式结构" class="headerlink" title="三段式结构"></a>三段式结构</h2><p>通过三段式的经典结构搭建出骨架。三段式之所以经典，是因为它最接近于人类思考问题的方式，也因此最容易被接受。比如我们分析一个现象的原因，常常会有这样的感觉，说 2 个理由太少，说 4 个理由太多，3个理由首先、其次、然后刚刚好。再比如我们的经典模式，是什么、为什么、怎么办，以及提出问题、分析问题、解决问题等等，都是三段式的。有科学研究表明，三段式符合大<br>脑记忆的规律，刚好构成了完整的因果关系。<br>写作里面的三段式是什么呢？就是触发、冲突和解决。</p><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>所谓触发，就是导火索。如果写的是一篇评论文章，就是指引子，比如近一年来接连爆出多起性侵未成年的案件，这就可以用一个最近的例子作为引子。<br>2020 年 6 月 17 日，经过长达 16 个小时的庭上激辩，58 岁的原新城控股董事长王振华涉嫌猥亵 9 岁儿童一案最终宣判，王振华一审获刑 5 年。随着王振华案的宣判，备受关注的性侵猥亵未成年话题再次回归大众视野。</p><p>这个引子，其实包含了以下 3 个基本问题：</p><ul><li>主要事件是什么？猥亵未成年；</li><li>事件发生在什么情景里？法院宣判了；</li><li>事件留下的悬念是什么？5 年判刑合理吗？</li></ul><p>如果写的是一个故事，以上面讲的张玉环事件为例，那触发就是张玉环出狱了，前妻终于见到了张玉环。这个触发也包含了 3 个基本问题：</p><ul><li>谁是主要人物？张玉环及其前妻；</li><li>发生在什么情景里？张玉环出狱和前妻见面了；</li><li>悬念是什么？见到了之后，他们怎么样了？</li></ul><p>一般来说，这 3 个基本问题，就是一个骨架里“触发”部分应包含的内容。</p><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>所谓冲突，就是文章内容里的矛盾之处，这种矛盾有大有小，找到矛盾的主要目的，就是为了让读者对内容产生认同。换句话说就是，写的内容，和你的生活具有接近性，笔下的矛盾，你也可能遇到。不能体现矛盾的文章，是没有吸引力的。即使写广告软文的时候，也要巧妙地设置冲突。<br>还是以张玉环前妻为例，这里的冲突就主要有：</p><ul><li>邻里对她的态度；</li><li>家庭成员对她的态度；</li><li>现任丈夫对她态度；</li><li>奔波中遭遇到的困难。</li></ul><p>冲突部分是最吸引读者的部分，越是把某个现象、人物推向两难的境地，就越能揭示一个事物的本质</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>解决就很好理解了，就是指这个问题、现象或者人物，在经过我们分析、描述、刻画以后，有了一个新的看法或者最终的结果。<br>比如，张玉环事件中，最终的结果是：在各方的帮助下，前妻的不断申诉下，张玉环最终出狱了。这当然也算是解决。但这样解决也太平淡了，我们写作时，为了让文章好看，往往会给解决这部分内容，留个有韵味的收尾。比如，张玉环出狱了，前妻在前往见他的途中，因为激动昏倒了，她等了20 多年的拥抱还是没有到来。通过上面对张玉环事件的描述，相信你已经感受到了，这天生是一个好故事。特别是当我们通过层层分析，把主心骨和骨架搭建好以后，这篇文章的脉络就清晰了，写起来也容易很多。</p><p>那到这，我们已经为文章找到了一个很棒的结构骨架，主心骨就是主线，长出的骨架就是“触发、冲突、解决”，接下来我们就可以根据这里的每个部分组织你的材料了。</p><h3 id="时空坐标系"><a href="#时空坐标系" class="headerlink" title="时空坐标系"></a>时空坐标系</h3><p>这种属于物理学范畴的理论也能应用于写作吗？当然可以。所谓时空坐标系，就是建立起时间和空间两条线，它就像文章的两个锚，抓住了它俩，骨架就好展开了。</p><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>先说时间。顾名思义，就是按照时间线开展你的写作。这种方式，简单实用，但有时会让读者觉得枯燥，比如“流水账”写法，所以我们在写作中才会采用倒叙、插叙等方式。<br>这里要介绍的肯定不是这两种最常见的方式，因为它们都很简单，接下来要讲的是写作中常用的双时间线方式。所谓双时间线，其实并不复杂，简单说就是用短时间线串起动态的场景，长时间线作为整个文章的背景。<br>这种方法比较适合以下两类场景：</p><ul><li>时间跨度长；</li><li>事件或者人物主角出现的场景不断变化。</li></ul><p>2020 年的某一天下午 2 点半，在一条敏感的军事边境线上，A 国的人开车逃向了 B 国。现在我们想写一篇文章来讲述这个罕见的逃亡过程，并追寻逃亡背后的原因。</p><p>这时我们就可以先用短时间线切入来作为场景。</p><p>2020 年的某一天，这天刚好是星期一，按照惯例这条军事边界线不对外开放。因为没有游客到来，周边区域显得空荡。当天下午 2 点半，空无一人的小道上，一辆蓝色的吉普车高速前行，向右转弯，接着向左，5 分钟后，高速冲过了桥头的哨所。一名士兵驾驶着这辆蓝色的吉普车，上演了一场惊心动魄的非典型逃亡。他的目标只有一个，就是冲过军事分界线，成功逃往 B 国。<br>在上述这个短时间线的切入下，文章的部分骨架已经展开了。接着我们可以进一步展开，展开的落脚点就是这条军事分界线。这是因为这条军事分界线后面隐藏了很多问题，比如这条分界线从古至今是什么样子的？怎么形成的？士兵为什么要从这里逃亡？<br>围绕着这条军事分界线，我们就可以套入一个长时间线。上世纪 50 年代，停战协定在这里签字，这条军事分界线也扬名于世……这样写，我们就把文章结构展开到了上个世纪，一条长的时间线为文章提供了时代背景。这种时间“套路”在写作中的运用比比皆是</p><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>当一篇文章不适合用时间线串联的时候，在空间上展开文章的骨架也是一个很好的方法，它比较适合一些宏大的主题。<br>比如我们设想一个场景：今天你所在的城市突然停电了，你看到不同的人面临停电时的千姿百态，想写篇文章描述这个场景。想想你会怎么展开这个骨架呢？<br>范承刚有篇文章《深圳停电两小时的民间细节》是如此描述的：</p><pre><code>这是深圳三十年来最大范围的停电事故。福田、罗湖及龙岗三地 2010 年的常住人口达431 万人，丧失电力供应的正是最繁华的区域。东南门路口，交警袁竣桦成了最忙碌的人。头顶的大厦与周遭的公路都沉入晦暗，没有了红绿灯，也没有了监控录像，一些车开始横冲直撞，四十多辆车迅速挤成一团，将十字路口变成了临时停车场，更多的车辆则被死死塞在三十余米宽的大道上，车龙绵延六百余米。光明的隐退带来声音的嘈杂。行人不再走人行天桥或过街隧道，而是如蝌蚪一般穿梭在车龙中，当晚近 30 度的高温让正在路上的人们汗流浃背、心烦气躁。</code></pre><p>242 个字，作者只描述了一个场景，停电后的公路。在这个场景里，其实有很多元素可以写，但作者抓住了几个空间元素，交警头顶的大厦和周遭的公路，公路上的红绿灯、车辆和行人。描述的顺序是从头顶到周边、从公路高处的红绿灯到公路上的车、人，每个元素依次铺开，骨架在空间的叙述下被带了出来，很自然，就像流动的水，让人记忆犹新。</p><h2 id="必学必会的几大开题手段"><a href="#必学必会的几大开题手段" class="headerlink" title="必学必会的几大开题手段"></a>必学必会的几大开题手段</h2><p>怎么设计一个好的开头。对一篇文章来讲，开头的重要性不言而喻。因为这个时代的阅读习惯，能读到结尾的人很少，大多数人只会看一眼开头。所以，我们不得不确保头两三段，就能调动读者的期待。</p><h3 id="一个好的开头应该包括哪些因素？"><a href="#一个好的开头应该包括哪些因素？" class="headerlink" title="一个好的开头应该包括哪些因素？"></a>一个好的开头应该包括哪些因素？</h3><p>开头是什么？一般来说，就是指为对方建立一个框架，确立时空坐标系，让对方进入这个坐标系，来理解你的文章。开头的形式有很多，比如开门见山、类比、引用等等。在我看来，只要这些形式能够激发读者的兴趣，都可以采用，并无定法。所以这里，我们就先抛开形式不谈，主要聊聊形式背后的本质。优秀的文章开头，它们大多有个共同的特质，那就是神秘或冲突。<br>神秘就是先给读者一个悬而未解的问题，迫使他到后面的段落中去寻找答案。而冲突就是给读者营造一个矛盾的氛围，在这个氛围中，吸引读者去理解这个矛盾的症结。<br>当然，一个优秀的开头，往往这两个因素都会有。比如 2007 年林珊珊在南方人物周刊发表的《少年杀母事件》的开头：</p><pre><code>张明明决定杀掉他的父母。这个想法在他脑中盘旋了差不多两个月。“我想，只有杀了我的父母，才能让我多年积累的仇恨得到释放，让我真正地过着无拘无束的生活。”</code></pre><p>这个开头，成为后来许多写作者模仿的对象。因为它把神秘和矛盾巧妙地揉合在了一起，既开门见山，又悬念十足，迫使我们想把故事继续读下去。因为和张明明决定杀掉父母前一样，我们头脑中也有很多疑问在盘旋：为什么要杀父母？两个月期间，张明明做了什么准备？积累的仇恨到底是什么？他期盼的无拘无束的生活又是什么？<br>当你接触到一个杀人事件，决定写一篇文章来描述它。此时，你的身份其实就是一位读者，你想想哪些问题是读者最关心的，哪些因素是最能让他们有代入感的，那就把它作为开头的部分，用文字表达出来。换句话说，当你打算写一篇文章，搭建好框架之后，就要把文章中最神秘、冲突的因素放在最前面，重新组合，然后再娓娓道来，读者体验会好很多。<br>这个方法理解起来并不难，要找到或神秘或冲突的因素也不难，但有哪些方式可以把这些因素表达出来呢？<br>先分享一个小技巧，看商业大片，特别是一些悬疑片，它们的开头往往处理得很好。俗话说，外行看热闹，内行看门道。所以，你看的时候，一定不要只是图热闹，而是要分析，它是怎么展现神秘或者冲突的，最后用文字把这个开头画面写出来。举个例子：<br>温子仁导演拍的悬疑片《电锯惊魂》，主要写的是一个废弃地下室内有两个男人，我就叫他们亚当和戈登吧。他们在别人的逼迫之下玩起了死亡游戏，在固定的时间里，他们必须找到线索逃离这里，否则就会死去。电影的开头是什么呢？用文字写出来，你感受下：<br>黑色的房间里，亚当从有水的浴缸里醒来。他发现自己被困在一间破败的地下室内。在他的对面，是同样手足无措的被困者戈登——他俩被人用铁链绑住了腿。在他俩中间，横亘着一具躺在血泊中的尸体，手里握着一把手枪。没人知道自己为何被绑，也不明白自己为何出现在这里，应该做些什么。但凶手已经把提示留给了他们。<br>如果你看过整部电影，你就会发现，导演采用的方法就和我上面讲的一样，他把影片中最神秘、冲突的因素直接放在了开头，而不是把亚当和戈登如何被绑架放在最前面。这样安排，显然是导演精心思考的结果。虽然，遭神秘人绑架也充满了悬念，但实际上这已经为观众开启了上帝视角，因为相比于主人公，观众已经知道了他们是被绑架过来的。而现在这个开头，观众就和主人公一样，不知道自己为什么会出现在这里，悬念十足。这样精心设计的开头会让观众的代入感更加强烈。</p><h2 id="该怎么为开头找到一个大概的样子"><a href="#该怎么为开头找到一个大概的样子" class="headerlink" title="该怎么为开头找到一个大概的样子"></a>该怎么为开头找到一个大概的样子</h2><p>再说第二个问题，当你找到写作中最精彩的元素之后，我们该怎么为开头找到一个大概的样子呢？这里分享三个步骤。<br>第一步，就像上面讲的那样，找到写作内容中最具神秘、冲突的部分，把它记录下来。有时候，它甚至可以直接作为开头。<br>比如，2020 年 7 月 20 日，有人在贴吧发了一个帖子，浙江大学建筑工程学院某某试图强奸一位女性，随后被逮捕。后经法院判决“强奸罪”后，被判有期徒刑一年，缓刑一年半。判决结果出来后，浙江大学只是给了留校察看的处分。实际上，这已经出乎很多人意料了。所以，这个冲突桥段已经构成了最好的开头：“强奸、判缓刑的，居然没被学校开除？”2020 年 7 月，一个论坛上一篇名为《公开的违纪处<br>分消息好久没有这么劲爆了》的帖子，为公众披露了这么一起校园强奸案。<br>当然，也有另外一种情况，对于我们接触的一些材料，想找到最有意思的元素需要花费一些功夫。这就需要我们进一步探索，看看这些神秘、冲突因素背后的人和事，有没有更为引人注目的特质。这就来到了下一步。<br>第二步，把写作内容中最具神秘、冲突的部分进行拆分，拆分成人物、事件、地点、时间、数据等小元素，然后把其中的 1～2 个小元素放大。比如南香红撰写的《木卡姆：人间非典型音乐》，就是一个很好的例子，它把地点进行了放大。</p><pre><code>在中国的地图上，你的眼睛一直向西，向西，再向西。找到新疆，找到喀什，再向西南方向，你会看到崇山峻岭的喀拉昆仑山和昆仑山上，有一条细幼的河蜿蜒而下，这条河上标有一个陌生又好听的名字———叶尔羌河。河在塔克拉玛干沙漠的西南部，划了一个弧和塔里木河连接在了一起。一大片一大片黄色的沙漠，一小块一小块人类可以居住的绿洲。沿着这条河滋养的绿洲生活的人，他们把自己称作刀郎人，他们把这条叫叶尔羌的河称作刀郎河，他们把自己唱的歌跳的舞叫做刀郎木卡姆。</code></pre><p>为什么选择放大地点呢？因为对绝大多数读者来说，这是一个十分陌生的地方。把它放在前面，就是放大这个特质，告诉读者这里的神秘。<br>这个开头中还暗含了两个小技巧<br>第一，作者不是直接告诉你，在新疆昆仑山上，有一条河叫叶尔羌河。而是开头直接用“你”这个人称代词来拉近距离，让读者跟着她的笔触，一步一步探究。<br>这是一个很有用的技巧，在一些广告软文、纪录片台词中经常被用到。比如豆瓣评分 9.2分的纪录片《航拍中国》第一季的开头文案：</p><pre><code>你见过什么样的中国，是 960 万平方公里的辽阔，还是 300 万平方公里的澎湃，是四季轮转的天地，还是冰与火演奏的乐章。像鸟儿一样，离开地面，冲上云霄，结果超乎你的想象，前往平时无法到达的地方，看见专属于高空的奇观。俯瞰这片朝夕相处的大地，再熟悉的景象，也变了一副模样。从身边的世界，到远方的家园，从自然地理，到人文历史，50 分钟的空中旅程，前所未有的极致体验。从现在开始，和我们一起，天际遨游。</code></pre><p>第二，一个优秀的开头除了有趣之外，我们还得在前几段就告诉读者这篇文章究竟要写什么。比如在《木卡姆：人间非典型音乐》这个例子中，作者在第一段交代了很丰富的内容，紧接着第二段就介绍了这篇文章的主题，出现了要讲的人物。</p><p>第三步，为那些放大的特质建立画面。这一点非常重要，这时你可以把自己想象成一名导演，想想该如何为这个特质构建一个画面。<br>我们接着分析前面木卡姆那个例子。在确定了要放大地点这个特质以后，紧接着就需要把这个特质描述出来。怎么描述呢？第一找意象，第二局部特写。作者找到的意象是河、沙漠、绿洲等等这些最能代表这个地点特质的事物。接着对这些事物进行了局部特写，河蜿蜒而下，划了一个弧；沙漠与河相连，是黄色的；绿洲是小块的。</p><pre><code>有一条细幼的河蜿蜒而下，这条河上标有一个陌生又好听的名字———叶尔羌河。河在塔克拉玛干沙漠的西南部，划了一个弧和塔里木河连接在了一起。一大片一大片黄色的沙漠，一小块一小块人类可以居住的绿洲。</code></pre><p>以上就是开头的三步法，根据这个法则，我再举个完整的例子，带你一起感受下。比如，有一篇人物软文交到了你的手上，主人公是演员胡歌。那我们怎么开头呢？</p><p>第一步：找神秘、冲突的部分。<br>我们都知道胡歌曾经出过车祸，他的脸遭受过极大的损伤。而后，他淡出银幕很长的时间。2015 年，随着琅琊榜热播，他再次声名鹊起，在剧中，他饰演的梅长苏也曾更换面容，获得重生。围绕这个基本事实，我们比较容易联想到，他刚刚出道时，在《仙剑奇侠传》里扮演的李逍遥这个角色，这两个角色一前一后，中间经历了车祸，物是人非，已经构成了一组比较好的冲突架构。<br>第二步，把写作内容中最具神秘、冲突的部分进行拆分。<br>那么这个冲突后，最明显的特质是什么呢？脸嘛。他至少有两点，是可以谈的。第一，俊俏的脸庞对明星意味着什么，这是不言而喻的；第二，恰巧这张俊俏的脸庞又受了伤，是很能代表这个人物经历的。<br>第三步，为特质建立画面。<br>首先找意象，脸上的伤疤；其次局部特写，放大这个伤疤。</p><p>有了这三步，开头也就呼之欲出了：<br>镜头中的他，没有了一张完美的脸。我们都知道，对明星来说，这意味着什么。<br>尽管可以通过技术手段来遮瑕，你仍然能看到隐藏在其中的疤痕。和《仙剑奇侠传》中那个双眸清澈、脸庞俊俏的李逍遥已然不同，现在的胡歌容貌有变。纵然如此，爽朗、友善、儒雅，这些特质从未离开过他。</p><h3 id="两种开头模式"><a href="#两种开头模式" class="headerlink" title="两种开头模式"></a>两种开头模式</h3><p>所有开头，是不是都能归类为这两种：综述型开头和用细节开头。接下来我们就逐一分析一下</p><h4 id="综述型开头"><a href="#综述型开头" class="headerlink" title="综述型开头"></a>综述型开头</h4><p>第一种，综述型开头。要写出一个好的综述型开头，比较难，因为它需要你跳出已有的素材，去归纳整篇文章的主旨。当你对写作的某个话题，恰好有些理论上的认知，或者恰好有些意象能够全面地概述主旨，建议使用综述型开头。因为它往往是独一无二的，其他人很难模仿。<br>这种方法使用起来，需要你具备两种基本能力：</p><ol><li>把看似无关的信息联系起来，也就是联想能力；</li><li>归纳概括能力。</li></ol><p>比如谢梦遥写的国王在领地》，开头是这样描述影视拍摄基地横店的：</p><pre><code>这里被称作横国是有原因的。红色的城门打开，是开阔的广场，穿过中庭，巍峨恢弘的秦王宫出现。护卫、宫女穿梭其间，如果运气好，你可以见到公主。古代与现代，刀枪剑戟与自拍神器，王侯将相与游客，铜板与人民币，衙门与快捷酒店，所有矛盾对立物混为一体。依靠步行（或者出租车）而不是时光机器，你可以完成一场又一场的穿越。横国是魔幻的，最多的「皇帝」在此登基，无数「史诗级战争」在此发生。</code></pre><p>这两段就是典型的综述型开头，它把一个独特的场景慢慢地呈现在你的面前，为人物的出场奠定了基础。</p><p>再举一个例子，就是在我们那边的乡村，时常还是能听到一些传闻，就是娶“鬼妻”，也就是为已亡的单身男子找到一个女尸合葬，以求圆满。<br>好了，现在我们要聊聊这种风俗，试着使用综述型开头。怎么做呢？其实，就是通过联想和归纳，找到一种能概述这种风俗的理念。想想看，在中国对“成双成对”似乎有种执念，这种执念背后其实是对圆满、和谐的极致追求。</p><p>我们就可以抓住这种执念来开头：<br>中国人对双数似乎有种特别的执念，凡事凑“双数”。大到精神世界，两仪生四象，四象生八卦。小到日常生活，送礼送一对，大门分两扇。这背后蕴含着圆满和谐的本意。<br>夫妻亦是如此。生前讲同床共枕，死后要同墓合葬。而对于那些未娶妻就过世的单身汉而言，为了弥补人生缺憾，只好娶“鬼妻”。</p><h4 id="用细节开头"><a href="#用细节开头" class="headerlink" title="用细节开头"></a>用细节开头</h4><p>相比于综述型开头，也可以选择一些好的细节作为开头。这种形式，操作起来更加简单。为什么会有这样的感觉？这是因为细节是很容易被模仿的。比如“某人吸了吸烟，烟雾在空气中弥漫”，都成了烂大街的标准句式了。再比如我上面提到的例子，“张明明决定杀掉他的父母”，也成了模仿者常用的句式，某某决定杀掉某某。不是说这些细节、句式不能用，而是想告诉你，这些细节找起来相对容易。所以，为了能让我们的细节开头更有特色，我们得找到 1～2 个特有的、能打动人的元素，这样你的开头就成功了一大半。<br>比如，有一个叫张国庆的老人，最近他的老房子要被拆迁了，无处可去，十分无助。写他的故事，找到了一个细节，就是他这段时间老是梦见抗日战争时期自己被日本人追捕的场景。它呈现了一种不安全感，这种人物的不安全感，是可以引发共鸣的。<br>放大这种场景特质，并建立起画面感。开头是这样的：</p><pre><code>黑暗中，这个噩梦最近又缠上了他。梦里，80 岁的张国庆身处险境，天空中是轰鸣的日本战斗机，后面是一群追杀他的日本兵。他在起伏的太行山脉中跑跑停停，离家越来越远。一条宽阔的大河挡在他的面前，前方已无路可逃。每每此时，他都会从睡梦中惊醒，心痛猝然袭来。自从 2018 年 6 月下午，甲乙村把镇政府的拆迁通知书贴到村口公示栏后，张国庆就重复做着这个梦。</code></pre><p>实际上，通过一个小的细节，营造出一个场景作为开头，是经常用到的写作技巧。</p><h2 id="如何让读者紧跟你的节奏？"><a href="#如何让读者紧跟你的节奏？" class="headerlink" title="如何让读者紧跟你的节奏？"></a>如何让读者紧跟你的节奏？</h2><p>写作，其实就是把文字和场景系统有效地组织起来。这个组织的过程中，一定是按照一定的顺序，带有目的性地谋篇布局，使用不同的句式，小心翼翼地引导读者的反应。在这个引导的过程中，我们叙事的语气、口吻将决定读者的体验。这个叙事的语气、口吻，表现在写作上，就是我们常说的，你的文章要有叙事感。</p><h3 id="叙事节奏：速度感、力量感和变化感"><a href="#叙事节奏：速度感、力量感和变化感" class="headerlink" title="叙事节奏：速度感、力量感和变化感"></a>叙事节奏：速度感、力量感和变化感</h3><p>此时的你正在听一首旋律，你被这个旋律打动了。那打动你的因素是什么呢？我想一首好听的曲子，它一定有独特的速度感，有快有慢；一定有种力量感，有重有轻；一定还有种变化感，在某个音符处突然变调，打破原有的节奏。其实，叙事节奏也是一样的，它也包括速度感、力量感和变化感。先来找一段名篇感受下。恰逢北京金秋，我们就选一段郁达夫先生所作的名篇《故都的秋》，来感受下这种音乐的美感吧</p><pre><code>不逢北国之秋，已将近十余年了。在南方每年到了秋天，总要想起陶然亭的芦花，钓鱼台的柳影，西山的虫唱，玉泉的夜月，潭柘寺的钟声。在北平即使不出门去吧，就是在皇城人海之中，租人家一椽破屋来住着，早晨起来，泡一碗浓茶，向院子一坐，你也能看得到很高很高的碧绿的天色，听得到青天下驯鸽的飞声</code></pre><p>以这段为例来分析下，叙事的节奏中包含的速度感、力量感和变化感分别是什么。</p><h4 id="速度感"><a href="#速度感" class="headerlink" title="速度感"></a>速度感</h4><p>所谓速度感，就是作者采用的句式往往是以短句组成，这些短句能够用最少的字数传递相当多的消息，能够特别有效地带领读者通过这些短句来理解复杂的环境。更有意思的是，它可以帮助写作者制造一种意象或者动作的连贯感，让读者感到有很多意象或者动作是同时连续发生的。<br>比如在上面这段话中，秋天是一个复杂的环境，包含的意象有很多，但怎么表达呢？郁达夫采用了短句，“总要想起陶然亭的芦花，钓鱼台的柳影，西山的虫唱，玉泉的夜月，潭柘寺的钟声”。<br>那什么时候需要这种速度感呢？就是我们的材料过于静态、平淡的时候，它们往往会放慢我们的写作节奏。这时，你就要提速了。<br>提速的方式，除了像郁达夫那样，直接通过“什么的什么”这种结构来呈现之外，还有就是用动词，把内容联系起来。<br>比如，我们设想这样一个场景，你的老家在几十年的发展中，由于经济越来越发达，你看到的景象是：高楼大厦，热闹的人流，门口的脏水和再也看不到的鱼。<br>你发现没，这些景象都是静态的，那怎么让它变得有节奏起来呢？<br>你可以这样写：过去四十年，我的老家已变成一副陌生的模样，周边的高楼从无到有，村民进城又返乡，屋前的河水由清变浊，河口的鲢鱼回了又去。</p><p>简单的句式，通过几个动词，增添了句子的活力，清楚、快速地把读者带入到场景当中去。速度感是通过短句、简单句式来实现的。相反，如果你写的句式过于复杂，它就会拖慢你的表达。</p><h4 id="力量感"><a href="#力量感" class="headerlink" title="力量感"></a>力量感</h4><p>接着我们来说力量感。你回想一下，从小到大哪种修辞手法常被认为能够给文章带来力量感。没错，排比，我们说使用排比这种修辞手法可以增强气势。从某个程度上来说，排比其实是通过“重复”来增强文章的力量感。在上面那段话中，郁达夫虽然没有使用排比，但他却用“重复”增强了语句的力量感，比如“你也能看得到很高很高的碧绿的天色”。<br>除此之外，还有另一种增强力量感的方式，就是调换句子的语序。你想想，在表达中，为了增强表达的力量感，你会怎样？<br>我们通常会把关键的词语放在开头或者结尾，而不是让它埋没在句子的中间。这种技巧，在写作中的运用十分普遍，但对初学者而言，却容易被忽略。</p><p>举个例子<br>“曲折，是对中国刑诉法诞生过程的一个恰当描述。”显然，“曲折”包含着我对刑诉法诞生过程的一个判断，同时也是提醒读者，我下面要写这个曲折的过程了。如果这个关键词放在中间，力量感瞬间就没有了。你感受下这种句式，“很多人用曲折来描述中国刑诉法诞生的过程”。<br>有时候我们为了增强力量感，使用“重复”这种手法的时候，其实减少了速度感。两者之间是矛盾的，所以我们在使用的时候，有两点需要注意。</p><p>第一，如果你确定这段内容确实重要，必须要让读者感受到你要表达的这种情感，牺牲速度是被允许的。<br>举个例子，比如在一些大城市，由于“控制人口”政策的影响，很多人不得不离开，但是还是有些人在抗争，希望留在这里生活。如果，你想描述这个群体留下来的渴望，那么增强这种力量感就十分必要了。</p><p>这样写：他们不要政府提供福利，也不要政府给出什么赔偿，更不要政府包车送他们回去。过去，他们做了无数次决定离开这里，现在，也做了同样多次的决定留在这里。他们就想待在这里，因为他们的家早已和城市园区融为一体，他们哪儿也去不了。这样的表述虽然降低了叙事的速度感，但也显然体会到了被描述对象留下来的决心。</p><p>第二，要从上下文来考虑，如果它们一直都是快节奏，在你犹豫是不是要放慢速度、增强力量感的时候，我会倾向于慢下来，因为它实际上产生了另一种效果，那就是变化感。</p><h4 id="变化感"><a href="#变化感" class="headerlink" title="变化感"></a>变化感</h4><p>变化感在书面表达中，最主要体现在两个方面。<br>第一，句式上的变化。这个好理解，就是在写作过程中，注重长短句的结合。你可以再次看郁达夫的这段话，这种句式上的变化体现得很明显。</p><pre><code>早晨起来，泡一碗浓茶，向院子一坐，你也能看得到很高很高的碧绿的天色，听得到青天下驯鸽的飞声。</code></pre><p>第二，句型上的变化。不知道你是不是和我有一样的感觉，就是小时候做语文作业的时候，老觉得改句型很无聊，明明是一个意思，非要让我们改成把字句、被字句、倒装句等等，一般来说，在一篇文章中，我们最常见的句型是“主谓宾”结构，但有时候我们要表达的内容比较复杂或者需要做解释的时候，我会更倾向于使用一些更长、更复杂的句型，有时候也要换成被动或者倒装句，一个主要目的就是增加文章的变化感。<br>举个例子，是杨继斌写的《富士康“八连跳”自杀之谜》，这篇文章的某个段落是这样写的：</p><pre><code>死亡掠过的富士康园区，生活仍在精确地继续着。在距离卢新跳楼处不远的大道上，人一样高的车轮轰然碾过。银行、咖啡馆、食堂、商店对大雨中匆匆而过的青年们张着大门。在生产电脑主板的车间里，白色工作帽下一双双眼睛秀丽明澈，他们像往日一样快速在主板上插进电阻、线圈。等到 17 点 30 分下班，刷卡机依例给每个人一个纽扣大小的笑脸标记。</code></pre><p>首先，这里的第一句话就是整段内容的总结，它表明死亡阴影笼罩下，生活还要继续。后面的内容就是把这个总结铺开。再看第三句句型，“银行、咖啡馆、食堂、商店对大雨中匆匆而过的青年们张着大门”。按照一般的写法，这句话可能会写成，“青年们匆匆而过开着的银行、咖啡馆、食堂和商店”，但是结合这句话的下一句，也是用人来做主语，这样的话段落就缺乏了句型上的变化，容易让人觉得枯燥。</p><h3 id="叙事策略：多线叙事和环形叙事"><a href="#叙事策略：多线叙事和环形叙事" class="headerlink" title="叙事策略：多线叙事和环形叙事"></a>叙事策略：多线叙事和环形叙事</h3><p>叙事的原则就一个，一定要有递进的关系。有些文章的段落，它不是递进关系，而是并列关系，也就是说，我随意调换每个段落的顺序，并不会影响读者的阅读。但你仔细想想，这会是一个好的叙事吗？当然不是，这样的叙事会让你觉得平淡无奇，嚼之无味。所以当你在写一篇文章时，一定要注意这个基本的原则。无论是采用哪种叙事策略，都要记住这一点。</p><h4 id="多线叙事"><a href="#多线叙事" class="headerlink" title="多线叙事"></a>多线叙事</h4><p>多线叙事其实并不神秘，它主要是指文章同时拥有几个叙事主线。这种叙事策略无论在写作，还是在电影中，都比较常见。比如最近一部大火的新剧《沉默的真相》就有 3 条叙事主线，分别对应三条线上的男主角：支教教师侯贵平、检察官江阳、警官严良，每条线用时间予以区分。不过，需要特别说明的是，三条主线不是指对应 3 个主题，而是为同一个主题服务的。<br>具体怎么运用呢？举个例子。2019 年和 2020 年在西昌凉山都发生了森林大火，牺牲了不少民间扑火队员。如果要写这群扑火队员的故事，其实多线叙事就非常有用。毫无疑问，我们的重点是扑火队员这项工作本身的高度危险性。开动你的脑筋，想想能有几条主线？如果是我来写的话，有这么 3 条线，是必然会用到的。</p><ul><li>时间线：从接到火情到奔赴现场，按时间顺序记录行程，扑火队员先会遇到什么困难，后会遇到什么困难，在这条线中，就可以得到展现。</li><li>人物线：从这些消防队员中选择一位，通过描述他的性格特征、生活阅历，来分析这群人中为何有人会丧生。这条线不一定非要贯穿全文，只是作为一个迷你人物特写占据几个段落即可。</li><li>日常生活线：前两条线都聚集在出现火情后的情况，但在没有遭遇火灾的时候，他们平常的训练是怎样的，是否专业等等。</li></ul><h4 id="环形叙事"><a href="#环形叙事" class="headerlink" title="环形叙事"></a>环形叙事</h4><p>顾名思义，环形叙事属于非线性叙事。也就是一个故事开始于结尾，结束于开端的故事。像电影《恐怖的邮轮》就属于环形叙事的上佳之作。<br>在写作中，你也可以使用这种叙事策略。它常常用于那种，事件或者人物难以逃脱宿命的题材。比如，某人想要突破现有的状态，但总有个制度或者环境围着你，让你跳不出去，回到原点。<br>请你设想这样一个场景：过去，我们参加奥数比赛获了奖可以加分，所以各种补习班特别多。政府为了减轻学生负担，很多地方都出台了“禁奥令”，禁止学校把“小升初”与奥数挂钩。但事实上，各学校为了保住现在的位置，一定会抢好的生源，所以这些“禁奥令”都成了一纸空文。<br>这个时候，如果你找到了一个好的样本。比如某位父亲对“禁奥令”深信不疑，在别的孩子都在利用暑假疯狂补课的时候，他就不会让自己的孩子上奥数课。但现实不断挑战他的观念，最终也不得不妥协。<br>这样的样本故事就适合环形叙事：</p><p>过去时光如梭，奥数比赛风头正劲，家家户户都在为了那些额外的分数而拼命奋斗。政府为了减轻学生的负担，颁布了“禁奥令”，明文规定学校不能再将奥数与“小升初”挂钩。</p><p>然而，现实却是一场复杂的博弈。在这个禁令的掩护下，各学校为了争夺优秀的生源，仍然默默地与奥数补习班保持着合作。人们都在为了孩子的未来而拼命，但其中有一位父亲，对“禁奥令”深信不疑。</p><p>这位父亲坚定地认为，孩子不需要为了一时的荣誉而丧失快乐的童年。他拒绝了所有的奥数补习班，让孩子在暑假里尽情地玩耍和学习其他感兴趣的东西。他对禁令的坚持成为了身边人议论的焦点，但他并不动摇。</p><p>然而，命运的捉弄始终存在。在禁奥令的大背景下，孩子的同学们一个个都在补习奥数，家长们也在为了孩子的前途而彷徨。这位父亲的信念在现实的考验下逐渐受到摧残。最终，他也不得不接受了事实，为了孩子的未来，妥协地选择了奥数的补习。</p><p>故事回到了起点，仿佛一切都是注定的轮回。这个环形叙事展现了人们在面对制度和现实时，往往难以逃脱命运的轨迹。无论如何努力，最终也可能回到原点，不得不顺应时势。这样的故事让人深思，生活中的抉择和妥协往往充满了无奈和坎坷。</p><h2 id="人物出场：为他们设置戏剧化场景的妙招"><a href="#人物出场：为他们设置戏剧化场景的妙招" class="headerlink" title="人物出场：为他们设置戏剧化场景的妙招"></a>人物出场：为他们设置戏剧化场景的妙招</h2><p>除了一些特殊的应用写作题材，人物都是一篇文章中不可或缺的灵魂。我们搞演讲、讲故事、写软文、写文案，很多时候都会有人物出场。很多文章中，因为人物缺乏安排，导致文章变得无聊，甚至混乱的例子比比皆是，一些有意思的人物被埋没在了一堆无关紧要的信息中。<br>一个重要人物的出场，最好有独特的细节描述，比如形象特征、话语特征，以确保读者能记住这个人物。</p><p>请你猜猜，以下是哪个人物的出场描写？</p><pre><code>一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！”黛玉纳罕道：“这些人个个皆敛声屏气，恭肃严整如此，这来者系谁，这样放诞无礼？”心下想时，只见一群媳妇丫鬟围拥着一个人从后房门进来。这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子。一双丹凤三角眼，两弯柳叶吊梢眉，身量苗条，体格风骚。粉面含春威不露，丹唇未启笑先闻。</code></pre><h3 id="从王熙凤出场，我们能学到什么"><a href="#从王熙凤出场，我们能学到什么" class="headerlink" title="从王熙凤出场，我们能学到什么"></a>从王熙凤出场，我们能学到什么</h3><p>我们在为一个人物出场做铺垫的时候，同样要注重两个特征——神秘和冲突，这是吸引读者往下阅读的不二法门。就以上面王熙凤出场的那段作为例子，来分析下作者是怎么营造场景的。</p><h4 id="使用引语"><a href="#使用引语" class="headerlink" title="使用引语"></a>使用引语</h4><p>首先，用引语“我来迟了，不曾迎接远客”带出王熙凤的出场。这实际上是一个很常见的技巧，但是有些人会用不好，大概率是没有把握以下这两个基本要求。<br>第一，引语必须符合人物身份。比如只能是黛玉纳罕，来者是谁，而不能换做其他人，因为她是外来人，她不了解王熙凤。<br>第二，引语内容要有特质。比如我曾经看过一些初学者写人物出场，总喜欢写：“我很累，感觉有千座山压在自己身上。”满头大汗、体格强壮的张三边干活边说。张三是一名建筑工人。<br>这样的引语其实没有任何意义。谁工作不累，谁没有压力，对不对？这样的引语展现不出人物的任何特质，自然也吸引不了任何人。<br>你看曹雪芹是怎么用引语的。首先，符合人物特质，未写王熙凤的外貌，就先已通过她的笑语声，传达出了人物的内在神韵，让外来者林黛玉都觉得她放诞无礼，这句先声夺人的直接引语就很妙。其次，营造了神秘感，这个时候读者的视角和黛玉一样，都在猜想在这样一个王公大院里谁敢如此无礼？最后，用引语的时候，简短、犀利，切忌冗长、枯燥。<br>针对最后一点，现在，联想一下“叙事的速度感”。这种速度感在引语方面，常常表现为：不完整地引用整句话，而是单独引用一个词组或者一个词。比如，某人用“诸事不顺”来形容自己目前的状态。诸事不顺肯定是某人原话中的一部分，我们写作的时候，如果觉得这个词语最能体现他的特征，那就只用这个词语作为引语就好了。</p><h4 id="制造悬念"><a href="#制造悬念" class="headerlink" title="制造悬念"></a>制造悬念</h4><p>所谓“这个人打扮与众姑娘不同，彩绣辉煌，恍若神妃仙子”，其实就是作者在进一步制造悬念，这也是人物出场常用到的技巧。这样的经典句式有很多，稍微归纳一下的话，以下两种最常见：</p><ul><li>最简单的就是“和什么什么不同”；</li><li>复杂点的就是“如果一切顺利的话，某某人此刻会在做什么”。</li></ul><h4 id="细节描写"><a href="#细节描写" class="headerlink" title="细节描写"></a>细节描写</h4><p>最后，是细节描写。这就包括外貌、状态等。这里有一个重要的误区就是，使用没有特质的细节。曹雪芹写人的时候，他不是把王熙凤的五官都拿来写，而是突出某个特点。比如王熙凤就是“丹凤眼””柳叶吊梢眉”。<br>其实这点做起来不是很难，关键得学会观察。换句话说，一个人的细节特质是要和场景联系起来的。比如，前面建筑工人张三的那个例子，现在要写他的出场，要写什么？写手，因为这是最能体现他工作特质的地方。</p><h4 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h4><p>此外，还有一个经常被使用的人物出场技巧，曹雪芹先生没有用到，那就是环境描述。<br>比如，我要让一个农村人物出场，还原他的生活场景就很有必要。那应该怎么写呢？同样，这个场景的选择最起码的要求是符合人物特质。<br>假设有这么一位农村儿童的父母外出打工，在农村的土路上因为车祸双亡，现在，我们要写这位命运悲惨的儿童，该让他出场了。就可以这样写：</p><pre><code>这实在是一座在中国版图上，平淡无奇的西部村庄。年轻父母的流失，村口操场上用于锻炼身体的双杠斑驳得就像被抛弃的遗物。新村连络县城的公路因年久失修而残破坑洼，为了生计奔波的年轻夫妻出行时稍一疏忽，就会在尘土弥漫的路上发生车祸。2020 年 5 月，李四（化名）的父母就在这里车祸双亡。</code></pre><p>首先，这个农村儿童家不会太富裕，因为父母要外出打工。而这是很多西部村庄的共同特征，我应该把它点出来，既能体现穷，也能和时代背景连接上。<br>其次，我要找一个细节环境来体现这个村庄的贫困。我选了体育器材，因为它是许多孩子玩耍的器材，但现在锈迹斑斑长期无人修理，这就能体现出没人没钱的西部农村现状，也是一个很能体现出现场环境的细节。<br>最后，我们知道孩子的父母是在一条农村的路上发生了意外，所以我们必须要找到那条路的特征。</p><h3 id="人物出场那些实用的写作技巧"><a href="#人物出场那些实用的写作技巧" class="headerlink" title="人物出场那些实用的写作技巧"></a>人物出场那些实用的写作技巧</h3><h4 id="制造冲突、悬念或者错觉"><a href="#制造冲突、悬念或者错觉" class="headerlink" title="制造冲突、悬念或者错觉"></a>制造冲突、悬念或者错觉</h4><p>比如，我们以撒贝宁这个人物出场为例。说起他，你脑海中的典型场景应该就是《今日说法》里的撒贝宁，西装革履、正襟危坐。但如果你换个情景，换成《明星大侦探》中他出场的情景，那你就可以刻意去制造错觉了。具体怎么做呢？<br>第一步，寻找《今日说法》和《明星大侦探》场景的共同之处，比如都要普法，分析嫌疑人的动机。<br>第二步，描述这个共同之处，撒贝宁的状态让大家误以为你在说《今日说法》下的撒贝宁，也就是制造错觉。<br>第三步，话锋一转，过渡一下，写一句“等等，你不会以为这是《今日说法》的现场吧？”<br>第四步，揭晓谜底，这是 2016 年《明星大侦探》的现场，被许多人认为这是撒贝宁综艺生涯的起点。</p><pre><code>同样是“犯罪现场”，倒在血泊中的无名尸体，散落在一旁的凶器，哭成泪人似的朋友，狡辩的嫌疑人……神秘悬疑的元素都在这里。节目后面常常隐藏着一个悲剧。与此对应的是，撒贝宁的正经。录制过程中，当节目话题与法律条文和法律精神有了联系，他会立刻严肃起来，眼光变得犀利，刚才热烈的氛围突然冷清。他说，在游戏中成功隐藏身份的凶手可以得到奖励，但在实际生活中，这对于人们是种痛苦。你不会以为这是《今日说法》的录制现场吧？这是 2016 年，被许多人认为是撒贝宁综艺生涯的起点，他在湖南卫视录制《明星大侦探》。</code></pre><p>还有一种技巧也很特别，就是用人物名字来制造悬念。谢梦遥在《“世相君”张伟：实用主义才是文艺的终极目的》一文中写新世相创始人张伟登场时，就用了名字来设置悬念。他这样写的：</p><pre><code>中国有超过 40 万个叫张伟的人。顶着怪异发型的歌手张伟制造了不少流行但颇具争议的口水歌，身高 1 米 83 的女篮运动员张伟获得了 5 次 WCBA 总冠军，还有一个长相英俊的张伟，是热门喜剧《爱情公寓》的主角。但我们即将要谈论的这个张伟，身高普通，长相普通，他更接近张伟这名字所暗示的意义——一个普通人。张伟最近——也可能是迄今为止仅有的一次——出现在聚光灯下，是在《鲁豫有约》节目里。作为拥有超过 40 万粉丝的微信公号“世相”的运营者，他与十数位公众号“大号”一同受邀，轮流走上嘉宾席分享心得。</code></pre><p>人物出场可以通过各种方式来设计的，但基本都逃不过那四个特征：引语、悬念、细节、环境。</p><h4 id="用环境描写昭示人物命运"><a href="#用环境描写昭示人物命运" class="headerlink" title="用环境描写昭示人物命运"></a>用环境描写昭示人物命运</h4><p>清末民初著名国学大师有两句著名的话，一句是“以我观物物皆著我之色彩”，另一句是“一切景语皆情语”。说的就是，环境、情景与人类情感的共情关系，也就是人物是悲哀的，那他眼中的景色和环境也是悲哀，反之亦成立。杜甫的那句“感时花溅泪，恨别鸟惊心”，也是运用了这种技巧。<br>事实上，这种技巧也为我们设置人物出场的环境带来了启示。举一个例子，何伟在《寻路中国》一书中，为了介绍一个故事的主人公魏子淇，就先用了大段笔墨，设置了他的生活场景三岔村。他是这样写的：</p><pre><code>20 世纪 90 年代初期，这儿的一所学校关闭了。村民们都没有买车，也不用手机。没有餐馆，没有商店，想找个花钱的地方都没有。每隔一、两天，会有个小贩开着敞篷货车从沟里上到这里来，车上装着大米、面条、肉，以及其他简单的日常用品。到了秋天，另外有卡车开上来收购村民们手里收获的东西。在村里，所有的车辆都停靠在那条死胡同土路的尽头，那里进行了拓宽，用于停车。那块土坝子代表了当地的全部经济活动——完全是一种停车场经济。</code></pre><p>初读的时候，可能没觉得有什么奇特之处，只是能感受到，通过他的描写，三岔村落后封闭的状态近在眼前。但是，当你读到主人公魏子淇出场时，你能发现作者的良苦用心，因为主人公原来是一位农民，生活贫苦，就跟停车场经济一样，感觉就像一条死胡同。但后来他开始经商，正是突破了原有的停车场经济，走出了那条死胡同。所以，这段环境描写与他后来的成功遥相呼应，那个时候的三岔村有多封闭，那么现在的主人公就有多开放，也就形成了环境和人物的反差。<br>比如，一位高个子的男人想要突破社会成见，挑战一些不合理不公平，但是又到处碰壁。现在，他又要坐绿皮火车前往远方去挑战，但是因为买票晚，卧铺只剩下了上铺。这个时候，要写这个大高个的出场，就可以联想到火车的情景：“因为在上铺，这个局促、狭隘的空间让他这样的高个子根本就伸不开，总有东西阻碍着他。”这不就像是他的生活吗？所以，安排这样的场景让他出场，是有象征意义的。</p><h4 id="主角晚登场"><a href="#主角晚登场" class="headerlink" title="主角晚登场"></a>主角晚登场</h4><p>最后一个技巧，主角晚登场。这种技巧比较适合人物揭秘或者分析人物瓜葛类的写作题材。比如 2017 年《芳华》这部电影大火的时候，冯小刚与王烁、叶京等人的瓜葛再一次被摆到了台面上。如果你有兴趣，可以去看看相关的文章，你会发现，主角往往是被慢慢引出来的。<br>比如微信公众号往事叉烧的文章《冯小刚王朔们的黑历史》，为了引出叶京这个人物，前面用了两段铺垫：</p><pre><code>没有人见冯小刚穿过短裤，夏天或运动时他也不穿，永远是一条长裤。有人问过他，这么热不穿短裤？冯小刚说：“不穿，不好看，就跟裤子外面插两根棍似的。”当然，穿长裤也没有多好看。那年代裤子不修身，冯小刚又竿儿瘦，老远看像是一条裤子走过来，所以得一诨号——“冯裤子”。第一个这么叫冯小刚的人，是王朔的大哥——叶京。不仅如此，叶京还拍了电视剧，按着冯小刚写了一号人物，让他再也没能摘掉这个外号。</code></pre><p>这种技巧的经典设计，就是先告诉你一个大众熟悉的人，然后再通过两者、甚至三者之间的关系引出这个幕后的人。</p><h2 id="细节打磨：如何设计出令人过目不忘的细节"><a href="#细节打磨：如何设计出令人过目不忘的细节" class="headerlink" title="细节打磨：如何设计出令人过目不忘的细节"></a>细节打磨：如何设计出令人过目不忘的细节</h2><p>2012 年，有一部纪录片走红了，它就是《舌尖上的中国》。该纪录片以食物为线索，以中国各地不同的地理环境、风俗礼仪和生活状态等为背景，全方位地介绍了中国各地的美食生态。这些文字用细节带动了你的五感。所谓五感，很好理解，就是视觉、听觉、味觉、嗅觉和触觉。选一段《舌尖上的中国》里的解说词你来感受一下，这段文字没有直接介绍美食，但也同样能让你感受到“细节带给我们的冲击”。<br>这段文字是描述中国人怎么使用藕这种食材的，它是这样介绍的：</p><pre><code>挖藕的人喜欢天气寒冷，这不是因为天冷好挖藕，而是天气冷买藕吃藕汤的人就多一些，藕的价格就会涨。在湖北，藕最常见的做法就是煮汤，这是武汉及鄂中一带的家常菜——莲藕炖排骨。整整一湖的莲藕，还要采摘 5 个月的时间。在嘉鱼县的珍湖上，300 个职业挖藕人，每天从日出延续到日落。在中国遍布淡水湖的大省，这样的场面年年上演。</code></pre><p>这里面的细节，“挖藕的人喜欢天气寒冷”，大多数人其实都不知道挖藕是在寒冷的天气里进行的，而越冷对于挖藕人来说越好。这种文字通过细节的选取，说出了画面所不能传达的东西，让这些文字搅动我们味蕾的同时，也带给我们其它的感触。</p><p>细节的抓取必须来源于观察，这是最基本的方法。所以，必须要老生常谈地说一句，没观察，无细节。</p><h3 id="精确联想"><a href="#精确联想" class="headerlink" title="精确联想"></a>精确联想</h3><p>如果你有一定的中国古诗词基础，听到旁白念“挖藕的人喜欢天气寒冷，这不是因为天冷好挖藕，而是天气冷买藕吃藕汤的人就多一些，藕的价格就会涨”，应该可以联想到这样一个情节，那就是白居易的《卖炭翁》。白居易是怎么写的呢？</p><pre><code>卖炭翁，伐薪烧炭南山中。满面尘灰烟火色，两鬓苍苍十指黑卖炭得钱何所营？身上衣裳口中食。可怜身上衣正单，心忧炭贱愿天寒。</code></pre><p>翻译成白话文就是：有位卖炭的老翁，整年在南山里砍柴烧炭。他满脸灰尘，显出被烟熏火燎的颜色，两鬓头发灰白，十个手指也被炭烧得很黑。卖炭得到的钱用来干什么？买身上穿的衣裳和嘴里吃的食物。可怜他身上只穿着单薄的衣服，心里却担心炭卖不出去，还希望天更寒冷。其实，挖藕的人就像卖炭的老翁一样，为了生计，同样喜欢天气寒冷，尽管会受很多苦。穿越一千多年，类似的细节在今天同样也能打动你我。<br>虽然这是两件不同的事，但两处人物心理细节的切入角度是完全一样的。精确联想是细节写作的法宝之一。该怎么精确联想呢？<br>第一种方式，是写的时候联想共情的细节。简而言之，就是你写事写人的时候，可以先代入到自己的身上，问问自己，什么会打动我。我们每个人都有感冒的经历，发烧、咳嗽无力。假如，有这么一个失独家庭，父亲年纪大了，生病感冒却无人照顾。现在，有人要求你写出这种孤独感，我们怎么找细节呢？你可以想想自己或者父母感冒的经历，有哪些是可以共情的。在一间只能勉强摆下一张床的卧室里，一位父亲独自躺在床上，发烧咳嗽、头昏无力。他不知道该打电话求助谁，但他还是拿起了电话喃喃自语。那是一种虚弱、颤抖、非常无力的声音。<br>第二种方式，是写的时候联想那些让你觉得异常、会产生反差的细节。比如一个没多少文化的农民工，却能背诵林黛玉的葬花词，这就是反差的细节，可以挖掘。<br>在大多数人的意识里，烈士陵园一定是庄严肃穆、环境优美的地方，但是你今天去的某个陵园让你觉得杂乱。这个时候，就会有很多反差细节展现在我们眼前。此时，我们一定要去捕捉到这些异常。<br>比如陵园布局杂乱，通往墓碑的小路落满枯叶，再比如墓碑周边都是湿漉漉的枯败植物。显然，这些细节的设计，是有意为之，要去营造氛围的，因为这会让人印象深刻。</p><h3 id="借助道具"><a href="#借助道具" class="headerlink" title="借助道具"></a>借助道具</h3><p>所谓借助道具，就是运用人物、事件身边与之关系密切的东西，来凸显它的特点。<br>印象中最深刻的就是中学时的一篇课文，契诃夫写的短篇小说《装在套子里的人》。他在描写主人公别里科夫的时候，是这么写的：</p><pre><code>哪怕在艳阳天出门他也总是穿着套鞋，带着雨伞，他的雨伞、怀表、削铅笔的小折刀等等一切能包裹起来的东西都总是装在套子里，就连他的脸也好像装在套子里，因为他总是把脸藏在竖起的衣领里面，戴着黑眼镜，耳朵里塞上棉花，坐出租马车的时候也要车夫马上把车篷支起来。</code></pre><p>注意下契诃夫使用的这些道具，套鞋、竖起来的衣领、黑眼镜、耳朵里的棉花、车篷等等，这一连串的道具都是为了刻化这个装在套子里的人物，具有很强的表现力。不得不感叹大师的功力！<br>借助一些道具来服务于主题。比如，我就看到一个很想成功的人，喜欢用一切带龙的道具，烟灰缸是带龙头的，打火机吐火的地方也是个龙头。这样的细节当然应该用到文章中。</p><p>他把玩着手上的打火机，打火机的形状是个金色的龙头，他喜欢龙头喷火的样子。10 年来，搜集这样的龙形物品，他已经到了一种痴迷的程度，烟灰缸是带龙头的，就连喝水的杯子也是如此。所有的这一切都可以归于一种心理：出人头地。除了借助道具来反映人物的性格特点之外，其实道具有时候也可以用来反映人物的成长。你可以想想金庸老先生在刻画令狐冲这个人物的时候，是怎么反映他的变化或者成长的？其实从他喝酒就能感受到。原来他喝酒用的道具是什么，一个破葫芦，但到了绿竹林，遇到圣姑任盈盈后，绿竹翁就带他品酒学酒，用那些有讲究的杯子，这些道具的转换其实就暗含了人物命运的变化</p><h3 id="逐步细化"><a href="#逐步细化" class="headerlink" title="逐步细化"></a>逐步细化</h3><p>假设张三和他女友在吃饭，吃饭中这对情侣吵架了，女生转身离开了。那“离开”这个动词，就是模糊的，它不属于细节描写。如果你要用细节来刻画这位女生离开的场景，那就要逐步细化。怎么细化呢？分层次来细化，也就是拆分。</p><p>首先我们知道，这两个人正在吃饭，那一定是坐着的。女生要离开，首先就要站起来，<br>第一个细节出来了：她是怎么站起来的？<br>其次，站起来后，她做了什么？这可能会构成第二个细节。<br>最后，她是怎么离开这个饭店的，这就构成了第三个细节。</p><p>那么，根据上面的逻辑顺序，我们基本上就可以逐步细化了。现在，我们进一步假设这位女生是一个很注重面子的人，只要在公共场合就会克制情绪。那么我们逐步细化的前提就是，哪些动作能够体现她的隐忍、克制。所以，这段描写就可能是这样的：</p><pre><code>她快速站起来，不言一语，只是盯着张三看了一眼，把椅子推进了桌下。然后转身，慢慢地走到门口，再快步地逃离了饭店。</code></pre><p>为什么写她不言一语，写她把椅子推进桌下，然后慢慢走到门口呢？其实都是为了体现她的隐忍，但是当她离开饭店门口，就是快步逃离了，因为她已经摆脱了公共场合的束缚。<br>再来感受一个逐步细化的例子。比如，我们写一个人端起碗、挑菜、吃饭，现在我们要逐步细化这个吃饭的情景。显然，不同的人物会有不同吃相。<br>一位很注意形象的人吃饭，他是这样的：他端起碗，把几缕菜叶送到嘴边，极小幅度地咀嚼着食物，每吃一口，都会拿起纸巾擦拭嘴角的油渍。<br>如果是一位大大咧咧的人吃饭，他可能就是这样的：他端起碗，把菜合着饭就往嘴里送，不时还发出一些声音。末了，嘴角还挂着一粒米粒。<br>其实，这也是一种平日里训练写作的方法，找朋友随便给你一个简单的句子，然后发挥你的想象，用细节去填充，使这个句子具体形象起来。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>第一，详略得当。从理论上来讲，一句话可以扩展出数不清的细节，但为什么大家不这么做呢？因为这样就没有详略了。两个基本原则。首先，环境细节描写的重要性小于人物细节描写的重要性。比如，我们要写某个街区随着时间的推移而变得衰败。那要表现这个衰败，我们会习惯性地用环境细节来表现，比如尘土飞扬的街道、杂草丛生的荒地、布满蜘蛛网的玻璃等等。当然，这些没有错。但是，如果这个时候你在这个街区看到了一个瘦骨嶙峋、衣衫褴褛的人，那你的细节描写的重点，就应该转到人物的身上。你可以感受下</p><pre><code>一切都是灰蒙蒙的。昏暗的灯光下，一个满脸憔悴的人，穿着无袖的汗衫，把一只胳膊肘搭在路灯柱上，另一手啃着半块面包。而在他的不远处，还有一个黑影在地上寻找着什么，突然扬起头，开心地说道：“你看，还有吃的。”</code></pre><p>相比于环境细节描写，如果突出的细节是人物，则更能拉近读者的观感，因为人才能更让我们产生共情。试想一下，一个街区再破败，它没有人，也不会有太多读者会去关注它。因为我们总是对人感兴趣，而非他们所在的地方。</p><p>其次，人物细节描写中，描写五官感受到的细节比描写人物的心理活动细节来得重要。原理也很简单，就是五官细节会让读者更有代入感。我们常常会怎么描述一个人难受的心理状态呢？七上八下、睡不着觉、像被刀子捅了一样……但这些就比不上用一些通过五官感受到的细节来得震撼。<br>比如说一个人因为孩子走丢了心里难受，睡不着觉。这时，我们需要尽量用五官能感受到的细节去刻画他的状态。我们这样写：</p><pre><code>卧室的灯关了，周遭又静谧了下来。连续几个晚上，他都因压抑而失眠。他用力地闭上眼，努力屏蔽外界的干扰。但平日里从不会注意的窸窣声，此时也会钻进他的耳朵，扰乱他的思绪。偶尔困得睡过去了，他也会突然坐起来，猛推身边的妻子说：“我们的孩子没了。</code></pre><p>第二，不要无用的细节。无用，一方面是指与主题毫无关系的细节描写，另一方面是指没有特点的细节。前一个方面，我就不举例了，因为大多数人是可以察觉，并且努力避免的。我想说说后一个方面，就是一些没有特点的细节。<br>所谓没有特点，不是说，你用的意象没有特点，而是指你的描述没有特点。比如，我们总喜欢用烟啊、酒啊来形容一个男人的苦闷、心痛。这并非没有特点，而是指有些朋友一写到这样的细节，就是“狠狠地吸了两口，朝外吐了吐烟圈”，这就属于没有特点了。<br>那怎样才能把这个细节写得有特点呢？我们假设现在有这样一位男性，最近因为被骗很苦闷，老婆离开了他，公司也快开不下去了。假如在他的办公室里，我们看到了他的状态，他向我们聊起了被骗的过程。在整个聊天过程中，你也看着他一根接一根地抽烟。上面的铺垫，我们完成了。现在怎么用到这个抽烟的细节呢？</p><pre><code>他坐在自己的位置上，用最舒服的姿势，和我们讲述着他被骗的过程。中途，他聊起离开了他的老婆，破散了的家，还谈起了即将破产的公司。手里的烟，他从来没有停过，一根根地抽，语气平静。这时，他从烟盒里拿出最后一根烟，正要点上。突然，整根烟就从嘴里滑了下来。他怔了一下，慢慢低下头，到地上去捡，还冒出了一句：“连烟都嫌弃我了。”良久，他才抬起头，此时已泪流满面。</code></pre><p>同样是描述烟，这个烟的细节是有特点的。烟在手的时候，他平静淡然，但当烟突然掉落的时候，他就再也绷不住了，悲伤从中而来，而烟就是其中的导火索。烟，只不过是逃避自我的伪装。</p><h2 id="遣词造句：如何让字和句吸引用户的眼球"><a href="#遣词造句：如何让字和句吸引用户的眼球" class="headerlink" title="遣词造句：如何让字和句吸引用户的眼球"></a>遣词造句：如何让字和句吸引用户的眼球</h2><p>文字的魅力是绝对存在的，在中国历来都是“一字之师”的说法。这个典故最早的出处，可能源于唐朝。<br>据传，唐朝有个叫齐己的和尚，很喜欢写诗，写得也很好。<br>有一次，齐己写了一首诗，叫《早梅》，其中有这么两句“前村深雪里，昨夜数枝开。”过了几天，好友郑谷来串门。齐己对他说：“我写了一首诗，你给我看看怎么样？”郑谷看了半天，说：“写得好，意境很好，情致也很高。但有一点，你写的是早开的梅花，一般不会数枝开，数枝就是开了一片啦，我觉得应该把数枝改成一枝。前村深雪里，昨夜一枝开。这就显得这梅花是早开的梅花。”齐己一听，恭恭敬敬地向郑谷拜了一拜，说：“改得好！你真是我的一字之师啊。”</p><p>基本原则是，要正确地使用语法、句法和词语，不要出现病句和错句。在我看过的比较好的文章中，像词语搭配错误、用词不当已经很少见了，现在比较常见的一种语病是：句式杂糅。之所以会这样，其实跟一个误区有关，那就是中文西化。越来越多的人在写作中借用英语从句表达，这很容易出现句式杂糅的情况。</p><p>举个例子：他平时总是沉默寡言，但只要一到学术会议上谈起他那心爱的专业时，就变得分外活跃而健谈多了。<br>这是典型的在修饰短语里面再出现一个新的句子结构，去掉“变得多了”就可以了：他平时总是沉默寡言，但只要一到学术会议上谈起他那心爱的专业时，就分外活跃而健谈。</p><p>基本方法是，要培养语感。所谓语感就是对语言表达的直观感受。语感好的人，凭着语感就能判断句子的正误，甚至好坏。至于怎么培养语感，网上的教程有很多，这里分享两个习惯：</p><pre><code>一是平常看书的时候，遇到有意思的文字，一定要读出来，它会潜移默化地对你产生影响。大家常问，为什么我写的时候想不到这个词呢？这个问题我也问过很多写作高手，他们的答案很一致，没什么速成的诀窍，就是多读。当你自己写的时候，很多词语会直接在脑海中跳出来，而不是刻意想出来的。二是自己写完一篇文章，大声读出来，既能培养语感，也能帮你快速修改文章。</code></pre><h3 id="词语"><a href="#词语" class="headerlink" title="词语"></a>词语</h3><p>我们先说用词上的讲究。一个好的写作者，在用词方面，会有哪些方法呢？一是精确凝练；二是动态感表达。下面我们逐一分析一下。</p><h4 id="精确凝练"><a href="#精确凝练" class="headerlink" title="精确凝练"></a>精确凝练</h4><p>所谓精确，就是具体准确清晰，你不能让读者不停地擦拭眼睛，也弄不清楚自己看到了什么东西，一切都还是模糊的。<br>所谓凝练，就是不啰嗦，有详略，不是任意一个名词都是需要修辞的，不是任何一个动词都需要副词去衬托的。<br>第一，不到万不得已不用弱动词，比如“进行”“造成”这样的动词；<br>第二，慎用形容词和副词，特别是不知道怎么形容的时候，宁可不用。</p><p>举个例子，写自己被外面的鸟儿吵醒，开启了一天的生活：明媚的早晨，柔柔的阳光照着我的卧室，轻盈的小鸟在树上婉转地鸣叫。我被这动人的鸟叫声吵醒。</p><p>这么短短的一句话，既不简略更不精准。<br>为什么不够简略呢？因为许多修饰是没有意义的，在我们的写作中，有个基本的原则是，修饰尽可能是为了主题服务，如果不是为了这一点，其它修饰能省则省，除非这个修饰非常完美。<br>表达自己被这动人的鸟叫声吵醒，保留婉转这个形容词就够了，你的其它修辞都是没有意义的，显得啰嗦。你想想，既然有鸟儿在树上唱歌，这天气一定不差，所以明媚这个形容词可以删掉。同理，像“柔柔的”“轻盈的”，这些词语通通没有保留的必要。<br>所以，可以直接改成：早晨，阳光照着我的卧室，小鸟在树上婉转地鸣叫。我被这鸟叫声吵醒了。<br>我们再说这句话里面的动词，“照着”这个动词很普通，一天中只要太阳没有“躲”起来，有阳光，我们都可以用照。这就很难体现此时此刻阳光的特殊性，所以这个时候，你就要提醒自己了，是不是可以换个动词。那么，开动脑筋，我们可以用什么动词呢？用“洒向”这个动词。为什么呢？一方面，根据我们生活的经验，早晨的阳光不怎么刺眼，所以用洒是准确的；另一方面，洒说明是缕缕阳光慢慢浸透的，自上而下的，显然，它是个更有画面感的词语。<br>像这样的例子还有很多。比如我印象中最深的，鲁迅在写孔乙己拿钱的动作时，就曾用了两个不同的动词，我们感受下。</p><pre><code>一处是：孔乙己一到店，所有喝酒的人便都看着他笑，有的叫道，“孔乙己，你脸上又添上新伤疤了！”他不回答，对柜里说，“温两碗酒，要一碟茴香豆。”便排出九文大钱。另一处是：我温了酒，端出去，放在门槛上。他从破衣袋里摸出四文大钱，放在我手里，见他满手是泥，原来他便用这手走来的。不一会，他喝完酒，便又在旁人的说笑声中，坐着用这手慢慢走去了。</code></pre><p>第一处用的是“排”出九文大钱。第二处用的是，“摸”出四文大钱。<br>假如你用硬币买东西。你拿出硬币，正常的情况下，是数好以后给老板，但孔乙己是把大钱拿出来，一个个排整齐，他这样做显然是故意给老板看的。动作背后的潜台词是：我不差钱，也不差你的，你看好了。第二处用“摸”，你再想想自己拿钱的动作，直接掏出来，但是孔乙己是摸。什么情况下才会摸呢？钱很少或者不确定有没有钱的时候，我们才会去“摸”，差别就在这里，所以不同的动词反映的是人物不同的状态。更重要的一点是，词语的应用是为主题服务的，孔乙己从“排”到“摸”出大钱，其实反映了他的财产状况越来越差，为其最后的消失埋下了伏笔。</p><p>当然，有好的形容词、副词千万不要吝啬用，那什么是好的形容词和副词呢？带有描述性质的，或者能够让你直接捕捉到的。举个例子，你感受下，“他的脸上露出了僵硬的笑容”，“僵硬”这个形容词，就是我们可以捕捉到的，读者完全可以立马明白“僵硬”是个什么状态。再比如“生了锈的铁杆”，“生了锈的”就是一个描述类形容词，这种形容词，是有信息增量的。</p><h4 id="动态感表达"><a href="#动态感表达" class="headerlink" title="动态感表达"></a>动态感表达</h4><p>先看一段话：</p><pre><code>所有人都试图爬到车厢上，一旦一个人成功了，其他人就更拼命，一时间所有的车厢都是人，努力抓住铁杆，爬进车窗，爬上火车车顶，尽一切可能接近火车。他们在尖叫，在推搡，甚至摔倒在其他人身上。一周之前他们还在自己家里，而现在，他们如此渴望生存，以至于周遭枪声四起，也不能阻止他们奔向那里。</code></pre><p>根据冯小刚《1942》这部电影中河南人乘火车逃荒的那段情节改写的文字。我们用词的一个很重要的目的，就是尽量让一篇文章里的每个元素都充满活力。因为读者喜欢看到的是处于动态中的人，任何事物，读者都更倾向于动态的。<br>能够建立起这样的动态画面，是怎么做到的？<br>诀窍一，用强动词。比如上面这段话中的，抓住、爬进、尖叫、推搡都是强动词，同时也是连贯的，它是最能带来画面感的。<br>诀窍二，即便写静态事物，也可以停下来想想，能不能换个表达，赋予事物以生命？这就要用到拟人化的表达。</p><p>电影《囧妈》里面有一段戏，就是徐峥饰演的角色徐伊万一个人在结了冰的贝加尔湖上奔跑，以追上某个目标。一般我们来写，那肯定就是从人物出发，这个人在冰川上喘着粗气、踉踉跄跄地奔跑。<br>那我们换个角度，不写人物，写冰川呢？整个世界都是安静的，只有冰川在吱吱地叫着，声音一直没有停下，提醒着我们，它的上面，有一个人正在奔跑。他是谁？<br>实际上这样写，是想在一个动态环境中带出人物，所以特意让冰川发声。这样的技巧，会经常用到。比如写洪水过后的江水，我会这样写：江面一片沉寂，平静的江水已经淹没了之前的所有绝望和惊慌。<br>大多数人要写江面一片沉寂，肯定会写没有声音，没有人。如果这样，这只是到了写作的第一层。我们为什么不能够通过用词产生以动衬静的作用呢？这样会更有画面感。所有我用了淹没、绝望、惊慌这样具有明显动态感的词语来表达这个沉寂的画面。想想王维的那首诗：蝉噪林逾静，鸟鸣山更幽。</p><h3 id="句式"><a href="#句式" class="headerlink" title="句式"></a>句式</h3><h4 id="语句顺序"><a href="#语句顺序" class="headerlink" title="语句顺序"></a>语句顺序</h4><p>简单来说，就是对句子进行排列。首先，我们得知道一个事情的自然顺序是什么，也就是它是按照什么顺序发展的。<br>举个例子：</p><pre><code>我每天早上起来，都是被闹钟先吵醒，然后进卫生间洗漱、换好衣服，接着吃早餐，装好母亲为我备好的午餐盒，然后出门。这就是自然顺序。</code></pre><p>为什么要先知道这个自然顺序呢？因为只有清楚一切是怎么发生的，才能决定哪句话是最重要的。<br>接着，就要回答怎么排列这个语句的自然顺序。关于这个问题，契诃夫有句经典格言：如果你在第一幕中展示了一把枪，它就必须开火。换句话说，如果在第二幕中有把要开火的枪，那你最好在第一幕中就要介绍它。<br>接着上面那个例子，比如我要写自己和父母发生了冲突，冲突的原因是，我不想带午餐盒去单位，而是想吃披萨，所以我偷偷把午餐盒放在了家里，这惹怒了母亲。这个时候，我们在组织语句顺序的时候，要有意地做好准备，把冲突的线索埋好。</p><pre><code>我每天早上都重复着同样的事，但今天早上有些不同。吃完了早餐后，我并不想装上午餐盒，心里想的都是公司楼下的榴莲比萨。早上，我问母亲能否不带午餐，但被拒绝了。她觉得这是冒犯她的权威。我走出卧室，穿过客厅时，把午餐盒放在了茶几上，背上了包，离开了家。</code></pre><p>这个场景，就是把描述不同点、异常情况的句子先交代出来，为下文的争吵预埋伏笔。</p><h4 id="打破常规"><a href="#打破常规" class="headerlink" title="打破常规"></a>打破常规</h4><p>所谓打破常规，其实就是要让句子有变化。<br>第一，让句子有快有慢。<br>一般来说，我们的原则是，当你解释枯燥但又重要的信息的时候，加快句子的速度；而当描述一个重要信息的时候，就放慢速度，让读者跟着你进入场景。<br>怎么加快速度呢？缩短句子，去除冗余的信息。<br>比如，我们要解释有关对未成年女性强奸罪的问题。首先，这是一个法律问题，我们得保证句子的精准；其次，因为它是法律解释，很容易枯燥，我们就要尽量缩短句子，以简单明了为目的。可以这么写：</p><pre><code>我国法律规定，与未满 14 周岁的幼女发生性关系，不论是否违背幼女的意志，均可判强奸罪。在此基础上，司法解释进一步阐明，和不满 12 周岁的幼女发生性关系，都应认定行为人明知对方是幼女。而对待已满 12 周岁不满 14 周岁的幼女，则要视身体发育状况、言谈举止等情况裁判，普通人认为这可能是幼女的，就应该认定行为人也明知对方是幼女。</code></pre><p>那如何慢下来？用细节描写。举个例子，比如要写一段张三追杀李四的情节，这么写：</p><p>广场上，张三朝着李四逃跑的方向追去，边跑边把手里的刀扔了过去。就在这个时候，播<br>放器的音乐停了，跳广场舞的大妈也停下了舞蹈，刚好看到了这一幕。<br>复制代码<br>这里我明显用了音乐停顿这个细节，通过增加句子，放慢了追逐的节奏，好拉长这个悬念时刻。</p><p>第二，让句子有不同的视角。<br>举个例子来说明，比如我们描写一个战争场面，一群人战胜了敌人，然后往村里运送战利品。我想，大多数人会写：</p><pre><code>这条路曲折泥泞，距离村子三公里多，刚结束战斗的人们运送着战利品沿着它往村里走去，边走还边流着血。</code></pre><p>这是一个以“人”作为视角来组织的句式。但如果我们想打破常规，让它有不同的视角，怎么办呢？就是把原句中的某一点拎出来，作为一个新视角来完成句式。比如，我们把边走边流着血这句里的“血”放在前面来写，写出来就是这样的：</p><pre><code>血滴一直延伸到村子里，足足有三公里多，滴血的路径也是人们运送战利品的路径，曲折泥泞。</code></pre><p>感受出来差别了吗？把“血滴”作为主视角，这么做基于两点：</p><p>一是让句子有变化，打破常规；<br>二是用血滴恰好能体现战斗的残酷和胜利的来之不易。</p><h2 id="有效修改：文章反复推敲的诀窍"><a href="#有效修改：文章反复推敲的诀窍" class="headerlink" title="有效修改：文章反复推敲的诀窍"></a>有效修改：文章反复推敲的诀窍</h2><h3 id="先增后减"><a href="#先增后减" class="headerlink" title="先增后减"></a>先增后减</h3><p>我们先说第一步，内容的修改。这一步的基本方法是先增后减。<br>首先就是快速阅读你的文章，看看文章中有哪些地方需要补充，没解释清楚的地方要补上去。比如，概念是否清晰，是否遗漏了细节等等。接着再做减法，看看是否有表意重复、是否有冗余，然后把它删掉。以上这些都是比较简单的。实操过程中，很多写作者也把更多的修改时间放在了这些细微之处。而我想提醒的是，既然已进入到最终的修改了，我们的着眼点就不能只停留于此，还需要跳出来从宏观上把握整篇内容。正所谓“不识庐山真面目，只缘身在此山中”。<br>从宏观上我们要看什么呢？我的答案是：叙述距离。它其实是指故事叙述者，也就是作者所处的一个位置，也叫心理距离。这本书提出了这样一个观点：写作者有时很难意识到，他在描述一个人或者一件事情的时候，其实已经选择了一个叙述距离。<br>这个概念说起来也很简单。这就好比我们拍视频，往往会下意识地变换拍摄距离，一会特写，一会远景，这是拍摄的技巧。但写作又不太一样，因为即便你始终在用一个距离来描述一件事情，也能写出文章来。最典型的就是议论文的写作。比如说，我们谈时间的重要性。可能先抛出一个论点，时间是有限的，我们要在有限的人生增加时间的厚度。很多人都会用到举例的方式。比如用岳飞，39 岁命丧风波亭，他的生命极为短暂，但他少年时便刺下“精忠报国”，写下“还我河山”，高唱着“莫等闲，白了少年头，空悲切”，短暂的生命绽放到了极致。同样地，我们还可以再举例。霍去病，20 多岁就年华早逝，却始终有着“匈奴未灭，何以家为”的抱负。简单来讲，就像上面举的岳飞、霍去病的例子，我们始终都是用一种“居高临下”或者说“审视”的距离去描述一件事。如果始终保持这样的叙述距离，我们当然也能写出一篇文章，但当我们修改的时候，其实也就一带而过了，不觉得有什么。而这样的文章弊端很明显，读者很难深入下去，为了论证而去论证的一些例子，难以打动人。<br>那对于这类文章的修改，我的经验就是：修改时，先按照前面说的先增后减原则，完成第一次修改。<br>接下来，要做的就是重新审视文章的叙述距离，它主要包含这两个方面：<br>文章里有没有特定的内部视角，也就是说你在描写一件事情的时候，假设你在不在现场；<br>文章里有没有概述性视角，也就是说作者是否在场景之上、故事之外？<br>比如上面那个例子，我们在用岳飞、霍去病举例的时候，我们都是习惯性地使用概述性视角，去点评别人的一生，却缺乏这些人物的内部视角。其实两种视角也代表了文章最重要的两个功能：<br>一是呈现，这就需要我们通过内部视角一层一层地剥离出来，让读者方便阅读；<br>二是表达，这就需要我们有一个概述性视角，把文章的意义表达给读者。<br>我们的文章如果始终在内部视角，那读者肯定就窥见不了全貌。修改的时候跳出文章，看它整体的叙述距离，要保证写作者自身既在事件之中，也在事件之外。</p><h3 id="论据处理的技巧"><a href="#论据处理的技巧" class="headerlink" title="论据处理的技巧"></a>论据处理的技巧</h3><p>接着说第二步，论据的修改。要讲述某件事情，在讲述的过程中，我们就会有价值判断。那你为什么要持这种价值判断呢？就是因为有相应的论据。论据是否得当，决定了你这篇文章是否言之有物、言之有理、言之有据。每次写完文章，都重新去看文章所用的论据是否能得出结论。特别是出处介绍和解释说明性的材料要重点关注，是否啰嗦、模糊不清，如果是，就需要重新打造。<br>那么，一篇文章中一般会有哪几种论据类型呢？常见的有以下 3 种：<br>第一，事实论据，像我们前面讲的在文章中引用岳飞、霍去病的例子，就属于这一类型。这种论据的形成，通常来源于我们的生活和历史。<br>第二，道理论据，最常见的就是名人名言、俗语了。<br>第三，数据论据<br>明白了论据类型，下一个问题就是怎么修改论据。<br>首先，论据是否恰当。<br>比如，要写一个女孩不畏挫折最终成功的故事，有人就会用一些案例来刻画。</p><pre><code>这个女孩喜欢打篮球，想进入市级篮球队，因一次考试表现不理想而遭到训斥，老师都说她不适合打篮球，但她就是“不信邪”，没有被挫折吓到，最终通过努力，终于进了市级篮球队。</code></pre><p>初看，可能会觉得没什么问题。但你仔细想想，体育不同于其它项目，很讲究天资，她都被老师认定不合适了，但努力后却又考进去了。这个大概率要么就是老师看错了，要么就是她考试时因紧张或者身体原因没有发挥好。换句话说，她最终是否考进去和没有被挫折吓到，无法建立起强相关关系。这样的论据，我就建议你不要用，因为经不起推敲。<br>其次，聊聊数据论据。<br>这种论据在文章中出现的频次是很高的。对写作者来说，数据是一把双刃剑，一方面它让结论更具说服力，另一方面它可能会枯燥，甚至没有意义。<br>第一，用平均数来代替一些大的数据。我假设一个例子，2018 年全国破获的刑事案件15.8 万起。当你把数据这样写出来，读者其实是没有概念的，但是你换个说法，2018 年全国平均每天破获的刑事案件就超过 400 起。数字变小了，也变得更形象了，更能引起人的注意。<br>第二，提供一些参照物来解释数据。比如在一篇讨论洪水泛滥的文章中，必须用到一个数据，短短两天，这里的进水量就达到了 24 亿立方米。这是一个很抽象的数据对不对？但是当我们把它换一个说法，这么大的水量足够让整个杭州拥有一百七十多个西湖。这个数字不但变得容易理解，也变得更加生动了。<br>第三，当数据多的时候，会显得拥挤，记得换一种表述。比如，2019 年，某某县经济发展较快，其财政年收入从 2018 年的 20 亿增长到 29.96 亿，增幅达到 49.8%。这种写法，数字出现太多，不够简练。我们稍微改下，效果会好些：过去一年里，某某县的财政收入增加了将近一半，达到了 29.96 亿。</p><p>接着，引用不恰当论据得出的观点，我们也称之为论证错误。<br>显然，这里我没法一个个讲写作中可能出现的论证错误，真的太多了。这里，推荐一本书，是哲学博士陈波写的《逻辑学是什么》，这本书内容很全面，对我们的写作很<br>有帮助，可以避免我们在写作中出现逻辑谬误。<br>这里我就先举个“三段论”推理的例子，你简单了解一点。世界 500 强公司是大公司，微软是大公司，所以微软是世界 500 强公司。<br>这句话的结论正确，但论证方式显然是错误的，即便没有知识背书相信你也是可以判断出来的。理论上，这句话其实是犯了“中项两不周延”的错误。简单来说就是，没有出现在结论当中的“大公司”，我们称之为中项。这个中项在“世界 500 强公司是大公司”的这句话中，不周延，也就是说大公司中除了世界 500 强公司，也有可能有其他公司。同样，这个中项在“微软是大公司”这句话中也不周延，大公司除了微软，也还有其他公司。<br>更深一层，这里面还会涉及到大前提、小前提、周延这些概念知识，如果你很感兴趣的话，可以去看看我推荐的这本书《逻辑学是什么》。但对于我们日常写作来说，论证方式错误与否，通过一些简单的渠道就可以判断了，比如，你可以让身边的小伙伴帮忙看看，或者你也可以自己多琢磨琢磨，再细心一点，也就解决了。</p><h3 id="连贯性的修改"><a href="#连贯性的修改" class="headerlink" title="连贯性的修改"></a>连贯性的修改</h3><p>连贯性的修改。这是非常重要的一个点，因为它跟读者体验密切相关。想象一下，当你看到一篇文章有种磕磕绊绊的感觉，一点都不流畅，这是种什么体验？<br>那怎么改呢？分两个方面。<br>第一，寻找那些细小而多余的结构，找东西替换它或者删掉它。这个也很简单，比如“他感到自己被赋予了一种压力”，就直接写成“他感受到了压力”，显然这样的表述节省了文章的空间。<br>第二，看文章中每个部分之间的衔接。这个稍微复杂点，当一篇文章从一个部分发展到另一个部分的时候，常常会使用一些标志性的句子或段落，我们称之为路标。这些路标的目的和意义，一方面是为了过渡到下一层意思，另一方面是为了让作者停下叙事来传达意义，或者揭示下一部分的内容。</p><p>举一个做得很好的例子，一起来感受下。<br>林珊珊和杜强曾经写过一篇文章，叫《九号院的年轻人》，这篇文章描述的是，原国务院农村发展研究中心内一群改革者的群像。里面有这么一段：</p><pre><code>“那时的青年有伤感的、哀叹的、悲愤的、抗争的，也有批判的，杜老引导着一帮批判的年轻人走向建设……他破格培养，委以重任。”多年沉浮后，曾轰动一时的“最年轻副部长”翁永曦一语概括：“九号院的灵魂是杜润生，九号院的色彩是生龙活虎的年轻人。”年轻人如今已过天命之年，谈及九号院，都流露出纯真神态。财讯传媒总裁戴小京曾是其中一员，他强调自己只是边缘角色。我问他，“农研室毕竟是官办组织，在 1980 年代理想主义氛围里，你的身份认同是什么？”“改革者。”他很肯定。“改革者”后来散落各方。2002 年，杜润生 90 岁生日，在曾经起草一号文件的京西宾馆，他们再次相聚。</code></pre><p>看的过程中，你应该已经注意到了，每一个部分之间的衔接度是非常高的。上一段的结尾几乎就是下一段的开头。例如，“九号院的色彩是生龙活虎的年轻人”是上一段的结尾，下一段的开头是“年轻人如今已过天命之年”，自然而然地带出了后一部分。同理，下面的“改革者”这段也起到了同样的作用。<br>这种技巧类似于修辞手法中的顶真，在写作中当我们想要保持文章的连贯性，或者强调意义时，通常会拿出来用用。比如上面所说的年轻人、改革者，都是作者有意为之，用来强调主题意义的。<br>这时你可能就要问了，是不是每个部分间的衔接都要用顶真呢？当然不是，这个需要因时而变、因势而变。<br>比如你前面在写农村因为观念束缚，变化缓慢，接下来要写有关城市变化的故事了。我们就可以换个方式过渡。</p><pre><code>“漩涡之外的城市，由于开放的观念、开阔的眼界，市民已经开始行动起来了。”</code></pre><p>我们分析一下。首先，为什么要用“漩涡”这个词语，因为变化就会产生旋涡。和农村相比，城市的优势是什么，观念开放、眼界开阔，同样我就把这两个概述性的词语用到了过渡句中。这样乡村和城市的对比也就变得鲜明起来。更重要的是，这句话其实是在提醒读者：接下来，我要讲开放的观念对市民造成了什么影响，以及他们是怎么行动的了。<br>有些小伙伴在写作中，常常是为了过渡而过渡。这里，再举一个设立路标不成功的例子。比如我们写一篇解释文章谈谈糖分对人体的影响。前面部分谈的是，糖分带给人的快乐，下一部分谈糖分摄入过多的危害。同样，我虚构一段，你感受下：</p><pre><code>张明还沉浸在糖分带给他的快乐之中。是的，当我们食用甜食时，大脑的奖励系统——多巴胺会被激活，会给心理带来极大的满足感。然而，糖分除了给人带来快乐外，其他人，包括张明在内，都承认摄入过多糖分会带来问题。对于那些经常食用高糖食物的人，即使在不饿的时候，他们对零食的渴望程度也更高。换言之，高糖食物可能会增强食欲，从而形成恶性循环，使人越来越沉迷于它的诱惑。</code></pre><p>这两段话里的路标：然而，糖分除了给人带来快乐外，其他人，包括张明在内，都承认摄入过多糖分会带来问题。<br>这个过渡其实是不成功的，为什么呢？两个理由：<br>第一，它提示的只是一个读者早就知道的知识；<br>第二，“问题”这个词很抽象，并不能很好地建构出意义。<br>这个路标的作用就不明显，我们要么更改下，要么删掉它。就这个例子而言，我倾向于删掉，因为太简单，读者一看就明白，根本不需要刻意去过渡。改一下：</p><pre><code>张明还沉浸在糖分带给他的快乐之中。是的，当我们食用甜食时，大脑的奖励系统——多巴胺会被激活，会给心理带来极大的满足感。在糖分的影响下，其他人，包括张明在内，都可能会对零食产生更高的渴望度，即便在不饿的时候。因为高糖食物可能会增强人的食欲，从而形成恶性循环。</code></pre><h1 id="写作应用"><a href="#写作应用" class="headerlink" title="写作应用"></a>写作应用</h1><h2 id="软文"><a href="#软文" class="headerlink" title="软文"></a>软文</h2><p>从定义上来说，软文就是软性宣传的文字，精妙之处就是那个“软”字，在用户没有受到强制宣传的情况下，文章和推广内容完美结合，从而达到广泛宣传的效果。<br>作为产品推广的一个重要营销手段，最近几年，软文营销这种方式已经越来越为用户所关注，尤其是原创文章、原创视频。另一方面，用户对软文营销也越来越习惯，如果植入得巧妙，就丝毫不会引起反感。甚至，我们还能在评论、弹幕中看到用户打趣道“恰饭时刻到了”。<br>软文不是指那种一看就是推广的文章，比如《史上卖得最疯狂、N 次断货的女装》，再比如“双十一”购物节上，各平台推出的购物软文等等，而是分享那些和品牌建设、人物包装等联系紧密的文章。简单来说，就是看起来不那么像软文的软文。</p><h3 id="寻找人物的识别标志"><a href="#寻找人物的识别标志" class="headerlink" title="寻找人物的识别标志"></a>寻找人物的识别标志</h3><p>先说第一个领域，人物类软文。要写好这一类型的软文，实际上是要解决两个问题：</p><ol><li>怎么塑造人物？</li><li>怎么在塑造过程中夹带“私货”？</li></ol><h4 id="塑造人物"><a href="#塑造人物" class="headerlink" title="塑造人物"></a>塑造人物</h4><p>我们从第一个问题开始解决。事实上，对任何人来说，塑造复杂人物在任何体裁中都属难事。新手们常会犯这样的错误，试图通过对周边环境的细节描写，来塑造纸上的人物形象。但是，很少有用户真的会关心人物周边的环境，除非它有显著的意义。单纯的描述是无意义的，如果你不了解你笔下的人物，就难以理解这些环境细节对他意味着什么。<br>换句话说，我们在写人物的时候，其实是在寻找人物意义，只有能解释人物意义的信息才可以帮助用户理解人物。去寻找这些人物意义的信息必然会花很多时间吧？这种想法其实是错误的。你想象下，平常你也许只需要花 5-10 秒就可以辨认出是周杰伦的歌曲，这是因为他的音乐自带识别标志。人物同样如此，你只需要截取一小片，得到这个人性格的一些片段，这就已经足够了。这个片段就是人物的识别标志。<br>人物的识别标志包含什么呢？</p><ul><li>情节，也就是已经发生的行为，用户喜欢看在这个特定情节中人物发生了什么。</li><li>反应，在这种特定情节下，人物的思考和应对分别是什么。</li></ul><p>就人物软文而言，因为我们的写作目的是确定的，就是要褒扬这个人物，树立起他的正面形象。所以，我们的情节选择是要围绕这个目的来的。显然，这种情节的类型基本相似，你要做的就是去寻找他是如何战胜挫折、困难的桥段，或者在遇到不公、冷嘲热讽时，他的应对。原因也很简单，用户喜欢冲突性强的情节，其次用户会在这些片段中看到自己的影子，因为这些情节他们多半也会遇到。</p><ul><li>第一种，欲扬先抑。先贬低后褒扬，这样我们就可以看到人物的成长。<ul><li>举个例子，热播剧《隐秘而伟大》，豆瓣评分 8.3，由李易峰领衔主演。假设你现在接了一单活，要为李易峰写篇人物软文。那么，欲扬先抑的这种方法就非常适合。我们只需要考虑用什么样的情节来把他烘托出来就行了。比如，我们可以按照这样的方式写：你知道李易峰在豆瓣上一共有多少部作品吗？73 部。这 73 部中，评分最高的就是这部《隐秘而伟大》。在这部剧播出之前，坦白讲，我对李易峰饰演的这部谍战剧不抱期待。原因是，以前他是如何如何的。</li></ul></li><li>第二种方法，为人物抱不平。比如这个人物明明可以火的，但是因为各种原因火不了了，从而激发大家的同情心.<ul><li>最近上映的电影《风平浪静》里的男主章宇，我们就可以定这样一个主题：章宇离影帝有多远？再比如倪虹洁，《武林外传》中的祝无双，同样也适用这一方法，也可以定类似主题：倪虹洁上微博热搜，阅读量超过 2 亿，这一次她可以火吗？</li></ul></li></ul><h4 id="夹带“私货”"><a href="#夹带“私货”" class="headerlink" title="夹带“私货”"></a>夹带“私货”</h4><p>该怎么神不知鬼不觉地在塑造过程中夹带“私货”呢？明写事暗写人。<br>还是说倪虹洁吧。<br>第一步，我们就要确定明写的事是什么。显然，热点事件是最好的切入口。那写倪虹洁，我们就可以借助《演员请就位》这部现阶段处在顶流的综艺节目。<br>第二步，寻找这件事里面最能产生冲突的东西。那就是节目里的市场评级了，最高级 S级，最低 B 级。在这个节目里，一些完全没有代表作品的男团演员都可能是 S 级，有代表作品的倪虹洁、马苏等人却是 B 级。我们就可以把这个放大，具体写写怎么回事，为什么会这样。写的时候要注意，你要让用户觉得我们是在讨论“这个分级制是否合理”。<br>第三步，我们的主人公倪虹洁该出场了，为她抱不平。<br>略写几段：</p><pre><code>一片争议声中，《演员请就位》迎来了第二季。节目里，演员们被知名制片人评为 S、A、B 三个级别。其中，S 级意味着演技纯熟、角色匹配度高、知名度高。（带热点事件）在节目里，荣获飞天、金鹰、华鼎三料视后的马苏被评为 B 级，也曾问鼎华鼎奖最佳女主角的唐一菲也是 B 级。而在她们对面，坐着多位男团成员，他们没有代表作，甚至还是演员圈的新手，却跻身 S 级的行列中。（找到事件中的冲突点）对马苏、唐一菲她们来说，观众似乎更欣赏她们的演技。但对演员而言，市场要求的不仅仅是演技，观众熟悉度、市场流量也是衡量他们市场价值的指标。有代表角色，但是不红，没有知名度，让她们在市场评级中只能屈居 B 级。（放大冲突点，你还可以进一步讨论下这个分级制是否合理。）和马苏、唐一菲一起坐上 B 级“冷板凳”的还有倪虹洁。或许，这个名字对你来说很陌生，但只要一提到祝无双，那位在《武林外传》中大喊“放着我来”的女捕头就已立马浮现在脑海中。（暗度陈仓，主人公登场）接下来，我们就可以写她被评为 B 级的尴尬，她的苦闷，她的过去，以及她在这个节目中，从 B 级晋升到 A 级的故事。</code></pre><p>这种方式方法，我们为某部电影做软文宣传的时候也可以采用，这个“暗写人”也可以是别的你想宣传的对象。比如，我们还是以《隐秘而伟大》这部剧举例，这是一部谍战剧。那说到国产谍战剧，你<br>会想到什么呢？《潜伏》嘛，所谓潜伏之后再无谍战。因此，把这部剧和潜伏对标，进行分析，是能起到比较好的宣传效果的。</p><h3 id="将品牌嵌入故事"><a href="#将品牌嵌入故事" class="headerlink" title="将品牌嵌入故事"></a>将品牌嵌入故事</h3><p>接下来说说推广企业品牌的软文写法。<br>我们先来看亚当斯密在《国富论》里的一段话：“我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出于他们自利的打算。我们不要求助于他们的爱心，只要求助于他们的自爱心。我们不要向他们说我们必需，只说他们有利。”<br>其实，这种观点同样提醒了我们。我们写软文的目的，不是要强求用户理解公司品牌的盈利必需，而是要告诉他们，公司的品牌对用户是有利的。那怎么让用户感觉到这种好处呢？我觉得存在这样两个维度：</p><ol><li>这个品牌有用；</li><li>这个品牌倡导的价值很好。</li></ol><p>就如同面包师做的面包，一是食物对人有用，二是这个食物好吃。只有明白了用户的需求，我们才能“对症下药”。所以，我们看到的企业品牌软文，基本上都是按照这两个维度来操作的。<br>怎么通过文章让用户觉得企业产品对他是有利的呢？</p><h4 id="品牌有用"><a href="#品牌有用" class="headerlink" title="品牌有用"></a>品牌有用</h4><p>第一个维度，让用户觉得这个品牌有用。<br>那最好的方法是什么呢？举例子。特别是举那些大家熟悉的例子，但是我们在向用户讲熟悉的例子的时候，要加些用户不知道的佐料进去<br>比如六神磊磊读金庸里有篇恰饭文《黄蓉：谁稀罕当一辈子少女》。<br>作者先抛出了一个观点：黄蓉很多东西她都怕，偏不怕老。女生们难免都想一直当少女，好像黄蓉并不大稀罕总当少女。为什么她不大稀罕总当少女，因为她在美丽、好看这件事上特自信。无论是十八岁、三十岁还是生了娃以后，她都好看。<br>为了把黄蓉这种自信体现得更为淋漓尽致，作者就开始对比了，他是这样写的：</p><pre><code>在江湖上，“第一美女”是更新迭代很快的，基本上几年一个周期，不比今天娱乐圈慢。小花一茬一茬地冒出来，黄蓉之后出了美女高手李莫愁，之后更是有小龙女。可是黄蓉从来没有真正被比下去过。</code></pre><p>为什么呢？因为她一直都“风致嫣然”。作者总结出了她的 3 个特点：自信，绝不放弃美好，每一个阶段都活出每个阶段的美丽。<br>这样，前面的铺垫也就完成了。接下来就是过渡到品牌了。我们学习下作者的过渡：</p><pre><code>（黄蓉）当了帮主，一忙起来就蓬头垢面，不行。像少女时那样完全仗着先天资本扛打，早晚一只叫花鸡，水也不补，该修复的也不修复，那也不行。早先的美往往靠天赋，后来的美要靠坚持和细节。</code></pre><p>潜台词就是，后来的美靠什么呢？靠某某品牌嘛，品牌就这样被带出来了。这种方法很简单，但我要提醒你，掌握这种方法的关键是，我们得让这篇软文有核心重点。上面这篇的核心重点就是黄蓉的自信、对美好的追求，而这些都是我们共同的人性。</p><h4 id="品牌倡导的价值很好"><a href="#品牌倡导的价值很好" class="headerlink" title="品牌倡导的价值很好"></a>品牌倡导的价值很好</h4><p>再说说第二个维度，让用户觉得这个品牌倡导的价值很好。最基本的方法就是讲故事，把这个品牌嵌入到故事当中。<br>比如，某短视频邀约写篇品牌软文。<br>第一，需要他们提供年轻人的案例。因为短视频的目标用户群体，主要就是年轻人。<br>第二，这个案例必须是关于年轻人焦虑的故事。因为说到 2020 年最火的词汇，那大概率是“内卷”。所谓“内卷”，简单来说就等同于“无论怎么努力，都无法实现进步”。从外卖员的辛苦到打工人的自嘲，人人可卷，万物可卷。<br>第三，这位焦虑的年轻人，必须突破焦虑。道理也很简单，因为如果没有突破，就无法把短视频这个品牌的价值植入进去</p><p>接下来要考虑的就是：在这个故事中，怎么体现这个短视频品牌的价值<br>思考过程是这样的：短视频，其实是一种记录自我的方式。要写的这个短视频平台本质上是提供给了一位普通人展示自己的舞台。所谓内卷，卷还是不卷，关键是能否寻找到清晰的自我价值。<br>从几个案例中挑了一个，就是一位在城市里找不到方向的年轻人，焦虑、失眠，一次偶然的机会，回到乡村，接触了村里的贫困户，真心想要帮助他们，于是决定留在乡村创业的故事。创业过程中，他遭遇困难、失望，却慢慢调整，最终事业慢慢走上正轨。<br>在提这个平台之前，可以先列个路标：<br>这个互联网时代，最有趣的地方之一，就是那些被算法选中的人、场、景，在某个特定时刻被改变了命运。<br>然后把品牌放进去：<br>真正的转机出现在 2019 年 6 月。他那不见起色的某短视频账号，因为一段悬崖边采药的视频，吸粉无数。视频里，如何如何。<br>接着把证据拿出来：<br>现实数据有力地佐证了这一判断：2018 年下半年，通过某短视频的方式，他卖了多少药材、销售了多少水果，增收了多少钱。在偏远的村落，被“闲置”的互联网重新有了生长的新生力量。<br>最后抬价值：<br>前面我讲了，短视频是提供给普通人展现自我价值的舞台。根据这点，我们就可以在结尾发散下。</p><pre><code>“苔花如米小，也学牡丹开”。原来，他一直觉得，那些在农田里看上去极为普通的幼苗，可怜无力，任何一次外界力量的袭来，都会让它彻底失去未来。这就如同他曾在大城市里播下的梦。但他现在发现，那些曾被认为可笑、天真的梦，依然值得被记录。只不过，它要先往下，往脚下伸展开去，等待一个生长的机会。你看，一篇营销软文就这样套路般地轻松完成了。</code></pre><h2 id="如何完成一篇出彩的演讲稿？"><a href="#如何完成一篇出彩的演讲稿？" class="headerlink" title="如何完成一篇出彩的演讲稿？"></a>如何完成一篇出彩的演讲稿？</h2><h3 id="演讲主题"><a href="#演讲主题" class="headerlink" title="演讲主题"></a>演讲主题</h3><p>演讲往往是命题作文。那我们的演讲稿用什么来作为主题呢？<br>最近年轻人最火的一个词，一定是内卷。人应该怎么避免被内卷化？这实在是一个伤脑筋的问题。假设，你接到了一个任务，请你以“内卷”作为主题，自找角度，写一篇 2500 字左右的简单演讲稿。<br>现在，我们就从头出发，分 4 步来完成这篇演讲稿吧。</p><h4 id="第一步：寻找切入口"><a href="#第一步：寻找切入口" class="headerlink" title="第一步：寻找切入口"></a>第一步：寻找切入口</h4><p>写演讲稿需要思考的第一件事，就是怎么让一个空泛的主题落地生根。比如，在当前的语境下，内卷是人人可卷，事事可卷，但我们总不能毫无重点地去谈论这个词吧，总得有个切入口。那怎么寻找这个切入口呢？我的方法是：落实到个体生命上去。你想想看，对听众而言，没有人喜欢那些大的、高的、虚的、喊口号式的东西，他们想听到的是平易近人，与他们的生活紧密相连的内容。所以，我们选择的切入点一定是要与个体的生命体验有关。你可能会有疑问了，演讲不是要升华吗？当然是的，但一定是从身边事的体悟中去升华，而不是凭空升华，否则，就只会让人觉得演讲人做作。现实生活中，我们为何会经常性地反感一些宏大的写作命题？其实就是因为我们很难找到切入口。这个时候，你要记着我上面说的，你得把自己融进去，写自己经历的人和事。比如，在每年国庆的时候，总有朋友问我，你看看这个演讲题目“为祖国骄傲”多空泛啊，该怎么写？我说，你要把祖国具象化，把它们变成一件件具体的事，一个个具体的人。这样演讲的题目就不再是为祖国骄傲，而是为某个人或者某件事背后的精神骄傲。写年度总结也是这样的。你认真想想，什么才能打动人？一定是一个人独特的生命体验。因为只有体验了，时光才不会虚度，体验了，这些感受才会属于你，你才能因此而创建出属于你自己的生活，进而把它拿出来分享。根据这一点，我们可以有这样一个头脑风暴的过程：如果我们把内卷当作大的时代环境，我们发现自己是无法改变的，因为它是一个系统，你无力与之抗争。唯一能做的是什么呢？还是得从自己出发，从改变自身出发。你管不了别人，但可以先改变自己。<br>那要改变自己，首先我们得知道改变什么。这就涉及到另一个问题，什么才是最重要的个人价值。这下我们的切入口就找到了，题目也就出来了，那我的题目就是：《“内卷”时代，自我如何应对？》。有了题目，我们就可以用“一句话法则”来确定主线：明白了什么是最重要的个人价值，才能知道自己要改变什么，坚守什么，从而抵抗内卷所带来的无奈和焦虑。</p><h4 id="第二步：建立框架，寻找论据"><a href="#第二步：建立框架，寻找论据" class="headerlink" title="第二步：建立框架，寻找论据"></a>第二步：建立框架，寻找论据</h4><p>现在切入口和主线我们都找到了，接下来要做的就是建立框架。怎么建立框架呢？具体来说，三段式就是：是什么、为什么、怎么办。确定了之后，我们要做的就是把相应的观点和论据放进去。就我们确定的演讲题目而言，这个三段式分别是这样的。<br>是什么：“内卷”，那什么是内卷？它的具体表现在哪里？<br>为什么：为什么会出现内卷？在我看来，是因为在各个领域，特别是 21 世纪以来，互联网、金融和房地产这三驾拉动经济的马车都在不同程度上遭受着瓶颈，增长乏力。如果这个蛋糕足够大，即便在分配不均的情况下，很多人还是可以分到一杯羹的，但现在很多人都分不到了。所以我认为，内卷的根本原因是因为新经济增长乏力。<br>怎么办：当经济乏力的时候，我们都知道得推动经济发展。那经济发展的原因是什么？找到了原因，我们就能对症下药了。<br>对演讲稿来说哪些论据很重要。</p><ul><li>要讲故事、有例子<ul><li>道理很简单，没有人不喜欢听故事。就像大家都知道苹果砸了牛顿的故事，但不一定知道牛顿三大定律。故事可以是别人，也可以是自己的。我的建议是，一篇演讲稿中不能都是别人的故事，得有自己的经历。首先就是它可以打动人，离听众不那么遥远；其次是因为自己亲历的故事可以有独特的内部视角。另外，请记住我在方法篇中讲过的，写故事得有细节和画面感。</li></ul></li><li>要有数据<ul><li>数据常常给人一种真实的感受，在具体论证某个观点的时候，如果能用上一种数据，就会显得格调很高。</li></ul></li><li>要有名人出场<ul><li>虽然我们常说，不能迷信权威，但要知道任何组织的形成、管治、支配均建构于某种特定的权威之上，适当的权威是能够消除混乱、带来秩序的。演讲也不例外，我们需要让名人为我们的观点背书，他是能够让听众接受的。不过，需要提醒你的是，我们已不再是中小学生了，在引用名人名言的时候，不要再引用那些司空见惯的话语。</li></ul></li></ul><h4 id="第三步：谋划开头，关注叙事节奏"><a href="#第三步：谋划开头，关注叙事节奏" class="headerlink" title="第三步：谋划开头，关注叙事节奏"></a>第三步：谋划开头，关注叙事节奏</h4><p>在完成第二步以后，基本框架就出来了，接下来要做的是写开头。<br>演讲稿的开头，不像写故事的开头要求那么高。它更为看重的是，你能否在第一时间拉近和听众的距离。我记得我原来在高校工作的时候，指导学生写演讲稿，我会给他们布置一个任务，去看 TED 的讲演视频，去总结他们开头的模式，你也可以试试。演讲稿的开头主要就是这样两种。</p><p>设置悬念，直接给出一个问题。</p><ul><li>比如有一个名为《没睡好的人，脑子里都是垃圾》的 TED 视频，他的开头就是这样的：睡眠，占用了我们一生三分之一的时间，但是真正有人知道它到底是怎么回事吗？</li></ul><p>讲一个小的故事，引人入胜</p><ul><li>比如在《20 岁光阴不再来》这个 TED 视频中，他的开头就是如此：我 20 多岁的时候，见了我第一位心理诊疗的客户。那时，我是伯克利大学临床心理学的博士生，一名 26 岁的女士，名叫亚里克斯，第一次诊疗时，亚里克斯穿着牛仔裤和宽大松垮的上衣走进我的办公室，坐在沙发上，踢掉高跟鞋，然后告诉我她要谈谈男人问题。听到这，我松了一口气，因为我同学的第一个客户是一个纵火犯……<br>用故事作为开头，一是要确保这个故事足够有趣，二是这个故事不要太长，而且讲完后最好点下题，否则听众不知道你想表达什么。</li></ul><p>说完开头，我们就得聊聊叙事节奏了。你可能会好奇，我为什么要把叙事节奏单独拿出来说。这是因为不同于书面写作，演讲稿是要讲出来给别人听的，所以节奏更为重要。节奏可以带动听众的情绪，可以调节听众的注意力。在演讲稿的撰写中，有一种技巧很重要，那就是记得使用段子，也就是要学会开玩笑。适当的开玩笑，既是调节现场气氛的有效手段，也是让演讲稿内容产生变化感的方式之一。</p><h4 id="第四步：成文"><a href="#第四步：成文" class="headerlink" title="第四步：成文"></a>第四步：成文</h4><p>接下来，把前三步做的准备投入到演讲稿的写作中，写成文章即可。</p><h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><h4 id="话题-1：演讲稿一定要有“逼格”"><a href="#话题-1：演讲稿一定要有“逼格”" class="headerlink" title="话题 1：演讲稿一定要有“逼格”"></a>话题 1：演讲稿一定要有“逼格”</h4><p>罗永浩有句话是这样说的：“观众不讨厌装逼，讨厌的是装逼装得不好；观众不讨厌吹牛逼，讨厌的是牛逼吹得不好。”所谓逼格，主要体现在两方面，一是词语使用有逼格，二是使用的名人名言有逼格。比<br>如，不要说“让我们分析一件事”，而是“让我们把这件事解构”，不要讲“据说”，而要说“相关证据表明”。使用的名人名言有逼格，在演讲稿中用到的部分名人尽量不是大众所熟知的。</p><h4 id="话题-2：演讲稿一定要有金句"><a href="#话题-2：演讲稿一定要有金句" class="headerlink" title="话题 2：演讲稿一定要有金句"></a>话题 2：演讲稿一定要有金句</h4><p>所谓金句，就是那些高大上的话，要力透纸背。怎么写呢？首先，要特别注意押韵，这样才会朗朗上口，容易传播；其次，你得给人启发。<br>比如，我在演讲稿中写的“它让我明白了，独立、自由、权利不用来争取的话，它就是一张废纸”；再比如“有时候，你还得去撞南墙，撞得头破血流了，你才有感受，你的思维才不会那么僵化”。</p><h2 id="如何用心讲好一个故事？"><a href="#如何用心讲好一个故事？" class="headerlink" title="如何用心讲好一个故事？"></a>如何用心讲好一个故事？</h2><p>所谓人的记忆，所谓历史，这些空朦苍茫的字词，其实就是位白发苍苍的老妇人给围坐在一起的孩子讲故事。这些故事，无论时代怎么变迁，它都能够存活下去，从年长者传给年轻人，从上一代传给下一代。可以说，我们每个人都是在故事中长大成人的。著名专栏作家亚历克斯蒂松曾在回答问题“为什么人类需要故事”时，他是这样说的：“没有故事，所有发生了的事情都会四处飘散，彼此之间毫无差别，没有任何东西会有任何意义。但是，一旦发生了的事情有了某种故事，所有其他跟人之为人有关系的好东西也就会出现。你会笑，会敬畏，会充满情绪地去行动，会被激怒，会想去让什么东西改变。”</p><h3 id="寻找好故事"><a href="#寻找好故事" class="headerlink" title="寻找好故事"></a>寻找好故事</h3><p>在日常生活中，我们似乎总能听到这样的对话，一个人对另一个人说，你要学会讲故事；而另一人耷拉着脑袋说，我连故事都找不到，怎么写，只能编。<br>首先，我们得明白什么是故事，就是大家每天的生活中会遇到的各种事情，比如看了一部电影，见了一个朋友，吃了一顿美食等等。但我们还得学会筛选，故事就是从这些事情当中挑选出来的精华部分。简单来说，就是把故事元素和其它材料分离，并把它们组织起来形成意义。而意义才是故事的本质。比如说，我们每天都会在街上看到外卖小哥闯红灯、逆行，这是再平常不过的小事了，就像很多人每天都要去上班一样普通。那故事是什么呢？是从这些小事中，挑选出来的精华部分，形成的意义。那意义是怎么找到的呢？有两种方法。</p><h4 id="推断法"><a href="#推断法" class="headerlink" title="推断法"></a>推断法</h4><p>这是一种向外辐射型的思维模式，这种方法比较适合于一些习以为常的小事。既然习以为常，也就是这件事本身不足以构成一个故事，因为太常见、太普通了，但是我们可以通过追问，去推断这个具体事件背后，是有更大的故事的。<br>比如，《外卖骑手，困在系统里》这篇文章就使用了这样的方法。这篇文章对闯红灯这个事情进行追问，为什么他们要闯红灯呢？背后的原因是什么？他们是主动的还是被动的？有了这个追问，我们寻找答案的过程，也就是搭建意义的过程了。<br>实际上，很多细小的情节，就发生在我们天天走过的大街上，但是我们往往因为太过熟悉而变得迟钝，错过了那些精彩的亮点。</p><h4 id="综合法"><a href="#综合法" class="headerlink" title="综合法"></a>综合法</h4><p>这是一种向内联系型的思维模式，这种方法比较适合于我们手头上有些成堆的小故事，看似没什么联系，但是我们可以通过组装的方式，去努力挖掘它们之间的联系，可能就会发现一个新的好故事。这就有点像推理破案，从蛛丝马迹中还原真相。比如，内地某省出台了鼓励老人就业、创业的政策，我们已知这是其中一个小故事。第二个故事，大量年轻劳动力前往沿海。第三个故事，中国新生儿出生率持续降低。<br>这些小故事看似没有关系，但这些都共同指向一个目标，中国在经历 30 多年人口红利后，很多地方开始面临老龄化比率过快增长的问题。这个时候，你就可以把故事锁定在老龄化问题上，去寻找相应的故事。</p><p>推断法和综合法是寻找故事的法宝。有没有更简单的方法呢？当然有，那就是改变角度西班牙的悬疑电影《看不见的客人》，整部影片针对同一件事，不停地转换叙事角度，通过不同的人说出来，故事完全就变了一个样。而更为具体的找故事也就是找主题的方法。</p><h3 id="搭建故事结构"><a href="#搭建故事结构" class="headerlink" title="搭建故事结构"></a>搭建故事结构</h3><p>找到好故事以后，我们接着搭建故事的结构。就某一个类型的东西关注比较多的时候，你一定要去刻意培养归纳的习惯。就好比故事，当你看多了，就会发现所有的故事都有这样三个层次：</p><ol><li>叙事，也就是发生了什么事；</li><li>人物对事件的感受和应对，如果一个写作者成功让读者用故事里的人物视角来观看事物，那人物和读者的感情也就合二为一了；</li><li>组合，把不同的元素组合起来，用以唤起故事的普遍意义，比如爱恨情仇、成长、生死等等。如果我们把故事放到显微镜下去观看，你会发现绝大多数故事的基本结构为：</li><li>最初的平衡状态；</li><li>平衡被一些行为所打破；</li><li>人物对平衡被打破的认知；</li><li>人物为修复平衡所做的努力；</li><li>平衡的修复或者失败。</li></ol><p>现在我们把故事结构进一步放大，拿到高倍显微镜下去看，你会发现，这些结构下有的是不同的角色。这里，我们可以借鉴俄罗斯民俗学家弗拉基米尔·普罗普的观点。他认为民间故事有许多共性，可以把这些共性加以归纳得出一些角色，这些角色都有相应的功能。</p><h3 id="把故事写精彩"><a href="#把故事写精彩" class="headerlink" title="把故事写精彩"></a>把故事写精彩</h3><p>两个写故事的技巧。</p><h4 id="要有对话"><a href="#要有对话" class="headerlink" title="要有对话"></a>要有对话</h4><p>比起直接叙述，对话更容易让读者有阅读的兴趣，因为这就是我们平日里沟通的方式，我们最为熟悉。另外，为了还原故事的本来状态，我们会让人物充分发声，从而起到塑造人物或者推动情节发展的效果。<br>何伟老师写的《寻路中国》比如，他写浙江丽水的老板搬迁的时候，想带两个熟练的女工走，而去和这两个女工的父亲老陶谈判的过程，作者抓住了双方的利益分歧，作者不厌其烦地引用两人的对话，而不是从老板或者父亲的视角单方面叙述，这种描写效果出奇得好。援引几段：</p><pre><code>“你跟不跟我们一起走？”王老板问道。“不走！”老陶回答道，“我儿子要在这儿上学，我们走不开。再说，我们还有生意要做。”“到了那边，如果你要做生意，可以照常做生意。”“你说得轻巧。”老陶说，“我们在这儿生意做得好好的。”王老板来的时候，我正在跟老陶聊天。老陶这个人很随和，也很幽默。可现在呢，他的身体语言完全变了个样：背挺得直直的，头抬得高高的，下巴向前挺出去。王老板还想再试下。“我得留在这儿，我要照看我的儿子呀。”老陶说。“那么，你的两个女儿要跟我们走吧。”实际上这才是王老板的如意算盘：把那两姐妹带走，让老陶留在这里。可老陶的反应也很快。“她们俩单独去是不行的。”他说，“她们还很年轻。”······</code></pre><p>通过这样的对话，寥寥数语，就把老陶协商时强硬的形象立了起来<br>那什么时候可以使用对话这种技巧呢？<br>首先，当故事需要喘息的时候，用对话可以放慢节奏，等等读者的脚步，等他进入到故事当中；其次，使用的对话能突出反映人物性格的时候。<br>再举个例子，这是虚构的一段经历，和一个抑郁症女孩相爱的故事。</p><pre><code>女主人公她得了抑郁症。那个时候，她还不知道我的名字。她也不知道，每一年的年会，看她在上面表演都是我最快乐的时候。看她在台上跳爵士舞，开同事的玩笑，戏谑生活琐事。台下的观众吹哨、鼓掌、叫好。而我竟没有任何动作，痴痴地看着她。后来，我在公司的食堂见到她，远远看着，气色不是很好，我为她担忧。但她似乎不认识我，我也害羞不愿上前询问。再见她时，已是某个下午。我坐在电脑旁，突然她走到我的面前，穿着一身黑色的裙子。“咦。”我很惊喜，“你找谁？”“找你。”她坐下了，就在我对面，“我得了抑郁症……”她很坦然，神色没有一点变化，“我听同事说，你认识这方面的医生。”她继续说，“能给我介绍吗？”我错愕地居然忘记了回话，半晌，点了点头。</code></pre><p>在这个例子中，我先是写了她的开朗、多才多艺，这是为接下来抑郁症的反转做铺垫。然后，使用了对话。其实，你应该也感受到了，通过对话，我是把这位直率、真诚的女性形象给塑造出来了，这比单纯反复地使用修饰词，效果好多了。</p><h4 id="将故事和观念融合"><a href="#将故事和观念融合" class="headerlink" title="将故事和观念融合"></a>将故事和观念融合</h4><p>我们既是一个故事的叙述者，也是一个故事的解读者。最重要的方法，是写作者对材料要有着强大的掌控力。这种掌控力主要来源于两个方面，广泛的阅读以及恰如其分的分类。怎么把这种掌控力体现在具体的故事写作中。要回答这个问题，<br>我们就要明白文章中解读材料的组成部分。在我看来，它是由漫笔、背景和说明组成，往往出现在对主要人物进行评价的时候，或者主要人物作出影响故事方向的决定时刻。<br>举个《哈佛非虚构写作课》中的一个例子:</p><pre><code>杰西卡才 11 岁。自从五年级，她就知道她在自己的葬礼上要穿什么。“我觉得我的舞会礼服是所有衣服中最漂亮的”，杰茜卡说，“我死后，我希望爸爸妈妈给我穿得美美的。”在过去的 5 年间，哥伦比亚特区有 224 名 18 岁以下的孩子被杀害，有的被当作枪击目标，有的只是旁观者。在枪火下生活的孩子如杰西卡，和一些离枪火比较远的孩子，已经理解了什么叫屠杀。当他们掌握了任天堂游戏、花样跳绳和长除法（long division），一些孩子已经对自己周围的环境作出了判断，知道了死亡几乎近在咫尺。所以，像杰西卡一样，他们已经开始安排自己的葬礼了。</code></pre><p>在作背景介绍的时候，我们可以通过提供不同类型论据的方式，让解读变得有趣。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写作原理&quot;&gt;&lt;a href=&quot;#写作原理&quot; class=&quot;headerlink&quot; title=&quot;写作原理&quot;&gt;&lt;/a&gt;写作原理&lt;/h1&gt;&lt;p&gt;对于一棵树来说，根系越发达，吸收的养分就越多。那阅读也是一样的，经典作品就好比树根，可以触及无数人已经筛选好的最佳养分。那谈</summary>
      
    
    
    
    <category term="others" scheme="http://example.com/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>香槟塔</title>
    <link href="http://example.com/p/52292.html"/>
    <id>http://example.com/p/52292.html</id>
    <published>2023-12-28T06:18:52.771Z</published>
    <updated>2023-08-04T10:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><pre><code>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</code></pre><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，</p><h3 id="输入用例"><a href="#输入用例" class="headerlink" title="输入用例"></a>输入用例</h3><p>示例 1:</p><pre><code>输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.00000解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</code></pre><p>示例 2:</p><pre><code>输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.50000解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</code></pre><p>示例 3:</p><pre><code>输入: poured = 100000009, query_row = 33, query_glass = 17输出: 1.00000</code></pre><p>提示：</p><pre><code>0 &lt;= poured &lt;= 1090 &lt;= query_glass &lt;= query_row &lt; 100</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>本弱鸡一直在纠结是不是数学问题，暴力的话poured是不是够用，每层减少对应数目，但是最后还是算不出来，最终也没有做出来。贴一个官方题解。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>class Solution &#123;</code></pre><p>public:<br>    double champagneTower(int poured, int query_row, int query_glass) {<br>        vector<double> row &#x3D; {(double)poured};<br>        for (int i &#x3D; 1; i &lt;&#x3D; query_row; i++) {<br>            vector<double> nextRow(i + 1, 0.0);<br>            for (int j &#x3D; 0; j &lt; row.size(); j++) {<br>                double volume &#x3D; row[j];<br>                if (volume &gt; 1) {<br>                    nextRow[j] +&#x3D; (volume - 1) &#x2F; 2;<br>                    nextRow[j + 1] +&#x3D; (volume - 1) &#x2F; 2;<br>                }<br>            }<br>            row &#x3D; nextRow;<br>        }<br>        return min(1.0, row[query_glass]);<br>    }<br>};</double></double></p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/">https://leetcode.cn/problems/champagne-tower/solution/xiang-bin-ta-by-leetcode-solution-y87c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
